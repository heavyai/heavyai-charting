/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/assets/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 230);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {//! moment.js
//! version : 2.13.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
     true ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, function () { 'use strict';

    var hookCallback;

    function utils_hooks__hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            m._isValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                m._isValid = m._isValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid (flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    function isUndefined(input) {
        return input === void 0;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (utils_hooks__hooks.deprecationHandler != null) {
                utils_hooks__hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (utils_hooks__hooks.deprecationHandler != null) {
            utils_hooks__hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;
    utils_hooks__hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function isObject(input) {
        return Object.prototype.toString.call(input) === '[object Object]';
    }

    function locale_set__set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    // internal storage for locale config files
    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                __webpack_require__(142)("./" + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = locale_locales__getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale');
                config = mergeConfigs(locales[name]._config, config);
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    config = mergeConfigs(locales[config.parentLocale]._config, config);
                } else {
                    // treat as if there is no base config
                    deprecateSimple('parentLocaleUndefined',
                            'specified parentLocale is not defined yet');
                }
            }
            locales[name] = new Locale(config);

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale;
            if (locales[name] != null) {
                config = mergeConfigs(locales[name]._config, config);
            }
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function locale_locales__getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function locale_locales__listLocales() {
        return keys(locales);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function get_set__set (mom, unit, value) {
        if (mom.isValid()) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    // MOMENTS

    function getSet (units, value) {
        var unit;
        if (typeof units === 'object') {
            for (unit in units) {
                this.set(unit, units[unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        return isArray(this._months) ? this._months[m.month()] :
            this._months[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function units_month__handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = create_utc__createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return units_month__handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (typeof value !== 'number') {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    function createDate (y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));

        //the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(utils_hooks__hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    utils_hooks__hooks.ISO_8601 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (getParsingFlags(config).bigHour === true &&
                config._a[HOUR] <= 12 &&
                config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else if (isDate(input)) {
            config._d = input;
        } else {
            configFromInput(config);
        }

        if (!valid__isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date(utils_hooks__hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function local__createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
         'moment().min is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
         function () {
             var other = local__createLocal.apply(null, arguments);
             if (this.isValid() && other.isValid()) {
                 return other < this ? this : other;
             } else {
                 return valid__createInvalid();
             }
         }
     );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
        function () {
            var other = local__createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return valid__createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = ((string || '').match(matcher) || []);
        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
            } else if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            this.utcOffset(offsetFromString(matchOffset, this._i));
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? local__createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?\d*)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

    function create__createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])        * sign,
                h  : toInt(match[HOUR])        * sign,
                m  : toInt(match[MINUTE])      * sign,
                s  : toInt(match[SECOND])      * sign,
                ms : toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add      = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function moment_calendar__calendar (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            diff = this.diff(sod, 'days', true),
            format = diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format]() : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input,units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input,units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            delta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString () {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if (isFunction(Date.prototype.toISOString)) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }

        // 'date' is an alias for 'day', so it should be considered as such.
        if (units === 'date') {
            units = 'day';
        }

        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return this._offset ? new Date(this.valueOf()) : this._d;
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function moment_valid__isValid () {
        return valid__isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        return isArray(this._weekdays) ? this._weekdays[m.day()] :
            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return this._weekdaysShort[m.day()];
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return this._weekdaysMin[m.day()];
    }

    function day_of_week__handleStrictParse(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = create_utc__createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = create_utc__createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.
        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add               = add_subtract__add;
    momentPrototype__proto.calendar          = moment_calendar__calendar;
    momentPrototype__proto.clone             = clone;
    momentPrototype__proto.diff              = diff;
    momentPrototype__proto.endOf             = endOf;
    momentPrototype__proto.format            = format;
    momentPrototype__proto.from              = from;
    momentPrototype__proto.fromNow           = fromNow;
    momentPrototype__proto.to                = to;
    momentPrototype__proto.toNow             = toNow;
    momentPrototype__proto.get               = getSet;
    momentPrototype__proto.invalidAt         = invalidAt;
    momentPrototype__proto.isAfter           = isAfter;
    momentPrototype__proto.isBefore          = isBefore;
    momentPrototype__proto.isBetween         = isBetween;
    momentPrototype__proto.isSame            = isSame;
    momentPrototype__proto.isSameOrAfter     = isSameOrAfter;
    momentPrototype__proto.isSameOrBefore    = isSameOrBefore;
    momentPrototype__proto.isValid           = moment_valid__isValid;
    momentPrototype__proto.lang              = lang;
    momentPrototype__proto.locale            = locale;
    momentPrototype__proto.localeData        = localeData;
    momentPrototype__proto.max               = prototypeMax;
    momentPrototype__proto.min               = prototypeMin;
    momentPrototype__proto.parsingFlags      = parsingFlags;
    momentPrototype__proto.set               = getSet;
    momentPrototype__proto.startOf           = startOf;
    momentPrototype__proto.subtract          = add_subtract__subtract;
    momentPrototype__proto.toArray           = toArray;
    momentPrototype__proto.toObject          = toObject;
    momentPrototype__proto.toDate            = toDate;
    momentPrototype__proto.toISOString       = moment_format__toISOString;
    momentPrototype__proto.toJSON            = toJSON;
    momentPrototype__proto.toString          = toString;
    momentPrototype__proto.unix              = unix;
    momentPrototype__proto.valueOf           = to_type__valueOf;
    momentPrototype__proto.creationData      = creationData;

    // Year
    momentPrototype__proto.year       = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear    = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month       = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
    momentPrototype__proto.weeksInYear    = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date       = getSetDayOfMonth;
    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset            = getSetOffset;
    momentPrototype__proto.utc                  = setOffsetToUTC;
    momentPrototype__proto.local                = setOffsetToLocal;
    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST                = isDaylightSavingTime;
    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
    momentPrototype__proto.isLocal              = isLocal;
    momentPrototype__proto.isUtcOffset          = isUtcOffset;
    momentPrototype__proto.isUtc                = isUtc;
    momentPrototype__proto.isUTC                = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);

    var momentPrototype = momentPrototype__proto;

    function moment__createUnix (input) {
        return local__createLocal(input * 1000);
    }

    function moment__createInZone () {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function locale_calendar__calendar (key, mom, now) {
        var output = this._calendar[key];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    function preParsePostFormat (string) {
        return string;
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var prototype__proto = Locale.prototype;

    prototype__proto._calendar       = defaultCalendar;
    prototype__proto.calendar        = locale_calendar__calendar;
    prototype__proto._longDateFormat = defaultLongDateFormat;
    prototype__proto.longDateFormat  = longDateFormat;
    prototype__proto._invalidDate    = defaultInvalidDate;
    prototype__proto.invalidDate     = invalidDate;
    prototype__proto._ordinal        = defaultOrdinal;
    prototype__proto.ordinal         = ordinal;
    prototype__proto._ordinalParse   = defaultOrdinalParse;
    prototype__proto.preparse        = preParsePostFormat;
    prototype__proto.postformat      = preParsePostFormat;
    prototype__proto._relativeTime   = defaultRelativeTime;
    prototype__proto.relativeTime    = relative__relativeTime;
    prototype__proto.pastFuture      = pastFuture;
    prototype__proto.set             = locale_set__set;

    // Month
    prototype__proto.months            =        localeMonths;
    prototype__proto._months           = defaultLocaleMonths;
    prototype__proto.monthsShort       =        localeMonthsShort;
    prototype__proto._monthsShort      = defaultLocaleMonthsShort;
    prototype__proto.monthsParse       =        localeMonthsParse;
    prototype__proto._monthsRegex      = defaultMonthsRegex;
    prototype__proto.monthsRegex       = monthsRegex;
    prototype__proto._monthsShortRegex = defaultMonthsShortRegex;
    prototype__proto.monthsShortRegex  = monthsShortRegex;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto._week = defaultLocaleWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays       =        localeWeekdays;
    prototype__proto._weekdays      = defaultLocaleWeekdays;
    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

    prototype__proto._weekdaysRegex      = defaultWeekdaysRegex;
    prototype__proto.weekdaysRegex       =        weekdaysRegex;
    prototype__proto._weekdaysShortRegex = defaultWeekdaysShortRegex;
    prototype__proto.weekdaysShortRegex  =        weekdaysShortRegex;
    prototype__proto._weekdaysMinRegex   = defaultWeekdaysMinRegex;
    prototype__proto.weekdaysMinRegex    =        weekdaysMinRegex;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get (format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = lists__get(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = locale_locales__getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return lists__get(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = lists__get(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function lists__listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function lists__listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function lists__listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function lists__listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function lists__listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract (duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf () {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function duration_get__get (units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function () {
            return this._data[name];
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45,  // seconds to minute
        m: 45,  // minutes to hour
        h: 22,  // hours to day
        d: 26,  // days to month
        M: 11   // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds]  ||
                minutes <= 1           && ['m']           ||
                minutes < thresholds.m && ['mm', minutes] ||
                hours   <= 1           && ['h']           ||
                hours   < thresholds.h && ['hh', hours]   ||
                days    <= 1           && ['d']           ||
                days    < thresholds.d && ['dd', days]    ||
                months  <= 1           && ['M']           ||
                months  < thresholds.M && ['MM', months]  ||
                years   <= 1           && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize (withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days         = iso_string__abs(this._days);
        var months       = iso_string__abs(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs            = duration_abs__abs;
    duration_prototype__proto.add            = duration_add_subtract__add;
    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
    duration_prototype__proto.as             = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds      = asSeconds;
    duration_prototype__proto.asMinutes      = asMinutes;
    duration_prototype__proto.asHours        = asHours;
    duration_prototype__proto.asDays         = asDays;
    duration_prototype__proto.asWeeks        = asWeeks;
    duration_prototype__proto.asMonths       = asMonths;
    duration_prototype__proto.asYears        = asYears;
    duration_prototype__proto.valueOf        = duration_as__valueOf;
    duration_prototype__proto._bubble        = bubble;
    duration_prototype__proto.get            = duration_get__get;
    duration_prototype__proto.milliseconds   = milliseconds;
    duration_prototype__proto.seconds        = seconds;
    duration_prototype__proto.minutes        = minutes;
    duration_prototype__proto.hours          = hours;
    duration_prototype__proto.days           = days;
    duration_prototype__proto.weeks          = weeks;
    duration_prototype__proto.months         = months;
    duration_prototype__proto.years          = years;
    duration_prototype__proto.humanize       = humanize;
    duration_prototype__proto.toISOString    = iso_string__toISOString;
    duration_prototype__proto.toString       = iso_string__toISOString;
    duration_prototype__proto.toJSON         = iso_string__toISOString;
    duration_prototype__proto.locale         = locale;
    duration_prototype__proto.localeData     = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    utils_hooks__hooks.version = '2.13.0';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn                    = momentPrototype;
    utils_hooks__hooks.min                   = min;
    utils_hooks__hooks.max                   = max;
    utils_hooks__hooks.now                   = now;
    utils_hooks__hooks.utc                   = create_utc__createUTC;
    utils_hooks__hooks.unix                  = moment__createUnix;
    utils_hooks__hooks.months                = lists__listMonths;
    utils_hooks__hooks.isDate                = isDate;
    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid               = valid__createInvalid;
    utils_hooks__hooks.duration              = create__createDuration;
    utils_hooks__hooks.isMoment              = isMoment;
    utils_hooks__hooks.weekdays              = lists__listWeekdays;
    utils_hooks__hooks.parseZone             = moment__createInZone;
    utils_hooks__hooks.localeData            = locale_locales__getLocale;
    utils_hooks__hooks.isDuration            = isDuration;
    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale          = defineLocale;
    utils_hooks__hooks.updateLocale          = updateLocale;
    utils_hooks__hooks.locales               = locale_locales__listLocales;
    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
    utils_hooks__hooks.prototype             = momentPrototype;

    var _moment = utils_hooks__hooks;

    return _moment;

}));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(141)(module)))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;!function() {
  var d3 = {
    version: "3.5.17"
  };
  var d3_arraySlice = [].slice, d3_array = function(list) {
    return d3_arraySlice.call(list);
  };
  var d3_document = this.document;
  function d3_documentElement(node) {
    return node && (node.ownerDocument || node.document || node).documentElement;
  }
  function d3_window(node) {
    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
  }
  if (d3_document) {
    try {
      d3_array(d3_document.documentElement.childNodes)[0].nodeType;
    } catch (e) {
      d3_array = function(list) {
        var i = list.length, array = new Array(i);
        while (i--) array[i] = list[i];
        return array;
      };
    }
  }
  if (!Date.now) Date.now = function() {
    return +new Date();
  };
  if (d3_document) {
    try {
      d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
    } catch (error) {
      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
      d3_element_prototype.setAttribute = function(name, value) {
        d3_element_setAttribute.call(this, name, value + "");
      };
      d3_element_prototype.setAttributeNS = function(space, local, value) {
        d3_element_setAttributeNS.call(this, space, local, value + "");
      };
      d3_style_prototype.setProperty = function(name, value, priority) {
        d3_style_setProperty.call(this, name, value + "", priority);
      };
    }
  }
  d3.ascending = d3_ascending;
  function d3_ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }
  d3.descending = function(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  };
  d3.min = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
    }
    return a;
  };
  d3.max = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
    }
    return a;
  };
  d3.extent = function(array, f) {
    var i = -1, n = array.length, a, b, c;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }
    return [ a, c ];
  };
  function d3_number(x) {
    return x === null ? NaN : +x;
  }
  function d3_numeric(x) {
    return !isNaN(x);
  }
  d3.sum = function(array, f) {
    var s = 0, n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = +array[i])) s += a;
    } else {
      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
    }
    return s;
  };
  d3.mean = function(array, f) {
    var s = 0, n = array.length, a, i = -1, j = n;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
    }
    if (j) return s / j;
  };
  d3.quantile = function(values, p) {
    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
    return e ? v + e * (values[h] - v) : v;
  };
  d3.median = function(array, f) {
    var numbers = [], n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
    }
    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
  };
  d3.variance = function(array, f) {
    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
    if (arguments.length === 1) {
      while (++i < n) {
        if (d3_numeric(a = d3_number(array[i]))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    } else {
      while (++i < n) {
        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    }
    if (j > 1) return s / (j - 1);
  };
  d3.deviation = function() {
    var v = d3.variance.apply(this, arguments);
    return v ? Math.sqrt(v) : v;
  };
  function d3_bisector(compare) {
    return {
      left: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
        }
        return lo;
      }
    };
  }
  var d3_bisect = d3_bisector(d3_ascending);
  d3.bisectLeft = d3_bisect.left;
  d3.bisect = d3.bisectRight = d3_bisect.right;
  d3.bisector = function(f) {
    return d3_bisector(f.length === 1 ? function(d, x) {
      return d3_ascending(f(d), x);
    } : f);
  };
  d3.shuffle = function(array, i0, i1) {
    if ((m = arguments.length) < 3) {
      i1 = array.length;
      if (m < 2) i0 = 0;
    }
    var m = i1 - i0, t, i;
    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
    }
    return array;
  };
  d3.permute = function(array, indexes) {
    var i = indexes.length, permutes = new Array(i);
    while (i--) permutes[i] = array[indexes[i]];
    return permutes;
  };
  d3.pairs = function(array) {
    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
    return pairs;
  };
  d3.transpose = function(matrix) {
    if (!(n = matrix.length)) return [];
    for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) {
      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) {
        row[j] = matrix[j][i];
      }
    }
    return transpose;
  };
  function d3_transposeLength(d) {
    return d.length;
  }
  d3.zip = function() {
    return d3.transpose(arguments);
  };
  d3.keys = function(map) {
    var keys = [];
    for (var key in map) keys.push(key);
    return keys;
  };
  d3.values = function(map) {
    var values = [];
    for (var key in map) values.push(map[key]);
    return values;
  };
  d3.entries = function(map) {
    var entries = [];
    for (var key in map) entries.push({
      key: key,
      value: map[key]
    });
    return entries;
  };
  d3.merge = function(arrays) {
    var n = arrays.length, m, i = -1, j = 0, merged, array;
    while (++i < n) j += arrays[i].length;
    merged = new Array(j);
    while (--n >= 0) {
      array = arrays[n];
      m = array.length;
      while (--m >= 0) {
        merged[--j] = array[m];
      }
    }
    return merged;
  };
  var abs = Math.abs;
  d3.range = function(start, stop, step) {
    if (arguments.length < 3) {
      step = 1;
      if (arguments.length < 2) {
        stop = start;
        start = 0;
      }
    }
    if ((stop - start) / step === Infinity) throw new Error("infinite range");
    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
    start *= k, stop *= k, step *= k;
    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
    return range;
  };
  function d3_range_integerScale(x) {
    var k = 1;
    while (x * k % 1) k *= 10;
    return k;
  }
  function d3_class(ctor, properties) {
    for (var key in properties) {
      Object.defineProperty(ctor.prototype, key, {
        value: properties[key],
        enumerable: false
      });
    }
  }
  d3.map = function(object, f) {
    var map = new d3_Map();
    if (object instanceof d3_Map) {
      object.forEach(function(key, value) {
        map.set(key, value);
      });
    } else if (Array.isArray(object)) {
      var i = -1, n = object.length, o;
      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
    } else {
      for (var key in object) map.set(key, object[key]);
    }
    return map;
  };
  function d3_Map() {
    this._ = Object.create(null);
  }
  var d3_map_proto = "__proto__", d3_map_zero = "\x00";
  d3_class(d3_Map, {
    has: d3_map_has,
    get: function(key) {
      return this._[d3_map_escape(key)];
    },
    set: function(key, value) {
      return this._[d3_map_escape(key)] = value;
    },
    remove: d3_map_remove,
    keys: d3_map_keys,
    values: function() {
      var values = [];
      for (var key in this._) values.push(this._[key]);
      return values;
    },
    entries: function() {
      var entries = [];
      for (var key in this._) entries.push({
        key: d3_map_unescape(key),
        value: this._[key]
      });
      return entries;
    },
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
    }
  });
  function d3_map_escape(key) {
    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
  }
  function d3_map_unescape(key) {
    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
  }
  function d3_map_has(key) {
    return d3_map_escape(key) in this._;
  }
  function d3_map_remove(key) {
    return (key = d3_map_escape(key)) in this._ && delete this._[key];
  }
  function d3_map_keys() {
    var keys = [];
    for (var key in this._) keys.push(d3_map_unescape(key));
    return keys;
  }
  function d3_map_size() {
    var size = 0;
    for (var key in this._) ++size;
    return size;
  }
  function d3_map_empty() {
    for (var key in this._) return false;
    return true;
  }
  d3.nest = function() {
    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
    function map(mapType, array, depth) {
      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
          values.push(object);
        } else {
          valuesByKey.set(keyValue, [ object ]);
        }
      }
      if (mapType) {
        object = mapType();
        setter = function(keyValue, values) {
          object.set(keyValue, map(mapType, values, depth));
        };
      } else {
        object = {};
        setter = function(keyValue, values) {
          object[keyValue] = map(mapType, values, depth);
        };
      }
      valuesByKey.forEach(setter);
      return object;
    }
    function entries(map, depth) {
      if (depth >= keys.length) return map;
      var array = [], sortKey = sortKeys[depth++];
      map.forEach(function(key, keyMap) {
        array.push({
          key: key,
          values: entries(keyMap, depth)
        });
      });
      return sortKey ? array.sort(function(a, b) {
        return sortKey(a.key, b.key);
      }) : array;
    }
    nest.map = function(array, mapType) {
      return map(mapType, array, 0);
    };
    nest.entries = function(array) {
      return entries(map(d3.map, array, 0), 0);
    };
    nest.key = function(d) {
      keys.push(d);
      return nest;
    };
    nest.sortKeys = function(order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    };
    nest.sortValues = function(order) {
      sortValues = order;
      return nest;
    };
    nest.rollup = function(f) {
      rollup = f;
      return nest;
    };
    return nest;
  };
  d3.set = function(array) {
    var set = new d3_Set();
    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
    return set;
  };
  function d3_Set() {
    this._ = Object.create(null);
  }
  d3_class(d3_Set, {
    has: d3_map_has,
    add: function(key) {
      this._[d3_map_escape(key += "")] = true;
      return key;
    },
    remove: d3_map_remove,
    values: d3_map_keys,
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key));
    }
  });
  d3.behavior = {};
  function d3_identity(d) {
    return d;
  }
  d3.rebind = function(target, source) {
    var i = 1, n = arguments.length, method;
    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
    return target;
  };
  function d3_rebind(target, source, method) {
    return function() {
      var value = method.apply(source, arguments);
      return value === source ? target : value;
    };
  }
  function d3_vendorSymbol(object, name) {
    if (name in object) return name;
    name = name.charAt(0).toUpperCase() + name.slice(1);
    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
      var prefixName = d3_vendorPrefixes[i] + name;
      if (prefixName in object) return prefixName;
    }
  }
  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
  function d3_noop() {}
  d3.dispatch = function() {
    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    return dispatch;
  };
  function d3_dispatch() {}
  d3_dispatch.prototype.on = function(type, listener) {
    var i = type.indexOf("."), name = "";
    if (i >= 0) {
      name = type.slice(i + 1);
      type = type.slice(0, i);
    }
    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
    if (arguments.length === 2) {
      if (listener == null) for (type in this) {
        if (this.hasOwnProperty(type)) this[type].on(name, null);
      }
      return this;
    }
  };
  function d3_dispatch_event(dispatch) {
    var listeners = [], listenerByName = new d3_Map();
    function event() {
      var z = listeners, i = -1, n = z.length, l;
      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
      return dispatch;
    }
    event.on = function(name, listener) {
      var l = listenerByName.get(name), i;
      if (arguments.length < 2) return l && l.on;
      if (l) {
        l.on = null;
        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
        listenerByName.remove(name);
      }
      if (listener) listeners.push(listenerByName.set(name, {
        on: listener
      }));
      return dispatch;
    };
    return event;
  }
  d3.event = null;
  function d3_eventPreventDefault() {
    d3.event.preventDefault();
  }
  function d3_eventSource() {
    var e = d3.event, s;
    while (s = e.sourceEvent) e = s;
    return e;
  }
  function d3_eventDispatch(target) {
    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    dispatch.of = function(thiz, argumentz) {
      return function(e1) {
        try {
          var e0 = e1.sourceEvent = d3.event;
          e1.target = target;
          d3.event = e1;
          dispatch[e1.type].apply(thiz, argumentz);
        } finally {
          d3.event = e0;
        }
      };
    };
    return dispatch;
  }
  d3.requote = function(s) {
    return s.replace(d3_requote_re, "\\$&");
  };
  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
  var d3_subclass = {}.__proto__ ? function(object, prototype) {
    object.__proto__ = prototype;
  } : function(object, prototype) {
    for (var property in prototype) object[property] = prototype[property];
  };
  function d3_selection(groups) {
    d3_subclass(groups, d3_selectionPrototype);
    return groups;
  }
  var d3_select = function(s, n) {
    return n.querySelector(s);
  }, d3_selectAll = function(s, n) {
    return n.querySelectorAll(s);
  }, d3_selectMatches = function(n, s) {
    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
    d3_selectMatches = function(n, s) {
      return d3_selectMatcher.call(n, s);
    };
    return d3_selectMatches(n, s);
  };
  if (typeof Sizzle === "function") {
    d3_select = function(s, n) {
      return Sizzle(s, n)[0] || null;
    };
    d3_selectAll = Sizzle;
    d3_selectMatches = Sizzle.matchesSelector;
  }
  d3.selection = function() {
    return d3.select(d3_document.documentElement);
  };
  var d3_selectionPrototype = d3.selection.prototype = [];
  d3_selectionPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, group, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selector(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_select(selector, this);
    };
  }
  d3_selectionPrototype.selectAll = function(selector) {
    var subgroups = [], subgroup, node;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
          subgroup.parentNode = node;
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selectorAll(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_selectAll(selector, this);
    };
  }
  var d3_nsXhtml = "http://www.w3.org/1999/xhtml";
  var d3_nsPrefix = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: d3_nsXhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  d3.ns = {
    prefix: d3_nsPrefix,
    qualify: function(name) {
      var i = name.indexOf(":"), prefix = name;
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return d3_nsPrefix.hasOwnProperty(prefix) ? {
        space: d3_nsPrefix[prefix],
        local: name
      } : name;
    }
  };
  d3_selectionPrototype.attr = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node();
        name = d3.ns.qualify(name);
        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
      }
      for (value in name) this.each(d3_selection_attr(value, name[value]));
      return this;
    }
    return this.each(d3_selection_attr(name, value));
  };
  function d3_selection_attr(name, value) {
    name = d3.ns.qualify(name);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrConstant() {
      this.setAttribute(name, value);
    }
    function attrConstantNS() {
      this.setAttributeNS(name.space, name.local, value);
    }
    function attrFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
    }
    function attrFunctionNS() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
    }
    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
  }
  function d3_collapse(s) {
    return s.trim().replace(/\s+/g, " ");
  }
  d3_selectionPrototype.classed = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
        if (value = node.classList) {
          while (++i < n) if (!value.contains(name[i])) return false;
        } else {
          value = node.getAttribute("class");
          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
        }
        return true;
      }
      for (value in name) this.each(d3_selection_classed(value, name[value]));
      return this;
    }
    return this.each(d3_selection_classed(name, value));
  };
  function d3_selection_classedRe(name) {
    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
  }
  function d3_selection_classes(name) {
    return (name + "").trim().split(/^|\s+/);
  }
  function d3_selection_classed(name, value) {
    name = d3_selection_classes(name).map(d3_selection_classedName);
    var n = name.length;
    function classedConstant() {
      var i = -1;
      while (++i < n) name[i](this, value);
    }
    function classedFunction() {
      var i = -1, x = value.apply(this, arguments);
      while (++i < n) name[i](this, x);
    }
    return typeof value === "function" ? classedFunction : classedConstant;
  }
  function d3_selection_classedName(name) {
    var re = d3_selection_classedRe(name);
    return function(node, value) {
      if (c = node.classList) return value ? c.add(name) : c.remove(name);
      var c = node.getAttribute("class") || "";
      if (value) {
        re.lastIndex = 0;
        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
      } else {
        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
      }
    };
  }
  d3_selectionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
        return this;
      }
      if (n < 2) {
        var node = this.node();
        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
      }
      priority = "";
    }
    return this.each(d3_selection_style(name, value, priority));
  };
  function d3_selection_style(name, value, priority) {
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleConstant() {
      this.style.setProperty(name, value, priority);
    }
    function styleFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
    }
    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
  }
  d3_selectionPrototype.property = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") return this.node()[name];
      for (value in name) this.each(d3_selection_property(value, name[value]));
      return this;
    }
    return this.each(d3_selection_property(name, value));
  };
  function d3_selection_property(name, value) {
    function propertyNull() {
      delete this[name];
    }
    function propertyConstant() {
      this[name] = value;
    }
    function propertyFunction() {
      var x = value.apply(this, arguments);
      if (x == null) delete this[name]; else this[name] = x;
    }
    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
  }
  d3_selectionPrototype.text = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    } : value == null ? function() {
      this.textContent = "";
    } : function() {
      this.textContent = value;
    }) : this.node().textContent;
  };
  d3_selectionPrototype.html = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    } : value == null ? function() {
      this.innerHTML = "";
    } : function() {
      this.innerHTML = value;
    }) : this.node().innerHTML;
  };
  d3_selectionPrototype.append = function(name) {
    name = d3_selection_creator(name);
    return this.select(function() {
      return this.appendChild(name.apply(this, arguments));
    });
  };
  function d3_selection_creator(name) {
    function create() {
      var document = this.ownerDocument, namespace = this.namespaceURI;
      return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);
    }
    function createNS() {
      return this.ownerDocument.createElementNS(name.space, name.local);
    }
    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
  }
  d3_selectionPrototype.insert = function(name, before) {
    name = d3_selection_creator(name);
    before = d3_selection_selector(before);
    return this.select(function() {
      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
    });
  };
  d3_selectionPrototype.remove = function() {
    return this.each(d3_selectionRemove);
  };
  function d3_selectionRemove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }
  d3_selectionPrototype.data = function(value, key) {
    var i = -1, n = this.length, group, node;
    if (!arguments.length) {
      value = new Array(n = (group = this[0]).length);
      while (++i < n) {
        if (node = group[i]) {
          value[i] = node.__data__;
        }
      }
      return value;
    }
    function bind(group, groupData) {
      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
      if (key) {
        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
        for (i = -1; ++i < n; ) {
          if (node = group[i]) {
            if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {
              exitNodes[i] = node;
            } else {
              nodeByKeyValue.set(keyValue, node);
            }
            keyValues[i] = keyValue;
          }
        }
        for (i = -1; ++i < m; ) {
          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          } else if (node !== true) {
            updateNodes[i] = node;
            node.__data__ = nodeData;
          }
          nodeByKeyValue.set(keyValue, true);
        }
        for (i = -1; ++i < n; ) {
          if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {
            exitNodes[i] = group[i];
          }
        }
      } else {
        for (i = -1; ++i < n0; ) {
          node = group[i];
          nodeData = groupData[i];
          if (node) {
            node.__data__ = nodeData;
            updateNodes[i] = node;
          } else {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
        }
        for (;i < m; ++i) {
          enterNodes[i] = d3_selection_dataNode(groupData[i]);
        }
        for (;i < n; ++i) {
          exitNodes[i] = group[i];
        }
      }
      enterNodes.update = updateNodes;
      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
      enter.push(enterNodes);
      update.push(updateNodes);
      exit.push(exitNodes);
    }
    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
    if (typeof value === "function") {
      while (++i < n) {
        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
      }
    } else {
      while (++i < n) {
        bind(group = this[i], value);
      }
    }
    update.enter = function() {
      return enter;
    };
    update.exit = function() {
      return exit;
    };
    return update;
  };
  function d3_selection_dataNode(data) {
    return {
      __data__: data
    };
  }
  d3_selectionPrototype.datum = function(value) {
    return arguments.length ? this.property("__data__", value) : this.property("__data__");
  };
  d3_selectionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_filter(selector) {
    return function() {
      return d3_selectMatches(this, selector);
    };
  }
  d3_selectionPrototype.order = function() {
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  };
  d3_selectionPrototype.sort = function(comparator) {
    comparator = d3_selection_sortComparator.apply(this, arguments);
    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
    return this.order();
  };
  function d3_selection_sortComparator(comparator) {
    if (!arguments.length) comparator = d3_ascending;
    return function(a, b) {
      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
    };
  }
  d3_selectionPrototype.each = function(callback) {
    return d3_selection_each(this, function(node, i, j) {
      callback.call(node, node.__data__, i, j);
    });
  };
  function d3_selection_each(groups, callback) {
    for (var j = 0, m = groups.length; j < m; j++) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
        if (node = group[i]) callback(node, i, j);
      }
    }
    return groups;
  }
  d3_selectionPrototype.call = function(callback) {
    var args = d3_array(arguments);
    callback.apply(args[0] = this, args);
    return this;
  };
  d3_selectionPrototype.empty = function() {
    return !this.node();
  };
  d3_selectionPrototype.node = function() {
    for (var j = 0, m = this.length; j < m; j++) {
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        var node = group[i];
        if (node) return node;
      }
    }
    return null;
  };
  d3_selectionPrototype.size = function() {
    var n = 0;
    d3_selection_each(this, function() {
      ++n;
    });
    return n;
  };
  function d3_selection_enter(selection) {
    d3_subclass(selection, d3_selection_enterPrototype);
    return selection;
  }
  var d3_selection_enterPrototype = [];
  d3.selection.enter = d3_selection_enter;
  d3.selection.enter.prototype = d3_selection_enterPrototype;
  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
  d3_selection_enterPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, upgroup, group, node;
    for (var j = -1, m = this.length; ++j < m; ) {
      upgroup = (group = this[j]).update;
      subgroups.push(subgroup = []);
      subgroup.parentNode = group.parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
          subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  d3_selection_enterPrototype.insert = function(name, before) {
    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
    return d3_selectionPrototype.insert.call(this, name, before);
  };
  function d3_selection_enterInsertBefore(enter) {
    var i0, j0;
    return function(d, i, j) {
      var group = enter[j].update, n = group.length, node;
      if (j != j0) j0 = j, i0 = 0;
      if (i >= i0) i0 = i + 1;
      while (!(node = group[i0]) && ++i0 < n) ;
      return node;
    };
  }
  d3.select = function(node) {
    var group;
    if (typeof node === "string") {
      group = [ d3_select(node, d3_document) ];
      group.parentNode = d3_document.documentElement;
    } else {
      group = [ node ];
      group.parentNode = d3_documentElement(node);
    }
    return d3_selection([ group ]);
  };
  d3.selectAll = function(nodes) {
    var group;
    if (typeof nodes === "string") {
      group = d3_array(d3_selectAll(nodes, d3_document));
      group.parentNode = d3_document.documentElement;
    } else {
      group = d3_array(nodes);
      group.parentNode = null;
    }
    return d3_selection([ group ]);
  };
  d3_selectionPrototype.on = function(type, listener, capture) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof type !== "string") {
        if (n < 2) listener = false;
        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
        return this;
      }
      if (n < 2) return (n = this.node()["__on" + type]) && n._;
      capture = false;
    }
    return this.each(d3_selection_on(type, listener, capture));
  };
  function d3_selection_on(type, listener, capture) {
    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
    if (i > 0) type = type.slice(0, i);
    var filter = d3_selection_onFilters.get(type);
    if (filter) type = filter, wrap = d3_selection_onFilter;
    function onRemove() {
      var l = this[name];
      if (l) {
        this.removeEventListener(type, l, l.$);
        delete this[name];
      }
    }
    function onAdd() {
      var l = wrap(listener, d3_array(arguments));
      onRemove.call(this);
      this.addEventListener(type, this[name] = l, l.$ = capture);
      l._ = listener;
    }
    function removeAll() {
      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
      for (var name in this) {
        if (match = name.match(re)) {
          var l = this[name];
          this.removeEventListener(match[1], l, l.$);
          delete this[name];
        }
      }
    }
    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
  }
  var d3_selection_onFilters = d3.map({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  });
  if (d3_document) {
    d3_selection_onFilters.forEach(function(k) {
      if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
    });
  }
  function d3_selection_onListener(listener, argumentz) {
    return function(e) {
      var o = d3.event;
      d3.event = e;
      argumentz[0] = this.__data__;
      try {
        listener.apply(this, argumentz);
      } finally {
        d3.event = o;
      }
    };
  }
  function d3_selection_onFilter(listener, argumentz) {
    var l = d3_selection_onListener(listener, argumentz);
    return function(e) {
      var target = this, related = e.relatedTarget;
      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
        l.call(target, e);
      }
    };
  }
  var d3_event_dragSelect, d3_event_dragId = 0;
  function d3_event_dragSuppress(node) {
    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
    if (d3_event_dragSelect == null) {
      d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
    }
    if (d3_event_dragSelect) {
      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
      style[d3_event_dragSelect] = "none";
    }
    return function(suppressClick) {
      w.on(name, null);
      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
      if (suppressClick) {
        var off = function() {
          w.on(click, null);
        };
        w.on(click, function() {
          d3_eventPreventDefault();
          off();
        }, true);
        setTimeout(off, 0);
      }
    };
  }
  d3.mouse = function(container) {
    return d3_mousePoint(container, d3_eventSource());
  };
  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
  function d3_mousePoint(container, e) {
    if (e.changedTouches) e = e.changedTouches[0];
    var svg = container.ownerSVGElement || container;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      if (d3_mouse_bug44083 < 0) {
        var window = d3_window(container);
        if (window.scrollX || window.scrollY) {
          svg = d3.select("body").append("svg").style({
            position: "absolute",
            top: 0,
            left: 0,
            margin: 0,
            padding: 0,
            border: "none"
          }, "important");
          var ctm = svg[0][0].getScreenCTM();
          d3_mouse_bug44083 = !(ctm.f || ctm.e);
          svg.remove();
        }
      }
      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
      point.y = e.clientY;
      point = point.matrixTransform(container.getScreenCTM().inverse());
      return [ point.x, point.y ];
    }
    var rect = container.getBoundingClientRect();
    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
  }
  d3.touch = function(container, touches, identifier) {
    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
      if ((touch = touches[i]).identifier === identifier) {
        return d3_mousePoint(container, touch);
      }
    }
  };
  d3.behavior.drag = function() {
    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
    function drag() {
      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
    }
    function dragstart(id, position, subject, move, end) {
      return function() {
        var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
        if (origin) {
          dragOffset = origin.apply(that, arguments);
          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
        } else {
          dragOffset = [ 0, 0 ];
        }
        dispatch({
          type: "dragstart"
        });
        function moved() {
          var position1 = position(parent, dragId), dx, dy;
          if (!position1) return;
          dx = position1[0] - position0[0];
          dy = position1[1] - position0[1];
          dragged |= dx | dy;
          position0 = position1;
          dispatch({
            type: "drag",
            x: position1[0] + dragOffset[0],
            y: position1[1] + dragOffset[1],
            dx: dx,
            dy: dy
          });
        }
        function ended() {
          if (!position(parent, dragId)) return;
          dragSubject.on(move + dragName, null).on(end + dragName, null);
          dragRestore(dragged);
          dispatch({
            type: "dragend"
          });
        }
      };
    }
    drag.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return drag;
    };
    return d3.rebind(drag, event, "on");
  };
  function d3_behavior_dragTouchId() {
    return d3.event.changedTouches[0].identifier;
  }
  d3.touches = function(container, touches) {
    if (arguments.length < 2) touches = d3_eventSource().touches;
    return touches ? d3_array(touches).map(function(touch) {
      var point = d3_mousePoint(container, touch);
      point.identifier = touch.identifier;
      return point;
    }) : [];
  };
  var  = 1e-6, 2 =  * ,  = Math.PI,  = 2 * ,  =  - , half =  / 2, d3_radians =  / 180, d3_degrees = 180 / ;
  function d3_sgn(x) {
    return x > 0 ? 1 : x < 0 ? -1 : 0;
  }
  function d3_cross2d(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
  }
  function d3_acos(x) {
    return x > 1 ? 0 : x < -1 ?  : Math.acos(x);
  }
  function d3_asin(x) {
    return x > 1 ? half : x < -1 ? -half : Math.asin(x);
  }
  function d3_sinh(x) {
    return ((x = Math.exp(x)) - 1 / x) / 2;
  }
  function d3_cosh(x) {
    return ((x = Math.exp(x)) + 1 / x) / 2;
  }
  function d3_tanh(x) {
    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
  }
  function d3_haversin(x) {
    return (x = Math.sin(x / 2)) * x;
  }
  var  = Math.SQRT2, 2 = 2, 4 = 4;
  d3.interpolateZoom = function(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < 2) {
      S = Math.log(w1 / w0) / ;
      i = function(t) {
        return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp( * t * S) ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + 4 * d2) / (2 * w0 * 2 * d1), b1 = (w1 * w1 - w0 * w0 - 4 * d2) / (2 * w1 * 2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / ;
      i = function(t) {
        var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (2 * d1) * (coshr0 * d3_tanh( * s + r0) - d3_sinh(r0));
        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh( * s + r0) ];
      };
    }
    i.duration = S * 1e3;
    return i;
  };
  d3.behavior.zoom = function() {
    var view = {
      x: 0,
      y: 0,
      k: 1
    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
    if (!d3_behavior_zoomWheel) {
      d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
      }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return d3.event.wheelDelta;
      }, "mousewheel") : (d3_behavior_zoomDelta = function() {
        return -d3.event.detail;
      }, "MozMousePixelScroll");
    }
    function zoom(g) {
      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
    }
    zoom.event = function(g) {
      g.each(function() {
        var dispatch = event.of(this, arguments), view1 = view;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.zoom", function() {
            view = this.__chart__ || {
              x: 0,
              y: 0,
              k: 1
            };
            zoomstarted(dispatch);
          }).tween("zoom:zoom", function() {
            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
            return function(t) {
              var l = i(t), k = dx / l[2];
              this.__chart__ = view = {
                x: cx - l[0] * k,
                y: cy - l[1] * k,
                k: k
              };
              zoomed(dispatch);
            };
          }).each("interrupt.zoom", function() {
            zoomended(dispatch);
          }).each("end.zoom", function() {
            zoomended(dispatch);
          });
        } else {
          this.__chart__ = view;
          zoomstarted(dispatch);
          zoomed(dispatch);
          zoomended(dispatch);
        }
      });
    };
    zoom.translate = function(_) {
      if (!arguments.length) return [ view.x, view.y ];
      view = {
        x: +_[0],
        y: +_[1],
        k: view.k
      };
      rescale();
      return zoom;
    };
    zoom.scale = function(_) {
      if (!arguments.length) return view.k;
      view = {
        x: view.x,
        y: view.y,
        k: null
      };
      scaleTo(+_);
      rescale();
      return zoom;
    };
    zoom.scaleExtent = function(_) {
      if (!arguments.length) return scaleExtent;
      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.center = function(_) {
      if (!arguments.length) return center;
      center = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.size = function(_) {
      if (!arguments.length) return size;
      size = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.duration = function(_) {
      if (!arguments.length) return duration;
      duration = +_;
      return zoom;
    };
    zoom.x = function(z) {
      if (!arguments.length) return x1;
      x1 = z;
      x0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    zoom.y = function(z) {
      if (!arguments.length) return y1;
      y1 = z;
      y0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    function location(p) {
      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
    }
    function point(l) {
      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
    }
    function scaleTo(s) {
      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
    }
    function translateTo(p, l) {
      l = point(l);
      view.x += p[0] - l[0];
      view.y += p[1] - l[1];
    }
    function zoomTo(that, p, l, k) {
      that.__chart__ = {
        x: view.x,
        y: view.y,
        k: view.k
      };
      scaleTo(Math.pow(2, k));
      translateTo(center0 = p, l);
      that = d3.select(that);
      if (duration > 0) that = that.transition().duration(duration);
      that.call(zoom.event);
    }
    function rescale() {
      if (x1) x1.domain(x0.range().map(function(x) {
        return (x - view.x) / view.k;
      }).map(x0.invert));
      if (y1) y1.domain(y0.range().map(function(y) {
        return (y - view.y) / view.k;
      }).map(y0.invert));
    }
    function zoomstarted(dispatch) {
      if (!zooming++) dispatch({
        type: "zoomstart"
      });
    }
    function zoomed(dispatch) {
      rescale();
      dispatch({
        type: "zoom",
        scale: view.k,
        translate: [ view.x, view.y ]
      });
    }
    function zoomended(dispatch) {
      if (!--zooming) dispatch({
        type: "zoomend"
      }), center0 = null;
    }
    function mousedowned() {
      var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
      d3_selection_interrupt.call(that);
      zoomstarted(dispatch);
      function moved() {
        dragged = 1;
        translateTo(d3.mouse(that), location0);
        zoomed(dispatch);
      }
      function ended() {
        subject.on(mousemove, null).on(mouseup, null);
        dragRestore(dragged);
        zoomended(dispatch);
      }
    }
    function touchstarted() {
      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
      started();
      zoomstarted(dispatch);
      subject.on(mousedown, null).on(touchstart, started);
      function relocate() {
        var touches = d3.touches(that);
        scale0 = view.k;
        touches.forEach(function(t) {
          if (t.identifier in locations0) locations0[t.identifier] = location(t);
        });
        return touches;
      }
      function started() {
        var target = d3.event.target;
        d3.select(target).on(touchmove, moved).on(touchend, ended);
        targets.push(target);
        var changed = d3.event.changedTouches;
        for (var i = 0, n = changed.length; i < n; ++i) {
          locations0[changed[i].identifier] = null;
        }
        var touches = relocate(), now = Date.now();
        if (touches.length === 1) {
          if (now - touchtime < 500) {
            var p = touches[0];
            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
            d3_eventPreventDefault();
          }
          touchtime = now;
        } else if (touches.length > 1) {
          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
          distance0 = dx * dx + dy * dy;
        }
      }
      function moved() {
        var touches = d3.touches(that), p0, l0, p1, l1;
        d3_selection_interrupt.call(that);
        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
          p1 = touches[i];
          if (l1 = locations0[p1.identifier]) {
            if (l0) break;
            p0 = p1, l0 = l1;
          }
        }
        if (l1) {
          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
          scaleTo(scale1 * scale0);
        }
        touchtime = null;
        translateTo(p0, l0);
        zoomed(dispatch);
      }
      function ended() {
        if (d3.event.touches.length) {
          var changed = d3.event.changedTouches;
          for (var i = 0, n = changed.length; i < n; ++i) {
            delete locations0[changed[i].identifier];
          }
          for (var identifier in locations0) {
            return void relocate();
          }
        }
        d3.selectAll(targets).on(zoomName, null);
        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
        dragRestore();
        zoomended(dispatch);
      }
    }
    function mousewheeled() {
      var dispatch = event.of(this, arguments);
      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), 
      translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
      mousewheelTimer = setTimeout(function() {
        mousewheelTimer = null;
        zoomended(dispatch);
      }, 50);
      d3_eventPreventDefault();
      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
      translateTo(center0, translate0);
      zoomed(dispatch);
    }
    function dblclicked() {
      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
    }
    return d3.rebind(zoom, event, "on");
  };
  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
  d3.color = d3_color;
  function d3_color() {}
  d3_color.prototype.toString = function() {
    return this.rgb() + "";
  };
  d3.hsl = d3_hsl;
  function d3_hsl(h, s, l) {
    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
  }
  var d3_hslPrototype = d3_hsl.prototype = new d3_color();
  d3_hslPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, this.l / k);
  };
  d3_hslPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, k * this.l);
  };
  d3_hslPrototype.rgb = function() {
    return d3_hsl_rgb(this.h, this.s, this.l);
  };
  function d3_hsl_rgb(h, s, l) {
    var m1, m2;
    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
    l = l < 0 ? 0 : l > 1 ? 1 : l;
    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
    m1 = 2 * l - m2;
    function v(h) {
      if (h > 360) h -= 360; else if (h < 0) h += 360;
      if (h < 60) return m1 + (m2 - m1) * h / 60;
      if (h < 180) return m2;
      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
      return m1;
    }
    function vv(h) {
      return Math.round(v(h) * 255);
    }
    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
  }
  d3.hcl = d3_hcl;
  function d3_hcl(h, c, l) {
    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
  }
  var d3_hclPrototype = d3_hcl.prototype = new d3_color();
  d3_hclPrototype.brighter = function(k) {
    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.darker = function(k) {
    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.rgb = function() {
    return d3_hcl_lab(this.h, this.c, this.l).rgb();
  };
  function d3_hcl_lab(h, c, l) {
    if (isNaN(h)) h = 0;
    if (isNaN(c)) c = 0;
    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
  }
  d3.lab = d3_lab;
  function d3_lab(l, a, b) {
    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
  }
  var d3_lab_K = 18;
  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
  var d3_labPrototype = d3_lab.prototype = new d3_color();
  d3_labPrototype.brighter = function(k) {
    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.darker = function(k) {
    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.rgb = function() {
    return d3_lab_rgb(this.l, this.a, this.b);
  };
  function d3_lab_rgb(l, a, b) {
    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
    x = d3_lab_xyz(x) * d3_lab_X;
    y = d3_lab_xyz(y) * d3_lab_Y;
    z = d3_lab_xyz(z) * d3_lab_Z;
    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
  }
  function d3_lab_hcl(l, a, b) {
    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
  }
  function d3_lab_xyz(x) {
    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
  }
  function d3_xyz_lab(x) {
    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
  }
  function d3_xyz_rgb(r) {
    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
  }
  d3.rgb = d3_rgb;
  function d3_rgb(r, g, b) {
    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
  }
  function d3_rgbNumber(value) {
    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
  }
  function d3_rgbString(value) {
    return d3_rgbNumber(value) + "";
  }
  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
  d3_rgbPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    var r = this.r, g = this.g, b = this.b, i = 30;
    if (!r && !g && !b) return new d3_rgb(i, i, i);
    if (r && r < i) r = i;
    if (g && g < i) g = i;
    if (b && b < i) b = i;
    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
  };
  d3_rgbPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_rgb(k * this.r, k * this.g, k * this.b);
  };
  d3_rgbPrototype.hsl = function() {
    return d3_rgb_hsl(this.r, this.g, this.b);
  };
  d3_rgbPrototype.toString = function() {
    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
  };
  function d3_rgb_hex(v) {
    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
  }
  function d3_rgb_parse(format, rgb, hsl) {
    var r = 0, g = 0, b = 0, m1, m2, color;
    m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
    if (m1) {
      m2 = m1[2].split(",");
      switch (m1[1]) {
       case "hsl":
        {
          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
        }

       case "rgb":
        {
          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
        }
      }
    }
    if (color = d3_rgb_names.get(format)) {
      return rgb(color.r, color.g, color.b);
    }
    if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
      if (format.length === 4) {
        r = (color & 3840) >> 4;
        r = r >> 4 | r;
        g = color & 240;
        g = g >> 4 | g;
        b = color & 15;
        b = b << 4 | b;
      } else if (format.length === 7) {
        r = (color & 16711680) >> 16;
        g = (color & 65280) >> 8;
        b = color & 255;
      }
    }
    return rgb(r, g, b);
  }
  function d3_rgb_hsl(r, g, b) {
    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
    if (d) {
      s = l < .5 ? d / (max + min) : d / (2 - max - min);
      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
      h *= 60;
    } else {
      h = NaN;
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new d3_hsl(h, s, l);
  }
  function d3_rgb_lab(r, g, b) {
    r = d3_rgb_xyz(r);
    g = d3_rgb_xyz(g);
    b = d3_rgb_xyz(b);
    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
  }
  function d3_rgb_xyz(r) {
    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
  }
  function d3_rgb_parseNumber(c) {
    var f = parseFloat(c);
    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
  }
  var d3_rgb_names = d3.map({
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  });
  d3_rgb_names.forEach(function(key, value) {
    d3_rgb_names.set(key, d3_rgbNumber(value));
  });
  function d3_functor(v) {
    return typeof v === "function" ? v : function() {
      return v;
    };
  }
  d3.functor = d3_functor;
  d3.xhr = d3_xhrType(d3_identity);
  function d3_xhrType(response) {
    return function(url, mimeType, callback) {
      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
      mimeType = null;
      return d3_xhr(url, mimeType, response, callback);
    };
  }
  function d3_xhr(url, mimeType, response, callback) {
    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
    if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
      request.readyState > 3 && respond();
    };
    function respond() {
      var status = request.status, result;
      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
        try {
          result = response.call(xhr, request);
        } catch (e) {
          dispatch.error.call(xhr, e);
          return;
        }
        dispatch.load.call(xhr, result);
      } else {
        dispatch.error.call(xhr, request);
      }
    }
    request.onprogress = function(event) {
      var o = d3.event;
      d3.event = event;
      try {
        dispatch.progress.call(xhr, request);
      } finally {
        d3.event = o;
      }
    };
    xhr.header = function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers[name];
      if (value == null) delete headers[name]; else headers[name] = value + "";
      return xhr;
    };
    xhr.mimeType = function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return xhr;
    };
    xhr.responseType = function(value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return xhr;
    };
    xhr.response = function(value) {
      response = value;
      return xhr;
    };
    [ "get", "post" ].forEach(function(method) {
      xhr[method] = function() {
        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
      };
    });
    xhr.send = function(method, data, callback) {
      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
      request.open(method, url, true);
      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
      if (responseType != null) request.responseType = responseType;
      if (callback != null) xhr.on("error", callback).on("load", function(request) {
        callback(null, request);
      });
      dispatch.beforesend.call(xhr, request);
      request.send(data == null ? null : data);
      return xhr;
    };
    xhr.abort = function() {
      request.abort();
      return xhr;
    };
    d3.rebind(xhr, dispatch, "on");
    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
  }
  function d3_xhr_fixCallback(callback) {
    return callback.length === 1 ? function(error, request) {
      callback(error == null ? request : null);
    } : callback;
  }
  function d3_xhrHasResponse(request) {
    var type = request.responseType;
    return type && type !== "text" ? request.response : request.responseText;
  }
  d3.dsv = function(delimiter, mimeType) {
    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
    function dsv(url, row, callback) {
      if (arguments.length < 3) callback = row, row = null;
      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
      xhr.row = function(_) {
        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
      };
      return xhr;
    }
    function response(request) {
      return dsv.parse(request.responseText);
    }
    function typedResponse(f) {
      return function(request) {
        return dsv.parse(request.responseText, f);
      };
    }
    dsv.parse = function(text, f) {
      var o;
      return dsv.parseRows(text, function(row, i) {
        if (o) return o(row, i - 1);
        var a = new Function("d", "return {" + row.map(function(name, i) {
          return JSON.stringify(name) + ": d[" + i + "]";
        }).join(",") + "}");
        o = f ? function(row, i) {
          return f(a(row), i);
        } : a;
      });
    };
    dsv.parseRows = function(text, f) {
      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
      function token() {
        if (I >= N) return EOF;
        if (eol) return eol = false, EOL;
        var j = I;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < N) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              ++i;
            }
          }
          I = i + 2;
          var c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) ++I;
          } else if (c === 10) {
            eol = true;
          }
          return text.slice(j + 1, i).replace(/""/g, '"');
        }
        while (I < N) {
          var c = text.charCodeAt(I++), k = 1;
          if (c === 10) eol = true; else if (c === 13) {
            eol = true;
            if (text.charCodeAt(I) === 10) ++I, ++k;
          } else if (c !== delimiterCode) continue;
          return text.slice(j, I - k);
        }
        return text.slice(j);
      }
      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && (a = f(a, n++)) == null) continue;
        rows.push(a);
      }
      return rows;
    };
    dsv.format = function(rows) {
      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
      var fieldSet = new d3_Set(), fields = [];
      rows.forEach(function(row) {
        for (var field in row) {
          if (!fieldSet.has(field)) {
            fields.push(fieldSet.add(field));
          }
        }
      });
      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
        return fields.map(function(field) {
          return formatValue(row[field]);
        }).join(delimiter);
      })).join("\n");
    };
    dsv.formatRows = function(rows) {
      return rows.map(formatRow).join("\n");
    };
    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }
    function formatValue(text) {
      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
    }
    return dsv;
  };
  d3.csv = d3.dsv(",", "text/csv");
  d3.tsv = d3.dsv("	", "text/tab-separated-values");
  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
    setTimeout(callback, 17);
  };
  d3.timer = function() {
    d3_timer.apply(this, arguments);
  };
  function d3_timer(callback, delay, then) {
    var n = arguments.length;
    if (n < 2) delay = 0;
    if (n < 3) then = Date.now();
    var time = then + delay, timer = {
      c: callback,
      t: time,
      n: null
    };
    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
    d3_timer_queueTail = timer;
    if (!d3_timer_interval) {
      d3_timer_timeout = clearTimeout(d3_timer_timeout);
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
    return timer;
  }
  function d3_timer_step() {
    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
    if (delay > 24) {
      if (isFinite(delay)) {
        clearTimeout(d3_timer_timeout);
        d3_timer_timeout = setTimeout(d3_timer_step, delay);
      }
      d3_timer_interval = 0;
    } else {
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  }
  d3.timer.flush = function() {
    d3_timer_mark();
    d3_timer_sweep();
  };
  function d3_timer_mark() {
    var now = Date.now(), timer = d3_timer_queueHead;
    while (timer) {
      if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;
      timer = timer.n;
    }
    return now;
  }
  function d3_timer_sweep() {
    var t0, t1 = d3_timer_queueHead, time = Infinity;
    while (t1) {
      if (t1.c) {
        if (t1.t < time) time = t1.t;
        t1 = (t0 = t1).n;
      } else {
        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
      }
    }
    d3_timer_queueTail = t0;
    return time;
  }
  function d3_format_precision(x, p) {
    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
  }
  d3.round = function(x, n) {
    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
  };
  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
  d3.formatPrefix = function(value, precision) {
    var i = 0;
    if (value = +value) {
      if (value < 0) value *= -1;
      if (precision) value = d3.round(value, d3_format_precision(value, precision));
      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
    }
    return d3_formatPrefixes[8 + i / 3];
  };
  function d3_formatPrefix(d, i) {
    var k = Math.pow(10, abs(8 - i) * 3);
    return {
      scale: i > 8 ? function(d) {
        return d / k;
      } : function(d) {
        return d * k;
      },
      symbol: d
    };
  }
  function d3_locale_numberFormat(locale) {
    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = locale_grouping[j = (j + 1) % locale_grouping.length];
      }
      return t.reverse().join(locale_thousands);
    } : d3_identity;
    return function(specifier) {
      var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
      if (precision) precision = +precision.substring(1);
      if (zfill || fill === "0" && align === "=") {
        zfill = fill = "0";
        align = "=";
      }
      switch (type) {
       case "n":
        comma = true;
        type = "g";
        break;

       case "%":
        scale = 100;
        suffix = "%";
        type = "f";
        break;

       case "p":
        scale = 100;
        suffix = "%";
        type = "r";
        break;

       case "b":
       case "o":
       case "x":
       case "X":
        if (symbol === "#") prefix = "0" + type.toLowerCase();

       case "c":
        exponent = false;

       case "d":
        integer = true;
        precision = 0;
        break;

       case "s":
        scale = -1;
        type = "r";
        break;
      }
      if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
      if (type == "r" && !precision) type = "g";
      if (precision != null) {
        if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
      }
      type = d3_format_types.get(type) || d3_format_typeDefault;
      var zcomma = zfill && comma;
      return function(value) {
        var fullSuffix = suffix;
        if (integer && value % 1) return "";
        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
        if (scale < 0) {
          var unit = d3.formatPrefix(value, precision);
          value = unit.scale(value);
          fullSuffix = unit.symbol + suffix;
        } else {
          value *= scale;
        }
        value = type(value, precision);
        var i = value.lastIndexOf("."), before, after;
        if (i < 0) {
          var j = exponent ? value.lastIndexOf("e") : -1;
          if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
        } else {
          before = value.substring(0, i);
          after = locale_decimal + value.substring(i + 1);
        }
        if (!zfill && comma) before = formatGroup(before, Infinity);
        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
        negative += prefix;
        value = before + after;
        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
      };
    };
  }
  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
  var d3_format_types = d3.map({
    b: function(x) {
      return x.toString(2);
    },
    c: function(x) {
      return String.fromCharCode(x);
    },
    o: function(x) {
      return x.toString(8);
    },
    x: function(x) {
      return x.toString(16);
    },
    X: function(x) {
      return x.toString(16).toUpperCase();
    },
    g: function(x, p) {
      return x.toPrecision(p);
    },
    e: function(x, p) {
      return x.toExponential(p);
    },
    f: function(x, p) {
      return x.toFixed(p);
    },
    r: function(x, p) {
      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
    }
  });
  function d3_format_typeDefault(x) {
    return x + "";
  }
  var d3_time = d3.time = {}, d3_date = Date;
  function d3_date_utc() {
    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
  }
  d3_date_utc.prototype = {
    getDate: function() {
      return this._.getUTCDate();
    },
    getDay: function() {
      return this._.getUTCDay();
    },
    getFullYear: function() {
      return this._.getUTCFullYear();
    },
    getHours: function() {
      return this._.getUTCHours();
    },
    getMilliseconds: function() {
      return this._.getUTCMilliseconds();
    },
    getMinutes: function() {
      return this._.getUTCMinutes();
    },
    getMonth: function() {
      return this._.getUTCMonth();
    },
    getSeconds: function() {
      return this._.getUTCSeconds();
    },
    getTime: function() {
      return this._.getTime();
    },
    getTimezoneOffset: function() {
      return 0;
    },
    valueOf: function() {
      return this._.valueOf();
    },
    setDate: function() {
      d3_time_prototype.setUTCDate.apply(this._, arguments);
    },
    setDay: function() {
      d3_time_prototype.setUTCDay.apply(this._, arguments);
    },
    setFullYear: function() {
      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
    },
    setHours: function() {
      d3_time_prototype.setUTCHours.apply(this._, arguments);
    },
    setMilliseconds: function() {
      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
    },
    setMinutes: function() {
      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
    },
    setMonth: function() {
      d3_time_prototype.setUTCMonth.apply(this._, arguments);
    },
    setSeconds: function() {
      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
    },
    setTime: function() {
      d3_time_prototype.setTime.apply(this._, arguments);
    }
  };
  var d3_time_prototype = Date.prototype;
  function d3_time_interval(local, step, number) {
    function round(date) {
      var d0 = local(date), d1 = offset(d0, 1);
      return date - d0 < d1 - date ? d0 : d1;
    }
    function ceil(date) {
      step(date = local(new d3_date(date - 1)), 1);
      return date;
    }
    function offset(date, k) {
      step(date = new d3_date(+date), k);
      return date;
    }
    function range(t0, t1, dt) {
      var time = ceil(t0), times = [];
      if (dt > 1) {
        while (time < t1) {
          if (!(number(time) % dt)) times.push(new Date(+time));
          step(time, 1);
        }
      } else {
        while (time < t1) times.push(new Date(+time)), step(time, 1);
      }
      return times;
    }
    function range_utc(t0, t1, dt) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = t0;
        return range(utc, t1, dt);
      } finally {
        d3_date = Date;
      }
    }
    local.floor = local;
    local.round = round;
    local.ceil = ceil;
    local.offset = offset;
    local.range = range;
    var utc = local.utc = d3_time_interval_utc(local);
    utc.floor = utc;
    utc.round = d3_time_interval_utc(round);
    utc.ceil = d3_time_interval_utc(ceil);
    utc.offset = d3_time_interval_utc(offset);
    utc.range = range_utc;
    return local;
  }
  function d3_time_interval_utc(method) {
    return function(date, k) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = date;
        return method(utc, k)._;
      } finally {
        d3_date = Date;
      }
    };
  }
  d3_time.year = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setMonth(0, 1);
    return date;
  }, function(date, offset) {
    date.setFullYear(date.getFullYear() + offset);
  }, function(date) {
    return date.getFullYear();
  });
  d3_time.years = d3_time.year.range;
  d3_time.years.utc = d3_time.year.utc.range;
  d3_time.day = d3_time_interval(function(date) {
    var day = new d3_date(2e3, 0);
    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
    return day;
  }, function(date, offset) {
    date.setDate(date.getDate() + offset);
  }, function(date) {
    return date.getDate() - 1;
  });
  d3_time.days = d3_time.day.range;
  d3_time.days.utc = d3_time.day.utc.range;
  d3_time.dayOfYear = function(date) {
    var year = d3_time.year(date);
    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
  };
  [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
    i = 7 - i;
    var interval = d3_time[day] = d3_time_interval(function(date) {
      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
      return date;
    }, function(date, offset) {
      date.setDate(date.getDate() + Math.floor(offset) * 7);
    }, function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
    });
    d3_time[day + "s"] = interval.range;
    d3_time[day + "s"].utc = interval.utc.range;
    d3_time[day + "OfYear"] = function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
    };
  });
  d3_time.week = d3_time.sunday;
  d3_time.weeks = d3_time.sunday.range;
  d3_time.weeks.utc = d3_time.sunday.utc.range;
  d3_time.weekOfYear = d3_time.sundayOfYear;
  function d3_locale_timeFormat(locale) {
    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
    function d3_time_format(template) {
      var n = template.length;
      function format(date) {
        var string = [], i = -1, j = 0, c, p, f;
        while (++i < n) {
          if (template.charCodeAt(i) === 37) {
            string.push(template.slice(j, i));
            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
            if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
            string.push(c);
            j = i + 1;
          }
        }
        string.push(template.slice(j, i));
        return string.join("");
      }
      format.parse = function(string) {
        var d = {
          y: 1900,
          m: 0,
          d: 1,
          H: 0,
          M: 0,
          S: 0,
          L: 0,
          Z: null
        }, i = d3_time_parse(d, template, string, 0);
        if (i != string.length) return null;
        if ("p" in d) d.H = d.H % 12 + d.p * 12;
        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
        if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("W" in d || "U" in d) {
          if (!("w" in d)) d.w = "W" in d ? 1 : 0;
          date.setFullYear(d.y, 0, 1);
          date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
        } else date.setFullYear(d.y, d.m, d.d);
        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
        return localZ ? date._ : date;
      };
      format.toString = function() {
        return template;
      };
      return format;
    }
    function d3_time_parse(date, template, string, j) {
      var c, p, t, i = 0, n = template.length, m = string.length;
      while (i < n) {
        if (j >= m) return -1;
        c = template.charCodeAt(i++);
        if (c === 37) {
          t = template.charAt(i++);
          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
          if (!p || (j = p(date, string, j)) < 0) return -1;
        } else if (c != string.charCodeAt(j++)) {
          return -1;
        }
      }
      return j;
    }
    d3_time_format.utc = function(template) {
      var local = d3_time_format(template);
      function format(date) {
        try {
          d3_date = d3_date_utc;
          var utc = new d3_date();
          utc._ = date;
          return local(utc);
        } finally {
          d3_date = Date;
        }
      }
      format.parse = function(string) {
        try {
          d3_date = d3_date_utc;
          var date = local.parse(string);
          return date && date._;
        } finally {
          d3_date = Date;
        }
      };
      format.toString = local.toString;
      return format;
    };
    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
    locale_periods.forEach(function(p, i) {
      d3_time_periodLookup.set(p.toLowerCase(), i);
    });
    var d3_time_formats = {
      a: function(d) {
        return locale_shortDays[d.getDay()];
      },
      A: function(d) {
        return locale_days[d.getDay()];
      },
      b: function(d) {
        return locale_shortMonths[d.getMonth()];
      },
      B: function(d) {
        return locale_months[d.getMonth()];
      },
      c: d3_time_format(locale_dateTime),
      d: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      e: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      H: function(d, p) {
        return d3_time_formatPad(d.getHours(), p, 2);
      },
      I: function(d, p) {
        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
      },
      j: function(d, p) {
        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
      },
      L: function(d, p) {
        return d3_time_formatPad(d.getMilliseconds(), p, 3);
      },
      m: function(d, p) {
        return d3_time_formatPad(d.getMonth() + 1, p, 2);
      },
      M: function(d, p) {
        return d3_time_formatPad(d.getMinutes(), p, 2);
      },
      p: function(d) {
        return locale_periods[+(d.getHours() >= 12)];
      },
      S: function(d, p) {
        return d3_time_formatPad(d.getSeconds(), p, 2);
      },
      U: function(d, p) {
        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
      },
      w: function(d) {
        return d.getDay();
      },
      W: function(d, p) {
        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
      },
      x: d3_time_format(locale_date),
      X: d3_time_format(locale_time),
      y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 100, p, 2);
      },
      Y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
      },
      Z: d3_time_zone,
      "%": function() {
        return "%";
      }
    };
    var d3_time_parsers = {
      a: d3_time_parseWeekdayAbbrev,
      A: d3_time_parseWeekday,
      b: d3_time_parseMonthAbbrev,
      B: d3_time_parseMonth,
      c: d3_time_parseLocaleFull,
      d: d3_time_parseDay,
      e: d3_time_parseDay,
      H: d3_time_parseHour24,
      I: d3_time_parseHour24,
      j: d3_time_parseDayOfYear,
      L: d3_time_parseMilliseconds,
      m: d3_time_parseMonthNumber,
      M: d3_time_parseMinutes,
      p: d3_time_parseAmPm,
      S: d3_time_parseSeconds,
      U: d3_time_parseWeekNumberSunday,
      w: d3_time_parseWeekdayNumber,
      W: d3_time_parseWeekNumberMonday,
      x: d3_time_parseLocaleDate,
      X: d3_time_parseLocaleTime,
      y: d3_time_parseYear,
      Y: d3_time_parseFullYear,
      Z: d3_time_parseZone,
      "%": d3_time_parseLiteralPercent
    };
    function d3_time_parseWeekdayAbbrev(date, string, i) {
      d3_time_dayAbbrevRe.lastIndex = 0;
      var n = d3_time_dayAbbrevRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseWeekday(date, string, i) {
      d3_time_dayRe.lastIndex = 0;
      var n = d3_time_dayRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonthAbbrev(date, string, i) {
      d3_time_monthAbbrevRe.lastIndex = 0;
      var n = d3_time_monthAbbrevRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonth(date, string, i) {
      d3_time_monthRe.lastIndex = 0;
      var n = d3_time_monthRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseLocaleFull(date, string, i) {
      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
    }
    function d3_time_parseLocaleDate(date, string, i) {
      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
    }
    function d3_time_parseLocaleTime(date, string, i) {
      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
    }
    function d3_time_parseAmPm(date, string, i) {
      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
      return n == null ? -1 : (date.p = n, i);
    }
    return d3_time_format;
  }
  var d3_time_formatPads = {
    "-": "",
    _: " ",
    "0": "0"
  }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
  function d3_time_formatPad(value, fill, width) {
    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
  }
  function d3_time_formatRe(names) {
    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
  }
  function d3_time_formatLookup(names) {
    var map = new d3_Map(), i = -1, n = names.length;
    while (++i < n) map.set(names[i].toLowerCase(), i);
    return map;
  }
  function d3_time_parseWeekdayNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 1));
    return n ? (date.w = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberSunday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.U = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberMonday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.W = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseFullYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 4));
    return n ? (date.y = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
  }
  function d3_time_parseZone(date, string, i) {
    return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, 
    i + 5) : -1;
  }
  function d3_time_expandYear(d) {
    return d + (d > 68 ? 1900 : 2e3);
  }
  function d3_time_parseMonthNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
  }
  function d3_time_parseDay(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.d = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseDayOfYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.j = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseHour24(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.H = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMinutes(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.M = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseSeconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.S = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMilliseconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.L = +n[0], i + n[0].length) : -1;
  }
  function d3_time_zone(d) {
    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
  }
  function d3_time_parseLiteralPercent(date, string, i) {
    d3_time_percentRe.lastIndex = 0;
    var n = d3_time_percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }
  function d3_time_formatMulti(formats) {
    var n = formats.length, i = -1;
    while (++i < n) formats[i][0] = this(formats[i][0]);
    return function(date) {
      var i = 0, f = formats[i];
      while (!f[1](date)) f = formats[++i];
      return f[0](date);
    };
  }
  d3.locale = function(locale) {
    return {
      numberFormat: d3_locale_numberFormat(locale),
      timeFormat: d3_locale_timeFormat(locale)
    };
  };
  var d3_locale_enUS = d3.locale({
    decimal: ".",
    thousands: ",",
    grouping: [ 3 ],
    currency: [ "$", "" ],
    dateTime: "%a %b %e %X %Y",
    date: "%m/%d/%Y",
    time: "%H:%M:%S",
    periods: [ "AM", "PM" ],
    days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
    shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
    months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
    shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
  });
  d3.format = d3_locale_enUS.numberFormat;
  d3.geo = {};
  function d3_adder() {}
  d3_adder.prototype = {
    s: 0,
    t: 0,
    add: function(y) {
      d3_adderSum(y, this.t, d3_adderTemp);
      d3_adderSum(d3_adderTemp.s, this.s, this);
      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
    },
    reset: function() {
      this.s = this.t = 0;
    },
    valueOf: function() {
      return this.s;
    }
  };
  var d3_adderTemp = new d3_adder();
  function d3_adderSum(a, b, o) {
    var x = o.s = a + b, bv = x - a, av = x - bv;
    o.t = a - av + (b - bv);
  }
  d3.geo.stream = function(object, listener) {
    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
      d3_geo_streamObjectType[object.type](object, listener);
    } else {
      d3_geo_streamGeometry(object, listener);
    }
  };
  function d3_geo_streamGeometry(geometry, listener) {
    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
      d3_geo_streamGeometryType[geometry.type](geometry, listener);
    }
  }
  var d3_geo_streamObjectType = {
    Feature: function(feature, listener) {
      d3_geo_streamGeometry(feature.geometry, listener);
    },
    FeatureCollection: function(object, listener) {
      var features = object.features, i = -1, n = features.length;
      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
    }
  };
  var d3_geo_streamGeometryType = {
    Sphere: function(object, listener) {
      listener.sphere();
    },
    Point: function(object, listener) {
      object = object.coordinates;
      listener.point(object[0], object[1], object[2]);
    },
    MultiPoint: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
    },
    LineString: function(object, listener) {
      d3_geo_streamLine(object.coordinates, listener, 0);
    },
    MultiLineString: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
    },
    Polygon: function(object, listener) {
      d3_geo_streamPolygon(object.coordinates, listener);
    },
    MultiPolygon: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
    },
    GeometryCollection: function(object, listener) {
      var geometries = object.geometries, i = -1, n = geometries.length;
      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
    }
  };
  function d3_geo_streamLine(coordinates, listener, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    listener.lineStart();
    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
    listener.lineEnd();
  }
  function d3_geo_streamPolygon(coordinates, listener) {
    var i = -1, n = coordinates.length;
    listener.polygonStart();
    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
    listener.polygonEnd();
  }
  d3.geo.area = function(object) {
    d3_geo_areaSum = 0;
    d3.geo.stream(object, d3_geo_area);
    return d3_geo_areaSum;
  };
  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
  var d3_geo_area = {
    sphere: function() {
      d3_geo_areaSum += 4 * ;
    },
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_areaRingSum.reset();
      d3_geo_area.lineStart = d3_geo_areaRingStart;
    },
    polygonEnd: function() {
      var area = 2 * d3_geo_areaRingSum;
      d3_geo_areaSum += area < 0 ? 4 *  + area : area;
      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
    }
  };
  function d3_geo_areaRingStart() {
    var 00, 00, 0, cos0, sin0;
    d3_geo_area.point = function(, ) {
      d3_geo_area.point = nextPoint;
      0 = (00 = ) * d3_radians, cos0 = Math.cos( = (00 = ) * d3_radians / 2 +  / 4), 
      sin0 = Math.sin();
    };
    function nextPoint(, ) {
       *= d3_radians;
       =  * d3_radians / 2 +  / 4;
      var d =  - 0, sd = d >= 0 ? 1 : -1, ad = sd * d, cos = Math.cos(), sin = Math.sin(), k = sin0 * sin, u = cos0 * cos + k * Math.cos(ad), v = k * sd * Math.sin(ad);
      d3_geo_areaRingSum.add(Math.atan2(v, u));
      0 = , cos0 = cos, sin0 = sin;
    }
    d3_geo_area.lineEnd = function() {
      nextPoint(00, 00);
    };
  }
  function d3_geo_cartesian(spherical) {
    var  = spherical[0],  = spherical[1], cos = Math.cos();
    return [ cos * Math.cos(), cos * Math.sin(), Math.sin() ];
  }
  function d3_geo_cartesianDot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function d3_geo_cartesianCross(a, b) {
    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
  }
  function d3_geo_cartesianAdd(a, b) {
    a[0] += b[0];
    a[1] += b[1];
    a[2] += b[2];
  }
  function d3_geo_cartesianScale(vector, k) {
    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
  }
  function d3_geo_cartesianNormalize(d) {
    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l;
    d[1] /= l;
    d[2] /= l;
  }
  function d3_geo_spherical(cartesian) {
    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
  }
  function d3_geo_sphericalEqual(a, b) {
    return abs(a[0] - b[0]) <  && abs(a[1] - b[1]) < ;
  }
  d3.geo.bounds = function() {
    var 0, 0, 1, 1, _, __, __, p0, dSum, ranges, range;
    var bound = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        bound.point = ringPoint;
        bound.lineStart = ringStart;
        bound.lineEnd = ringEnd;
        dSum = 0;
        d3_geo_area.polygonStart();
      },
      polygonEnd: function() {
        d3_geo_area.polygonEnd();
        bound.point = point;
        bound.lineStart = lineStart;
        bound.lineEnd = lineEnd;
        if (d3_geo_areaRingSum < 0) 0 = -(1 = 180), 0 = -(1 = 90); else if (dSum > ) 1 = 90; else if (dSum < -) 0 = -90;
        range[0] = 0, range[1] = 1;
      }
    };
    function point(, ) {
      ranges.push(range = [ 0 = , 1 =  ]);
      if ( < 0) 0 = ;
      if ( > 1) 1 = ;
    }
    function linePoint(, ) {
      var p = d3_geo_cartesian([  * d3_radians,  * d3_radians ]);
      if (p0) {
        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
        d3_geo_cartesianNormalize(inflection);
        inflection = d3_geo_spherical(inflection);
        var d =  - _, s = d > 0 ? 1 : -1, i = inflection[0] * d3_degrees * s, antimeridian = abs(d) > 180;
        if (antimeridian ^ (s * _ < i && i < s * )) {
          var i = inflection[1] * d3_degrees;
          if (i > 1) 1 = i;
        } else if (i = (i + 360) % 360 - 180, antimeridian ^ (s * _ < i && i < s * )) {
          var i = -inflection[1] * d3_degrees;
          if (i < 0) 0 = i;
        } else {
          if ( < 0) 0 = ;
          if ( > 1) 1 = ;
        }
        if (antimeridian) {
          if ( < _) {
            if (angle(0, ) > angle(0, 1)) 1 = ;
          } else {
            if (angle(, 1) > angle(0, 1)) 0 = ;
          }
        } else {
          if (1 >= 0) {
            if ( < 0) 0 = ;
            if ( > 1) 1 = ;
          } else {
            if ( > _) {
              if (angle(0, ) > angle(0, 1)) 1 = ;
            } else {
              if (angle(, 1) > angle(0, 1)) 0 = ;
            }
          }
        }
      } else {
        point(, );
      }
      p0 = p, _ = ;
    }
    function lineStart() {
      bound.point = linePoint;
    }
    function lineEnd() {
      range[0] = 0, range[1] = 1;
      bound.point = point;
      p0 = null;
    }
    function ringPoint(, ) {
      if (p0) {
        var d =  - _;
        dSum += abs(d) > 180 ? d + (d > 0 ? 360 : -360) : d;
      } else __ = , __ = ;
      d3_geo_area.point(, );
      linePoint(, );
    }
    function ringStart() {
      d3_geo_area.lineStart();
    }
    function ringEnd() {
      ringPoint(__, __);
      d3_geo_area.lineEnd();
      if (abs(dSum) > ) 0 = -(1 = 180);
      range[0] = 0, range[1] = 1;
      p0 = null;
    }
    function angle(0, 1) {
      return (1 -= 0) < 0 ? 1 + 360 : 1;
    }
    function compareRanges(a, b) {
      return a[0] - b[0];
    }
    function withinRange(x, range) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }
    return function(feature) {
      1 = 1 = -(0 = 0 = Infinity);
      ranges = [];
      d3.geo.stream(feature, bound);
      var n = ranges.length;
      if (n) {
        ranges.sort(compareRanges);
        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
          b = ranges[i];
          if (withinRange(b[0], a) || withinRange(b[1], a)) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }
        var best = -Infinity, d;
        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
          b = merged[i];
          if ((d = angle(a[1], b[0])) > best) best = d, 0 = b[0], 1 = a[1];
        }
      }
      ranges = range = null;
      return 0 === Infinity || 0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ 0, 0 ], [ 1, 1 ] ];
    };
  }();
  d3.geo.centroid = function(object) {
    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
    d3.geo.stream(object, d3_geo_centroid);
    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
    if (m < 2) {
      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
      if (d3_geo_centroidW1 < ) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
      m = x * x + y * y + z * z;
      if (m < 2) return [ NaN, NaN ];
    }
    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
  };
  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
  var d3_geo_centroid = {
    sphere: d3_noop,
    point: d3_geo_centroidPoint,
    lineStart: d3_geo_centroidLineStart,
    lineEnd: d3_geo_centroidLineEnd,
    polygonStart: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
    }
  };
  function d3_geo_centroidPoint(, ) {
     *= d3_radians;
    var cos = Math.cos( *= d3_radians);
    d3_geo_centroidPointXYZ(cos * Math.cos(), cos * Math.sin(), Math.sin());
  }
  function d3_geo_centroidPointXYZ(x, y, z) {
    ++d3_geo_centroidW0;
    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
  }
  function d3_geo_centroidLineStart() {
    var x0, y0, z0;
    d3_geo_centroid.point = function(, ) {
       *= d3_radians;
      var cos = Math.cos( *= d3_radians);
      x0 = cos * Math.cos();
      y0 = cos * Math.sin();
      z0 = Math.sin();
      d3_geo_centroid.point = nextPoint;
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    function nextPoint(, ) {
       *= d3_radians;
      var cos = Math.cos( *= d3_radians), x = cos * Math.cos(), y = cos * Math.sin(), z = Math.sin(), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_centroidLineEnd() {
    d3_geo_centroid.point = d3_geo_centroidPoint;
  }
  function d3_geo_centroidRingStart() {
    var 00, 00, x0, y0, z0;
    d3_geo_centroid.point = function(, ) {
      00 = , 00 = ;
      d3_geo_centroid.point = nextPoint;
       *= d3_radians;
      var cos = Math.cos( *= d3_radians);
      x0 = cos * Math.cos();
      y0 = cos * Math.sin();
      z0 = Math.sin();
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    d3_geo_centroid.lineEnd = function() {
      nextPoint(00, 00);
      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
      d3_geo_centroid.point = d3_geo_centroidPoint;
    };
    function nextPoint(, ) {
       *= d3_radians;
      var cos = Math.cos( *= d3_radians), x = cos * Math.cos(), y = cos * Math.sin(), z = Math.sin(), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
      d3_geo_centroidX2 += v * cx;
      d3_geo_centroidY2 += v * cy;
      d3_geo_centroidZ2 += v * cz;
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_compose(a, b) {
    function compose(x, y) {
      return x = a(x, y), b(x[0], x[1]);
    }
    if (a.invert && b.invert) compose.invert = function(x, y) {
      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
    };
    return compose;
  }
  function d3_true() {
    return true;
  }
  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
    var subject = [], clip = [];
    segments.forEach(function(segment) {
      if ((n = segment.length - 1) <= 0) return;
      var n, p0 = segment[0], p1 = segment[n];
      if (d3_geo_sphericalEqual(p0, p1)) {
        listener.lineStart();
        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
        listener.lineEnd();
        return;
      }
      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
      a.o = b;
      subject.push(a);
      clip.push(b);
      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
      a.o = b;
      subject.push(a);
      clip.push(b);
    });
    clip.sort(compare);
    d3_geo_clipPolygonLinkCircular(subject);
    d3_geo_clipPolygonLinkCircular(clip);
    if (!subject.length) return;
    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
      clip[i].e = entry = !entry;
    }
    var start = subject[0], points, point;
    while (1) {
      var current = start, isSubject = true;
      while (current.v) if ((current = current.n) === start) return;
      points = current.z;
      listener.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.n.x, 1, listener);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.p.x, -1, listener);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      listener.lineEnd();
    }
  }
  function d3_geo_clipPolygonLinkCircular(array) {
    if (!(n = array.length)) return;
    var n, i = 0, a = array[0], b;
    while (++i < n) {
      a.n = b = array[i];
      b.p = a;
      a = b;
    }
    a.n = b = array[0];
    b.p = a;
  }
  function d3_geo_clipPolygonIntersection(point, points, other, entry) {
    this.x = point;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
    return function(rotate, listener) {
      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon = [];
        },
        polygonEnd: function() {
          clip.point = point;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = d3.merge(segments);
          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
          if (segments.length) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
          } else if (clipStartInside) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            interpolate(null, null, 1, listener);
            listener.lineEnd();
          }
          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
          segments = polygon = null;
        },
        sphere: function() {
          listener.polygonStart();
          listener.lineStart();
          interpolate(null, null, 1, listener);
          listener.lineEnd();
          listener.polygonEnd();
        }
      };
      function point(, ) {
        var point = rotate(, );
        if (pointVisible( = point[0],  = point[1])) listener.point(, );
      }
      function pointLine(, ) {
        var point = rotate(, );
        line.point(point[0], point[1]);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point;
        line.lineEnd();
      }
      var segments;
      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
      function pointRing(, ) {
        ring.push([ ,  ]);
        var point = rotate(, );
        ringListener.point(point[0], point[1]);
      }
      function ringStart() {
        ringListener.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringListener.lineEnd();
        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
        ring.pop();
        polygon.push(ring);
        ring = null;
        if (!n) return;
        if (clean & 1) {
          segment = ringSegments[0];
          var n = segment.length - 1, i = -1, point;
          if (n > 0) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            while (++i < n) listener.point((point = segment[i])[0], point[1]);
            listener.lineEnd();
          }
          return;
        }
        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
      }
      return clip;
    };
  }
  function d3_geo_clipSegmentLength1(segment) {
    return segment.length > 1;
  }
  function d3_geo_clipBufferListener() {
    var lines = [], line;
    return {
      lineStart: function() {
        lines.push(line = []);
      },
      point: function(, ) {
        line.push([ ,  ]);
      },
      lineEnd: d3_noop,
      buffer: function() {
        var buffer = lines;
        lines = [];
        line = null;
        return buffer;
      },
      rejoin: function() {
        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
      }
    };
  }
  function d3_geo_clipSort(a, b) {
    return ((a = a.x)[0] < 0 ? a[1] - half -  : half - a[1]) - ((b = b.x)[0] < 0 ? b[1] - half -  : half - b[1]);
  }
  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -, - / 2 ]);
  function d3_geo_clipAntimeridianLine(listener) {
    var 0 = NaN, 0 = NaN, s0 = NaN, clean;
    return {
      lineStart: function() {
        listener.lineStart();
        clean = 1;
      },
      point: function(1, 1) {
        var s1 = 1 > 0 ?  : -, d = abs(1 - 0);
        if (abs(d - ) < ) {
          listener.point(0, 0 = (0 + 1) / 2 > 0 ? half : -half);
          listener.point(s0, 0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(s1, 0);
          listener.point(1, 0);
          clean = 0;
        } else if (s0 !== s1 && d >= ) {
          if (abs(0 - s0) < ) 0 -= s0 * ;
          if (abs(1 - s1) < ) 1 -= s1 * ;
          0 = d3_geo_clipAntimeridianIntersect(0, 0, 1, 1);
          listener.point(s0, 0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(s1, 0);
          clean = 0;
        }
        listener.point(0 = 1, 0 = 1);
        s0 = s1;
      },
      lineEnd: function() {
        listener.lineEnd();
        0 = 0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function d3_geo_clipAntimeridianIntersect(0, 0, 1, 1) {
    var cos0, cos1, sin0_1 = Math.sin(0 - 1);
    return abs(sin0_1) >  ? Math.atan((Math.sin(0) * (cos1 = Math.cos(1)) * Math.sin(1) - Math.sin(1) * (cos0 = Math.cos(0)) * Math.sin(0)) / (cos0 * cos1 * sin0_1)) : (0 + 1) / 2;
  }
  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
    var ;
    if (from == null) {
       = direction * half;
      listener.point(-, );
      listener.point(0, );
      listener.point(, );
      listener.point(, 0);
      listener.point(, -);
      listener.point(0, -);
      listener.point(-, -);
      listener.point(-, 0);
      listener.point(-, );
    } else if (abs(from[0] - to[0]) > ) {
      var s = from[0] < to[0] ?  : -;
       = direction * s / 2;
      listener.point(-s, );
      listener.point(0, );
      listener.point(s, );
    } else {
      listener.point(to[0], to[1]);
    }
  }
  function d3_geo_pointInPolygon(point, polygon) {
    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
    d3_geo_areaRingSum.reset();
    for (var i = 0, n = polygon.length; i < n; ++i) {
      var ring = polygon[i], m = ring.length;
      if (!m) continue;
      var point0 = ring[0], 0 = point0[0], 0 = point0[1] / 2 +  / 4, sin0 = Math.sin(0), cos0 = Math.cos(0), j = 1;
      while (true) {
        if (j === m) j = 0;
        point = ring[j];
        var  = point[0],  = point[1] / 2 +  / 4, sin = Math.sin(), cos = Math.cos(), d =  - 0, sd = d >= 0 ? 1 : -1, ad = sd * d, antimeridian = ad > , k = sin0 * sin;
        d3_geo_areaRingSum.add(Math.atan2(k * sd * Math.sin(ad), cos0 * cos + k * Math.cos(ad)));
        polarAngle += antimeridian ? d + sd *  : d;
        if (antimeridian ^ 0 >= meridian ^  >= meridian) {
          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
          d3_geo_cartesianNormalize(arc);
          var intersection = d3_geo_cartesianCross(meridianNormal, arc);
          d3_geo_cartesianNormalize(intersection);
          var arc = (antimeridian ^ d >= 0 ? -1 : 1) * d3_asin(intersection[2]);
          if (parallel > arc || parallel === arc && (arc[0] || arc[1])) {
            winding += antimeridian ^ d >= 0 ? 1 : -1;
          }
        }
        if (!j++) break;
        0 = , sin0 = sin, cos0 = cos, point0 = point;
      }
    }
    return (polarAngle < - || polarAngle <  && d3_geo_areaRingSum < -) ^ winding & 1;
  }
  function d3_geo_clipCircle(radius) {
    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > , interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -, radius -  ]);
    function visible(, ) {
      return Math.cos() * Math.cos() > cr;
    }
    function clipLine(listener) {
      var point0, c0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(, ) {
          var point1 = [ ,  ], point2, v = visible(, ), c = smallRadius ? v ? 0 : code(, ) : v ? code( + ( < 0 ?  : -), ) : 0;
          if (!point0 && (v00 = v0 = v)) listener.lineStart();
          if (v !== v0) {
            point2 = intersect(point0, point1);
            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
              point1[0] += ;
              point1[1] += ;
              v = visible(point1[0], point1[1]);
            }
          }
          if (v !== v0) {
            clean = 0;
            if (v) {
              listener.lineStart();
              point2 = intersect(point1, point0);
              listener.point(point2[0], point2[1]);
            } else {
              point2 = intersect(point0, point1);
              listener.point(point2[0], point2[1]);
              listener.lineEnd();
            }
            point0 = point2;
          } else if (notHemisphere && point0 && smallRadius ^ v) {
            var t;
            if (!(c & c0) && (t = intersect(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
              } else {
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
              }
            }
          }
          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
            listener.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v, c0 = c;
        },
        lineEnd: function() {
          if (v0) listener.lineEnd();
          point0 = null;
        },
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect(a, b, two) {
      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
      if (!determinant) return !two && a;
      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
      d3_geo_cartesianAdd(A, B);
      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
      if (t2 < 0) return;
      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
      d3_geo_cartesianAdd(q, A);
      q = d3_geo_spherical(q);
      if (!two) return q;
      var 0 = a[0], 1 = b[0], 0 = a[1], 1 = b[1], z;
      if (1 < 0) z = 0, 0 = 1, 1 = z;
      var  = 1 - 0, polar = abs( - ) < , meridian = polar ||  < ;
      if (!polar && 1 < 0) z = 0, 0 = 1, 1 = z;
      if (meridian ? polar ? 0 + 1 > 0 ^ q[1] < (abs(q[0] - 0) <  ? 0 : 1) : 0 <= q[1] && q[1] <= 1 :  >  ^ (0 <= q[0] && q[0] <= 1)) {
        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
        d3_geo_cartesianAdd(q1, A);
        return [ q, d3_geo_spherical(q1) ];
      }
    }
    function code(, ) {
      var r = smallRadius ? radius :  - radius, code = 0;
      if ( < -r) code |= 1; else if ( > r) code |= 2;
      if ( < -r) code |= 4; else if ( > r) code |= 8;
      return code;
    }
  }
  function d3_geom_clipLine(x0, y0, x1, y1) {
    return function(line) {
      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      if (t0 > 0) line.a = {
        x: ax + t0 * dx,
        y: ay + t0 * dy
      };
      if (t1 < 1) line.b = {
        x: ax + t1 * dx,
        y: ay + t1 * dy
      };
      return line;
    };
  }
  var d3_geo_clipExtentMAX = 1e9;
  d3.geo.clipExtent = function() {
    var x0, y0, x1, y1, stream, clip, clipExtent = {
      stream: function(output) {
        if (stream) stream.valid = false;
        stream = clip(output);
        stream.valid = true;
        return stream;
      },
      extent: function(_) {
        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
        if (stream) stream.valid = false, stream = null;
        return clipExtent;
      }
    };
    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
  };
  function d3_geo_clipExtent(x0, y0, x1, y1) {
    return function(listener) {
      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          listener = bufferListener;
          segments = [];
          polygon = [];
          clean = true;
        },
        polygonEnd: function() {
          listener = listener_;
          segments = d3.merge(segments);
          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
          if (inside || visible) {
            listener.polygonStart();
            if (inside) {
              listener.lineStart();
              interpolate(null, null, 1, listener);
              listener.lineEnd();
            }
            if (visible) {
              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
            }
            listener.polygonEnd();
          }
          segments = polygon = ring = null;
        }
      };
      function insidePolygon(p) {
        var wn = 0, n = polygon.length, y = p[1];
        for (var i = 0; i < n; ++i) {
          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
            b = v[j];
            if (a[1] <= y) {
              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
            } else {
              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
            }
            a = b;
          }
        }
        return wn !== 0;
      }
      function interpolate(from, to, direction, listener) {
        var a = 0, a1 = 0;
        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
          do {
            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          } while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          listener.point(to[0], to[1]);
        }
      }
      function pointVisible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }
      function point(x, y) {
        if (pointVisible(x, y)) listener.point(x, y);
      }
      var x__, y__, v__, x_, y_, v_, first, clean;
      function lineStart() {
        clip.point = linePoint;
        if (polygon) polygon.push(ring = []);
        first = true;
        v_ = false;
        x_ = y_ = NaN;
      }
      function lineEnd() {
        if (segments) {
          linePoint(x__, y__);
          if (v__ && v_) bufferListener.rejoin();
          segments.push(bufferListener.buffer());
        }
        clip.point = point;
        if (v_) listener.lineEnd();
      }
      function linePoint(x, y) {
        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
        var v = pointVisible(x, y);
        if (polygon) ring.push([ x, y ]);
        if (first) {
          x__ = x, y__ = y, v__ = v;
          first = false;
          if (v) {
            listener.lineStart();
            listener.point(x, y);
          }
        } else {
          if (v && v_) listener.point(x, y); else {
            var l = {
              a: {
                x: x_,
                y: y_
              },
              b: {
                x: x,
                y: y
              }
            };
            if (clipLine(l)) {
              if (!v_) {
                listener.lineStart();
                listener.point(l.a.x, l.a.y);
              }
              listener.point(l.b.x, l.b.y);
              if (!v) listener.lineEnd();
              clean = false;
            } else if (v) {
              listener.lineStart();
              listener.point(x, y);
              clean = false;
            }
          }
        }
        x_ = x, y_ = y, v_ = v;
      }
      return clip;
    };
    function corner(p, direction) {
      return abs(p[0] - x0) <  ? direction > 0 ? 0 : 3 : abs(p[0] - x1) <  ? direction > 0 ? 2 : 1 : abs(p[1] - y0) <  ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
    }
    function compare(a, b) {
      return comparePoints(a.x, b.x);
    }
    function comparePoints(a, b) {
      var ca = corner(a, 1), cb = corner(b, 1);
      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
    }
  }
  function d3_geo_conic(projectAt) {
    var 0 = 0, 1 =  / 3, m = d3_geo_projectionMutator(projectAt), p = m(0, 1);
    p.parallels = function(_) {
      if (!arguments.length) return [ 0 /  * 180, 1 /  * 180 ];
      return m(0 = _[0] *  / 180, 1 = _[1] *  / 180);
    };
    return p;
  }
  function d3_geo_conicEqualArea(0, 1) {
    var sin0 = Math.sin(0), n = (sin0 + Math.sin(1)) / 2, C = 1 + sin0 * (2 * n - sin0), 0 = Math.sqrt(C) / n;
    function forward(, ) {
      var  = Math.sqrt(C - 2 * n * Math.sin()) / n;
      return [  * Math.sin( *= n), 0 -  * Math.cos() ];
    }
    forward.invert = function(x, y) {
      var 0_y = 0 - y;
      return [ Math.atan2(x, 0_y) / n, d3_asin((C - (x * x + 0_y * 0_y) * n * n) / (2 * n)) ];
    };
    return forward;
  }
  (d3.geo.conicEqualArea = function() {
    return d3_geo_conic(d3_geo_conicEqualArea);
  }).raw = d3_geo_conicEqualArea;
  d3.geo.albers = function() {
    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
  };
  d3.geo.albersUsa = function() {
    var lower48 = d3.geo.albers();
    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
    var point, pointStream = {
      point: function(x, y) {
        point = [ x, y ];
      }
    }, lower48Point, alaskaPoint, hawaiiPoint;
    function albersUsa(coordinates) {
      var x = coordinates[0], y = coordinates[1];
      point = null;
      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
      return point;
    }
    albersUsa.invert = function(coordinates) {
      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
    };
    albersUsa.stream = function(stream) {
      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
      return {
        point: function(x, y) {
          lower48Stream.point(x, y);
          alaskaStream.point(x, y);
          hawaiiStream.point(x, y);
        },
        sphere: function() {
          lower48Stream.sphere();
          alaskaStream.sphere();
          hawaiiStream.sphere();
        },
        lineStart: function() {
          lower48Stream.lineStart();
          alaskaStream.lineStart();
          hawaiiStream.lineStart();
        },
        lineEnd: function() {
          lower48Stream.lineEnd();
          alaskaStream.lineEnd();
          hawaiiStream.lineEnd();
        },
        polygonStart: function() {
          lower48Stream.polygonStart();
          alaskaStream.polygonStart();
          hawaiiStream.polygonStart();
        },
        polygonEnd: function() {
          lower48Stream.polygonEnd();
          alaskaStream.polygonEnd();
          hawaiiStream.polygonEnd();
        }
      };
    };
    albersUsa.precision = function(_) {
      if (!arguments.length) return lower48.precision();
      lower48.precision(_);
      alaska.precision(_);
      hawaii.precision(_);
      return albersUsa;
    };
    albersUsa.scale = function(_) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(_);
      alaska.scale(_ * .35);
      hawaii.scale(_);
      return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(_) {
      if (!arguments.length) return lower48.translate();
      var k = lower48.scale(), x = +_[0], y = +_[1];
      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + , y + .12 * k +  ], [ x - .214 * k - , y + .234 * k -  ] ]).stream(pointStream).point;
      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + , y + .166 * k +  ], [ x - .115 * k - , y + .234 * k -  ] ]).stream(pointStream).point;
      return albersUsa;
    };
    return albersUsa.scale(1070);
  };
  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_pathAreaPolygon = 0;
      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
    }
  };
  function d3_geo_pathAreaRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathArea.point = function(x, y) {
      d3_geo_pathArea.point = nextPoint;
      x00 = x0 = x, y00 = y0 = y;
    };
    function nextPoint(x, y) {
      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
      x0 = x, y0 = y;
    }
    d3_geo_pathArea.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
  var d3_geo_pathBounds = {
    point: d3_geo_pathBoundsPoint,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_pathBoundsPoint(x, y) {
    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
  }
  function d3_geo_pathBuffer() {
    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointCircle = d3_geo_pathBufferCircle(_);
        return stream;
      },
      result: function() {
        if (buffer.length) {
          var result = buffer.join("");
          buffer = [];
          return result;
        }
      }
    };
    function point(x, y) {
      buffer.push("M", x, ",", y, pointCircle);
    }
    function pointLineStart(x, y) {
      buffer.push("M", x, ",", y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      buffer.push("L", x, ",", y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      buffer.push("Z");
    }
    return stream;
  }
  function d3_geo_pathBufferCircle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
  }
  var d3_geo_pathCentroid = {
    point: d3_geo_pathCentroidPoint,
    lineStart: d3_geo_pathCentroidLineStart,
    lineEnd: d3_geo_pathCentroidLineEnd,
    polygonStart: function() {
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
    }
  };
  function d3_geo_pathCentroidPoint(x, y) {
    d3_geo_centroidX0 += x;
    d3_geo_centroidY0 += y;
    ++d3_geo_centroidZ0;
  }
  function d3_geo_pathCentroidLineStart() {
    var x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
  }
  function d3_geo_pathCentroidLineEnd() {
    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
  }
  function d3_geo_pathCentroidRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      z = y0 * x - x0 * y;
      d3_geo_centroidX2 += z * (x0 + x);
      d3_geo_centroidY2 += z * (y0 + y);
      d3_geo_centroidZ2 += z * 3;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
    d3_geo_pathCentroid.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  function d3_geo_pathContext(context) {
    var pointRadius = 4.5;
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointRadius = _;
        return stream;
      },
      result: d3_noop
    };
    function point(x, y) {
      context.moveTo(x + pointRadius, y);
      context.arc(x, y, pointRadius, 0, );
    }
    function pointLineStart(x, y) {
      context.moveTo(x, y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      context.lineTo(x, y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      context.closePath();
    }
    return stream;
  }
  function d3_geo_resample(project) {
    var 2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
    function resample(stream) {
      return (maxDepth ? resampleRecursive : resampleNone)(stream);
    }
    function resampleNone(stream) {
      return d3_geo_transformPoint(stream, function(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      });
    }
    function resampleRecursive(stream) {
      var 00, 00, x00, y00, a00, b00, c00, 0, x0, y0, a0, b0, c0;
      var resample = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resample.lineStart = ringStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resample.lineStart = lineStart;
        }
      };
      function point(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      }
      function lineStart() {
        x0 = NaN;
        resample.point = linePoint;
        stream.lineStart();
      }
      function linePoint(, ) {
        var c = d3_geo_cartesian([ ,  ]), p = project(, );
        resampleLineTo(x0, y0, 0, a0, b0, c0, x0 = p[0], y0 = p[1], 0 = , a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
        stream.point(x0, y0);
      }
      function lineEnd() {
        resample.point = point;
        stream.lineEnd();
      }
      function ringStart() {
        lineStart();
        resample.point = ringPoint;
        resample.lineEnd = ringEnd;
      }
      function ringPoint(, ) {
        linePoint(00 = , 00 = ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
        resample.point = linePoint;
      }
      function ringEnd() {
        resampleLineTo(x0, y0, 0, a0, b0, c0, x00, y00, 00, a00, b00, c00, maxDepth, stream);
        resample.lineEnd = lineEnd;
        lineEnd();
      }
      return resample;
    }
    function resampleLineTo(x0, y0, 0, a0, b0, c0, x1, y1, 1, a1, b1, c1, depth, stream) {
      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
      if (d2 > 4 * 2 && depth--) {
        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), 2 = Math.asin(c /= m), 2 = abs(abs(c) - 1) <  || abs(0 - 1) <  ? (0 + 1) / 2 : Math.atan2(b, a), p = project(2, 2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > 2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
          resampleLineTo(x0, y0, 0, a0, b0, c0, x2, y2, 2, a /= m, b /= m, c, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, 2, a, b, c, x1, y1, 1, a1, b1, c1, depth, stream);
        }
      }
    }
    resample.precision = function(_) {
      if (!arguments.length) return Math.sqrt(2);
      maxDepth = (2 = _ * _) > 0 && 16;
      return resample;
    };
    return resample;
  }
  d3.geo.path = function() {
    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
    function path(object) {
      if (object) {
        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
        d3.geo.stream(object, cacheStream);
      }
      return contextStream.result();
    }
    path.area = function(object) {
      d3_geo_pathAreaSum = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathArea));
      return d3_geo_pathAreaSum;
    };
    path.centroid = function(object) {
      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
    };
    path.bounds = function(object) {
      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
      d3.geo.stream(object, projectStream(d3_geo_pathBounds));
      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
    };
    path.projection = function(_) {
      if (!arguments.length) return projection;
      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
      return reset();
    };
    path.context = function(_) {
      if (!arguments.length) return context;
      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
      return reset();
    };
    path.pointRadius = function(_) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
      return path;
    };
    function reset() {
      cacheStream = null;
      return path;
    }
    return path.projection(d3.geo.albersUsa()).context(null);
  };
  function d3_geo_pathProjectStream(project) {
    var resample = d3_geo_resample(function(x, y) {
      return project([ x * d3_degrees, y * d3_degrees ]);
    });
    return function(stream) {
      return d3_geo_projectionRadians(resample(stream));
    };
  }
  d3.geo.transform = function(methods) {
    return {
      stream: function(stream) {
        var transform = new d3_geo_transform(stream);
        for (var k in methods) transform[k] = methods[k];
        return transform;
      }
    };
  };
  function d3_geo_transform(stream) {
    this.stream = stream;
  }
  d3_geo_transform.prototype = {
    point: function(x, y) {
      this.stream.point(x, y);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };
  function d3_geo_transformPoint(stream, point) {
    return {
      point: point,
      sphere: function() {
        stream.sphere();
      },
      lineStart: function() {
        stream.lineStart();
      },
      lineEnd: function() {
        stream.lineEnd();
      },
      polygonStart: function() {
        stream.polygonStart();
      },
      polygonEnd: function() {
        stream.polygonEnd();
      }
    };
  }
  d3.geo.projection = d3_geo_projection;
  d3.geo.projectionMutator = d3_geo_projectionMutator;
  function d3_geo_projection(project) {
    return d3_geo_projectionMutator(function() {
      return project;
    })();
  }
  function d3_geo_projectionMutator(projectAt) {
    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
      x = project(x, y);
      return [ x[0] * k + x, y - x[1] * k ];
    }), k = 150, x = 480, y = 250,  = 0,  = 0,  = 0,  = 0,  = 0, x, y, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
    function projection(point) {
      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
      return [ point[0] * k + x, y - point[1] * k ];
    }
    function invert(point) {
      point = projectRotate.invert((point[0] - x) / k, (y - point[1]) / k);
      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
    }
    projection.stream = function(output) {
      if (stream) stream.valid = false;
      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
      stream.valid = true;
      return stream;
    };
    projection.clipAngle = function(_) {
      if (!arguments.length) return clipAngle;
      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
      return invalidate();
    };
    projection.clipExtent = function(_) {
      if (!arguments.length) return clipExtent;
      clipExtent = _;
      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
      return invalidate();
    };
    projection.scale = function(_) {
      if (!arguments.length) return k;
      k = +_;
      return reset();
    };
    projection.translate = function(_) {
      if (!arguments.length) return [ x, y ];
      x = +_[0];
      y = +_[1];
      return reset();
    };
    projection.center = function(_) {
      if (!arguments.length) return [  * d3_degrees,  * d3_degrees ];
       = _[0] % 360 * d3_radians;
       = _[1] % 360 * d3_radians;
      return reset();
    };
    projection.rotate = function(_) {
      if (!arguments.length) return [  * d3_degrees,  * d3_degrees,  * d3_degrees ];
       = _[0] % 360 * d3_radians;
       = _[1] % 360 * d3_radians;
       = _.length > 2 ? _[2] % 360 * d3_radians : 0;
      return reset();
    };
    d3.rebind(projection, projectResample, "precision");
    function reset() {
      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(, , ), project);
      var center = project(, );
      x = x - center[0] * k;
      y = y + center[1] * k;
      return invalidate();
    }
    function invalidate() {
      if (stream) stream.valid = false, stream = null;
      return projection;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection.invert = project.invert && invert;
      return reset();
    };
  }
  function d3_geo_projectionRadians(stream) {
    return d3_geo_transformPoint(stream, function(x, y) {
      stream.point(x * d3_radians, y * d3_radians);
    });
  }
  function d3_geo_equirectangular(, ) {
    return [ ,  ];
  }
  (d3.geo.equirectangular = function() {
    return d3_geo_projection(d3_geo_equirectangular);
  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
  d3.geo.rotation = function(rotate) {
    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
    function forward(coordinates) {
      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    }
    forward.invert = function(coordinates) {
      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    };
    return forward;
  };
  function d3_geo_identityRotation(, ) {
    return [  >  ?  -  :  < - ?  +  : ,  ];
  }
  d3_geo_identityRotation.invert = d3_geo_equirectangular;
  function d3_geo_rotation(, , ) {
    return  ?  ||  ? d3_geo_compose(d3_geo_rotation(), d3_geo_rotation(, )) : d3_geo_rotation() :  ||  ? d3_geo_rotation(, ) : d3_geo_identityRotation;
  }
  function d3_geo_forwardRotation() {
    return function(, ) {
      return  += , [  >  ?  -  :  < - ?  +  : ,  ];
    };
  }
  function d3_geo_rotation() {
    var rotation = d3_geo_forwardRotation();
    rotation.invert = d3_geo_forwardRotation(-);
    return rotation;
  }
  function d3_geo_rotation(, ) {
    var cos = Math.cos(), sin = Math.sin(), cos = Math.cos(), sin = Math.sin();
    function rotation(, ) {
      var cos = Math.cos(), x = Math.cos() * cos, y = Math.sin() * cos, z = Math.sin(), k = z * cos + x * sin;
      return [ Math.atan2(y * cos - k * sin, x * cos - z * sin), d3_asin(k * cos + y * sin) ];
    }
    rotation.invert = function(, ) {
      var cos = Math.cos(), x = Math.cos() * cos, y = Math.sin() * cos, z = Math.sin(), k = z * cos - y * sin;
      return [ Math.atan2(y * cos + z * sin, x * cos + k * sin), d3_asin(k * cos - x * sin) ];
    };
    return rotation;
  }
  d3.geo.circle = function() {
    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
    function circle() {
      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
      interpolate(null, null, 1, {
        point: function(x, y) {
          ring.push(x = rotate(x, y));
          x[0] *= d3_degrees, x[1] *= d3_degrees;
        }
      });
      return {
        type: "Polygon",
        coordinates: [ ring ]
      };
    }
    circle.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return circle;
    };
    circle.angle = function(x) {
      if (!arguments.length) return angle;
      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
      return circle;
    };
    circle.precision = function(_) {
      if (!arguments.length) return precision;
      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
      return circle;
    };
    return circle.angle(90);
  };
  function d3_geo_circleInterpolate(radius, precision) {
    var cr = Math.cos(radius), sr = Math.sin(radius);
    return function(from, to, direction, listener) {
      var step = direction * precision;
      if (from != null) {
        from = d3_geo_circleAngle(cr, from);
        to = d3_geo_circleAngle(cr, to);
        if (direction > 0 ? from < to : from > to) from += direction * ;
      } else {
        from = radius + direction * ;
        to = radius - .5 * step;
      }
      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
      }
    };
  }
  function d3_geo_circleAngle(cr, point) {
    var a = d3_geo_cartesian(point);
    a[0] -= cr;
    d3_geo_cartesianNormalize(a);
    var angle = d3_acos(-a[1]);
    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ) % (2 * Math.PI);
  }
  d3.geo.distance = function(a, b) {
    var  = (b[0] - a[0]) * d3_radians, 0 = a[1] * d3_radians, 1 = b[1] * d3_radians, sin = Math.sin(), cos = Math.cos(), sin0 = Math.sin(0), cos0 = Math.cos(0), sin1 = Math.sin(1), cos1 = Math.cos(1), t;
    return Math.atan2(Math.sqrt((t = cos1 * sin) * t + (t = cos0 * sin1 - sin0 * cos1 * cos) * t), sin0 * sin1 + cos0 * cos1 * cos);
  };
  d3.geo.graticule = function() {
    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
    function graticule() {
      return {
        type: "MultiLineString",
        coordinates: lines()
      };
    }
    function lines() {
      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
        return abs(x % DX) > ;
      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
        return abs(y % DY) > ;
      }).map(y));
    }
    graticule.lines = function() {
      return lines().map(function(coordinates) {
        return {
          type: "LineString",
          coordinates: coordinates
        };
      });
    };
    graticule.outline = function() {
      return {
        type: "Polygon",
        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
      };
    };
    graticule.extent = function(_) {
      if (!arguments.length) return graticule.minorExtent();
      return graticule.majorExtent(_).minorExtent(_);
    };
    graticule.majorExtent = function(_) {
      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
      X0 = +_[0][0], X1 = +_[1][0];
      Y0 = +_[0][1], Y1 = +_[1][1];
      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
      return graticule.precision(precision);
    };
    graticule.minorExtent = function(_) {
      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
      x0 = +_[0][0], x1 = +_[1][0];
      y0 = +_[0][1], y1 = +_[1][1];
      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
      return graticule.precision(precision);
    };
    graticule.step = function(_) {
      if (!arguments.length) return graticule.minorStep();
      return graticule.majorStep(_).minorStep(_);
    };
    graticule.majorStep = function(_) {
      if (!arguments.length) return [ DX, DY ];
      DX = +_[0], DY = +_[1];
      return graticule;
    };
    graticule.minorStep = function(_) {
      if (!arguments.length) return [ dx, dy ];
      dx = +_[0], dy = +_[1];
      return graticule;
    };
    graticule.precision = function(_) {
      if (!arguments.length) return precision;
      precision = +_;
      x = d3_geo_graticuleX(y0, y1, 90);
      y = d3_geo_graticuleY(x0, x1, precision);
      X = d3_geo_graticuleX(Y0, Y1, 90);
      Y = d3_geo_graticuleY(X0, X1, precision);
      return graticule;
    };
    return graticule.majorExtent([ [ -180, -90 +  ], [ 180, 90 -  ] ]).minorExtent([ [ -180, -80 -  ], [ 180, 80 +  ] ]);
  };
  function d3_geo_graticuleX(y0, y1, dy) {
    var y = d3.range(y0, y1 - , dy).concat(y1);
    return function(x) {
      return y.map(function(y) {
        return [ x, y ];
      });
    };
  }
  function d3_geo_graticuleY(x0, x1, dx) {
    var x = d3.range(x0, x1 - , dx).concat(x1);
    return function(y) {
      return x.map(function(x) {
        return [ x, y ];
      });
    };
  }
  function d3_source(d) {
    return d.source;
  }
  function d3_target(d) {
    return d.target;
  }
  d3.geo.greatArc = function() {
    var source = d3_source, source_, target = d3_target, target_;
    function greatArc() {
      return {
        type: "LineString",
        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
      };
    }
    greatArc.distance = function() {
      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
    };
    greatArc.source = function(_) {
      if (!arguments.length) return source;
      source = _, source_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.target = function(_) {
      if (!arguments.length) return target;
      target = _, target_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.precision = function() {
      return arguments.length ? greatArc : 0;
    };
    return greatArc;
  };
  d3.geo.interpolate = function(source, target) {
    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
  };
  function d3_geo_interpolate(x0, y0, x1, y1) {
    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
    var interpolate = d ? function(t) {
      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
    } : function() {
      return [ x0 * d3_degrees, y0 * d3_degrees ];
    };
    interpolate.distance = d;
    return interpolate;
  }
  d3.geo.length = function(object) {
    d3_geo_lengthSum = 0;
    d3.geo.stream(object, d3_geo_length);
    return d3_geo_lengthSum;
  };
  var d3_geo_lengthSum;
  var d3_geo_length = {
    sphere: d3_noop,
    point: d3_noop,
    lineStart: d3_geo_lengthLineStart,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_lengthLineStart() {
    var 0, sin0, cos0;
    d3_geo_length.point = function(, ) {
      0 =  * d3_radians, sin0 = Math.sin( *= d3_radians), cos0 = Math.cos();
      d3_geo_length.point = nextPoint;
    };
    d3_geo_length.lineEnd = function() {
      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
    };
    function nextPoint(, ) {
      var sin = Math.sin( *= d3_radians), cos = Math.cos(), t = abs(( *= d3_radians) - 0), cos = Math.cos(t);
      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cos * Math.sin(t)) * t + (t = cos0 * sin - sin0 * cos * cos) * t), sin0 * sin + cos0 * cos * cos);
      0 = , sin0 = sin, cos0 = cos;
    }
  }
  function d3_geo_azimuthal(scale, angle) {
    function azimuthal(, ) {
      var cos = Math.cos(), cos = Math.cos(), k = scale(cos * cos);
      return [ k * cos * Math.sin(), k * Math.sin() ];
    }
    azimuthal.invert = function(x, y) {
      var  = Math.sqrt(x * x + y * y), c = angle(), sinc = Math.sin(c), cosc = Math.cos(c);
      return [ Math.atan2(x * sinc,  * cosc), Math.asin( && y * sinc / ) ];
    };
    return azimuthal;
  }
  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(coscos) {
    return Math.sqrt(2 / (1 + coscos));
  }, function() {
    return 2 * Math.asin( / 2);
  });
  (d3.geo.azimuthalEqualArea = function() {
    return d3_geo_projection(d3_geo_azimuthalEqualArea);
  }).raw = d3_geo_azimuthalEqualArea;
  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(coscos) {
    var c = Math.acos(coscos);
    return c && c / Math.sin(c);
  }, d3_identity);
  (d3.geo.azimuthalEquidistant = function() {
    return d3_geo_projection(d3_geo_azimuthalEquidistant);
  }).raw = d3_geo_azimuthalEquidistant;
  function d3_geo_conicConformal(0, 1) {
    var cos0 = Math.cos(0), t = function() {
      return Math.tan( / 4 +  / 2);
    }, n = 0 === 1 ? Math.sin(0) : Math.log(cos0 / Math.cos(1)) / Math.log(t(1) / t(0)), F = cos0 * Math.pow(t(0), n) / n;
    if (!n) return d3_geo_mercator;
    function forward(, ) {
      if (F > 0) {
        if ( < -half + )  = -half + ;
      } else {
        if ( > half - )  = half - ;
      }
      var  = F / Math.pow(t(), n);
      return [  * Math.sin(n * ), F -  * Math.cos(n * ) ];
    }
    forward.invert = function(x, y) {
      var 0_y = F - y,  = d3_sgn(n) * Math.sqrt(x * x + 0_y * 0_y);
      return [ Math.atan2(x, 0_y) / n, 2 * Math.atan(Math.pow(F / , 1 / n)) - half ];
    };
    return forward;
  }
  (d3.geo.conicConformal = function() {
    return d3_geo_conic(d3_geo_conicConformal);
  }).raw = d3_geo_conicConformal;
  function d3_geo_conicEquidistant(0, 1) {
    var cos0 = Math.cos(0), n = 0 === 1 ? Math.sin(0) : (cos0 - Math.cos(1)) / (1 - 0), G = cos0 / n + 0;
    if (abs(n) < ) return d3_geo_equirectangular;
    function forward(, ) {
      var  = G - ;
      return [  * Math.sin(n * ), G -  * Math.cos(n * ) ];
    }
    forward.invert = function(x, y) {
      var 0_y = G - y;
      return [ Math.atan2(x, 0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + 0_y * 0_y) ];
    };
    return forward;
  }
  (d3.geo.conicEquidistant = function() {
    return d3_geo_conic(d3_geo_conicEquidistant);
  }).raw = d3_geo_conicEquidistant;
  var d3_geo_gnomonic = d3_geo_azimuthal(function(coscos) {
    return 1 / coscos;
  }, Math.atan);
  (d3.geo.gnomonic = function() {
    return d3_geo_projection(d3_geo_gnomonic);
  }).raw = d3_geo_gnomonic;
  function d3_geo_mercator(, ) {
    return [ , Math.log(Math.tan( / 4 +  / 2)) ];
  }
  d3_geo_mercator.invert = function(x, y) {
    return [ x, 2 * Math.atan(Math.exp(y)) - half ];
  };
  function d3_geo_mercatorProjection(project) {
    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
    m.scale = function() {
      var v = scale.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.translate = function() {
      var v = translate.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.clipExtent = function(_) {
      var v = clipExtent.apply(m, arguments);
      if (v === m) {
        if (clipAuto = _ == null) {
          var k =  * scale(), t = translate();
          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
        }
      } else if (clipAuto) {
        v = null;
      }
      return v;
    };
    return m.clipExtent(null);
  }
  (d3.geo.mercator = function() {
    return d3_geo_mercatorProjection(d3_geo_mercator);
  }).raw = d3_geo_mercator;
  var d3_geo_orthographic = d3_geo_azimuthal(function() {
    return 1;
  }, Math.asin);
  (d3.geo.orthographic = function() {
    return d3_geo_projection(d3_geo_orthographic);
  }).raw = d3_geo_orthographic;
  var d3_geo_stereographic = d3_geo_azimuthal(function(coscos) {
    return 1 / (1 + coscos);
  }, function() {
    return 2 * Math.atan();
  });
  (d3.geo.stereographic = function() {
    return d3_geo_projection(d3_geo_stereographic);
  }).raw = d3_geo_stereographic;
  function d3_geo_transverseMercator(, ) {
    return [ Math.log(Math.tan( / 4 +  / 2)), - ];
  }
  d3_geo_transverseMercator.invert = function(x, y) {
    return [ -y, 2 * Math.atan(Math.exp(x)) - half ];
  };
  (d3.geo.transverseMercator = function() {
    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
    projection.center = function(_) {
      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
    };
    projection.rotate = function(_) {
      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
      [ _[0], _[1], _[2] - 90 ]);
    };
    return rotate([ 0, 0, 90 ]);
  }).raw = d3_geo_transverseMercator;
  d3.geom = {};
  function d3_geom_pointX(d) {
    return d[0];
  }
  function d3_geom_pointY(d) {
    return d[1];
  }
  d3.geom.hull = function(vertices) {
    var x = d3_geom_pointX, y = d3_geom_pointY;
    if (arguments.length) return hull(vertices);
    function hull(data) {
      if (data.length < 3) return [];
      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
      for (i = 0; i < n; i++) {
        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
      }
      points.sort(d3_geom_hullOrder);
      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
      return polygon;
    }
    hull.x = function(_) {
      return arguments.length ? (x = _, hull) : x;
    };
    hull.y = function(_) {
      return arguments.length ? (y = _, hull) : y;
    };
    return hull;
  };
  function d3_geom_hullUpper(points) {
    var n = points.length, hull = [ 0, 1 ], hs = 2;
    for (var i = 2; i < n; i++) {
      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
      hull[hs++] = i;
    }
    return hull.slice(0, hs);
  }
  function d3_geom_hullOrder(a, b) {
    return a[0] - b[0] || a[1] - b[1];
  }
  d3.geom.polygon = function(coordinates) {
    d3_subclass(coordinates, d3_geom_polygonPrototype);
    return coordinates;
  };
  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
  d3_geom_polygonPrototype.area = function() {
    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
    while (++i < n) {
      a = b;
      b = this[i];
      area += a[1] * b[0] - a[0] * b[1];
    }
    return area * .5;
  };
  d3_geom_polygonPrototype.centroid = function(k) {
    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
    if (!arguments.length) k = -1 / (6 * this.area());
    while (++i < n) {
      a = b;
      b = this[i];
      c = a[0] * b[1] - b[0] * a[1];
      x += (a[0] + b[0]) * c;
      y += (a[1] + b[1]) * c;
    }
    return [ x * k, y * k ];
  };
  d3_geom_polygonPrototype.clip = function(subject) {
    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
    while (++i < n) {
      input = subject.slice();
      subject.length = 0;
      b = this[i];
      c = input[(m = input.length - closed) - 1];
      j = -1;
      while (++j < m) {
        d = input[j];
        if (d3_geom_polygonInside(d, a, b)) {
          if (!d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          subject.push(d);
        } else if (d3_geom_polygonInside(c, a, b)) {
          subject.push(d3_geom_polygonIntersect(c, d, a, b));
        }
        c = d;
      }
      if (closed) subject.push(subject[0]);
      a = b;
    }
    return subject;
  };
  function d3_geom_polygonInside(p, a, b) {
    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
  }
  function d3_geom_polygonIntersect(c, d, a, b) {
    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
    return [ x1 + ua * x21, y1 + ua * y21 ];
  }
  function d3_geom_polygonClosed(coordinates) {
    var a = coordinates[0], b = coordinates[coordinates.length - 1];
    return !(a[0] - b[0] || a[1] - b[1]);
  }
  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
  function d3_geom_voronoiBeach() {
    d3_geom_voronoiRedBlackNode(this);
    this.edge = this.site = this.circle = null;
  }
  function d3_geom_voronoiCreateBeach(site) {
    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
    beach.site = site;
    return beach;
  }
  function d3_geom_voronoiDetachBeach(beach) {
    d3_geom_voronoiDetachCircle(beach);
    d3_geom_voronoiBeaches.remove(beach);
    d3_geom_voronoiBeachPool.push(beach);
    d3_geom_voronoiRedBlackNode(beach);
  }
  function d3_geom_voronoiRemoveBeach(beach) {
    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
      x: x,
      y: y
    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
    d3_geom_voronoiDetachBeach(beach);
    var lArc = previous;
    while (lArc.circle && abs(x - lArc.circle.x) <  && abs(y - lArc.circle.cy) < ) {
      previous = lArc.P;
      disappearing.unshift(lArc);
      d3_geom_voronoiDetachBeach(lArc);
      lArc = previous;
    }
    disappearing.unshift(lArc);
    d3_geom_voronoiDetachCircle(lArc);
    var rArc = next;
    while (rArc.circle && abs(x - rArc.circle.x) <  && abs(y - rArc.circle.cy) < ) {
      next = rArc.N;
      disappearing.push(rArc);
      d3_geom_voronoiDetachBeach(rArc);
      rArc = next;
    }
    disappearing.push(rArc);
    d3_geom_voronoiDetachCircle(rArc);
    var nArcs = disappearing.length, iArc;
    for (iArc = 1; iArc < nArcs; ++iArc) {
      rArc = disappearing[iArc];
      lArc = disappearing[iArc - 1];
      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
    }
    lArc = disappearing[0];
    rArc = disappearing[nArcs - 1];
    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiAddBeach(site) {
    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
    while (node) {
      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
      if (dxl > ) node = node.L; else {
        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
        if (dxr > ) {
          if (!node.R) {
            lArc = node;
            break;
          }
          node = node.R;
        } else {
          if (dxl > -) {
            lArc = node.P;
            rArc = node;
          } else if (dxr > -) {
            lArc = node;
            rArc = node.N;
          } else {
            lArc = rArc = node;
          }
          break;
        }
      }
    }
    var newArc = d3_geom_voronoiCreateBeach(site);
    d3_geom_voronoiBeaches.insert(lArc, newArc);
    if (!lArc && !rArc) return;
    if (lArc === rArc) {
      d3_geom_voronoiDetachCircle(lArc);
      rArc = d3_geom_voronoiCreateBeach(lArc.site);
      d3_geom_voronoiBeaches.insert(newArc, rArc);
      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      d3_geom_voronoiAttachCircle(lArc);
      d3_geom_voronoiAttachCircle(rArc);
      return;
    }
    if (!rArc) {
      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      return;
    }
    d3_geom_voronoiDetachCircle(lArc);
    d3_geom_voronoiDetachCircle(rArc);
    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
      x: (cy * hb - by * hc) / d + ax,
      y: (bx * hc - cx * hb) / d + ay
    };
    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
    if (!pby2) return rfocx;
    var lArc = arc.P;
    if (!lArc) return -Infinity;
    site = lArc.site;
    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
    if (!plby2) return lfocx;
    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
    return (rfocx + lfocx) / 2;
  }
  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
    var rArc = arc.N;
    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
    var site = arc.site;
    return site.y === directrix ? site.x : Infinity;
  }
  function d3_geom_voronoiCell(site) {
    this.site = site;
    this.edges = [];
  }
  d3_geom_voronoiCell.prototype.prepare = function() {
    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
    while (iHalfEdge--) {
      edge = halfEdges[iHalfEdge].edge;
      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
    }
    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
    return halfEdges.length;
  };
  function d3_geom_voronoiCloseCells(extent) {
    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
    while (iCell--) {
      cell = cells[iCell];
      if (!cell || !cell.prepare()) continue;
      halfEdges = cell.edges;
      nHalfEdges = halfEdges.length;
      iHalfEdge = 0;
      while (iHalfEdge < nHalfEdges) {
        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
        if (abs(x3 - x2) >  || abs(y3 - y2) > ) {
          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) <  && y1 - y3 >  ? {
            x: x0,
            y: abs(x2 - x0) <  ? y2 : y1
          } : abs(y3 - y1) <  && x1 - x3 >  ? {
            x: abs(y2 - y1) <  ? x2 : x1,
            y: y1
          } : abs(x3 - x1) <  && y3 - y0 >  ? {
            x: x1,
            y: abs(x2 - x1) <  ? y2 : y0
          } : abs(y3 - y0) <  && x3 - x0 >  ? {
            x: abs(y2 - y0) <  ? x2 : x0,
            y: y0
          } : null), cell.site, null));
          ++nHalfEdges;
        }
      }
    }
  }
  function d3_geom_voronoiHalfEdgeOrder(a, b) {
    return b.angle - a.angle;
  }
  function d3_geom_voronoiCircle() {
    d3_geom_voronoiRedBlackNode(this);
    this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function d3_geom_voronoiAttachCircle(arc) {
    var lArc = arc.P, rArc = arc.N;
    if (!lArc || !rArc) return;
    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
    if (lSite === rSite) return;
    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
    var d = 2 * (ax * cy - ay * cx);
    if (d >= -2) return;
    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
    circle.arc = arc;
    circle.site = cSite;
    circle.x = x + bx;
    circle.y = cy + Math.sqrt(x * x + y * y);
    circle.cy = cy;
    arc.circle = circle;
    var before = null, node = d3_geom_voronoiCircles._;
    while (node) {
      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
        if (node.L) node = node.L; else {
          before = node.P;
          break;
        }
      } else {
        if (node.R) node = node.R; else {
          before = node;
          break;
        }
      }
    }
    d3_geom_voronoiCircles.insert(before, circle);
    if (!before) d3_geom_voronoiFirstCircle = circle;
  }
  function d3_geom_voronoiDetachCircle(arc) {
    var circle = arc.circle;
    if (circle) {
      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
      d3_geom_voronoiCircles.remove(circle);
      d3_geom_voronoiCirclePool.push(circle);
      d3_geom_voronoiRedBlackNode(circle);
      arc.circle = null;
    }
  }
  function d3_geom_voronoiClipEdges(extent) {
    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
    while (i--) {
      e = edges[i];
      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) <  && abs(e.a.y - e.b.y) < ) {
        e.a = e.b = null;
        edges.splice(i, 1);
      }
    }
  }
  function d3_geom_voronoiConnectEdge(edge, extent) {
    var vb = edge.b;
    if (vb) return true;
    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
    if (ry === ly) {
      if (fx < x0 || fx >= x1) return;
      if (lx > rx) {
        if (!va) va = {
          x: fx,
          y: y0
        }; else if (va.y >= y1) return;
        vb = {
          x: fx,
          y: y1
        };
      } else {
        if (!va) va = {
          x: fx,
          y: y1
        }; else if (va.y < y0) return;
        vb = {
          x: fx,
          y: y0
        };
      }
    } else {
      fm = (lx - rx) / (ry - ly);
      fb = fy - fm * fx;
      if (fm < -1 || fm > 1) {
        if (lx > rx) {
          if (!va) va = {
            x: (y0 - fb) / fm,
            y: y0
          }; else if (va.y >= y1) return;
          vb = {
            x: (y1 - fb) / fm,
            y: y1
          };
        } else {
          if (!va) va = {
            x: (y1 - fb) / fm,
            y: y1
          }; else if (va.y < y0) return;
          vb = {
            x: (y0 - fb) / fm,
            y: y0
          };
        }
      } else {
        if (ly < ry) {
          if (!va) va = {
            x: x0,
            y: fm * x0 + fb
          }; else if (va.x >= x1) return;
          vb = {
            x: x1,
            y: fm * x1 + fb
          };
        } else {
          if (!va) va = {
            x: x1,
            y: fm * x1 + fb
          }; else if (va.x < x0) return;
          vb = {
            x: x0,
            y: fm * x0 + fb
          };
        }
      }
    }
    edge.a = va;
    edge.b = vb;
    return true;
  }
  function d3_geom_voronoiEdge(lSite, rSite) {
    this.l = lSite;
    this.r = rSite;
    this.a = this.b = null;
  }
  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, rSite);
    d3_geom_voronoiEdges.push(edge);
    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
    return edge;
  }
  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, null);
    edge.a = va;
    edge.b = vb;
    d3_geom_voronoiEdges.push(edge);
    return edge;
  }
  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
    if (!edge.a && !edge.b) {
      edge.a = vertex;
      edge.l = lSite;
      edge.r = rSite;
    } else if (edge.l === rSite) {
      edge.b = vertex;
    } else {
      edge.a = vertex;
    }
  }
  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
    var va = edge.a, vb = edge.b;
    this.edge = edge;
    this.site = lSite;
    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
  }
  d3_geom_voronoiHalfEdge.prototype = {
    start: function() {
      return this.edge.l === this.site ? this.edge.a : this.edge.b;
    },
    end: function() {
      return this.edge.l === this.site ? this.edge.b : this.edge.a;
    }
  };
  function d3_geom_voronoiRedBlackTree() {
    this._ = null;
  }
  function d3_geom_voronoiRedBlackNode(node) {
    node.U = node.C = node.L = node.R = node.P = node.N = null;
  }
  d3_geom_voronoiRedBlackTree.prototype = {
    insert: function(after, node) {
      var parent, grandpa, uncle;
      if (after) {
        node.P = after;
        node.N = after.N;
        if (after.N) after.N.P = node;
        after.N = node;
        if (after.R) {
          after = after.R;
          while (after.L) after = after.L;
          after.L = node;
        } else {
          after.R = node;
        }
        parent = after;
      } else if (this._) {
        after = d3_geom_voronoiRedBlackFirst(this._);
        node.P = null;
        node.N = after;
        after.P = after.L = node;
        parent = after;
      } else {
        node.P = node.N = null;
        this._ = node;
        parent = null;
      }
      node.L = node.R = null;
      node.U = parent;
      node.C = true;
      after = node;
      while (parent && parent.C) {
        grandpa = parent.U;
        if (parent === grandpa.L) {
          uncle = grandpa.R;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.R) {
              d3_geom_voronoiRedBlackRotateLeft(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
          }
        } else {
          uncle = grandpa.L;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.L) {
              d3_geom_voronoiRedBlackRotateRight(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
          }
        }
        parent = after.U;
      }
      this._.C = false;
    },
    remove: function(node) {
      if (node.N) node.N.P = node.P;
      if (node.P) node.P.N = node.N;
      node.N = node.P = null;
      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
      if (parent) {
        if (parent.L === node) parent.L = next; else parent.R = next;
      } else {
        this._ = next;
      }
      if (left && right) {
        red = next.C;
        next.C = node.C;
        next.L = left;
        left.U = next;
        if (next !== right) {
          parent = next.U;
          next.U = node.U;
          node = next.R;
          parent.L = node;
          next.R = right;
          right.U = next;
        } else {
          next.U = parent;
          parent = next;
          node = next.R;
        }
      } else {
        red = node.C;
        node = next;
      }
      if (node) node.U = parent;
      if (red) return;
      if (node && node.C) {
        node.C = false;
        return;
      }
      do {
        if (node === this._) break;
        if (node === parent.L) {
          sibling = parent.R;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            sibling = parent.R;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.R || !sibling.R.C) {
              sibling.L.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateRight(this, sibling);
              sibling = parent.R;
            }
            sibling.C = parent.C;
            parent.C = sibling.R.C = false;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            node = this._;
            break;
          }
        } else {
          sibling = parent.L;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            sibling = parent.L;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.L || !sibling.L.C) {
              sibling.R.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
              sibling = parent.L;
            }
            sibling.C = parent.C;
            parent.C = sibling.L.C = false;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            node = this._;
            break;
          }
        }
        sibling.C = true;
        node = parent;
        parent = parent.U;
      } while (!node.C);
      if (node) node.C = false;
    }
  };
  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
    var p = node, q = node.R, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.R = q.L;
    if (p.R) p.R.U = p;
    q.L = p;
  }
  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
    var p = node, q = node.L, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.L = q.R;
    if (p.L) p.L.U = p;
    q.R = p;
  }
  function d3_geom_voronoiRedBlackFirst(node) {
    while (node.L) node = node.L;
    return node;
  }
  function d3_geom_voronoi(sites, bbox) {
    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
    d3_geom_voronoiEdges = [];
    d3_geom_voronoiCells = new Array(sites.length);
    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
    while (true) {
      circle = d3_geom_voronoiFirstCircle;
      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
        if (site.x !== x0 || site.y !== y0) {
          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
          d3_geom_voronoiAddBeach(site);
          x0 = site.x, y0 = site.y;
        }
        site = sites.pop();
      } else if (circle) {
        d3_geom_voronoiRemoveBeach(circle.arc);
      } else {
        break;
      }
    }
    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
    var diagram = {
      cells: d3_geom_voronoiCells,
      edges: d3_geom_voronoiEdges
    };
    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
    return diagram;
  }
  function d3_geom_voronoiVertexOrder(a, b) {
    return b.y - a.y || b.x - a.x;
  }
  d3.geom.voronoi = function(points) {
    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
    if (points) return voronoi(points);
    function voronoi(data) {
      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
          var s = e.start();
          return [ s.x, s.y ];
        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
        polygon.point = data[i];
      });
      return polygons;
    }
    function sites(data) {
      return data.map(function(d, i) {
        return {
          x: Math.round(fx(d, i) / ) * ,
          y: Math.round(fy(d, i) / ) * ,
          i: i
        };
      });
    }
    voronoi.links = function(data) {
      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
        return edge.l && edge.r;
      }).map(function(edge) {
        return {
          source: data[edge.l.i],
          target: data[edge.r.i]
        };
      });
    };
    voronoi.triangles = function(data) {
      var triangles = [];
      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
        while (++j < m) {
          e0 = e1;
          s0 = s1;
          e1 = edges[j].edge;
          s1 = e1.l === site ? e1.r : e1.l;
          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
          }
        }
      });
      return triangles;
    };
    voronoi.x = function(_) {
      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
    };
    voronoi.y = function(_) {
      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
    };
    voronoi.clipExtent = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
      return voronoi;
    };
    voronoi.size = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
    };
    return voronoi;
  };
  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
  function d3_geom_voronoiTriangleArea(a, b, c) {
    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
  }
  d3.geom.delaunay = function(vertices) {
    return d3.geom.voronoi().triangles(vertices);
  };
  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
    if (compat = arguments.length) {
      x = d3_geom_quadtreeCompatX;
      y = d3_geom_quadtreeCompatY;
      if (compat === 3) {
        y2 = y1;
        x2 = x1;
        y1 = x1 = 0;
      }
      return quadtree(points);
    }
    function quadtree(data) {
      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
      if (x1 != null) {
        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
      } else {
        x2_ = y2_ = -(x1_ = y1_ = Infinity);
        xs = [], ys = [];
        n = data.length;
        if (compat) for (i = 0; i < n; ++i) {
          d = data[i];
          if (d.x < x1_) x1_ = d.x;
          if (d.y < y1_) y1_ = d.y;
          if (d.x > x2_) x2_ = d.x;
          if (d.y > y2_) y2_ = d.y;
          xs.push(d.x);
          ys.push(d.y);
        } else for (i = 0; i < n; ++i) {
          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
          if (x_ < x1_) x1_ = x_;
          if (y_ < y1_) y1_ = y_;
          if (x_ > x2_) x2_ = x_;
          if (y_ > y2_) y2_ = y_;
          xs.push(x_);
          ys.push(y_);
        }
      }
      var dx = x2_ - x1_, dy = y2_ - y1_;
      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
      function insert(n, d, x, y, x1, y1, x2, y2) {
        if (isNaN(x) || isNaN(y)) return;
        if (n.leaf) {
          var nx = n.x, ny = n.y;
          if (nx != null) {
            if (abs(nx - x) + abs(ny - y) < .01) {
              insertChild(n, d, x, y, x1, y1, x2, y2);
            } else {
              var nPoint = n.point;
              n.x = n.y = n.point = null;
              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
              insertChild(n, d, x, y, x1, y1, x2, y2);
            }
          } else {
            n.x = x, n.y = y, n.point = d;
          }
        } else {
          insertChild(n, d, x, y, x1, y1, x2, y2);
        }
      }
      function insertChild(n, d, x, y, x1, y1, x2, y2) {
        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
        n.leaf = false;
        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
        if (right) x1 = xm; else x2 = xm;
        if (below) y1 = ym; else y2 = ym;
        insert(n, d, x, y, x1, y1, x2, y2);
      }
      var root = d3_geom_quadtreeNode();
      root.add = function(d) {
        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
      };
      root.visit = function(f) {
        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
      };
      root.find = function(point) {
        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
      };
      i = -1;
      if (x1 == null) {
        while (++i < n) {
          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
        }
        --i;
      } else data.forEach(root.add);
      xs = ys = data = d = null;
      return root;
    }
    quadtree.x = function(_) {
      return arguments.length ? (x = _, quadtree) : x;
    };
    quadtree.y = function(_) {
      return arguments.length ? (y = _, quadtree) : y;
    };
    quadtree.extent = function(_) {
      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
      y2 = +_[1][1];
      return quadtree;
    };
    quadtree.size = function(_) {
      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
      return quadtree;
    };
    return quadtree;
  };
  function d3_geom_quadtreeCompatX(d) {
    return d.x;
  }
  function d3_geom_quadtreeCompatY(d) {
    return d.y;
  }
  function d3_geom_quadtreeNode() {
    return {
      leaf: true,
      nodes: [],
      point: null,
      x: null,
      y: null
    };
  }
  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
    if (!f(node, x1, y1, x2, y2)) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
    }
  }
  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
    var minDistance2 = Infinity, closestPoint;
    (function find(node, x1, y1, x2, y2) {
      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
      if (point = node.point) {
        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
        if (distance2 < minDistance2) {
          var distance = Math.sqrt(minDistance2 = distance2);
          x0 = x - distance, y0 = y - distance;
          x3 = x + distance, y3 = y + distance;
          closestPoint = point;
        }
      }
      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
        if (node = children[i & 3]) switch (i & 3) {
         case 0:
          find(node, x1, y1, xm, ym);
          break;

         case 1:
          find(node, xm, y1, x2, ym);
          break;

         case 2:
          find(node, x1, ym, xm, y2);
          break;

         case 3:
          find(node, xm, ym, x2, y2);
          break;
        }
      }
    })(root, x0, y0, x3, y3);
    return closestPoint;
  }
  d3.interpolateRgb = d3_interpolateRgb;
  function d3_interpolateRgb(a, b) {
    a = d3.rgb(a);
    b = d3.rgb(b);
    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
    return function(t) {
      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
    };
  }
  d3.interpolateObject = d3_interpolateObject;
  function d3_interpolateObject(a, b) {
    var i = {}, c = {}, k;
    for (k in a) {
      if (k in b) {
        i[k] = d3_interpolate(a[k], b[k]);
      } else {
        c[k] = a[k];
      }
    }
    for (k in b) {
      if (!(k in a)) {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }
  d3.interpolateNumber = d3_interpolateNumber;
  function d3_interpolateNumber(a, b) {
    a = +a, b = +b;
    return function(t) {
      return a * (1 - t) + b * t;
    };
  }
  d3.interpolateString = d3_interpolateString;
  function d3_interpolateString(a, b) {
    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
    a = a + "", b = b + "";
    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs; else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i]) s[i] += bm; else s[++i] = bm;
      } else {
        s[++i] = null;
        q.push({
          i: i,
          x: d3_interpolateNumber(am, bm)
        });
      }
      bi = d3_interpolate_numberB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs; else s[++i] = bs;
    }
    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
      return b(t) + "";
    }) : function() {
      return b;
    } : (b = q.length, function(t) {
      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    });
  }
  var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
  d3.interpolate = d3_interpolate;
  function d3_interpolate(a, b) {
    var i = d3.interpolators.length, f;
    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
    return f;
  }
  d3.interpolators = [ function(a, b) {
    var t = typeof b;
    return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
  } ];
  d3.interpolateArray = d3_interpolateArray;
  function d3_interpolateArray(a, b) {
    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
    for (;i < na; ++i) c[i] = a[i];
    for (;i < nb; ++i) c[i] = b[i];
    return function(t) {
      for (i = 0; i < n0; ++i) c[i] = x[i](t);
      return c;
    };
  }
  var d3_ease_default = function() {
    return d3_identity;
  };
  var d3_ease = d3.map({
    linear: d3_ease_default,
    poly: d3_ease_poly,
    quad: function() {
      return d3_ease_quad;
    },
    cubic: function() {
      return d3_ease_cubic;
    },
    sin: function() {
      return d3_ease_sin;
    },
    exp: function() {
      return d3_ease_exp;
    },
    circle: function() {
      return d3_ease_circle;
    },
    elastic: d3_ease_elastic,
    back: d3_ease_back,
    bounce: function() {
      return d3_ease_bounce;
    }
  });
  var d3_ease_mode = d3.map({
    "in": d3_identity,
    out: d3_ease_reverse,
    "in-out": d3_ease_reflect,
    "out-in": function(f) {
      return d3_ease_reflect(d3_ease_reverse(f));
    }
  });
  d3.ease = function(name) {
    var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
    t = d3_ease.get(t) || d3_ease_default;
    m = d3_ease_mode.get(m) || d3_identity;
    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
  };
  function d3_ease_clamp(f) {
    return function(t) {
      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
    };
  }
  function d3_ease_reverse(f) {
    return function(t) {
      return 1 - f(1 - t);
    };
  }
  function d3_ease_reflect(f) {
    return function(t) {
      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
    };
  }
  function d3_ease_quad(t) {
    return t * t;
  }
  function d3_ease_cubic(t) {
    return t * t * t;
  }
  function d3_ease_cubicInOut(t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t, t3 = t2 * t;
    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
  }
  function d3_ease_poly(e) {
    return function(t) {
      return Math.pow(t, e);
    };
  }
  function d3_ease_sin(t) {
    return 1 - Math.cos(t * half);
  }
  function d3_ease_exp(t) {
    return Math.pow(2, 10 * (t - 1));
  }
  function d3_ease_circle(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function d3_ease_elastic(a, p) {
    var s;
    if (arguments.length < 2) p = .45;
    if (arguments.length) s = p /  * Math.asin(1 / a); else a = 1, s = p / 4;
    return function(t) {
      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) *  / p);
    };
  }
  function d3_ease_back(s) {
    if (!s) s = 1.70158;
    return function(t) {
      return t * t * ((s + 1) * t - s);
    };
  }
  function d3_ease_bounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
  }
  d3.interpolateHcl = d3_interpolateHcl;
  function d3_interpolateHcl(a, b) {
    a = d3.hcl(a);
    b = d3.hcl(b);
    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
    };
  }
  d3.interpolateHsl = d3_interpolateHsl;
  function d3_interpolateHsl(a, b) {
    a = d3.hsl(a);
    b = d3.hsl(b);
    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
    };
  }
  d3.interpolateLab = d3_interpolateLab;
  function d3_interpolateLab(a, b) {
    a = d3.lab(a);
    b = d3.lab(b);
    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
    return function(t) {
      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
    };
  }
  d3.interpolateRound = d3_interpolateRound;
  function d3_interpolateRound(a, b) {
    b -= a;
    return function(t) {
      return Math.round(a + b * t);
    };
  }
  d3.transform = function(string) {
    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
    return (d3.transform = function(string) {
      if (string != null) {
        g.setAttribute("transform", string);
        var t = g.transform.baseVal.consolidate();
      }
      return new d3_transform(t ? t.matrix : d3_transformIdentity);
    })(string);
  };
  function d3_transform(m) {
    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
    if (r0[0] * r1[1] < r1[0] * r0[1]) {
      r0[0] *= -1;
      r0[1] *= -1;
      kx *= -1;
      kz *= -1;
    }
    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
    this.translate = [ m.e, m.f ];
    this.scale = [ kx, ky ];
    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
  }
  d3_transform.prototype.toString = function() {
    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
  };
  function d3_transformDot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  function d3_transformNormalize(a) {
    var k = Math.sqrt(d3_transformDot(a, a));
    if (k) {
      a[0] /= k;
      a[1] /= k;
    }
    return k;
  }
  function d3_transformCombine(a, b, k) {
    a[0] += k * b[0];
    a[1] += k * b[1];
    return a;
  }
  var d3_transformIdentity = {
    a: 1,
    b: 0,
    c: 0,
    d: 1,
    e: 0,
    f: 0
  };
  d3.interpolateTransform = d3_interpolateTransform;
  function d3_interpolateTransformPop(s) {
    return s.length ? s.pop() + "," : "";
  }
  function d3_interpolateTranslate(ta, tb, s, q) {
    if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
      var i = s.push("translate(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: d3_interpolateNumber(ta[0], tb[0])
      }, {
        i: i - 2,
        x: d3_interpolateNumber(ta[1], tb[1])
      });
    } else if (tb[0] || tb[1]) {
      s.push("translate(" + tb + ")");
    }
  }
  function d3_interpolateRotate(ra, rb, s, q) {
    if (ra !== rb) {
      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
      q.push({
        i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,
        x: d3_interpolateNumber(ra, rb)
      });
    } else if (rb) {
      s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");
    }
  }
  function d3_interpolateSkew(wa, wb, s, q) {
    if (wa !== wb) {
      q.push({
        i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,
        x: d3_interpolateNumber(wa, wb)
      });
    } else if (wb) {
      s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");
    }
  }
  function d3_interpolateScale(ka, kb, s, q) {
    if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
      var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: d3_interpolateNumber(ka[0], kb[0])
      }, {
        i: i - 2,
        x: d3_interpolateNumber(ka[1], kb[1])
      });
    } else if (kb[0] !== 1 || kb[1] !== 1) {
      s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");
    }
  }
  function d3_interpolateTransform(a, b) {
    var s = [], q = [];
    a = d3.transform(a), b = d3.transform(b);
    d3_interpolateTranslate(a.translate, b.translate, s, q);
    d3_interpolateRotate(a.rotate, b.rotate, s, q);
    d3_interpolateSkew(a.skew, b.skew, s, q);
    d3_interpolateScale(a.scale, b.scale, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  }
  function d3_uninterpolateNumber(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return (x - a) / b;
    };
  }
  function d3_uninterpolateClamp(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return Math.max(0, Math.min(1, (x - a) / b));
    };
  }
  d3.layout = {};
  d3.layout.bundle = function() {
    return function(links) {
      var paths = [], i = -1, n = links.length;
      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
      return paths;
    };
  };
  function d3_layout_bundlePath(link) {
    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
    while (start !== lca) {
      start = start.parent;
      points.push(start);
    }
    var k = points.length;
    while (end !== lca) {
      points.splice(k, 0, end);
      end = end.parent;
    }
    return points;
  }
  function d3_layout_bundleAncestors(node) {
    var ancestors = [], parent = node.parent;
    while (parent != null) {
      ancestors.push(node);
      node = parent;
      parent = parent.parent;
    }
    ancestors.push(node);
    return ancestors;
  }
  function d3_layout_bundleLeastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
    while (aNode === bNode) {
      sharedNode = aNode;
      aNode = aNodes.pop();
      bNode = bNodes.pop();
    }
    return sharedNode;
  }
  d3.layout.chord = function() {
    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
    function relayout() {
      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
      chords = [];
      groups = [];
      k = 0, i = -1;
      while (++i < n) {
        x = 0, j = -1;
        while (++j < n) {
          x += matrix[i][j];
        }
        groupSums.push(x);
        subgroupIndex.push(d3.range(n));
        k += x;
      }
      if (sortGroups) {
        groupIndex.sort(function(a, b) {
          return sortGroups(groupSums[a], groupSums[b]);
        });
      }
      if (sortSubgroups) {
        subgroupIndex.forEach(function(d, i) {
          d.sort(function(a, b) {
            return sortSubgroups(matrix[i][a], matrix[i][b]);
          });
        });
      }
      k = ( - padding * n) / k;
      x = 0, i = -1;
      while (++i < n) {
        x0 = x, j = -1;
        while (++j < n) {
          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
          subgroups[di + "-" + dj] = {
            index: di,
            subindex: dj,
            startAngle: a0,
            endAngle: a1,
            value: v
          };
        }
        groups[di] = {
          index: di,
          startAngle: x0,
          endAngle: x,
          value: groupSums[di]
        };
        x += padding;
      }
      i = -1;
      while (++i < n) {
        j = i - 1;
        while (++j < n) {
          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
          if (source.value || target.value) {
            chords.push(source.value < target.value ? {
              source: target,
              target: source
            } : {
              source: source,
              target: target
            });
          }
        }
      }
      if (sortChords) resort();
    }
    function resort() {
      chords.sort(function(a, b) {
        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
      });
    }
    chord.matrix = function(x) {
      if (!arguments.length) return matrix;
      n = (matrix = x) && matrix.length;
      chords = groups = null;
      return chord;
    };
    chord.padding = function(x) {
      if (!arguments.length) return padding;
      padding = x;
      chords = groups = null;
      return chord;
    };
    chord.sortGroups = function(x) {
      if (!arguments.length) return sortGroups;
      sortGroups = x;
      chords = groups = null;
      return chord;
    };
    chord.sortSubgroups = function(x) {
      if (!arguments.length) return sortSubgroups;
      sortSubgroups = x;
      chords = null;
      return chord;
    };
    chord.sortChords = function(x) {
      if (!arguments.length) return sortChords;
      sortChords = x;
      if (chords) resort();
      return chord;
    };
    chord.chords = function() {
      if (!chords) relayout();
      return chords;
    };
    chord.groups = function() {
      if (!groups) relayout();
      return groups;
    };
    return chord;
  };
  d3.layout.force = function() {
    var force = {}, event = d3.dispatch("start", "tick", "end"), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
    function repulse(node) {
      return function(quad, x1, _, x2) {
        if (quad.point !== node) {
          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
          if (dw * dw / theta2 < dn) {
            if (dn < chargeDistance2) {
              var k = quad.charge / dn;
              node.px -= dx * k;
              node.py -= dy * k;
            }
            return true;
          }
          if (quad.point && dn && dn < chargeDistance2) {
            var k = quad.pointCharge / dn;
            node.px -= dx * k;
            node.py -= dy * k;
          }
        }
        return !quad.charge;
      };
    }
    force.tick = function() {
      if ((alpha *= .99) < .005) {
        timer = null;
        event.end({
          type: "end",
          alpha: alpha = 0
        });
        return true;
      }
      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
      for (i = 0; i < m; ++i) {
        o = links[i];
        s = o.source;
        t = o.target;
        x = t.x - s.x;
        y = t.y - s.y;
        if (l = x * x + y * y) {
          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
          x *= l;
          y *= l;
          t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);
          t.y -= y * k;
          s.x += x * (k = 1 - k);
          s.y += y * k;
        }
      }
      if (k = alpha * gravity) {
        x = size[0] / 2;
        y = size[1] / 2;
        i = -1;
        if (k) while (++i < n) {
          o = nodes[i];
          o.x += (x - o.x) * k;
          o.y += (y - o.y) * k;
        }
      }
      if (charge) {
        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
        i = -1;
        while (++i < n) {
          if (!(o = nodes[i]).fixed) {
            q.visit(repulse(o));
          }
        }
      }
      i = -1;
      while (++i < n) {
        o = nodes[i];
        if (o.fixed) {
          o.x = o.px;
          o.y = o.py;
        } else {
          o.x -= (o.px - (o.px = o.x)) * friction;
          o.y -= (o.py - (o.py = o.y)) * friction;
        }
      }
      event.tick({
        type: "tick",
        alpha: alpha
      });
    };
    force.nodes = function(x) {
      if (!arguments.length) return nodes;
      nodes = x;
      return force;
    };
    force.links = function(x) {
      if (!arguments.length) return links;
      links = x;
      return force;
    };
    force.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return force;
    };
    force.linkDistance = function(x) {
      if (!arguments.length) return linkDistance;
      linkDistance = typeof x === "function" ? x : +x;
      return force;
    };
    force.distance = force.linkDistance;
    force.linkStrength = function(x) {
      if (!arguments.length) return linkStrength;
      linkStrength = typeof x === "function" ? x : +x;
      return force;
    };
    force.friction = function(x) {
      if (!arguments.length) return friction;
      friction = +x;
      return force;
    };
    force.charge = function(x) {
      if (!arguments.length) return charge;
      charge = typeof x === "function" ? x : +x;
      return force;
    };
    force.chargeDistance = function(x) {
      if (!arguments.length) return Math.sqrt(chargeDistance2);
      chargeDistance2 = x * x;
      return force;
    };
    force.gravity = function(x) {
      if (!arguments.length) return gravity;
      gravity = +x;
      return force;
    };
    force.theta = function(x) {
      if (!arguments.length) return Math.sqrt(theta2);
      theta2 = x * x;
      return force;
    };
    force.alpha = function(x) {
      if (!arguments.length) return alpha;
      x = +x;
      if (alpha) {
        if (x > 0) {
          alpha = x;
        } else {
          timer.c = null, timer.t = NaN, timer = null;
          event.end({
            type: "end",
            alpha: alpha = 0
          });
        }
      } else if (x > 0) {
        event.start({
          type: "start",
          alpha: alpha = x
        });
        timer = d3_timer(force.tick);
      }
      return force;
    };
    force.start = function() {
      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
      for (i = 0; i < n; ++i) {
        (o = nodes[i]).index = i;
        o.weight = 0;
      }
      for (i = 0; i < m; ++i) {
        o = links[i];
        if (typeof o.source == "number") o.source = nodes[o.source];
        if (typeof o.target == "number") o.target = nodes[o.target];
        ++o.source.weight;
        ++o.target.weight;
      }
      for (i = 0; i < n; ++i) {
        o = nodes[i];
        if (isNaN(o.x)) o.x = position("x", w);
        if (isNaN(o.y)) o.y = position("y", h);
        if (isNaN(o.px)) o.px = o.x;
        if (isNaN(o.py)) o.py = o.y;
      }
      distances = [];
      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
      strengths = [];
      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
      charges = [];
      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
      function position(dimension, size) {
        if (!neighbors) {
          neighbors = new Array(n);
          for (j = 0; j < n; ++j) {
            neighbors[j] = [];
          }
          for (j = 0; j < m; ++j) {
            var o = links[j];
            neighbors[o.source.index].push(o.target);
            neighbors[o.target.index].push(o.source);
          }
        }
        var candidates = neighbors[i], j = -1, l = candidates.length, x;
        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
        return Math.random() * size;
      }
      return force.resume();
    };
    force.resume = function() {
      return force.alpha(.1);
    };
    force.stop = function() {
      return force.alpha(0);
    };
    force.drag = function() {
      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
      if (!arguments.length) return drag;
      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
    };
    function dragmove(d) {
      d.px = d3.event.x, d.py = d3.event.y;
      force.resume();
    }
    return d3.rebind(force, event, "on");
  };
  function d3_layout_forceDragstart(d) {
    d.fixed |= 2;
  }
  function d3_layout_forceDragend(d) {
    d.fixed &= ~6;
  }
  function d3_layout_forceMouseover(d) {
    d.fixed |= 4;
    d.px = d.x, d.py = d.y;
  }
  function d3_layout_forceMouseout(d) {
    d.fixed &= ~4;
  }
  function d3_layout_forceAccumulate(quad, alpha, charges) {
    var cx = 0, cy = 0;
    quad.charge = 0;
    if (!quad.leaf) {
      var nodes = quad.nodes, n = nodes.length, i = -1, c;
      while (++i < n) {
        c = nodes[i];
        if (c == null) continue;
        d3_layout_forceAccumulate(c, alpha, charges);
        quad.charge += c.charge;
        cx += c.charge * c.cx;
        cy += c.charge * c.cy;
      }
    }
    if (quad.point) {
      if (!quad.leaf) {
        quad.point.x += Math.random() - .5;
        quad.point.y += Math.random() - .5;
      }
      var k = alpha * charges[quad.point.index];
      quad.charge += quad.pointCharge = k;
      cx += k * quad.point.x;
      cy += k * quad.point.y;
    }
    quad.cx = cx / quad.charge;
    quad.cy = cy / quad.charge;
  }
  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
  d3.layout.hierarchy = function() {
    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
    function hierarchy(root) {
      var stack = [ root ], nodes = [], node;
      root.depth = 0;
      while ((node = stack.pop()) != null) {
        nodes.push(node);
        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
          var n, childs, child;
          while (--n >= 0) {
            stack.push(child = childs[n]);
            child.parent = node;
            child.depth = node.depth + 1;
          }
          if (value) node.value = 0;
          node.children = childs;
        } else {
          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
          delete node.children;
        }
      }
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var childs, parent;
        if (sort && (childs = node.children)) childs.sort(sort);
        if (value && (parent = node.parent)) parent.value += node.value;
      });
      return nodes;
    }
    hierarchy.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return hierarchy;
    };
    hierarchy.children = function(x) {
      if (!arguments.length) return children;
      children = x;
      return hierarchy;
    };
    hierarchy.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return hierarchy;
    };
    hierarchy.revalue = function(root) {
      if (value) {
        d3_layout_hierarchyVisitBefore(root, function(node) {
          if (node.children) node.value = 0;
        });
        d3_layout_hierarchyVisitAfter(root, function(node) {
          var parent;
          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
          if (parent = node.parent) parent.value += node.value;
        });
      }
      return root;
    };
    return hierarchy;
  };
  function d3_layout_hierarchyRebind(object, hierarchy) {
    d3.rebind(object, hierarchy, "sort", "children", "value");
    object.nodes = object;
    object.links = d3_layout_hierarchyLinks;
    return object;
  }
  function d3_layout_hierarchyVisitBefore(node, callback) {
    var nodes = [ node ];
    while ((node = nodes.pop()) != null) {
      callback(node);
      if ((children = node.children) && (n = children.length)) {
        var n, children;
        while (--n >= 0) nodes.push(children[n]);
      }
    }
  }
  function d3_layout_hierarchyVisitAfter(node, callback) {
    var nodes = [ node ], nodes2 = [];
    while ((node = nodes.pop()) != null) {
      nodes2.push(node);
      if ((children = node.children) && (n = children.length)) {
        var i = -1, n, children;
        while (++i < n) nodes.push(children[i]);
      }
    }
    while ((node = nodes2.pop()) != null) {
      callback(node);
    }
  }
  function d3_layout_hierarchyChildren(d) {
    return d.children;
  }
  function d3_layout_hierarchyValue(d) {
    return d.value;
  }
  function d3_layout_hierarchySort(a, b) {
    return b.value - a.value;
  }
  function d3_layout_hierarchyLinks(nodes) {
    return d3.merge(nodes.map(function(parent) {
      return (parent.children || []).map(function(child) {
        return {
          source: parent,
          target: child
        };
      });
    }));
  }
  d3.layout.partition = function() {
    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
    function position(node, x, dx, dy) {
      var children = node.children;
      node.x = x;
      node.y = node.depth * dy;
      node.dx = dx;
      node.dy = dy;
      if (children && (n = children.length)) {
        var i = -1, n, c, d;
        dx = node.value ? dx / node.value : 0;
        while (++i < n) {
          position(c = children[i], x, d = c.value * dx, dy);
          x += d;
        }
      }
    }
    function depth(node) {
      var children = node.children, d = 0;
      if (children && (n = children.length)) {
        var i = -1, n;
        while (++i < n) d = Math.max(d, depth(children[i]));
      }
      return 1 + d;
    }
    function partition(d, i) {
      var nodes = hierarchy.call(this, d, i);
      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
      return nodes;
    }
    partition.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return partition;
    };
    return d3_layout_hierarchyRebind(partition, hierarchy);
  };
  d3.layout.pie = function() {
    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = , padAngle = 0;
    function pie(data) {
      var n = data.length, values = data.map(function(d, i) {
        return +value.call(pie, d, i);
      }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;
      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
        return values[j] - values[i];
      } : function(i, j) {
        return sort(data[i], data[j]);
      });
      index.forEach(function(i) {
        arcs[i] = {
          data: data[i],
          value: v = values[i],
          startAngle: a,
          endAngle: a += v * k + pa,
          padAngle: p
        };
      });
      return arcs;
    }
    pie.value = function(_) {
      if (!arguments.length) return value;
      value = _;
      return pie;
    };
    pie.sort = function(_) {
      if (!arguments.length) return sort;
      sort = _;
      return pie;
    };
    pie.startAngle = function(_) {
      if (!arguments.length) return startAngle;
      startAngle = _;
      return pie;
    };
    pie.endAngle = function(_) {
      if (!arguments.length) return endAngle;
      endAngle = _;
      return pie;
    };
    pie.padAngle = function(_) {
      if (!arguments.length) return padAngle;
      padAngle = _;
      return pie;
    };
    return pie;
  };
  var d3_layout_pieSortByValue = {};
  d3.layout.stack = function() {
    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
    function stack(data, index) {
      if (!(n = data.length)) return data;
      var series = data.map(function(d, i) {
        return values.call(stack, d, i);
      });
      var points = series.map(function(d) {
        return d.map(function(v, i) {
          return [ x.call(stack, v, i), y.call(stack, v, i) ];
        });
      });
      var orders = order.call(stack, points, index);
      series = d3.permute(series, orders);
      points = d3.permute(points, orders);
      var offsets = offset.call(stack, points, index);
      var m = series[0].length, n, i, j, o;
      for (j = 0; j < m; ++j) {
        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
        for (i = 1; i < n; ++i) {
          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
        }
      }
      return data;
    }
    stack.values = function(x) {
      if (!arguments.length) return values;
      values = x;
      return stack;
    };
    stack.order = function(x) {
      if (!arguments.length) return order;
      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
      return stack;
    };
    stack.offset = function(x) {
      if (!arguments.length) return offset;
      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
      return stack;
    };
    stack.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      return stack;
    };
    stack.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      return stack;
    };
    stack.out = function(z) {
      if (!arguments.length) return out;
      out = z;
      return stack;
    };
    return stack;
  };
  function d3_layout_stackX(d) {
    return d.x;
  }
  function d3_layout_stackY(d) {
    return d.y;
  }
  function d3_layout_stackOut(d, y0, y) {
    d.y0 = y0;
    d.y = y;
  }
  var d3_layout_stackOrders = d3.map({
    "inside-out": function(data) {
      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
        return max[a] - max[b];
      }), top = 0, bottom = 0, tops = [], bottoms = [];
      for (i = 0; i < n; ++i) {
        j = index[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }
      return bottoms.reverse().concat(tops);
    },
    reverse: function(data) {
      return d3.range(data.length).reverse();
    },
    "default": d3_layout_stackOrderDefault
  });
  var d3_layout_stackOffsets = d3.map({
    silhouette: function(data) {
      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o > max) max = o;
        sums.push(o);
      }
      for (j = 0; j < m; ++j) {
        y0[j] = (max - sums[j]) / 2;
      }
      return y0;
    },
    wiggle: function(data) {
      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
      y0[0] = o = o0 = 0;
      for (j = 1; j < m; ++j) {
        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
          }
          s2 += s3 * data[i][j][1];
        }
        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
        if (o < o0) o0 = o;
      }
      for (j = 0; j < m; ++j) y0[j] -= o0;
      return y0;
    },
    expand: function(data) {
      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
      }
      for (j = 0; j < m; ++j) y0[j] = 0;
      return y0;
    },
    zero: d3_layout_stackOffsetZero
  });
  function d3_layout_stackOrderDefault(data) {
    return d3.range(data.length);
  }
  function d3_layout_stackOffsetZero(data) {
    var j = -1, m = data[0].length, y0 = [];
    while (++j < m) y0[j] = 0;
    return y0;
  }
  function d3_layout_stackMaxIndex(array) {
    var i = 1, j = 0, v = array[0][1], k, n = array.length;
    for (;i < n; ++i) {
      if ((k = array[i][1]) > v) {
        j = i;
        v = k;
      }
    }
    return j;
  }
  function d3_layout_stackReduceSum(d) {
    return d.reduce(d3_layout_stackSum, 0);
  }
  function d3_layout_stackSum(p, d) {
    return p + d[1];
  }
  d3.layout.histogram = function() {
    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
    function histogram(data, i) {
      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
      while (++i < m) {
        bin = bins[i] = [];
        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
        bin.y = 0;
      }
      if (m > 0) {
        i = -1;
        while (++i < n) {
          x = values[i];
          if (x >= range[0] && x <= range[1]) {
            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
            bin.y += k;
            bin.push(data[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(x) {
      if (!arguments.length) return valuer;
      valuer = x;
      return histogram;
    };
    histogram.range = function(x) {
      if (!arguments.length) return ranger;
      ranger = d3_functor(x);
      return histogram;
    };
    histogram.bins = function(x) {
      if (!arguments.length) return binner;
      binner = typeof x === "number" ? function(range) {
        return d3_layout_histogramBinFixed(range, x);
      } : d3_functor(x);
      return histogram;
    };
    histogram.frequency = function(x) {
      if (!arguments.length) return frequency;
      frequency = !!x;
      return histogram;
    };
    return histogram;
  };
  function d3_layout_histogramBinSturges(range, values) {
    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
  }
  function d3_layout_histogramBinFixed(range, n) {
    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
    while (++x <= n) f[x] = m * x + b;
    return f;
  }
  function d3_layout_histogramRange(values) {
    return [ d3.min(values), d3.max(values) ];
  }
  d3.layout.pack = function() {
    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
    function pack(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
        return radius;
      };
      root.x = root.y = 0;
      d3_layout_hierarchyVisitAfter(root, function(d) {
        d.r = +r(d.value);
      });
      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
      if (padding) {
        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r += dr;
        });
        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r -= dr;
        });
      }
      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
      return nodes;
    }
    pack.size = function(_) {
      if (!arguments.length) return size;
      size = _;
      return pack;
    };
    pack.radius = function(_) {
      if (!arguments.length) return radius;
      radius = _ == null || typeof _ === "function" ? _ : +_;
      return pack;
    };
    pack.padding = function(_) {
      if (!arguments.length) return padding;
      padding = +_;
      return pack;
    };
    return d3_layout_hierarchyRebind(pack, hierarchy);
  };
  function d3_layout_packSort(a, b) {
    return a.value - b.value;
  }
  function d3_layout_packInsert(a, b) {
    var c = a._pack_next;
    a._pack_next = b;
    b._pack_prev = a;
    b._pack_next = c;
    c._pack_prev = b;
  }
  function d3_layout_packSplice(a, b) {
    a._pack_next = b;
    b._pack_prev = a;
  }
  function d3_layout_packIntersects(a, b) {
    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
    return .999 * dr * dr > dx * dx + dy * dy;
  }
  function d3_layout_packSiblings(node) {
    if (!(nodes = node.children) || !(n = nodes.length)) return;
    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
    function bound(node) {
      xMin = Math.min(node.x - node.r, xMin);
      xMax = Math.max(node.x + node.r, xMax);
      yMin = Math.min(node.y - node.r, yMin);
      yMax = Math.max(node.y + node.r, yMax);
    }
    nodes.forEach(d3_layout_packLink);
    a = nodes[0];
    a.x = -a.r;
    a.y = 0;
    bound(a);
    if (n > 1) {
      b = nodes[1];
      b.x = b.r;
      b.y = 0;
      bound(b);
      if (n > 2) {
        c = nodes[2];
        d3_layout_packPlace(a, b, c);
        bound(c);
        d3_layout_packInsert(a, c);
        a._pack_prev = c;
        d3_layout_packInsert(c, b);
        b = a._pack_next;
        for (i = 3; i < n; i++) {
          d3_layout_packPlace(a, b, c = nodes[i]);
          var isect = 0, s1 = 1, s2 = 1;
          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
            if (d3_layout_packIntersects(j, c)) {
              isect = 1;
              break;
            }
          }
          if (isect == 1) {
            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
              if (d3_layout_packIntersects(k, c)) {
                break;
              }
            }
          }
          if (isect) {
            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
            i--;
          } else {
            d3_layout_packInsert(a, c);
            b = c;
            bound(c);
          }
        }
      }
    }
    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
    for (i = 0; i < n; i++) {
      c = nodes[i];
      c.x -= cx;
      c.y -= cy;
      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
    }
    node.r = cr;
    nodes.forEach(d3_layout_packUnlink);
  }
  function d3_layout_packLink(node) {
    node._pack_next = node._pack_prev = node;
  }
  function d3_layout_packUnlink(node) {
    delete node._pack_next;
    delete node._pack_prev;
  }
  function d3_layout_packTransform(node, x, y, k) {
    var children = node.children;
    node.x = x += k * node.x;
    node.y = y += k * node.y;
    node.r *= k;
    if (children) {
      var i = -1, n = children.length;
      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
    }
  }
  function d3_layout_packPlace(a, b, c) {
    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
    if (db && (dx || dy)) {
      var da = b.r + c.r, dc = dx * dx + dy * dy;
      da *= da;
      db *= db;
      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
      c.x = a.x + x * dx + y * dy;
      c.y = a.y + x * dy - y * dx;
    } else {
      c.x = a.x + db;
      c.y = a.y;
    }
  }
  d3.layout.tree = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
    function tree(d, i) {
      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
      d3_layout_hierarchyVisitBefore(root1, secondWalk);
      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
        var left = root0, right = root0, bottom = root0;
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          if (node.x < left.x) left = node;
          if (node.x > right.x) right = node;
          if (node.depth > bottom.depth) bottom = node;
        });
        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          node.x = (node.x + tx) * kx;
          node.y = node.depth * ky;
        });
      }
      return nodes;
    }
    function wrapTree(root0) {
      var root1 = {
        A: null,
        children: [ root0 ]
      }, queue = [ root1 ], node1;
      while ((node1 = queue.pop()) != null) {
        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
          queue.push((children[i] = child = {
            _: children[i],
            parent: node1,
            children: (child = children[i].children) && child.slice() || [],
            A: null,
            a: null,
            z: 0,
            m: 0,
            c: 0,
            s: 0,
            t: null,
            i: i
          }).a = child);
        }
      }
      return root1.children[0];
    }
    function firstWalk(v) {
      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
      if (children.length) {
        d3_layout_treeShift(v);
        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
        if (w) {
          v.z = w.z + separation(v._, w._);
          v.m = v.z - midpoint;
        } else {
          v.z = midpoint;
        }
      } else if (w) {
        v.z = w.z + separation(v._, w._);
      }
      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
    }
    function secondWalk(v) {
      v._.x = v.z + v.parent.m;
      v.m += v.parent.m;
    }
    function apportion(v, w, ancestor) {
      if (w) {
        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
          vom = d3_layout_treeLeft(vom);
          vop = d3_layout_treeRight(vop);
          vop.a = v;
          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
          if (shift > 0) {
            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim.m;
          sip += vip.m;
          som += vom.m;
          sop += vop.m;
        }
        if (vim && !d3_layout_treeRight(vop)) {
          vop.t = vim;
          vop.m += sim - sop;
        }
        if (vip && !d3_layout_treeLeft(vom)) {
          vom.t = vip;
          vom.m += sip - som;
          ancestor = v;
        }
      }
      return ancestor;
    }
    function sizeNode(node) {
      node.x *= size[0];
      node.y = node.depth * size[1];
    }
    tree.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return tree;
    };
    tree.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null ? sizeNode : null;
      return tree;
    };
    tree.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) == null ? null : sizeNode;
      return tree;
    };
    return d3_layout_hierarchyRebind(tree, hierarchy);
  };
  function d3_layout_treeSeparation(a, b) {
    return a.parent == b.parent ? 1 : 2;
  }
  function d3_layout_treeLeft(v) {
    var children = v.children;
    return children.length ? children[0] : v.t;
  }
  function d3_layout_treeRight(v) {
    var children = v.children, n;
    return (n = children.length) ? children[n - 1] : v.t;
  }
  function d3_layout_treeMove(wm, wp, shift) {
    var change = shift / (wp.i - wm.i);
    wp.c -= change;
    wp.s += shift;
    wm.c += change;
    wp.z += shift;
    wp.m += shift;
  }
  function d3_layout_treeShift(v) {
    var shift = 0, change = 0, children = v.children, i = children.length, w;
    while (--i >= 0) {
      w = children[i];
      w.z += shift;
      w.m += shift;
      shift += w.s + (change += w.c);
    }
  }
  function d3_layout_treeAncestor(vim, v, ancestor) {
    return vim.a.parent === v.parent ? vim.a : ancestor;
  }
  d3.layout.cluster = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
    function cluster(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var children = node.children;
        if (children && children.length) {
          node.x = d3_layout_clusterX(children);
          node.y = d3_layout_clusterY(children);
        } else {
          node.x = previousNode ? x += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
        node.x = (node.x - root.x) * size[0];
        node.y = (root.y - node.y) * size[1];
      } : function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
      });
      return nodes;
    }
    cluster.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return cluster;
    };
    cluster.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null;
      return cluster;
    };
    cluster.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) != null;
      return cluster;
    };
    return d3_layout_hierarchyRebind(cluster, hierarchy);
  };
  function d3_layout_clusterY(children) {
    return 1 + d3.max(children, function(child) {
      return child.y;
    });
  }
  function d3_layout_clusterX(children) {
    return children.reduce(function(x, child) {
      return x + child.x;
    }, 0) / children.length;
  }
  function d3_layout_clusterLeft(node) {
    var children = node.children;
    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
  }
  function d3_layout_clusterRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
  }
  d3.layout.treemap = function() {
    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
    function scale(children, k) {
      var i = -1, n = children.length, child, area;
      while (++i < n) {
        area = (child = children[i]).value * (k < 0 ? 0 : k);
        child.area = isNaN(area) || area <= 0 ? 0 : area;
      }
    }
    function squarify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while ((n = remaining.length) > 0) {
          row.push(child = remaining[n - 1]);
          row.area += child.area;
          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
            remaining.pop();
            best = score;
          } else {
            row.area -= row.pop().area;
            position(row, u, rect, false);
            u = Math.min(rect.dx, rect.dy);
            row.length = row.area = 0;
            best = Infinity;
          }
        }
        if (row.length) {
          position(row, u, rect, true);
          row.length = row.area = 0;
        }
        children.forEach(squarify);
      }
    }
    function stickify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), remaining = children.slice(), child, row = [];
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while (child = remaining.pop()) {
          row.push(child);
          row.area += child.area;
          if (child.z != null) {
            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
            row.length = row.area = 0;
          }
        }
        children.forEach(stickify);
      }
    }
    function worst(row, u) {
      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
      while (++i < n) {
        if (!(r = row[i].area)) continue;
        if (r < rmin) rmin = r;
        if (r > rmax) rmax = r;
      }
      s *= s;
      u *= u;
      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
    }
    function position(row, u, rect, flush) {
      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
      if (u == rect.dx) {
        if (flush || v > rect.dy) v = rect.dy;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dy = v;
          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
        }
        o.z = true;
        o.dx += rect.x + rect.dx - x;
        rect.y += v;
        rect.dy -= v;
      } else {
        if (flush || v > rect.dx) v = rect.dx;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dx = v;
          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
        }
        o.z = false;
        o.dy += rect.y + rect.dy - y;
        rect.x += v;
        rect.dx -= v;
      }
    }
    function treemap(d) {
      var nodes = stickies || hierarchy(d), root = nodes[0];
      root.x = root.y = 0;
      if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0;
      if (stickies) hierarchy.revalue(root);
      scale([ root ], root.dx * root.dy / root.value);
      (stickies ? stickify : squarify)(root);
      if (sticky) stickies = nodes;
      return nodes;
    }
    treemap.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return treemap;
    };
    treemap.padding = function(x) {
      if (!arguments.length) return padding;
      function padFunction(node) {
        var p = x.call(treemap, node, node.depth);
        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
      }
      function padConstant(node) {
        return d3_layout_treemapPad(node, x);
      }
      var type;
      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
      padConstant) : padConstant;
      return treemap;
    };
    treemap.round = function(x) {
      if (!arguments.length) return round != Number;
      round = x ? Math.round : Number;
      return treemap;
    };
    treemap.sticky = function(x) {
      if (!arguments.length) return sticky;
      sticky = x;
      stickies = null;
      return treemap;
    };
    treemap.ratio = function(x) {
      if (!arguments.length) return ratio;
      ratio = x;
      return treemap;
    };
    treemap.mode = function(x) {
      if (!arguments.length) return mode;
      mode = x + "";
      return treemap;
    };
    return d3_layout_hierarchyRebind(treemap, hierarchy);
  };
  function d3_layout_treemapPadNull(node) {
    return {
      x: node.x,
      y: node.y,
      dx: node.dx,
      dy: node.dy
    };
  }
  function d3_layout_treemapPad(node, padding) {
    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
    if (dx < 0) {
      x += dx / 2;
      dx = 0;
    }
    if (dy < 0) {
      y += dy / 2;
      dy = 0;
    }
    return {
      x: x,
      y: y,
      dx: dx,
      dy: dy
    };
  }
  d3.random = {
    normal: function(, ) {
      var n = arguments.length;
      if (n < 2)  = 1;
      if (n < 1)  = 0;
      return function() {
        var x, y, r;
        do {
          x = Math.random() * 2 - 1;
          y = Math.random() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);
        return  +  * x * Math.sqrt(-2 * Math.log(r) / r);
      };
    },
    logNormal: function() {
      var random = d3.random.normal.apply(d3, arguments);
      return function() {
        return Math.exp(random());
      };
    },
    bates: function(m) {
      var random = d3.random.irwinHall(m);
      return function() {
        return random() / m;
      };
    },
    irwinHall: function(m) {
      return function() {
        for (var s = 0, j = 0; j < m; j++) s += Math.random();
        return s;
      };
    }
  };
  d3.scale = {};
  function d3_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_scaleRange(scale) {
    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
  }
  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
    return function(x) {
      return i(u(x));
    };
  }
  function d3_scale_nice(domain, nice) {
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
    if (x1 < x0) {
      dx = i0, i0 = i1, i1 = dx;
      dx = x0, x0 = x1, x1 = dx;
    }
    domain[i0] = nice.floor(x0);
    domain[i1] = nice.ceil(x1);
    return domain;
  }
  function d3_scale_niceStep(step) {
    return step ? {
      floor: function(x) {
        return Math.floor(x / step) * step;
      },
      ceil: function(x) {
        return Math.ceil(x / step) * step;
      }
    } : d3_scale_niceIdentity;
  }
  var d3_scale_niceIdentity = {
    floor: d3_identity,
    ceil: d3_identity
  };
  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
    if (domain[k] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }
    while (++j <= k) {
      u.push(uninterpolate(domain[j - 1], domain[j]));
      i.push(interpolate(range[j - 1], range[j]));
    }
    return function(x) {
      var j = d3.bisect(domain, x, 1, k) - 1;
      return i[j](u[j](x));
    };
  }
  d3.scale.linear = function() {
    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
  };
  function d3_scale_linear(domain, range, interpolate, clamp) {
    var output, input;
    function rescale() {
      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
      output = linear(domain, range, uninterpolate, interpolate);
      input = linear(range, domain, uninterpolate, d3_interpolate);
      return scale;
    }
    function scale(x) {
      return output(x);
    }
    scale.invert = function(y) {
      return input(y);
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(Number);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.rangeRound = function(x) {
      return scale.range(x).interpolate(d3_interpolateRound);
    };
    scale.clamp = function(x) {
      if (!arguments.length) return clamp;
      clamp = x;
      return rescale();
    };
    scale.interpolate = function(x) {
      if (!arguments.length) return interpolate;
      interpolate = x;
      return rescale();
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      d3_scale_linearNice(domain, m);
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_linear(domain, range, interpolate, clamp);
    };
    return rescale();
  }
  function d3_scale_linearRebind(scale, linear) {
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_scale_linearNice(domain, m) {
    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
    return domain;
  }
  function d3_scale_linearTickRange(domain, m) {
    if (m == null) m = 10;
    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
    extent[0] = Math.ceil(extent[0] / step) * step;
    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
    extent[2] = step;
    return extent;
  }
  function d3_scale_linearTicks(domain, m) {
    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
  }
  function d3_scale_linearTickFormat(domain, m, format) {
    var range = d3_scale_linearTickRange(domain, m);
    if (format) {
      var match = d3_format_re.exec(format);
      match.shift();
      if (match[8] === "s") {
        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
        if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
        match[8] = "f";
        format = d3.format(match.join(""));
        return function(d) {
          return format(prefix.scale(d)) + prefix.symbol;
        };
      }
      if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
      format = match.join("");
    } else {
      format = ",." + d3_scale_linearPrecision(range[2]) + "f";
    }
    return d3.format(format);
  }
  var d3_scale_linearFormatSignificant = {
    s: 1,
    g: 1,
    p: 1,
    r: 1,
    e: 1
  };
  function d3_scale_linearPrecision(value) {
    return -Math.floor(Math.log(value) / Math.LN10 + .01);
  }
  function d3_scale_linearFormatPrecision(type, range) {
    var p = d3_scale_linearPrecision(range[2]);
    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
  }
  d3.scale.log = function() {
    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
  };
  function d3_scale_log(linear, base, positive, domain) {
    function log(x) {
      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
    }
    function pow(x) {
      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
    }
    function scale(x) {
      return linear(log(x));
    }
    scale.invert = function(x) {
      return pow(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      positive = x[0] >= 0;
      linear.domain((domain = x.map(Number)).map(log));
      return scale;
    };
    scale.base = function(_) {
      if (!arguments.length) return base;
      base = +_;
      linear.domain(domain.map(log));
      return scale;
    };
    scale.nice = function() {
      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
      linear.domain(niced);
      domain = niced.map(pow);
      return scale;
    };
    scale.ticks = function() {
      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
      if (isFinite(j - i)) {
        if (positive) {
          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
          ticks.push(pow(i));
        } else {
          ticks.push(pow(i));
          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
        }
        for (i = 0; ticks[i] < u; i++) {}
        for (j = ticks.length; ticks[j - 1] > v; j--) {}
        ticks = ticks.slice(i, j);
      }
      return ticks;
    };
    scale.tickFormat = function(n, format) {
      if (!arguments.length) return d3_scale_logFormat;
      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
      var k = Math.max(1, base * n / scale.ticks().length);
      return function(d) {
        var i = d / pow(Math.round(log(d)));
        if (i * base < base - .5) i *= base;
        return i <= k ? format(d) : "";
      };
    };
    scale.copy = function() {
      return d3_scale_log(linear.copy(), base, positive, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
    floor: function(x) {
      return -Math.ceil(-x);
    },
    ceil: function(x) {
      return -Math.floor(-x);
    }
  };
  d3.scale.pow = function() {
    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
  };
  function d3_scale_pow(linear, exponent, domain) {
    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
    function scale(x) {
      return linear(powp(x));
    }
    scale.invert = function(x) {
      return powb(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      linear.domain((domain = x.map(Number)).map(powp));
      return scale;
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      return scale.domain(d3_scale_linearNice(domain, m));
    };
    scale.exponent = function(x) {
      if (!arguments.length) return exponent;
      powp = d3_scale_powPow(exponent = x);
      powb = d3_scale_powPow(1 / exponent);
      linear.domain(domain.map(powp));
      return scale;
    };
    scale.copy = function() {
      return d3_scale_pow(linear.copy(), exponent, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_scale_powPow(e) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
    };
  }
  d3.scale.sqrt = function() {
    return d3.scale.pow().exponent(.5);
  };
  d3.scale.ordinal = function() {
    return d3_scale_ordinal([], {
      t: "range",
      a: [ [] ]
    });
  };
  function d3_scale_ordinal(domain, ranger) {
    var index, range, rangeBand;
    function scale(x) {
      return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
    }
    function steps(start, step) {
      return d3.range(domain.length).map(function(i) {
        return start + step * i;
      });
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = [];
      index = new d3_Map();
      var i = -1, n = x.length, xi;
      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
      return scale[ranger.t].apply(scale, ranger.a);
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      rangeBand = 0;
      ranger = {
        t: "range",
        a: arguments
      };
      return scale;
    };
    scale.rangePoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 
      0) : (stop - start) / (domain.length - 1 + padding);
      range = steps(start + step * padding / 2, step);
      rangeBand = 0;
      ranger = {
        t: "rangePoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundPoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 
      0) : (stop - start) / (domain.length - 1 + padding) | 0;
      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
      rangeBand = 0;
      ranger = {
        t: "rangeRoundPoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
      range = steps(start + step * outerPadding, step);
      if (reverse) range.reverse();
      rangeBand = step * (1 - padding);
      ranger = {
        t: "rangeBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
      if (reverse) range.reverse();
      rangeBand = Math.round(step * (1 - padding));
      ranger = {
        t: "rangeRoundBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeBand = function() {
      return rangeBand;
    };
    scale.rangeExtent = function() {
      return d3_scaleExtent(ranger.a[0]);
    };
    scale.copy = function() {
      return d3_scale_ordinal(domain, ranger);
    };
    return scale.domain(domain);
  }
  d3.scale.category10 = function() {
    return d3.scale.ordinal().range(d3_category10);
  };
  d3.scale.category20 = function() {
    return d3.scale.ordinal().range(d3_category20);
  };
  d3.scale.category20b = function() {
    return d3.scale.ordinal().range(d3_category20b);
  };
  d3.scale.category20c = function() {
    return d3.scale.ordinal().range(d3_category20c);
  };
  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
  d3.scale.quantile = function() {
    return d3_scale_quantile([], []);
  };
  function d3_scale_quantile(domain, range) {
    var thresholds;
    function rescale() {
      var k = 0, q = range.length;
      thresholds = [];
      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
      return scale;
    }
    function scale(x) {
      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.quantiles = function() {
      return thresholds;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
    };
    scale.copy = function() {
      return d3_scale_quantile(domain, range);
    };
    return rescale();
  }
  d3.scale.quantize = function() {
    return d3_scale_quantize(0, 1, [ 0, 1 ]);
  };
  function d3_scale_quantize(x0, x1, range) {
    var kx, i;
    function scale(x) {
      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
    }
    function rescale() {
      kx = range.length / (x1 - x0);
      i = range.length - 1;
      return scale;
    }
    scale.domain = function(x) {
      if (!arguments.length) return [ x0, x1 ];
      x0 = +x[0];
      x1 = +x[x.length - 1];
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      y = y < 0 ? NaN : y / kx + x0;
      return [ y, y + 1 / kx ];
    };
    scale.copy = function() {
      return d3_scale_quantize(x0, x1, range);
    };
    return rescale();
  }
  d3.scale.threshold = function() {
    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
  };
  function d3_scale_threshold(domain, range) {
    function scale(x) {
      if (x <= x) return range[d3.bisect(domain, x)];
    }
    scale.domain = function(_) {
      if (!arguments.length) return domain;
      domain = _;
      return scale;
    };
    scale.range = function(_) {
      if (!arguments.length) return range;
      range = _;
      return scale;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return [ domain[y - 1], domain[y] ];
    };
    scale.copy = function() {
      return d3_scale_threshold(domain, range);
    };
    return scale;
  }
  d3.scale.identity = function() {
    return d3_scale_identity([ 0, 1 ]);
  };
  function d3_scale_identity(domain) {
    function identity(x) {
      return +x;
    }
    identity.invert = identity;
    identity.domain = identity.range = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(identity);
      return identity;
    };
    identity.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    identity.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    identity.copy = function() {
      return d3_scale_identity(domain);
    };
    return identity;
  }
  d3.svg = {};
  function d3_zero() {
    return 0;
  }
  d3.svg.arc = function() {
    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
    function arc() {
      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - half, a1 = endAngle.apply(this, arguments) - half, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
      if (da >= ) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
        if (!cw) p1 *= -1;
        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
      }
      if (r1) {
        x0 = r1 * Math.cos(a0 + p1);
        y0 = r1 * Math.sin(a0 + p1);
        x1 = r1 * Math.cos(a1 - p1);
        y1 = r1 * Math.sin(a1 - p1);
        var l1 = Math.abs(a1 - a0 - 2 * p1) <=  ? 0 : 1;
        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
          var h1 = (a0 + a1) / 2;
          x0 = r1 * Math.cos(h1);
          y0 = r1 * Math.sin(h1);
          x1 = y1 = null;
        }
      } else {
        x0 = y0 = 0;
      }
      if (r0) {
        x2 = r0 * Math.cos(a1 - p0);
        y2 = r0 * Math.sin(a1 - p0);
        x3 = r0 * Math.cos(a0 + p0);
        y3 = r0 * Math.sin(a0 + p0);
        var l0 = Math.abs(a0 - a1 + 2 * p0) <=  ? 0 : 1;
        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
          var h0 = (a0 + a1) / 2;
          x2 = r0 * Math.cos(h0);
          y2 = r0 * Math.sin(h0);
          x3 = y3 = null;
        }
      } else {
        x2 = y2 = 0;
      }
      if (da >  && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
        cr = r0 < r1 ^ cw ? 0 : 1;
        var rc1 = rc, rc0 = rc;
        if (da < ) {
          var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
        }
        if (x1 != null) {
          var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
          if (rc === rc1) {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
          } else {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
          }
        } else {
          path.push("M", x0, ",", y0);
        }
        if (x3 != null) {
          var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
          if (rc === rc0) {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          } else {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          }
        } else {
          path.push("L", x2, ",", y2);
        }
      } else {
        path.push("M", x0, ",", y0);
        if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
        path.push("L", x2, ",", y2);
        if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
      }
      path.push("Z");
      return path.join("");
    }
    function circleSegment(r1, cw) {
      return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
    }
    arc.innerRadius = function(v) {
      if (!arguments.length) return innerRadius;
      innerRadius = d3_functor(v);
      return arc;
    };
    arc.outerRadius = function(v) {
      if (!arguments.length) return outerRadius;
      outerRadius = d3_functor(v);
      return arc;
    };
    arc.cornerRadius = function(v) {
      if (!arguments.length) return cornerRadius;
      cornerRadius = d3_functor(v);
      return arc;
    };
    arc.padRadius = function(v) {
      if (!arguments.length) return padRadius;
      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
      return arc;
    };
    arc.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return arc;
    };
    arc.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return arc;
    };
    arc.padAngle = function(v) {
      if (!arguments.length) return padAngle;
      padAngle = d3_functor(v);
      return arc;
    };
    arc.centroid = function() {
      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - half;
      return [ Math.cos(a) * r, Math.sin(a) * r ];
    };
    return arc;
  };
  var d3_svg_arcAuto = "auto";
  function d3_svg_arcInnerRadius(d) {
    return d.innerRadius;
  }
  function d3_svg_arcOuterRadius(d) {
    return d.outerRadius;
  }
  function d3_svg_arcStartAngle(d) {
    return d.startAngle;
  }
  function d3_svg_arcEndAngle(d) {
    return d.endAngle;
  }
  function d3_svg_arcPadAngle(d) {
    return d && d.padAngle;
  }
  function d3_svg_arcSweep(x0, y0, x1, y1) {
    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
  }
  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
  }
  function d3_svg_line(projection) {
    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
    function line(data) {
      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
      function segment() {
        segments.push("M", interpolate(projection(points), tension));
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
        } else if (points.length) {
          segment();
          points = [];
        }
      }
      if (points.length) segment();
      return segments.length ? segments.join("") : null;
    }
    line.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      return line;
    };
    line.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return line;
    };
    line.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return line;
    };
    line.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      return line;
    };
    line.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return line;
    };
    return line;
  }
  d3.svg.line = function() {
    return d3_svg_line(d3_identity);
  };
  var d3_svg_lineInterpolators = d3.map({
    linear: d3_svg_lineLinear,
    "linear-closed": d3_svg_lineLinearClosed,
    step: d3_svg_lineStep,
    "step-before": d3_svg_lineStepBefore,
    "step-after": d3_svg_lineStepAfter,
    basis: d3_svg_lineBasis,
    "basis-open": d3_svg_lineBasisOpen,
    "basis-closed": d3_svg_lineBasisClosed,
    bundle: d3_svg_lineBundle,
    cardinal: d3_svg_lineCardinal,
    "cardinal-open": d3_svg_lineCardinalOpen,
    "cardinal-closed": d3_svg_lineCardinalClosed,
    monotone: d3_svg_lineMonotone
  });
  d3_svg_lineInterpolators.forEach(function(key, value) {
    value.key = key;
    value.closed = /-closed$/.test(key);
  });
  function d3_svg_lineLinear(points) {
    return points.length > 1 ? points.join("L") : points + "Z";
  }
  function d3_svg_lineLinearClosed(points) {
    return points.join("L") + "Z";
  }
  function d3_svg_lineStep(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
    if (n > 1) path.push("H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepBefore(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepAfter(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
    return path.join("");
  }
  function d3_svg_lineCardinalOpen(points, tension) {
    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineCardinalClosed(points, tension) {
    return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
  }
  function d3_svg_lineCardinal(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineHermite(points, tangents) {
    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
      return d3_svg_lineLinear(points);
    }
    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
    if (quad) {
      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
      p0 = points[1];
      pi = 2;
    }
    if (tangents.length > 1) {
      t = tangents[1];
      p = points[pi];
      pi++;
      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      for (var i = 2; i < tangents.length; i++, pi++) {
        p = points[pi];
        t = tangents[i];
        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      }
    }
    if (quad) {
      var lp = points[pi];
      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
    }
    return path;
  }
  function d3_svg_lineCardinalTangents(points, tension) {
    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
    while (++i < n) {
      p0 = p1;
      p1 = p2;
      p2 = points[i];
      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
    }
    return tangents;
  }
  function d3_svg_lineBasis(points) {
    if (points.length < 3) return d3_svg_lineLinear(points);
    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    points.push(points[n - 1]);
    while (++i <= n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    points.pop();
    path.push("L", pi);
    return path.join("");
  }
  function d3_svg_lineBasisOpen(points) {
    if (points.length < 4) return d3_svg_lineLinear(points);
    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
    while (++i < 3) {
      pi = points[i];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
    --i;
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisClosed(points) {
    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
    while (++i < 4) {
      pi = points[i % n];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    --i;
    while (++i < m) {
      pi = points[i % n];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBundle(points, tension) {
    var n = points.length - 1;
    if (n) {
      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
      while (++i <= n) {
        p = points[i];
        t = i / n;
        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
      }
    }
    return d3_svg_lineBasis(points);
  }
  function d3_svg_lineDot4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
  function d3_svg_lineBasisBezier(path, x, y) {
    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
  }
  function d3_svg_lineSlope(p0, p1) {
    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
  }
  function d3_svg_lineFiniteDifferences(points) {
    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
    while (++i < j) {
      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
    }
    m[i] = d;
    return m;
  }
  function d3_svg_lineMonotoneTangents(points) {
    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
    while (++i < j) {
      d = d3_svg_lineSlope(points[i], points[i + 1]);
      if (abs(d) < ) {
        m[i] = m[i + 1] = 0;
      } else {
        a = m[i] / d;
        b = m[i + 1] / d;
        s = a * a + b * b;
        if (s > 9) {
          s = d * 3 / Math.sqrt(s);
          m[i] = s * a;
          m[i + 1] = s * b;
        }
      }
    }
    i = -1;
    while (++i <= j) {
      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
      tangents.push([ s || 0, m[i] * s || 0 ]);
    }
    return tangents;
  }
  function d3_svg_lineMonotone(points) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
  }
  d3.svg.line.radial = function() {
    var line = d3_svg_line(d3_svg_lineRadial);
    line.radius = line.x, delete line.x;
    line.angle = line.y, delete line.y;
    return line;
  };
  function d3_svg_lineRadial(points) {
    var point, i = -1, n = points.length, r, a;
    while (++i < n) {
      point = points[i];
      r = point[0];
      a = point[1] - half;
      point[0] = r * Math.cos(a);
      point[1] = r * Math.sin(a);
    }
    return points;
  }
  function d3_svg_area(projection) {
    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
    function area(data) {
      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
        return x;
      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
        return y;
      } : d3_functor(y1), x, y;
      function segment() {
        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
        } else if (points0.length) {
          segment();
          points0 = [];
          points1 = [];
        }
      }
      if (points0.length) segment();
      return segments.length ? segments.join("") : null;
    }
    area.x = function(_) {
      if (!arguments.length) return x1;
      x0 = x1 = _;
      return area;
    };
    area.x0 = function(_) {
      if (!arguments.length) return x0;
      x0 = _;
      return area;
    };
    area.x1 = function(_) {
      if (!arguments.length) return x1;
      x1 = _;
      return area;
    };
    area.y = function(_) {
      if (!arguments.length) return y1;
      y0 = y1 = _;
      return area;
    };
    area.y0 = function(_) {
      if (!arguments.length) return y0;
      y0 = _;
      return area;
    };
    area.y1 = function(_) {
      if (!arguments.length) return y1;
      y1 = _;
      return area;
    };
    area.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return area;
    };
    area.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      interpolateReverse = interpolate.reverse || interpolate;
      L = interpolate.closed ? "M" : "L";
      return area;
    };
    area.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return area;
    };
    return area;
  }
  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
  d3.svg.area = function() {
    return d3_svg_area(d3_identity);
  };
  d3.svg.area.radial = function() {
    var area = d3_svg_area(d3_svg_lineRadial);
    area.radius = area.x, delete area.x;
    area.innerRadius = area.x0, delete area.x0;
    area.outerRadius = area.x1, delete area.x1;
    area.angle = area.y, delete area.y;
    area.startAngle = area.y0, delete area.y0;
    area.endAngle = area.y1, delete area.y1;
    return area;
  };
  d3.svg.chord = function() {
    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function chord(d, i) {
      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
    }
    function subgroup(self, f, d, i) {
      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - half, a1 = endAngle.call(self, subgroup, i) - half;
      return {
        r: r,
        a0: a0,
        a1: a1,
        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
      };
    }
    function equals(a, b) {
      return a.a0 == b.a0 && a.a1 == b.a1;
    }
    function arc(r, p, a) {
      return "A" + r + "," + r + " 0 " + +(a > ) + ",1 " + p;
    }
    function curve(r0, p0, r1, p1) {
      return "Q 0,0 " + p1;
    }
    chord.radius = function(v) {
      if (!arguments.length) return radius;
      radius = d3_functor(v);
      return chord;
    };
    chord.source = function(v) {
      if (!arguments.length) return source;
      source = d3_functor(v);
      return chord;
    };
    chord.target = function(v) {
      if (!arguments.length) return target;
      target = d3_functor(v);
      return chord;
    };
    chord.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return chord;
    };
    chord.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return chord;
    };
    return chord;
  };
  function d3_svg_chordRadius(d) {
    return d.radius;
  }
  d3.svg.diagonal = function() {
    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
    function diagonal(d, i) {
      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
        x: p0.x,
        y: m
      }, {
        x: p3.x,
        y: m
      }, p3 ];
      p = p.map(projection);
      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
    }
    diagonal.source = function(x) {
      if (!arguments.length) return source;
      source = d3_functor(x);
      return diagonal;
    };
    diagonal.target = function(x) {
      if (!arguments.length) return target;
      target = d3_functor(x);
      return diagonal;
    };
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    return diagonal;
  };
  function d3_svg_diagonalProjection(d) {
    return [ d.x, d.y ];
  }
  d3.svg.diagonal.radial = function() {
    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
    diagonal.projection = function(x) {
      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
    };
    return diagonal;
  };
  function d3_svg_diagonalRadialProjection(projection) {
    return function() {
      var d = projection.apply(this, arguments), r = d[0], a = d[1] - half;
      return [ r * Math.cos(a), r * Math.sin(a) ];
    };
  }
  d3.svg.symbol = function() {
    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
    function symbol(d, i) {
      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
    }
    symbol.type = function(x) {
      if (!arguments.length) return type;
      type = d3_functor(x);
      return symbol;
    };
    symbol.size = function(x) {
      if (!arguments.length) return size;
      size = d3_functor(x);
      return symbol;
    };
    return symbol;
  };
  function d3_svg_symbolSize() {
    return 64;
  }
  function d3_svg_symbolType() {
    return "circle";
  }
  function d3_svg_symbolCircle(size) {
    var r = Math.sqrt(size / );
    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
  }
  var d3_svg_symbols = d3.map({
    circle: d3_svg_symbolCircle,
    cross: function(size) {
      var r = Math.sqrt(size / 5) / 2;
      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
    },
    diamond: function(size) {
      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
    },
    square: function(size) {
      var r = Math.sqrt(size) / 2;
      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
    },
    "triangle-down": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
    },
    "triangle-up": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
    }
  });
  d3.svg.symbolTypes = d3_svg_symbols.keys();
  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
  d3_selectionPrototype.transition = function(name) {
    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
      time: Date.now(),
      ease: d3_ease_cubicInOut,
      delay: 0,
      duration: 250
    };
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_selectionPrototype.interrupt = function(name) {
    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
  };
  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
  function d3_selection_interruptNS(ns) {
    return function() {
      var lock, activeId, active;
      if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
        active.timer.c = null;
        active.timer.t = NaN;
        if (--lock.count) delete lock[activeId]; else delete this[ns];
        lock.active += .5;
        active.event && active.event.interrupt.call(this, this.__data__, active.index);
      }
    };
  }
  function d3_transition(groups, ns, id) {
    d3_subclass(groups, d3_transitionPrototype);
    groups.namespace = ns;
    groups.id = id;
    return groups;
  }
  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
  d3_transitionPrototype.call = d3_selectionPrototype.call;
  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
  d3_transitionPrototype.node = d3_selectionPrototype.node;
  d3_transitionPrototype.size = d3_selectionPrototype.size;
  d3.transition = function(selection, name) {
    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
  };
  d3.transition.prototype = d3_transitionPrototype;
  d3_transitionPrototype.select = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          d3_transitionNode(subnode, i, ns, id, node[ns][id]);
          subgroup.push(subnode);
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.selectAll = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          transition = node[ns][id];
          subnodes = selector.call(node, node.__data__, i, j);
          subgroups.push(subgroup = []);
          for (var k = -1, o = subnodes.length; ++k < o; ) {
            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
            subgroup.push(subnode);
          }
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_transition(subgroups, this.namespace, this.id);
  };
  d3_transitionPrototype.tween = function(name, tween) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
    return d3_selection_each(this, tween == null ? function(node) {
      node[ns][id].tween.remove(name);
    } : function(node) {
      node[ns][id].tween.set(name, tween);
    });
  };
  function d3_transition_tween(groups, name, value, tween) {
    var id = groups.id, ns = groups.namespace;
    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
    } : (value = tween(value), function(node) {
      node[ns][id].tween.set(name, value);
    }));
  }
  d3_transitionPrototype.attr = function(nameNS, value) {
    if (arguments.length < 2) {
      for (value in nameNS) this.attr(value, nameNS[value]);
      return this;
    }
    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrTween(b) {
      return b == null ? attrNull : (b += "", function() {
        var a = this.getAttribute(name), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttribute(name, i(t));
        });
      });
    }
    function attrTweenNS(b) {
      return b == null ? attrNullNS : (b += "", function() {
        var a = this.getAttributeNS(name.space, name.local), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttributeNS(name.space, name.local, i(t));
        });
      });
    }
    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.attrTween = function(nameNS, tween) {
    var name = d3.ns.qualify(nameNS);
    function attrTween(d, i) {
      var f = tween.call(this, d, i, this.getAttribute(name));
      return f && function(t) {
        this.setAttribute(name, f(t));
      };
    }
    function attrTweenNS(d, i) {
      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
      return f && function(t) {
        this.setAttributeNS(name.space, name.local, f(t));
      };
    }
    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.style(priority, name[priority], value);
        return this;
      }
      priority = "";
    }
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleString(b) {
      return b == null ? styleNull : (b += "", function() {
        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
        return a !== b && (i = d3_interpolate(a, b), function(t) {
          this.style.setProperty(name, i(t), priority);
        });
      });
    }
    return d3_transition_tween(this, "style." + name, value, styleString);
  };
  d3_transitionPrototype.styleTween = function(name, tween, priority) {
    if (arguments.length < 3) priority = "";
    function styleTween(d, i) {
      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
      return f && function(t) {
        this.style.setProperty(name, f(t), priority);
      };
    }
    return this.tween("style." + name, styleTween);
  };
  d3_transitionPrototype.text = function(value) {
    return d3_transition_tween(this, "text", value, d3_transition_text);
  };
  function d3_transition_text(b) {
    if (b == null) b = "";
    return function() {
      this.textContent = b;
    };
  }
  d3_transitionPrototype.remove = function() {
    var ns = this.namespace;
    return this.each("end.transition", function() {
      var p;
      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
    });
  };
  d3_transitionPrototype.ease = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].ease;
    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
    return d3_selection_each(this, function(node) {
      node[ns][id].ease = value;
    });
  };
  d3_transitionPrototype.delay = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].delay;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].delay = +value.call(node, node.__data__, i, j);
    } : (value = +value, function(node) {
      node[ns][id].delay = value;
    }));
  };
  d3_transitionPrototype.duration = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].duration;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
    } : (value = Math.max(1, value), function(node) {
      node[ns][id].duration = value;
    }));
  };
  d3_transitionPrototype.each = function(type, listener) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) {
      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
      try {
        d3_transitionInheritId = id;
        d3_selection_each(this, function(node, i, j) {
          d3_transitionInherit = node[ns][id];
          type.call(node, node.__data__, i, j);
        });
      } finally {
        d3_transitionInherit = inherit;
        d3_transitionInheritId = inheritId;
      }
    } else {
      d3_selection_each(this, function(node) {
        var transition = node[ns][id];
        (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
      });
    }
    return this;
  };
  d3_transitionPrototype.transition = function() {
    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if (node = group[i]) {
          transition = node[ns][id0];
          d3_transitionNode(node, i, ns, id1, {
            time: transition.time,
            ease: transition.ease,
            delay: transition.delay + transition.duration,
            duration: transition.duration
          });
        }
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id1);
  };
  function d3_transitionNamespace(name) {
    return name == null ? "__transition__" : "__transition_" + name + "__";
  }
  function d3_transitionNode(node, i, ns, id, inherit) {
    var lock = node[ns] || (node[ns] = {
      active: 0,
      count: 0
    }), transition = lock[id], time, timer, duration, ease, tweens;
    function schedule(elapsed) {
      var delay = transition.delay;
      timer.t = delay + time;
      if (delay <= elapsed) return start(elapsed - delay);
      timer.c = start;
    }
    function start(elapsed) {
      var activeId = lock.active, active = lock[activeId];
      if (active) {
        active.timer.c = null;
        active.timer.t = NaN;
        --lock.count;
        delete lock[activeId];
        active.event && active.event.interrupt.call(node, node.__data__, active.index);
      }
      for (var cancelId in lock) {
        if (+cancelId < id) {
          var cancel = lock[cancelId];
          cancel.timer.c = null;
          cancel.timer.t = NaN;
          --lock.count;
          delete lock[cancelId];
        }
      }
      timer.c = tick;
      d3_timer(function() {
        if (timer.c && tick(elapsed || 1)) {
          timer.c = null;
          timer.t = NaN;
        }
        return 1;
      }, 0, time);
      lock.active = id;
      transition.event && transition.event.start.call(node, node.__data__, i);
      tweens = [];
      transition.tween.forEach(function(key, value) {
        if (value = value.call(node, node.__data__, i)) {
          tweens.push(value);
        }
      });
      ease = transition.ease;
      duration = transition.duration;
    }
    function tick(elapsed) {
      var t = elapsed / duration, e = ease(t), n = tweens.length;
      while (n > 0) {
        tweens[--n].call(node, e);
      }
      if (t >= 1) {
        transition.event && transition.event.end.call(node, node.__data__, i);
        if (--lock.count) delete lock[id]; else delete node[ns];
        return 1;
      }
    }
    if (!transition) {
      time = inherit.time;
      timer = d3_timer(schedule, 0, time);
      transition = lock[id] = {
        tween: new d3_Map(),
        time: time,
        timer: timer,
        delay: inherit.delay,
        duration: inherit.duration,
        ease: inherit.ease,
        index: i
      };
      inherit = null;
      ++lock.count;
    }
  }
  d3.svg.axis = function() {
    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
    function axis(g) {
      g.each(function() {
        var g = d3.select(this);
        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ), tickExit = d3.transition(tick.exit()).style("opacity", ).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
        d3.transition(path));
        tickEnter.append("line");
        tickEnter.append("text");
        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
        if (orient === "bottom" || orient === "top") {
          tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
          text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
          pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
        } else {
          tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
          text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
          pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
        }
        lineEnter.attr(y2, sign * innerTickSize);
        textEnter.attr(y1, sign * tickSpacing);
        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
        if (scale1.rangeBand) {
          var x = scale1, dx = x.rangeBand() / 2;
          scale0 = scale1 = function(d) {
            return x(d) + dx;
          };
        } else if (scale0.rangeBand) {
          scale0 = scale1;
        } else {
          tickExit.call(tickTransform, scale1, scale0);
        }
        tickEnter.call(tickTransform, scale0, scale1);
        tickUpdate.call(tickTransform, scale1, scale1);
      });
    }
    axis.scale = function(x) {
      if (!arguments.length) return scale;
      scale = x;
      return axis;
    };
    axis.orient = function(x) {
      if (!arguments.length) return orient;
      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
      return axis;
    };
    axis.ticks = function() {
      if (!arguments.length) return tickArguments_;
      tickArguments_ = d3_array(arguments);
      return axis;
    };
    axis.tickValues = function(x) {
      if (!arguments.length) return tickValues;
      tickValues = x;
      return axis;
    };
    axis.tickFormat = function(x) {
      if (!arguments.length) return tickFormat_;
      tickFormat_ = x;
      return axis;
    };
    axis.tickSize = function(x) {
      var n = arguments.length;
      if (!n) return innerTickSize;
      innerTickSize = +x;
      outerTickSize = +arguments[n - 1];
      return axis;
    };
    axis.innerTickSize = function(x) {
      if (!arguments.length) return innerTickSize;
      innerTickSize = +x;
      return axis;
    };
    axis.outerTickSize = function(x) {
      if (!arguments.length) return outerTickSize;
      outerTickSize = +x;
      return axis;
    };
    axis.tickPadding = function(x) {
      if (!arguments.length) return tickPadding;
      tickPadding = +x;
      return axis;
    };
    axis.tickSubdivide = function() {
      return arguments.length && axis;
    };
    return axis;
  };
  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  };
  function d3_svg_axisX(selection, x0, x1) {
    selection.attr("transform", function(d) {
      var v0 = x0(d);
      return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
    });
  }
  function d3_svg_axisY(selection, y0, y1) {
    selection.attr("transform", function(d) {
      var v0 = y0(d);
      return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
    });
  }
  d3.svg.brush = function() {
    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
    function brush(g) {
      g.each(function() {
        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
        var background = g.selectAll(".background").data([ 0 ]);
        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
        var resize = g.selectAll(".resize").data(resizes, d3_identity);
        resize.exit().remove();
        resize.enter().append("g").attr("class", function(d) {
          return "resize " + d;
        }).style("cursor", function(d) {
          return d3_svg_brushCursor[d];
        }).append("rect").attr("x", function(d) {
          return /[ew]$/.test(d) ? -3 : null;
        }).attr("y", function(d) {
          return /^[ns]/.test(d) ? -3 : null;
        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
        resize.style("display", brush.empty() ? "none" : null);
        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
        if (x) {
          range = d3_scaleRange(x);
          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
          redrawX(gUpdate);
        }
        if (y) {
          range = d3_scaleRange(y);
          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
          redrawY(gUpdate);
        }
        redraw(gUpdate);
      });
    }
    brush.event = function(g) {
      g.each(function() {
        var event_ = event.of(this, arguments), extent1 = {
          x: xExtent,
          y: yExtent,
          i: xExtentDomain,
          j: yExtentDomain
        }, extent0 = this.__chart__ || extent1;
        this.__chart__ = extent1;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.brush", function() {
            xExtentDomain = extent0.i;
            yExtentDomain = extent0.j;
            xExtent = extent0.x;
            yExtent = extent0.y;
            event_({
              type: "brushstart"
            });
          }).tween("brush:brush", function() {
            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
            xExtentDomain = yExtentDomain = null;
            return function(t) {
              xExtent = extent1.x = xi(t);
              yExtent = extent1.y = yi(t);
              event_({
                type: "brush",
                mode: "resize"
              });
            };
          }).each("end.brush", function() {
            xExtentDomain = extent1.i;
            yExtentDomain = extent1.j;
            event_({
              type: "brush",
              mode: "resize"
            });
            event_({
              type: "brushend"
            });
          });
        } else {
          event_({
            type: "brushstart"
          });
          event_({
            type: "brush",
            mode: "resize"
          });
          event_({
            type: "brushend"
          });
        }
      });
    };
    function redraw(g) {
      g.selectAll(".resize").attr("transform", function(d) {
        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
      });
    }
    function redrawX(g) {
      g.select(".extent").attr("x", xExtent[0]);
      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
    }
    function redrawY(g) {
      g.select(".extent").attr("y", yExtent[0]);
      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
    }
    function brushstart() {
      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
      var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
      if (d3.event.changedTouches) {
        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
      } else {
        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
      }
      g.interrupt().selectAll("*").interrupt();
      if (dragging) {
        origin[0] = xExtent[0] - origin[0];
        origin[1] = yExtent[0] - origin[1];
      } else if (resizing) {
        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
        origin[0] = xExtent[ex];
        origin[1] = yExtent[ey];
      } else if (d3.event.altKey) center = origin.slice();
      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
      d3.select("body").style("cursor", eventTarget.style("cursor"));
      event_({
        type: "brushstart"
      });
      brushmove();
      function keydown() {
        if (d3.event.keyCode == 32) {
          if (!dragging) {
            center = null;
            origin[0] -= xExtent[1];
            origin[1] -= yExtent[1];
            dragging = 2;
          }
          d3_eventPreventDefault();
        }
      }
      function keyup() {
        if (d3.event.keyCode == 32 && dragging == 2) {
          origin[0] += xExtent[1];
          origin[1] += yExtent[1];
          dragging = 0;
          d3_eventPreventDefault();
        }
      }
      function brushmove() {
        var point = d3.mouse(target), moved = false;
        if (offset) {
          point[0] += offset[0];
          point[1] += offset[1];
        }
        if (!dragging) {
          if (d3.event.altKey) {
            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
            origin[0] = xExtent[+(point[0] < center[0])];
            origin[1] = yExtent[+(point[1] < center[1])];
          } else center = null;
        }
        if (resizingX && move1(point, x, 0)) {
          redrawX(g);
          moved = true;
        }
        if (resizingY && move1(point, y, 1)) {
          redrawY(g);
          moved = true;
        }
        if (moved) {
          redraw(g);
          event_({
            type: "brush",
            mode: dragging ? "move" : "resize"
          });
        }
      }
      function move1(point, scale, i) {
        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
        if (dragging) {
          r0 -= position;
          r1 -= size + position;
        }
        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
        if (dragging) {
          max = (min += position) + size;
        } else {
          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
          if (position < min) {
            max = min;
            min = position;
          } else {
            max = position;
          }
        }
        if (extent[0] != min || extent[1] != max) {
          if (i) yExtentDomain = null; else xExtentDomain = null;
          extent[0] = min;
          extent[1] = max;
          return true;
        }
      }
      function brushend() {
        brushmove();
        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
        d3.select("body").style("cursor", null);
        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
        dragRestore();
        event_({
          type: "brushend"
        });
      }
    }
    brush.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.clamp = function(z) {
      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
      return brush;
    };
    brush.extent = function(z) {
      var x0, x1, y0, y1, t;
      if (!arguments.length) {
        if (x) {
          if (xExtentDomain) {
            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
          } else {
            x0 = xExtent[0], x1 = xExtent[1];
            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
            if (x1 < x0) t = x0, x0 = x1, x1 = t;
          }
        }
        if (y) {
          if (yExtentDomain) {
            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
          } else {
            y0 = yExtent[0], y1 = yExtent[1];
            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
            if (y1 < y0) t = y0, y0 = y1, y1 = t;
          }
        }
        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
      }
      if (x) {
        x0 = z[0], x1 = z[1];
        if (y) x0 = x0[0], x1 = x1[0];
        xExtentDomain = [ x0, x1 ];
        if (x.invert) x0 = x(x0), x1 = x(x1);
        if (x1 < x0) t = x0, x0 = x1, x1 = t;
        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
      }
      if (y) {
        y0 = z[0], y1 = z[1];
        if (x) y0 = y0[1], y1 = y1[1];
        yExtentDomain = [ y0, y1 ];
        if (y.invert) y0 = y(y0), y1 = y(y1);
        if (y1 < y0) t = y0, y0 = y1, y1 = t;
        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
      }
      return brush;
    };
    brush.clear = function() {
      if (!brush.empty()) {
        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
        xExtentDomain = yExtentDomain = null;
      }
      return brush;
    };
    brush.empty = function() {
      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
    };
    return d3.rebind(brush, event, "on");
  };
  var d3_svg_brushCursor = {
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };
  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
  var d3_time_formatUtc = d3_time_format.utc;
  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
  function d3_time_formatIsoNative(date) {
    return date.toISOString();
  }
  d3_time_formatIsoNative.parse = function(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  };
  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
  d3_time.second = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 1e3) * 1e3);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
  }, function(date) {
    return date.getSeconds();
  });
  d3_time.seconds = d3_time.second.range;
  d3_time.seconds.utc = d3_time.second.utc.range;
  d3_time.minute = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 6e4) * 6e4);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
  }, function(date) {
    return date.getMinutes();
  });
  d3_time.minutes = d3_time.minute.range;
  d3_time.minutes.utc = d3_time.minute.utc.range;
  d3_time.hour = d3_time_interval(function(date) {
    var timezone = date.getTimezoneOffset() / 60;
    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
  }, function(date) {
    return date.getHours();
  });
  d3_time.hours = d3_time.hour.range;
  d3_time.hours.utc = d3_time.hour.utc.range;
  d3_time.month = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setDate(1);
    return date;
  }, function(date, offset) {
    date.setMonth(date.getMonth() + offset);
  }, function(date) {
    return date.getMonth();
  });
  d3_time.months = d3_time.month.range;
  d3_time.months.utc = d3_time.month.utc.range;
  function d3_time_scale(linear, methods, format) {
    function scale(x) {
      return linear(x);
    }
    scale.invert = function(x) {
      return d3_time_scaleDate(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
      linear.domain(x);
      return scale;
    };
    function tickMethod(extent, count) {
      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
        return d / 31536e6;
      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
    }
    scale.nice = function(interval, skip) {
      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
      if (method) interval = method[0], skip = method[1];
      function skipped(date) {
        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
      }
      return scale.domain(d3_scale_nice(domain, skip > 1 ? {
        floor: function(date) {
          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
          return date;
        },
        ceil: function(date) {
          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
          return date;
        }
      } : interval));
    };
    scale.ticks = function(interval, skip) {
      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
        range: interval
      }, skip ];
      if (method) interval = method[0], skip = method[1];
      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
    };
    scale.tickFormat = function() {
      return format;
    };
    scale.copy = function() {
      return d3_time_scale(linear.copy(), methods, format);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_time_scaleDate(t) {
    return new Date(t);
  }
  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
    return d.getMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getMinutes();
  } ], [ "%I %p", function(d) {
    return d.getHours();
  } ], [ "%a %d", function(d) {
    return d.getDay() && d.getDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getDate() != 1;
  } ], [ "%B", function(d) {
    return d.getMonth();
  } ], [ "%Y", d3_true ] ]);
  var d3_time_scaleMilliseconds = {
    range: function(start, stop, step) {
      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
    },
    floor: d3_identity,
    ceil: d3_identity
  };
  d3_time_scaleLocalMethods.year = d3_time.year;
  d3_time.scale = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
  };
  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
    return [ m[0].utc, m[1] ];
  });
  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
    return d.getUTCMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getUTCSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getUTCMinutes();
  } ], [ "%I %p", function(d) {
    return d.getUTCHours();
  } ], [ "%a %d", function(d) {
    return d.getUTCDay() && d.getUTCDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getUTCDate() != 1;
  } ], [ "%B", function(d) {
    return d.getUTCMonth();
  } ], [ "%Y", d3_true ] ]);
  d3_time_scaleUtcMethods.year = d3_time.year.utc;
  d3_time.scale.utc = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
  };
  d3.text = d3_xhrType(function(request) {
    return request.responseText;
  });
  d3.json = function(url, callback) {
    return d3_xhr(url, "application/json", d3_json, callback);
  };
  function d3_json(request) {
    return JSON.parse(request.responseText);
  }
  d3.html = function(url, callback) {
    return d3_xhr(url, "text/html", d3_html, callback);
  };
  function d3_html(request) {
    var range = d3_document.createRange();
    range.selectNode(d3_document.body);
    return range.createContextualFragment(request.responseText);
  }
  d3.xml = d3_xhrType(function(request) {
    return request.responseXML;
  });
  if (true) this.d3 = d3, !(__WEBPACK_AMD_DEFINE_FACTORY__ = (d3),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else if (typeof module === "object" && module.exports) module.exports = d3; else this.d3 = d3;
}();

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.round = exports.units = exports.chartRegistry = exports.constants = undefined;
exports.logging = logging;
exports.sampledCount = sampledCount;
exports.incrementSampledCount = incrementSampledCount;
exports.decrementSampledCount = decrementSampledCount;
exports.refreshDisabled = refreshDisabled;
exports.disableRefresh = disableRefresh;
exports.enableRefresh = enableRefresh;
exports.globalTransitionDuration = globalTransitionDuration;
exports.disableTransitions = disableTransitions;
exports.registerChart = registerChart;
exports.getChart = getChart;
exports.deregisterChart = deregisterChart;
exports.hasChart = hasChart;
exports.deregisterAllCharts = deregisterAllCharts;
exports.filterAll = filterAll;
exports.refocusAll = refocusAll;
exports.transition = transition;
exports.optionalTransition = optionalTransition;
exports.afterTransition = afterTransition;
exports.override = override;
exports.renderlet = renderlet;
exports.instanceOfChart = instanceOfChart;

var _utils = __webpack_require__(4);

var _logging = false;
var _sampledCount = 0;
var _refreshDisabled = false;
var _globalTransitionDuration = null;
var _renderlet = null;
var _disableTransitions = false;

var constants = exports.constants = {
  CHART_CLASS: "dc-chart",
  DEBUG_GROUP_CLASS: "debug",
  STACK_CLASS: "stack",
  DESELECTED_CLASS: "deselected",
  SELECTED_CLASS: "selected",
  NODE_INDEX_NAME: "__index__",
  GROUP_INDEX_NAME: "__group_index__",
  DEFAULT_CHART_GROUP: "__default_chart_group__",
  NEGLIGIBLE_NUMBER: 1e-10,
  ACCENT_CLASS: "accented",
  EVENT_DELAY: 0
};

function logging(_) {
  if (!arguments.length) {
    return _logging;
  }
  _logging = _;
}

function sampledCount(_) {
  if (!arguments.length) {
    return _sampledCount;
  }
  _sampledCount = _;
}

function incrementSampledCount() {
  return _sampledCount++;
}

function decrementSampledCount() {
  return _sampledCount--;
}

function refreshDisabled(_) {
  if (!arguments.length) {
    return _refreshDisabled;
  }
  _refreshDisabled = _;
}

function disableRefresh() {
  _refreshDisabled = true;
}

function enableRefresh() {
  _refreshDisabled = false;
}

function globalTransitionDuration(_) {
  if (!arguments.length) {
    return _globalTransitionDuration;
  }
  _globalTransitionDuration = _;
}

function disableTransitions(_) {
  if (!arguments.length) {
    return _disableTransitions;
  }
  _disableTransitions = _;
}

var chartRegistry = exports.chartRegistry = function () {
  // chartGroup:string => charts:array
  var _chartMap = {};

  function initializeChartGroup(group) {
    if (!group) {
      group = constants.DEFAULT_CHART_GROUP;
    }

    if (!_chartMap[group]) {
      _chartMap[group] = [];
    }

    return group;
  }

  return {
    has: function has(chart) {
      for (var e in _chartMap) {
        if (_chartMap[e].indexOf(chart) >= 0) {
          return true;
        }
      }
      return false;
    },
    register: function register(chart, group) {
      group = initializeChartGroup(group);
      _chartMap[group].push(chart);
    },
    deregister: function deregister(chart, group) {
      group = initializeChartGroup(group);
      for (var i = 0; i < _chartMap[group].length; i++) {
        if (_chartMap[group][i].anchorName() === chart.anchorName()) {
          _chartMap[group].splice(i, 1);
          break;
        }
      }
    },
    clear: function clear(group) {
      if (group) {
        delete _chartMap[group];
      } else {
        _chartMap = {};
      }
    },
    list: function list(group) {
      group = initializeChartGroup(group);
      return _chartMap[group];
    }
  };
}();

function registerChart(chart, group) {
  chartRegistry.register(chart, group);
}

function getChart(dcFlag) {
  return chartRegistry.list().reduce(function (accum, chrt) {
    return chrt.__dcFlag__ === dcFlag ? chrt : accum;
  }, null);
}

function deregisterChart(chart, group) {
  chartRegistry.deregister(chart, group);
}

function hasChart(chart) {
  return chartRegistry.has(chart);
}

function deregisterAllCharts(group) {
  chartRegistry.clear(group);
}

/**
 * Clear all filters on all charts within the given chart group. If the chart group is not given then
 * only charts that belong to the default chart group will be reset.
 * @memberof dc
 * @name filterAll
 * @param {String} [group]
 */
function filterAll(group) {
  var charts = chartRegistry.list(group);
  for (var i = 0; i < charts.length; ++i) {
    charts[i].filterAll();
  }
}

/**
 * Reset zoom level / focus on all charts that belong to the given chart group. If the chart group is
 * not given then only charts that belong to the default chart group will be reset.
 * @memberof dc
 * @name refocusAll
 * @param {String} [group]
 */
function refocusAll(group) {
  var charts = chartRegistry.list(group);
  for (var i = 0; i < charts.length; ++i) {
    if (charts[i].focus) {
      charts[i].focus();
    }
  }
}

function transition(selections, duration, callback, name) {
  if (duration <= 0 || duration === undefined || _disableTransitions) {
    return selections;
  }

  var s = selections.transition(name).duration(duration);

  if (typeof callback === "function") {
    callback(s);
  }

  return s;
}

/* somewhat silly, but to avoid duplicating logic */
function optionalTransition(enable, duration, callback, name) {
  if (enable) {
    return function (selection) {
      return transition(selection, duration, callback, name);
    };
  } else {
    return function (selection) {
      return selection;
    };
  }
}

// See http://stackoverflow.com/a/20773846
function afterTransition(_transition, callback) {
  if (_transition.empty() || !_transition.duration) {
    callback.call(_transition);
  } else {
    var n = 0;
    _transition.each(function () {
      ++n;
    }).each("end", function () {
      if (! --n) {
        callback.call(_transition);
      }
    });
  }
}

/**
 * @name units
 * @memberof dc
 * @type {{}}
 */
var units = exports.units = {};

/**
 * The default value for {@link #dc.coordinateGridMixin+xUnits .xUnits} for the
 * {@link #dc.coordinateGridMixin Coordinate Grid Chart} and should
 * be used when the x values are a sequence of integers.
 * It is a function that counts the number of integers in the range supplied in its start and end parameters.
 * @name integers
 * @memberof units
 * @see {@link #dc.coordinateGridMixin+xUnits coordinateGridMixin.xUnits}
 * @example
 * chart.xUnits(units.integers) // already the default
 * @param {Number} start
 * @param {Number} end
 * @return {Number}
 */
units.integers = function (start, end) {
  return Math.abs(end - start);
};

/**
 * This argument can be passed to the {@link #dc.coordinateGridMixin+xUnits .xUnits} function of the to
 * specify ordinal units for the x axis. Usually this parameter is used in combination with passing
 * {@link https://github.com/mbostock/d3/wiki/Ordinal-Scales d3.scale.ordinal} to
 * {@link #dc.coordinateGridMixin+x .x}.
 * It just returns the domain passed to it, which for ordinal charts is an array of all values.
 * @name ordinal
 * @memberof units
 * @see {@link https://github.com/mbostock/d3/wiki/Ordinal-Scales d3.scale.ordinal}
 * @see {@link #dc.coordinateGridMixin+xUnits coordinateGridMixin.xUnits}
 * @see {@link #dc.coordinateGridMixin+x coordinateGridMixin.x}
 * @example
 * chart.xUnits(dc.units.ordinal)
 *      .x(d3.scale.ordinal())
 * @param {*} start
 * @param {*} end
 * @param {Array<String>} domain
 * @return {Array<String>}
 */
units.ordinal = function (start, end, domain) {
  return domain;
};

/**
 * @name fp
 * @memberof units
 * @type {{}}
 */
units.fp = {};
/**
 * This function generates an argument for the {@link #dc.coordinateGridMixin Coordinate Grid Chart}
 * {@link #dc.coordinateGridMixin+xUnits .xUnits} function specifying that the x values are floating-point
 * numbers with the given precision.
 * The returned function determines how many values at the given precision will fit into the range
 * supplied in its start and end parameters.
 * @name precision
 * @memberof units.fp
 * @see {@link #dc.coordinateGridMixin+xUnits coordinateGridMixin.xUnits}
 * @example
 * // specify values (and ticks) every 0.1 units
 * chart.xUnits(units.fp.precision(0.1)
 * // there are 500 units between 0.5 and 1 if the precision is 0.001
 * var thousandths = units.fp.precision(0.001);
 * thousandths(0.5, 1.0) // returns 500
 * @param {Number} precision
 * @return {Function} start-end unit function
 */
units.fp.precision = function (precision) {
  var _f = function _f(s, e) {
    var d = Math.abs((e - s) / _f.resolution);
    if (_utils.utils.isNegligible(d - Math.floor(d))) {
      return Math.floor(d);
    } else {
      return Math.ceil(d);
    }
  };
  _f.resolution = precision;
  return _f;
};

var round = exports.round = {};
round.floor = function (n) {
  return Math.floor(n);
};
round.ceil = function (n) {
  return Math.ceil(n);
};
round.round = function (n) {
  return Math.round(n);
};

function override(obj, functionName, newFunction) {
  var existingFunction = obj[functionName];
  obj["_" + functionName] = existingFunction;
  obj[functionName] = newFunction;
}

function renderlet(_) {
  if (!arguments.length) {
    return _renderlet;
  }
  _renderlet = _;
}

function instanceOfChart(o) {
  return o instanceof Object && o.__dcFlag__ && true;
}

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = createParser;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__parse_expression__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse_datastate__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__parse_transform__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__parse_source__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__write_sql__ = __webpack_require__(30);






/**
 * Creates a parser than can parse expressions, transforms, and intermediary
 * SQL representations. This parser is used internally by the data graph.
 * @see {@link Parser} for further information.
 * @memberof API
 */
function createParser() {
  var transformParsers = {};
  var expressionParsers = {};

  /**
   * A collection of functions used for parsing expressions, transforms, and
   * intermediary SQL representations
   * @namespace Parser
   */
  var parser = {
    parseExpression: parseExpression,
    parseTransform: parseTransform,
    parseDataState: parseDataState,
    parseSource: parseSource,
    writeSQL: writeSQL,
    write: __WEBPACK_IMPORTED_MODULE_4__write_sql__["b" /* write */],
    registerParser: registerParser
  };

  /**
   * Returns all child data node instances of the graph.
   * @memberof Parser
   * @inner
   */
  function registerParser(definition, typeParser) {
    if (definition.meta === "expression") {
      expressionParsers[definition.type] = typeParser;
    } else if (definition.meta === "transform") {
      transformParsers[definition.type] = typeParser;
    }
  }

  /**
   * Parses expressions and returns a valid SQL expression string
   * @memberof Parser
   * @inner
   * @see {@link Expression} for further information.
   */
  function parseExpression(expression) {
    if (expressionParsers[expression.type]) {
      return expressionParsers[expression.type](expression, parser);
    }
    return Object(__WEBPACK_IMPORTED_MODULE_0__parse_expression__["a" /* default */])(expression, parser);
  }

  /**
   * Parses transforms and returns an intermediary SQL representation
   * @memberof Parser
   * @inner
   * @see {@link Transform} for further information.
   */
  function parseTransform(sql, transform) {
    if (transformParsers[transform.type]) {
      return transformParsers[transform.type](sql, transform, parser);
    }
    return Object(__WEBPACK_IMPORTED_MODULE_2__parse_transform__["a" /* default */])(sql, transform, parser);
  }

  /**
   * Parses a data node state and returns an intermediary SQL representation
   * @memberof Parser
   * @inner
   */
  function parseDataState(data, sql) {
    return Object(__WEBPACK_IMPORTED_MODULE_1__parse_datastate__["a" /* default */])(data, parser, sql);
  }

  /**
   * Parses a source transform and returns a valid SQL FROM clause
   * @memberof Parser
   * @inner
   */
  function parseSource(sourceTransforms) {
    return Object(__WEBPACK_IMPORTED_MODULE_3__parse_source__["a" /* default */])(sourceTransforms, parser);
  }

  /**
  * Parses a data node state and returns a valid SQL string
   * @memberof Parser
   * @inner
   */
  function writeSQL(state) {
    return Object(__WEBPACK_IMPORTED_MODULE_4__write_sql__["a" /* default */])(state, parser);
  }

  return parser;
}

/* harmony default export */ __webpack_exports__["b"] = (createParser());

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utils = exports.pluck = exports.printers = exports.customTimeFormat = exports.TIME_UNITS = exports.deepClone = exports.deepEquals = exports.dateFormat = exports.parser = undefined;
exports.extractTickFormat = extractTickFormat;
exports.xDomain = xDomain;
exports.xScale = xScale;
exports.xAxisTickFormat = xAxisTickFormat;

var _mapdDataLayer = __webpack_require__(18);

var _formattingHelpers = __webpack_require__(7);

var _datesAndTimes = __webpack_require__(36);

var _deepEqual = __webpack_require__(137);

var _deepEqual2 = _interopRequireDefault(_deepEqual);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _core = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var parser = exports.parser = (0, _mapdDataLayer.createParser)();

function hexBinSQL(sql, _ref, parser) {
  var width = _ref.width,
      height = _ref.height,
      mark = _ref.mark,
      x = _ref.x,
      y = _ref.y,
      aggregate = _ref.aggregate;

  var hexoffsetx = 0;
  var hexoffsety = 0;

  var heximgwidth = width;
  var heximgheight = height;

  var hexminmercx = x.domain[0];
  var hexmaxmercx = x.domain[1];
  var hexminmercy = y.domain[0];
  var hexmaxmercy = y.domain[1];

  if (hexoffsetx) {
    var mercxdiff = hexoffsetx * (hexmaxmercx - hexminmercx) / heximgwidth;
    hexminmercx -= mercxdiff;
    hexmaxmercx -= mercxdiff;
  }

  if (hexoffsety) {
    var mercydiff = hexoffsety * (hexmaxmercy - hexminmercy) / heximgheight;
    hexminmercy -= mercydiff;
    hexmaxmercy -= mercydiff;
  }

  var args = parser.parseExpression(x.field) + "," + (hexminmercx + ",") + (hexmaxmercx + ",") + (parser.parseExpression(y.field) + ",") + (hexminmercy + ",") + (hexmaxmercy + ",") + (mark.width + ",") + (mark.height + ",") + (hexoffsetx + ",") + (hexoffsety + ",") + (width + ",") + ("" + height);

  sql.select.push("reg_" + mark.shape + "_horiz_pixel_bin_x(" + args + ") as x");
  sql.select.push("reg_" + mark.shape + "_horiz_pixel_bin_y(" + args + ") as y");
  sql.select.push(parser.parseExpression(aggregate) + " as color");
  sql.groupby.push("x");
  sql.groupby.push("y");

  return sql;
}

function rectBinSQL(sql, _ref2, parser) {
  var width = _ref2.width,
      height = _ref2.height,
      mark = _ref2.mark,
      x = _ref2.x,
      y = _ref2.y,
      aggregate = _ref2.aggregate;

  sql.select.push("rect_pixel_bin_x(" + parser.parseExpression(x.field) + ", " + x.domain[0] + ", " + x.domain[1] + ", " + mark.width + ", 0, " + width + ") as x");
  sql.select.push("rect_pixel_bin_y(" + parser.parseExpression(y.field) + ", " + y.domain[0] + ", " + y.domain[1] + ", " + mark.height + ", 0, " + height + ") as y");
  sql.select.push(parser.parseExpression(aggregate) + " as color");
  sql.groupby.push("x");
  sql.groupby.push("y");

  return sql;
}

parser.registerParser({
  meta: "transform",
  type: "pixel_bin"
}, function (sql, transform, parser) {
  switch (transform.mark.shape) {
    case "hex":
      return hexBinSQL(sql, transform, parser);
    case "square":
      return rectBinSQL(sql, transform, parser);
    default:
      return sql;
  }
});

var dateFormat = exports.dateFormat = _d2.default.time.format("%m/%d/%Y");

var deepEquals = exports.deepEquals = __webpack_require__(137); // eslint-disable-line global-require

var deepClone = exports.deepClone = function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
};

var TIME_UNITS = exports.TIME_UNITS = {
  DATE: true,
  TIMESTAMP: true,
  date: true,
  datetime: true,
  timestamp: true,
  "timestamp without timezone": true,
  TIME: true

  /* istanbul ignore next */
};var customTimeFormat = exports.customTimeFormat = _d2.default.time.format.utc.multi([[".%L", function (d) {
  return d.getUTCMilliseconds();
}], [":%S", function (d) {
  return d.getUTCSeconds();
}], ["%I:%M", function (d) {
  return d.getUTCMinutes();
}], ["%I %p", function (d) {
  return d.getUTCHours();
}], ["%a %d", function (d) {
  return d.getUTCDay() && d.getUTCDate() != 1;
}], // eslint-disable-line eqeqeq
["%b %d", function (d) {
  return d.getUTCDate() != 1;
}], // eslint-disable-line eqeqeq
["%b", function (d) {
  return d.getUTCMonth();
}], ["%Y", function () {
  return true;
}]]);

function extractTickFormat(timeBin) {
  return function (tick) {
    switch (timeBin) {
      case "year":
        return Math.ceil(tick);
      case "isodow":
        return _datesAndTimes.DAYS[tick - 1];
      case "month":
        return _datesAndTimes.MONTHS[tick - 1];
      case "quarter":
        return _datesAndTimes.QUARTERS[tick - 1];
      case "hour":
      case "minute":
        return tick + 1;
      default:
        return tick;
    }
  };
}

function xDomain(extract, currentLowValue, currentHighValue, timeBin) {
  if (extract) {
    switch (timeBin) {
      case "year":
        return [currentLowValue.getFullYear(), currentHighValue.getFullYear()];
      case "quarter":
        return [1, 4]; // eslint-disable-line no-magic-numbers
      case "isodow":
        return [1, 7]; // eslint-disable-line no-magic-numbers
      case "month":
        return [1, 12]; // eslint-disable-line no-magic-numbers
      case "day":
        return [1, 31]; // eslint-disable-line no-magic-numbers
      case "hour":
        return [0, 23]; // eslint-disable-line no-magic-numbers
      case "minute":
        return [0, 59]; // eslint-disable-line no-magic-numbers
      default:
        return [1, 7]; // eslint-disable-line no-magic-numbers
    }
  } else {
    return [currentLowValue, currentHighValue];
  }
}

function xScale(extract, isChartDate) {
  if (extract || !isChartDate) {
    return _d2.default.scale.linear();
  } else {
    return _d2.default.time.scale.utc();
  }
}

function xAxisTickFormat(_ref3, isChartDate) {
  var extract = _ref3.extract,
      timeBin = _ref3.timeBin;

  if (extract) {
    return utils.extractTickFormat(timeBin);
  } else if (isChartDate) {
    return customTimeFormat;
  } else {
    return _d2.default.format(".2s");
  }
}

var printers = exports.printers = {};

printers.filters = function (filters) {
  var s = "";

  for (var i = 0; i < filters.length; ++i) {
    if (i > 0) {
      s = s + ", ";
    }
    s = s + printers.filter(filters[i]);
  }

  return s;
};

printers.filter = function (filter) {
  var s = "";

  if (typeof filter !== "undefined" && filter !== null) {
    if (filter instanceof Array) {
      if (filter.length >= 2) {
        s = "[" + utils.printSingleValue(filter[0]) + " -> " + utils.printSingleValue(filter[1]) + "]";
      } else if (filter.length >= 1) {
        s = utils.printSingleValue(filter[0]);
      }
    } else {
      s = utils.printSingleValue(filter);
    }
  }

  return s;
};

var pluck = exports.pluck = function pluck(n, f) {
  if (!f) {
    return function (d) {
      return d[n];
    };
  }
  return function (d, i) {
    return f.call(d, d[n], i);
  };
};

var utils = exports.utils = {};

utils.printSingleValue = function (filter) {
  var s = String(filter);

  if (filter instanceof Date) {
    s = dateFormat(filter);
  } else if (typeof filter === "string") {
    s = filter;
  } else if (utils.isFloat(filter)) {
    s = utils.printSingleValue.fformat(filter);
  } else if (utils.isInteger(filter)) {
    s = Math.round(filter);
  }

  return s;
};
utils.printSingleValue.fformat = _d2.default.format(".2f");

// FIXME: these assume than any string r is a percentage (whether or not it
// includes %).
utils.add = function (l, r, c) {
  if (typeof r === "string") {
    r = r.replace("%", "");
  }

  if (l instanceof Date) {
    if (typeof r === "string") {
      r = Number(r);
    }
    var d = new Date();
    d.setTime(l.getTime());
    d.setDate(l.getDate() + r);
    return d;
  } else if (typeof r === "string") {
    var percentage = Number(r) / 100;
    return l + c * percentage;
  } else {
    return l + r;
  }
};

utils.subtract = function (l, r, c) {
  if (typeof r === "string") {
    r = r.replace("%", "");
  }

  if (l instanceof Date) {
    if (typeof r === "string") {
      r = Number(r);
    }
    var d = new Date();
    d.setTime(l.getTime());
    d.setDate(l.getDate() - r);
    return d;
  } else if (typeof r === "string") {
    var percentage = Number(r) / 100;
    return l - c * percentage;
  } else {
    return l - r;
  }
};

utils.isNumber = function (n) {
  return n === Number(n);
};

utils.isFloat = function (n) {
  return n === Number(n) && n !== (n | 0);
};

utils.isInteger = function (n) {
  return n === Number(n) && n === (n | 0);
};

utils.isNegligible = function (n) {
  return !utils.isNumber(n) || n < _core.constants.NEGLIGIBLE_NUMBER && n > -_core.constants.NEGLIGIBLE_NUMBER;
};

utils.clamp = function (val, min, max) {
  return val < min ? min : val > max ? max : val;
};

var _idCounter = 0;
utils.uniqueId = function () {
  return ++_idCounter;
};

utils.nameToId = function (name) {
  if (parseFloat(name)) {
    return name;
  } else {
    return name.toLowerCase().replace(/[\s]/g, "_").replace(/[\.']/g, "");
  }
};

utils.appendOrSelect = function (parent, selector, tag) {
  tag = tag || selector;
  var element = parent.select(selector);
  if (element.empty()) {
    element = parent.append(tag);
  }
  return element;
};

utils.safeNumber = function (n) {
  return utils.isNumber(Number(n)) ? Number(n) : 0;
};

utils.b64toBlob = function (b64Data, contentType, sliceSize) {
  contentType = contentType || "";
  sliceSize = sliceSize || 512;

  var byteCharacters = atob(b64Data);
  var byteArrays = [];

  for (var offset = 0; offset < byteCharacters.length; offset = offset + sliceSize) {
    var slice = byteCharacters.slice(offset, offset + sliceSize);

    var byteNumbers = new Array(slice.length);
    for (var i = 0; i < slice.length; i++) {
      byteNumbers[i] = slice.charCodeAt(i);
    }

    var byteArray = new Uint8Array(byteNumbers);

    byteArrays.push(byteArray);
  }

  var blob = new Blob(byteArrays, { type: contentType });
  return blob;
};

utils.isOrdinal = function (type) {
  var BOOL_TYPES = { BOOL: true };

  var TEXT_TYPES = {
    varchar: true,
    text: true,
    STR: true
  };

  var TEXT_AND_BOOL_TYPES = Object.assign({}, TEXT_TYPES, BOOL_TYPES);

  return type in TEXT_AND_BOOL_TYPES;
};

utils.isQuantitative = function (type) {
  var NUMERICAL_INTEGER_TYPES = {
    int2: true,
    int4: true,
    int8: true,
    SMALLINT: true,
    INT: true,
    BIGINT: true
  };

  var NUMERICAL_REAL_TYPES = {
    FLOAT: true,
    DOUBLE: true,
    DECIMAL: true
  };

  var NONCUSTOM_NUMERICAL_TYPES = Object.assign({}, NUMERICAL_INTEGER_TYPES, NUMERICAL_REAL_TYPES);

  return type in NONCUSTOM_NUMERICAL_TYPES;
};

utils.deepEquals = _deepEqual2.default;
utils.customTimeFormat = customTimeFormat;
utils.extractTickFormat = extractTickFormat;
utils.formatValue = _formattingHelpers.formatDataValue;
utils.maybeFormatInfinity = _formattingHelpers.maybeFormatInfinity;

utils.nullsFirst = function (sorting) {
  return function (a, b) {
    if (a === null) {
      return -1;
    } else if (b === null) {
      return 1;
    }

    return sorting(a, b);
  };
};

utils.nullsLast = function (sorting) {
  return function (a, b) {
    if (a === null) {
      return 1;
    } else if (b === null) {
      return -1;
    }

    return sorting(a, b);
  };
};

/***/ }),
/* 5 */,
/* 6 */,
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizeArrayByValue = exports.isArrayOfObjects = exports.hasAllObjects = exports.isPlainObject = exports.genericDateTimeFormat = exports.momentUTCFormat = exports.nullLabelHtml = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.formatDataValue = formatDataValue;
exports.maybeFormatInfinity = maybeFormatInfinity;
exports.formatNumber = formatNumber;
exports.formatArrayValue = formatArrayValue;
exports.formatTimeBinValue = formatTimeBinValue;
exports.formatExtractValue = formatExtractValue;
exports.normalizeFiltersArray = normalizeFiltersArray;

var _datesAndTimes = __webpack_require__(36);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _moment = __webpack_require__(0);

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NUMBER_LENGTH = 4;

var numFormat = _d2.default.format(".2s");
var commafy = _d2.default.format(",");

var nullLabelHtml = exports.nullLabelHtml = "<tspan class=\"null-value\"> NULL </tspan>";
var momentUTCFormat = exports.momentUTCFormat = function momentUTCFormat(d, f) {
  return _moment2.default.utc(d).locale("en").format(f);
};
var genericDateTimeFormat = exports.genericDateTimeFormat = function genericDateTimeFormat(d) {
  return momentUTCFormat(d, "MMM D, YYYY") + " \u205F" + momentUTCFormat(d, "HH:mm:ss");
};
var isPlainObject = exports.isPlainObject = function isPlainObject(value) {
  return !Array.isArray(value) && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" && !(value instanceof Date);
};
var hasAllObjects = exports.hasAllObjects = function hasAllObjects(collection) {
  return collection.reduce(function (accum, value) {
    return isPlainObject(value) && accum;
  }, true);
};
var isArrayOfObjects = exports.isArrayOfObjects = function isArrayOfObjects(value) {
  return Array.isArray(value) && hasAllObjects(value);
};
var normalizeArrayByValue = exports.normalizeArrayByValue = function normalizeArrayByValue(collection) {
  return isArrayOfObjects(collection) ? collection.map(function (data) {
    return data.value;
  }) : collection;
};

function formatDataValue(data, numAbbr) {
  if (typeof data === "number") {
    return formatNumber(data, numAbbr);
  } else if (Array.isArray(data)) {
    return formatArrayValue(data);
  } else if (data instanceof Date) {
    return genericDateTimeFormat(data);
  } else if (data === null) {
    return nullLabelHtml;
  }
  return data;
}

function maybeFormatInfinity(data) {
  return data.map(function (d) {
    if (d.val === "-Infinity" || d.val === "Infinity") {
      d.label = d.val;
      d.val = 0;
    }
    return d;
  });
}

function formatNumber(d, abbr) {
  var isLong = String(d).length > NUMBER_LENGTH;
  var formattedHasAlpha = numFormat(d).match(/[a-z]/i);
  var isLargeNumber = isLong && formattedHasAlpha;
  return isLargeNumber && abbr ? numFormat(d) : commafy(parseFloat(d.toFixed(2)));
}

function formatArrayValue(data) {
  if (_typeof(data[0]) === "object" && !(data[0] instanceof Date)) {
    return data[0].isExtract ? formatExtractValue(data[0].value, data[0].extractUnit) : formatTimeBinValue(data);
  } else {
    return data.map(function (d) {
      return formatDataValue(d);
    }).join(" \u2013 ");
  }
}

function formatTimeBinValue(data) {
  var startTime = data[0];
  var endTime = data[1];
  switch (startTime.timeBin) {
    case "decade":
      return momentUTCFormat(startTime.value, "YYYY") + " \u2013 " + momentUTCFormat(endTime.value, "YYYY");
    case "year":
      return momentUTCFormat(startTime.value, "YYYY");
    case "quarter":
      return _moment2.default.utc(startTime.value).locale("en").quarter() + "Q " + momentUTCFormat(startTime.value, "YYYY");
    case "month":
      return momentUTCFormat(startTime.value, "MMM YYYY");
    case "week":
      return momentUTCFormat(startTime.value, "MMM D") + " \u2013 " + momentUTCFormat(endTime.value, "MMM D, YYYY");
    case "day":
      return momentUTCFormat(startTime.value, "MMM D, YYYY");
    case "hour":
    case "minute":
      return momentUTCFormat(startTime.value, "MMM D, YYYY") + " \u205F" + momentUTCFormat(startTime.value, "HH:mm");
    default:
      return genericDateTimeFormat(startTime.value);
  }
}

function formatExtractValue(number, label) {
  switch (label) {
    case "isodow":
      return _datesAndTimes.DAYS[number - 1];
    case "month":
      return _datesAndTimes.MONTHS[number - 1];
    case "quarter":
      return _datesAndTimes.QUARTERS[number - 1];
    case "hour":
      return _datesAndTimes.HOURS[number];
    case "minute":
      return number + 1;
    default:
      return number;
  }
}

function normalizeFiltersArray(filters) {
  return filters.map(function (f) {
    if (isArrayOfObjects(f)) {
      return normalizeArrayByValue(f);
    } else {
      return f;
    }
  });
}

/***/ }),
/* 8 */,
/* 9 */,
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseFilter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__create_parser__ = __webpack_require__(3);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };




function parseFilter(sql, transform) {
  var parser = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : __WEBPACK_IMPORTED_MODULE_0__create_parser__["b" /* default */];

  switch (transform.type) {
    case "filter":
      sql.where.push("(" + (_typeof(transform.expr) === "object" ? parser.parseExpression(transform.expr) : transform.expr) + ")");
    default:
      return sql;
  }
}

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseSource;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__create_parser__ = __webpack_require__(3);


function joinRelation(type) {
  switch (type) {
    case "join.left":
      return "LEFT JOIN";
    case "join.right":
      return "RIGHT JOIN";
    case "join.inner":
      return "INNER JOIN";
    case "join":
    default:
      return "JOIN";
  }
}

function parseSource(transforms) {
  var parser = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : __WEBPACK_IMPORTED_MODULE_0__create_parser__["b" /* default */];

  return transforms.reduce(function (stmt, transform, index) {
    if (typeof transform.table === "string" && transform.type === "scan") {
      return stmt.concat(transform.table);
    } else if (transform.type === "join" || transform.type === "join.inner" || transform.type === "join.left" || transform.type === "join.right") {
      var right = stmt.pop();
      var left = stmt.pop();
      var joinType = typeof transform.type === "string" ? transform.type : "join";
      // $FlowFixMe
      var joinStmt = left + " " + joinRelation(joinType) + " " + right;
      var aliasStmt = typeof transform.as === "string" ? " as " + transform.as : "";
      return stmt.concat(joinStmt + aliasStmt);
    } else if (transform.type === "data" || transform.type === "root") {
      // $FlowFixMe
      var subquery = parser.writeSQL(transform);
      return stmt.concat("(" + subquery + ")");
    } else {
      return stmt;
    }
  }, []).join();
}

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)))

/***/ }),
/* 13 */,
/* 14 */,
/* 15 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 16 */,
/* 17 */,
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__parser_create_parser__ = __webpack_require__(3);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "createParser", function() { return __WEBPACK_IMPORTED_MODULE_0__parser_create_parser__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__create_data_graph__ = __webpack_require__(31);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "createDataGraph", function() { return __WEBPACK_IMPORTED_MODULE_1__create_data_graph__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__helpers_expression_builders__ = __webpack_require__(34);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "expr", function() { return __WEBPACK_IMPORTED_MODULE_2__helpers_expression_builders__; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__helpers_transform_builders__ = __webpack_require__(35);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "rel", function() { return __WEBPACK_IMPORTED_MODULE_3__helpers_transform_builders__; });
/**
 * The exported `mapd-data-layer` module. Consists of a graph constructor and
 * helper functions to build expressions and transforms and to parse them
 * @namespace API
 */









/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseExpression;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__create_parser__ = __webpack_require__(3);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };



function parseExpression(expression) {
  var parser = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : __WEBPACK_IMPORTED_MODULE_0__create_parser__["b" /* default */];

  if (typeof expression === "string" || !(typeof expression === "undefined" ? "undefined" : _typeof(expression)) === "object") {
    return expression;
  }

  switch (expression.type) {
    case "=":
    case "<>":
    case "<":
    case ">":
    case "<=":
    case ">=":
      return expression.left + " " + expression.type + " " + (typeof expression.right === "string" ? "'" + expression.right + "'" : expression.right);
    case "between":
    case "not between":
      return expression.field + " " + expression.type.toUpperCase() + " " + expression.left + " AND " + expression.right;
    case "is null":
    case "is not null":
      return expression.field + " " + expression.type.toUpperCase();
    case "ilike":
    case "like":
    case "not like":
      return expression.left + " " + expression.type.toUpperCase() + " " + ("%\"" + expression.right + "\"%");
    case "coalesce":
      return "COALESCE(" + expression.values.map(function (field) {
        return "'" + field + "'";
      }).join(", ") + ")";
    case "in":
    case "not in":
      if (Array.isArray(expression.set)) {
        return expression.expr + " " + expression.type.toUpperCase() + " (" + expression.set.map(function (field) {
          return "'" + field + "'";
        }).join(", ") + ")";
      } else if (_typeof(expression.set) === "object" && (expression.set.type === "data" || expression.set.type === "root")) {
        return expression.expr + " " + expression.type.toUpperCase() + " (" + parser.writeSQL(expression.set) + ")";
      } else {
        return expression;
      }
    case "not":
      return "NOT(" + parseExpression(expression.expr) + ")";
    case "and":
    case "or":
      return "(" + parseExpression(expression.left) + " " + expression.type.toUpperCase() + " " + parseExpression(expression.right) + ")";
    case "case":
      return "CASE WHEN " + expression.cond.map(function (cond) {
        return parseExpression(cond[0]) + " THEN " + cond[1];
      }).join(" ") + " ELSE '" + expression.else + "' END";
    case "date_trunc":
      return "date_trunc(" + expression.unit + ", " + expression.field + ")";
    case "extract":
      return "extract(" + expression.unit + " from " + expression.field + ")";
    case "root":
      return "(" + parser.writeSQL(expression) + ")";
    case "count":
      if (expression.distinct && expression.approx) {
        return "approx_count_distinct(" + expression.field + ")";
      } else if (expression.distinct) {
        return "count(distinct " + expression.field + " )";
      } else {
        return "count(" + expression.field + ")";
      }
    case "stddev":
    case "stddev_pop":
    case "stddev_samp":
    case "var_pop":
    case "var_samp":
      return expression.type + "(" + expression.x + ")";
    case "corr":
    case "covar_pop":
    case "covar_samp":
      return expression.type + "(" + expression.x + ", " + expression.y + ")";
    case "min":
    case "max":
    case "sum":
      return expression.type + "(" + expression.field + ")";
    case "average":
      return "avg(" + expression.field + ")";
    default:
      return expression;
  }
}

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseDataState;


function parseDataState(state, parser) {
  var initialSQL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    select: [],
    from: "",
    where: [],
    groupby: [],
    having: [],
    orderby: [],
    limit: "",
    offset: "",
    unresolved: {}
  };

  return state.transform.reduce(function (sql, t) {
    return parser.parseTransform(sql, t, parser);
  }, {
    select: initialSQL.select,
    from: state.type === "root" ? typeof state.source === "string" ? state.source : parser.parseSource(state.source) : initialSQL.from,
    where: initialSQL.where,
    groupby: initialSQL.groupby,
    having: initialSQL.having,
    orderby: initialSQL.orderby,
    limit: initialSQL.limit,
    offset: initialSQL.offset,
    unresolved: initialSQL.unresolved
  });
}

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseTransform;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__parse_aggregate__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse_bin__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__parse_crossfilter__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__parse_sort__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__parse_limit__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__parse_filter__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__parse_project__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__parse_resolvefilter__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__parse_sample__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__parse_source__ = __webpack_require__(11);











function parseTransform(sql, t, parser) {
  switch (t.type) {
    case "aggregate":
      return Object(__WEBPACK_IMPORTED_MODULE_0__parse_aggregate__["a" /* default */])(sql, t, parser);
    case "bin":
      return Object(__WEBPACK_IMPORTED_MODULE_1__parse_bin__["a" /* default */])(sql, t);
    case "sort":
      return Object(__WEBPACK_IMPORTED_MODULE_3__parse_sort__["a" /* default */])(sql, t);
    case "limit":
      return Object(__WEBPACK_IMPORTED_MODULE_4__parse_limit__["a" /* default */])(sql, t);
    case "filter":
      return Object(__WEBPACK_IMPORTED_MODULE_5__parse_filter__["a" /* default */])(sql, t, parser);
    case "project":
      return Object(__WEBPACK_IMPORTED_MODULE_6__parse_project__["a" /* default */])(sql, t, parser);
    case "sample":
      return Object(__WEBPACK_IMPORTED_MODULE_8__parse_sample__["a" /* default */])(sql, t);
    case "resolvefilter":
      return Object(__WEBPACK_IMPORTED_MODULE_7__parse_resolvefilter__["a" /* default */])(sql, t);
    case "crossfilter":
      return Object(__WEBPACK_IMPORTED_MODULE_2__parse_crossfilter__["a" /* default */])(sql, t);
    /* istanbul ignore next */
    default:
      return sql;
  }
}

/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseAggregate;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__create_parser__ = __webpack_require__(3);


var AGGREGATES = {
  average: "AVG",
  count: "COUNT",
  min: "MIN",
  max: "MAX",
  sum: "SUM"
};

function parseAggregate(sql, transform) {
  var parser = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : __WEBPACK_IMPORTED_MODULE_0__create_parser__["b" /* default */];

  if (Array.isArray(transform.groupby)) {
    transform.groupby.forEach(function (group) {
      sql = parseGroupBy(sql, group, parser);
    });
  } else {
    sql = parseGroupBy(sql, transform.groupby, parser);
  }

  transform.fields.forEach(function (field, index) {
    var as = transform.as[index];
    sql.select.push(aggregateField(transform.ops[index], field, as));
  });

  return sql;
}

function aggregateField(op, field, as) {
  var str = "";
  if (op === null) {
    str += field;
  } else if (AGGREGATES[op]) {
    str += AGGREGATES[op] + "(" + field + ")";
  }
  return str + ("" + (as ? " as " + as : ""));
}

function parseGroupBy(sql, groupby, parser) {
  if (typeof groupby === "string") {
    sql.select.push(groupby);
    sql.groupby.push(groupby);
  } else if (groupby.type === "bin") {
    sql = parser.parseTransform(sql, groupby);
    sql.groupby.push(groupby.as);
  } else if (groupby.type === "project") {
    sql.select.push(parser.parseExpression(groupby.expr) + (groupby.as ? " as " + groupby.as : ""));
    if (groupby.as) {
      sql.groupby.push(groupby.as);
    }
  }
  return sql;
}

/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseBin;


function parseBin(sql, _ref) {
  var field = _ref.field,
      as = _ref.as,
      extent = _ref.extent,
      maxbins = _ref.maxbins;

  sql.select.push("cast((cast(" + field + " as float) - " + extent[0] + ") * " + maxbins / (extent[1] - extent[0]) + " as int) as " + as);
  sql.where.push("((" + field + " >= " + extent[0] + " AND " + field + " <= " + extent[1] + ") OR (" + field + " IS NULL))");
  sql.having.push("(" + as + " >= 0 AND " + as + " < " + maxbins + " OR " + as + " IS NULL)");
  return sql;
}

/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseCrossfilter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__create_parser__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse_filter__ = __webpack_require__(10);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };




function parseCrossfilter(sql, transform) {
  var parser = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : __WEBPACK_IMPORTED_MODULE_0__create_parser__["b" /* default */];

  switch (transform.type) {
    case "crossfilter":
      if (_typeof(sql.unresolved) === "object") {
        if (sql.unresolved.hasOwnProperty(transform.signal)) {
          transform.filter.forEach(function (filter) {
            if (sql.unresolved) {
              var ignore = sql.unresolved[transform.signal].ignore;

              if (Array.isArray(ignore) ? ignore.indexOf(filter.id) === -1 : filter.id !== ignore) {
                Object(__WEBPACK_IMPORTED_MODULE_1__parse_filter__["a" /* default */])(sql, filter, parser);
              }
            }
          });
        }
      }
    default:
      return sql;
  }
}

/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseSort;


var ORDERINGS = {
  ascending: "ASC",
  descending: "DESC"
};


function parseSort(sql, transform) {
  transform.field.forEach(function (field, index) {
    sql.orderby.push(field + (Array.isArray(transform.order) ? " " + ORDERINGS[transform.order[index]] : ""));
  });
  return sql;
}

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseLimit;


function parseLimit(sql, transform) {
  sql.limit += transform.row;
  sql.offset += transform.offset || sql.offset;
  return sql;
}

/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseProject;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__create_parser__ = __webpack_require__(3);



function parseProject(sql, transform) {
  var parser = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : __WEBPACK_IMPORTED_MODULE_0__create_parser__["b" /* default */];

  sql.select.push(parser.parseExpression(transform.expr) + (transform.as ? " as " + transform.as : ""));
  return sql;
}

/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseResolvefilter;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function parseResolvefilter(sql, transform) {
  switch (transform.type) {
    case "resolvefilter":
      if (_typeof(sql.unresolved) === "object") {
        sql.unresolved[transform.filter.signal] = transform;
      } else {
        sql.unresolved = _defineProperty({}, transform.filter.signal, transform);
      }
    default:
      return sql;
  }
}

/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = sample;


var GOLDEN_RATIO = 265445761;

var THIRTY_TWO_BITS = 4294967296;

function sample(sql, transform) {
  /* istanbul ignore else */
  if (transform.method === "multiplicative") {
    var size = transform.size,
        limit = transform.limit;

    var ratio = Math.min(limit / size, 1.0);
    if (ratio < 1) {
      var threshold = Math.floor(THIRTY_TWO_BITS * ratio);
      sql.where.push("MOD(" + sql.from + ".rowid * " + GOLDEN_RATIO + ", " + THIRTY_TWO_BITS + ") < " + threshold);
    }
  }

  return sql;
}

/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = writeSQL;
/* harmony export (immutable) */ __webpack_exports__["b"] = write;


function writeSQL(state, parser) {
  return write(parser.parseDataState(state));
}


function write(sql) {
  return writeSelect(sql.select) + writeFrom(sql.from) + writeWhere(sql.where) + writeGroupby(sql.groupby) + writeHaving(sql.having) + writeOrderBy(sql.orderby) + writeLimit(sql.limit) + writeOffset(sql.offset);
}

function writeSelect(select) {
  return select.length ? "SELECT " + select.join(", ") : "SELECT *";
}

function writeFrom(from) {
  return " FROM " + from;
}

function writeWhere(where) {
  return where.length ? " WHERE " + where.join(" AND ") : "";
}

function writeGroupby(groupby) {
  return groupby.length ? " GROUP BY " + groupby.join(", ") : "";
}

function writeHaving(having) {
  return having.length ? " HAVING " + having.join(" AND ") : "";
}

function writeOrderBy(orderby) {
  return orderby.length ? " ORDER BY " + orderby.join(", ") : "";
}

function writeLimit(limit) {
  return limit.length ? " LIMIT " + limit : "";
}

function writeOffset(offset) {
  return offset.length ? " OFFSET " + offset : "";
}

/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = createDataGraph;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__create_data_node__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parser_create_parser__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_invariant__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_invariant__);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };





/**
 * Creates a data graph instance. Must pass in a connector object that implements a query method.
 * @see {@link Graph} for further information.
 * @memberof API
 */
function createDataGraph(connector) {
  __WEBPACK_IMPORTED_MODULE_2_invariant___default()(typeof connector.query === "function", "invalid connector");

  var context = {
    connector: connector,
    parser: Object(__WEBPACK_IMPORTED_MODULE_1__parser_create_parser__["a" /* createParser */])()
  };

  var childNodes = [];

  /**
   * An instance of a data graph. A data graph is basically a tree, where each
   * node represents a
   * @namespace Graph
   */
  var graphAPI = {
    registerParser: registerParser,
    children: children,
    data: data
  };

  /**
   * Registers a custom expression or transform parser. The `typeDef` argument
   * must be a valid type definition and the `typeParser` argument must be a
   * function that matches the type of an ExpressionParser or TransformParser
   * @see {@link https://github.com/mapd/mapd-data-layer/tree/master/src/parser/createParser.js|createParser.js}
   * @memberof Graph
   * @inner
   */
  function registerParser(typeDef, typeParser) {
    context.parser.registerParser(typeDef, typeParser);
  }

  /**
   * Returns all child data node instances of the graph.
   * @memberof Graph
   * @inner
   */
  function children() {
    return childNodes;
  }

  /**
   * Creates a root data node instance. The source must be specific in the
   * initial state. An example of a source, is a string pointing to a tables
   * or an array of source transformations.
   * @memberof Graph
   * @inner
   */
  function data(state) {
    var dataNode = Object(__WEBPACK_IMPORTED_MODULE_0__create_data_node__["a" /* default */])(context, typeof state === "string" || Array.isArray(state) ? { source: state, type: "root" } : _extends({}, state, { type: "root" }));
    childNodes.push(dataNode);
    return dataNode;
  }

  return graphAPI;
}

/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = createDataNode;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_invariant__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(33);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };




function createDataNode(context) {
  var initialState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var state = {
    type: initialState.type || "data",
    source: initialState.source,
    transform: initialState.transform || [],
    children: initialState.children || []
  };

  /**
   * A node in the graph that represents a set of data transformations.
   * @namespace Data
   * @see {@link https://github.com/mapd/mapd-data-layer/tree/master/src/create-data-node.js|create-data-node.js}
   */
  var dataNodeAPI = {
    getState: getState,
    transform: transform,
    toSQL: toSQL,
    values: values,
    data: data
  };

  /**
   * Returns the state of the data node.
   * @memberof Data
   * @inner
   */
  function getState() {
    return state;
  }

  /**
   * Sets the transform state of the data node. Either takes in an array of
   * transforms or a function that takes and returns an array of transforms
   * @memberof Data
   * @inner
   */
  function transform(setter) {
    state.transform = typeof setter === "function" ? setter(state.transform) : setter;
    return dataNodeAPI;
  }

  /**
   * Returns the SQL string representation of the set of transforms from
   * the node instance to its source root in the graph
   * @memberof Data
   * @inner
   */
  function toSQL() {
    return context.parser.write(Object(__WEBPACK_IMPORTED_MODULE_1__utils__["a" /* reduceToSQL */])(context, dataNodeAPI));
  }

  /**
   * Uses the `connector` in the graph context to execute data node's
   * SQL query representation and returns queried data as a promise.
   * @memberof Data
   * @inner
   */
  function values() {
    return context.connector.query(context.parser.write(Object(__WEBPACK_IMPORTED_MODULE_1__utils__["a" /* reduceToSQL */])(context, dataNodeAPI)));
  }

  /**
   * Creates a data node instance and sets it as a child of the parent.
   * @memberof Data
   * @inner
   */
  function data(childState) {
    var dataNode = createDataNode(context, _extends({}, childState, {
      source: dataNodeAPI
    }));
    state.children.push(dataNode);
    return dataNode;
  }

  return dataNodeAPI;
}

/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export traverse */
/* harmony export (immutable) */ __webpack_exports__["a"] = reduceToSQL;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var identity = function identity(a) {
  return a;
};


function traverse(node, iterator, xform, accum) {
  accum = xform(accum, iterator(node));
  var source = node.getState().source;
  return (typeof source === "undefined" ? "undefined" : _typeof(source)) === "object" && !Array.isArray(source) ? traverse(source, iterator, xform, accum) : accum;
}

function reduceToSQL(context, node) {
  var initialSQL = {
    select: [],
    from: "",
    where: [],
    groupby: [],
    having: [],
    orderby: [],
    limit: "",
    offset: "",
    unresolved: {}
  };

  function toSQL(accum, rightNode) {
    return context.parser.parseDataState(rightNode.getState(), accum);
  }

  return traverse(node, identity, toSQL, initialSQL);
}

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["alias"] = alias;
/* harmony export (immutable) */ __webpack_exports__["avg"] = avg;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["sum"] = sum;
/* harmony export (immutable) */ __webpack_exports__["count"] = count;
/* harmony export (immutable) */ __webpack_exports__["approxCount"] = approxCount;
/* harmony export (immutable) */ __webpack_exports__["countStar"] = countStar;
/* harmony export (immutable) */ __webpack_exports__["extract"] = extract;
/* harmony export (immutable) */ __webpack_exports__["dateTrunc"] = dateTrunc;
/* harmony export (immutable) */ __webpack_exports__["inExpr"] = inExpr;
/* harmony export (immutable) */ __webpack_exports__["not"] = not;
/* harmony export (immutable) */ __webpack_exports__["caseExpr"] = caseExpr;
/* harmony export (immutable) */ __webpack_exports__["between"] = between;


/**
 * Creates an alias expression
 * @memberof Expression
 */
function alias(as, expr) {
  return {
    expr: expr,
    as: as
  };
}

/**
 * Creates an average expression
 * @memberof Expression
 */

/**
 * Expression builders. These are helper functions to create expression objects
 * @name expr
 * @memberof API
 * @see {@link Expression}
 */

/**
 * Expression builder module.
 * @name Expression
 * @see {@link https://github.com/mapd/mapd-data-layer/tree/master/src/types/expression-type.js|Expression Types}
 */
function avg(alias, field) {
  return {
    type: "average",
    field: field,
    as: alias
  };
}

/**
 * creates a min expression
 * @memberof Expression
 */
function min(alias, field) {
  return {
    type: "min",
    field: field,
    as: alias
  };
}

/**
 * creates a max expression
 * @memberof Expression
 */
function max(alias, field) {
  return {
    type: "max",
    field: field,
    as: alias
  };
}

/**
 * creates a sum expression
 * @memberof Expression
 */
function sum(alias, field) {
  return {
    type: "sum",
    field: field,
    as: alias
  };
}

/**
 * creates a count expression
 * @memberof Expression
 */
function count(distinct, alias, field) {
  return {
    type: "count",
    distinct: distinct,
    approx: false,
    field: field,
    as: alias
  };
}

/**
 * creates an approx count expression
 * @memberof Expression
 */
function approxCount(distinct, alias, field) {
  return {
    type: "count",
    distinct: distinct,
    approx: true,
    field: field,
    as: alias
  };
}

/**
 * creates a count star expression
 * @memberof Expression
 */
function countStar(alias) {
  return {
    type: "count",
    distinct: false,
    approx: false,
    field: "*",
    as: alias
  };
}

/**
 * creates an extract function expression
 * @memberof Expression
 */
function extract(unit, field) {
  return {
    type: "extract",
    unit: unit,
    field: field
  };
}

/**
 * creates a date_trunc function expression
 * @memberof Expression
 */
function dateTrunc(unit, field) {
  return {
    type: "date_trunc",
    unit: unit,
    field: field
  };
}

/**
 * creates an in expression
 * @memberof Expression
 */
function inExpr(expr, set) {
  return {
    type: "in",
    expr: expr,
    set: set
  };
}

/**
 * Creates a not expression
 * @memberof Expression
 */
function not(expr) {
  return {
    type: "not",
    expr: expr
  };
}

/**
 * Creates a case expression
 * @memberof Expression
 */
function caseExpr(cond, end) {
  return {
    type: "case",
    cond: cond,
    else: end
  };
}

/**
 * Creates a between expression
 * @memberof Expression
 */
function between(field, range) {
  return {
    type: "between",
    field: field,
    left: range[0],
    right: range[1]
  };
}

/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["project"] = project;
/* harmony export (immutable) */ __webpack_exports__["aggregate"] = aggregate;
/* harmony export (immutable) */ __webpack_exports__["filter"] = filter;
/* harmony export (immutable) */ __webpack_exports__["filterRange"] = filterRange;
/* harmony export (immutable) */ __webpack_exports__["filterIn"] = filterIn;
/* harmony export (immutable) */ __webpack_exports__["bin"] = bin;
/* harmony export (immutable) */ __webpack_exports__["limit"] = limit;
/* harmony export (immutable) */ __webpack_exports__["sort"] = sort;
/* harmony export (immutable) */ __webpack_exports__["top"] = top;
/* harmony export (immutable) */ __webpack_exports__["bottom"] = bottom;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Creates a Project transform
 * @memberof Transform
 */
function project(expr) {
  // $FlowFixMe
  return {
    type: "project",
    expr: typeof expr === "string" ? expr : expr.expr,
    as: typeof expr === "string" ? null : expr.as
  };
}
/**
 * Transform builders. These are helpers function to create transform objects.
 * @name rel
 * @memberof API
 * @see {@link #transform-1|Transform}
 */

/**
 * Transsform builder module.
 * @name Transform
 * @see {@link https://github.com/mapd/mapd-data-layer/tree/master/src/types/transform-type.js|Transform Types}
 */


function getAggs(agg) {
  if (Array.isArray(agg)) {
    return {
      fields: agg.map(function (a) {
        return a.field;
      }),
      ops: agg.map(function (a) {
        return a.type;
      }),
      // $FlowFixMe
      as: agg.map(function (a) {
        return a.as;
      })
    };
  } else {
    return {
      fields: [agg.field],
      ops: [agg.type],
      as: [agg.as || ""]
    };
  }
}

function getGroupBy(groupby) {
  if (Array.isArray(groupby)) {
    return groupby.map(function (group) {
      if ((typeof group === "undefined" ? "undefined" : _typeof(group)) === "object") {
        return {
          type: "project",
          expr: group.expr,
          as: group.as
        };
      } else {
        return group;
      }
    });
  } else if ((typeof groupby === "undefined" ? "undefined" : _typeof(groupby)) === "object") {
    return {
      type: "project",
      expr: groupby.expr,
      as: groupby.as
    };
  } else {
    return groupby;
  }
}

/**
 * Creates an Aggregate transform
 * @memberof Transform
 */
function aggregate(groupby, agg) {
  var aggs = getAggs(agg);
  var group = getGroupBy(groupby);
  return {
    type: "aggregate",
    fields: aggs.fields,
    ops: aggs.ops,
    as: aggs.as,
    groupby: group
  };
}

/**
 * Creates an Filter transform
 * @memberof Transform
 */
function filter(expr) {
  var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

  return {
    type: "filter",
    id: id,
    expr: expr
  };
}

/**
 * Creates an Filter transform that uses a between expression
 * @memberof Transform
 */
function filterRange(field, range) {
  var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

  return {
    type: "filter",
    id: id,
    expr: {
      type: "between",
      field: field,
      left: range[0],
      right: range[1]
    }
  };
}

/**
 * Creates an Filter transform that uses an in expression
 * @memberof Transform
 */
function filterIn(field, set) {
  var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

  return {
    type: "filter",
    id: id,
    expr: {
      type: "in",
      expr: field,
      set: set
    }
  };
}

/**
 * Creates a Bin tranform
 * @memberof Transform
 */
function bin(alias, field, extent, maxbins) {
  return {
    type: "bin",
    field: field,
    extent: extent,
    maxbins: maxbins,
    as: alias
  };
}

/**
 * Creates a Limit transform
 * @memberof Transform
 */
function limit(row, offset) {
  return {
    type: "limit",
    row: row,
    offset: offset
  };
}

/**
 * Creates a Sort transform
 * @memberof Transform
 */
function sort(field, order) {
  return {
    type: "sort",
    field: typeof field === "string" ? [field] : field,
    order: typeof order === "string" ? [order] : order
  };
}

/**
 * Creates a Sort transform ordered by descending and a Limit transform
 * @memberof Transform
 */
function top(field, limit, offset) {
  return [{
    type: "sort",
    field: [field],
    order: ["descending"]
  }, {
    type: "limit",
    row: limit,
    offset: offset
  }];
}

/**
* Creates a Sort transform ordered by ascending and a Limit transform
 * @memberof Transform
 */
function bottom(field, limit, offset) {
  return [{
    type: "sort",
    field: [field],
    order: ["ascending"]
  }, {
    type: "limit",
    row: limit,
    offset: offset
  }];
}

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var DAYS = exports.DAYS = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];

var MONTHS = exports.MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

var QUARTERS = exports.QUARTERS = ["Q1", "Q2", "Q3", "Q4"];

var HOURS = exports.HOURS = ["12AM", "1AM", "2AM", "3AM", "4AM", "5AM", "6AM", "7AM", "8AM", "9AM", "10AM", "11AM", "12PM", "1PM", "2PM", "3PM", "4PM", "5PM", "6PM", "7PM", "8PM", "9PM", "10PM", "11PM"];

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : afrikaans (af)
//! author : Werner Mollentze : https://github.com/wernerm

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var af = moment.defineLocale('af', {
        months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
        weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
        weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
        weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
        meridiemParse: /vm|nm/i,
        isPM : function (input) {
            return /^nm$/i.test(input);
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? 'vm' : 'VM';
            } else {
                return isLower ? 'nm' : 'NM';
            }
        },
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Vandag om] LT',
            nextDay : '[Mre om] LT',
            nextWeek : 'dddd [om] LT',
            lastDay : '[Gister om] LT',
            lastWeek : '[Laas] dddd [om] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'oor %s',
            past : '%s gelede',
            s : '\'n paar sekondes',
            m : '\'n minuut',
            mm : '%d minute',
            h : '\'n uur',
            hh : '%d ure',
            d : '\'n dag',
            dd : '%d dae',
            M : '\'n maand',
            MM : '%d maande',
            y : '\'n jaar',
            yy : '%d jaar'
        },
        ordinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter
        },
        week : {
            dow : 1, // Maandag is die eerste dag van die week.
            doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
        }
    });

    return af;

}));

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! Locale: Arabic (ar)
//! Author: Abdel Said: https://github.com/abdelsaid
//! Changes in months, weekdays: Ahmed Elkhatib
//! Native plural forms: forabi https://github.com/forabi

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    }, pluralForm = function (n) {
        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    }, plurals = {
        s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
    }, pluralize = function (u) {
        return function (number, withoutSuffix, string, isFuture) {
            var f = pluralForm(number),
                str = plurals[u][pluralForm(number)];
            if (f === 2) {
                str = str[withoutSuffix ? 0 : 1];
            }
            return str.replace(/%d/i, number);
        };
    }, months = [
        '  ',
        ' ',
        ' ',
        ' ',
        ' ',
        ' ',
        ' ',
        ' ',
        ' ',
        '  ',
        '  ',
        '  '
    ];

    var ar = moment.defineLocale('ar', {
        months : months,
        monthsShort : months,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'D/\u200FM/\u200FYYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM : function (input) {
            return '' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : pluralize('s'),
            m : pluralize('m'),
            mm : pluralize('m'),
            h : pluralize('h'),
            hh : pluralize('h'),
            d : pluralize('d'),
            dd : pluralize('d'),
            M : pluralize('M'),
            MM : pluralize('M'),
            y : pluralize('y'),
            yy : pluralize('y')
        },
        preparse: function (string) {
            return string.replace(/\u200f/g, '').replace(/[]/g, function (match) {
                return numberMap[match];
            }).replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '');
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ar;

}));

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Moroccan Arabic (ar-ma)
//! author : ElFadili Yassine : https://github.com/ElFadiliY
//! author : Abdel Said : https://github.com/abdelsaid

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var ar_ma = moment.defineLocale('ar-ma', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : '',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ar_ma;

}));

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic Saudi Arabia (ar-sa)
//! author : Suhail Alkowaileet : https://github.com/xsoh

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var ar_sa = moment.defineLocale('ar-sa', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM : function (input) {
            return '' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : '',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            }).replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '');
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ar_sa;

}));

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale  : Tunisian Arabic (ar-tn)

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var ar_tn = moment.defineLocale('ar-tn', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s',
            past: ' %s',
            s: '',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return ar_tn;

}));

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : azerbaijani (az)
//! author : topchiyev : https://github.com/topchiyev

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var suffixes = {
        1: '-inci',
        5: '-inci',
        8: '-inci',
        70: '-inci',
        80: '-inci',
        2: '-nci',
        7: '-nci',
        20: '-nci',
        50: '-nci',
        3: '-nc',
        4: '-nc',
        100: '-nc',
        6: '-nc',
        9: '-uncu',
        10: '-uncu',
        30: '-uncu',
        60: '-nc',
        90: '-nc'
    };

    var az = moment.defineLocale('az', {
        months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
        monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
        weekdays : 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),
        weekdaysShort : 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),
        weekdaysMin : 'Bz_BE_A__CA_C_'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[bugn saat] LT',
            nextDay : '[sabah saat] LT',
            nextWeek : '[gln hft] dddd [saat] LT',
            lastDay : '[dnn] LT',
            lastWeek : '[ken hft] dddd [saat] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s sonra',
            past : '%s vvl',
            s : 'birne saniyy',
            m : 'bir dqiq',
            mm : '%d dqiq',
            h : 'bir saat',
            hh : '%d saat',
            d : 'bir gn',
            dd : '%d gn',
            M : 'bir ay',
            MM : '%d ay',
            y : 'bir il',
            yy : '%d il'
        },
        meridiemParse: /gec|shr|gndz|axam/,
        isPM : function (input) {
            return /^(gndz|axam)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'gec';
            } else if (hour < 12) {
                return 'shr';
            } else if (hour < 17) {
                return 'gndz';
            } else {
                return 'axam';
            }
        },
        ordinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
        ordinal : function (number) {
            if (number === 0) {  // special case for zero
                return number + '-nc';
            }
            var a = number % 10,
                b = number % 100 - a,
                c = number >= 100 ? 100 : null;
            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return az;

}));

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : belarusian (be)
//! author : Dmitry Demidov : https://github.com/demidov91
//! author: Praleska: http://praleska.pro/
//! Author : Menelion Elensle : https://github.com/Oire

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'mm': withoutSuffix ? '__' : '__',
            'hh': withoutSuffix ? '__' : '__',
            'dd': '__',
            'MM': '__',
            'yy': '__'
        };
        if (key === 'm') {
            return withoutSuffix ? '' : '';
        }
        else if (key === 'h') {
            return withoutSuffix ? '' : '';
        }
        else {
            return number + ' ' + plural(format[key], +number);
        }
    }

    var be = moment.defineLocale('be', {
        months : {
            format: '___________'.split('_'),
            standalone: '___________'.split('_')
        },
        monthsShort : '___________'.split('_'),
        weekdays : {
            format: '______'.split('_'),
            standalone: '______'.split('_'),
            isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/
        },
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY .',
            LLL : 'D MMMM YYYY ., HH:mm',
            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
        },
        calendar : {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            lastDay: '[ ] LT',
            nextWeek: function () {
                return '[] dddd [] LT';
            },
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                case 3:
                case 5:
                case 6:
                    return '[ ] dddd [] LT';
                case 1:
                case 2:
                case 4:
                    return '[ ] dddd [] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            m : relativeTimeWithPlural,
            mm : relativeTimeWithPlural,
            h : relativeTimeWithPlural,
            hh : relativeTimeWithPlural,
            d : '',
            dd : relativeTimeWithPlural,
            M : '',
            MM : relativeTimeWithPlural,
            y : '',
            yy : relativeTimeWithPlural
        },
        meridiemParse: /|||/,
        isPM : function (input) {
            return /^(|)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return '';
            } else {
                return '';
            }
        },
        ordinalParse: /\d{1,2}-(||)/,
        ordinal: function (number, period) {
            switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
            case 'w':
            case 'W':
                return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-' : number + '-';
            case 'D':
                return number + '-';
            default:
                return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return be;

}));

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : bulgarian (bg)
//! author : Krasen Borisov : https://github.com/kraz

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var bg = moment.defineLocale('bg', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'D.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd, D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ] LT',
            lastWeek : function () {
                switch (this.day()) {
                case 0:
                case 3:
                case 6:
                    return '[ ] dddd [] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[ ] dddd [] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : ' ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        ordinalParse: /\d{1,2}-(|||||)/,
        ordinal : function (number) {
            var lastDigit = number % 10,
                last2Digits = number % 100;
            if (number === 0) {
                return number + '-';
            } else if (last2Digits === 0) {
                return number + '-';
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + '-';
            } else if (lastDigit === 1) {
                return number + '-';
            } else if (lastDigit === 2) {
                return number + '-';
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + '-';
            } else {
                return number + '-';
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return bg;

}));

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bengali (bn)
//! author : Kaushik Gandhi : https://github.com/kaushikgandhi

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var bn = moment.defineLocale('bn', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm ',
            LTS : 'A h:mm:ss ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm '
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /||||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if ((meridiem === '' && hour >= 4) ||
                    (meridiem === '' && hour < 5) ||
                    meridiem === '') {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return bn;

}));

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : tibetan (bo)
//! author : Thupten N. Chakrishar : https://github.com/vajradog

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var bo = moment.defineLocale('bo', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm',
            LTS : 'A h:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm',
            LLLL : 'dddd, D MMMM YYYY, A h:mm'
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : '[], LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : '',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /||||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if ((meridiem === '' && hour >= 4) ||
                    (meridiem === '' && hour < 5) ||
                    meridiem === '') {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return bo;

}));

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : breton (br)
//! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function relativeTimeWithMutation(number, withoutSuffix, key) {
        var format = {
            'mm': 'munutenn',
            'MM': 'miz',
            'dd': 'devezh'
        };
        return number + ' ' + mutation(format[key], number);
    }
    function specialMutationForYears(number) {
        switch (lastNumber(number)) {
        case 1:
        case 3:
        case 4:
        case 5:
        case 9:
            return number + ' bloaz';
        default:
            return number + ' vloaz';
        }
    }
    function lastNumber(number) {
        if (number > 9) {
            return lastNumber(number % 10);
        }
        return number;
    }
    function mutation(text, number) {
        if (number === 2) {
            return softMutation(text);
        }
        return text;
    }
    function softMutation(text) {
        var mutationTable = {
            'm': 'v',
            'b': 'v',
            'd': 'z'
        };
        if (mutationTable[text.charAt(0)] === undefined) {
            return text;
        }
        return mutationTable[text.charAt(0)] + text.substring(1);
    }

    var br = moment.defineLocale('br', {
        months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
        monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
        weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
        weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
        weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'h[e]mm A',
            LTS : 'h[e]mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D [a viz] MMMM YYYY',
            LLL : 'D [a viz] MMMM YYYY h[e]mm A',
            LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'
        },
        calendar : {
            sameDay : '[Hiziv da] LT',
            nextDay : '[Warc\'hoazh da] LT',
            nextWeek : 'dddd [da] LT',
            lastDay : '[Dec\'h da] LT',
            lastWeek : 'dddd [paset da] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'a-benn %s',
            past : '%s \'zo',
            s : 'un nebeud segondenno',
            m : 'ur vunutenn',
            mm : relativeTimeWithMutation,
            h : 'un eur',
            hh : '%d eur',
            d : 'un devezh',
            dd : relativeTimeWithMutation,
            M : 'ur miz',
            MM : relativeTimeWithMutation,
            y : 'ur bloaz',
            yy : specialMutationForYears
        },
        ordinalParse: /\d{1,2}(a|vet)/,
        ordinal : function (number) {
            var output = (number === 1) ? 'a' : 'vet';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return br;

}));

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : bosnian (bs)
//! author : Nedim Cholich : https://github.com/frontyard
//! based on (hr) translation by Bojan Markovi

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
        case 'm':
            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
        case 'mm':
            if (number === 1) {
                result += 'minuta';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'minute';
            } else {
                result += 'minuta';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'jedan sat' : 'jednog sata';
        case 'hh':
            if (number === 1) {
                result += 'sat';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'sata';
            } else {
                result += 'sati';
            }
            return result;
        case 'dd':
            if (number === 1) {
                result += 'dan';
            } else {
                result += 'dana';
            }
            return result;
        case 'MM':
            if (number === 1) {
                result += 'mjesec';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'mjeseca';
            } else {
                result += 'mjeseci';
            }
            return result;
        case 'yy':
            if (number === 1) {
                result += 'godina';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'godine';
            } else {
                result += 'godina';
            }
            return result;
        }
    }

    var bs = moment.defineLocale('bs', {
        months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
        weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
        weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD. MM. YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[danas u] LT',
            nextDay  : '[sutra u] LT',
            nextWeek : function () {
                switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[juer u] LT',
            lastWeek : function () {
                switch (this.day()) {
                case 0:
                case 3:
                    return '[prolu] dddd [u] LT';
                case 6:
                    return '[prole] [subote] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[proli] dddd [u] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'par sekundi',
            m      : translate,
            mm     : translate,
            h      : translate,
            hh     : translate,
            d      : 'dan',
            dd     : translate,
            M      : 'mjesec',
            MM     : translate,
            y      : 'godinu',
            yy     : translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return bs;

}));

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : catalan (ca)
//! author : Juan G. Hurtado : https://github.com/juanghurtado

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var ca = moment.defineLocale('ca', {
        months : 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
        monthsShort : 'gen._febr._mar._abr._mai._jun._jul._ag._set._oct._nov._des.'.split('_'),
        monthsParseExact : true,
        weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
        weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
        weekdaysMin : 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay : function () {
                return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            nextDay : function () {
                return '[dem a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            lastDay : function () {
                return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'en %s',
            past : 'fa %s',
            s : 'uns segons',
            m : 'un minut',
            mm : '%d minuts',
            h : 'una hora',
            hh : '%d hores',
            d : 'un dia',
            dd : '%d dies',
            M : 'un mes',
            MM : '%d mesos',
            y : 'un any',
            yy : '%d anys'
        },
        ordinalParse: /\d{1,2}(r|n|t||a)/,
        ordinal : function (number, period) {
            var output = (number === 1) ? 'r' :
                (number === 2) ? 'n' :
                (number === 3) ? 'r' :
                (number === 4) ? 't' : '';
            if (period === 'w' || period === 'W') {
                output = 'a';
            }
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return ca;

}));

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : czech (cs)
//! author : petrbela : https://github.com/petrbela

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var months = 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_'),
        monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_');
    function plural(n) {
        return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
        case 's':  // a few seconds / in a few seconds / a few seconds ago
            return (withoutSuffix || isFuture) ? 'pr sekund' : 'pr sekundami';
        case 'm':  // a minute / in a minute / a minute ago
            return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'minuty' : 'minut');
            } else {
                return result + 'minutami';
            }
            break;
        case 'h':  // an hour / in an hour / an hour ago
            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
        case 'hh': // 9 hours / in 9 hours / 9 hours ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'hodiny' : 'hodin');
            } else {
                return result + 'hodinami';
            }
            break;
        case 'd':  // a day / in a day / a day ago
            return (withoutSuffix || isFuture) ? 'den' : 'dnem';
        case 'dd': // 9 days / in 9 days / 9 days ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'dny' : 'dn');
            } else {
                return result + 'dny';
            }
            break;
        case 'M':  // a month / in a month / a month ago
            return (withoutSuffix || isFuture) ? 'msc' : 'mscem';
        case 'MM': // 9 months / in 9 months / 9 months ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'msce' : 'msc');
            } else {
                return result + 'msci';
            }
            break;
        case 'y':  // a year / in a year / a year ago
            return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
        case 'yy': // 9 years / in 9 years / 9 years ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'roky' : 'let');
            } else {
                return result + 'lety';
            }
            break;
        }
    }

    var cs = moment.defineLocale('cs', {
        months : months,
        monthsShort : monthsShort,
        monthsParse : (function (months, monthsShort) {
            var i, _monthsParse = [];
            for (i = 0; i < 12; i++) {
                // use custom parser to solve problem with July (ervenec)
                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
            }
            return _monthsParse;
        }(months, monthsShort)),
        shortMonthsParse : (function (monthsShort) {
            var i, _shortMonthsParse = [];
            for (i = 0; i < 12; i++) {
                _shortMonthsParse[i] = new RegExp('^' + monthsShort[i] + '$', 'i');
            }
            return _shortMonthsParse;
        }(monthsShort)),
        longMonthsParse : (function (months) {
            var i, _longMonthsParse = [];
            for (i = 0; i < 12; i++) {
                _longMonthsParse[i] = new RegExp('^' + months[i] + '$', 'i');
            }
            return _longMonthsParse;
        }(months)),
        weekdays : 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),
        weekdaysShort : 'ne_po_t_st_t_p_so'.split('_'),
        weekdaysMin : 'ne_po_t_st_t_p_so'.split('_'),
        longDateFormat : {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay: '[dnes v] LT',
            nextDay: '[ztra v] LT',
            nextWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[v nedli v] LT';
                case 1:
                case 2:
                    return '[v] dddd [v] LT';
                case 3:
                    return '[ve stedu v] LT';
                case 4:
                    return '[ve tvrtek v] LT';
                case 5:
                    return '[v ptek v] LT';
                case 6:
                    return '[v sobotu v] LT';
                }
            },
            lastDay: '[vera v] LT',
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[minulou nedli v] LT';
                case 1:
                case 2:
                    return '[minul] dddd [v] LT';
                case 3:
                    return '[minulou stedu v] LT';
                case 4:
                case 5:
                    return '[minul] dddd [v] LT';
                case 6:
                    return '[minulou sobotu v] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : 'ped %s',
            s : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        ordinalParse : /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return cs;

}));

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : chuvash (cv)
//! author : Anatoly Mironov : https://github.com/mirontoli

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var cv = moment.defineLocale('cv', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'YYYY [] MMMM [] D[-]',
            LLL : 'YYYY [] MMMM [] D[-], HH:mm',
            LLLL : 'dddd, YYYY [] MMMM [] D[-], HH:mm'
        },
        calendar : {
            sameDay: '[] LT []',
            nextDay: '[] LT []',
            lastDay: '[] LT []',
            nextWeek: '[] dddd LT []',
            lastWeek: '[] dddd LT []',
            sameElse: 'L'
        },
        relativeTime : {
            future : function (output) {
                var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';
                return output + affix;
            },
            past : '%s ',
            s : '- ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        ordinalParse: /\d{1,2}-/,
        ordinal : '%d-',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return cv;

}));

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Welsh (cy)
//! author : Robert Allen

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var cy = moment.defineLocale('cy', {
        months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
        monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
        weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
        weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
        weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
        weekdaysParseExact : true,
        // time formats are the same as en-gb
        longDateFormat: {
            LT: 'HH:mm',
            LTS : 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[Heddiw am] LT',
            nextDay: '[Yfory am] LT',
            nextWeek: 'dddd [am] LT',
            lastDay: '[Ddoe am] LT',
            lastWeek: 'dddd [diwethaf am] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'mewn %s',
            past: '%s yn l',
            s: 'ychydig eiliadau',
            m: 'munud',
            mm: '%d munud',
            h: 'awr',
            hh: '%d awr',
            d: 'diwrnod',
            dd: '%d diwrnod',
            M: 'mis',
            MM: '%d mis',
            y: 'blwyddyn',
            yy: '%d flynedd'
        },
        ordinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
        // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
        ordinal: function (number) {
            var b = number,
                output = '',
                lookup = [
                    '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
                    'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
                ];
            if (b > 20) {
                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                    output = 'fed'; // not 30ain, 70ain or 90ain
                } else {
                    output = 'ain';
                }
            } else if (b > 0) {
                output = lookup[b];
            }
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return cy;

}));

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : danish (da)
//! author : Ulrik Nielsen : https://github.com/mrbase

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var da = moment.defineLocale('da', {
        months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
        weekdaysShort : 'sn_man_tir_ons_tor_fre_lr'.split('_'),
        weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY HH:mm',
            LLLL : 'dddd [d.] D. MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[I dag kl.] LT',
            nextDay : '[I morgen kl.] LT',
            nextWeek : 'dddd [kl.] LT',
            lastDay : '[I gr kl.] LT',
            lastWeek : '[sidste] dddd [kl] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : '%s siden',
            s : 'f sekunder',
            m : 'et minut',
            mm : '%d minutter',
            h : 'en time',
            hh : '%d timer',
            d : 'en dag',
            dd : '%d dage',
            M : 'en mned',
            MM : '%d mneder',
            y : 'et r',
            yy : '%d r'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return da;

}));

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : german (de)
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensle: https://github.com/Oire
//! author : Mikolaj Dadela : https://github.com/mik01aj

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var de = moment.defineLocale('de', {
        months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort : 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        monthsParseExact : true,
        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY HH:mm',
            LLLL : 'dddd, D. MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime : {
            future : 'in %s',
            past : 'vor %s',
            s : 'ein paar Sekunden',
            m : processRelativeTime,
            mm : '%d Minuten',
            h : processRelativeTime,
            hh : '%d Stunden',
            d : processRelativeTime,
            dd : processRelativeTime,
            M : processRelativeTime,
            MM : processRelativeTime,
            y : processRelativeTime,
            yy : processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return de;

}));

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : austrian german (de-at)
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensle: https://github.com/Oire
//! author : Martin Groller : https://github.com/MadMG
//! author : Mikolaj Dadela : https://github.com/mik01aj

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var de_at = moment.defineLocale('de-at', {
        months : 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort : 'Jn._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        monthsParseExact : true,
        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY HH:mm',
            LLLL : 'dddd, D. MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime : {
            future : 'in %s',
            past : 'vor %s',
            s : 'ein paar Sekunden',
            m : processRelativeTime,
            mm : '%d Minuten',
            h : processRelativeTime,
            hh : '%d Stunden',
            d : processRelativeTime,
            dd : processRelativeTime,
            M : processRelativeTime,
            MM : processRelativeTime,
            y : processRelativeTime,
            yy : processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return de_at;

}));

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : dhivehi (dv)
//! author : Jawish Hameed : https://github.com/jawish

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var months = [
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        ''
    ], weekdays = [
        '',
        '',
        '',
        '',
        '',
        '',
        ''
    ];

    var dv = moment.defineLocale('dv', {
        months : months,
        monthsShort : months,
        weekdays : weekdays,
        weekdaysShort : weekdays,
        weekdaysMin : '______'.split('_'),
        longDateFormat : {

            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'D/M/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM : function (input) {
            return '' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : '',
            m : '',
            mm : ' %d',
            h : '',
            hh : ' %d',
            d : '',
            dd : ' %d',
            M : '',
            MM : ' %d',
            y : '',
            yy : ' %d'
        },
        preparse: function (string) {
            return string.replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/,/g, '');
        },
        week : {
            dow : 7,  // Sunday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return dv;

}));

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : modern greek (el)
//! author : Aggelos Karalias : https://github.com/mehiel

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }


    var el = moment.defineLocale('el', {
        monthsNominativeEl : '___________'.split('_'),
        monthsGenitiveEl : '___________'.split('_'),
        months : function (momentToFormat, format) {
            if (/D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
                return this._monthsGenitiveEl[momentToFormat.month()];
            } else {
                return this._monthsNominativeEl[momentToFormat.month()];
            }
        },
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? '' : '';
            } else {
                return isLower ? '' : '';
            }
        },
        isPM : function (input) {
            return ((input + '').toLowerCase()[0] === '');
        },
        meridiemParse : /[]\.??\.?/i,
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendarEl : {
            sameDay : '[ {}] LT',
            nextDay : '[ {}] LT',
            nextWeek : 'dddd [{}] LT',
            lastDay : '[ {}] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 6:
                        return '[ ] dddd [{}] LT';
                    default:
                        return '[ ] dddd [{}] LT';
                }
            },
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendarEl[key],
                hours = mom && mom.hours();
            if (isFunction(output)) {
                output = output.apply(mom);
            }
            return output.replace('{}', (hours % 12 === 1 ? '' : ''));
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        ordinalParse: /\d{1,2}/,
        ordinal: '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4st is the first week of the year.
        }
    });

    return el;

}));

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : australian english (en-au)

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var en_au = moment.defineLocale('en-au', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return en_au;

}));

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : canadian english (en-ca)
//! author : Jonathan Abourbih : https://github.com/jonbca

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var en_ca = moment.defineLocale('en-ca', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'YYYY-MM-DD',
            LL : 'MMMM D, YYYY',
            LLL : 'MMMM D, YYYY h:mm A',
            LLLL : 'dddd, MMMM D, YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    return en_ca;

}));

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : great britain english (en-gb)
//! author : Chris Gedrim : https://github.com/chrisgedrim

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var en_gb = moment.defineLocale('en-gb', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return en_gb;

}));

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Irish english (en-ie)
//! author : Chris Cartlidge : https://github.com/chriscartlidge

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var en_ie = moment.defineLocale('en-ie', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return en_ie;

}));

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : New Zealand english (en-nz)

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var en_nz = moment.defineLocale('en-nz', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return en_nz;

}));

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : esperanto (eo)
//! author : Colin Dean : https://github.com/colindean
//! komento: Mi estas malcerta se mi korekte traktis akuzativojn en tiu traduko.
//!          Se ne, bonvolu korekti kaj avizi min por ke mi povas lerni!

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var eo = moment.defineLocale('eo', {
        months : 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_ag_sep_okt_nov_dec'.split('_'),
        weekdays : 'Dimano_Lundo_Mardo_Merkredo_ado_Vendredo_Sabato'.split('_'),
        weekdaysShort : 'Dim_Lun_Mard_Merk_a_Ven_Sab'.split('_'),
        weekdaysMin : 'Di_Lu_Ma_Me_a_Ve_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'D[-an de] MMMM, YYYY',
            LLL : 'D[-an de] MMMM, YYYY HH:mm',
            LLLL : 'dddd, [la] D[-an de] MMMM, YYYY HH:mm'
        },
        meridiemParse: /[ap]\.t\.m/i,
        isPM: function (input) {
            return input.charAt(0).toLowerCase() === 'p';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'p.t.m.' : 'P.T.M.';
            } else {
                return isLower ? 'a.t.m.' : 'A.T.M.';
            }
        },
        calendar : {
            sameDay : '[Hodia je] LT',
            nextDay : '[Morga je] LT',
            nextWeek : 'dddd [je] LT',
            lastDay : '[Hiera je] LT',
            lastWeek : '[pasinta] dddd [je] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'je %s',
            past : 'anta %s',
            s : 'sekundoj',
            m : 'minuto',
            mm : '%d minutoj',
            h : 'horo',
            hh : '%d horoj',
            d : 'tago',//ne 'diurno', ar estas uzita por proksimumo
            dd : '%d tagoj',
            M : 'monato',
            MM : '%d monatoj',
            y : 'jaro',
            yy : '%d jaroj'
        },
        ordinalParse: /\d{1,2}a/,
        ordinal : '%da',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return eo;

}));

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : spanish (es)
//! author : Julio Napur : https://github.com/julionc

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

    var es = moment.defineLocale('es', {
        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
        monthsShort : function (m, format) {
            if (/-MMM-/.test(format)) {
                return monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        monthsParseExact : true,
        weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
        weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
        weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY H:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
        },
        calendar : {
            sameDay : function () {
                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextDay : function () {
                return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastDay : function () {
                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'en %s',
            past : 'hace %s',
            s : 'unos segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'una hora',
            hh : '%d horas',
            d : 'un da',
            dd : '%d das',
            M : 'un mes',
            MM : '%d meses',
            y : 'un ao',
            yy : '%d aos'
        },
        ordinalParse : /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return es;

}));

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : estonian (et)
//! author : Henry Kehlmann : https://github.com/madhenry
//! improvements : Illimar Tambek : https://github.com/ragulka

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            's' : ['mne sekundi', 'mni sekund', 'paar sekundit'],
            'm' : ['he minuti', 'ks minut'],
            'mm': [number + ' minuti', number + ' minutit'],
            'h' : ['he tunni', 'tund aega', 'ks tund'],
            'hh': [number + ' tunni', number + ' tundi'],
            'd' : ['he peva', 'ks pev'],
            'M' : ['kuu aja', 'kuu aega', 'ks kuu'],
            'MM': [number + ' kuu', number + ' kuud'],
            'y' : ['he aasta', 'aasta', 'ks aasta'],
            'yy': [number + ' aasta', number + ' aastat']
        };
        if (withoutSuffix) {
            return format[key][2] ? format[key][2] : format[key][1];
        }
        return isFuture ? format[key][0] : format[key][1];
    }

    var et = moment.defineLocale('et', {
        months        : 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
        monthsShort   : 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
        weekdays      : 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),
        weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
        weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
        longDateFormat : {
            LT   : 'H:mm',
            LTS : 'H:mm:ss',
            L    : 'DD.MM.YYYY',
            LL   : 'D. MMMM YYYY',
            LLL  : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[Tna,] LT',
            nextDay  : '[Homme,] LT',
            nextWeek : '[Jrgmine] dddd LT',
            lastDay  : '[Eile,] LT',
            lastWeek : '[Eelmine] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s prast',
            past   : '%s tagasi',
            s      : processRelativeTime,
            m      : processRelativeTime,
            mm     : processRelativeTime,
            h      : processRelativeTime,
            hh     : processRelativeTime,
            d      : processRelativeTime,
            dd     : '%d peva',
            M      : processRelativeTime,
            MM     : processRelativeTime,
            y      : processRelativeTime,
            yy     : processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return et;

}));

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : euskara (eu)
//! author : Eneko Illarramendi : https://github.com/eillarra

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var eu = moment.defineLocale('eu', {
        months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
        monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
        monthsParseExact : true,
        weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
        weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
        weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'YYYY[ko] MMMM[ren] D[a]',
            LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',
            LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
            l : 'YYYY-M-D',
            ll : 'YYYY[ko] MMM D[a]',
            lll : 'YYYY[ko] MMM D[a] HH:mm',
            llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'
        },
        calendar : {
            sameDay : '[gaur] LT[etan]',
            nextDay : '[bihar] LT[etan]',
            nextWeek : 'dddd LT[etan]',
            lastDay : '[atzo] LT[etan]',
            lastWeek : '[aurreko] dddd LT[etan]',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s barru',
            past : 'duela %s',
            s : 'segundo batzuk',
            m : 'minutu bat',
            mm : '%d minutu',
            h : 'ordu bat',
            hh : '%d ordu',
            d : 'egun bat',
            dd : '%d egun',
            M : 'hilabete bat',
            MM : '%d hilabete',
            y : 'urte bat',
            yy : '%d urte'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return eu;

}));

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Persian (fa)
//! author : Ebrahim Byagowi : https://github.com/ebraminio

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var fa = moment.defineLocale('fa', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '\u200c__\u200c__\u200c__'.split('_'),
        weekdaysShort : '\u200c__\u200c__\u200c__'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        meridiemParse: /  |  /,
        isPM: function (input) {
            return /  /.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '  ';
            } else {
                return '  ';
            }
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ] LT',
            lastWeek : 'dddd [] [] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[-]/g, function (match) {
                return numberMap[match];
            }).replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '');
        },
        ordinalParse: /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return fa;

}));

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : finnish (fi)
//! author : Tarmo Aidantausta : https://github.com/bleadof

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' '),
        numbersFuture = [
            'nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden',
            numbersPast[7], numbersPast[8], numbersPast[9]
        ];
    function translate(number, withoutSuffix, key, isFuture) {
        var result = '';
        switch (key) {
        case 's':
            return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
        case 'm':
            return isFuture ? 'minuutin' : 'minuutti';
        case 'mm':
            result = isFuture ? 'minuutin' : 'minuuttia';
            break;
        case 'h':
            return isFuture ? 'tunnin' : 'tunti';
        case 'hh':
            result = isFuture ? 'tunnin' : 'tuntia';
            break;
        case 'd':
            return isFuture ? 'pivn' : 'piv';
        case 'dd':
            result = isFuture ? 'pivn' : 'piv';
            break;
        case 'M':
            return isFuture ? 'kuukauden' : 'kuukausi';
        case 'MM':
            result = isFuture ? 'kuukauden' : 'kuukautta';
            break;
        case 'y':
            return isFuture ? 'vuoden' : 'vuosi';
        case 'yy':
            result = isFuture ? 'vuoden' : 'vuotta';
            break;
        }
        result = verbalNumber(number, isFuture) + ' ' + result;
        return result;
    }
    function verbalNumber(number, isFuture) {
        return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
    }

    var fi = moment.defineLocale('fi', {
        months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
        monthsShort : 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),
        weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
        weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
        weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD.MM.YYYY',
            LL : 'Do MMMM[ta] YYYY',
            LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',
            LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
            l : 'D.M.YYYY',
            ll : 'Do MMM YYYY',
            lll : 'Do MMM YYYY, [klo] HH.mm',
            llll : 'ddd, Do MMM YYYY, [klo] HH.mm'
        },
        calendar : {
            sameDay : '[tnn] [klo] LT',
            nextDay : '[huomenna] [klo] LT',
            nextWeek : 'dddd [klo] LT',
            lastDay : '[eilen] [klo] LT',
            lastWeek : '[viime] dddd[na] [klo] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s pst',
            past : '%s sitten',
            s : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fi;

}));

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : faroese (fo)
//! author : Ragnar Johannesen : https://github.com/ragnar123

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var fo = moment.defineLocale('fo', {
        months : 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays : 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),
        weekdaysShort : 'sun_mn_ts_mik_hs_fr_ley'.split('_'),
        weekdaysMin : 'su_m_t_mi_h_fr_le'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D. MMMM, YYYY HH:mm'
        },
        calendar : {
            sameDay : '[ dag kl.] LT',
            nextDay : '[ morgin kl.] LT',
            nextWeek : 'dddd [kl.] LT',
            lastDay : '[ gjr kl.] LT',
            lastWeek : '[sstu] dddd [kl] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'um %s',
            past : '%s sani',
            s : 'f sekund',
            m : 'ein minutt',
            mm : '%d minuttir',
            h : 'ein tmi',
            hh : '%d tmar',
            d : 'ein dagur',
            dd : '%d dagar',
            M : 'ein mnai',
            MM : '%d mnair',
            y : 'eitt r',
            yy : '%d r'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fo;

}));

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : french (fr)
//! author : John Fischer : https://github.com/jfroffice

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var fr = moment.defineLocale('fr', {
        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
        monthsParseExact : true,
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Aujourd\'hui ] LT',
            nextDay: '[Demain ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[Hier ] LT',
            lastWeek: 'dddd [dernier ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        ordinalParse: /\d{1,2}(er|)/,
        ordinal : function (number) {
            return number + (number === 1 ? 'er' : '');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fr;

}));

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : canadian french (fr-ca)
//! author : Jonathan Abourbih : https://github.com/jonbca

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var fr_ca = moment.defineLocale('fr-ca', {
        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
        monthsParseExact : true,
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Aujourd\'hui ] LT',
            nextDay: '[Demain ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[Hier ] LT',
            lastWeek: 'dddd [dernier ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        ordinalParse: /\d{1,2}(er|e)/,
        ordinal : function (number) {
            return number + (number === 1 ? 'er' : 'e');
        }
    });

    return fr_ca;

}));

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : swiss french (fr)
//! author : Gaspard Bucher : https://github.com/gaspard

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var fr_ch = moment.defineLocale('fr-ch', {
        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
        monthsParseExact : true,
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Aujourd\'hui ] LT',
            nextDay: '[Demain ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[Hier ] LT',
            lastWeek: 'dddd [dernier ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        ordinalParse: /\d{1,2}(er|e)/,
        ordinal : function (number) {
            return number + (number === 1 ? 'er' : 'e');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fr_ch;

}));

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : frisian (fy)
//! author : Robin van der Vliet : https://github.com/robin0van0der0v

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),
        monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');

    var fy = moment.defineLocale('fy', {
        months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
        monthsShort : function (m, format) {
            if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots[m.month()];
            } else {
                return monthsShortWithDots[m.month()];
            }
        },
        monthsParseExact : true,
        weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
        weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
        weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[hjoed om] LT',
            nextDay: '[moarn om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[juster om] LT',
            lastWeek: '[frne] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'oer %s',
            past : '%s lyn',
            s : 'in pear sekonden',
            m : 'ien mint',
            mm : '%d minuten',
            h : 'ien oere',
            hh : '%d oeren',
            d : 'ien dei',
            dd : '%d dagen',
            M : 'ien moanne',
            MM : '%d moannen',
            y : 'ien jier',
            yy : '%d jierren'
        },
        ordinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fy;

}));

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : great britain scottish gealic (gd)
//! author : Jon Ashdown : https://github.com/jonashdown

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var months = [
        'Am Faoilleach', 'An Gearran', 'Am Mrt', 'An Giblean', 'An Citean', 'An t-gmhios', 'An t-Iuchar', 'An Lnastal', 'An t-Sultain', 'An Dmhair', 'An t-Samhain', 'An Dbhlachd'
    ];

    var monthsShort = ['Faoi', 'Gear', 'Mrt', 'Gibl', 'Cit', 'gmh', 'Iuch', 'Ln', 'Sult', 'Dmh', 'Samh', 'Dbh'];

    var weekdays = ['Didmhnaich', 'Diluain', 'Dimirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];

    var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];

    var weekdaysMin = ['D', 'Lu', 'M', 'Ci', 'Ar', 'Ha', 'Sa'];

    var gd = moment.defineLocale('gd', {
        months : months,
        monthsShort : monthsShort,
        monthsParseExact : true,
        weekdays : weekdays,
        weekdaysShort : weekdaysShort,
        weekdaysMin : weekdaysMin,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[An-diugh aig] LT',
            nextDay : '[A-mireach aig] LT',
            nextWeek : 'dddd [aig] LT',
            lastDay : '[An-d aig] LT',
            lastWeek : 'dddd [seo chaidh] [aig] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'ann an %s',
            past : 'bho chionn %s',
            s : 'beagan diogan',
            m : 'mionaid',
            mm : '%d mionaidean',
            h : 'uair',
            hh : '%d uairean',
            d : 'latha',
            dd : '%d latha',
            M : 'mos',
            MM : '%d mosan',
            y : 'bliadhna',
            yy : '%d bliadhna'
        },
        ordinalParse : /\d{1,2}(d|na|mh)/,
        ordinal : function (number) {
            var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return gd;

}));

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : galician (gl)
//! author : Juan G. Hurtado : https://github.com/juanghurtado

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var gl = moment.defineLocale('gl', {
        months : 'Xaneiro_Febreiro_Marzo_Abril_Maio_Xuo_Xullo_Agosto_Setembro_Outubro_Novembro_Decembro'.split('_'),
        monthsShort : 'Xan._Feb._Mar._Abr._Mai._Xu._Xul._Ago._Set._Out._Nov._Dec.'.split('_'),
        monthsParseExact: true,
        weekdays : 'Domingo_Luns_Martes_Mrcores_Xoves_Venres_Sbado'.split('_'),
        weekdaysShort : 'Dom._Lun._Mar._Mr._Xov._Ven._Sb.'.split('_'),
        weekdaysMin : 'Do_Lu_Ma_M_Xo_Ve_S'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay : function () {
                return '[hoxe ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextDay : function () {
                return '[ma ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
            },
            lastDay : function () {
                return '[onte ' + ((this.hours() !== 1) ? '' : 'a') + '] LT';
            },
            lastWeek : function () {
                return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : function (str) {
                if (str === 'uns segundos') {
                    return 'nuns segundos';
                }
                return 'en ' + str;
            },
            past : 'hai %s',
            s : 'uns segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'unha hora',
            hh : '%d horas',
            d : 'un da',
            dd : '%d das',
            M : 'un mes',
            MM : '%d meses',
            y : 'un ano',
            yy : '%d anos'
        },
        ordinalParse : /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return gl;

}));

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hebrew (he)
//! author : Tomer Cohen : https://github.com/tomer
//! author : Moshe Simantov : https://github.com/DevelopmentIL
//! author : Tal Ater : https://github.com/TalAter

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var he = moment.defineLocale('he', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D []MMMM YYYY',
            LLL : 'D []MMMM YYYY HH:mm',
            LLLL : 'dddd, D []MMMM YYYY HH:mm',
            l : 'D/M/YYYY',
            ll : 'D MMM YYYY',
            lll : 'D MMM YYYY HH:mm',
            llll : 'ddd, D MMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[ ]LT',
            nextDay : '[ ]LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ]LT',
            lastWeek : '[] dddd [ ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : ' ',
            m : '',
            mm : '%d ',
            h : '',
            hh : function (number) {
                if (number === 2) {
                    return '';
                }
                return number + ' ';
            },
            d : '',
            dd : function (number) {
                if (number === 2) {
                    return '';
                }
                return number + ' ';
            },
            M : '',
            MM : function (number) {
                if (number === 2) {
                    return '';
                }
                return number + ' ';
            },
            y : '',
            yy : function (number) {
                if (number === 2) {
                    return '';
                } else if (number % 10 === 0 && number !== 10) {
                    return number + ' ';
                }
                return number + ' ';
            }
        },
        meridiemParse: /"|"| | | ||/i,
        isPM : function (input) {
            return /^("| |)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 5) {
                return ' ';
            } else if (hour < 10) {
                return '';
            } else if (hour < 12) {
                return isLower ? '"' : ' ';
            } else if (hour < 18) {
                return isLower ? '"' : ' ';
            } else {
                return '';
            }
        }
    });

    return he;

}));

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : hindi (hi)
//! author : Mayank Singhal : https://github.com/mayanksinghal

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var hi = moment.defineLocale('hi', {
        months : '___________'.split('_'),
        monthsShort : '._.__.___._._._._._.'.split('_'),
        monthsParseExact: true,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm ',
            LTS : 'A h:mm:ss ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm '
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : '  ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // Hindi notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
        meridiemParse: /|||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return hi;

}));

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : hrvatski (hr)
//! author : Bojan Markovi : https://github.com/bmarkovic

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
        case 'm':
            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
        case 'mm':
            if (number === 1) {
                result += 'minuta';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'minute';
            } else {
                result += 'minuta';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'jedan sat' : 'jednog sata';
        case 'hh':
            if (number === 1) {
                result += 'sat';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'sata';
            } else {
                result += 'sati';
            }
            return result;
        case 'dd':
            if (number === 1) {
                result += 'dan';
            } else {
                result += 'dana';
            }
            return result;
        case 'MM':
            if (number === 1) {
                result += 'mjesec';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'mjeseca';
            } else {
                result += 'mjeseci';
            }
            return result;
        case 'yy':
            if (number === 1) {
                result += 'godina';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'godine';
            } else {
                result += 'godina';
            }
            return result;
        }
    }

    var hr = moment.defineLocale('hr', {
        months : {
            format: 'sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
            standalone: 'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
        },
        monthsShort : 'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
        monthsParseExact: true,
        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
        weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
        weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD. MM. YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[danas u] LT',
            nextDay  : '[sutra u] LT',
            nextWeek : function () {
                switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[juer u] LT',
            lastWeek : function () {
                switch (this.day()) {
                case 0:
                case 3:
                    return '[prolu] dddd [u] LT';
                case 6:
                    return '[prole] [subote] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[proli] dddd [u] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'par sekundi',
            m      : translate,
            mm     : translate,
            h      : translate,
            hh     : translate,
            d      : 'dan',
            dd     : translate,
            M      : 'mjesec',
            MM     : translate,
            y      : 'godinu',
            yy     : translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return hr;

}));

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : hungarian (hu)
//! author : Adam Brunner : https://github.com/adambrunner

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');
    function translate(number, withoutSuffix, key, isFuture) {
        var num = number,
            suffix;
        switch (key) {
        case 's':
            return (isFuture || withoutSuffix) ? 'nhny msodperc' : 'nhny msodperce';
        case 'm':
            return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
        case 'mm':
            return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
        case 'h':
            return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');
        case 'hh':
            return num + (isFuture || withoutSuffix ? ' ra' : ' rja');
        case 'd':
            return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
        case 'dd':
            return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
        case 'M':
            return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
        case 'MM':
            return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
        case 'y':
            return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');
        case 'yy':
            return num + (isFuture || withoutSuffix ? ' v' : ' ve');
        }
        return '';
    }
    function week(isFuture) {
        return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
    }

    var hu = moment.defineLocale('hu', {
        months : 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),
        monthsShort : 'jan_feb_mrc_pr_mj_jn_jl_aug_szept_okt_nov_dec'.split('_'),
        weekdays : 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),
        weekdaysShort : 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),
        weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'YYYY.MM.DD.',
            LL : 'YYYY. MMMM D.',
            LLL : 'YYYY. MMMM D. H:mm',
            LLLL : 'YYYY. MMMM D., dddd H:mm'
        },
        meridiemParse: /de|du/i,
        isPM: function (input) {
            return input.charAt(1).toLowerCase() === 'u';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower === true ? 'de' : 'DE';
            } else {
                return isLower === true ? 'du' : 'DU';
            }
        },
        calendar : {
            sameDay : '[ma] LT[-kor]',
            nextDay : '[holnap] LT[-kor]',
            nextWeek : function () {
                return week.call(this, true);
            },
            lastDay : '[tegnap] LT[-kor]',
            lastWeek : function () {
                return week.call(this, false);
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s mlva',
            past : '%s',
            s : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return hu;

}));

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Armenian (hy-am)
//! author : Armendarabyan : https://github.com/armendarabyan

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var hy_am = moment.defineLocale('hy-am', {
        months : {
            format: '___________'.split('_'),
            standalone: '___________'.split('_')
        },
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY .',
            LLL : 'D MMMM YYYY ., HH:mm',
            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
        },
        calendar : {
            sameDay: '[] LT',
            nextDay: '[] LT',
            lastDay: '[] LT',
            nextWeek: function () {
                return 'dddd [ ] LT';
            },
            lastWeek: function () {
                return '[] dddd [ ] LT';
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : '  ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        meridiemParse: /|||/,
        isPM: function (input) {
            return /^(|)$/.test(input);
        },
        meridiem : function (hour) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return '';
            } else {
                return '';
            }
        },
        ordinalParse: /\d{1,2}|\d{1,2}-(|)/,
        ordinal: function (number, period) {
            switch (period) {
            case 'DDD':
            case 'w':
            case 'W':
            case 'DDDo':
                if (number === 1) {
                    return number + '-';
                }
                return number + '-';
            default:
                return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return hy_am;

}));

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bahasa Indonesia (id)
//! author : Mohammad Satrio Utomo : https://github.com/tyok
//! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var id = moment.defineLocale('id', {
        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
        weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
        weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|siang|sore|malam/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'siang') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'sore' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'siang';
            } else if (hours < 19) {
                return 'sore';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Besok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kemarin pukul] LT',
            lastWeek : 'dddd [lalu pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lalu',
            s : 'beberapa detik',
            m : 'semenit',
            mm : '%d menit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return id;

}));

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : icelandic (is)
//! author : Hinrik rn Sigursson : https://github.com/hinrik

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function plural(n) {
        if (n % 100 === 11) {
            return true;
        } else if (n % 10 === 1) {
            return false;
        }
        return true;
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
        case 's':
            return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';
        case 'm':
            return withoutSuffix ? 'mnta' : 'mntu';
        case 'mm':
            if (plural(number)) {
                return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');
            } else if (withoutSuffix) {
                return result + 'mnta';
            }
            return result + 'mntu';
        case 'hh':
            if (plural(number)) {
                return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
            }
            return result + 'klukkustund';
        case 'd':
            if (withoutSuffix) {
                return 'dagur';
            }
            return isFuture ? 'dag' : 'degi';
        case 'dd':
            if (plural(number)) {
                if (withoutSuffix) {
                    return result + 'dagar';
                }
                return result + (isFuture ? 'daga' : 'dgum');
            } else if (withoutSuffix) {
                return result + 'dagur';
            }
            return result + (isFuture ? 'dag' : 'degi');
        case 'M':
            if (withoutSuffix) {
                return 'mnuur';
            }
            return isFuture ? 'mnu' : 'mnui';
        case 'MM':
            if (plural(number)) {
                if (withoutSuffix) {
                    return result + 'mnuir';
                }
                return result + (isFuture ? 'mnui' : 'mnuum');
            } else if (withoutSuffix) {
                return result + 'mnuur';
            }
            return result + (isFuture ? 'mnu' : 'mnui');
        case 'y':
            return withoutSuffix || isFuture ? 'r' : 'ri';
        case 'yy':
            if (plural(number)) {
                return result + (withoutSuffix || isFuture ? 'r' : 'rum');
            }
            return result + (withoutSuffix || isFuture ? 'r' : 'ri');
        }
    }

    var is = moment.defineLocale('is', {
        months : 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),
        weekdays : 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),
        weekdaysShort : 'sun_mn_ri_mi_fim_fs_lau'.split('_'),
        weekdaysMin : 'Su_M_r_Mi_Fi_F_La'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY [kl.] H:mm',
            LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'
        },
        calendar : {
            sameDay : '[ dag kl.] LT',
            nextDay : '[ morgun kl.] LT',
            nextWeek : 'dddd [kl.] LT',
            lastDay : '[ gr kl.] LT',
            lastWeek : '[sasta] dddd [kl.] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'eftir %s',
            past : 'fyrir %s san',
            s : translate,
            m : translate,
            mm : translate,
            h : 'klukkustund',
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return is;

}));

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : italian (it)
//! author : Lorenzo : https://github.com/aliem
//! author: Mattia Larentis: https://github.com/nostalgiaz

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var it = moment.defineLocale('it', {
        months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
        monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
        weekdays : 'Domenica_Luned_Marted_Mercoled_Gioved_Venerd_Sabato'.split('_'),
        weekdaysShort : 'Dom_Lun_Mar_Mer_Gio_Ven_Sab'.split('_'),
        weekdaysMin : 'Do_Lu_Ma_Me_Gi_Ve_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Oggi alle] LT',
            nextDay: '[Domani alle] LT',
            nextWeek: 'dddd [alle] LT',
            lastDay: '[Ieri alle] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[la scorsa] dddd [alle] LT';
                    default:
                        return '[lo scorso] dddd [alle] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : function (s) {
                return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
            },
            past : '%s fa',
            s : 'alcuni secondi',
            m : 'un minuto',
            mm : '%d minuti',
            h : 'un\'ora',
            hh : '%d ore',
            d : 'un giorno',
            dd : '%d giorni',
            M : 'un mese',
            MM : '%d mesi',
            y : 'un anno',
            yy : '%d anni'
        },
        ordinalParse : /\d{1,2}/,
        ordinal: '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return it;

}));

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : japanese (ja)
//! author : LI Long : https://github.com/baryon

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var ja = moment.defineLocale('ja', {
        months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'Ahm',
            LTS : 'Ahms',
            L : 'YYYY/MM/DD',
            LL : 'YYYYMD',
            LLL : 'YYYYMDAhm',
            LLLL : 'YYYYMDAhm dddd'
        },
        meridiemParse: /|/i,
        isPM : function (input) {
            return input === '';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : '[]dddd LT',
            lastDay : '[] LT',
            lastWeek : '[]dddd LT',
            sameElse : 'L'
        },
        ordinalParse : /\d{1,2}/,
        ordinal : function (number, period) {
            switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
                return number + '';
            default:
                return number;
            }
        },
        relativeTime : {
            future : '%s',
            past : '%s',
            s : '',
            m : '1',
            mm : '%d',
            h : '1',
            hh : '%d',
            d : '1',
            dd : '%d',
            M : '1',
            MM : '%d',
            y : '1',
            yy : '%d'
        }
    });

    return ja;

}));

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Boso Jowo (jv)
//! author : Rony Lantip : https://github.com/lantip
//! reference: http://jv.wikipedia.org/wiki/Basa_Jawa

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var jv = moment.defineLocale('jv', {
        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
        weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
        weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /enjing|siyang|sonten|ndalu/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'enjing') {
                return hour;
            } else if (meridiem === 'siyang') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'enjing';
            } else if (hours < 15) {
                return 'siyang';
            } else if (hours < 19) {
                return 'sonten';
            } else {
                return 'ndalu';
            }
        },
        calendar : {
            sameDay : '[Dinten puniko pukul] LT',
            nextDay : '[Mbenjang pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kala wingi pukul] LT',
            lastWeek : 'dddd [kepengker pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'wonten ing %s',
            past : '%s ingkang kepengker',
            s : 'sawetawis detik',
            m : 'setunggal menit',
            mm : '%d menit',
            h : 'setunggal jam',
            hh : '%d jam',
            d : 'sedinten',
            dd : '%d dinten',
            M : 'sewulan',
            MM : '%d wulan',
            y : 'setaun',
            yy : '%d taun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return jv;

}));

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Georgian (ka)
//! author : Irakli Janiashvili : https://github.com/irakli-janiashvili

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var ka = moment.defineLocale('ka', {
        months : {
            standalone: '___________'.split('_'),
            format: '___________'.split('_')
        },
        monthsShort : '___________'.split('_'),
        weekdays : {
            standalone: '______'.split('_'),
            format: '______'.split('_'),
            isFormat: /(|)/
        },
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[] LT[-]',
            nextDay : '[] LT[-]',
            lastDay : '[] LT[-]',
            nextWeek : '[] dddd LT[-]',
            lastWeek : '[] dddd LT-',
            sameElse : 'L'
        },
        relativeTime : {
            future : function (s) {
                return (/(|||)/).test(s) ?
                    s.replace(/$/, '') :
                    s + '';
            },
            past : function (s) {
                if ((/(||||)/).test(s)) {
                    return s.replace(/(|)$/, ' ');
                }
                if ((//).test(s)) {
                    return s.replace(/$/, ' ');
                }
            },
            s : ' ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        ordinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
        ordinal : function (number) {
            if (number === 0) {
                return number;
            }
            if (number === 1) {
                return number + '-';
            }
            if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
                return '-' + number;
            }
            return number + '-';
        },
        week : {
            dow : 1,
            doy : 7
        }
    });

    return ka;

}));

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : kazakh (kk)
//! authors : Nurlan Rakhimzhanov : https://github.com/nurlan

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var suffixes = {
        0: '-',
        1: '-',
        2: '-',
        3: '-',
        4: '-',
        5: '-',
        6: '-',
        7: '-',
        8: '-',
        9: '-',
        10: '-',
        20: '-',
        30: '-',
        40: '-',
        50: '-',
        60: '-',
        70: '-',
        80: '-',
        90: '-',
        100: '-'
    };

    var kk = moment.defineLocale('kk', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ] LT',
            lastWeek : '[ ] dddd [] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        ordinalParse: /\d{1,2}-(|)/,
        ordinal : function (number) {
            var a = number % 10,
                b = number >= 100 ? 100 : null;
            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return kk;

}));

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : khmer (km)
//! author : Kruy Vanna : https://github.com/kruyvanna

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var km = moment.defineLocale('km', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS : 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[ ] LT',
            lastWeek: 'dddd [] [] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s',
            past: '%s',
            s: '',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return km;

}));

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : korean (ko)
//!
//! authors
//!
//! - Kyungwook, Park : https://github.com/kyungw00k
//! - Jeeeyul Lee <jeeeyul@gmail.com>

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var ko = moment.defineLocale('ko', {
        months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h m',
            LTS : 'A h m s',
            L : 'YYYY.MM.DD',
            LL : 'YYYY MMMM D',
            LLL : 'YYYY MMMM D A h m',
            LLLL : 'YYYY MMMM D dddd A h m'
        },
        calendar : {
            sameDay : ' LT',
            nextDay : ' LT',
            nextWeek : 'dddd LT',
            lastDay : ' LT',
            lastWeek : ' dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            ss : '%d',
            m : '',
            mm : '%d',
            h : ' ',
            hh : '%d',
            d : '',
            dd : '%d',
            M : ' ',
            MM : '%d',
            y : ' ',
            yy : '%d'
        },
        ordinalParse : /\d{1,2}/,
        ordinal : '%d',
        meridiemParse : /|/,
        isPM : function (token) {
            return token === '';
        },
        meridiem : function (hour, minute, isUpper) {
            return hour < 12 ? '' : '';
        }
    });

    return ko;

}));

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : kyrgyz (ky)
//! author : Chyngyz Arystan uulu : https://github.com/chyngyz

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';



    var suffixes = {
        0: '-',
        1: '-',
        2: '-',
        3: '-',
        4: '-',
        5: '-',
        6: '-',
        7: '-',
        8: '-',
        9: '-',
        10: '-',
        20: '-',
        30: '-',
        40: '-',
        50: '-',
        60: '-',
        70: '-',
        80: '-',
        90: '-',
        100: '-'
    };

    var ky = moment.defineLocale('ky', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ] LT',
            lastWeek : '[ ] dddd [] [] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        ordinalParse: /\d{1,2}-(|||)/,
        ordinal : function (number) {
            var a = number % 10,
                b = number >= 100 ? 100 : null;
            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ky;

}));

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Luxembourgish (lb)
//! author : mweimerskirch : https://github.com/mweimerskirch, David Raison : https://github.com/kwisatz

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eng Minutt', 'enger Minutt'],
            'h': ['eng Stonn', 'enger Stonn'],
            'd': ['een Dag', 'engem Dag'],
            'M': ['ee Mount', 'engem Mount'],
            'y': ['ee Joer', 'engem Joer']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }
    function processFutureTime(string) {
        var number = string.substr(0, string.indexOf(' '));
        if (eifelerRegelAppliesToNumber(number)) {
            return 'a ' + string;
        }
        return 'an ' + string;
    }
    function processPastTime(string) {
        var number = string.substr(0, string.indexOf(' '));
        if (eifelerRegelAppliesToNumber(number)) {
            return 'viru ' + string;
        }
        return 'virun ' + string;
    }
    /**
     * Returns true if the word before the given number loses the '-n' ending.
     * e.g. 'an 10 Deeg' but 'a 5 Deeg'
     *
     * @param number {integer}
     * @returns {boolean}
     */
    function eifelerRegelAppliesToNumber(number) {
        number = parseInt(number, 10);
        if (isNaN(number)) {
            return false;
        }
        if (number < 0) {
            // Negative Number --> always true
            return true;
        } else if (number < 10) {
            // Only 1 digit
            if (4 <= number && number <= 7) {
                return true;
            }
            return false;
        } else if (number < 100) {
            // 2 digits
            var lastDigit = number % 10, firstDigit = number / 10;
            if (lastDigit === 0) {
                return eifelerRegelAppliesToNumber(firstDigit);
            }
            return eifelerRegelAppliesToNumber(lastDigit);
        } else if (number < 10000) {
            // 3 or 4 digits --> recursively check first digit
            while (number >= 10) {
                number = number / 10;
            }
            return eifelerRegelAppliesToNumber(number);
        } else {
            // Anything larger than 4 digits: recursively check first n-3 digits
            number = number / 1000;
            return eifelerRegelAppliesToNumber(number);
        }
    }

    var lb = moment.defineLocale('lb', {
        months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        monthsParseExact : true,
        weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
        weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),
        weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'H:mm [Auer]',
            LTS: 'H:mm:ss [Auer]',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm [Auer]',
            LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
        },
        calendar: {
            sameDay: '[Haut um] LT',
            sameElse: 'L',
            nextDay: '[Muer um] LT',
            nextWeek: 'dddd [um] LT',
            lastDay: '[Gschter um] LT',
            lastWeek: function () {
                // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
                switch (this.day()) {
                    case 2:
                    case 4:
                        return '[Leschten] dddd [um] LT';
                    default:
                        return '[Leschte] dddd [um] LT';
                }
            }
        },
        relativeTime : {
            future : processFutureTime,
            past : processPastTime,
            s : 'e puer Sekonnen',
            m : processRelativeTime,
            mm : '%d Minutten',
            h : processRelativeTime,
            hh : '%d Stonnen',
            d : processRelativeTime,
            dd : '%d Deeg',
            M : processRelativeTime,
            MM : '%d Mint',
            y : processRelativeTime,
            yy : '%d Joer'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return lb;

}));

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : lao (lo)
//! author : Ryan Hart : https://github.com/ryanhart2

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var lo = moment.defineLocale('lo', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM: function (input) {
            return input === '';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : '[]dddd[] LT',
            lastDay : '[] LT',
            lastWeek : '[]dddd[] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s',
            s : '',
            m : '1 ',
            mm : '%d ',
            h : '1 ',
            hh : '%d ',
            d : '1 ',
            dd : '%d ',
            M : '1 ',
            MM : '%d ',
            y : '1 ',
            yy : '%d '
        },
        ordinalParse: /()\d{1,2}/,
        ordinal : function (number) {
            return '' + number;
        }
    });

    return lo;

}));

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Lithuanian (lt)
//! author : Mindaugas Mozras : https://github.com/mmozuras

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var units = {
        'm' : 'minut_minuts_minut',
        'mm': 'minuts_minui_minutes',
        'h' : 'valanda_valandos_valand',
        'hh': 'valandos_valand_valandas',
        'd' : 'diena_dienos_dien',
        'dd': 'dienos_dien_dienas',
        'M' : 'mnuo_mnesio_mnes',
        'MM': 'mnesiai_mnesi_mnesius',
        'y' : 'metai_met_metus',
        'yy': 'metai_met_metus'
    };
    function translateSeconds(number, withoutSuffix, key, isFuture) {
        if (withoutSuffix) {
            return 'kelios sekunds';
        } else {
            return isFuture ? 'keli sekundi' : 'kelias sekundes';
        }
    }
    function translateSingular(number, withoutSuffix, key, isFuture) {
        return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
    }
    function special(number) {
        return number % 10 === 0 || (number > 10 && number < 20);
    }
    function forms(key) {
        return units[key].split('_');
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        if (number === 1) {
            return result + translateSingular(number, withoutSuffix, key[0], isFuture);
        } else if (withoutSuffix) {
            return result + (special(number) ? forms(key)[1] : forms(key)[0]);
        } else {
            if (isFuture) {
                return result + forms(key)[1];
            } else {
                return result + (special(number) ? forms(key)[1] : forms(key)[2]);
            }
        }
    }
    var lt = moment.defineLocale('lt', {
        months : {
            format: 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_'),
            standalone: 'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split('_')
        },
        monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
        weekdays : {
            format: 'sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien'.split('_'),
            standalone: 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_'),
            isFormat: /dddd HH:mm/
        },
        weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),
        weekdaysMin : 'S_P_A_T_K_Pn_'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'YYYY [m.] MMMM D [d.]',
            LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
            LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
            l : 'YYYY-MM-DD',
            ll : 'YYYY [m.] MMMM D [d.]',
            lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
            llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
        },
        calendar : {
            sameDay : '[iandien] LT',
            nextDay : '[Rytoj] LT',
            nextWeek : 'dddd LT',
            lastDay : '[Vakar] LT',
            lastWeek : '[Prajus] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'po %s',
            past : 'prie %s',
            s : translateSeconds,
            m : translateSingular,
            mm : translate,
            h : translateSingular,
            hh : translate,
            d : translateSingular,
            dd : translate,
            M : translateSingular,
            MM : translate,
            y : translateSingular,
            yy : translate
        },
        ordinalParse: /\d{1,2}-oji/,
        ordinal : function (number) {
            return number + '-oji';
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return lt;

}));

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : latvian (lv)
//! author : Kristaps Karlsons : https://github.com/skakri
//! author : Jnis Elmeris : https://github.com/JanisE

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var units = {
        'm': 'mintes_mintm_minte_mintes'.split('_'),
        'mm': 'mintes_mintm_minte_mintes'.split('_'),
        'h': 'stundas_stundm_stunda_stundas'.split('_'),
        'hh': 'stundas_stundm_stunda_stundas'.split('_'),
        'd': 'dienas_dienm_diena_dienas'.split('_'),
        'dd': 'dienas_dienm_diena_dienas'.split('_'),
        'M': 'mnea_mneiem_mnesis_mnei'.split('_'),
        'MM': 'mnea_mneiem_mnesis_mnei'.split('_'),
        'y': 'gada_gadiem_gads_gadi'.split('_'),
        'yy': 'gada_gadiem_gads_gadi'.split('_')
    };
    /**
     * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
     */
    function format(forms, number, withoutSuffix) {
        if (withoutSuffix) {
            // E.g. "21 minte", "3 mintes".
            return number % 10 === 1 && number !== 11 ? forms[2] : forms[3];
        } else {
            // E.g. "21 mintes" as in "pc 21 mintes".
            // E.g. "3 mintm" as in "pc 3 mintm".
            return number % 10 === 1 && number !== 11 ? forms[0] : forms[1];
        }
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        return number + ' ' + format(units[key], number, withoutSuffix);
    }
    function relativeTimeWithSingular(number, withoutSuffix, key) {
        return format(units[key], number, withoutSuffix);
    }
    function relativeSeconds(number, withoutSuffix) {
        return withoutSuffix ? 'daas sekundes' : 'dam sekundm';
    }

    var lv = moment.defineLocale('lv', {
        months : 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),
        weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
        weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY.',
            LL : 'YYYY. [gada] D. MMMM',
            LLL : 'YYYY. [gada] D. MMMM, HH:mm',
            LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'
        },
        calendar : {
            sameDay : '[odien pulksten] LT',
            nextDay : '[Rt pulksten] LT',
            nextWeek : 'dddd [pulksten] LT',
            lastDay : '[Vakar pulksten] LT',
            lastWeek : '[Pagju] dddd [pulksten] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'pc %s',
            past : 'pirms %s',
            s : relativeSeconds,
            m : relativeTimeWithSingular,
            mm : relativeTimeWithPlural,
            h : relativeTimeWithSingular,
            hh : relativeTimeWithPlural,
            d : relativeTimeWithSingular,
            dd : relativeTimeWithPlural,
            M : relativeTimeWithSingular,
            MM : relativeTimeWithPlural,
            y : relativeTimeWithSingular,
            yy : relativeTimeWithPlural
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return lv;

}));

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Montenegrin (me)
//! author : Miodrag Nika <miodrag@restartit.me> : https://github.com/miodragnikac

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var translator = {
        words: { //Different grammatical cases
            m: ['jedan minut', 'jednog minuta'],
            mm: ['minut', 'minuta', 'minuta'],
            h: ['jedan sat', 'jednog sata'],
            hh: ['sat', 'sata', 'sati'],
            dd: ['dan', 'dana', 'dana'],
            MM: ['mjesec', 'mjeseca', 'mjeseci'],
            yy: ['godina', 'godine', 'godina']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var me = moment.defineLocale('me', {
        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
        monthsParseExact : true,
        weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
        weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L: 'DD. MM. YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sjutra u] LT',

            nextWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[jue u] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[prole] [nedjelje] [u] LT',
                    '[prolog] [ponedjeljka] [u] LT',
                    '[prolog] [utorka] [u] LT',
                    '[prole] [srijede] [u] LT',
                    '[prolog] [etvrtka] [u] LT',
                    '[prolog] [petka] [u] LT',
                    '[prole] [subote] [u] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'nekoliko sekundi',
            m      : translator.translate,
            mm     : translator.translate,
            h      : translator.translate,
            hh     : translator.translate,
            d      : 'dan',
            dd     : translator.translate,
            M      : 'mjesec',
            MM     : translator.translate,
            y      : 'godinu',
            yy     : translator.translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return me;

}));

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : macedonian (mk)
//! author : Borislav Mickov : https://github.com/B0k0

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var mk = moment.defineLocale('mk', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : 'e_o_____a'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'D.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd, D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : '[] dddd [] LT',
            lastDay : '[ ] LT',
            lastWeek : function () {
                switch (this.day()) {
                case 0:
                case 3:
                case 6:
                    return '[] dddd [] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[] dddd [] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : ' ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        ordinalParse: /\d{1,2}-(|||||)/,
        ordinal : function (number) {
            var lastDigit = number % 10,
                last2Digits = number % 100;
            if (number === 0) {
                return number + '-';
            } else if (last2Digits === 0) {
                return number + '-';
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + '-';
            } else if (lastDigit === 1) {
                return number + '-';
            } else if (lastDigit === 2) {
                return number + '-';
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + '-';
            } else {
                return number + '-';
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return mk;

}));

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : malayalam (ml)
//! author : Floyd Pink : https://github.com/floydpink

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var ml = moment.defineLocale('ml', {
        months : '___________'.split('_'),
        monthsShort : '._._._.___._._._._._.'.split('_'),
        monthsParseExact : true,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm -',
            LTS : 'A h:mm:ss -',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm -',
            LLLL : 'dddd, D MMMM YYYY, A h:mm -'
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        meridiemParse: /|| ||/i,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if ((meridiem === '' && hour >= 4) ||
                    meridiem === ' ' ||
                    meridiem === '') {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return ' ';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        }
    });

    return ml;

}));

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Marathi (mr)
//! author : Harshad Kale : https://github.com/kalehv
//! author : Vivek Athalye : https://github.com/vnathalye

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    function relativeTimeMr(number, withoutSuffix, string, isFuture)
    {
        var output = '';
        if (withoutSuffix) {
            switch (string) {
                case 's': output = ' '; break;
                case 'm': output = ' '; break;
                case 'mm': output = '%d '; break;
                case 'h': output = ' '; break;
                case 'hh': output = '%d '; break;
                case 'd': output = ' '; break;
                case 'dd': output = '%d '; break;
                case 'M': output = ' '; break;
                case 'MM': output = '%d '; break;
                case 'y': output = ' '; break;
                case 'yy': output = '%d '; break;
            }
        }
        else {
            switch (string) {
                case 's': output = ' '; break;
                case 'm': output = ' '; break;
                case 'mm': output = '%d '; break;
                case 'h': output = ' '; break;
                case 'hh': output = '%d '; break;
                case 'd': output = ' '; break;
                case 'dd': output = '%d '; break;
                case 'M': output = ' '; break;
                case 'MM': output = '%d '; break;
                case 'y': output = ' '; break;
                case 'yy': output = '%d '; break;
            }
        }
        return output.replace(/%d/i, number);
    }

    var mr = moment.defineLocale('mr', {
        months : '___________'.split('_'),
        monthsShort: '._._._._._._._._._._._.'.split('_'),
        monthsParseExact : true,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm ',
            LTS : 'A h:mm:ss ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm '
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek: '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future: '%s',
            past: '%s',
            s: relativeTimeMr,
            m: relativeTimeMr,
            mm: relativeTimeMr,
            h: relativeTimeMr,
            hh: relativeTimeMr,
            d: relativeTimeMr,
            dd: relativeTimeMr,
            M: relativeTimeMr,
            MM: relativeTimeMr,
            y: relativeTimeMr,
            yy: relativeTimeMr
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /|||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return mr;

}));

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bahasa Malaysia (ms-MY)
//! author : Weldan Jamili : https://github.com/weldan

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var ms = moment.defineLocale('ms', {
        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'tengahari') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'petang' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'tengahari';
            } else if (hours < 19) {
                return 'petang';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Esok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kelmarin pukul] LT',
            lastWeek : 'dddd [lepas pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lepas',
            s : 'beberapa saat',
            m : 'seminit',
            mm : '%d minit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ms;

}));

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bahasa Malaysia (ms-MY)
//! author : Weldan Jamili : https://github.com/weldan

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var ms_my = moment.defineLocale('ms-my', {
        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'tengahari') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'petang' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'tengahari';
            } else if (hours < 19) {
                return 'petang';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Esok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kelmarin pukul] LT',
            lastWeek : 'dddd [lepas pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lepas',
            s : 'beberapa saat',
            m : 'seminit',
            mm : '%d minit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ms_my;

}));

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Burmese (my)
//! author : Squar team, mysquar.com

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var my = moment.defineLocale('my', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),

        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[.] LT []',
            nextDay: '[] LT []',
            nextWeek: 'dddd LT []',
            lastDay: '[.] LT []',
            lastWeek: '[] dddd LT []',
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s ',
            past: ' %s ',
            s: '.',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return my;

}));

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : norwegian bokml (nb)
//! authors : Espen Hovlandsdal : https://github.com/rexxars
//!           Sigurd Gartmann : https://github.com/sigurdga

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var nb = moment.defineLocale('nb', {
        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
        monthsParseExact : true,
        weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
        weekdaysShort : 's._ma._ti._on._to._fr._l.'.split('_'),
        weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY [kl.] HH:mm',
            LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
        },
        calendar : {
            sameDay: '[i dag kl.] LT',
            nextDay: '[i morgen kl.] LT',
            nextWeek: 'dddd [kl.] LT',
            lastDay: '[i gr kl.] LT',
            lastWeek: '[forrige] dddd [kl.] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : '%s siden',
            s : 'noen sekunder',
            m : 'ett minutt',
            mm : '%d minutter',
            h : 'en time',
            hh : '%d timer',
            d : 'en dag',
            dd : '%d dager',
            M : 'en mned',
            MM : '%d mneder',
            y : 'ett r',
            yy : '%d r'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return nb;

}));

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : nepali/nepalese
//! author : suvash : https://github.com/suvash

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var ne = moment.defineLocale('ne', {
        months : '___________'.split('_'),
        monthsShort : '._.__.___._._._._._.'.split('_'),
        monthsParseExact : true,
        weekdays : '______'.split('_'),
        weekdaysShort : '._._._._._._.'.split('_'),
        weekdaysMin : '._._._._._._.'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'A h:mm ',
            LTS : 'A h:mm:ss ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /|||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 3) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 16) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : '[] dddd[,] LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd[,] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s',
            past : '%s ',
            s : ' ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ne;

}));

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : dutch (nl)
//! author : Joris Rling : https://github.com/jjupiter

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

    var nl = moment.defineLocale('nl', {
        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
        monthsShort : function (m, format) {
            if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots[m.month()];
            } else {
                return monthsShortWithDots[m.month()];
            }
        },
        monthsParseExact : true,
        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
        weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[vandaag om] LT',
            nextDay: '[morgen om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[gisteren om] LT',
            lastWeek: '[afgelopen] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'over %s',
            past : '%s geleden',
            s : 'een paar seconden',
            m : 'n minuut',
            mm : '%d minuten',
            h : 'n uur',
            hh : '%d uur',
            d : 'n dag',
            dd : '%d dagen',
            M : 'n maand',
            MM : '%d maanden',
            y : 'n jaar',
            yy : '%d jaar'
        },
        ordinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return nl;

}));

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : norwegian nynorsk (nn)
//! author : https://github.com/mechuwind

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var nn = moment.defineLocale('nn', {
        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays : 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
        weekdaysShort : 'sun_mn_tys_ons_tor_fre_lau'.split('_'),
        weekdaysMin : 'su_m_ty_on_to_fr_l'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY [kl.] H:mm',
            LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
        },
        calendar : {
            sameDay: '[I dag klokka] LT',
            nextDay: '[I morgon klokka] LT',
            nextWeek: 'dddd [klokka] LT',
            lastDay: '[I gr klokka] LT',
            lastWeek: '[Fregande] dddd [klokka] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : '%s sidan',
            s : 'nokre sekund',
            m : 'eit minutt',
            mm : '%d minutt',
            h : 'ein time',
            hh : '%d timar',
            d : 'ein dag',
            dd : '%d dagar',
            M : 'ein mnad',
            MM : '%d mnader',
            y : 'eit r',
            yy : '%d r'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return nn;

}));

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : punjabi india (pa-in)
//! author : Harpreet Singh : https://github.com/harpreetkhalsagtbit

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var pa_in = moment.defineLocale('pa-in', {
        // There are months name as per Nanakshahi Calender but they are not used as rigidly in modern Punjabi.
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm ',
            LTS : 'A h:mm:ss ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm '
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
        meridiemParse: /|||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return pa_in;

}));

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : polish (pl)
//! author : Rafal Hirsz : https://github.com/evoL

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_'),
        monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_');
    function plural(n) {
        return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
    }
    function translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
        case 'm':
            return withoutSuffix ? 'minuta' : 'minut';
        case 'mm':
            return result + (plural(number) ? 'minuty' : 'minut');
        case 'h':
            return withoutSuffix  ? 'godzina'  : 'godzin';
        case 'hh':
            return result + (plural(number) ? 'godziny' : 'godzin');
        case 'MM':
            return result + (plural(number) ? 'miesice' : 'miesicy');
        case 'yy':
            return result + (plural(number) ? 'lata' : 'lat');
        }
    }

    var pl = moment.defineLocale('pl', {
        months : function (momentToFormat, format) {
            if (format === '') {
                // Hack: if format empty we know this is used to generate
                // RegExp by moment. Give then back both valid forms of months
                // in RegExp ready format.
                return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
            } else if (/D MMMM/.test(format)) {
                return monthsSubjective[momentToFormat.month()];
            } else {
                return monthsNominative[momentToFormat.month()];
            }
        },
        monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),
        weekdays : 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),
        weekdaysShort : 'nie_pon_wt_r_czw_pt_sb'.split('_'),
        weekdaysMin : 'Nd_Pn_Wt_r_Cz_Pt_So'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Dzi o] LT',
            nextDay: '[Jutro o] LT',
            nextWeek: '[W] dddd [o] LT',
            lastDay: '[Wczoraj o] LT',
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[W zesz niedziel o] LT';
                case 3:
                    return '[W zesz rod o] LT';
                case 6:
                    return '[W zesz sobot o] LT';
                default:
                    return '[W zeszy] dddd [o] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : '%s temu',
            s : 'kilka sekund',
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : '1 dzie',
            dd : '%d dni',
            M : 'miesic',
            MM : translate,
            y : 'rok',
            yy : translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return pl;

}));

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : portuguese (pt)
//! author : Jefferson : https://github.com/jalex79

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var pt = moment.defineLocale('pt', {
        months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays : 'Domingo_Segunda-Feira_Tera-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sbado'.split('_'),
        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
        weekdaysMin : 'Dom_2_3_4_5_6_Sb'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY HH:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Hoje s] LT',
            nextDay: '[Amanh s] LT',
            nextWeek: 'dddd [s] LT',
            lastDay: '[Ontem s] LT',
            lastWeek: function () {
                return (this.day() === 0 || this.day() === 6) ?
                    '[ltimo] dddd [s] LT' : // Saturday + Sunday
                    '[ltima] dddd [s] LT'; // Monday - Friday
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'em %s',
            past : 'h %s',
            s : 'segundos',
            m : 'um minuto',
            mm : '%d minutos',
            h : 'uma hora',
            hh : '%d horas',
            d : 'um dia',
            dd : '%d dias',
            M : 'um ms',
            MM : '%d meses',
            y : 'um ano',
            yy : '%d anos'
        },
        ordinalParse: /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return pt;

}));

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : brazilian portuguese (pt-br)
//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var pt_br = moment.defineLocale('pt-br', {
        months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays : 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
        weekdaysMin : 'Dom_2_3_4_5_6_Sb'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY [s] HH:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY [s] HH:mm'
        },
        calendar : {
            sameDay: '[Hoje s] LT',
            nextDay: '[Amanh s] LT',
            nextWeek: 'dddd [s] LT',
            lastDay: '[Ontem s] LT',
            lastWeek: function () {
                return (this.day() === 0 || this.day() === 6) ?
                    '[ltimo] dddd [s] LT' : // Saturday + Sunday
                    '[ltima] dddd [s] LT'; // Monday - Friday
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'em %s',
            past : '%s atrs',
            s : 'poucos segundos',
            m : 'um minuto',
            mm : '%d minutos',
            h : 'uma hora',
            hh : '%d horas',
            d : 'um dia',
            dd : '%d dias',
            M : 'um ms',
            MM : '%d meses',
            y : 'um ano',
            yy : '%d anos'
        },
        ordinalParse: /\d{1,2}/,
        ordinal : '%d'
    });

    return pt_br;

}));

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : romanian (ro)
//! author : Vlad Gurdiga : https://github.com/gurdiga
//! author : Valentin Agachi : https://github.com/avaly

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
                'mm': 'minute',
                'hh': 'ore',
                'dd': 'zile',
                'MM': 'luni',
                'yy': 'ani'
            },
            separator = ' ';
        if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
            separator = ' de ';
        }
        return number + separator + format[key];
    }

    var ro = moment.defineLocale('ro', {
        months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
        monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays : 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),
        weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),
        weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd, D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay: '[azi la] LT',
            nextDay: '[mine la] LT',
            nextWeek: 'dddd [la] LT',
            lastDay: '[ieri la] LT',
            lastWeek: '[fosta] dddd [la] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'peste %s',
            past : '%s n urm',
            s : 'cteva secunde',
            m : 'un minut',
            mm : relativeTimeWithPlural,
            h : 'o or',
            hh : relativeTimeWithPlural,
            d : 'o zi',
            dd : relativeTimeWithPlural,
            M : 'o lun',
            MM : relativeTimeWithPlural,
            y : 'un an',
            yy : relativeTimeWithPlural
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ro;

}));

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : russian (ru)
//! author : Viktorminator : https://github.com/Viktorminator
//! Author : Menelion Elensle : https://github.com/Oire
//! author :   : https://github.com/socketpair

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'mm': withoutSuffix ? '__' : '__',
            'hh': '__',
            'dd': '__',
            'MM': '__',
            'yy': '__'
        };
        if (key === 'm') {
            return withoutSuffix ? '' : '';
        }
        else {
            return number + ' ' + plural(format[key], +number);
        }
    }
    var monthsParse = [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i];

    // http://new.gramota.ru/spravka/rules/139-prop :  103
    //  : http://new.gramota.ru/spravka/buro/search-answer?s=242637
    // CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
    var ru = moment.defineLocale('ru', {
        months : {
            format: '___________'.split('_'),
            standalone: '___________'.split('_')
        },
        monthsShort : {
            //  CLDR  "."  ".",        ?
            format: '._._._.____._._._._.'.split('_'),
            standalone: '._.__.____._._._._.'.split('_')
        },
        weekdays : {
            standalone: '______'.split('_'),
            format: '______'.split('_'),
            isFormat: /\[ ?[] ?(?:||)? ?\] ?dddd/
        },
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        monthsParse : monthsParse,
        longMonthsParse : monthsParse,
        shortMonthsParse : monthsParse,
        monthsRegex: /^([]|[]|[]|[]|[]|[]|?|[]|\.|\.|\.||.||.|.|.||[.]|.|[]|[]|[])/i,
        monthsShortRegex: /^([]|[]|[]|[]|[]|[]|?|[]|\.|\.|\.||.||.|.|.||[.]|.|[]|[]|[])/i,
        monthsStrictRegex: /^([]|[]|[]|[]|[]|[]|?|[]|?|[]|[]|[])/i,
        monthsShortStrictRegex: /^(\.|\.|\.||\.|[]|[.]|\.|\.|\.|\.|[])/i,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY .',
            LLL : 'D MMMM YYYY ., HH:mm',
            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
        },
        calendar : {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            lastDay: '[ ] LT',
            nextWeek: function (now) {
                if (now.week() !== this.week()) {
                    switch (this.day()) {
                    case 0:
                        return '[ ] dddd [] LT';
                    case 1:
                    case 2:
                    case 4:
                        return '[ ] dddd [] LT';
                    case 3:
                    case 5:
                    case 6:
                        return '[ ] dddd [] LT';
                    }
                } else {
                    if (this.day() === 2) {
                        return '[] dddd [] LT';
                    } else {
                        return '[] dddd [] LT';
                    }
                }
            },
            lastWeek: function (now) {
                if (now.week() !== this.week()) {
                    switch (this.day()) {
                    case 0:
                        return '[ ] dddd [] LT';
                    case 1:
                    case 2:
                    case 4:
                        return '[ ] dddd [] LT';
                    case 3:
                    case 5:
                    case 6:
                        return '[ ] dddd [] LT';
                    }
                } else {
                    if (this.day() === 2) {
                        return '[] dddd [] LT';
                    } else {
                        return '[] dddd [] LT';
                    }
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            m : relativeTimeWithPlural,
            mm : relativeTimeWithPlural,
            h : '',
            hh : relativeTimeWithPlural,
            d : '',
            dd : relativeTimeWithPlural,
            M : '',
            MM : relativeTimeWithPlural,
            y : '',
            yy : relativeTimeWithPlural
        },
        meridiemParse: /|||/i,
        isPM : function (input) {
            return /^(|)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return '';
            } else {
                return '';
            }
        },
        ordinalParse: /\d{1,2}-(||)/,
        ordinal: function (number, period) {
            switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
                return number + '-';
            case 'D':
                return number + '-';
            case 'w':
            case 'W':
                return number + '-';
            default:
                return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ru;

}));

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Northern Sami (se)
//! authors : Brd Rolstad Henriksen : https://github.com/karamell

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';



    var se = moment.defineLocale('se', {
        months : 'oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu'.split('_'),
        monthsShort : 'oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov'.split('_'),
        weekdays : 'sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat'.split('_'),
        weekdaysShort : 'sotn_vuos_ma_gask_duor_bear_lv'.split('_'),
        weekdaysMin : 's_v_m_g_d_b_L'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'MMMM D. [b.] YYYY',
            LLL : 'MMMM D. [b.] YYYY [ti.] HH:mm',
            LLLL : 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
        },
        calendar : {
            sameDay: '[otne ti] LT',
            nextDay: '[ihttin ti] LT',
            nextWeek: 'dddd [ti] LT',
            lastDay: '[ikte ti] LT',
            lastWeek: '[ovddit] dddd [ti] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s geaes',
            past : 'mait %s',
            s : 'moadde sekunddat',
            m : 'okta minuhta',
            mm : '%d minuhtat',
            h : 'okta diimmu',
            hh : '%d diimmut',
            d : 'okta beaivi',
            dd : '%d beaivvit',
            M : 'okta mnnu',
            MM : '%d mnut',
            y : 'okta jahki',
            yy : '%d jagit'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return se;

}));

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Sinhalese (si)
//! author : Sampath Sitinamaluwa : https://github.com/sampathsris

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    /*jshint -W100*/
    var si = moment.defineLocale('si', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'a h:mm',
            LTS : 'a h:mm:ss',
            L : 'YYYY/MM/DD',
            LL : 'YYYY MMMM D',
            LLL : 'YYYY MMMM D, a h:mm',
            LLLL : 'YYYY MMMM D [] dddd, a h:mm:ss'
        },
        calendar : {
            sameDay : '[] LT[]',
            nextDay : '[] LT[]',
            nextWeek : 'dddd LT[]',
            lastDay : '[] LT[]',
            lastWeek : '[] dddd LT[]',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s',
            past : '%s ',
            s : ' ',
            m : '',
            mm : ' %d',
            h : '',
            hh : ' %d',
            d : '',
            dd : ' %d',
            M : '',
            MM : ' %d',
            y : '',
            yy : ' %d'
        },
        ordinalParse: /\d{1,2} /,
        ordinal : function (number) {
            return number + ' ';
        },
        meridiemParse : / | |.|../,
        isPM : function (input) {
            return input === '..' || input === ' ';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? '..' : ' ';
            } else {
                return isLower ? '..' : ' ';
            }
        }
    });

    return si;

}));

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : slovak (sk)
//! author : Martin Minka : https://github.com/k2s
//! based on work of petrbela : https://github.com/petrbela

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var months = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_'),
        monthsShort = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');
    function plural(n) {
        return (n > 1) && (n < 5);
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
        case 's':  // a few seconds / in a few seconds / a few seconds ago
            return (withoutSuffix || isFuture) ? 'pr seknd' : 'pr sekundami';
        case 'm':  // a minute / in a minute / a minute ago
            return withoutSuffix ? 'minta' : (isFuture ? 'mintu' : 'mintou');
        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'minty' : 'mint');
            } else {
                return result + 'mintami';
            }
            break;
        case 'h':  // an hour / in an hour / an hour ago
            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
        case 'hh': // 9 hours / in 9 hours / 9 hours ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'hodiny' : 'hodn');
            } else {
                return result + 'hodinami';
            }
            break;
        case 'd':  // a day / in a day / a day ago
            return (withoutSuffix || isFuture) ? 'de' : 'dom';
        case 'dd': // 9 days / in 9 days / 9 days ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'dni' : 'dn');
            } else {
                return result + 'dami';
            }
            break;
        case 'M':  // a month / in a month / a month ago
            return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
        case 'MM': // 9 months / in 9 months / 9 months ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'mesiace' : 'mesiacov');
            } else {
                return result + 'mesiacmi';
            }
            break;
        case 'y':  // a year / in a year / a year ago
            return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
        case 'yy': // 9 years / in 9 years / 9 years ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'roky' : 'rokov');
            } else {
                return result + 'rokmi';
            }
            break;
        }
    }

    var sk = moment.defineLocale('sk', {
        months : months,
        monthsShort : monthsShort,
        weekdays : 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),
        weekdaysShort : 'ne_po_ut_st_t_pi_so'.split('_'),
        weekdaysMin : 'ne_po_ut_st_t_pi_so'.split('_'),
        longDateFormat : {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay: '[dnes o] LT',
            nextDay: '[zajtra o] LT',
            nextWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[v nedeu o] LT';
                case 1:
                case 2:
                    return '[v] dddd [o] LT';
                case 3:
                    return '[v stredu o] LT';
                case 4:
                    return '[vo tvrtok o] LT';
                case 5:
                    return '[v piatok o] LT';
                case 6:
                    return '[v sobotu o] LT';
                }
            },
            lastDay: '[vera o] LT',
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[minul nedeu o] LT';
                case 1:
                case 2:
                    return '[minul] dddd [o] LT';
                case 3:
                    return '[minul stredu o] LT';
                case 4:
                case 5:
                    return '[minul] dddd [o] LT';
                case 6:
                    return '[minul sobotu o] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : 'pred %s',
            s : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return sk;

}));

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : slovenian (sl)
//! author : Robert Sedovek : https://github.com/sedovsek

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
        case 's':
            return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
        case 'm':
            return withoutSuffix ? 'ena minuta' : 'eno minuto';
        case 'mm':
            if (number === 1) {
                result += withoutSuffix ? 'minuta' : 'minuto';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'minute' : 'minutami';
            } else {
                result += withoutSuffix || isFuture ? 'minut' : 'minutami';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'ena ura' : 'eno uro';
        case 'hh':
            if (number === 1) {
                result += withoutSuffix ? 'ura' : 'uro';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'uri' : 'urama';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'ure' : 'urami';
            } else {
                result += withoutSuffix || isFuture ? 'ur' : 'urami';
            }
            return result;
        case 'd':
            return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
        case 'dd':
            if (number === 1) {
                result += withoutSuffix || isFuture ? 'dan' : 'dnem';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
            } else {
                result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
            }
            return result;
        case 'M':
            return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
        case 'MM':
            if (number === 1) {
                result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
            } else {
                result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
            }
            return result;
        case 'y':
            return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
        case 'yy':
            if (number === 1) {
                result += withoutSuffix || isFuture ? 'leto' : 'letom';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'leti' : 'letoma';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'leta' : 'leti';
            } else {
                result += withoutSuffix || isFuture ? 'let' : 'leti';
            }
            return result;
        }
    }

    var sl = moment.defineLocale('sl', {
        months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays : 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),
        weekdaysShort : 'ned._pon._tor._sre._et._pet._sob.'.split('_'),
        weekdaysMin : 'ne_po_to_sr_e_pe_so'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD. MM. YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[danes ob] LT',
            nextDay  : '[jutri ob] LT',

            nextWeek : function () {
                switch (this.day()) {
                case 0:
                    return '[v] [nedeljo] [ob] LT';
                case 3:
                    return '[v] [sredo] [ob] LT';
                case 6:
                    return '[v] [soboto] [ob] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[v] dddd [ob] LT';
                }
            },
            lastDay  : '[veraj ob] LT',
            lastWeek : function () {
                switch (this.day()) {
                case 0:
                    return '[prejnjo] [nedeljo] [ob] LT';
                case 3:
                    return '[prejnjo] [sredo] [ob] LT';
                case 6:
                    return '[prejnjo] [soboto] [ob] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[prejnji] dddd [ob] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'ez %s',
            past   : 'pred %s',
            s      : processRelativeTime,
            m      : processRelativeTime,
            mm     : processRelativeTime,
            h      : processRelativeTime,
            hh     : processRelativeTime,
            d      : processRelativeTime,
            dd     : processRelativeTime,
            M      : processRelativeTime,
            MM     : processRelativeTime,
            y      : processRelativeTime,
            yy     : processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return sl;

}));

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Albanian (sq)
//! author : Flakrim Ismani : https://github.com/flakerimi
//! author: Menelion Elensle: https://github.com/Oire (tests)
//! author : Oerd Cukalla : https://github.com/oerd (fixes)

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var sq = moment.defineLocale('sq', {
        months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),
        monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),
        weekdays : 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),
        weekdaysShort : 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),
        weekdaysMin : 'D_H_Ma_M_E_P_Sh'.split('_'),
        weekdaysParseExact : true,
        meridiemParse: /PD|MD/,
        isPM: function (input) {
            return input.charAt(0) === 'M';
        },
        meridiem : function (hours, minutes, isLower) {
            return hours < 12 ? 'PD' : 'MD';
        },
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Sot n] LT',
            nextDay : '[Nesr n] LT',
            nextWeek : 'dddd [n] LT',
            lastDay : '[Dje n] LT',
            lastWeek : 'dddd [e kaluar n] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'n %s',
            past : '%s m par',
            s : 'disa sekonda',
            m : 'nj minut',
            mm : '%d minuta',
            h : 'nj or',
            hh : '%d or',
            d : 'nj dit',
            dd : '%d dit',
            M : 'nj muaj',
            MM : '%d muaj',
            y : 'nj vit',
            yy : '%d vite'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return sq;

}));

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Serbian-latin (sr)
//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var translator = {
        words: { //Different grammatical cases
            m: ['jedan minut', 'jedne minute'],
            mm: ['minut', 'minute', 'minuta'],
            h: ['jedan sat', 'jednog sata'],
            hh: ['sat', 'sata', 'sati'],
            dd: ['dan', 'dana', 'dana'],
            MM: ['mesec', 'meseca', 'meseci'],
            yy: ['godina', 'godine', 'godina']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var sr = moment.defineLocale('sr', {
        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays: 'nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota'.split('_'),
        weekdaysShort: 'ned._pon._uto._sre._et._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L: 'DD. MM. YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sutra u] LT',
            nextWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[u] [nedelju] [u] LT';
                case 3:
                    return '[u] [sredu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[jue u] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[prole] [nedelje] [u] LT',
                    '[prolog] [ponedeljka] [u] LT',
                    '[prolog] [utorka] [u] LT',
                    '[prole] [srede] [u] LT',
                    '[prolog] [etvrtka] [u] LT',
                    '[prolog] [petka] [u] LT',
                    '[prole] [subote] [u] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'pre %s',
            s      : 'nekoliko sekundi',
            m      : translator.translate,
            mm     : translator.translate,
            h      : translator.translate,
            hh     : translator.translate,
            d      : 'dan',
            dd     : translator.translate,
            M      : 'mesec',
            MM     : translator.translate,
            y      : 'godinu',
            yy     : translator.translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return sr;

}));

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Serbian-cyrillic (sr-cyrl)
//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var translator = {
        words: { //Different grammatical cases
            m: [' ', ' '],
            mm: ['', '', ''],
            h: [' ', ' '],
            hh: ['', '', ''],
            dd: ['', '', ''],
            MM: ['', '', ''],
            yy: ['', '', '']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var sr_cyrl = moment.defineLocale('sr-cyrl', {
        months: '___________'.split('_'),
        monthsShort: '._._._.____._._._._.'.split('_'),
        monthsParseExact: true,
        weekdays: '______'.split('_'),
        weekdaysShort: '._._._._._._.'.split('_'),
        weekdaysMin: '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L: 'DD. MM. YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[] [] [] LT';
                case 3:
                    return '[] [] [] LT';
                case 6:
                    return '[] [] [] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[] dddd [] LT';
                }
            },
            lastDay  : '[ ] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past   : ' %s',
            s      : ' ',
            m      : translator.translate,
            mm     : translator.translate,
            h      : translator.translate,
            hh     : translator.translate,
            d      : '',
            dd     : translator.translate,
            M      : '',
            MM     : translator.translate,
            y      : '',
            yy     : translator.translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return sr_cyrl;

}));

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : siSwati (ss)
//! author : Nicolai Davies<mail@nicolai.io> : https://github.com/nicolaidavies

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';



    var ss = moment.defineLocale('ss', {
        months : "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
        monthsShort : 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
        weekdays : 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
        weekdaysShort : 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
        weekdaysMin : 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Namuhla nga] LT',
            nextDay : '[Kusasa nga] LT',
            nextWeek : 'dddd [nga] LT',
            lastDay : '[Itolo nga] LT',
            lastWeek : 'dddd [leliphelile] [nga] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'nga %s',
            past : 'wenteka nga %s',
            s : 'emizuzwana lomcane',
            m : 'umzuzu',
            mm : '%d emizuzu',
            h : 'lihora',
            hh : '%d emahora',
            d : 'lilanga',
            dd : '%d emalanga',
            M : 'inyanga',
            MM : '%d tinyanga',
            y : 'umnyaka',
            yy : '%d iminyaka'
        },
        meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'ekuseni';
            } else if (hours < 15) {
                return 'emini';
            } else if (hours < 19) {
                return 'entsambama';
            } else {
                return 'ebusuku';
            }
        },
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'ekuseni') {
                return hour;
            } else if (meridiem === 'emini') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
                if (hour === 0) {
                    return 0;
                }
                return hour + 12;
            }
        },
        ordinalParse: /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return ss;

}));

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : swedish (sv)
//! author : Jens Alm : https://github.com/ulmus

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var sv = moment.defineLocale('sv', {
        months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),
        weekdaysShort : 'sn_mn_tis_ons_tor_fre_lr'.split('_'),
        weekdaysMin : 's_m_ti_on_to_fr_l'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [kl.] HH:mm',
            LLLL : 'dddd D MMMM YYYY [kl.] HH:mm',
            lll : 'D MMM YYYY HH:mm',
            llll : 'ddd D MMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Idag] LT',
            nextDay: '[Imorgon] LT',
            lastDay: '[Igr] LT',
            nextWeek: '[P] dddd LT',
            lastWeek: '[I] dddd[s] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : 'fr %s sedan',
            s : 'ngra sekunder',
            m : 'en minut',
            mm : '%d minuter',
            h : 'en timme',
            hh : '%d timmar',
            d : 'en dag',
            dd : '%d dagar',
            M : 'en mnad',
            MM : '%d mnader',
            y : 'ett r',
            yy : '%d r'
        },
        ordinalParse: /\d{1,2}(e|a)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'e' :
                (b === 1) ? 'a' :
                (b === 2) ? 'a' :
                (b === 3) ? 'e' : 'e';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return sv;

}));

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : swahili (sw)
//! author : Fahad Kassim : https://github.com/fadsel

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var sw = moment.defineLocale('sw', {
        months : 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
        weekdays : 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
        weekdaysShort : 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
        weekdaysMin : 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[leo saa] LT',
            nextDay : '[kesho saa] LT',
            nextWeek : '[wiki ijayo] dddd [saat] LT',
            lastDay : '[jana] LT',
            lastWeek : '[wiki iliyopita] dddd [saat] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s baadaye',
            past : 'tokea %s',
            s : 'hivi punde',
            m : 'dakika moja',
            mm : 'dakika %d',
            h : 'saa limoja',
            hh : 'masaa %d',
            d : 'siku moja',
            dd : 'masiku %d',
            M : 'mwezi mmoja',
            MM : 'miezi %d',
            y : 'mwaka mmoja',
            yy : 'miaka %d'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return sw;

}));

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : tamil (ta)
//! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var ta = moment.defineLocale('ta', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, HH:mm',
            LLLL : 'dddd, D MMMM YYYY, HH:mm'
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[ ] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : '  ',
            m : ' ',
            mm : '%d ',
            h : '  ',
            hh : '%d  ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        ordinalParse: /\d{1,2}/,
        ordinal : function (number) {
            return number + '';
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // refer http://ta.wikipedia.org/s/1er1
        meridiemParse: /|||||/,
        meridiem : function (hour, minute, isLower) {
            if (hour < 2) {
                return ' ';
            } else if (hour < 6) {
                return ' ';  // 
            } else if (hour < 10) {
                return ' '; // 
            } else if (hour < 14) {
                return ' '; // 
            } else if (hour < 18) {
                return ' '; // 
            } else if (hour < 22) {
                return ' '; // 
            } else {
                return ' ';
            }
        },
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 2 ? hour : hour + 12;
            } else if (meridiem === '' || meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else {
                return hour + 12;
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ta;

}));

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : telugu (te)
//! author : Krishna Chaitanya Thota : https://github.com/kcthota

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var te = moment.defineLocale('te', {
        months : '___________'.split('_'),
        monthsShort : '._.__.____._._._._.'.split('_'),
        monthsParseExact : true,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm',
            LTS : 'A h:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm',
            LLLL : 'dddd, D MMMM YYYY, A h:mm'
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        ordinalParse : /\d{1,2}/,
        ordinal : '%d',
        meridiemParse: /|||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return te;

}));

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : thai (th)
//! author : Kridsada Thanabulpong : https://github.com/sirn

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var th = moment.defineLocale('th', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        monthsParseExact: true,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'), // yes, three characters difference
        weekdaysMin : '._._._._._._.'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H  m ',
            LTS : 'H  m  s ',
            L : 'YYYY/MM/DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY  H  m ',
            LLLL : 'dddd D MMMM YYYY  H  m '
        },
        meridiemParse: /|/,
        isPM: function (input) {
            return input === '';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd[ ] LT',
            lastDay : '[ ] LT',
            lastWeek : '[]dddd[ ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s',
            s : '',
            m : '1 ',
            mm : '%d ',
            h : '1 ',
            hh : '%d ',
            d : '1 ',
            dd : '%d ',
            M : '1 ',
            MM : '%d ',
            y : '1 ',
            yy : '%d '
        }
    });

    return th;

}));

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tagalog/Filipino (tl-ph)
//! author : Dan Hagman

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var tl_ph = moment.defineLocale('tl-ph', {
        months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
        monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
        weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
        weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
        weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'MM/D/YYYY',
            LL : 'MMMM D, YYYY',
            LLL : 'MMMM D, YYYY HH:mm',
            LLLL : 'dddd, MMMM DD, YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Ngayon sa] LT',
            nextDay: '[Bukas sa] LT',
            nextWeek: 'dddd [sa] LT',
            lastDay: '[Kahapon sa] LT',
            lastWeek: 'dddd [huling linggo] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'sa loob ng %s',
            past : '%s ang nakalipas',
            s : 'ilang segundo',
            m : 'isang minuto',
            mm : '%d minuto',
            h : 'isang oras',
            hh : '%d oras',
            d : 'isang araw',
            dd : '%d araw',
            M : 'isang buwan',
            MM : '%d buwan',
            y : 'isang taon',
            yy : '%d taon'
        },
        ordinalParse: /\d{1,2}/,
        ordinal : function (number) {
            return number;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return tl_ph;

}));

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Klingon (tlh)
//! author : Dominika Kruk : https://github.com/amaranthrose

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var numbersNouns = 'pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

    function translateFuture(output) {
        var time = output;
        time = (output.indexOf('jaj') !== -1) ?
    	time.slice(0, -3) + 'leS' :
    	(output.indexOf('jar') !== -1) ?
    	time.slice(0, -3) + 'waQ' :
    	(output.indexOf('DIS') !== -1) ?
    	time.slice(0, -3) + 'nem' :
    	time + ' pIq';
        return time;
    }

    function translatePast(output) {
        var time = output;
        time = (output.indexOf('jaj') !== -1) ?
    	time.slice(0, -3) + 'Hu' :
    	(output.indexOf('jar') !== -1) ?
    	time.slice(0, -3) + 'wen' :
    	(output.indexOf('DIS') !== -1) ?
    	time.slice(0, -3) + 'ben' :
    	time + ' ret';
        return time;
    }

    function translate(number, withoutSuffix, string, isFuture) {
        var numberNoun = numberAsNoun(number);
        switch (string) {
            case 'mm':
                return numberNoun + ' tup';
            case 'hh':
                return numberNoun + ' rep';
            case 'dd':
                return numberNoun + ' jaj';
            case 'MM':
                return numberNoun + ' jar';
            case 'yy':
                return numberNoun + ' DIS';
        }
    }

    function numberAsNoun(number) {
        var hundred = Math.floor((number % 1000) / 100),
    	ten = Math.floor((number % 100) / 10),
    	one = number % 10,
    	word = '';
        if (hundred > 0) {
            word += numbersNouns[hundred] + 'vatlh';
        }
        if (ten > 0) {
            word += ((word !== '') ? ' ' : '') + numbersNouns[ten] + 'maH';
        }
        if (one > 0) {
            word += ((word !== '') ? ' ' : '') + numbersNouns[one];
        }
        return (word === '') ? 'pagh' : word;
    }

    var tlh = moment.defineLocale('tlh', {
        months : 'tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha'.split('_'),
        monthsShort : 'jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha'.split('_'),
        monthsParseExact : true,
        weekdays : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
        weekdaysShort : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
        weekdaysMin : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[DaHjaj] LT',
            nextDay: '[waleS] LT',
            nextWeek: 'LLL',
            lastDay: '[waHu] LT',
            lastWeek: 'LLL',
            sameElse: 'L'
        },
        relativeTime : {
            future : translateFuture,
            past : translatePast,
            s : 'puS lup',
            m : 'wa tup',
            mm : translate,
            h : 'wa rep',
            hh : translate,
            d : 'wa jaj',
            dd : translate,
            M : 'wa jar',
            MM : translate,
            y : 'wa DIS',
            yy : translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return tlh;

}));

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : turkish (tr)
//! authors : Erhan Gundogan : https://github.com/erhangundogan,
//!           Burak Yiit Kaya: https://github.com/BYK

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var suffixes = {
        1: '\'inci',
        5: '\'inci',
        8: '\'inci',
        70: '\'inci',
        80: '\'inci',
        2: '\'nci',
        7: '\'nci',
        20: '\'nci',
        50: '\'nci',
        3: '\'nc',
        4: '\'nc',
        100: '\'nc',
        6: '\'nc',
        9: '\'uncu',
        10: '\'uncu',
        30: '\'uncu',
        60: '\'nc',
        90: '\'nc'
    };

    var tr = moment.defineLocale('tr', {
        months : 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),
        monthsShort : 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),
        weekdays : 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),
        weekdaysShort : 'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),
        weekdaysMin : 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[bugn saat] LT',
            nextDay : '[yarn saat] LT',
            nextWeek : '[haftaya] dddd [saat] LT',
            lastDay : '[dn] LT',
            lastWeek : '[geen hafta] dddd [saat] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s sonra',
            past : '%s nce',
            s : 'birka saniye',
            m : 'bir dakika',
            mm : '%d dakika',
            h : 'bir saat',
            hh : '%d saat',
            d : 'bir gn',
            dd : '%d gn',
            M : 'bir ay',
            MM : '%d ay',
            y : 'bir yl',
            yy : '%d yl'
        },
        ordinalParse: /\d{1,2}'(inci|nci|nc|nc|uncu|nc)/,
        ordinal : function (number) {
            if (number === 0) {  // special case for zero
                return number + '\'nc';
            }
            var a = number % 10,
                b = number % 100 - a,
                c = number >= 100 ? 100 : null;
            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return tr;

}));

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : talossan (tzl)
//! author : Robin van der Vliet : https://github.com/robin0van0der0v with the help of Iust Canun

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';



    // After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
    // This is currently too difficult (maybe even impossible) to add.
    var tzl = moment.defineLocale('tzl', {
        months : 'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
        weekdays : 'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),
        weekdaysShort : 'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),
        weekdaysMin : 'S_L_Ma_M_Xh_Vi_S'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM [dallas] YYYY',
            LLL : 'D. MMMM [dallas] YYYY HH.mm',
            LLLL : 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
        },
        meridiemParse: /d\'o|d\'a/i,
        isPM : function (input) {
            return 'd\'o' === input.toLowerCase();
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'd\'o' : 'D\'O';
            } else {
                return isLower ? 'd\'a' : 'D\'A';
            }
        },
        calendar : {
            sameDay : '[oxhi ] LT',
            nextDay : '[dem ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ieiri ] LT',
            lastWeek : '[sr el] dddd [lasteu ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'osprei %s',
            past : 'ja%s',
            s : processRelativeTime,
            m : processRelativeTime,
            mm : processRelativeTime,
            h : processRelativeTime,
            hh : processRelativeTime,
            d : processRelativeTime,
            dd : processRelativeTime,
            M : processRelativeTime,
            MM : processRelativeTime,
            y : processRelativeTime,
            yy : processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            's': ['viensas secunds', '\'iensas secunds'],
            'm': ['\'n mut', '\'iens mut'],
            'mm': [number + ' muts', '' + number + ' muts'],
            'h': ['\'n ora', '\'iensa ora'],
            'hh': [number + ' oras', '' + number + ' oras'],
            'd': ['\'n ziua', '\'iensa ziua'],
            'dd': [number + ' ziuas', '' + number + ' ziuas'],
            'M': ['\'n mes', '\'iens mes'],
            'MM': [number + ' mesen', '' + number + ' mesen'],
            'y': ['\'n ar', '\'iens ar'],
            'yy': [number + ' ars', '' + number + ' ars']
        };
        return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);
    }

    return tzl;

}));

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Morocco Central Atlas Tamazit (tzm)
//! author : Abdel Said : https://github.com/abdelsaid

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var tzm = moment.defineLocale('tzm', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[ ] LT',
            lastWeek: 'dddd [] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : '   %s',
            past : ' %s',
            s : '',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d o',
            M : 'o',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return tzm;

}));

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Morocco Central Atlas Tamazit in Latin (tzm-latn)
//! author : Abdel Said : https://github.com/abdelsaid

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var tzm_latn = moment.defineLocale('tzm-latn', {
        months : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
        monthsShort : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
        weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
        weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
        weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[asdkh g] LT',
            nextDay: '[aska g] LT',
            nextWeek: 'dddd [g] LT',
            lastDay: '[assant g] LT',
            lastWeek: 'dddd [g] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'dadkh s yan %s',
            past : 'yan %s',
            s : 'imik',
            m : 'minu',
            mm : '%d minu',
            h : 'saa',
            hh : '%d tassain',
            d : 'ass',
            dd : '%d ossan',
            M : 'ayowr',
            MM : '%d iyyirn',
            y : 'asgas',
            yy : '%d isgasn'
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return tzm_latn;

}));

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : ukrainian (uk)
//! author : zemlanin : https://github.com/zemlanin
//! Author : Menelion Elensle : https://github.com/Oire

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'mm': withoutSuffix ? '__' : '__',
            'hh': withoutSuffix ? '__' : '__',
            'dd': '__',
            'MM': '__',
            'yy': '__'
        };
        if (key === 'm') {
            return withoutSuffix ? '' : '';
        }
        else if (key === 'h') {
            return withoutSuffix ? '' : '';
        }
        else {
            return number + ' ' + plural(format[key], +number);
        }
    }
    function weekdaysCaseReplace(m, format) {
        var weekdays = {
            'nominative': '______'.split('_'),
            'accusative': '______'.split('_'),
            'genitive': '______'.split('_')
        },
        nounCase = (/(\[[]\]) ?dddd/).test(format) ?
            'accusative' :
            ((/\[?(?:|)? ?\] ?dddd/).test(format) ?
                'genitive' :
                'nominative');
        return weekdays[nounCase][m.day()];
    }
    function processHoursFunction(str) {
        return function () {
            return str + '' + (this.hours() === 11 ? '' : '') + '] LT';
        };
    }

    var uk = moment.defineLocale('uk', {
        months : {
            'format': '___________'.split('_'),
            'standalone': '___________'.split('_')
        },
        monthsShort : '___________'.split('_'),
        weekdays : weekdaysCaseReplace,
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY .',
            LLL : 'D MMMM YYYY ., HH:mm',
            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
        },
        calendar : {
            sameDay: processHoursFunction('[ '),
            nextDay: processHoursFunction('[ '),
            lastDay: processHoursFunction('[ '),
            nextWeek: processHoursFunction('[] dddd ['),
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                case 3:
                case 5:
                case 6:
                    return processHoursFunction('[] dddd [').call(this);
                case 1:
                case 2:
                case 4:
                    return processHoursFunction('[] dddd [').call(this);
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            m : relativeTimeWithPlural,
            mm : relativeTimeWithPlural,
            h : '',
            hh : relativeTimeWithPlural,
            d : '',
            dd : relativeTimeWithPlural,
            M : '',
            MM : relativeTimeWithPlural,
            y : '',
            yy : relativeTimeWithPlural
        },
        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
        meridiemParse: /|||/,
        isPM: function (input) {
            return /^(|)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return '';
            } else {
                return '';
            }
        },
        ordinalParse: /\d{1,2}-(|)/,
        ordinal: function (number, period) {
            switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
            case 'w':
            case 'W':
                return number + '-';
            case 'D':
                return number + '-';
            default:
                return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return uk;

}));

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : uzbek (uz)
//! author : Sardor Muminov : https://github.com/muminoff

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var uz = moment.defineLocale('uz', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'D MMMM YYYY, dddd HH:mm'
        },
        calendar : {
            sameDay : '[ ] LT []',
            nextDay : '[] LT []',
            nextWeek : 'dddd [ ] LT []',
            lastDay : '[ ] LT []',
            lastWeek : '[] dddd [ ] LT []',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s ',
            past : '  %s ',
            s : '',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return uz;

}));

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : vietnamese (vi)
//! author : Bang Nguyen : https://github.com/bangnk

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var vi = moment.defineLocale('vi', {
        months : 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),
        monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
        monthsParseExact : true,
        weekdays : 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),
        weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysParseExact : true,
        meridiemParse: /sa|ch/i,
        isPM : function (input) {
            return /^ch$/i.test(input);
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? 'sa' : 'SA';
            } else {
                return isLower ? 'ch' : 'CH';
            }
        },
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM [nm] YYYY',
            LLL : 'D MMMM [nm] YYYY HH:mm',
            LLLL : 'dddd, D MMMM [nm] YYYY HH:mm',
            l : 'DD/M/YYYY',
            ll : 'D MMM YYYY',
            lll : 'D MMM YYYY HH:mm',
            llll : 'ddd, D MMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Hm nay lc] LT',
            nextDay: '[Ngy mai lc] LT',
            nextWeek: 'dddd [tun ti lc] LT',
            lastDay: '[Hm qua lc] LT',
            lastWeek: 'dddd [tun ri lc] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s ti',
            past : '%s trc',
            s : 'vi giy',
            m : 'mt pht',
            mm : '%d pht',
            h : 'mt gi',
            hh : '%d gi',
            d : 'mt ngy',
            dd : '%d ngy',
            M : 'mt thng',
            MM : '%d thng',
            y : 'mt nm',
            yy : '%d nm'
        },
        ordinalParse: /\d{1,2}/,
        ordinal : function (number) {
            return number;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return vi;

}));

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : pseudo (x-pseudo)
//! author : Andrew Hood : https://github.com/andrewhood125

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var x_pseudo = moment.defineLocale('x-pseudo', {
        months : 'J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr'.split('_'),
        monthsShort : 'J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc'.split('_'),
        monthsParseExact : true,
        weekdays : 'S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d'.split('_'),
        weekdaysShort : 'S~_~M_~T_~Wd_~Th_~Fr_~St'.split('_'),
        weekdaysMin : 'S~_M~_T_~W_T~h_Fr~_S'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[T~d~ t] LT',
            nextDay : '[T~m~rr~w t] LT',
            nextWeek : 'dddd [t] LT',
            lastDay : '[~st~rd~ t] LT',
            lastWeek : '[L~st] dddd [t] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '~ %s',
            past : '%s ~g',
            s : ' ~fw ~sc~ds',
            m : ' ~m~t',
            mm : '%d m~~ts',
            h : '~ h~r',
            hh : '%d h~rs',
            d : ' ~d',
            dd : '%d d~s',
            M : ' ~m~th',
            MM : '%d m~t~hs',
            y : ' ~r',
            yy : '%d ~rs'
        },
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return x_pseudo;

}));

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : chinese (zh-cn)
//! author : suupic : https://github.com/suupic
//! author : Zeno Zeng : https://github.com/zenozeng

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var zh_cn = moment.defineLocale('zh-cn', {
        months : '___________'.split('_'),
        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'Ahmm',
            LTS : 'Ahms',
            L : 'YYYY-MM-DD',
            LL : 'YYYYMMMD',
            LLL : 'YYYYMMMDAhmm',
            LLLL : 'YYYYMMMDddddAhmm',
            l : 'YYYY-MM-DD',
            ll : 'YYYYMMMD',
            lll : 'YYYYMMMDAhmm',
            llll : 'YYYYMMMDddddAhmm'
        },
        meridiemParse: /|||||/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '' || meridiem === '' ||
                    meridiem === '') {
                return hour;
            } else if (meridiem === '' || meridiem === '') {
                return hour + 12;
            } else {
                // ''
                return hour >= 11 ? hour : hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '';
            } else if (hm < 900) {
                return '';
            } else if (hm < 1130) {
                return '';
            } else if (hm < 1230) {
                return '';
            } else if (hm < 1800) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : function () {
                return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
            },
            nextDay : function () {
                return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
            },
            lastDay : function () {
                return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
            },
            nextWeek : function () {
                var startOfWeek, prefix;
                startOfWeek = moment().startOf('week');
                prefix = this.diff(startOfWeek, 'days') >= 7 ? '[]' : '[]';
                return this.minutes() === 0 ? prefix + 'dddAh' : prefix + 'dddAhmm';
            },
            lastWeek : function () {
                var startOfWeek, prefix;
                startOfWeek = moment().startOf('week');
                prefix = this.unix() < startOfWeek.unix()  ? '[]' : '[]';
                return this.minutes() === 0 ? prefix + 'dddAh' : prefix + 'dddAhmm';
            },
            sameElse : 'LL'
        },
        ordinalParse: /\d{1,2}(||)/,
        ordinal : function (number, period) {
            switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
                return number + '';
            case 'M':
                return number + '';
            case 'w':
            case 'W':
                return number + '';
            default:
                return number;
            }
        },
        relativeTime : {
            future : '%s',
            past : '%s',
            s : '',
            m : '1 ',
            mm : '%d ',
            h : '1 ',
            hh : '%d ',
            d : '1 ',
            dd : '%d ',
            M : '1 ',
            MM : '%d ',
            y : '1 ',
            yy : '%d '
        },
        week : {
            // GB/T 7408-1994ISO 8601:1988
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return zh_cn;

}));

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : traditional chinese (zh-tw)
//! author : Ben : https://github.com/ben-lin

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var zh_tw = moment.defineLocale('zh-tw', {
        months : '___________'.split('_'),
        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'Ahmm',
            LTS : 'Ahms',
            L : 'YYYYMMMD',
            LL : 'YYYYMMMD',
            LLL : 'YYYYMMMDAhmm',
            LLLL : 'YYYYMMMDddddAhmm',
            l : 'YYYYMMMD',
            ll : 'YYYYMMMD',
            lll : 'YYYYMMMDAhmm',
            llll : 'YYYYMMMDddddAhmm'
        },
        meridiemParse: /||||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '' || meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === '' || meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 900) {
                return '';
            } else if (hm < 1130) {
                return '';
            } else if (hm < 1230) {
                return '';
            } else if (hm < 1800) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[]LT',
            nextDay : '[]LT',
            nextWeek : '[]ddddLT',
            lastDay : '[]LT',
            lastWeek : '[]ddddLT',
            sameElse : 'L'
        },
        ordinalParse: /\d{1,2}(||)/,
        ordinal : function (number, period) {
            switch (period) {
            case 'd' :
            case 'D' :
            case 'DDD' :
                return number + '';
            case 'M' :
                return number + '';
            case 'w' :
            case 'W' :
                return number + '';
            default :
                return number;
            }
        },
        relativeTime : {
            future : '%s',
            past : '%s',
            s : '',
            m : '1',
            mm : '%d',
            h : '1',
            hh : '%d',
            d : '1',
            dd : '%d',
            M : '1',
            MM : '%d',
            y : '1',
            yy : '%d'
        }
    });

    return zh_tw;

}));

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var pSlice = Array.prototype.slice;
var objectKeys = __webpack_require__(143);
var isArguments = __webpack_require__(144);

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}


/***/ }),
/* 138 */,
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

//  Ramda v0.21.0
//  https://github.com/ramda/ramda
//  (c) 2013-2016 Scott Sauyet, Michael Hurley, and David Chambers
//  Ramda may be freely distributed under the MIT license.

;(function() {

  'use strict';

  /**
     * A special placeholder value used to specify "gaps" within curried functions,
     * allowing partial application of any combination of arguments, regardless of
     * their positions.
     *
     * If `g` is a curried ternary function and `_` is `R.__`, the following are
     * equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2, _)(1, 3)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @constant
     * @memberOf R
     * @since v0.6.0
     * @category Function
     * @example
     *
     *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');
     *      greet('Alice'); //=> 'Hello, Alice!'
     */
    var __ = { '@@functional/placeholder': true };

    /* eslint-disable no-unused-vars */
    var _arity = function _arity(n, fn) {
        /* eslint-disable no-unused-vars */
        switch (n) {
        case 0:
            return function () {
                return fn.apply(this, arguments);
            };
        case 1:
            return function (a0) {
                return fn.apply(this, arguments);
            };
        case 2:
            return function (a0, a1) {
                return fn.apply(this, arguments);
            };
        case 3:
            return function (a0, a1, a2) {
                return fn.apply(this, arguments);
            };
        case 4:
            return function (a0, a1, a2, a3) {
                return fn.apply(this, arguments);
            };
        case 5:
            return function (a0, a1, a2, a3, a4) {
                return fn.apply(this, arguments);
            };
        case 6:
            return function (a0, a1, a2, a3, a4, a5) {
                return fn.apply(this, arguments);
            };
        case 7:
            return function (a0, a1, a2, a3, a4, a5, a6) {
                return fn.apply(this, arguments);
            };
        case 8:
            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
                return fn.apply(this, arguments);
            };
        case 9:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
                return fn.apply(this, arguments);
            };
        case 10:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                return fn.apply(this, arguments);
            };
        default:
            throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
        }
    };

    var _arrayFromIterator = function _arrayFromIterator(iter) {
        var list = [];
        var next;
        while (!(next = iter.next()).done) {
            list.push(next.value);
        }
        return list;
    };

    var _arrayOf = function _arrayOf() {
        return Array.prototype.slice.call(arguments);
    };

    var _cloneRegExp = function _cloneRegExp(pattern) {
        return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
    };

    var _complement = function _complement(f) {
        return function () {
            return !f.apply(this, arguments);
        };
    };

    /**
     * Private `concat` function to merge two array-like objects.
     *
     * @private
     * @param {Array|Arguments} [set1=[]] An array-like object.
     * @param {Array|Arguments} [set2=[]] An array-like object.
     * @return {Array} A new, merged array.
     * @example
     *
     *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
     */
    var _concat = function _concat(set1, set2) {
        set1 = set1 || [];
        set2 = set2 || [];
        var idx;
        var len1 = set1.length;
        var len2 = set2.length;
        var result = [];
        idx = 0;
        while (idx < len1) {
            result[result.length] = set1[idx];
            idx += 1;
        }
        idx = 0;
        while (idx < len2) {
            result[result.length] = set2[idx];
            idx += 1;
        }
        return result;
    };

    var _containsWith = function _containsWith(pred, x, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            if (pred(x, list[idx])) {
                return true;
            }
            idx += 1;
        }
        return false;
    };

    var _filter = function _filter(fn, list) {
        var idx = 0;
        var len = list.length;
        var result = [];
        while (idx < len) {
            if (fn(list[idx])) {
                result[result.length] = list[idx];
            }
            idx += 1;
        }
        return result;
    };

    var _forceReduced = function _forceReduced(x) {
        return {
            '@@transducer/value': x,
            '@@transducer/reduced': true
        };
    };

    // String(x => x) evaluates to "x => x", so the pattern may not match.
    var _functionName = function _functionName(f) {
        // String(x => x) evaluates to "x => x", so the pattern may not match.
        var match = String(f).match(/^function (\w*)/);
        return match == null ? '' : match[1];
    };

    var _has = function _has(prop, obj) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
    };

    var _identity = function _identity(x) {
        return x;
    };

    var _isArguments = function () {
        var toString = Object.prototype.toString;
        return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
            return toString.call(x) === '[object Arguments]';
        } : function _isArguments(x) {
            return _has('callee', x);
        };
    }();

    /**
     * Tests whether or not an object is an array.
     *
     * @private
     * @param {*} val The object to test.
     * @return {Boolean} `true` if `val` is an array, `false` otherwise.
     * @example
     *
     *      _isArray([]); //=> true
     *      _isArray(null); //=> false
     *      _isArray({}); //=> false
     */
    var _isArray = Array.isArray || function _isArray(val) {
        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
    };

    var _isFunction = function _isNumber(x) {
        return Object.prototype.toString.call(x) === '[object Function]';
    };

    /**
     * Determine if the passed argument is an integer.
     *
     * @private
     * @param {*} n
     * @category Type
     * @return {Boolean}
     */
    var _isInteger = Number.isInteger || function _isInteger(n) {
        return n << 0 === n;
    };

    var _isNumber = function _isNumber(x) {
        return Object.prototype.toString.call(x) === '[object Number]';
    };

    var _isObject = function _isObject(x) {
        return Object.prototype.toString.call(x) === '[object Object]';
    };

    var _isPlaceholder = function _isPlaceholder(a) {
        return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
    };

    var _isRegExp = function _isRegExp(x) {
        return Object.prototype.toString.call(x) === '[object RegExp]';
    };

    var _isString = function _isString(x) {
        return Object.prototype.toString.call(x) === '[object String]';
    };

    var _isTransformer = function _isTransformer(obj) {
        return typeof obj['@@transducer/step'] === 'function';
    };

    var _map = function _map(fn, functor) {
        var idx = 0;
        var len = functor.length;
        var result = Array(len);
        while (idx < len) {
            result[idx] = fn(functor[idx]);
            idx += 1;
        }
        return result;
    };

    // Based on https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
    var _objectAssign = function _objectAssign(target) {
        if (target == null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }
        var output = Object(target);
        var idx = 1;
        var length = arguments.length;
        while (idx < length) {
            var source = arguments[idx];
            if (source != null) {
                for (var nextKey in source) {
                    if (_has(nextKey, source)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
            idx += 1;
        }
        return output;
    };

    var _of = function _of(x) {
        return [x];
    };

    var _pipe = function _pipe(f, g) {
        return function () {
            return g.call(this, f.apply(this, arguments));
        };
    };

    var _pipeP = function _pipeP(f, g) {
        return function () {
            var ctx = this;
            return f.apply(ctx, arguments).then(function (x) {
                return g.call(ctx, x);
            });
        };
    };

    // \b matches word boundary; [\b] matches backspace
    var _quote = function _quote(s) {
        var escaped = s.replace(/\\/g, '\\\\').replace(/[\b]/g, '\\b')    // \b matches word boundary; [\b] matches backspace
    .replace(/\f/g, '\\f').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t').replace(/\v/g, '\\v').replace(/\0/g, '\\0');
        return '"' + escaped.replace(/"/g, '\\"') + '"';
    };

    var _reduced = function _reduced(x) {
        return x && x['@@transducer/reduced'] ? x : {
            '@@transducer/value': x,
            '@@transducer/reduced': true
        };
    };

    /**
     * An optimized, private array `slice` implementation.
     *
     * @private
     * @param {Arguments|Array} args The array or arguments object to consider.
     * @param {Number} [from=0] The array index to slice from, inclusive.
     * @param {Number} [to=args.length] The array index to slice to, exclusive.
     * @return {Array} A new, sliced array.
     * @example
     *
     *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]
     *
     *      var firstThreeArgs = function(a, b, c, d) {
     *        return _slice(arguments, 0, 3);
     *      };
     *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]
     */
    var _slice = function _slice(args, from, to) {
        switch (arguments.length) {
        case 1:
            return _slice(args, 0, args.length);
        case 2:
            return _slice(args, from, args.length);
        default:
            var list = [];
            var idx = 0;
            var len = Math.max(0, Math.min(args.length, to) - from);
            while (idx < len) {
                list[idx] = args[from + idx];
                idx += 1;
            }
            return list;
        }
    };

    /**
     * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
     */
    var _toISOString = function () {
        var pad = function pad(n) {
            return (n < 10 ? '0' : '') + n;
        };
        return typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
            return d.toISOString();
        } : function _toISOString(d) {
            return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
        };
    }();

    var _xfBase = {
        init: function () {
            return this.xf['@@transducer/init']();
        },
        result: function (result) {
            return this.xf['@@transducer/result'](result);
        }
    };

    var _xwrap = function () {
        function XWrap(fn) {
            this.f = fn;
        }
        XWrap.prototype['@@transducer/init'] = function () {
            throw new Error('init not implemented on XWrap');
        };
        XWrap.prototype['@@transducer/result'] = function (acc) {
            return acc;
        };
        XWrap.prototype['@@transducer/step'] = function (acc, x) {
            return this.f(acc, x);
        };
        return function _xwrap(fn) {
            return new XWrap(fn);
        };
    }();

    var _aperture = function _aperture(n, list) {
        var idx = 0;
        var limit = list.length - (n - 1);
        var acc = new Array(limit >= 0 ? limit : 0);
        while (idx < limit) {
            acc[idx] = _slice(list, idx, idx + n);
            idx += 1;
        }
        return acc;
    };

    var _assign = typeof Object.assign === 'function' ? Object.assign : _objectAssign;

    /**
     * Similar to hasMethod, this checks whether a function has a [methodname]
     * function. If it isn't an array it will execute that function otherwise it
     * will default to the ramda implementation.
     *
     * @private
     * @param {Function} fn ramda implemtation
     * @param {String} methodname property to check for a custom implementation
     * @return {Object} Whatever the return value of the method is.
     */
    var _checkForMethod = function _checkForMethod(methodname, fn) {
        return function () {
            var length = arguments.length;
            if (length === 0) {
                return fn();
            }
            var obj = arguments[length - 1];
            return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, _slice(arguments, 0, length - 1));
        };
    };

    /**
     * Optimized internal one-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curry1 = function _curry1(fn) {
        return function f1(a) {
            if (arguments.length === 0 || _isPlaceholder(a)) {
                return f1;
            } else {
                return fn.apply(this, arguments);
            }
        };
    };

    /**
     * Optimized internal two-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curry2 = function _curry2(fn) {
        return function f2(a, b) {
            switch (arguments.length) {
            case 0:
                return f2;
            case 1:
                return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
                    return fn(a, _b);
                });
            default:
                return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
                    return fn(_a, b);
                }) : _isPlaceholder(b) ? _curry1(function (_b) {
                    return fn(a, _b);
                }) : fn(a, b);
            }
        };
    };

    /**
     * Optimized internal three-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curry3 = function _curry3(fn) {
        return function f3(a, b, c) {
            switch (arguments.length) {
            case 0:
                return f3;
            case 1:
                return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
                    return fn(a, _b, _c);
                });
            case 2:
                return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
                    return fn(_a, b, _c);
                }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
                    return fn(a, _b, _c);
                }) : _curry1(function (_c) {
                    return fn(a, b, _c);
                });
            default:
                return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
                    return fn(_a, _b, c);
                }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
                    return fn(_a, b, _c);
                }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
                    return fn(a, _b, _c);
                }) : _isPlaceholder(a) ? _curry1(function (_a) {
                    return fn(_a, b, c);
                }) : _isPlaceholder(b) ? _curry1(function (_b) {
                    return fn(a, _b, c);
                }) : _isPlaceholder(c) ? _curry1(function (_c) {
                    return fn(a, b, _c);
                }) : fn(a, b, c);
            }
        };
    };

    /**
     * Internal curryN function.
     *
     * @private
     * @category Function
     * @param {Number} length The arity of the curried function.
     * @param {Array} received An array of arguments received thus far.
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curryN = function _curryN(length, received, fn) {
        return function () {
            var combined = [];
            var argsIdx = 0;
            var left = length;
            var combinedIdx = 0;
            while (combinedIdx < received.length || argsIdx < arguments.length) {
                var result;
                if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
                    result = received[combinedIdx];
                } else {
                    result = arguments[argsIdx];
                    argsIdx += 1;
                }
                combined[combinedIdx] = result;
                if (!_isPlaceholder(result)) {
                    left -= 1;
                }
                combinedIdx += 1;
            }
            return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
        };
    };

    /**
     * Returns a function that dispatches with different strategies based on the
     * object in list position (last argument). If it is an array, executes [fn].
     * Otherwise, if it has a function with [methodname], it will execute that
     * function (functor case). Otherwise, if it is a transformer, uses transducer
     * [xf] to return a new transformer (transducer case). Otherwise, it will
     * default to executing [fn].
     *
     * @private
     * @param {String} methodname property to check for a custom implementation
     * @param {Function} xf transducer to initialize if object is transformer
     * @param {Function} fn default ramda implementation
     * @return {Function} A function that dispatches on object in list position
     */
    var _dispatchable = function _dispatchable(methodname, xf, fn) {
        return function () {
            var length = arguments.length;
            if (length === 0) {
                return fn();
            }
            var obj = arguments[length - 1];
            if (!_isArray(obj)) {
                var args = _slice(arguments, 0, length - 1);
                if (typeof obj[methodname] === 'function') {
                    return obj[methodname].apply(obj, args);
                }
                if (_isTransformer(obj)) {
                    var transducer = xf.apply(null, args);
                    return transducer(obj);
                }
            }
            return fn.apply(this, arguments);
        };
    };

    var _dropLastWhile = function dropLastWhile(pred, list) {
        var idx = list.length - 1;
        while (idx >= 0 && pred(list[idx])) {
            idx -= 1;
        }
        return _slice(list, 0, idx + 1);
    };

    var _xall = function () {
        function XAll(f, xf) {
            this.xf = xf;
            this.f = f;
            this.all = true;
        }
        XAll.prototype['@@transducer/init'] = _xfBase.init;
        XAll.prototype['@@transducer/result'] = function (result) {
            if (this.all) {
                result = this.xf['@@transducer/step'](result, true);
            }
            return this.xf['@@transducer/result'](result);
        };
        XAll.prototype['@@transducer/step'] = function (result, input) {
            if (!this.f(input)) {
                this.all = false;
                result = _reduced(this.xf['@@transducer/step'](result, false));
            }
            return result;
        };
        return _curry2(function _xall(f, xf) {
            return new XAll(f, xf);
        });
    }();

    var _xany = function () {
        function XAny(f, xf) {
            this.xf = xf;
            this.f = f;
            this.any = false;
        }
        XAny.prototype['@@transducer/init'] = _xfBase.init;
        XAny.prototype['@@transducer/result'] = function (result) {
            if (!this.any) {
                result = this.xf['@@transducer/step'](result, false);
            }
            return this.xf['@@transducer/result'](result);
        };
        XAny.prototype['@@transducer/step'] = function (result, input) {
            if (this.f(input)) {
                this.any = true;
                result = _reduced(this.xf['@@transducer/step'](result, true));
            }
            return result;
        };
        return _curry2(function _xany(f, xf) {
            return new XAny(f, xf);
        });
    }();

    var _xaperture = function () {
        function XAperture(n, xf) {
            this.xf = xf;
            this.pos = 0;
            this.full = false;
            this.acc = new Array(n);
        }
        XAperture.prototype['@@transducer/init'] = _xfBase.init;
        XAperture.prototype['@@transducer/result'] = function (result) {
            this.acc = null;
            return this.xf['@@transducer/result'](result);
        };
        XAperture.prototype['@@transducer/step'] = function (result, input) {
            this.store(input);
            return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;
        };
        XAperture.prototype.store = function (input) {
            this.acc[this.pos] = input;
            this.pos += 1;
            if (this.pos === this.acc.length) {
                this.pos = 0;
                this.full = true;
            }
        };
        XAperture.prototype.getCopy = function () {
            return _concat(_slice(this.acc, this.pos), _slice(this.acc, 0, this.pos));
        };
        return _curry2(function _xaperture(n, xf) {
            return new XAperture(n, xf);
        });
    }();

    var _xdrop = function () {
        function XDrop(n, xf) {
            this.xf = xf;
            this.n = n;
        }
        XDrop.prototype['@@transducer/init'] = _xfBase.init;
        XDrop.prototype['@@transducer/result'] = _xfBase.result;
        XDrop.prototype['@@transducer/step'] = function (result, input) {
            if (this.n > 0) {
                this.n -= 1;
                return result;
            }
            return this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdrop(n, xf) {
            return new XDrop(n, xf);
        });
    }();

    var _xdropLast = function () {
        function XDropLast(n, xf) {
            this.xf = xf;
            this.pos = 0;
            this.full = false;
            this.acc = new Array(n);
        }
        XDropLast.prototype['@@transducer/init'] = _xfBase.init;
        XDropLast.prototype['@@transducer/result'] = function (result) {
            this.acc = null;
            return this.xf['@@transducer/result'](result);
        };
        XDropLast.prototype['@@transducer/step'] = function (result, input) {
            if (this.full) {
                result = this.xf['@@transducer/step'](result, this.acc[this.pos]);
            }
            this.store(input);
            return result;
        };
        XDropLast.prototype.store = function (input) {
            this.acc[this.pos] = input;
            this.pos += 1;
            if (this.pos === this.acc.length) {
                this.pos = 0;
                this.full = true;
            }
        };
        return _curry2(function _xdropLast(n, xf) {
            return new XDropLast(n, xf);
        });
    }();

    var _xdropRepeatsWith = function () {
        function XDropRepeatsWith(pred, xf) {
            this.xf = xf;
            this.pred = pred;
            this.lastValue = undefined;
            this.seenFirstValue = false;
        }
        XDropRepeatsWith.prototype['@@transducer/init'] = function () {
            return this.xf['@@transducer/init']();
        };
        XDropRepeatsWith.prototype['@@transducer/result'] = function (result) {
            return this.xf['@@transducer/result'](result);
        };
        XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
            var sameAsLast = false;
            if (!this.seenFirstValue) {
                this.seenFirstValue = true;
            } else if (this.pred(this.lastValue, input)) {
                sameAsLast = true;
            }
            this.lastValue = input;
            return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdropRepeatsWith(pred, xf) {
            return new XDropRepeatsWith(pred, xf);
        });
    }();

    var _xdropWhile = function () {
        function XDropWhile(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
        XDropWhile.prototype['@@transducer/result'] = _xfBase.result;
        XDropWhile.prototype['@@transducer/step'] = function (result, input) {
            if (this.f) {
                if (this.f(input)) {
                    return result;
                }
                this.f = null;
            }
            return this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdropWhile(f, xf) {
            return new XDropWhile(f, xf);
        });
    }();

    var _xfilter = function () {
        function XFilter(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XFilter.prototype['@@transducer/init'] = _xfBase.init;
        XFilter.prototype['@@transducer/result'] = _xfBase.result;
        XFilter.prototype['@@transducer/step'] = function (result, input) {
            return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
        };
        return _curry2(function _xfilter(f, xf) {
            return new XFilter(f, xf);
        });
    }();

    var _xfind = function () {
        function XFind(f, xf) {
            this.xf = xf;
            this.f = f;
            this.found = false;
        }
        XFind.prototype['@@transducer/init'] = _xfBase.init;
        XFind.prototype['@@transducer/result'] = function (result) {
            if (!this.found) {
                result = this.xf['@@transducer/step'](result, void 0);
            }
            return this.xf['@@transducer/result'](result);
        };
        XFind.prototype['@@transducer/step'] = function (result, input) {
            if (this.f(input)) {
                this.found = true;
                result = _reduced(this.xf['@@transducer/step'](result, input));
            }
            return result;
        };
        return _curry2(function _xfind(f, xf) {
            return new XFind(f, xf);
        });
    }();

    var _xfindIndex = function () {
        function XFindIndex(f, xf) {
            this.xf = xf;
            this.f = f;
            this.idx = -1;
            this.found = false;
        }
        XFindIndex.prototype['@@transducer/init'] = _xfBase.init;
        XFindIndex.prototype['@@transducer/result'] = function (result) {
            if (!this.found) {
                result = this.xf['@@transducer/step'](result, -1);
            }
            return this.xf['@@transducer/result'](result);
        };
        XFindIndex.prototype['@@transducer/step'] = function (result, input) {
            this.idx += 1;
            if (this.f(input)) {
                this.found = true;
                result = _reduced(this.xf['@@transducer/step'](result, this.idx));
            }
            return result;
        };
        return _curry2(function _xfindIndex(f, xf) {
            return new XFindIndex(f, xf);
        });
    }();

    var _xfindLast = function () {
        function XFindLast(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XFindLast.prototype['@@transducer/init'] = _xfBase.init;
        XFindLast.prototype['@@transducer/result'] = function (result) {
            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
        };
        XFindLast.prototype['@@transducer/step'] = function (result, input) {
            if (this.f(input)) {
                this.last = input;
            }
            return result;
        };
        return _curry2(function _xfindLast(f, xf) {
            return new XFindLast(f, xf);
        });
    }();

    var _xfindLastIndex = function () {
        function XFindLastIndex(f, xf) {
            this.xf = xf;
            this.f = f;
            this.idx = -1;
            this.lastIdx = -1;
        }
        XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;
        XFindLastIndex.prototype['@@transducer/result'] = function (result) {
            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
        };
        XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
            this.idx += 1;
            if (this.f(input)) {
                this.lastIdx = this.idx;
            }
            return result;
        };
        return _curry2(function _xfindLastIndex(f, xf) {
            return new XFindLastIndex(f, xf);
        });
    }();

    var _xmap = function () {
        function XMap(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XMap.prototype['@@transducer/init'] = _xfBase.init;
        XMap.prototype['@@transducer/result'] = _xfBase.result;
        XMap.prototype['@@transducer/step'] = function (result, input) {
            return this.xf['@@transducer/step'](result, this.f(input));
        };
        return _curry2(function _xmap(f, xf) {
            return new XMap(f, xf);
        });
    }();

    var _xtake = function () {
        function XTake(n, xf) {
            this.xf = xf;
            this.n = n;
        }
        XTake.prototype['@@transducer/init'] = _xfBase.init;
        XTake.prototype['@@transducer/result'] = _xfBase.result;
        XTake.prototype['@@transducer/step'] = function (result, input) {
            if (this.n === 0) {
                return _reduced(result);
            } else {
                this.n -= 1;
                return this.xf['@@transducer/step'](result, input);
            }
        };
        return _curry2(function _xtake(n, xf) {
            return new XTake(n, xf);
        });
    }();

    var _xtakeWhile = function () {
        function XTakeWhile(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
        XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;
        XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
            return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
        };
        return _curry2(function _xtakeWhile(f, xf) {
            return new XTakeWhile(f, xf);
        });
    }();

    /**
     * Adds two values.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a
     * @param {Number} b
     * @return {Number}
     * @see R.subtract
     * @example
     *
     *      R.add(2, 3);       //=>  5
     *      R.add(7)(10);      //=> 17
     */
    var add = _curry2(function add(a, b) {
        return Number(a) + Number(b);
    });

    /**
     * Applies a function to the value at the given index of an array, returning a
     * new copy of the array with the element at the given index replaced with the
     * result of the function application.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig (a -> a) -> Number -> [a] -> [a]
     * @param {Function} fn The function to apply.
     * @param {Number} idx The index.
     * @param {Array|Arguments} list An array-like object whose value
     *        at the supplied index will be replaced.
     * @return {Array} A copy of the supplied array-like object with
     *         the element at index `idx` replaced with the value
     *         returned by applying `fn` to the existing element.
     * @see R.update
     * @example
     *
     *      R.adjust(R.add(10), 1, [0, 1, 2]);     //=> [0, 11, 2]
     *      R.adjust(R.add(10))(1)([0, 1, 2]);     //=> [0, 11, 2]
     */
    var adjust = _curry3(function adjust(fn, idx, list) {
        if (idx >= list.length || idx < -list.length) {
            return list;
        }
        var start = idx < 0 ? list.length : 0;
        var _idx = start + idx;
        var _list = _concat(list);
        _list[_idx] = fn(list[_idx]);
        return _list;
    });

    /**
     * Returns `true` if all elements of the list match the predicate, `false` if
     * there are any that don't.
     *
     * Dispatches to the `all` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> Boolean
     * @param {Function} fn The predicate function.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
     *         otherwise.
     * @see R.any, R.none, R.transduce
     * @example
     *
     *      var lessThan2 = R.flip(R.lt)(2);
     *      var lessThan3 = R.flip(R.lt)(3);
     *      R.all(lessThan2)([1, 2]); //=> false
     *      R.all(lessThan3)([1, 2]); //=> true
     */
    var all = _curry2(_dispatchable('all', _xall, function all(fn, list) {
        var idx = 0;
        while (idx < list.length) {
            if (!fn(list[idx])) {
                return false;
            }
            idx += 1;
        }
        return true;
    }));

    /**
     * Returns a function that always returns the given value. Note that for
     * non-primitives the value returned is a reference to the original value.
     *
     * This function is known as `const`, `constant`, or `K` (for K combinator) in
     * other languages and libraries.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig a -> (* -> a)
     * @param {*} val The value to wrap in a function
     * @return {Function} A Function :: * -> val.
     * @example
     *
     *      var t = R.always('Tee');
     *      t(); //=> 'Tee'
     */
    var always = _curry1(function always(val) {
        return function () {
            return val;
        };
    });

    /**
     * Returns `true` if both arguments are `true`; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Logic
     * @sig * -> * -> *
     * @param {Boolean} a A boolean value
     * @param {Boolean} b A boolean value
     * @return {Boolean} `true` if both arguments are `true`, `false` otherwise
     * @see R.both
     * @example
     *
     *      R.and(true, true); //=> true
     *      R.and(true, false); //=> false
     *      R.and(false, true); //=> false
     *      R.and(false, false); //=> false
     */
    var and = _curry2(function and(a, b) {
        return a && b;
    });

    /**
     * Returns `true` if at least one of elements of the list match the predicate,
     * `false` otherwise.
     *
     * Dispatches to the `any` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> Boolean
     * @param {Function} fn The predicate function.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
     *         otherwise.
     * @see R.all, R.none, R.transduce
     * @example
     *
     *      var lessThan0 = R.flip(R.lt)(0);
     *      var lessThan2 = R.flip(R.lt)(2);
     *      R.any(lessThan0)([1, 2]); //=> false
     *      R.any(lessThan2)([1, 2]); //=> true
     */
    var any = _curry2(_dispatchable('any', _xany, function any(fn, list) {
        var idx = 0;
        while (idx < list.length) {
            if (fn(list[idx])) {
                return true;
            }
            idx += 1;
        }
        return false;
    }));

    /**
     * Returns a new list, composed of n-tuples of consecutive elements If `n` is
     * greater than the length of the list, an empty list is returned.
     *
     * Dispatches to the `aperture` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category List
     * @sig Number -> [a] -> [[a]]
     * @param {Number} n The size of the tuples to create
     * @param {Array} list The list to split into `n`-tuples
     * @return {Array} The new list.
     * @see R.transduce
     * @example
     *
     *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
     *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
     *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
     */
    var aperture = _curry2(_dispatchable('aperture', _xaperture, _aperture));

    /**
     * Returns a new list containing the contents of the given list, followed by
     * the given element.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> [a]
     * @param {*} el The element to add to the end of the new list.
     * @param {Array} list The list whose contents will be added to the beginning of the output
     *        list.
     * @return {Array} A new list containing the contents of the old list followed by `el`.
     * @see R.prepend
     * @example
     *
     *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
     *      R.append('tests', []); //=> ['tests']
     *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
     */
    var append = _curry2(function append(el, list) {
        return _concat(list, [el]);
    });

    /**
     * Applies function `fn` to the argument list `args`. This is useful for
     * creating a fixed-arity function from a variadic function. `fn` should be a
     * bound function if context is significant.
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Function
     * @sig (*... -> a) -> [*] -> a
     * @param {Function} fn
     * @param {Array} args
     * @return {*}
     * @see R.call, R.unapply
     * @example
     *
     *      var nums = [1, 2, 3, -99, 42, 6, 7];
     *      R.apply(Math.max, nums); //=> 42
     */
    var apply = _curry2(function apply(fn, args) {
        return fn.apply(this, args);
    });

    /**
     * Makes a shallow clone of an object, setting or overriding the specified
     * property with the given value. Note that this copies and flattens prototype
     * properties onto the new object as well. All non-primitive properties are
     * copied by reference.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @sig String -> a -> {k: v} -> {k: v}
     * @param {String} prop the property name to set
     * @param {*} val the new value
     * @param {Object} obj the object to clone
     * @return {Object} a new object similar to the original except for the specified property.
     * @see R.dissoc
     * @example
     *
     *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
     */
    var assoc = _curry3(function assoc(prop, val, obj) {
        var result = {};
        for (var p in obj) {
            result[p] = obj[p];
        }
        result[prop] = val;
        return result;
    });

    /**
     * Makes a shallow clone of an object, setting or overriding the nodes required
     * to create the given path, and placing the specific value at the tail end of
     * that path. Note that this copies and flattens prototype properties onto the
     * new object as well. All non-primitive properties are copied by reference.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @sig [String] -> a -> {k: v} -> {k: v}
     * @param {Array} path the path to set
     * @param {*} val the new value
     * @param {Object} obj the object to clone
     * @return {Object} a new object similar to the original except along the specified path.
     * @see R.dissocPath
     * @example
     *
     *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
     */
    var assocPath = _curry3(function assocPath(path, val, obj) {
        switch (path.length) {
        case 0:
            return val;
        case 1:
            return assoc(path[0], val, obj);
        default:
            return assoc(path[0], assocPath(_slice(path, 1), val, Object(obj[path[0]])), obj);
        }
    });

    /**
     * Creates a function that is bound to a context.
     * Note: `R.bind` does not provide the additional argument-binding capabilities of
     * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category Function
     * @category Object
     * @sig (* -> *) -> {*} -> (* -> *)
     * @param {Function} fn The function to bind to context
     * @param {Object} thisObj The context to bind `fn` to
     * @return {Function} A function that will execute in the context of `thisObj`.
     * @see R.partial
     */
    var bind = _curry2(function bind(fn, thisObj) {
        return _arity(fn.length, function () {
            return fn.apply(thisObj, arguments);
        });
    });

    /**
     * Restricts a number to be within a range.
     *
     * Also works for other ordered types such as Strings and Dates.
     *
     * @func
     * @memberOf R
     * @since v0.20.0
     * @category Relation
     * @sig Ord a => a -> a -> a -> a
     * @param {Number} minimum number
     * @param {Number} maximum number
     * @param {Number} value to be clamped
     * @return {Number} Returns the clamped value
     * @example
     *
     *      R.clamp(1, 10, -1) // => 1
     *      R.clamp(1, 10, 11) // => 10
     *      R.clamp(1, 10, 4)  // => 4
     */
    var clamp = _curry3(function clamp(min, max, value) {
        if (min > max) {
            throw new Error('min must not be greater than max in clamp(min, max, value)');
        }
        return value < min ? min : value > max ? max : value;
    });

    /**
     * Makes a comparator function out of a function that reports whether the first
     * element is less than the second.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a, b -> Boolean) -> (a, b -> Number)
     * @param {Function} pred A predicate function of arity two.
     * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`.
     * @example
     *
     *      var cmp = R.comparator((a, b) => a.age < b.age);
     *      var people = [
     *        // ...
     *      ];
     *      R.sort(cmp, people);
     */
    var comparator = _curry1(function comparator(pred) {
        return function (a, b) {
            return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
        };
    });

    /**
     * Returns a curried equivalent of the provided function, with the specified
     * arity. The curried function has two unusual capabilities. First, its
     * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
     * following are equivalent:
     *
     *   - `g(1)(2)(3)`
     *   - `g(1)(2, 3)`
     *   - `g(1, 2)(3)`
     *   - `g(1, 2, 3)`
     *
     * Secondly, the special placeholder value `R.__` may be used to specify
     * "gaps", allowing partial application of any combination of arguments,
     * regardless of their positions. If `g` is as above and `_` is `R.__`, the
     * following are equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @func
     * @memberOf R
     * @since v0.5.0
     * @category Function
     * @sig Number -> (* -> a) -> (* -> a)
     * @param {Number} length The arity for the returned function.
     * @param {Function} fn The function to curry.
     * @return {Function} A new, curried function.
     * @see R.curry
     * @example
     *
     *      var sumArgs = (...args) => R.sum(args);
     *
     *      var curriedAddFourNumbers = R.curryN(4, sumArgs);
     *      var f = curriedAddFourNumbers(1, 2);
     *      var g = f(3);
     *      g(4); //=> 10
     */
    var curryN = _curry2(function curryN(length, fn) {
        if (length === 1) {
            return _curry1(fn);
        }
        return _arity(length, _curryN(length, [], fn));
    });

    /**
     * Decrements its argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Math
     * @sig Number -> Number
     * @param {Number} n
     * @return {Number}
     * @see R.inc
     * @example
     *
     *      R.dec(42); //=> 41
     */
    var dec = add(-1);

    /**
     * Returns the second argument if it is not `null`, `undefined` or `NaN`
     * otherwise the first argument is returned.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Logic
     * @sig a -> b -> a | b
     * @param {a} val The default value.
     * @param {b} val The value to return if it is not null or undefined
     * @return {*} The the second value or the default value
     * @example
     *
     *      var defaultTo42 = R.defaultTo(42);
     *
     *      defaultTo42(null);  //=> 42
     *      defaultTo42(undefined);  //=> 42
     *      defaultTo42('Ramda');  //=> 'Ramda'
     *      defaultTo42(parseInt('string')); //=> 42
     */
    var defaultTo = _curry2(function defaultTo(d, v) {
        return v == null || v !== v ? d : v;
    });

    /**
     * Finds the set (i.e. no duplicates) of all elements in the first list not
     * contained in the second list. Duplication is determined according to the
     * value returned by applying the supplied predicate to two list elements.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The elements in `list1` that are not in `list2`.
     * @see R.difference
     * @example
     *
     *      var cmp = (x, y) => x.a === y.a;
     *      var l1 = [{a: 1}, {a: 2}, {a: 3}];
     *      var l2 = [{a: 3}, {a: 4}];
     *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
     */
    var differenceWith = _curry3(function differenceWith(pred, first, second) {
        var out = [];
        var idx = 0;
        var firstLen = first.length;
        while (idx < firstLen) {
            if (!_containsWith(pred, first[idx], second) && !_containsWith(pred, first[idx], out)) {
                out.push(first[idx]);
            }
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a new object that does not contain a `prop` property.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Object
     * @sig String -> {k: v} -> {k: v}
     * @param {String} prop the name of the property to dissociate
     * @param {Object} obj the object to clone
     * @return {Object} a new object similar to the original but without the specified property
     * @see R.assoc
     * @example
     *
     *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
     */
    var dissoc = _curry2(function dissoc(prop, obj) {
        var result = {};
        for (var p in obj) {
            if (p !== prop) {
                result[p] = obj[p];
            }
        }
        return result;
    });

    /**
     * Makes a shallow clone of an object, omitting the property at the given path.
     * Note that this copies and flattens prototype properties onto the new object
     * as well. All non-primitive properties are copied by reference.
     *
     * @func
     * @memberOf R
     * @since v0.11.0
     * @category Object
     * @sig [String] -> {k: v} -> {k: v}
     * @param {Array} path the path to set
     * @param {Object} obj the object to clone
     * @return {Object} a new object without the property at path
     * @see R.assocPath
     * @example
     *
     *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
     */
    var dissocPath = _curry2(function dissocPath(path, obj) {
        switch (path.length) {
        case 0:
            return obj;
        case 1:
            return dissoc(path[0], obj);
        default:
            var head = path[0];
            var tail = _slice(path, 1);
            return obj[head] == null ? obj : assoc(head, dissocPath(tail, obj[head]), obj);
        }
    });

    /**
     * Divides two numbers. Equivalent to `a / b`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The first value.
     * @param {Number} b The second value.
     * @return {Number} The result of `a / b`.
     * @see R.multiply
     * @example
     *
     *      R.divide(71, 100); //=> 0.71
     *
     *      var half = R.divide(R.__, 2);
     *      half(42); //=> 21
     *
     *      var reciprocal = R.divide(1);
     *      reciprocal(4);   //=> 0.25
     */
    var divide = _curry2(function divide(a, b) {
        return a / b;
    });

    /**
     * Returns a new list containing the last `n` elements of a given list, passing
     * each value to the supplied predicate function, skipping elements while the
     * predicate function returns `true`. The predicate function is passed one
     * argument: *(value)*.
     *
     * Dispatches to the `dropWhile` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.takeWhile, R.transduce, R.addIndex
     * @example
     *
     *      var lteTwo = x => x <= 2;
     *
     *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
     */
    var dropWhile = _curry2(_dispatchable('dropWhile', _xdropWhile, function dropWhile(pred, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len && pred(list[idx])) {
            idx += 1;
        }
        return _slice(list, idx);
    }));

    /**
     * Returns the empty value of its argument's type. Ramda defines the empty
     * value of Array (`[]`), Object (`{}`), String (`''`), and Arguments. Other
     * types are supported if they define `<Type>.empty` and/or
     * `<Type>.prototype.empty`.
     *
     * Dispatches to the `empty` method of the first argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Function
     * @sig a -> a
     * @param {*} x
     * @return {*}
     * @example
     *
     *      R.empty(Just(42));      //=> Nothing()
     *      R.empty([1, 2, 3]);     //=> []
     *      R.empty('unicorns');    //=> ''
     *      R.empty({x: 1, y: 2});  //=> {}
     */
    // else
    var empty = _curry1(function empty(x) {
        return x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? '' : _isObject(x) ? {} : _isArguments(x) ? function () {
            return arguments;
        }() : // else
        void 0;
    });

    /**
     * Creates a new object by recursively evolving a shallow copy of `object`,
     * according to the `transformation` functions. All non-primitive properties
     * are copied by reference.
     *
     * A `transformation` function will not be invoked if its corresponding key
     * does not exist in the evolved object.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Object
     * @sig {k: (v -> v)} -> {k: v} -> {k: v}
     * @param {Object} transformations The object specifying transformation functions to apply
     *        to the object.
     * @param {Object} object The object to be transformed.
     * @return {Object} The transformed object.
     * @example
     *
     *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
     *      var transformations = {
     *        firstName: R.trim,
     *        lastName: R.trim, // Will not get invoked.
     *        data: {elapsed: R.add(1), remaining: R.add(-1)}
     *      };
     *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
     */
    var evolve = _curry2(function evolve(transformations, object) {
        var result = {};
        var transformation, key, type;
        for (key in object) {
            transformation = transformations[key];
            type = typeof transformation;
            result[key] = type === 'function' ? transformation(object[key]) : type === 'object' ? evolve(transformations[key], object[key]) : object[key];
        }
        return result;
    });

    /**
     * Returns the first element of the list which matches the predicate, or
     * `undefined` if no element matches.
     *
     * Dispatches to the `find` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> a | undefined
     * @param {Function} fn The predicate function used to determine if the element is the
     *        desired one.
     * @param {Array} list The array to consider.
     * @return {Object} The element found, or `undefined`.
     * @see R.transduce
     * @example
     *
     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
     *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
     *      R.find(R.propEq('a', 4))(xs); //=> undefined
     */
    var find = _curry2(_dispatchable('find', _xfind, function find(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            if (fn(list[idx])) {
                return list[idx];
            }
            idx += 1;
        }
    }));

    /**
     * Returns the index of the first element of the list which matches the
     * predicate, or `-1` if no element matches.
     *
     * Dispatches to the `findIndex` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> Boolean) -> [a] -> Number
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Number} The index of the element found, or `-1`.
     * @see R.transduce
     * @example
     *
     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
     *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
     *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
     */
    var findIndex = _curry2(_dispatchable('findIndex', _xfindIndex, function findIndex(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            if (fn(list[idx])) {
                return idx;
            }
            idx += 1;
        }
        return -1;
    }));

    /**
     * Returns the last element of the list which matches the predicate, or
     * `undefined` if no element matches.
     *
     * Dispatches to the `findLast` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> Boolean) -> [a] -> a | undefined
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Object} The element found, or `undefined`.
     * @see R.transduce
     * @example
     *
     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
     *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
     *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
     */
    var findLast = _curry2(_dispatchable('findLast', _xfindLast, function findLast(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
            if (fn(list[idx])) {
                return list[idx];
            }
            idx -= 1;
        }
    }));

    /**
     * Returns the index of the last element of the list which matches the
     * predicate, or `-1` if no element matches.
     *
     * Dispatches to the `findLastIndex` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> Boolean) -> [a] -> Number
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Number} The index of the element found, or `-1`.
     * @see R.transduce
     * @example
     *
     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
     *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
     *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
     */
    var findLastIndex = _curry2(_dispatchable('findLastIndex', _xfindLastIndex, function findLastIndex(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
            if (fn(list[idx])) {
                return idx;
            }
            idx -= 1;
        }
        return -1;
    }));

    /**
     * Iterate over an input `list`, calling a provided function `fn` for each
     * element in the list.
     *
     * `fn` receives one argument: *(value)*.
     *
     * Note: `R.forEach` does not skip deleted or unassigned indices (sparse
     * arrays), unlike the native `Array.prototype.forEach` method. For more
     * details on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
     *
     * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns
     * the original array. In some libraries this function is named `each`.
     *
     * Dispatches to the `forEach` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> *) -> [a] -> [a]
     * @param {Function} fn The function to invoke. Receives one argument, `value`.
     * @param {Array} list The list to iterate over.
     * @return {Array} The original list.
     * @see R.addIndex
     * @example
     *
     *      var printXPlusFive = x => console.log(x + 5);
     *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
     *      //-> 6
     *      //-> 7
     *      //-> 8
     */
    var forEach = _curry2(_checkForMethod('forEach', function forEach(fn, list) {
        var len = list.length;
        var idx = 0;
        while (idx < len) {
            fn(list[idx]);
            idx += 1;
        }
        return list;
    }));

    /**
     * Creates a new object out of a list key-value pairs.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig [[k,v]] -> {k: v}
     * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
     * @return {Object} The object made by pairing up `keys` and `values`.
     * @see R.toPairs, R.pair
     * @example
     *
     *      R.fromPairs([['a', 1], ['b', 2],  ['c', 3]]); //=> {a: 1, b: 2, c: 3}
     */
    var fromPairs = _curry1(function fromPairs(pairs) {
        var idx = 0;
        var len = pairs.length;
        var out = {};
        while (idx < len) {
            if (_isArray(pairs[idx]) && pairs[idx].length) {
                out[pairs[idx][0]] = pairs[idx][1];
            }
            idx += 1;
        }
        return out;
    });

    /**
     * Takes a list and returns a list of lists where each sublist's elements are
     * all "equal" according to the provided equality function.
     *
     * @func
     * @memberOf R
     * @since v0.21.0
     * @category List
     * @sig (a, a -> Boolean) -> [a] -> [[a]]
     * @param {Function} fn Function for determining whether two given (adjacent)
     *        elements should be in the same group
     * @param {Array} list The array to group. Also accepts a string, which will be
     *        treated as a list of characters.
     * @return {List} A list that contains sublists of equal elements,
     *         whose concatenations is equal to the original list.
     * @example
     *
     *    groupWith(R.equals, [0, 1, 1, 2, 3, 5, 8, 13, 21])
     *    // [[0], [1, 1], [2, 3, 5, 8, 13, 21]]
     *
     *    groupWith((a, b) => a % 2 === b % 2, [0, 1, 1, 2, 3, 5, 8, 13, 21])
     *    // [[0], [1, 1], [2], [3, 5], [8], [13, 21]]
     *
     *    R.groupWith(R.eqBy(isVowel), 'aestiou')
     *    // ['ae', 'st', 'iou']
     */
    var groupWith = _curry2(function (fn, list) {
        var res = [];
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            var nextidx = idx + 1;
            while (nextidx < len && fn(list[idx], list[nextidx])) {
                nextidx += 1;
            }
            res.push(list.slice(idx, nextidx));
            idx = nextidx;
        }
        return res;
    });

    /**
     * Returns `true` if the first argument is greater than the second; `false`
     * otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @see R.lt
     * @example
     *
     *      R.gt(2, 1); //=> true
     *      R.gt(2, 2); //=> false
     *      R.gt(2, 3); //=> false
     *      R.gt('a', 'z'); //=> false
     *      R.gt('z', 'a'); //=> true
     */
    var gt = _curry2(function gt(a, b) {
        return a > b;
    });

    /**
     * Returns `true` if the first argument is greater than or equal to the second;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {Number} a
     * @param {Number} b
     * @return {Boolean}
     * @see R.lte
     * @example
     *
     *      R.gte(2, 1); //=> true
     *      R.gte(2, 2); //=> true
     *      R.gte(2, 3); //=> false
     *      R.gte('a', 'z'); //=> false
     *      R.gte('z', 'a'); //=> true
     */
    var gte = _curry2(function gte(a, b) {
        return a >= b;
    });

    /**
     * Returns whether or not an object has an own property with the specified name
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Object
     * @sig s -> {s: x} -> Boolean
     * @param {String} prop The name of the property to check for.
     * @param {Object} obj The object to query.
     * @return {Boolean} Whether the property exists.
     * @example
     *
     *      var hasName = R.has('name');
     *      hasName({name: 'alice'});   //=> true
     *      hasName({name: 'bob'});     //=> true
     *      hasName({});                //=> false
     *
     *      var point = {x: 0, y: 0};
     *      var pointHas = R.has(R.__, point);
     *      pointHas('x');  //=> true
     *      pointHas('y');  //=> true
     *      pointHas('z');  //=> false
     */
    var has = _curry2(_has);

    /**
     * Returns whether or not an object or its prototype chain has a property with
     * the specified name
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Object
     * @sig s -> {s: x} -> Boolean
     * @param {String} prop The name of the property to check for.
     * @param {Object} obj The object to query.
     * @return {Boolean} Whether the property exists.
     * @example
     *
     *      function Rectangle(width, height) {
     *        this.width = width;
     *        this.height = height;
     *      }
     *      Rectangle.prototype.area = function() {
     *        return this.width * this.height;
     *      };
     *
     *      var square = new Rectangle(2, 2);
     *      R.hasIn('width', square);  //=> true
     *      R.hasIn('area', square);  //=> true
     */
    var hasIn = _curry2(function hasIn(prop, obj) {
        return prop in obj;
    });

    /**
     * Returns true if its arguments are identical, false otherwise. Values are
     * identical if they reference the same memory. `NaN` is identical to `NaN`;
     * `0` and `-0` are not identical.
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category Relation
     * @sig a -> a -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @example
     *
     *      var o = {};
     *      R.identical(o, o); //=> true
     *      R.identical(1, 1); //=> true
     *      R.identical(1, '1'); //=> false
     *      R.identical([], []); //=> false
     *      R.identical(0, -0); //=> false
     *      R.identical(NaN, NaN); //=> true
     */
    // SameValue algorithm
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Step 6.a: NaN == NaN
    var identical = _curry2(function identical(a, b) {
        // SameValue algorithm
        if (a === b) {
            // Steps 1-5, 7-10
            // Steps 6.b-6.e: +0 != -0
            return a !== 0 || 1 / a === 1 / b;
        } else {
            // Step 6.a: NaN == NaN
            return a !== a && b !== b;
        }
    });

    /**
     * A function that does nothing but return the parameter supplied to it. Good
     * as a default or placeholder function.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig a -> a
     * @param {*} x The value to return.
     * @return {*} The input value, `x`.
     * @example
     *
     *      R.identity(1); //=> 1
     *
     *      var obj = {};
     *      R.identity(obj) === obj; //=> true
     */
    var identity = _curry1(_identity);

    /**
     * Creates a function that will process either the `onTrue` or the `onFalse`
     * function depending upon the result of the `condition` predicate.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Logic
     * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
     * @param {Function} condition A predicate function
     * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
     * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
     * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`
     *                    function depending upon the result of the `condition` predicate.
     * @see R.unless, R.when
     * @example
     *
     *      var incCount = R.ifElse(
     *        R.has('count'),
     *        R.over(R.lensProp('count'), R.inc),
     *        R.assoc('count', 1)
     *      );
     *      incCount({});           //=> { count: 1 }
     *      incCount({ count: 1 }); //=> { count: 2 }
     */
    var ifElse = _curry3(function ifElse(condition, onTrue, onFalse) {
        return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
            return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
        });
    });

    /**
     * Increments its argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Math
     * @sig Number -> Number
     * @param {Number} n
     * @return {Number}
     * @see R.dec
     * @example
     *
     *      R.inc(42); //=> 43
     */
    var inc = add(1);

    /**
     * Inserts the supplied element into the list, at index `index`. _Note that
     * this is not destructive_: it returns a copy of the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @since v0.2.2
     * @category List
     * @sig Number -> a -> [a] -> [a]
     * @param {Number} index The position to insert the element
     * @param {*} elt The element to insert into the Array
     * @param {Array} list The list to insert into
     * @return {Array} A new Array with `elt` inserted at `index`.
     * @example
     *
     *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
     */
    var insert = _curry3(function insert(idx, elt, list) {
        idx = idx < list.length && idx >= 0 ? idx : list.length;
        var result = _slice(list);
        result.splice(idx, 0, elt);
        return result;
    });

    /**
     * Inserts the sub-list into the list, at index `index`. _Note that this is not
     * destructive_: it returns a copy of the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category List
     * @sig Number -> [a] -> [a] -> [a]
     * @param {Number} index The position to insert the sub-list
     * @param {Array} elts The sub-list to insert into the Array
     * @param {Array} list The list to insert the sub-list into
     * @return {Array} A new Array with `elts` inserted starting at `index`.
     * @example
     *
     *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
     */
    var insertAll = _curry3(function insertAll(idx, elts, list) {
        idx = idx < list.length && idx >= 0 ? idx : list.length;
        return _concat(_concat(_slice(list, 0, idx), elts), _slice(list, idx));
    });

    /**
     * Creates a new list with the separator interposed between elements.
     *
     * Dispatches to the `intersperse` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig a -> [a] -> [a]
     * @param {*} separator The element to add to the list.
     * @param {Array} list The list to be interposed.
     * @return {Array} The new list.
     * @example
     *
     *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']
     */
    var intersperse = _curry2(_checkForMethod('intersperse', function intersperse(separator, list) {
        var out = [];
        var idx = 0;
        var length = list.length;
        while (idx < length) {
            if (idx === length - 1) {
                out.push(list[idx]);
            } else {
                out.push(list[idx], separator);
            }
            idx += 1;
        }
        return out;
    }));

    /**
     * See if an object (`val`) is an instance of the supplied constructor. This
     * function will check up the inheritance chain, if any.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Type
     * @sig (* -> {*}) -> a -> Boolean
     * @param {Object} ctor A constructor
     * @param {*} val The value to test
     * @return {Boolean}
     * @example
     *
     *      R.is(Object, {}); //=> true
     *      R.is(Number, 1); //=> true
     *      R.is(Object, 1); //=> false
     *      R.is(String, 's'); //=> true
     *      R.is(String, new String('')); //=> true
     *      R.is(Object, new String('')); //=> true
     *      R.is(Object, 's'); //=> false
     *      R.is(Number, {}); //=> false
     */
    var is = _curry2(function is(Ctor, val) {
        return val != null && val.constructor === Ctor || val instanceof Ctor;
    });

    /**
     * Tests whether or not an object is similar to an array.
     *
     * @func
     * @memberOf R
     * @since v0.5.0
     * @category Type
     * @category List
     * @sig * -> Boolean
     * @param {*} x The object to test.
     * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
     * @example
     *
     *      R.isArrayLike([]); //=> true
     *      R.isArrayLike(true); //=> false
     *      R.isArrayLike({}); //=> false
     *      R.isArrayLike({length: 10}); //=> false
     *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
     */
    var isArrayLike = _curry1(function isArrayLike(x) {
        if (_isArray(x)) {
            return true;
        }
        if (!x) {
            return false;
        }
        if (typeof x !== 'object') {
            return false;
        }
        if (x instanceof String) {
            return false;
        }
        if (x.nodeType === 1) {
            return !!x.length;
        }
        if (x.length === 0) {
            return true;
        }
        if (x.length > 0) {
            return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
        }
        return false;
    });

    /**
     * Checks if the input value is `null` or `undefined`.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Type
     * @sig * -> Boolean
     * @param {*} x The value to test.
     * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
     * @example
     *
     *      R.isNil(null); //=> true
     *      R.isNil(undefined); //=> true
     *      R.isNil(0); //=> false
     *      R.isNil([]); //=> false
     */
    var isNil = _curry1(function isNil(x) {
        return x == null;
    });

    /**
     * Returns a list containing the names of all the enumerable own properties of
     * the supplied object.
     * Note that the order of the output array is not guaranteed to be consistent
     * across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {k: v} -> [k]
     * @param {Object} obj The object to extract properties from
     * @return {Array} An array of the object's own properties.
     * @example
     *
     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
     */
    // cover IE < 9 keys issues
    // Safari bug
    var keys = function () {
        // cover IE < 9 keys issues
        var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
        var nonEnumerableProps = [
            'constructor',
            'valueOf',
            'isPrototypeOf',
            'toString',
            'propertyIsEnumerable',
            'hasOwnProperty',
            'toLocaleString'
        ];
        // Safari bug
        var hasArgsEnumBug = function () {
            'use strict';
            return arguments.propertyIsEnumerable('length');
        }();
        var contains = function contains(list, item) {
            var idx = 0;
            while (idx < list.length) {
                if (list[idx] === item) {
                    return true;
                }
                idx += 1;
            }
            return false;
        };
        return typeof Object.keys === 'function' && !hasArgsEnumBug ? _curry1(function keys(obj) {
            return Object(obj) !== obj ? [] : Object.keys(obj);
        }) : _curry1(function keys(obj) {
            if (Object(obj) !== obj) {
                return [];
            }
            var prop, nIdx;
            var ks = [];
            var checkArgsLength = hasArgsEnumBug && _isArguments(obj);
            for (prop in obj) {
                if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
                    ks[ks.length] = prop;
                }
            }
            if (hasEnumBug) {
                nIdx = nonEnumerableProps.length - 1;
                while (nIdx >= 0) {
                    prop = nonEnumerableProps[nIdx];
                    if (_has(prop, obj) && !contains(ks, prop)) {
                        ks[ks.length] = prop;
                    }
                    nIdx -= 1;
                }
            }
            return ks;
        });
    }();

    /**
     * Returns a list containing the names of all the properties of the supplied
     * object, including prototype properties.
     * Note that the order of the output array is not guaranteed to be consistent
     * across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Object
     * @sig {k: v} -> [k]
     * @param {Object} obj The object to extract properties from
     * @return {Array} An array of the object's own and prototype properties.
     * @example
     *
     *      var F = function() { this.x = 'X'; };
     *      F.prototype.y = 'Y';
     *      var f = new F();
     *      R.keysIn(f); //=> ['x', 'y']
     */
    var keysIn = _curry1(function keysIn(obj) {
        var prop;
        var ks = [];
        for (prop in obj) {
            ks[ks.length] = prop;
        }
        return ks;
    });

    /**
     * Returns the number of elements in the array by returning `list.length`.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig [a] -> Number
     * @param {Array} list The array to inspect.
     * @return {Number} The length of the array.
     * @example
     *
     *      R.length([]); //=> 0
     *      R.length([1, 2, 3]); //=> 3
     */
    var length = _curry1(function length(list) {
        return list != null && is(Number, list.length) ? list.length : NaN;
    });

    /**
     * Returns `true` if the first argument is less than the second; `false`
     * otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @see R.gt
     * @example
     *
     *      R.lt(2, 1); //=> false
     *      R.lt(2, 2); //=> false
     *      R.lt(2, 3); //=> true
     *      R.lt('a', 'z'); //=> true
     *      R.lt('z', 'a'); //=> false
     */
    var lt = _curry2(function lt(a, b) {
        return a < b;
    });

    /**
     * Returns `true` if the first argument is less than or equal to the second;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {Number} a
     * @param {Number} b
     * @return {Boolean}
     * @see R.gte
     * @example
     *
     *      R.lte(2, 1); //=> false
     *      R.lte(2, 2); //=> true
     *      R.lte(2, 3); //=> true
     *      R.lte('a', 'z'); //=> true
     *      R.lte('z', 'a'); //=> false
     */
    var lte = _curry2(function lte(a, b) {
        return a <= b;
    });

    /**
     * The mapAccum function behaves like a combination of map and reduce; it
     * applies a function to each element of a list, passing an accumulating
     * parameter from left to right, and returning a final value of this
     * accumulator together with the new list.
     *
     * The iterator function receives two arguments, *acc* and *value*, and should
     * return a tuple *[acc, value]*.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
     * @param {Function} fn The function to be called on every element of the input `list`.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.addIndex
     * @example
     *
     *      var digits = ['1', '2', '3', '4'];
     *      var appender = (a, b) => [a + b, a + b];
     *
     *      R.mapAccum(appender, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
     */
    var mapAccum = _curry3(function mapAccum(fn, acc, list) {
        var idx = 0;
        var len = list.length;
        var result = [];
        var tuple = [acc];
        while (idx < len) {
            tuple = fn(tuple[0], list[idx]);
            result[idx] = tuple[1];
            idx += 1;
        }
        return [
            tuple[0],
            result
        ];
    });

    /**
     * The mapAccumRight function behaves like a combination of map and reduce; it
     * applies a function to each element of a list, passing an accumulating
     * parameter from right to left, and returning a final value of this
     * accumulator together with the new list.
     *
     * Similar to `mapAccum`, except moves through the input list from the right to
     * the left.
     *
     * The iterator function receives two arguments, *acc* and *value*, and should
     * return a tuple *[acc, value]*.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
     * @param {Function} fn The function to be called on every element of the input `list`.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.addIndex
     * @example
     *
     *      var digits = ['1', '2', '3', '4'];
     *      var append = (a, b) => [a + b, a + b];
     *
     *      R.mapAccumRight(append, 0, digits); //=> ['04321', ['04321', '0432', '043', '04']]
     */
    var mapAccumRight = _curry3(function mapAccumRight(fn, acc, list) {
        var idx = list.length - 1;
        var result = [];
        var tuple = [acc];
        while (idx >= 0) {
            tuple = fn(tuple[0], list[idx]);
            result[idx] = tuple[1];
            idx -= 1;
        }
        return [
            tuple[0],
            result
        ];
    });

    /**
     * Tests a regular expression against a String. Note that this function will
     * return an empty array when there are no matches. This differs from
     * [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
     * which returns `null` when there are no matches.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category String
     * @sig RegExp -> String -> [String | Undefined]
     * @param {RegExp} rx A regular expression.
     * @param {String} str The string to match against
     * @return {Array} The list of matches or empty array.
     * @see R.test
     * @example
     *
     *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
     *      R.match(/a/, 'b'); //=> []
     *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
     */
    var match = _curry2(function match(rx, str) {
        return str.match(rx) || [];
    });

    /**
     * mathMod behaves like the modulo operator should mathematically, unlike the
     * `%` operator (and by extension, R.modulo). So while "-17 % 5" is -2,
     * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN
     * when the modulus is zero or negative.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} m The dividend.
     * @param {Number} p the modulus.
     * @return {Number} The result of `b mod a`.
     * @example
     *
     *      R.mathMod(-17, 5);  //=> 3
     *      R.mathMod(17, 5);   //=> 2
     *      R.mathMod(17, -5);  //=> NaN
     *      R.mathMod(17, 0);   //=> NaN
     *      R.mathMod(17.2, 5); //=> NaN
     *      R.mathMod(17, 5.3); //=> NaN
     *
     *      var clock = R.mathMod(R.__, 12);
     *      clock(15); //=> 3
     *      clock(24); //=> 0
     *
     *      var seventeenMod = R.mathMod(17);
     *      seventeenMod(3);  //=> 2
     *      seventeenMod(4);  //=> 1
     *      seventeenMod(10); //=> 7
     */
    var mathMod = _curry2(function mathMod(m, p) {
        if (!_isInteger(m)) {
            return NaN;
        }
        if (!_isInteger(p) || p < 1) {
            return NaN;
        }
        return (m % p + p) % p;
    });

    /**
     * Returns the larger of its two arguments.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> a
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.maxBy, R.min
     * @example
     *
     *      R.max(789, 123); //=> 789
     *      R.max('a', 'b'); //=> 'b'
     */
    var max = _curry2(function max(a, b) {
        return b > a ? b : a;
    });

    /**
     * Takes a function and two values, and returns whichever value produces the
     * larger result when passed to the provided function.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Relation
     * @sig Ord b => (a -> b) -> a -> a -> a
     * @param {Function} f
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.max, R.minBy
     * @example
     *
     *      //  square :: Number -> Number
     *      var square = n => n * n;
     *
     *      R.maxBy(square, -3, 2); //=> -3
     *
     *      R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); //=> -5
     *      R.reduce(R.maxBy(square), 0, []); //=> 0
     */
    var maxBy = _curry3(function maxBy(f, a, b) {
        return f(b) > f(a) ? b : a;
    });

    /**
     * Create a new object with the own properties of the first object merged with
     * the own properties of the second object. If a key exists in both objects,
     * the value from the second object will be used.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {k: v} -> {k: v} -> {k: v}
     * @param {Object} l
     * @param {Object} r
     * @return {Object}
     * @see R.mergeWith, R.mergeWithKey
     * @example
     *
     *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
     *      //=> { 'name': 'fred', 'age': 40 }
     *
     *      var resetToDefault = R.merge(R.__, {x: 0});
     *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
     */
    var merge = _curry2(function merge(l, r) {
        return _assign({}, l, r);
    });

    /**
     * Merges a list of objects together into one object.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig [{k: v}] -> {k: v}
     * @param {Array} list An array of objects
     * @return {Object} A merged object.
     * @see R.reduce
     * @example
     *
     *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
     *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
     */
    var mergeAll = _curry1(function mergeAll(list) {
        return _assign.apply(null, [{}].concat(list));
    });

    /**
     * Creates a new object with the own properties of the two provided objects. If
     * a key exists in both objects, the provided function is applied to the key
     * and the values associated with the key in each object, with the result being
     * used as the value associated with the key in the returned object. The key
     * will be excluded from the returned object if the resulting value is
     * `undefined`.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Object
     * @sig (String -> a -> a -> a) -> {a} -> {a} -> {a}
     * @param {Function} fn
     * @param {Object} l
     * @param {Object} r
     * @return {Object}
     * @see R.merge, R.mergeWith
     * @example
     *
     *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
     *      R.mergeWithKey(concatValues,
     *                     { a: true, thing: 'foo', values: [10, 20] },
     *                     { b: true, thing: 'bar', values: [15, 35] });
     *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }
     */
    var mergeWithKey = _curry3(function mergeWithKey(fn, l, r) {
        var result = {};
        var k;
        for (k in l) {
            if (_has(k, l)) {
                result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
            }
        }
        for (k in r) {
            if (_has(k, r) && !_has(k, result)) {
                result[k] = r[k];
            }
        }
        return result;
    });

    /**
     * Returns the smaller of its two arguments.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> a
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.minBy, R.max
     * @example
     *
     *      R.min(789, 123); //=> 123
     *      R.min('a', 'b'); //=> 'a'
     */
    var min = _curry2(function min(a, b) {
        return b < a ? b : a;
    });

    /**
     * Takes a function and two values, and returns whichever value produces the
     * smaller result when passed to the provided function.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Relation
     * @sig Ord b => (a -> b) -> a -> a -> a
     * @param {Function} f
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.min, R.maxBy
     * @example
     *
     *      //  square :: Number -> Number
     *      var square = n => n * n;
     *
     *      R.minBy(square, -3, 2); //=> 2
     *
     *      R.reduce(R.minBy(square), Infinity, [3, -5, 4, 1, -2]); //=> 1
     *      R.reduce(R.minBy(square), Infinity, []); //=> Infinity
     */
    var minBy = _curry3(function minBy(f, a, b) {
        return f(b) < f(a) ? b : a;
    });

    /**
     * Divides the second parameter by the first and returns the remainder. Note
     * that this function preserves the JavaScript-style behavior for modulo. For
     * mathematical modulo see `mathMod`.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The value to the divide.
     * @param {Number} b The pseudo-modulus
     * @return {Number} The result of `b % a`.
     * @see R.mathMod
     * @example
     *
     *      R.modulo(17, 3); //=> 2
     *      // JS behavior:
     *      R.modulo(-17, 3); //=> -2
     *      R.modulo(17, -3); //=> 2
     *
     *      var isOdd = R.modulo(R.__, 2);
     *      isOdd(42); //=> 0
     *      isOdd(21); //=> 1
     */
    var modulo = _curry2(function modulo(a, b) {
        return a % b;
    });

    /**
     * Multiplies two numbers. Equivalent to `a * b` but curried.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The first value.
     * @param {Number} b The second value.
     * @return {Number} The result of `a * b`.
     * @see R.divide
     * @example
     *
     *      var double = R.multiply(2);
     *      var triple = R.multiply(3);
     *      double(3);       //=>  6
     *      triple(4);       //=> 12
     *      R.multiply(2, 5);  //=> 10
     */
    var multiply = _curry2(function multiply(a, b) {
        return a * b;
    });

    /**
     * Wraps a function of any arity (including nullary) in a function that accepts
     * exactly `n` parameters. Any extraneous parameters will not be passed to the
     * supplied function.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig Number -> (* -> a) -> (* -> a)
     * @param {Number} n The desired arity of the new function.
     * @param {Function} fn The function to wrap.
     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
     *         arity `n`.
     * @example
     *
     *      var takesTwoArgs = (a, b) => [a, b];
     *
     *      takesTwoArgs.length; //=> 2
     *      takesTwoArgs(1, 2); //=> [1, 2]
     *
     *      var takesOneArg = R.nAry(1, takesTwoArgs);
     *      takesOneArg.length; //=> 1
     *      // Only `n` arguments are passed to the wrapped function
     *      takesOneArg(1, 2); //=> [1, undefined]
     */
    var nAry = _curry2(function nAry(n, fn) {
        switch (n) {
        case 0:
            return function () {
                return fn.call(this);
            };
        case 1:
            return function (a0) {
                return fn.call(this, a0);
            };
        case 2:
            return function (a0, a1) {
                return fn.call(this, a0, a1);
            };
        case 3:
            return function (a0, a1, a2) {
                return fn.call(this, a0, a1, a2);
            };
        case 4:
            return function (a0, a1, a2, a3) {
                return fn.call(this, a0, a1, a2, a3);
            };
        case 5:
            return function (a0, a1, a2, a3, a4) {
                return fn.call(this, a0, a1, a2, a3, a4);
            };
        case 6:
            return function (a0, a1, a2, a3, a4, a5) {
                return fn.call(this, a0, a1, a2, a3, a4, a5);
            };
        case 7:
            return function (a0, a1, a2, a3, a4, a5, a6) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
            };
        case 8:
            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
            };
        case 9:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
            };
        case 10:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            };
        default:
            throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
        }
    });

    /**
     * Negates its argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Math
     * @sig Number -> Number
     * @param {Number} n
     * @return {Number}
     * @example
     *
     *      R.negate(42); //=> -42
     */
    var negate = _curry1(function negate(n) {
        return -n;
    });

    /**
     * Returns `true` if no elements of the list match the predicate, `false`
     * otherwise.
     *
     * Dispatches to the `any` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> Boolean
     * @param {Function} fn The predicate function.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
     * @see R.all, R.any
     * @example
     *
     *      var isEven = n => n % 2 === 0;
     *
     *      R.none(isEven, [1, 3, 5, 7, 9, 11]); //=> true
     *      R.none(isEven, [1, 3, 5, 7, 8, 11]); //=> false
     */
    var none = _curry2(_complement(_dispatchable('any', _xany, any)));

    /**
     * A function that returns the `!` of its argument. It will return `true` when
     * passed false-y value, and `false` when passed a truth-y one.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Logic
     * @sig * -> Boolean
     * @param {*} a any value
     * @return {Boolean} the logical inverse of passed argument.
     * @see R.complement
     * @example
     *
     *      R.not(true); //=> false
     *      R.not(false); //=> true
     *      R.not(0); => true
     *      R.not(1); => false
     */
    var not = _curry1(function not(a) {
        return !a;
    });

    /**
     * Returns the nth element of the given list or string. If n is negative the
     * element at index length + n is returned.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Number -> [a] -> a | Undefined
     * @sig Number -> String -> String
     * @param {Number} offset
     * @param {*} list
     * @return {*}
     * @example
     *
     *      var list = ['foo', 'bar', 'baz', 'quux'];
     *      R.nth(1, list); //=> 'bar'
     *      R.nth(-1, list); //=> 'quux'
     *      R.nth(-99, list); //=> undefined
     *
     *      R.nth(2, 'abc'); //=> 'c'
     *      R.nth(3, 'abc'); //=> ''
     */
    var nth = _curry2(function nth(offset, list) {
        var idx = offset < 0 ? list.length + offset : offset;
        return _isString(list) ? list.charAt(idx) : list[idx];
    });

    /**
     * Returns a function which returns its nth argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Function
     * @sig Number -> *... -> *
     * @param {Number} n
     * @return {Function}
     * @example
     *
     *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
     *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
     */
    var nthArg = _curry1(function nthArg(n) {
        return function () {
            return nth(n, arguments);
        };
    });

    /**
     * Creates an object containing a single key:value pair.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Object
     * @sig String -> a -> {String:a}
     * @param {String} key
     * @param {*} val
     * @return {Object}
     * @see R.pair
     * @example
     *
     *      var matchPhrases = R.compose(
     *        R.objOf('must'),
     *        R.map(R.objOf('match_phrase'))
     *      );
     *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
     */
    var objOf = _curry2(function objOf(key, val) {
        var obj = {};
        obj[key] = val;
        return obj;
    });

    /**
     * Returns a singleton array containing the value provided.
     *
     * Note this `of` is different from the ES6 `of`; See
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Function
     * @sig a -> [a]
     * @param {*} x any value
     * @return {Array} An array wrapping `x`.
     * @example
     *
     *      R.of(null); //=> [null]
     *      R.of([42]); //=> [[42]]
     */
    var of = _curry1(_of);

    /**
     * Accepts a function `fn` and returns a function that guards invocation of
     * `fn` such that `fn` can only ever be called once, no matter how many times
     * the returned function is invoked. The first value calculated is returned in
     * subsequent invocations.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a... -> b) -> (a... -> b)
     * @param {Function} fn The function to wrap in a call-only-once wrapper.
     * @return {Function} The wrapped function.
     * @example
     *
     *      var addOneOnce = R.once(x => x + 1);
     *      addOneOnce(10); //=> 11
     *      addOneOnce(addOneOnce(50)); //=> 11
     */
    var once = _curry1(function once(fn) {
        var called = false;
        var result;
        return _arity(fn.length, function () {
            if (called) {
                return result;
            }
            called = true;
            result = fn.apply(this, arguments);
            return result;
        });
    });

    /**
     * Returns `true` if one or both of its arguments are `true`. Returns `false`
     * if both arguments are `false`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Logic
     * @sig * -> * -> *
     * @param {Boolean} a A boolean value
     * @param {Boolean} b A boolean value
     * @return {Boolean} `true` if one or both arguments are `true`, `false` otherwise
     * @see R.either
     * @example
     *
     *      R.or(true, true); //=> true
     *      R.or(true, false); //=> true
     *      R.or(false, true); //=> true
     *      R.or(false, false); //=> false
     */
    var or = _curry2(function or(a, b) {
        return a || b;
    });

    /**
     * Returns the result of "setting" the portion of the given data structure
     * focused by the given lens to the result of applying the given function to
     * the focused value.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Lens s a -> (a -> a) -> s -> s
     * @param {Lens} lens
     * @param {*} v
     * @param {*} x
     * @return {*}
     * @see R.prop, R.lensIndex, R.lensProp
     * @example
     *
     *      var headLens = R.lensIndex(0);
     *
     *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
     */
    // `Identity` is a functor that holds a single value, where `map` simply
    // transforms the held value with the provided function.
    // The value returned by the getter function is first transformed with `f`,
    // then set as the value of an `Identity`. This is then mapped over with the
    // setter function of the lens.
    var over = function () {
        // `Identity` is a functor that holds a single value, where `map` simply
        // transforms the held value with the provided function.
        var Identity = function (x) {
            return {
                value: x,
                map: function (f) {
                    return Identity(f(x));
                }
            };
        };
        return _curry3(function over(lens, f, x) {
            // The value returned by the getter function is first transformed with `f`,
            // then set as the value of an `Identity`. This is then mapped over with the
            // setter function of the lens.
            return lens(function (y) {
                return Identity(f(y));
            })(x).value;
        });
    }();

    /**
     * Takes two arguments, `fst` and `snd`, and returns `[fst, snd]`.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category List
     * @sig a -> b -> (a,b)
     * @param {*} fst
     * @param {*} snd
     * @return {Array}
     * @see R.objOf, R.of
     * @example
     *
     *      R.pair('foo', 'bar'); //=> ['foo', 'bar']
     */
    var pair = _curry2(function pair(fst, snd) {
        return [
            fst,
            snd
        ];
    });

    /**
     * Retrieve the value at a given path.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Object
     * @sig [String] -> {k: v} -> v | Undefined
     * @param {Array} path The path to use.
     * @param {Object} obj The object to retrieve the nested property from.
     * @return {*} The data at `path`.
     * @example
     *
     *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
     *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
     */
    var path = _curry2(function path(paths, obj) {
        var val = obj;
        var idx = 0;
        while (idx < paths.length) {
            if (val == null) {
                return;
            }
            val = val[paths[idx]];
            idx += 1;
        }
        return val;
    });

    /**
     * If the given, non-null object has a value at the given path, returns the
     * value at that path. Otherwise returns the provided default value.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Object
     * @sig a -> [String] -> Object -> a
     * @param {*} d The default value.
     * @param {Array} p The path to use.
     * @param {Object} obj The object to retrieve the nested property from.
     * @return {*} The data at `path` of the supplied object or the default value.
     * @example
     *
     *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2
     *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> "N/A"
     */
    var pathOr = _curry3(function pathOr(d, p, obj) {
        return defaultTo(d, path(p, obj));
    });

    /**
     * Returns `true` if the specified object property at given path satisfies the
     * given predicate; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Logic
     * @sig (a -> Boolean) -> [String] -> Object -> Boolean
     * @param {Function} pred
     * @param {Array} propPath
     * @param {*} obj
     * @return {Boolean}
     * @see R.propSatisfies, R.path
     * @example
     *
     *      R.pathSatisfies(y => y > 0, ['x', 'y'], {x: {y: 2}}); //=> true
     */
    var pathSatisfies = _curry3(function pathSatisfies(pred, propPath, obj) {
        return propPath.length > 0 && pred(path(propPath, obj));
    });

    /**
     * Returns a partial copy of an object containing only the keys specified. If
     * the key does not exist, the property is ignored.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [k] -> {k: v} -> {k: v}
     * @param {Array} names an array of String property names to copy onto a new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with only properties from `names` on it.
     * @see R.omit, R.props
     * @example
     *
     *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
     *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
     */
    var pick = _curry2(function pick(names, obj) {
        var result = {};
        var idx = 0;
        while (idx < names.length) {
            if (names[idx] in obj) {
                result[names[idx]] = obj[names[idx]];
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Similar to `pick` except that this one includes a `key: undefined` pair for
     * properties that don't exist.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [k] -> {k: v} -> {k: v}
     * @param {Array} names an array of String property names to copy onto a new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with only properties from `names` on it.
     * @see R.pick
     * @example
     *
     *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
     *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
     */
    var pickAll = _curry2(function pickAll(names, obj) {
        var result = {};
        var idx = 0;
        var len = names.length;
        while (idx < len) {
            var name = names[idx];
            result[name] = obj[name];
            idx += 1;
        }
        return result;
    });

    /**
     * Returns a partial copy of an object containing only the keys that satisfy
     * the supplied predicate.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @sig (v, k -> Boolean) -> {k: v} -> {k: v}
     * @param {Function} pred A predicate to determine whether or not a key
     *        should be included on the output object.
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with only properties that satisfy `pred`
     *         on it.
     * @see R.pick, R.filter
     * @example
     *
     *      var isUpperCase = (val, key) => key.toUpperCase() === key;
     *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
     */
    var pickBy = _curry2(function pickBy(test, obj) {
        var result = {};
        for (var prop in obj) {
            if (test(obj[prop], prop, obj)) {
                result[prop] = obj[prop];
            }
        }
        return result;
    });

    /**
     * Returns a new list with the given element at the front, followed by the
     * contents of the list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> [a]
     * @param {*} el The item to add to the head of the output list.
     * @param {Array} list The array to add to the tail of the output list.
     * @return {Array} A new array.
     * @see R.append
     * @example
     *
     *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
     */
    var prepend = _curry2(function prepend(el, list) {
        return _concat([el], list);
    });

    /**
     * Returns a function that when supplied an object returns the indicated
     * property of that object, if it exists.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig s -> {s: a} -> a | Undefined
     * @param {String} p The property name
     * @param {Object} obj The object to query
     * @return {*} The value at `obj.p`.
     * @example
     *
     *      R.prop('x', {x: 100}); //=> 100
     *      R.prop('x', {}); //=> undefined
     */
    var prop = _curry2(function prop(p, obj) {
        return obj[p];
    });

    /**
     * If the given, non-null object has an own property with the specified name,
     * returns the value of that property. Otherwise returns the provided default
     * value.
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category Object
     * @sig a -> String -> Object -> a
     * @param {*} val The default value.
     * @param {String} p The name of the property to return.
     * @param {Object} obj The object to query.
     * @return {*} The value of given property of the supplied object or the default value.
     * @example
     *
     *      var alice = {
     *        name: 'ALICE',
     *        age: 101
     *      };
     *      var favorite = R.prop('favoriteLibrary');
     *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
     *
     *      favorite(alice);  //=> undefined
     *      favoriteWithDefault(alice);  //=> 'Ramda'
     */
    var propOr = _curry3(function propOr(val, p, obj) {
        return obj != null && _has(p, obj) ? obj[p] : val;
    });

    /**
     * Returns `true` if the specified object property satisfies the given
     * predicate; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Logic
     * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
     * @param {Function} pred
     * @param {String} name
     * @param {*} obj
     * @return {Boolean}
     * @see R.propEq, R.propIs
     * @example
     *
     *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
     */
    var propSatisfies = _curry3(function propSatisfies(pred, name, obj) {
        return pred(obj[name]);
    });

    /**
     * Acts as multiple `prop`: array of keys in, array of values out. Preserves
     * order.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [k] -> {k: v} -> [v]
     * @param {Array} ps The property names to fetch
     * @param {Object} obj The object to query
     * @return {Array} The corresponding values or partially applied function.
     * @example
     *
     *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
     *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
     *
     *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));
     *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
     */
    var props = _curry2(function props(ps, obj) {
        var len = ps.length;
        var out = [];
        var idx = 0;
        while (idx < len) {
            out[idx] = obj[ps[idx]];
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Number -> Number -> [Number]
     * @param {Number} from The first number in the list.
     * @param {Number} to One more than the last number in the list.
     * @return {Array} The list of numbers in tthe set `[a, b)`.
     * @example
     *
     *      R.range(1, 5);    //=> [1, 2, 3, 4]
     *      R.range(50, 53);  //=> [50, 51, 52]
     */
    var range = _curry2(function range(from, to) {
        if (!(_isNumber(from) && _isNumber(to))) {
            throw new TypeError('Both arguments to range must be numbers');
        }
        var result = [];
        var n = from;
        while (n < to) {
            result.push(n);
            n += 1;
        }
        return result;
    });

    /**
     * Returns a single item by iterating through the list, successively calling
     * the iterator function and passing it an accumulator value and the current
     * value from the array, and then passing the result to the next call.
     *
     * Similar to `reduce`, except moves through the input list from the right to
     * the left.
     *
     * The iterator function receives two values: *(acc, value)*
     *
     * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse
     * arrays), unlike the native `Array.prototype.reduce` method. For more details
     * on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a,b -> a) -> a -> [b] -> a
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.addIndex
     * @example
     *
     *      var pairs = [ ['a', 1], ['b', 2], ['c', 3] ];
     *      var flattenPairs = (acc, pair) => acc.concat(pair);
     *
     *      R.reduceRight(flattenPairs, [], pairs); //=> [ 'c', 3, 'b', 2, 'a', 1 ]
     */
    var reduceRight = _curry3(function reduceRight(fn, acc, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
            acc = fn(acc, list[idx]);
            idx -= 1;
        }
        return acc;
    });

    /**
     * Returns a value wrapped to indicate that it is the final value of the reduce
     * and transduce functions. The returned value should be considered a black
     * box: the internal structure is not guaranteed to be stable.
     *
     * Note: this optimization is unavailable to functions not explicitly listed
     * above. For instance, it is not currently supported by reduceRight.
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category List
     * @sig a -> *
     * @param {*} x The final value of the reduce.
     * @return {*} The wrapped value.
     * @see R.reduce, R.transduce
     * @example
     *
     *      R.reduce(
     *        R.pipe(R.add, R.when(R.gte(R.__, 10), R.reduced)),
     *        0,
     *        [1, 2, 3, 4, 5]) // 10
     */
    var reduced = _curry1(_reduced);

    /**
     * Removes the sub-list of `list` starting at index `start` and containing
     * `count` elements. _Note that this is not destructive_: it returns a copy of
     * the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @since v0.2.2
     * @category List
     * @sig Number -> Number -> [a] -> [a]
     * @param {Number} start The position to start removing elements
     * @param {Number} count The number of elements to remove
     * @param {Array} list The list to remove from
     * @return {Array} A new Array with `count` elements from `start` removed.
     * @example
     *
     *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
     */
    var remove = _curry3(function remove(start, count, list) {
        return _concat(_slice(list, 0, Math.min(start, list.length)), _slice(list, Math.min(list.length, start + count)));
    });

    /**
     * Replace a substring or regex match in a string with a replacement.
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category String
     * @sig RegExp|String -> String -> String -> String
     * @param {RegExp|String} pattern A regular expression or a substring to match.
     * @param {String} replacement The string to replace the matches with.
     * @param {String} str The String to do the search and replacement in.
     * @return {String} The result.
     * @example
     *
     *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
     *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
     *
     *      // Use the "g" (global) flag to replace all occurrences:
     *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
     */
    var replace = _curry3(function replace(regex, replacement, str) {
        return str.replace(regex, replacement);
    });

    /**
     * Returns a new list or string with the elements or characters in reverse
     * order.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a]
     * @sig String -> String
     * @param {Array|String} list
     * @return {Array|String}
     * @example
     *
     *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
     *      R.reverse([1, 2]);     //=> [2, 1]
     *      R.reverse([1]);        //=> [1]
     *      R.reverse([]);         //=> []
     *
     *      R.reverse('abc');      //=> 'cba'
     *      R.reverse('ab');       //=> 'ba'
     *      R.reverse('a');        //=> 'a'
     *      R.reverse('');         //=> ''
     */
    var reverse = _curry1(function reverse(list) {
        return _isString(list) ? list.split('').reverse().join('') : _slice(list).reverse();
    });

    /**
     * Scan is similar to reduce, but returns a list of successively reduced values
     * from the left
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig (a,b -> a) -> a -> [b] -> [a]
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {Array} A list of all intermediately reduced values.
     * @example
     *
     *      var numbers = [1, 2, 3, 4];
     *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
     */
    var scan = _curry3(function scan(fn, acc, list) {
        var idx = 0;
        var len = list.length;
        var result = [acc];
        while (idx < len) {
            acc = fn(acc, list[idx]);
            result[idx + 1] = acc;
            idx += 1;
        }
        return result;
    });

    /**
     * Returns the result of "setting" the portion of the given data structure
     * focused by the given lens to the given value.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Lens s a -> a -> s -> s
     * @param {Lens} lens
     * @param {*} v
     * @param {*} x
     * @return {*}
     * @see R.prop, R.lensIndex, R.lensProp
     * @example
     *
     *      var xLens = R.lensProp('x');
     *
     *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
     *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
     */
    var set = _curry3(function set(lens, v, x) {
        return over(lens, always(v), x);
    });

    /**
     * Returns the elements of the given list or string (or object with a `slice`
     * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
     *
     * Dispatches to the `slice` method of the third argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.4
     * @category List
     * @sig Number -> Number -> [a] -> [a]
     * @sig Number -> Number -> String -> String
     * @param {Number} fromIndex The start index (inclusive).
     * @param {Number} toIndex The end index (exclusive).
     * @param {*} list
     * @return {*}
     * @example
     *
     *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
     *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
     *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
     *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
     *      R.slice(0, 3, 'ramda');                     //=> 'ram'
     */
    var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
        return Array.prototype.slice.call(list, fromIndex, toIndex);
    }));

    /**
     * Returns a copy of the list, sorted according to the comparator function,
     * which should accept two values at a time and return a negative number if the
     * first value is smaller, a positive number if it's larger, and zero if they
     * are equal. Please note that this is a **copy** of the list. It does not
     * modify the original.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a,a -> Number) -> [a] -> [a]
     * @param {Function} comparator A sorting function :: a -> b -> Int
     * @param {Array} list The list to sort
     * @return {Array} a new array with its elements sorted by the comparator function.
     * @example
     *
     *      var diff = function(a, b) { return a - b; };
     *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
     */
    var sort = _curry2(function sort(comparator, list) {
        return _slice(list).sort(comparator);
    });

    /**
     * Sorts the list according to the supplied function.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord b => (a -> b) -> [a] -> [a]
     * @param {Function} fn
     * @param {Array} list The list to sort.
     * @return {Array} A new list sorted by the keys generated by `fn`.
     * @example
     *
     *      var sortByFirstItem = R.sortBy(R.prop(0));
     *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
     *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];
     *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
     *      var alice = {
     *        name: 'ALICE',
     *        age: 101
     *      };
     *      var bob = {
     *        name: 'Bob',
     *        age: -10
     *      };
     *      var clara = {
     *        name: 'clara',
     *        age: 314.159
     *      };
     *      var people = [clara, bob, alice];
     *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
     */
    var sortBy = _curry2(function sortBy(fn, list) {
        return _slice(list).sort(function (a, b) {
            var aa = fn(a);
            var bb = fn(b);
            return aa < bb ? -1 : aa > bb ? 1 : 0;
        });
    });

    /**
     * Splits a given list or string at a given index.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig Number -> [a] -> [[a], [a]]
     * @sig Number -> String -> [String, String]
     * @param {Number} index The index where the array/string is split.
     * @param {Array|String} array The array/string to be split.
     * @return {Array}
     * @example
     *
     *      R.splitAt(1, [1, 2, 3]);          //=> [[1], [2, 3]]
     *      R.splitAt(5, 'hello world');      //=> ['hello', ' world']
     *      R.splitAt(-1, 'foobar');          //=> ['fooba', 'r']
     */
    var splitAt = _curry2(function splitAt(index, array) {
        return [
            slice(0, index, array),
            slice(index, length(array), array)
        ];
    });

    /**
     * Splits a collection into slices of the specified length.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig Number -> [a] -> [[a]]
     * @sig Number -> String -> [String]
     * @param {Number} n
     * @param {Array} list
     * @return {Array}
     * @example
     *
     *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
     *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
     */
    var splitEvery = _curry2(function splitEvery(n, list) {
        if (n <= 0) {
            throw new Error('First argument to splitEvery must be a positive integer');
        }
        var result = [];
        var idx = 0;
        while (idx < list.length) {
            result.push(slice(idx, idx += n, list));
        }
        return result;
    });

    /**
     * Takes a list and a predicate and returns a pair of lists with the following properties:
     *
     *  - the result of concatenating the two output lists is equivalent to the input list;
     *  - none of the elements of the first output list satisfies the predicate; and
     *  - if the second output list is non-empty, its first element satisfies the predicate.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [[a], [a]]
     * @param {Function} pred The predicate that determines where the array is split.
     * @param {Array} list The array to be split.
     * @return {Array}
     * @example
     *
     *      R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=> [[1], [2, 3, 1, 2, 3]]
     */
    var splitWhen = _curry2(function splitWhen(pred, list) {
        var idx = 0;
        var len = list.length;
        var prefix = [];
        while (idx < len && !pred(list[idx])) {
            prefix.push(list[idx]);
            idx += 1;
        }
        return [
            prefix,
            _slice(list, idx)
        ];
    });

    /**
     * Subtracts its second argument from its first argument.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The first value.
     * @param {Number} b The second value.
     * @return {Number} The result of `a - b`.
     * @see R.add
     * @example
     *
     *      R.subtract(10, 8); //=> 2
     *
     *      var minus5 = R.subtract(R.__, 5);
     *      minus5(17); //=> 12
     *
     *      var complementaryAngle = R.subtract(90);
     *      complementaryAngle(30); //=> 60
     *      complementaryAngle(72); //=> 18
     */
    var subtract = _curry2(function subtract(a, b) {
        return Number(a) - Number(b);
    });

    /**
     * Returns all but the first element of the given list or string (or object
     * with a `tail` method).
     *
     * Dispatches to the `slice` method of the first argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a]
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @see R.head, R.init, R.last
     * @example
     *
     *      R.tail([1, 2, 3]);  //=> [2, 3]
     *      R.tail([1, 2]);     //=> [2]
     *      R.tail([1]);        //=> []
     *      R.tail([]);         //=> []
     *
     *      R.tail('abc');  //=> 'bc'
     *      R.tail('ab');   //=> 'b'
     *      R.tail('a');    //=> ''
     *      R.tail('');     //=> ''
     */
    var tail = _checkForMethod('tail', slice(1, Infinity));

    /**
     * Returns the first `n` elements of the given list, string, or
     * transducer/transformer (or object with a `take` method).
     *
     * Dispatches to the `take` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n
     * @param {*} list
     * @return {*}
     * @see R.drop
     * @example
     *
     *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
     *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
     *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.take(3, 'ramda');               //=> 'ram'
     *
     *      var personnel = [
     *        'Dave Brubeck',
     *        'Paul Desmond',
     *        'Eugene Wright',
     *        'Joe Morello',
     *        'Gerry Mulligan',
     *        'Bob Bates',
     *        'Joe Dodge',
     *        'Ron Crotty'
     *      ];
     *
     *      var takeFive = R.take(5);
     *      takeFive(personnel);
     *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
     */
    var take = _curry2(_dispatchable('take', _xtake, function take(n, xs) {
        return slice(0, n < 0 ? Infinity : n, xs);
    }));

    /**
     * Returns a new list containing the last `n` elements of a given list, passing
     * each value to the supplied predicate function, and terminating when the
     * predicate function returns `false`. Excludes the element that caused the
     * predicate function to fail. The predicate function is passed one argument:
     * *(value)*.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.dropLastWhile, R.addIndex
     * @example
     *
     *      var isNotOne = x => x !== 1;
     *
     *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
     */
    var takeLastWhile = _curry2(function takeLastWhile(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0 && fn(list[idx])) {
            idx -= 1;
        }
        return _slice(list, idx + 1, Infinity);
    });

    /**
     * Returns a new list containing the first `n` elements of a given list,
     * passing each value to the supplied predicate function, and terminating when
     * the predicate function returns `false`. Excludes the element that caused the
     * predicate function to fail. The predicate function is passed one argument:
     * *(value)*.
     *
     * Dispatches to the `takeWhile` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.dropWhile, R.transduce, R.addIndex
     * @example
     *
     *      var isNotFour = x => x !== 4;
     *
     *      R.takeWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3]
     */
    var takeWhile = _curry2(_dispatchable('takeWhile', _xtakeWhile, function takeWhile(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len && fn(list[idx])) {
            idx += 1;
        }
        return _slice(list, 0, idx);
    }));

    /**
     * Runs the given function with the supplied object, then returns the object.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a -> *) -> a -> a
     * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
     * @param {*} x
     * @return {*} `x`.
     * @example
     *
     *      var sayX = x => console.log('x is ' + x);
     *      R.tap(sayX, 100); //=> 100
     *      //-> 'x is 100'
     */
    var tap = _curry2(function tap(fn, x) {
        fn(x);
        return x;
    });

    /**
     * Calls an input function `n` times, returning an array containing the results
     * of those function calls.
     *
     * `fn` is passed one argument: The current value of `n`, which begins at `0`
     * and is gradually incremented to `n - 1`.
     *
     * @func
     * @memberOf R
     * @since v0.2.3
     * @category List
     * @sig (Number -> a) -> Number -> [a]
     * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
     * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
     * @return {Array} An array containing the return values of all calls to `fn`.
     * @example
     *
     *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
     */
    var times = _curry2(function times(fn, n) {
        var len = Number(n);
        var idx = 0;
        var list;
        if (len < 0 || isNaN(len)) {
            throw new RangeError('n must be a non-negative number');
        }
        list = new Array(len);
        while (idx < len) {
            list[idx] = fn(idx);
            idx += 1;
        }
        return list;
    });

    /**
     * Converts an object into an array of key, value arrays. Only the object's
     * own properties are used.
     * Note that the order of the output array is not guaranteed to be consistent
     * across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.4.0
     * @category Object
     * @sig {String: *} -> [[String,*]]
     * @param {Object} obj The object to extract from
     * @return {Array} An array of key, value arrays from the object's own properties.
     * @see R.fromPairs
     * @example
     *
     *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
     */
    var toPairs = _curry1(function toPairs(obj) {
        var pairs = [];
        for (var prop in obj) {
            if (_has(prop, obj)) {
                pairs[pairs.length] = [
                    prop,
                    obj[prop]
                ];
            }
        }
        return pairs;
    });

    /**
     * Converts an object into an array of key, value arrays. The object's own
     * properties and prototype properties are used. Note that the order of the
     * output array is not guaranteed to be consistent across different JS
     * platforms.
     *
     * @func
     * @memberOf R
     * @since v0.4.0
     * @category Object
     * @sig {String: *} -> [[String,*]]
     * @param {Object} obj The object to extract from
     * @return {Array} An array of key, value arrays from the object's own
     *         and prototype properties.
     * @example
     *
     *      var F = function() { this.x = 'X'; };
     *      F.prototype.y = 'Y';
     *      var f = new F();
     *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
     */
    var toPairsIn = _curry1(function toPairsIn(obj) {
        var pairs = [];
        for (var prop in obj) {
            pairs[pairs.length] = [
                prop,
                obj[prop]
            ];
        }
        return pairs;
    });

    /**
     * Transposes the rows and columns of a 2D list.
     * When passed a list of `n` lists of length `x`,
     * returns a list of `x` lists of length `n`.
     *
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig [[a]] -> [[a]]
     * @param {Array} list A 2D list
     * @return {Array} A 2D list
     * @example
     *
     *      R.transpose([[1, 'a'], [2, 'b'], [3, 'c']]) //=> [[1, 2, 3], ['a', 'b', 'c']]
     *      R.transpose([[1, 2, 3], ['a', 'b', 'c']]) //=> [[1, 'a'], [2, 'b'], [3, 'c']]
     *
     * If some of the rows are shorter than the following rows, their elements are skipped:
     *
     *      R.transpose([[10, 11], [20], [], [30, 31, 32]]) //=> [[10, 20, 30], [11, 31], [32]]
     */
    var transpose = _curry1(function transpose(outerlist) {
        var i = 0;
        var result = [];
        while (i < outerlist.length) {
            var innerlist = outerlist[i];
            var j = 0;
            while (j < innerlist.length) {
                if (typeof result[j] === 'undefined') {
                    result[j] = [];
                }
                result[j].push(innerlist[j]);
                j += 1;
            }
            i += 1;
        }
        return result;
    });

    /**
     * Removes (strips) whitespace from both ends of the string.
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category String
     * @sig String -> String
     * @param {String} str The string to trim.
     * @return {String} Trimmed version of `str`.
     * @example
     *
     *      R.trim('   xyz  '); //=> 'xyz'
     *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
     */
    var trim = function () {
        var ws = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
        var zeroWidth = '\u200B';
        var hasProtoTrim = typeof String.prototype.trim === 'function';
        if (!hasProtoTrim || (ws.trim() || !zeroWidth.trim())) {
            return _curry1(function trim(str) {
                var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
                var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
                return str.replace(beginRx, '').replace(endRx, '');
            });
        } else {
            return _curry1(function trim(str) {
                return str.trim();
            });
        }
    }();

    /**
     * `tryCatch` takes two functions, a `tryer` and a `catcher`. The returned
     * function evaluates the `tryer`; if it does not throw, it simply returns the
     * result. If the `tryer` *does* throw, the returned function evaluates the
     * `catcher` function and returns its result. Note that for effective
     * composition with this function, both the `tryer` and `catcher` functions
     * must return the same type of results.
     *
     * @func
     * @memberOf R
     * @since v0.20.0
     * @category Function
     * @sig (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
     * @param {Function} tryer The function that may throw.
     * @param {Function} catcher The function that will be evaluated if `tryer` throws.
     * @return {Function} A new function that will catch exceptions and send then to the catcher.
     * @example
     *
     *      R.tryCatch(R.prop('x'), R.F, {x: true}); //=> true
     *      R.tryCatch(R.prop('x'), R.F, null);      //=> false
     */
    var tryCatch = _curry2(function _tryCatch(tryer, catcher) {
        return _arity(tryer.length, function () {
            try {
                return tryer.apply(this, arguments);
            } catch (e) {
                return catcher.apply(this, _concat([e], arguments));
            }
        });
    });

    /**
     * Gives a single-word string description of the (native) type of a value,
     * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
     * attempt to distinguish user Object types any further, reporting them all as
     * 'Object'.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Type
     * @sig (* -> {*}) -> String
     * @param {*} val The value to test
     * @return {String}
     * @example
     *
     *      R.type({}); //=> "Object"
     *      R.type(1); //=> "Number"
     *      R.type(false); //=> "Boolean"
     *      R.type('s'); //=> "String"
     *      R.type(null); //=> "Null"
     *      R.type([]); //=> "Array"
     *      R.type(/[A-z]/); //=> "RegExp"
     */
    var type = _curry1(function type(val) {
        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
    });

    /**
     * Takes a function `fn`, which takes a single array argument, and returns a
     * function which:
     *
     *   - takes any number of positional arguments;
     *   - passes these arguments to `fn` as an array; and
     *   - returns the result.
     *
     * In other words, R.unapply derives a variadic function from a function which
     * takes an array. R.unapply is the inverse of R.apply.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Function
     * @sig ([*...] -> a) -> (*... -> a)
     * @param {Function} fn
     * @return {Function}
     * @see R.apply
     * @example
     *
     *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
     */
    var unapply = _curry1(function unapply(fn) {
        return function () {
            return fn(_slice(arguments));
        };
    });

    /**
     * Wraps a function of any arity (including nullary) in a function that accepts
     * exactly 1 parameter. Any extraneous parameters will not be passed to the
     * supplied function.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Function
     * @sig (* -> b) -> (a -> b)
     * @param {Function} fn The function to wrap.
     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
     *         arity 1.
     * @example
     *
     *      var takesTwoArgs = function(a, b) {
     *        return [a, b];
     *      };
     *      takesTwoArgs.length; //=> 2
     *      takesTwoArgs(1, 2); //=> [1, 2]
     *
     *      var takesOneArg = R.unary(takesTwoArgs);
     *      takesOneArg.length; //=> 1
     *      // Only 1 argument is passed to the wrapped function
     *      takesOneArg(1, 2); //=> [1, undefined]
     */
    var unary = _curry1(function unary(fn) {
        return nAry(1, fn);
    });

    /**
     * Returns a function of arity `n` from a (manually) curried function.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Function
     * @sig Number -> (a -> b) -> (a -> c)
     * @param {Number} length The arity for the returned function.
     * @param {Function} fn The function to uncurry.
     * @return {Function} A new function.
     * @see R.curry
     * @example
     *
     *      var addFour = a => b => c => d => a + b + c + d;
     *
     *      var uncurriedAddFour = R.uncurryN(4, addFour);
     *      uncurriedAddFour(1, 2, 3, 4); //=> 10
     */
    var uncurryN = _curry2(function uncurryN(depth, fn) {
        return curryN(depth, function () {
            var currentDepth = 1;
            var value = fn;
            var idx = 0;
            var endIdx;
            while (currentDepth <= depth && typeof value === 'function') {
                endIdx = currentDepth === depth ? arguments.length : idx + value.length;
                value = value.apply(this, _slice(arguments, idx, endIdx));
                currentDepth += 1;
                idx = endIdx;
            }
            return value;
        });
    });

    /**
     * Builds a list from a seed value. Accepts an iterator function, which returns
     * either false to stop iteration or an array of length 2 containing the value
     * to add to the resulting list and the seed to be used in the next call to the
     * iterator function.
     *
     * The iterator function receives one argument: *(seed)*.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig (a -> [b]) -> * -> [b]
     * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
     *        either false to quit iteration or an array of length two to proceed. The element
     *        at index 0 of this array will be added to the resulting array, and the element
     *        at index 1 will be passed to the next call to `fn`.
     * @param {*} seed The seed value.
     * @return {Array} The final list.
     * @example
     *
     *      var f = n => n > 50 ? false : [-n, n + 10];
     *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
     */
    var unfold = _curry2(function unfold(fn, seed) {
        var pair = fn(seed);
        var result = [];
        while (pair && pair.length) {
            result[result.length] = pair[0];
            pair = fn(pair[1]);
        }
        return result;
    });

    /**
     * Returns a new list containing only one copy of each element in the original
     * list, based upon the value returned by applying the supplied predicate to
     * two list elements. Prefers the first item if two items compare equal based
     * on the predicate.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category List
     * @sig (a, a -> Boolean) -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      var strEq = R.eqBy(String);
     *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
     *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
     *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
     *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
     */
    var uniqWith = _curry2(function uniqWith(pred, list) {
        var idx = 0;
        var len = list.length;
        var result = [];
        var item;
        while (idx < len) {
            item = list[idx];
            if (!_containsWith(pred, item, result)) {
                result[result.length] = item;
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Tests the final argument by passing it to the given predicate function. If
     * the predicate is not satisfied, the function will return the result of
     * calling the `whenFalseFn` function with the same argument. If the predicate
     * is satisfied, the argument is returned as is.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Logic
     * @sig (a -> Boolean) -> (a -> a) -> a -> a
     * @param {Function} pred        A predicate function
     * @param {Function} whenFalseFn A function to invoke when the `pred` evaluates
     *                               to a falsy value.
     * @param {*}        x           An object to test with the `pred` function and
     *                               pass to `whenFalseFn` if necessary.
     * @return {*} Either `x` or the result of applying `x` to `whenFalseFn`.
     * @see R.ifElse, R.when
     * @example
     *
     *      // coerceArray :: (a|[a]) -> [a]
     *      var coerceArray = R.unless(R.isArrayLike, R.of);
     *      coerceArray([1, 2, 3]); //=> [1, 2, 3]
     *      coerceArray(1);         //=> [1]
     */
    var unless = _curry3(function unless(pred, whenFalseFn, x) {
        return pred(x) ? x : whenFalseFn(x);
    });

    /**
     * Takes a predicate, a transformation function, and an initial value,
     * and returns a value of the same type as the initial value.
     * It does so by applying the transformation until the predicate is satisfied,
     * at which point it returns the satisfactory value.
     *
     * @func
     * @memberOf R
     * @since v0.20.0
     * @category Logic
     * @sig (a -> Boolean) -> (a -> a) -> a -> a
     * @param {Function} pred A predicate function
     * @param {Function} fn The iterator function
     * @param {*} init Initial value
     * @return {*} Final value that satisfies predicate
     * @example
     *
     *      R.until(R.gt(R.__, 100), R.multiply(2))(1) // => 128
     */
    var until = _curry3(function until(pred, fn, init) {
        var val = init;
        while (!pred(val)) {
            val = fn(val);
        }
        return val;
    });

    /**
     * Returns a new copy of the array with the element at the provided index
     * replaced with the given value.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig Number -> a -> [a] -> [a]
     * @param {Number} idx The index to update.
     * @param {*} x The value to exist at the given index of the returned array.
     * @param {Array|Arguments} list The source array-like object to be updated.
     * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
     * @see R.adjust
     * @example
     *
     *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]
     *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]
     */
    var update = _curry3(function update(idx, x, list) {
        return adjust(always(x), idx, list);
    });

    /**
     * Accepts a function `fn` and a list of transformer functions and returns a
     * new curried function. When the new function is invoked, it calls the
     * function `fn` with parameters consisting of the result of calling each
     * supplied handler on successive arguments to the new function.
     *
     * If more arguments are passed to the returned function than transformer
     * functions, those arguments are passed directly to `fn` as additional
     * parameters. If you expect additional arguments that don't need to be
     * transformed, although you can ignore them, it's best to pass an identity
     * function so that the new function reports the correct arity.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (x1 -> x2 -> ... -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)
     * @param {Function} fn The function to wrap.
     * @param {Array} transformers A list of transformer functions
     * @return {Function} The wrapped function.
     * @example
     *
     *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81
     *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81
     *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32
     *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32
     */
    var useWith = _curry2(function useWith(fn, transformers) {
        return curryN(transformers.length, function () {
            var args = [];
            var idx = 0;
            while (idx < transformers.length) {
                args.push(transformers[idx].call(this, arguments[idx]));
                idx += 1;
            }
            return fn.apply(this, args.concat(_slice(arguments, transformers.length)));
        });
    });

    /**
     * Returns a list of all the enumerable own properties of the supplied object.
     * Note that the order of the output array is not guaranteed across different
     * JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {k: v} -> [v]
     * @param {Object} obj The object to extract values from
     * @return {Array} An array of the values of the object's own properties.
     * @example
     *
     *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
     */
    var values = _curry1(function values(obj) {
        var props = keys(obj);
        var len = props.length;
        var vals = [];
        var idx = 0;
        while (idx < len) {
            vals[idx] = obj[props[idx]];
            idx += 1;
        }
        return vals;
    });

    /**
     * Returns a list of all the properties, including prototype properties, of the
     * supplied object.
     * Note that the order of the output array is not guaranteed to be consistent
     * across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Object
     * @sig {k: v} -> [v]
     * @param {Object} obj The object to extract values from
     * @return {Array} An array of the values of the object's own and prototype properties.
     * @example
     *
     *      var F = function() { this.x = 'X'; };
     *      F.prototype.y = 'Y';
     *      var f = new F();
     *      R.valuesIn(f); //=> ['X', 'Y']
     */
    var valuesIn = _curry1(function valuesIn(obj) {
        var prop;
        var vs = [];
        for (prop in obj) {
            vs[vs.length] = obj[prop];
        }
        return vs;
    });

    /**
     * Returns a "view" of the given data structure, determined by the given lens.
     * The lens's focus determines which portion of the data structure is visible.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Lens s a -> s -> a
     * @param {Lens} lens
     * @param {*} x
     * @return {*}
     * @see R.prop, R.lensIndex, R.lensProp
     * @example
     *
     *      var xLens = R.lensProp('x');
     *
     *      R.view(xLens, {x: 1, y: 2});  //=> 1
     *      R.view(xLens, {x: 4, y: 2});  //=> 4
     */
    // `Const` is a functor that effectively ignores the function given to `map`.
    // Using `Const` effectively ignores the setter function of the `lens`,
    // leaving the value returned by the getter function unmodified.
    var view = function () {
        // `Const` is a functor that effectively ignores the function given to `map`.
        var Const = function (x) {
            return {
                value: x,
                map: function () {
                    return this;
                }
            };
        };
        return _curry2(function view(lens, x) {
            // Using `Const` effectively ignores the setter function of the `lens`,
            // leaving the value returned by the getter function unmodified.
            return lens(Const)(x).value;
        });
    }();

    /**
     * Tests the final argument by passing it to the given predicate function. If
     * the predicate is satisfied, the function will return the result of calling
     * the `whenTrueFn` function with the same argument. If the predicate is not
     * satisfied, the argument is returned as is.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Logic
     * @sig (a -> Boolean) -> (a -> a) -> a -> a
     * @param {Function} pred       A predicate function
     * @param {Function} whenTrueFn A function to invoke when the `condition`
     *                              evaluates to a truthy value.
     * @param {*}        x          An object to test with the `pred` function and
     *                              pass to `whenTrueFn` if necessary.
     * @return {*} Either `x` or the result of applying `x` to `whenTrueFn`.
     * @see R.ifElse, R.unless
     * @example
     *
     *      // truncate :: String -> String
     *      var truncate = R.when(
     *        R.propSatisfies(R.gt(R.__, 10), 'length'),
     *        R.pipe(R.take(10), R.append(''), R.join(''))
     *      );
     *      truncate('12345');         //=> '12345'
     *      truncate('0123456789ABC'); //=> '0123456789'
     */
    var when = _curry3(function when(pred, whenTrueFn, x) {
        return pred(x) ? whenTrueFn(x) : x;
    });

    /**
     * Takes a spec object and a test object; returns true if the test satisfies
     * the spec. Each of the spec's own properties must be a predicate function.
     * Each predicate is applied to the value of the corresponding property of the
     * test object. `where` returns true if all the predicates return true, false
     * otherwise.
     *
     * `where` is well suited to declaratively expressing constraints for other
     * functions such as `filter` and `find`.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category Object
     * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
     * @param {Object} spec
     * @param {Object} testObj
     * @return {Boolean}
     * @example
     *
     *      // pred :: Object -> Boolean
     *      var pred = R.where({
     *        a: R.equals('foo'),
     *        b: R.complement(R.equals('bar')),
     *        x: R.gt(_, 10),
     *        y: R.lt(_, 20)
     *      });
     *
     *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
     *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
     *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
     *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
     *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
     */
    var where = _curry2(function where(spec, testObj) {
        for (var prop in spec) {
            if (_has(prop, spec) && !spec[prop](testObj[prop])) {
                return false;
            }
        }
        return true;
    });

    /**
     * Wrap a function inside another to allow you to make adjustments to the
     * parameters, or do other processing either before the internal function is
     * called or with its results.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a... -> b) -> ((a... -> b) -> a... -> c) -> (a... -> c)
     * @param {Function} fn The function to wrap.
     * @param {Function} wrapper The wrapper function.
     * @return {Function} The wrapped function.
     * @example
     *
     *      var greet = name => 'Hello ' + name;
     *
     *      var shoutedGreet = R.wrap(greet, (gr, name) => gr(name).toUpperCase());
     *
     *      shoutedGreet("Kathy"); //=> "HELLO KATHY"
     *
     *      var shortenedGreet = R.wrap(greet, function(gr, name) {
     *        return gr(name.substring(0, 3));
     *      });
     *      shortenedGreet("Robert"); //=> "Hello Rob"
     */
    var wrap = _curry2(function wrap(fn, wrapper) {
        return curryN(fn.length, function () {
            return wrapper.apply(this, _concat([fn], arguments));
        });
    });

    /**
     * Creates a new list out of the two supplied by creating each possible pair
     * from the lists.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [b] -> [[a,b]]
     * @param {Array} as The first list.
     * @param {Array} bs The second list.
     * @return {Array} The list made by combining each possible pair from
     *         `as` and `bs` into pairs (`[a, b]`).
     * @example
     *
     *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
     */
    // = xprodWith(prepend); (takes about 3 times as long...)
    var xprod = _curry2(function xprod(a, b) {
        // = xprodWith(prepend); (takes about 3 times as long...)
        var idx = 0;
        var ilen = a.length;
        var j;
        var jlen = b.length;
        var result = [];
        while (idx < ilen) {
            j = 0;
            while (j < jlen) {
                result[result.length] = [
                    a[idx],
                    b[j]
                ];
                j += 1;
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Creates a new list out of the two supplied by pairing up equally-positioned
     * items from both lists. The returned list is truncated to the length of the
     * shorter of the two input lists.
     * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [b] -> [[a,b]]
     * @param {Array} list1 The first array to consider.
     * @param {Array} list2 The second array to consider.
     * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
     * @example
     *
     *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
     */
    var zip = _curry2(function zip(a, b) {
        var rv = [];
        var idx = 0;
        var len = Math.min(a.length, b.length);
        while (idx < len) {
            rv[idx] = [
                a[idx],
                b[idx]
            ];
            idx += 1;
        }
        return rv;
    });

    /**
     * Creates a new object out of a list of keys and a list of values.
     * Key/value pairing is truncated to the length of the shorter of the two lists.
     * Note: `zipObj` is equivalent to `pipe(zipWith(pair), fromPairs)`.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig [String] -> [*] -> {String: *}
     * @param {Array} keys The array that will be properties on the output object.
     * @param {Array} values The list of values on the output object.
     * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
     * @example
     *
     *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
     */
    var zipObj = _curry2(function zipObj(keys, values) {
        var idx = 0;
        var len = Math.min(keys.length, values.length);
        var out = {};
        while (idx < len) {
            out[keys[idx]] = values[idx];
            idx += 1;
        }
        return out;
    });

    /**
     * Creates a new list out of the two supplied by applying the function to each
     * equally-positioned pair in the lists. The returned list is truncated to the
     * length of the shorter of the two input lists.
     *
     * @function
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a,b -> c) -> [a] -> [b] -> [c]
     * @param {Function} fn The function used to combine the two elements into one value.
     * @param {Array} list1 The first array to consider.
     * @param {Array} list2 The second array to consider.
     * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
     *         using `fn`.
     * @example
     *
     *      var f = (x, y) => {
     *        // ...
     *      };
     *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
     *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
     */
    var zipWith = _curry3(function zipWith(fn, a, b) {
        var rv = [];
        var idx = 0;
        var len = Math.min(a.length, b.length);
        while (idx < len) {
            rv[idx] = fn(a[idx], b[idx]);
            idx += 1;
        }
        return rv;
    });

    /**
     * A function that always returns `false`. Any passed in parameters are ignored.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Function
     * @sig * -> Boolean
     * @param {*}
     * @return {Boolean}
     * @see R.always, R.T
     * @example
     *
     *      R.F(); //=> false
     */
    var F = always(false);

    /**
     * A function that always returns `true`. Any passed in parameters are ignored.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Function
     * @sig * -> Boolean
     * @param {*}
     * @return {Boolean}
     * @see R.always, R.F
     * @example
     *
     *      R.T(); //=> true
     */
    var T = always(true);

    /**
     * Copies an object.
     *
     * @private
     * @param {*} value The value to be copied
     * @param {Array} refFrom Array containing the source references
     * @param {Array} refTo Array containing the copied source references
     * @param {Boolean} deep Whether or not to perform deep cloning.
     * @return {*} The copied value.
     */
    var _clone = function _clone(value, refFrom, refTo, deep) {
        var copy = function copy(copiedValue) {
            var len = refFrom.length;
            var idx = 0;
            while (idx < len) {
                if (value === refFrom[idx]) {
                    return refTo[idx];
                }
                idx += 1;
            }
            refFrom[idx + 1] = value;
            refTo[idx + 1] = copiedValue;
            for (var key in value) {
                copiedValue[key] = deep ? _clone(value[key], refFrom, refTo, true) : value[key];
            }
            return copiedValue;
        };
        switch (type(value)) {
        case 'Object':
            return copy({});
        case 'Array':
            return copy([]);
        case 'Date':
            return new Date(value.valueOf());
        case 'RegExp':
            return _cloneRegExp(value);
        default:
            return value;
        }
    };

    var _createPartialApplicator = function _createPartialApplicator(concat) {
        return _curry2(function (fn, args) {
            return _arity(Math.max(0, fn.length - args.length), function () {
                return fn.apply(this, concat(args, arguments));
            });
        });
    };

    var _dropLast = function dropLast(n, xs) {
        return take(n < xs.length ? xs.length - n : 0, xs);
    };

    // Values of other types are only equal if identical.
    var _equals = function _equals(a, b, stackA, stackB) {
        if (identical(a, b)) {
            return true;
        }
        if (type(a) !== type(b)) {
            return false;
        }
        if (a == null || b == null) {
            return false;
        }
        if (typeof a.equals === 'function' || typeof b.equals === 'function') {
            return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
        }
        switch (type(a)) {
        case 'Arguments':
        case 'Array':
        case 'Object':
            if (typeof a.constructor === 'function' && _functionName(a.constructor) === 'Promise') {
                return a === b;
            }
            break;
        case 'Boolean':
        case 'Number':
        case 'String':
            if (!(typeof a === typeof b && identical(a.valueOf(), b.valueOf()))) {
                return false;
            }
            break;
        case 'Date':
            if (!identical(a.valueOf(), b.valueOf())) {
                return false;
            }
            break;
        case 'Error':
            return a.name === b.name && a.message === b.message;
        case 'RegExp':
            if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
                return false;
            }
            break;
        case 'Map':
        case 'Set':
            if (!_equals(_arrayFromIterator(a.entries()), _arrayFromIterator(b.entries()), stackA, stackB)) {
                return false;
            }
            break;
        case 'Int8Array':
        case 'Uint8Array':
        case 'Uint8ClampedArray':
        case 'Int16Array':
        case 'Uint16Array':
        case 'Int32Array':
        case 'Uint32Array':
        case 'Float32Array':
        case 'Float64Array':
            break;
        case 'ArrayBuffer':
            break;
        default:
            // Values of other types are only equal if identical.
            return false;
        }
        var keysA = keys(a);
        if (keysA.length !== keys(b).length) {
            return false;
        }
        var idx = stackA.length - 1;
        while (idx >= 0) {
            if (stackA[idx] === a) {
                return stackB[idx] === b;
            }
            idx -= 1;
        }
        stackA.push(a);
        stackB.push(b);
        idx = keysA.length - 1;
        while (idx >= 0) {
            var key = keysA[idx];
            if (!(_has(key, b) && _equals(b[key], a[key], stackA, stackB))) {
                return false;
            }
            idx -= 1;
        }
        stackA.pop();
        stackB.pop();
        return true;
    };

    /**
     * `_makeFlat` is a helper function that returns a one-level or fully recursive
     * function based on the flag passed in.
     *
     * @private
     */
    var _makeFlat = function _makeFlat(recursive) {
        return function flatt(list) {
            var value, jlen, j;
            var result = [];
            var idx = 0;
            var ilen = list.length;
            while (idx < ilen) {
                if (isArrayLike(list[idx])) {
                    value = recursive ? flatt(list[idx]) : list[idx];
                    j = 0;
                    jlen = value.length;
                    while (j < jlen) {
                        result[result.length] = value[j];
                        j += 1;
                    }
                } else {
                    result[result.length] = list[idx];
                }
                idx += 1;
            }
            return result;
        };
    };

    var _reduce = function () {
        function _arrayReduce(xf, acc, list) {
            var idx = 0;
            var len = list.length;
            while (idx < len) {
                acc = xf['@@transducer/step'](acc, list[idx]);
                if (acc && acc['@@transducer/reduced']) {
                    acc = acc['@@transducer/value'];
                    break;
                }
                idx += 1;
            }
            return xf['@@transducer/result'](acc);
        }
        function _iterableReduce(xf, acc, iter) {
            var step = iter.next();
            while (!step.done) {
                acc = xf['@@transducer/step'](acc, step.value);
                if (acc && acc['@@transducer/reduced']) {
                    acc = acc['@@transducer/value'];
                    break;
                }
                step = iter.next();
            }
            return xf['@@transducer/result'](acc);
        }
        function _methodReduce(xf, acc, obj) {
            return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));
        }
        var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
        return function _reduce(fn, acc, list) {
            if (typeof fn === 'function') {
                fn = _xwrap(fn);
            }
            if (isArrayLike(list)) {
                return _arrayReduce(fn, acc, list);
            }
            if (typeof list.reduce === 'function') {
                return _methodReduce(fn, acc, list);
            }
            if (list[symIterator] != null) {
                return _iterableReduce(fn, acc, list[symIterator]());
            }
            if (typeof list.next === 'function') {
                return _iterableReduce(fn, acc, list);
            }
            throw new TypeError('reduce: list must be array or iterable');
        };
    }();

    var _stepCat = function () {
        var _stepCatArray = {
            '@@transducer/init': Array,
            '@@transducer/step': function (xs, x) {
                xs.push(x);
                return xs;
            },
            '@@transducer/result': _identity
        };
        var _stepCatString = {
            '@@transducer/init': String,
            '@@transducer/step': function (a, b) {
                return a + b;
            },
            '@@transducer/result': _identity
        };
        var _stepCatObject = {
            '@@transducer/init': Object,
            '@@transducer/step': function (result, input) {
                return _assign(result, isArrayLike(input) ? objOf(input[0], input[1]) : input);
            },
            '@@transducer/result': _identity
        };
        return function _stepCat(obj) {
            if (_isTransformer(obj)) {
                return obj;
            }
            if (isArrayLike(obj)) {
                return _stepCatArray;
            }
            if (typeof obj === 'string') {
                return _stepCatString;
            }
            if (typeof obj === 'object') {
                return _stepCatObject;
            }
            throw new Error('Cannot create transformer for ' + obj);
        };
    }();

    var _xdropLastWhile = function () {
        function XDropLastWhile(fn, xf) {
            this.f = fn;
            this.retained = [];
            this.xf = xf;
        }
        XDropLastWhile.prototype['@@transducer/init'] = _xfBase.init;
        XDropLastWhile.prototype['@@transducer/result'] = function (result) {
            this.retained = null;
            return this.xf['@@transducer/result'](result);
        };
        XDropLastWhile.prototype['@@transducer/step'] = function (result, input) {
            return this.f(input) ? this.retain(result, input) : this.flush(result, input);
        };
        XDropLastWhile.prototype.flush = function (result, input) {
            result = _reduce(this.xf['@@transducer/step'], result, this.retained);
            this.retained = [];
            return this.xf['@@transducer/step'](result, input);
        };
        XDropLastWhile.prototype.retain = function (result, input) {
            this.retained.push(input);
            return result;
        };
        return _curry2(function _xdropLastWhile(fn, xf) {
            return new XDropLastWhile(fn, xf);
        });
    }();

    var _xgroupBy = function () {
        function XGroupBy(f, xf) {
            this.xf = xf;
            this.f = f;
            this.inputs = {};
        }
        XGroupBy.prototype['@@transducer/init'] = _xfBase.init;
        XGroupBy.prototype['@@transducer/result'] = function (result) {
            var key;
            for (key in this.inputs) {
                if (_has(key, this.inputs)) {
                    result = this.xf['@@transducer/step'](result, this.inputs[key]);
                    if (result['@@transducer/reduced']) {
                        result = result['@@transducer/value'];
                        break;
                    }
                }
            }
            this.inputs = null;
            return this.xf['@@transducer/result'](result);
        };
        XGroupBy.prototype['@@transducer/step'] = function (result, input) {
            var key = this.f(input);
            this.inputs[key] = this.inputs[key] || [
                key,
                []
            ];
            this.inputs[key][1] = append(input, this.inputs[key][1]);
            return result;
        };
        return _curry2(function _xgroupBy(f, xf) {
            return new XGroupBy(f, xf);
        });
    }();

    /**
     * Creates a new list iteration function from an existing one by adding two new
     * parameters to its callback function: the current index, and the entire list.
     *
     * This would turn, for instance, Ramda's simple `map` function into one that
     * more closely resembles `Array.prototype.map`. Note that this will only work
     * for functions in which the iteration callback function is the first
     * parameter, and where the list is the last parameter. (This latter might be
     * unimportant if the list parameter is not used.)
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category Function
     * @category List
     * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
     * @param {Function} fn A list iteration function that does not pass index or list to its callback
     * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
     * @example
     *
     *      var mapIndexed = R.addIndex(R.map);
     *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
     *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
     */
    var addIndex = _curry1(function addIndex(fn) {
        return curryN(fn.length, function () {
            var idx = 0;
            var origFn = arguments[0];
            var list = arguments[arguments.length - 1];
            var args = _slice(arguments);
            args[0] = function () {
                var result = origFn.apply(this, _concat(arguments, [
                    idx,
                    list
                ]));
                idx += 1;
                return result;
            };
            return fn.apply(this, args);
        });
    });

    /**
     * Wraps a function of any arity (including nullary) in a function that accepts
     * exactly 2 parameters. Any extraneous parameters will not be passed to the
     * supplied function.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Function
     * @sig (* -> c) -> (a, b -> c)
     * @param {Function} fn The function to wrap.
     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
     *         arity 2.
     * @example
     *
     *      var takesThreeArgs = function(a, b, c) {
     *        return [a, b, c];
     *      };
     *      takesThreeArgs.length; //=> 3
     *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
     *
     *      var takesTwoArgs = R.binary(takesThreeArgs);
     *      takesTwoArgs.length; //=> 2
     *      // Only 2 arguments are passed to the wrapped function
     *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
     */
    var binary = _curry1(function binary(fn) {
        return nAry(2, fn);
    });

    /**
     * Creates a deep copy of the value which may contain (nested) `Array`s and
     * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are not
     * copied, but assigned by their reference.
     *
     * Dispatches to a `clone` method if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {*} -> {*}
     * @param {*} value The object or array to clone
     * @return {*} A new object or array.
     * @example
     *
     *      var objects = [{}, {}, {}];
     *      var objectsClone = R.clone(objects);
     *      objects[0] === objectsClone[0]; //=> false
     */
    var clone = _curry1(function clone(value) {
        return value != null && typeof value.clone === 'function' ? value.clone() : _clone(value, [], [], true);
    });

    /**
     * Returns a curried equivalent of the provided function. The curried function
     * has two unusual capabilities. First, its arguments needn't be provided one
     * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
     * following are equivalent:
     *
     *   - `g(1)(2)(3)`
     *   - `g(1)(2, 3)`
     *   - `g(1, 2)(3)`
     *   - `g(1, 2, 3)`
     *
     * Secondly, the special placeholder value `R.__` may be used to specify
     * "gaps", allowing partial application of any combination of arguments,
     * regardless of their positions. If `g` is as above and `_` is `R.__`, the
     * following are equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (* -> a) -> (* -> a)
     * @param {Function} fn The function to curry.
     * @return {Function} A new, curried function.
     * @see R.curryN
     * @example
     *
     *      var addFourNumbers = (a, b, c, d) => a + b + c + d;
     *
     *      var curriedAddFourNumbers = R.curry(addFourNumbers);
     *      var f = curriedAddFourNumbers(1, 2);
     *      var g = f(3);
     *      g(4); //=> 10
     */
    var curry = _curry1(function curry(fn) {
        return curryN(fn.length, fn);
    });

    /**
     * Returns all but the first `n` elements of the given list, string, or
     * transducer/transformer (or object with a `drop` method).
     *
     * Dispatches to the `drop` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n
     * @param {*} list
     * @return {*}
     * @see R.take, R.transduce
     * @example
     *
     *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
     *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
     *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
     *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
     *      R.drop(3, 'ramda');               //=> 'da'
     */
    var drop = _curry2(_dispatchable('drop', _xdrop, function drop(n, xs) {
        return slice(Math.max(0, n), Infinity, xs);
    }));

    /**
     * Returns a list containing all but the last `n` elements of the given `list`.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n The number of elements of `xs` to skip.
     * @param {Array} xs The collection to consider.
     * @return {Array}
     * @see R.takeLast
     * @example
     *
     *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
     *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
     *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
     *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
     *      R.dropLast(3, 'ramda');               //=> 'ra'
     */
    var dropLast = _curry2(_dispatchable('dropLast', _xdropLast, _dropLast));

    /**
     * Returns a new list containing all but last the`n` elements of a given list,
     * passing each value from the right to the supplied predicate function,
     * skipping elements while the predicate function returns `true`. The predicate
     * function is passed one argument: (value)*.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.takeLastWhile, R.addIndex
     * @example
     *
     *      var lteThree = x => x <= 3;
     *
     *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]
     */
    var dropLastWhile = _curry2(_dispatchable('dropLastWhile', _xdropLastWhile, _dropLastWhile));

    /**
     * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
     * cyclical data structures.
     *
     * Dispatches symmetrically to the `equals` methods of both arguments, if
     * present.
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category Relation
     * @sig a -> b -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @example
     *
     *      R.equals(1, 1); //=> true
     *      R.equals(1, '1'); //=> false
     *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
     *
     *      var a = {}; a.v = a;
     *      var b = {}; b.v = b;
     *      R.equals(a, b); //=> true
     */
    var equals = _curry2(function equals(a, b) {
        return _equals(a, b, [], []);
    });

    /**
     * Takes a predicate and a "filterable", and returns a new filterable of the
     * same type containing the members of the given filterable which satisfy the
     * given predicate.
     *
     * Dispatches to the `filter` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Filterable f => (a -> Boolean) -> f a -> f a
     * @param {Function} pred
     * @param {Array} filterable
     * @return {Array}
     * @see R.reject, R.transduce, R.addIndex
     * @example
     *
     *      var isEven = n => n % 2 === 0;
     *
     *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
     *
     *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
     */
    // else
    var filter = _curry2(_dispatchable('filter', _xfilter, function (pred, filterable) {
        return _isObject(filterable) ? _reduce(function (acc, key) {
            if (pred(filterable[key])) {
                acc[key] = filterable[key];
            }
            return acc;
        }, {}, keys(filterable)) : // else
        _filter(pred, filterable);
    }));

    /**
     * Returns a new list by pulling every item out of it (and all its sub-arrays)
     * and putting them in a new array, depth-first.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [b]
     * @param {Array} list The array to consider.
     * @return {Array} The flattened list.
     * @see R.unnest
     * @example
     *
     *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
     *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
     */
    var flatten = _curry1(_makeFlat(true));

    /**
     * Returns a new function much like the supplied one, except that the first two
     * arguments' order is reversed.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z)
     * @param {Function} fn The function to invoke with its first two parameters reversed.
     * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
     * @example
     *
     *      var mergeThree = (a, b, c) => [].concat(a, b, c);
     *
     *      mergeThree(1, 2, 3); //=> [1, 2, 3]
     *
     *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
     */
    var flip = _curry1(function flip(fn) {
        return curry(function (a, b) {
            var args = _slice(arguments);
            args[0] = b;
            args[1] = a;
            return fn.apply(this, args);
        });
    });

    /**
     * Returns the first element of the given list or string. In some libraries
     * this function is named `first`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> a | Undefined
     * @sig String -> String
     * @param {Array|String} list
     * @return {*}
     * @see R.tail, R.init, R.last
     * @example
     *
     *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
     *      R.head([]); //=> undefined
     *
     *      R.head('abc'); //=> 'a'
     *      R.head(''); //=> ''
     */
    var head = nth(0);

    /**
     * Returns all but the last element of the given list or string.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category List
     * @sig [a] -> [a]
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @see R.last, R.head, R.tail
     * @example
     *
     *      R.init([1, 2, 3]);  //=> [1, 2]
     *      R.init([1, 2]);     //=> [1]
     *      R.init([1]);        //=> []
     *      R.init([]);         //=> []
     *
     *      R.init('abc');  //=> 'ab'
     *      R.init('ab');   //=> 'a'
     *      R.init('a');    //=> ''
     *      R.init('');     //=> ''
     */
    var init = slice(0, -1);

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of those
     * elements common to both lists. Duplication is determined according to the
     * value returned by applying the supplied predicate to two list elements.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
     * @param {Function} pred A predicate function that determines whether
     *        the two supplied elements are equal.
     * @param {Array} list1 One list of items to compare
     * @param {Array} list2 A second list of items to compare
     * @return {Array} A new list containing those elements common to both lists.
     * @see R.intersection
     * @example
     *
     *      var buffaloSpringfield = [
     *        {id: 824, name: 'Richie Furay'},
     *        {id: 956, name: 'Dewey Martin'},
     *        {id: 313, name: 'Bruce Palmer'},
     *        {id: 456, name: 'Stephen Stills'},
     *        {id: 177, name: 'Neil Young'}
     *      ];
     *      var csny = [
     *        {id: 204, name: 'David Crosby'},
     *        {id: 456, name: 'Stephen Stills'},
     *        {id: 539, name: 'Graham Nash'},
     *        {id: 177, name: 'Neil Young'}
     *      ];
     *
     *      R.intersectionWith(R.eqBy(R.prop('id')), buffaloSpringfield, csny);
     *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
     */
    var intersectionWith = _curry3(function intersectionWith(pred, list1, list2) {
        var lookupList, filteredList;
        if (list1.length > list2.length) {
            lookupList = list1;
            filteredList = list2;
        } else {
            lookupList = list2;
            filteredList = list1;
        }
        var results = [];
        var idx = 0;
        while (idx < filteredList.length) {
            if (_containsWith(pred, filteredList[idx], lookupList)) {
                results[results.length] = filteredList[idx];
            }
            idx += 1;
        }
        return uniqWith(pred, results);
    });

    /**
     * Transforms the items of the list with the transducer and appends the
     * transformed items to the accumulator using an appropriate iterator function
     * based on the accumulator type.
     *
     * The accumulator can be an array, string, object or a transformer. Iterated
     * items will be appended to arrays and concatenated to strings. Objects will
     * be merged directly or 2-item arrays will be merged as key, value pairs.
     *
     * The accumulator can also be a transformer object that provides a 2-arity
     * reducing iterator function, step, 0-arity initial value function, init, and
     * 1-arity result extraction function result. The step function is used as the
     * iterator function in reduce. The result function is used to convert the
     * final accumulator into the return type and in most cases is R.identity. The
     * init function is used to provide the initial accumulator.
     *
     * The iteration is performed with R.reduce after initializing the transducer.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category List
     * @sig a -> (b -> b) -> [c] -> a
     * @param {*} acc The initial accumulator value.
     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @example
     *
     *      var numbers = [1, 2, 3, 4];
     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
     *
     *      R.into([], transducer, numbers); //=> [2, 3]
     *
     *      var intoArray = R.into([]);
     *      intoArray(transducer, numbers); //=> [2, 3]
     */
    var into = _curry3(function into(acc, xf, list) {
        return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), _clone(acc, [], [], false), list);
    });

    /**
     * Same as R.invertObj, however this accounts for objects with duplicate values
     * by putting the values into an array.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Object
     * @sig {s: x} -> {x: [ s, ... ]}
     * @param {Object} obj The object or array to invert
     * @return {Object} out A new object with keys
     * in an array.
     * @example
     *
     *      var raceResultsByFirstName = {
     *        first: 'alice',
     *        second: 'jake',
     *        third: 'alice',
     *      };
     *      R.invert(raceResultsByFirstName);
     *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
     */
    var invert = _curry1(function invert(obj) {
        var props = keys(obj);
        var len = props.length;
        var idx = 0;
        var out = {};
        while (idx < len) {
            var key = props[idx];
            var val = obj[key];
            var list = _has(val, out) ? out[val] : out[val] = [];
            list[list.length] = key;
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a new object with the keys of the given object as values, and the
     * values of the given object, which are coerced to strings, as keys. Note
     * that the last key found is preferred when handling the same value.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Object
     * @sig {s: x} -> {x: s}
     * @param {Object} obj The object or array to invert
     * @return {Object} out A new object
     * @example
     *
     *      var raceResults = {
     *        first: 'alice',
     *        second: 'jake'
     *      };
     *      R.invertObj(raceResults);
     *      //=> { 'alice': 'first', 'jake':'second' }
     *
     *      // Alternatively:
     *      var raceResults = ['alice', 'jake'];
     *      R.invertObj(raceResults);
     *      //=> { 'alice': '0', 'jake':'1' }
     */
    var invertObj = _curry1(function invertObj(obj) {
        var props = keys(obj);
        var len = props.length;
        var idx = 0;
        var out = {};
        while (idx < len) {
            var key = props[idx];
            out[obj[key]] = key;
            idx += 1;
        }
        return out;
    });

    /**
     * Returns `true` if the given value is its type's empty value; `false`
     * otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Logic
     * @sig a -> Boolean
     * @param {*} x
     * @return {Boolean}
     * @see R.empty
     * @example
     *
     *      R.isEmpty([1, 2, 3]);   //=> false
     *      R.isEmpty([]);          //=> true
     *      R.isEmpty('');          //=> true
     *      R.isEmpty(null);        //=> false
     *      R.isEmpty({});          //=> true
     *      R.isEmpty({length: 0}); //=> false
     */
    var isEmpty = _curry1(function isEmpty(x) {
        return x != null && equals(x, empty(x));
    });

    /**
     * Returns the last element of the given list or string.
     *
     * @func
     * @memberOf R
     * @since v0.1.4
     * @category List
     * @sig [a] -> a | Undefined
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @see R.init, R.head, R.tail
     * @example
     *
     *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
     *      R.last([]); //=> undefined
     *
     *      R.last('abc'); //=> 'c'
     *      R.last(''); //=> ''
     */
    var last = nth(-1);

    /**
     * Returns the position of the last occurrence of an item in an array, or -1 if
     * the item is not included in the array. `R.equals` is used to determine
     * equality.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> Number
     * @param {*} target The item to find.
     * @param {Array} xs The array to search in.
     * @return {Number} the index of the target, or -1 if the target is not found.
     * @see R.indexOf
     * @example
     *
     *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
     *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
     */
    var lastIndexOf = _curry2(function lastIndexOf(target, xs) {
        if (typeof xs.lastIndexOf === 'function' && !_isArray(xs)) {
            return xs.lastIndexOf(target);
        } else {
            var idx = xs.length - 1;
            while (idx >= 0) {
                if (equals(xs[idx], target)) {
                    return idx;
                }
                idx -= 1;
            }
            return -1;
        }
    });

    /**
     * Takes a function and
     * a [functor](https://github.com/fantasyland/fantasy-land#functor),
     * applies the function to each of the functor's values, and returns
     * a functor of the same shape.
     *
     * Ramda provides suitable `map` implementations for `Array` and `Object`,
     * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
     *
     * Dispatches to the `map` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * Also treats functions as functors and will compose them together.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Functor f => (a -> b) -> f a -> f b
     * @param {Function} fn The function to be called on every element of the input `list`.
     * @param {Array} list The list to be iterated over.
     * @return {Array} The new list.
     * @see R.transduce, R.addIndex
     * @example
     *
     *      var double = x => x * 2;
     *
     *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
     *
     *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
     */
    var map = _curry2(_dispatchable('map', _xmap, function map(fn, functor) {
        switch (Object.prototype.toString.call(functor)) {
        case '[object Function]':
            return curryN(functor.length, function () {
                return fn.call(this, functor.apply(this, arguments));
            });
        case '[object Object]':
            return _reduce(function (acc, key) {
                acc[key] = fn(functor[key]);
                return acc;
            }, {}, keys(functor));
        default:
            return _map(fn, functor);
        }
    }));

    /**
     * An Object-specific version of `map`. The function is applied to three
     * arguments: *(value, key, obj)*. If only the value is significant, use
     * `map` instead.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Object
     * @sig ((*, String, Object) -> *) -> Object -> Object
     * @param {Function} fn
     * @param {Object} obj
     * @return {Object}
     * @see R.map
     * @example
     *
     *      var values = { x: 1, y: 2, z: 3 };
     *      var prependKeyAndDouble = (num, key, obj) => key + (num * 2);
     *
     *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }
     */
    var mapObjIndexed = _curry2(function mapObjIndexed(fn, obj) {
        return _reduce(function (acc, key) {
            acc[key] = fn(obj[key], key, obj);
            return acc;
        }, {}, keys(obj));
    });

    /**
     * Creates a new object with the own properties of the two provided objects. If
     * a key exists in both objects, the provided function is applied to the values
     * associated with the key in each object, with the result being used as the
     * value associated with the key in the returned object. The key will be
     * excluded from the returned object if the resulting value is `undefined`.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Object
     * @sig (a -> a -> a) -> {a} -> {a} -> {a}
     * @param {Function} fn
     * @param {Object} l
     * @param {Object} r
     * @return {Object}
     * @see R.merge, R.mergeWithKey
     * @example
     *
     *      R.mergeWith(R.concat,
     *                  { a: true, values: [10, 20] },
     *                  { b: true, values: [15, 35] });
     *      //=> { a: true, b: true, values: [10, 20, 15, 35] }
     */
    var mergeWith = _curry3(function mergeWith(fn, l, r) {
        return mergeWithKey(function (_, _l, _r) {
            return fn(_l, _r);
        }, l, r);
    });

    /**
     * Takes a function `f` and a list of arguments, and returns a function `g`.
     * When applied, `g` returns the result of applying `f` to the arguments
     * provided initially followed by the arguments provided to `g`.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Function
     * @sig ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x)
     * @param {Function} f
     * @param {Array} args
     * @return {Function}
     * @see R.partialRight
     * @example
     *
     *      var multiply = (a, b) => a * b;
     *      var double = R.partial(multiply, [2]);
     *      double(2); //=> 4
     *
     *      var greet = (salutation, title, firstName, lastName) =>
     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
     *
     *      var sayHello = R.partial(greet, ['Hello']);
     *      var sayHelloToMs = R.partial(sayHello, ['Ms.']);
     *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
     */
    var partial = _createPartialApplicator(_concat);

    /**
     * Takes a function `f` and a list of arguments, and returns a function `g`.
     * When applied, `g` returns the result of applying `f` to the arguments
     * provided to `g` followed by the arguments provided initially.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Function
     * @sig ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)
     * @param {Function} f
     * @param {Array} args
     * @return {Function}
     * @see R.partial
     * @example
     *
     *      var greet = (salutation, title, firstName, lastName) =>
     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
     *
     *      var greetMsJaneJones = R.partialRight(greet, ['Ms.', 'Jane', 'Jones']);
     *
     *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
     */
    var partialRight = _createPartialApplicator(flip(_concat));

    /**
     * Determines whether a nested path on an object has a specific value, in
     * `R.equals` terms. Most likely used to filter a list.
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Relation
     * @sig [String] -> * -> {String: *} -> Boolean
     * @param {Array} path The path of the nested property to use
     * @param {*} val The value to compare the nested property with
     * @param {Object} obj The object to check the nested property in
     * @return {Boolean} `true` if the value equals the nested object property,
     *         `false` otherwise.
     * @example
     *
     *      var user1 = { address: { zipCode: 90210 } };
     *      var user2 = { address: { zipCode: 55555 } };
     *      var user3 = { name: 'Bob' };
     *      var users = [ user1, user2, user3 ];
     *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);
     *      R.filter(isFamous, users); //=> [ user1 ]
     */
    var pathEq = _curry3(function pathEq(_path, val, obj) {
        return equals(path(_path, obj), val);
    });

    /**
     * Returns a new list by plucking the same named property off all objects in
     * the list supplied.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig k -> [{k: v}] -> [v]
     * @param {Number|String} key The key name to pluck off of each object.
     * @param {Array} list The array to consider.
     * @return {Array} The list of values for the given key.
     * @see R.props
     * @example
     *
     *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
     *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
     */
    var pluck = _curry2(function pluck(p, list) {
        return map(prop(p), list);
    });

    /**
     * Reasonable analog to SQL `select` statement.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @category Relation
     * @sig [k] -> [{k: v}] -> [{k: v}]
     * @param {Array} props The property names to project
     * @param {Array} objs The objects to query
     * @return {Array} An array of objects with just the `props` properties.
     * @example
     *
     *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
     *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
     *      var kids = [abby, fred];
     *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
     */
    // passing `identity` gives correct arity
    var project = useWith(_map, [
        pickAll,
        identity
    ]);

    /**
     * Returns `true` if the specified object property is equal, in `R.equals`
     * terms, to the given value; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig String -> a -> Object -> Boolean
     * @param {String} name
     * @param {*} val
     * @param {*} obj
     * @return {Boolean}
     * @see R.equals, R.propSatisfies
     * @example
     *
     *      var abby = {name: 'Abby', age: 7, hair: 'blond'};
     *      var fred = {name: 'Fred', age: 12, hair: 'brown'};
     *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};
     *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};
     *      var kids = [abby, fred, rusty, alois];
     *      var hasBrownHair = R.propEq('hair', 'brown');
     *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
     */
    var propEq = _curry3(function propEq(name, val, obj) {
        return propSatisfies(equals(val), name, obj);
    });

    /**
     * Returns `true` if the specified object property is of the given type;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Type
     * @sig Type -> String -> Object -> Boolean
     * @param {Function} type
     * @param {String} name
     * @param {*} obj
     * @return {Boolean}
     * @see R.is, R.propSatisfies
     * @example
     *
     *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
     *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
     *      R.propIs(Number, 'x', {});            //=> false
     */
    var propIs = _curry3(function propIs(type, name, obj) {
        return propSatisfies(is(type), name, obj);
    });

    /**
     * Returns a single item by iterating through the list, successively calling
     * the iterator function and passing it an accumulator value and the current
     * value from the array, and then passing the result to the next call.
     *
     * The iterator function receives two values: *(acc, value)*. It may use
     * `R.reduced` to shortcut the iteration.
     *
     * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
     * arrays), unlike the native `Array.prototype.reduce` method. For more details
     * on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
     *
     * Dispatches to the `reduce` method of the third argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig ((a, b) -> a) -> a -> [b] -> a
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.reduced, R.addIndex
     * @example
     *
     *      var numbers = [1, 2, 3];
     *      var add = (a, b) => a + b;
     *
     *      R.reduce(add, 10, numbers); //=> 16
     */
    var reduce = _curry3(_reduce);

    /**
     * Groups the elements of the list according to the result of calling
     * the String-returning function `keyFn` on each element and reduces the elements
     * of each group to a single value via the reducer function `valueFn`.
     *
     * This function is basically a more general `groupBy` function.
     *
     * @func
     * @memberOf R
     * @since v0.20.0
     * @category List
     * @sig ((a, b) -> a) -> a -> (b -> String) -> [b] -> {String: a}
     * @param {Function} valueFn The function that reduces the elements of each group to a single
     *        value. Receives two values, accumulator for a particular group and the current element.
     * @param {*} acc The (initial) accumulator value for each group.
     * @param {Function} keyFn The function that maps the list's element into a key.
     * @param {Array} list The array to group.
     * @return {Object} An object with the output of `keyFn` for keys, mapped to the output of
     *         `valueFn` for elements which produced that key when passed to `keyFn`.
     * @see R.groupBy, R.reduce
     * @example
     *
     *      var reduceToNamesBy = R.reduceBy((acc, student) => acc.concat(student.name), []);
     *      var namesByGrade = reduceToNamesBy(function(student) {
     *        var score = student.score;
     *        return score < 65 ? 'F' :
     *               score < 70 ? 'D' :
     *               score < 80 ? 'C' :
     *               score < 90 ? 'B' : 'A';
     *      });
     *      var students = [{name: 'Lucy', score: 92},
     *                      {name: 'Drew', score: 85},
     *                      // ...
     *                      {name: 'Bart', score: 62}];
     *      namesByGrade(students);
     *      // {
     *      //   'A': ['Lucy'],
     *      //   'B': ['Drew']
     *      //   // ...,
     *      //   'F': ['Bart']
     *      // }
     */
    var reduceBy = _curryN(4, [], function reduceBy(valueFn, valueAcc, keyFn, list) {
        return _reduce(function (acc, elt) {
            var key = keyFn(elt);
            acc[key] = valueFn(_has(key, acc) ? acc[key] : valueAcc, elt);
            return acc;
        }, {}, list);
    });

    /**
     * The complement of `filter`.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Filterable f => (a -> Boolean) -> f a -> f a
     * @param {Function} pred
     * @param {Array} filterable
     * @return {Array}
     * @see R.filter, R.transduce, R.addIndex
     * @example
     *
     *      var isOdd = (n) => n % 2 === 1;
     *
     *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
     *
     *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
     */
    var reject = _curry2(function reject(pred, filterable) {
        return filter(_complement(pred), filterable);
    });

    /**
     * Returns a fixed list of size `n` containing a specified identical value.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig a -> n -> [a]
     * @param {*} value The value to repeat.
     * @param {Number} n The desired size of the output list.
     * @return {Array} A new array containing `n` `value`s.
     * @example
     *
     *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
     *
     *      var obj = {};
     *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
     *      repeatedObjs[0] === repeatedObjs[1]; //=> true
     */
    var repeat = _curry2(function repeat(value, n) {
        return times(always(value), n);
    });

    /**
     * Adds together all the elements of a list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list An array of numbers
     * @return {Number} The sum of all the numbers in the list.
     * @see R.reduce
     * @example
     *
     *      R.sum([2,4,6,8,100,1]); //=> 121
     */
    var sum = reduce(add, 0);

    /**
     * Returns a new list containing the last `n` elements of the given list.
     * If `n > list.length`, returns a list of `list.length` elements.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n The number of elements to return.
     * @param {Array} xs The collection to consider.
     * @return {Array}
     * @see R.dropLast
     * @example
     *
     *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
     *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
     *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.takeLast(3, 'ramda');               //=> 'mda'
     */
    var takeLast = _curry2(function takeLast(n, xs) {
        return drop(n >= 0 ? xs.length - n : 0, xs);
    });

    /**
     * Initializes a transducer using supplied iterator function. Returns a single
     * item by iterating through the list, successively calling the transformed
     * iterator function and passing it an accumulator value and the current value
     * from the array, and then passing the result to the next call.
     *
     * The iterator function receives two values: *(acc, value)*. It will be
     * wrapped as a transformer to initialize the transducer. A transformer can be
     * passed directly in place of an iterator function. In both cases, iteration
     * may be stopped early with the `R.reduced` function.
     *
     * A transducer is a function that accepts a transformer and returns a
     * transformer and can be composed directly.
     *
     * A transformer is an an object that provides a 2-arity reducing iterator
     * function, step, 0-arity initial value function, init, and 1-arity result
     * extraction function, result. The step function is used as the iterator
     * function in reduce. The result function is used to convert the final
     * accumulator into the return type and in most cases is R.identity. The init
     * function can be used to provide an initial accumulator, but is ignored by
     * transduce.
     *
     * The iteration is performed with R.reduce after initializing the transducer.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category List
     * @sig (c -> c) -> (a,b -> a) -> a -> [b] -> a
     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array. Wrapped as transformer, if necessary, and used to
     *        initialize the transducer
     * @param {*} acc The initial accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.reduce, R.reduced, R.into
     * @example
     *
     *      var numbers = [1, 2, 3, 4];
     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
     *
     *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
     */
    var transduce = curryN(4, function transduce(xf, fn, acc, list) {
        return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
    });

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of the elements
     * of each list. Duplication is determined according to the value returned by
     * applying the supplied predicate to two list elements.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The first and second lists concatenated, with
     *         duplicates removed.
     * @see R.union
     * @example
     *
     *      var l1 = [{a: 1}, {a: 2}];
     *      var l2 = [{a: 1}, {a: 4}];
     *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
     */
    var unionWith = _curry3(function unionWith(pred, list1, list2) {
        return uniqWith(pred, _concat(list1, list2));
    });

    /**
     * Takes a spec object and a test object; returns true if the test satisfies
     * the spec, false otherwise. An object satisfies the spec if, for each of the
     * spec's own properties, accessing that property of the object gives the same
     * value (in `R.equals` terms) as accessing that property of the spec.
     *
     * `whereEq` is a specialization of [`where`](#where).
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Object
     * @sig {String: *} -> {String: *} -> Boolean
     * @param {Object} spec
     * @param {Object} testObj
     * @return {Boolean}
     * @see R.where
     * @example
     *
     *      // pred :: Object -> Boolean
     *      var pred = R.whereEq({a: 1, b: 2});
     *
     *      pred({a: 1});              //=> false
     *      pred({a: 1, b: 2});        //=> true
     *      pred({a: 1, b: 2, c: 3});  //=> true
     *      pred({a: 1, b: 1});        //=> false
     */
    var whereEq = _curry2(function whereEq(spec, testObj) {
        return where(map(equals, spec), testObj);
    });

    var _flatCat = function () {
        var preservingReduced = function (xf) {
            return {
                '@@transducer/init': _xfBase.init,
                '@@transducer/result': function (result) {
                    return xf['@@transducer/result'](result);
                },
                '@@transducer/step': function (result, input) {
                    var ret = xf['@@transducer/step'](result, input);
                    return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
                }
            };
        };
        return function _xcat(xf) {
            var rxf = preservingReduced(xf);
            return {
                '@@transducer/init': _xfBase.init,
                '@@transducer/result': function (result) {
                    return rxf['@@transducer/result'](result);
                },
                '@@transducer/step': function (result, input) {
                    return !isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
                }
            };
        };
    }();

    // Array.prototype.indexOf doesn't exist below IE9
    // manually crawl the list to distinguish between +0 and -0
    // NaN
    // non-zero numbers can utilise Set
    // all these types can utilise Set
    // null can utilise Set
    // anything else not covered above, defer to R.equals
    var _indexOf = function _indexOf(list, a, idx) {
        var inf, item;
        // Array.prototype.indexOf doesn't exist below IE9
        if (typeof list.indexOf === 'function') {
            switch (typeof a) {
            case 'number':
                if (a === 0) {
                    // manually crawl the list to distinguish between +0 and -0
                    inf = 1 / a;
                    while (idx < list.length) {
                        item = list[idx];
                        if (item === 0 && 1 / item === inf) {
                            return idx;
                        }
                        idx += 1;
                    }
                    return -1;
                } else if (a !== a) {
                    // NaN
                    while (idx < list.length) {
                        item = list[idx];
                        if (typeof item === 'number' && item !== item) {
                            return idx;
                        }
                        idx += 1;
                    }
                    return -1;
                }
                // non-zero numbers can utilise Set
                return list.indexOf(a, idx);
            // all these types can utilise Set
            case 'string':
            case 'boolean':
            case 'function':
            case 'undefined':
                return list.indexOf(a, idx);
            case 'object':
                if (a === null) {
                    // null can utilise Set
                    return list.indexOf(a, idx);
                }
            }
        }
        // anything else not covered above, defer to R.equals
        while (idx < list.length) {
            if (equals(list[idx], a)) {
                return idx;
            }
            idx += 1;
        }
        return -1;
    };

    var _xchain = _curry2(function _xchain(f, xf) {
        return map(f, _flatCat(xf));
    });

    /**
     * Takes a list of predicates and returns a predicate that returns true for a
     * given list of arguments if every one of the provided predicates is satisfied
     * by those arguments.
     *
     * The function returned is a curried function whose arity matches that of the
     * highest-arity predicate.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Logic
     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
     * @param {Array} preds
     * @return {Function}
     * @see R.anyPass
     * @example
     *
     *      var isQueen = R.propEq('rank', 'Q');
     *      var isSpade = R.propEq('suit', '');
     *      var isQueenOfSpades = R.allPass([isQueen, isSpade]);
     *
     *      isQueenOfSpades({rank: 'Q', suit: ''}); //=> false
     *      isQueenOfSpades({rank: 'Q', suit: ''}); //=> true
     */
    var allPass = _curry1(function allPass(preds) {
        return curryN(reduce(max, 0, pluck('length', preds)), function () {
            var idx = 0;
            var len = preds.length;
            while (idx < len) {
                if (!preds[idx].apply(this, arguments)) {
                    return false;
                }
                idx += 1;
            }
            return true;
        });
    });

    /**
     * Returns `true` if all elements are unique, in `R.equals` terms, otherwise
     * `false`.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category List
     * @sig [a] -> Boolean
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if all elements are unique, else `false`.
     * @deprecated since v0.20.0
     * @example
     *
     *      R.allUniq(['1', 1]); //=> true
     *      R.allUniq([1, 1]);   //=> false
     *      R.allUniq([[42], [42]]); //=> false
     */
    var allUniq = _curry1(function allUniq(list) {
        var len = list.length;
        var idx = 0;
        while (idx < len) {
            if (_indexOf(list, list[idx], idx + 1) >= 0) {
                return false;
            }
            idx += 1;
        }
        return true;
    });

    /**
     * Takes a list of predicates and returns a predicate that returns true for a
     * given list of arguments if at least one of the provided predicates is
     * satisfied by those arguments.
     *
     * The function returned is a curried function whose arity matches that of the
     * highest-arity predicate.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Logic
     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
     * @param {Array} preds
     * @return {Function}
     * @see R.allPass
     * @example
     *
     *      var gte = R.anyPass([R.gt, R.equals]);
     *
     *      gte(3, 2); //=> true
     *      gte(2, 2); //=> true
     *      gte(2, 3); //=> false
     */
    var anyPass = _curry1(function anyPass(preds) {
        return curryN(reduce(max, 0, pluck('length', preds)), function () {
            var idx = 0;
            var len = preds.length;
            while (idx < len) {
                if (preds[idx].apply(this, arguments)) {
                    return true;
                }
                idx += 1;
            }
            return false;
        });
    });

    /**
     * ap applies a list of functions to a list of values.
     *
     * Dispatches to the `ap` method of the second argument, if present. Also
     * treats functions as applicatives.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Function
     * @sig [f] -> [a] -> [f a]
     * @param {Array} fns An array of functions
     * @param {Array} vs An array of values
     * @return {Array} An array of results of applying each of `fns` to all of `vs` in turn.
     * @example
     *
     *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
     */
    // else
    var ap = _curry2(function ap(applicative, fn) {
        return typeof applicative.ap === 'function' ? applicative.ap(fn) : typeof applicative === 'function' ? curryN(Math.max(applicative.length, fn.length), function () {
            return applicative.apply(this, arguments)(fn.apply(this, arguments));
        }) : // else
        _reduce(function (acc, f) {
            return _concat(acc, map(f, fn));
        }, [], applicative);
    });

    /**
     * Given a spec object recursively mapping properties to functions, creates a
     * function producing an object of the same structure, by mapping each property
     * to the result of calling its associated function with the supplied arguments.
     *
     * @func
     * @memberOf R
     * @since v0.20.0
     * @category Function
     * @sig {k: ((a, b, ..., m) -> v)} -> ((a, b, ..., m) -> {k: v})
     * @param {Object} spec an object recursively mapping properties to functions for
     *        producing the values for these properties.
     * @return {Function} A function that returns an object of the same structure
     * as `spec', with each property set to the value returned by calling its
     * associated function with the supplied arguments.
     * @see R.juxt
     * @example
     *
     *      var getMetrics = R.applySpec({
     *                                      sum: R.add,
     *                                      nested: { mul: R.multiply }
     *                                   });
     *      getMetrics(2, 4); // => { sum: 6, nested: { mul: 8 } }
     */
    var applySpec = _curry1(function applySpec(spec) {
        spec = map(function (v) {
            return typeof v == 'function' ? v : applySpec(v);
        }, spec);
        return curryN(reduce(max, 0, pluck('length', values(spec))), function () {
            var args = arguments;
            return map(function (f) {
                return apply(f, args);
            }, spec);
        });
    });

    /**
     * Returns the result of calling its first argument with the remaining
     * arguments. This is occasionally useful as a converging function for
     * `R.converge`: the left branch can produce a function while the right branch
     * produces a value to be passed to that function as an argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Function
     * @sig (*... -> a),*... -> a
     * @param {Function} fn The function to apply to the remaining arguments.
     * @param {...*} args Any number of positional arguments.
     * @return {*}
     * @see R.apply
     * @example
     *
     *      var indentN = R.pipe(R.times(R.always(' ')),
     *                           R.join(''),
     *                           R.replace(/^(?!$)/gm));
     *
     *      var format = R.converge(R.call, [
     *                                  R.pipe(R.prop('indent'), indentN),
     *                                  R.prop('value')
     *                              ]);
     *
     *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
     */
    var call = curry(function call(fn) {
        return fn.apply(this, _slice(arguments, 1));
    });

    /**
     * `chain` maps a function over a list and concatenates the results. `chain`
     * is also known as `flatMap` in some libraries
     *
     * Dispatches to the `chain` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig (a -> [b]) -> [a] -> [b]
     * @param {Function} fn
     * @param {Array} list
     * @return {Array}
     * @example
     *
     *      var duplicate = n => [n, n];
     *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
     */
    var chain = _curry2(_dispatchable('chain', _xchain, function chain(fn, monad) {
        if (typeof monad === 'function') {
            return function () {
                return monad.call(this, fn.apply(this, arguments)).apply(this, arguments);
            };
        }
        return _makeFlat(false)(map(fn, monad));
    }));

    /**
     * Returns a function, `fn`, which encapsulates if/else-if/else logic.
     * `R.cond` takes a list of [predicate, transform] pairs. All of the arguments
     * to `fn` are applied to each of the predicates in turn until one returns a
     * "truthy" value, at which point `fn` returns the result of applying its
     * arguments to the corresponding transformer. If none of the predicates
     * matches, `fn` returns undefined.
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category Logic
     * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
     * @param {Array} pairs
     * @return {Function}
     * @example
     *
     *      var fn = R.cond([
     *        [R.equals(0),   R.always('water freezes at 0C')],
     *        [R.equals(100), R.always('water boils at 100C')],
     *        [R.T,           temp => 'nothing special happens at ' + temp + 'C']
     *      ]);
     *      fn(0); //=> 'water freezes at 0C'
     *      fn(50); //=> 'nothing special happens at 50C'
     *      fn(100); //=> 'water boils at 100C'
     */
    var cond = _curry1(function cond(pairs) {
        var arity = reduce(max, 0, map(function (pair) {
            return pair[0].length;
        }, pairs));
        return _arity(arity, function () {
            var idx = 0;
            while (idx < pairs.length) {
                if (pairs[idx][0].apply(this, arguments)) {
                    return pairs[idx][1].apply(this, arguments);
                }
                idx += 1;
            }
        });
    });

    /**
     * Wraps a constructor function inside a curried function that can be called
     * with the same arguments and returns the same type. The arity of the function
     * returned is specified to allow using variadic constructor functions.
     *
     * @func
     * @memberOf R
     * @since v0.4.0
     * @category Function
     * @sig Number -> (* -> {*}) -> (* -> {*})
     * @param {Number} n The arity of the constructor function.
     * @param {Function} Fn The constructor function to wrap.
     * @return {Function} A wrapped, curried constructor function.
     * @example
     *
     *      // Variadic constructor function
     *      var Widget = () => {
     *        this.children = Array.prototype.slice.call(arguments);
     *        // ...
     *      };
     *      Widget.prototype = {
     *        // ...
     *      };
     *      var allConfigs = [
     *        // ...
     *      ];
     *      R.map(R.constructN(1, Widget), allConfigs); // a list of Widgets
     */
    var constructN = _curry2(function constructN(n, Fn) {
        if (n > 10) {
            throw new Error('Constructor with greater than ten arguments');
        }
        if (n === 0) {
            return function () {
                return new Fn();
            };
        }
        return curry(nAry(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
            switch (arguments.length) {
            case 1:
                return new Fn($0);
            case 2:
                return new Fn($0, $1);
            case 3:
                return new Fn($0, $1, $2);
            case 4:
                return new Fn($0, $1, $2, $3);
            case 5:
                return new Fn($0, $1, $2, $3, $4);
            case 6:
                return new Fn($0, $1, $2, $3, $4, $5);
            case 7:
                return new Fn($0, $1, $2, $3, $4, $5, $6);
            case 8:
                return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
            case 9:
                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
            case 10:
                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
            }
        }));
    });

    /**
     * Accepts a converging function and a list of branching functions and returns
     * a new function. When invoked, this new function is applied to some
     * arguments, each branching function is applied to those same arguments. The
     * results of each branching function are passed as arguments to the converging
     * function to produce the return value.
     *
     * @func
     * @memberOf R
     * @since v0.4.2
     * @category Function
     * @sig (x1 -> x2 -> ... -> z) -> [(a -> b -> ... -> x1), (a -> b -> ... -> x2), ...] -> (a -> b -> ... -> z)
     * @param {Function} after A function. `after` will be invoked with the return values of
     *        `fn1` and `fn2` as its arguments.
     * @param {Array} functions A list of functions.
     * @return {Function} A new function.
     * @example
     *
     *      var add = (a, b) => a + b;
     *      var multiply = (a, b) => a * b;
     *      var subtract = (a, b) => a - b;
     *
     *      // multiply( add(1, 2), subtract(1, 2) );
     *      R.converge(multiply, [add, subtract])(1, 2); //=> -3
     *
     *      var add3 = (a, b, c) => a + b + c;
     *      R.converge(add3, [multiply, add, subtract])(1, 2); //=> 4
     */
    var converge = _curry2(function converge(after, fns) {
        return curryN(reduce(max, 0, pluck('length', fns)), function () {
            var args = arguments;
            var context = this;
            return after.apply(context, _map(function (fn) {
                return fn.apply(context, args);
            }, fns));
        });
    });

    /**
     * Counts the elements of a list according to how many match each value of a
     * key generated by the supplied function. Returns an object mapping the keys
     * produced by `fn` to the number of occurrences in the list. Note that all
     * keys are coerced to strings because of how JavaScript objects work.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig (a -> String) -> [a] -> {*}
     * @param {Function} fn The function used to map values to keys.
     * @param {Array} list The list to count elements from.
     * @return {Object} An object mapping keys to number of occurrences in the list.
     * @example
     *
     *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
     *      var letters = R.split('', 'abcABCaaaBBc');
     *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
     *      R.countBy(R.toLower)(letters);   //=> {'a': 5, 'b': 4, 'c': 3}
     */
    var countBy = reduceBy(function (acc, elem) {
        return acc + 1;
    }, 0);

    /**
     * Returns a new list without any consecutively repeating elements. Equality is
     * determined by applying the supplied predicate two consecutive elements. The
     * first element in a series of equal element is the one being preserved.
     *
     * Dispatches to the `dropRepeatsWith` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig (a, a -> Boolean) -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list The array to consider.
     * @return {Array} `list` without repeating elements.
     * @see R.transduce
     * @example
     *
     *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
     *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]
     */
    var dropRepeatsWith = _curry2(_dispatchable('dropRepeatsWith', _xdropRepeatsWith, function dropRepeatsWith(pred, list) {
        var result = [];
        var idx = 1;
        var len = list.length;
        if (len !== 0) {
            result[0] = list[0];
            while (idx < len) {
                if (!pred(last(result), list[idx])) {
                    result[result.length] = list[idx];
                }
                idx += 1;
            }
        }
        return result;
    }));

    /**
     * Takes a function and two values in its domain and returns `true` if the
     * values map to the same value in the codomain; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Relation
     * @sig (a -> b) -> a -> a -> Boolean
     * @param {Function} f
     * @param {*} x
     * @param {*} y
     * @return {Boolean}
     * @example
     *
     *      R.eqBy(Math.abs, 5, -5); //=> true
     */
    var eqBy = _curry3(function eqBy(f, x, y) {
        return equals(f(x), f(y));
    });

    /**
     * Reports whether two objects have the same value, in `R.equals` terms, for
     * the specified property. Useful as a curried predicate.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig k -> {k: v} -> {k: v} -> Boolean
     * @param {String} prop The name of the property to compare
     * @param {Object} obj1
     * @param {Object} obj2
     * @return {Boolean}
     *
     * @example
     *
     *      var o1 = { a: 1, b: 2, c: 3, d: 4 };
     *      var o2 = { a: 10, b: 20, c: 3, d: 40 };
     *      R.eqProps('a', o1, o2); //=> false
     *      R.eqProps('c', o1, o2); //=> true
     */
    var eqProps = _curry3(function eqProps(prop, obj1, obj2) {
        return equals(obj1[prop], obj2[prop]);
    });

    /**
     * Splits a list into sub-lists stored in an object, based on the result of
     * calling a String-returning function on each element, and grouping the
     * results according to values returned.
     *
     * Dispatches to the `groupBy` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> String) -> [a] -> {String: [a]}
     * @param {Function} fn Function :: a -> String
     * @param {Array} list The array to group
     * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
     *         that produced that key when passed to `fn`.
     * @see R.transduce
     * @example
     *
     *      var byGrade = R.groupBy(function(student) {
     *        var score = student.score;
     *        return score < 65 ? 'F' :
     *               score < 70 ? 'D' :
     *               score < 80 ? 'C' :
     *               score < 90 ? 'B' : 'A';
     *      });
     *      var students = [{name: 'Abby', score: 84},
     *                      {name: 'Eddy', score: 58},
     *                      // ...
     *                      {name: 'Jack', score: 69}];
     *      byGrade(students);
     *      // {
     *      //   'A': [{name: 'Dianne', score: 99}],
     *      //   'B': [{name: 'Abby', score: 84}]
     *      //   // ...,
     *      //   'F': [{name: 'Eddy', score: 58}]
     *      // }
     */
    var groupBy = _curry2(_dispatchable('groupBy', _xgroupBy, reduceBy(function (acc, item) {
        if (acc == null) {
            acc = [];
        }
        acc.push(item);
        return acc;
    }, null)));

    /**
     * Given a function that generates a key, turns a list of objects into an
     * object indexing the objects by the given key. Note that if multiple
     * objects generate the same value for the indexing key only the last value
     * will be included in the generated object.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig (a -> String) -> [{k: v}] -> {k: {k: v}}
     * @param {Function} fn Function :: a -> String
     * @param {Array} array The array of objects to index
     * @return {Object} An object indexing each array element by the given property.
     * @example
     *
     *      var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];
     *      R.indexBy(R.prop('id'), list);
     *      //=> {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}}
     */
    var indexBy = reduceBy(function (acc, elem) {
        return elem;
    }, null);

    /**
     * Returns the position of the first occurrence of an item in an array, or -1
     * if the item is not included in the array. `R.equals` is used to determine
     * equality.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> Number
     * @param {*} target The item to find.
     * @param {Array} xs The array to search in.
     * @return {Number} the index of the target, or -1 if the target is not found.
     * @see R.lastIndexOf
     * @example
     *
     *      R.indexOf(3, [1,2,3,4]); //=> 2
     *      R.indexOf(10, [1,2,3,4]); //=> -1
     */
    var indexOf = _curry2(function indexOf(target, xs) {
        return typeof xs.indexOf === 'function' && !_isArray(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
    });

    /**
     * juxt applies a list of functions to a list of values.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Function
     * @sig [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])
     * @param {Array} fns An array of functions
     * @return {Function} A function that returns a list of values after applying each of the original `fns` to its parameters.
     * @see R.applySpec
     * @example
     *
     *      var range = R.juxt([Math.min, Math.max]);
     *      range(3, 4, 9, -3); //=> [-3, 9]
     */
    var juxt = _curry1(function juxt(fns) {
        return converge(_arrayOf, fns);
    });

    /**
     * Returns a lens for the given getter and setter functions. The getter "gets"
     * the value of the focus; the setter "sets" the value of the focus. The setter
     * should not mutate the data structure.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
     * @param {Function} getter
     * @param {Function} setter
     * @return {Lens}
     * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
     * @example
     *
     *      var xLens = R.lens(R.prop('x'), R.assoc('x'));
     *
     *      R.view(xLens, {x: 1, y: 2});            //=> 1
     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
     */
    var lens = _curry2(function lens(getter, setter) {
        return function (toFunctorFn) {
            return function (target) {
                return map(function (focus) {
                    return setter(focus, target);
                }, toFunctorFn(getter(target)));
            };
        };
    });

    /**
     * Returns a lens whose focus is the specified index.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Number -> Lens s a
     * @param {Number} n
     * @return {Lens}
     * @see R.view, R.set, R.over
     * @example
     *
     *      var headLens = R.lensIndex(0);
     *
     *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
     *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
     *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
     */
    var lensIndex = _curry1(function lensIndex(n) {
        return lens(nth(n), update(n));
    });

    /**
     * Returns a lens whose focus is the specified path.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig [String] -> Lens s a
     * @param {Array} path The path to use.
     * @return {Lens}
     * @see R.view, R.set, R.over
     * @example
     *
     *      var xyLens = R.lensPath(['x', 'y']);
     *
     *      R.view(xyLens, {x: {y: 2, z: 3}});            //=> 2
     *      R.set(xyLens, 4, {x: {y: 2, z: 3}});          //=> {x: {y: 4, z: 3}}
     *      R.over(xyLens, R.negate, {x: {y: 2, z: 3}});  //=> {x: {y: -2, z: 3}}
     */
    var lensPath = _curry1(function lensPath(p) {
        return lens(path(p), assocPath(p));
    });

    /**
     * Returns a lens whose focus is the specified property.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig String -> Lens s a
     * @param {String} k
     * @return {Lens}
     * @see R.view, R.set, R.over
     * @example
     *
     *      var xLens = R.lensProp('x');
     *
     *      R.view(xLens, {x: 1, y: 2});            //=> 1
     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
     */
    var lensProp = _curry1(function lensProp(k) {
        return lens(prop(k), assoc(k));
    });

    /**
     * "lifts" a function to be the specified arity, so that it may "map over" that
     * many lists, Functions or other objects that satisfy the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Function
     * @sig Number -> (*... -> *) -> ([*]... -> [*])
     * @param {Function} fn The function to lift into higher context
     * @return {Function} The lifted function.
     * @see R.lift, R.ap
     * @example
     *
     *      var madd3 = R.liftN(3, R.curryN(3, (...args) => R.sum(args)));
     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
     */
    var liftN = _curry2(function liftN(arity, fn) {
        var lifted = curryN(arity, fn);
        return curryN(arity, function () {
            return _reduce(ap, map(lifted, arguments[0]), _slice(arguments, 1));
        });
    });

    /**
     * Returns the mean of the given list of numbers.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list
     * @return {Number}
     * @example
     *
     *      R.mean([2, 7, 9]); //=> 6
     *      R.mean([]); //=> NaN
     */
    var mean = _curry1(function mean(list) {
        return sum(list) / list.length;
    });

    /**
     * Returns the median of the given list of numbers.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list
     * @return {Number}
     * @example
     *
     *      R.median([2, 9, 7]); //=> 7
     *      R.median([7, 2, 10, 9]); //=> 8
     *      R.median([]); //=> NaN
     */
    var median = _curry1(function median(list) {
        var len = list.length;
        if (len === 0) {
            return NaN;
        }
        var width = 2 - len % 2;
        var idx = (len - width) / 2;
        return mean(_slice(list).sort(function (a, b) {
            return a < b ? -1 : a > b ? 1 : 0;
        }).slice(idx, idx + width));
    });

    /**
     * Takes a predicate and a list or other "filterable" object and returns the
     * pair of filterable objects of the same type of elements which do and do not
     * satisfy, the predicate, respectively.
     *
     * @func
     * @memberOf R
     * @since v0.1.4
     * @category List
     * @sig Filterable f => (a -> Boolean) -> f a -> [f a, f a]
     * @param {Function} pred A predicate to determine which side the element belongs to.
     * @param {Array} filterable the list (or other filterable) to partition.
     * @return {Array} An array, containing first the subset of elements that satisfy the
     *         predicate, and second the subset of elements that do not satisfy.
     * @see R.filter, R.reject
     * @example
     *
     *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);
     *      // => [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
     *
     *      R.partition(R.contains('s'), { a: 'sss', b: 'ttt', foo: 'bars' });
     *      // => [ { a: 'sss', foo: 'bars' }, { b: 'ttt' }  ]
     */
    var partition = juxt([
        filter,
        reject
    ]);

    /**
     * Performs left-to-right function composition. The leftmost function may have
     * any arity; the remaining functions must be unary.
     *
     * In some libraries this function is named `sequence`.
     *
     * **Note:** The result of pipe is not automatically curried.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.compose
     * @example
     *
     *      var f = R.pipe(Math.pow, R.negate, R.inc);
     *
     *      f(3, 4); // -(3^4) + 1
     */
    var pipe = function pipe() {
        if (arguments.length === 0) {
            throw new Error('pipe requires at least one argument');
        }
        return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
    };

    /**
     * Performs left-to-right composition of one or more Promise-returning
     * functions. The leftmost function may have any arity; the remaining functions
     * must be unary.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Function
     * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.composeP
     * @example
     *
     *      //  followersForUser :: String -> Promise [User]
     *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
     */
    var pipeP = function pipeP() {
        if (arguments.length === 0) {
            throw new Error('pipeP requires at least one argument');
        }
        return _arity(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));
    };

    /**
     * Multiplies together all the elements of a list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list An array of numbers
     * @return {Number} The product of all the numbers in the list.
     * @see R.reduce
     * @example
     *
     *      R.product([2,4,6,8,100,1]); //=> 38400
     */
    var product = reduce(multiply, 1);

    /**
     * Transforms a [Traversable](https://github.com/fantasyland/fantasy-land#traversable)
     * of [Applicative](https://github.com/fantasyland/fantasy-land#applicative) into an
     * Applicative of Traversable.
     *
     * Dispatches to the `sequence` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig (Applicative f, Traversable t) => (a -> f a) -> t (f a) -> f (t a)
     * @param {Function} of
     * @param {*} traversable
     * @return {*}
     * @see R.traverse
     * @example
     *
     *      R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
     *      R.sequence(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
     *
     *      R.sequence(R.of, Just([1, 2, 3])); //=> [Just(1), Just(2), Just(3)]
     *      R.sequence(R.of, Nothing());       //=> [Nothing()]
     */
    var sequence = _curry2(function sequence(of, traversable) {
        return typeof traversable.sequence === 'function' ? traversable.sequence(of) : reduceRight(function (acc, x) {
            return ap(map(prepend, x), acc);
        }, of([]), traversable);
    });

    /**
     * Maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning
     * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),
     * then uses [`sequence`](#sequence) to transform the resulting Traversable of Applicative
     * into an Applicative of Traversable.
     *
     * Dispatches to the `sequence` method of the third argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig (Applicative f, Traversable t) => (a -> f a) -> (a -> f b) -> t a -> f (t b)
     * @param {Function} of
     * @param {Function} f
     * @param {*} traversable
     * @return {*}
     * @see R.sequence
     * @example
     *
     *      // Returns `Nothing` if the given divisor is `0`
     *      safeDiv = n => d => d === 0 ? Nothing() : Just(n / d)
     *
     *      R.traverse(Maybe.of, safeDiv(10), [2, 4, 5]); //=> Just([5, 2.5, 2])
     *      R.traverse(Maybe.of, safeDiv(10), [2, 0, 5]); //=> Nothing
     */
    var traverse = _curry3(function traverse(of, f, traversable) {
        return sequence(of, map(f, traversable));
    });

    /**
     * Shorthand for `R.chain(R.identity)`, which removes one level of nesting from
     * any [Chain](https://github.com/fantasyland/fantasy-land#chain).
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig Chain c => c (c a) -> c a
     * @param {*} list
     * @return {*}
     * @see R.flatten, R.chain
     * @example
     *
     *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
     *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
     */
    var unnest = chain(_identity);

    var _contains = function _contains(a, list) {
        return _indexOf(list, a, 0) >= 0;
    };

    //  mapPairs :: (Object, [String]) -> [String]
    var _toString = function _toString(x, seen) {
        var recur = function recur(y) {
            var xs = seen.concat([x]);
            return _contains(y, xs) ? '<Circular>' : _toString(y, xs);
        };
        //  mapPairs :: (Object, [String]) -> [String]
        var mapPairs = function (obj, keys) {
            return _map(function (k) {
                return _quote(k) + ': ' + recur(obj[k]);
            }, keys.slice().sort());
        };
        switch (Object.prototype.toString.call(x)) {
        case '[object Arguments]':
            return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';
        case '[object Array]':
            return '[' + _map(recur, x).concat(mapPairs(x, reject(function (k) {
                return /^\d+$/.test(k);
            }, keys(x)))).join(', ') + ']';
        case '[object Boolean]':
            return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
        case '[object Date]':
            return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString(x))) + ')';
        case '[object Null]':
            return 'null';
        case '[object Number]':
            return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
        case '[object String]':
            return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);
        case '[object Undefined]':
            return 'undefined';
        default:
            if (typeof x.toString === 'function') {
                var repr = x.toString();
                if (repr !== '[object Object]') {
                    return repr;
                }
            }
            return '{' + mapPairs(x, keys(x)).join(', ') + '}';
        }
    };

    /**
     * Performs right-to-left function composition. The rightmost function may have
     * any arity; the remaining functions must be unary.
     *
     * **Note:** The result of compose is not automatically curried.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.pipe
     * @example
     *
     *      var f = R.compose(R.inc, R.negate, Math.pow);
     *
     *      f(3, 4); // -(3^4) + 1
     */
    var compose = function compose() {
        if (arguments.length === 0) {
            throw new Error('compose requires at least one argument');
        }
        return pipe.apply(this, reverse(arguments));
    };

    /**
     * Returns the right-to-left Kleisli composition of the provided functions,
     * each of which must return a value of a type supported by [`chain`](#chain).
     *
     * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), R.chain(f))`.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Function
     * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (m a -> m z)
     * @param {...Function}
     * @return {Function}
     * @see R.pipeK
     * @example
     *
     *      //  parseJson :: String -> Maybe *
     *      //  get :: String -> Object -> Maybe *
     *
     *      //  getStateCode :: Maybe String -> Maybe String
     *      var getStateCode = R.composeK(
     *        R.compose(Maybe.of, R.toUpper),
     *        get('state'),
     *        get('address'),
     *        get('user'),
     *        parseJson
     *      );
     *
     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
     *      //=> Just('NY')
     *      getStateCode(Maybe.of('[Invalid JSON]'));
     *      //=> Nothing()
     */
    var composeK = function composeK() {
        return compose.apply(this, prepend(identity, map(chain, arguments)));
    };

    /**
     * Performs right-to-left composition of one or more Promise-returning
     * functions. The rightmost function may have any arity; the remaining
     * functions must be unary.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Function
     * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.pipeP
     * @example
     *
     *      //  followersForUser :: String -> Promise [User]
     *      var followersForUser = R.composeP(db.getFollowers, db.getUserById);
     */
    var composeP = function composeP() {
        if (arguments.length === 0) {
            throw new Error('composeP requires at least one argument');
        }
        return pipeP.apply(this, reverse(arguments));
    };

    /**
     * Wraps a constructor function inside a curried function that can be called
     * with the same arguments and returns the same type.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (* -> {*}) -> (* -> {*})
     * @param {Function} Fn The constructor function to wrap.
     * @return {Function} A wrapped, curried constructor function.
     * @example
     *
     *      // Constructor function
     *      var Widget = config => {
     *        // ...
     *      };
     *      Widget.prototype = {
     *        // ...
     *      };
     *      var allConfigs = [
     *        // ...
     *      ];
     *      R.map(R.construct(Widget), allConfigs); // a list of Widgets
     */
    var construct = _curry1(function construct(Fn) {
        return constructN(Fn.length, Fn);
    });

    /**
     * Returns `true` if the specified value is equal, in `R.equals` terms, to at
     * least one element of the given list; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> Boolean
     * @param {Object} a The item to compare against.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the item is in the list, `false` otherwise.
     * @see R.any
     * @example
     *
     *      R.contains(3, [1, 2, 3]); //=> true
     *      R.contains(4, [1, 2, 3]); //=> false
     *      R.contains([42], [[42]]); //=> true
     */
    var contains = _curry2(_contains);

    /**
     * Finds the set (i.e. no duplicates) of all elements in the first list not
     * contained in the second list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig [*] -> [*] -> [*]
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The elements in `list1` that are not in `list2`.
     * @see R.differenceWith
     * @example
     *
     *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
     *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
     */
    var difference = _curry2(function difference(first, second) {
        var out = [];
        var idx = 0;
        var firstLen = first.length;
        while (idx < firstLen) {
            if (!_contains(first[idx], second) && !_contains(first[idx], out)) {
                out[out.length] = first[idx];
            }
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a new list without any consecutively repeating elements. `R.equals`
     * is used to determine equality.
     *
     * Dispatches to the `dropRepeats` method of the first argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig [a] -> [a]
     * @param {Array} list The array to consider.
     * @return {Array} `list` without repeating elements.
     * @see R.transduce
     * @example
     *
     *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
     */
    var dropRepeats = _curry1(_dispatchable('dropRepeats', _xdropRepeatsWith(equals), dropRepeatsWith(equals)));

    /**
     * "lifts" a function of arity > 1 so that it may "map over" a list, Function or other
     * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Function
     * @sig (*... -> *) -> ([*]... -> [*])
     * @param {Function} fn The function to lift into higher context
     * @return {Function} The lifted function.
     * @see R.liftN
     * @example
     *
     *      var madd3 = R.lift(R.curry((a, b, c) => a + b + c));
     *
     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
     *
     *      var madd5 = R.lift(R.curry((a, b, c, d, e) => a + b + c + d + e));
     *
     *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]
     */
    var lift = _curry1(function lift(fn) {
        return liftN(fn.length, fn);
    });

    /**
     * Returns a partial copy of an object omitting the keys specified.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [String] -> {String: *} -> {String: *}
     * @param {Array} names an array of String property names to omit from the new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with properties from `names` not on it.
     * @see R.pick
     * @example
     *
     *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
     */
    var omit = _curry2(function omit(names, obj) {
        var result = {};
        for (var prop in obj) {
            if (!_contains(prop, names)) {
                result[prop] = obj[prop];
            }
        }
        return result;
    });

    /**
     * Returns the left-to-right Kleisli composition of the provided functions,
     * each of which must return a value of a type supported by [`chain`](#chain).
     *
     * `R.pipeK(f, g, h)` is equivalent to `R.pipe(R.chain(f), R.chain(g), R.chain(h))`.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Function
     * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (m a -> m z)
     * @param {...Function}
     * @return {Function}
     * @see R.composeK
     * @example
     *
     *      //  parseJson :: String -> Maybe *
     *      //  get :: String -> Object -> Maybe *
     *
     *      //  getStateCode :: Maybe String -> Maybe String
     *      var getStateCode = R.pipeK(
     *        parseJson,
     *        get('user'),
     *        get('address'),
     *        get('state'),
     *        R.compose(Maybe.of, R.toUpper)
     *      );
     *
     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
     *      //=> Just('NY')
     *      getStateCode(Maybe.of('[Invalid JSON]'));
     *      //=> Nothing()
     */
    var pipeK = function pipeK() {
        return composeK.apply(this, reverse(arguments));
    };

    /**
     * Returns the string representation of the given value. `eval`'ing the output
     * should result in a value equivalent to the input value. Many of the built-in
     * `toString` methods do not satisfy this requirement.
     *
     * If the given value is an `[object Object]` with a `toString` method other
     * than `Object.prototype.toString`, this method is invoked with no arguments
     * to produce the return value. This means user-defined constructor functions
     * can provide a suitable `toString` method. For example:
     *
     *     function Point(x, y) {
     *       this.x = x;
     *       this.y = y;
     *     }
     *
     *     Point.prototype.toString = function() {
     *       return 'new Point(' + this.x + ', ' + this.y + ')';
     *     };
     *
     *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category String
     * @sig * -> String
     * @param {*} val
     * @return {String}
     * @example
     *
     *      R.toString(42); //=> '42'
     *      R.toString('abc'); //=> '"abc"'
     *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
     *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
     *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
     */
    var toString = _curry1(function toString(val) {
        return _toString(val, []);
    });

    /**
     * Returns a new list without values in the first argument.
     * `R.equals` is used to determine equality.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig [a] -> [a] -> [a]
     * @param {Array} list1 The values to be removed from `list2`.
     * @param {Array} list2 The array to remove values from.
     * @return {Array} The new array without values in `list1`.
     * @see R.transduce
     * @example
     *
     *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]
     */
    var without = _curry2(function (xs, list) {
        return reject(flip(_contains)(xs), list);
    });

    // A simple Set type that honours R.equals semantics
    /* globals Set */
    /**
       * Combines the logic for checking whether an item is a member of the set and
       * for adding a new item to the set.
       *
       * @param item       The item to check or add to the Set instance.
       * @param shouldAdd  If true, the item will be added to the set if it doesn't
       *                   already exist.
       * @param set        The set instance to check or add to.
       * @return {boolean} When shouldAdd is true, this will return true when a new
       *                   item was added otherwise false. When shouldAdd is false,
       *                   this will return true if the item already exists, otherwise
       *                   false.
       */
    // distinguish between +0 and -0
    // these types can all utilise Set
    // set._items['boolean'] holds a two element array
    // representing [ falseExists, trueExists ]
    // compare functions for reference equality
    /* falls through */
    // reduce the search size of heterogeneous sets by creating buckets
    // for each type.
    // scan through all previously applied items
    var _Set = function () {
        function _Set() {
            /* globals Set */
            this._nativeSet = typeof Set === 'function' ? new Set() : null;
            this._items = {};
        }
        _Set.prototype.add = function (item) {
            return hasOrAdd(item, true, this);
        };
        _Set.prototype.has = function (item) {
            return hasOrAdd(item, false, this);
        };
        /**
       * Combines the logic for checking whether an item is a member of the set and
       * for adding a new item to the set.
       *
       * @param item       The item to check or add to the Set instance.
       * @param shouldAdd  If true, the item will be added to the set if it doesn't
       *                   already exist.
       * @param set        The set instance to check or add to.
       * @return {boolean} When shouldAdd is true, this will return true when a new
       *                   item was added otherwise false. When shouldAdd is false,
       *                   this will return true if the item already exists, otherwise
       *                   false.
       */
        function hasOrAdd(item, shouldAdd, set) {
            var type = typeof item;
            var prevSize, newSize;
            switch (type) {
            case 'string':
            case 'number':
                // distinguish between +0 and -0
                if (item === 0 && !set._items['-0'] && 1 / item === -Infinity) {
                    if (shouldAdd) {
                        set._items['-0'] = true;
                    }
                    return shouldAdd;
                }
                // these types can all utilise Set
                if (set._nativeSet !== null) {
                    if (shouldAdd) {
                        prevSize = set._nativeSet.size;
                        set._nativeSet.add(item);
                        newSize = set._nativeSet.size;
                        return newSize > prevSize;
                    } else {
                        return set._nativeSet.has(item);
                    }
                } else {
                    if (!(type in set._items)) {
                        if (shouldAdd) {
                            set._items[type] = {};
                            set._items[type][item] = true;
                        }
                        return shouldAdd;
                    } else if (item in set._items[type]) {
                        return !shouldAdd;
                    } else {
                        if (shouldAdd) {
                            set._items[type][item] = true;
                        }
                        return shouldAdd;
                    }
                }
            case 'boolean':
                // set._items['boolean'] holds a two element array
                // representing [ falseExists, trueExists ]
                if (type in set._items) {
                    var bIdx = item ? 1 : 0;
                    if (set._items[type][bIdx]) {
                        return !shouldAdd;
                    } else {
                        if (shouldAdd) {
                            set._items[type][bIdx] = true;
                        }
                        return shouldAdd;
                    }
                } else {
                    if (shouldAdd) {
                        set._items[type] = item ? [
                            false,
                            true
                        ] : [
                            true,
                            false
                        ];
                    }
                    return shouldAdd;
                }
            case 'function':
                // compare functions for reference equality
                if (set._nativeSet !== null) {
                    if (shouldAdd) {
                        prevSize = set._nativeSet.size;
                        set._nativeSet.add(item);
                        newSize = set._nativeSet.size;
                        return newSize > prevSize;
                    } else {
                        return set._nativeSet.has(item);
                    }
                } else {
                    if (!(type in set._items)) {
                        if (shouldAdd) {
                            set._items[type] = [item];
                        }
                        return shouldAdd;
                    }
                    if (!_contains(item, set._items[type])) {
                        if (shouldAdd) {
                            set._items[type].push(item);
                        }
                        return shouldAdd;
                    }
                }
                return !shouldAdd;
            case 'undefined':
                if (set._items[type]) {
                    return !shouldAdd;
                } else {
                    if (shouldAdd) {
                        set._items[type] = true;
                    }
                    return shouldAdd;
                }
            case 'object':
                if (item === null) {
                    if (!set._items['null']) {
                        if (shouldAdd) {
                            set._items['null'] = true;
                        }
                        return shouldAdd;
                    }
                    return !shouldAdd;
                }
            /* falls through */
            default:
                // reduce the search size of heterogeneous sets by creating buckets
                // for each type.
                type = Object.prototype.toString.call(item);
                if (!(type in set._items)) {
                    if (shouldAdd) {
                        set._items[type] = [item];
                    }
                    return shouldAdd;
                }
                // scan through all previously applied items
                if (!_contains(item, set._items[type])) {
                    if (shouldAdd) {
                        set._items[type].push(item);
                    }
                    return shouldAdd;
                }
                return !shouldAdd;
            }
        }
        return _Set;
    }();

    /**
     * A function wrapping calls to the two functions in an `&&` operation,
     * returning the result of the first function if it is false-y and the result
     * of the second function otherwise. Note that this is short-circuited,
     * meaning that the second function will not be invoked if the first returns a
     * false-y value.
     *
     * In addition to functions, `R.both` also accepts any fantasy-land compatible
     * applicative functor.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category Logic
     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
     * @param {Function} f a predicate
     * @param {Function} g another predicate
     * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
     * @see R.and
     * @example
     *
     *      var gt10 = x => x > 10;
     *      var even = x => x % 2 === 0;
     *      var f = R.both(gt10, even);
     *      f(100); //=> true
     *      f(101); //=> false
     */
    var both = _curry2(function both(f, g) {
        return _isFunction(f) ? function _both() {
            return f.apply(this, arguments) && g.apply(this, arguments);
        } : lift(and)(f, g);
    });

    /**
     * Takes a function `f` and returns a function `g` such that:
     *
     *   - applying `g` to zero or more arguments will give __true__ if applying
     *     the same arguments to `f` gives a logical __false__ value; and
     *
     *   - applying `g` to zero or more arguments will give __false__ if applying
     *     the same arguments to `f` gives a logical __true__ value.
     *
     * `R.complement` will work on all other functors as well.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category Logic
     * @sig (*... -> *) -> (*... -> Boolean)
     * @param {Function} f
     * @return {Function}
     * @see R.not
     * @example
     *
     *      var isEven = n => n % 2 === 0;
     *      var isOdd = R.complement(isEven);
     *      isOdd(21); //=> true
     *      isOdd(42); //=> false
     */
    var complement = lift(not);

    /**
     * A function wrapping calls to the two functions in an `||` operation,
     * returning the result of the first function if it is truth-y and the result
     * of the second function otherwise. Note that this is short-circuited,
     * meaning that the second function will not be invoked if the first returns a
     * truth-y value.
     *
     * In addition to functions, `R.either` also accepts any fantasy-land compatible
     * applicative functor.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category Logic
     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
     * @param {Function} f a predicate
     * @param {Function} g another predicate
     * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
     * @see R.or
     * @example
     *
     *      var gt10 = x => x > 10;
     *      var even = x => x % 2 === 0;
     *      var f = R.either(gt10, even);
     *      f(101); //=> true
     *      f(8); //=> true
     */
    var either = _curry2(function either(f, g) {
        return _isFunction(f) ? function _either() {
            return f.apply(this, arguments) || g.apply(this, arguments);
        } : lift(or)(f, g);
    });

    /**
     * Turns a named method with a specified arity into a function that can be
     * called directly supplied with arguments and a target object.
     *
     * The returned function is curried and accepts `arity + 1` parameters where
     * the final parameter is the target object.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
     * @param {Number} arity Number of arguments the returned function should take
     *        before the target object.
     * @param {String} method Name of the method to call.
     * @return {Function} A new curried function.
     * @example
     *
     *      var sliceFrom = R.invoker(1, 'slice');
     *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
     *      var sliceFrom6 = R.invoker(2, 'slice')(6);
     *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
     */
    var invoker = _curry2(function invoker(arity, method) {
        return curryN(arity + 1, function () {
            var target = arguments[arity];
            if (target != null && is(Function, target[method])) {
                return target[method].apply(target, _slice(arguments, 0, arity));
            }
            throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
        });
    });

    /**
     * Returns a string made by inserting the `separator` between each element and
     * concatenating all the elements into a single string.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig String -> [a] -> String
     * @param {Number|String} separator The string used to separate the elements.
     * @param {Array} xs The elements to join into a string.
     * @return {String} str The string made by concatenating `xs` with `separator`.
     * @see R.split
     * @example
     *
     *      var spacer = R.join(' ');
     *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
     *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
     */
    var join = invoker(1, 'join');

    /**
     * Creates a new function that, when invoked, caches the result of calling `fn`
     * for a given argument set and returns the result. Subsequent calls to the
     * memoized `fn` with the same argument set will not result in an additional
     * call to `fn`; instead, the cached result for that set of arguments will be
     * returned.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (*... -> a) -> (*... -> a)
     * @param {Function} fn The function to memoize.
     * @return {Function} Memoized version of `fn`.
     * @example
     *
     *      var count = 0;
     *      var factorial = R.memoize(n => {
     *        count += 1;
     *        return R.product(R.range(1, n + 1));
     *      });
     *      factorial(5); //=> 120
     *      factorial(5); //=> 120
     *      factorial(5); //=> 120
     *      count; //=> 1
     */
    var memoize = _curry1(function memoize(fn) {
        var cache = {};
        return _arity(fn.length, function () {
            var key = toString(arguments);
            if (!_has(key, cache)) {
                cache[key] = fn.apply(this, arguments);
            }
            return cache[key];
        });
    });

    /**
     * Splits a string into an array of strings based on the given
     * separator.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category String
     * @sig (String | RegExp) -> String -> [String]
     * @param {String|RegExp} sep The pattern.
     * @param {String} str The string to separate into an array.
     * @return {Array} The array of strings from `str` separated by `str`.
     * @see R.join
     * @example
     *
     *      var pathComponents = R.split('/');
     *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
     *
     *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
     */
    var split = invoker(1, 'split');

    /**
     * Determines whether a given string matches a given regular expression.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category String
     * @sig RegExp -> String -> Boolean
     * @param {RegExp} pattern
     * @param {String} str
     * @return {Boolean}
     * @see R.match
     * @example
     *
     *      R.test(/^x/, 'xyz'); //=> true
     *      R.test(/^y/, 'xyz'); //=> false
     */
    var test = _curry2(function test(pattern, str) {
        if (!_isRegExp(pattern)) {
            throw new TypeError('\u2018test\u2019 requires a value of type RegExp as its first argument; received ' + toString(pattern));
        }
        return _cloneRegExp(pattern).test(str);
    });

    /**
     * The lower case version of a string.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category String
     * @sig String -> String
     * @param {String} str The string to lower case.
     * @return {String} The lower case version of `str`.
     * @see R.toUpper
     * @example
     *
     *      R.toLower('XYZ'); //=> 'xyz'
     */
    var toLower = invoker(0, 'toLowerCase');

    /**
     * The upper case version of a string.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category String
     * @sig String -> String
     * @param {String} str The string to upper case.
     * @return {String} The upper case version of `str`.
     * @see R.toLower
     * @example
     *
     *      R.toUpper('abc'); //=> 'ABC'
     */
    var toUpper = invoker(0, 'toUpperCase');

    /**
     * Returns a new list containing only one copy of each element in the original
     * list, based upon the value returned by applying the supplied function to
     * each list element. Prefers the first item if the supplied function produces
     * the same value on two items. `R.equals` is used for comparison.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig (a -> b) -> [a] -> [a]
     * @param {Function} fn A function used to produce a value to use during comparisons.
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
     */
    var uniqBy = _curry2(function uniqBy(fn, list) {
        var set = new _Set();
        var result = [];
        var idx = 0;
        var appliedItem, item;
        while (idx < list.length) {
            item = list[idx];
            appliedItem = fn(item);
            if (set.add(appliedItem)) {
                result.push(item);
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Returns the result of concatenating the given lists or strings.
     *
     * Dispatches to the `concat` method of the first argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a] -> [a]
     * @sig String -> String -> String
     * @param {Array|String} a
     * @param {Array|String} b
     * @return {Array|String}
     *
     * @example
     *
     *      R.concat([], []); //=> []
     *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
     *      R.concat('ABC', 'DEF'); // 'ABCDEF'
     */
    var concat = flip(invoker(1, 'concat'));

    /**
     * Finds the set (i.e. no duplicates) of all elements contained in the first or
     * second list, but not both.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Relation
     * @sig [*] -> [*] -> [*]
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The elements in `list1` or `list2`, but not both.
     * @see R.symmetricDifferenceWith
     * @example
     *
     *      R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=> [1,2,7,6,5]
     *      R.symmetricDifference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5,1,2]
     */
    var symmetricDifference = _curry2(function symmetricDifference(list1, list2) {
        return concat(difference(list1, list2), difference(list2, list1));
    });

    /**
     * Finds the set (i.e. no duplicates) of all elements contained in the first or
     * second list, but not both. Duplication is determined according to the value
     * returned by applying the supplied predicate to two list elements.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Relation
     * @sig (a -> a -> Boolean) -> [a] -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The elements in `list1` or `list2`, but not both.
     * @see R.symmetricDifference
     * @example
     *
     *      var eqA = R.eqBy(R.prop('a'));
     *      var l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];
     *      var l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];
     *      R.symmetricDifferenceWith(eqA, l1, l2); //=> [{a: 1}, {a: 2}, {a: 5}, {a: 6}]
     */
    var symmetricDifferenceWith = _curry3(function symmetricDifferenceWith(pred, list1, list2) {
        return concat(differenceWith(pred, list1, list2), differenceWith(pred, list2, list1));
    });

    /**
     * Returns a new list containing only one copy of each element in the original
     * list. `R.equals` is used to determine equality.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a]
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
     *      R.uniq([1, '1']);     //=> [1, '1']
     *      R.uniq([[42], [42]]); //=> [[42]]
     */
    var uniq = uniqBy(identity);

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of those
     * elements common to both lists.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig [*] -> [*] -> [*]
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The list of elements found in both `list1` and `list2`.
     * @see R.intersectionWith
     * @example
     *
     *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
     */
    var intersection = _curry2(function intersection(list1, list2) {
        var lookupList, filteredList;
        if (list1.length > list2.length) {
            lookupList = list1;
            filteredList = list2;
        } else {
            lookupList = list2;
            filteredList = list1;
        }
        return uniq(_filter(flip(_contains)(lookupList), filteredList));
    });

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of the elements
     * of each list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig [*] -> [*] -> [*]
     * @param {Array} as The first list.
     * @param {Array} bs The second list.
     * @return {Array} The first and second lists concatenated, with
     *         duplicates removed.
     * @example
     *
     *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
     */
    var union = _curry2(compose(uniq, _concat));

    var R = {
        F: F,
        T: T,
        __: __,
        add: add,
        addIndex: addIndex,
        adjust: adjust,
        all: all,
        allPass: allPass,
        allUniq: allUniq,
        always: always,
        and: and,
        any: any,
        anyPass: anyPass,
        ap: ap,
        aperture: aperture,
        append: append,
        apply: apply,
        applySpec: applySpec,
        assoc: assoc,
        assocPath: assocPath,
        binary: binary,
        bind: bind,
        both: both,
        call: call,
        chain: chain,
        clamp: clamp,
        clone: clone,
        comparator: comparator,
        complement: complement,
        compose: compose,
        composeK: composeK,
        composeP: composeP,
        concat: concat,
        cond: cond,
        construct: construct,
        constructN: constructN,
        contains: contains,
        converge: converge,
        countBy: countBy,
        curry: curry,
        curryN: curryN,
        dec: dec,
        defaultTo: defaultTo,
        difference: difference,
        differenceWith: differenceWith,
        dissoc: dissoc,
        dissocPath: dissocPath,
        divide: divide,
        drop: drop,
        dropLast: dropLast,
        dropLastWhile: dropLastWhile,
        dropRepeats: dropRepeats,
        dropRepeatsWith: dropRepeatsWith,
        dropWhile: dropWhile,
        either: either,
        empty: empty,
        eqBy: eqBy,
        eqProps: eqProps,
        equals: equals,
        evolve: evolve,
        filter: filter,
        find: find,
        findIndex: findIndex,
        findLast: findLast,
        findLastIndex: findLastIndex,
        flatten: flatten,
        flip: flip,
        forEach: forEach,
        fromPairs: fromPairs,
        groupBy: groupBy,
        groupWith: groupWith,
        gt: gt,
        gte: gte,
        has: has,
        hasIn: hasIn,
        head: head,
        identical: identical,
        identity: identity,
        ifElse: ifElse,
        inc: inc,
        indexBy: indexBy,
        indexOf: indexOf,
        init: init,
        insert: insert,
        insertAll: insertAll,
        intersection: intersection,
        intersectionWith: intersectionWith,
        intersperse: intersperse,
        into: into,
        invert: invert,
        invertObj: invertObj,
        invoker: invoker,
        is: is,
        isArrayLike: isArrayLike,
        isEmpty: isEmpty,
        isNil: isNil,
        join: join,
        juxt: juxt,
        keys: keys,
        keysIn: keysIn,
        last: last,
        lastIndexOf: lastIndexOf,
        length: length,
        lens: lens,
        lensIndex: lensIndex,
        lensPath: lensPath,
        lensProp: lensProp,
        lift: lift,
        liftN: liftN,
        lt: lt,
        lte: lte,
        map: map,
        mapAccum: mapAccum,
        mapAccumRight: mapAccumRight,
        mapObjIndexed: mapObjIndexed,
        match: match,
        mathMod: mathMod,
        max: max,
        maxBy: maxBy,
        mean: mean,
        median: median,
        memoize: memoize,
        merge: merge,
        mergeAll: mergeAll,
        mergeWith: mergeWith,
        mergeWithKey: mergeWithKey,
        min: min,
        minBy: minBy,
        modulo: modulo,
        multiply: multiply,
        nAry: nAry,
        negate: negate,
        none: none,
        not: not,
        nth: nth,
        nthArg: nthArg,
        objOf: objOf,
        of: of,
        omit: omit,
        once: once,
        or: or,
        over: over,
        pair: pair,
        partial: partial,
        partialRight: partialRight,
        partition: partition,
        path: path,
        pathEq: pathEq,
        pathOr: pathOr,
        pathSatisfies: pathSatisfies,
        pick: pick,
        pickAll: pickAll,
        pickBy: pickBy,
        pipe: pipe,
        pipeK: pipeK,
        pipeP: pipeP,
        pluck: pluck,
        prepend: prepend,
        product: product,
        project: project,
        prop: prop,
        propEq: propEq,
        propIs: propIs,
        propOr: propOr,
        propSatisfies: propSatisfies,
        props: props,
        range: range,
        reduce: reduce,
        reduceBy: reduceBy,
        reduceRight: reduceRight,
        reduced: reduced,
        reject: reject,
        remove: remove,
        repeat: repeat,
        replace: replace,
        reverse: reverse,
        scan: scan,
        sequence: sequence,
        set: set,
        slice: slice,
        sort: sort,
        sortBy: sortBy,
        split: split,
        splitAt: splitAt,
        splitEvery: splitEvery,
        splitWhen: splitWhen,
        subtract: subtract,
        sum: sum,
        symmetricDifference: symmetricDifference,
        symmetricDifferenceWith: symmetricDifferenceWith,
        tail: tail,
        take: take,
        takeLast: takeLast,
        takeLastWhile: takeLastWhile,
        takeWhile: takeWhile,
        tap: tap,
        test: test,
        times: times,
        toLower: toLower,
        toPairs: toPairs,
        toPairsIn: toPairsIn,
        toString: toString,
        toUpper: toUpper,
        transduce: transduce,
        transpose: transpose,
        traverse: traverse,
        trim: trim,
        tryCatch: tryCatch,
        type: type,
        unapply: unapply,
        unary: unary,
        uncurryN: uncurryN,
        unfold: unfold,
        union: union,
        unionWith: unionWith,
        uniq: uniq,
        uniqBy: uniqBy,
        uniqWith: uniqWith,
        unless: unless,
        unnest: unnest,
        until: until,
        update: update,
        useWith: useWith,
        values: values,
        valuesIn: valuesIn,
        view: view,
        when: when,
        where: where,
        whereEq: whereEq,
        without: without,
        wrap: wrap,
        xprod: xprod,
        zip: zip,
        zipObj: zipObj,
        zipWith: zipWith
    };
  /* eslint-env amd */

  /* TEST_ENTRY_POINT */

  if (true) {
    module.exports = R;
  } else if (typeof define === 'function' && define.amd) {
    define(function() { return R; });
  } else {
    this.R = R;
  }

}.call(this));


/***/ }),
/* 140 */,
/* 141 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./af": 37,
	"./af.js": 37,
	"./ar": 38,
	"./ar-ma": 39,
	"./ar-ma.js": 39,
	"./ar-sa": 40,
	"./ar-sa.js": 40,
	"./ar-tn": 41,
	"./ar-tn.js": 41,
	"./ar.js": 38,
	"./az": 42,
	"./az.js": 42,
	"./be": 43,
	"./be.js": 43,
	"./bg": 44,
	"./bg.js": 44,
	"./bn": 45,
	"./bn.js": 45,
	"./bo": 46,
	"./bo.js": 46,
	"./br": 47,
	"./br.js": 47,
	"./bs": 48,
	"./bs.js": 48,
	"./ca": 49,
	"./ca.js": 49,
	"./cs": 50,
	"./cs.js": 50,
	"./cv": 51,
	"./cv.js": 51,
	"./cy": 52,
	"./cy.js": 52,
	"./da": 53,
	"./da.js": 53,
	"./de": 54,
	"./de-at": 55,
	"./de-at.js": 55,
	"./de.js": 54,
	"./dv": 56,
	"./dv.js": 56,
	"./el": 57,
	"./el.js": 57,
	"./en-au": 58,
	"./en-au.js": 58,
	"./en-ca": 59,
	"./en-ca.js": 59,
	"./en-gb": 60,
	"./en-gb.js": 60,
	"./en-ie": 61,
	"./en-ie.js": 61,
	"./en-nz": 62,
	"./en-nz.js": 62,
	"./eo": 63,
	"./eo.js": 63,
	"./es": 64,
	"./es.js": 64,
	"./et": 65,
	"./et.js": 65,
	"./eu": 66,
	"./eu.js": 66,
	"./fa": 67,
	"./fa.js": 67,
	"./fi": 68,
	"./fi.js": 68,
	"./fo": 69,
	"./fo.js": 69,
	"./fr": 70,
	"./fr-ca": 71,
	"./fr-ca.js": 71,
	"./fr-ch": 72,
	"./fr-ch.js": 72,
	"./fr.js": 70,
	"./fy": 73,
	"./fy.js": 73,
	"./gd": 74,
	"./gd.js": 74,
	"./gl": 75,
	"./gl.js": 75,
	"./he": 76,
	"./he.js": 76,
	"./hi": 77,
	"./hi.js": 77,
	"./hr": 78,
	"./hr.js": 78,
	"./hu": 79,
	"./hu.js": 79,
	"./hy-am": 80,
	"./hy-am.js": 80,
	"./id": 81,
	"./id.js": 81,
	"./is": 82,
	"./is.js": 82,
	"./it": 83,
	"./it.js": 83,
	"./ja": 84,
	"./ja.js": 84,
	"./jv": 85,
	"./jv.js": 85,
	"./ka": 86,
	"./ka.js": 86,
	"./kk": 87,
	"./kk.js": 87,
	"./km": 88,
	"./km.js": 88,
	"./ko": 89,
	"./ko.js": 89,
	"./ky": 90,
	"./ky.js": 90,
	"./lb": 91,
	"./lb.js": 91,
	"./lo": 92,
	"./lo.js": 92,
	"./lt": 93,
	"./lt.js": 93,
	"./lv": 94,
	"./lv.js": 94,
	"./me": 95,
	"./me.js": 95,
	"./mk": 96,
	"./mk.js": 96,
	"./ml": 97,
	"./ml.js": 97,
	"./mr": 98,
	"./mr.js": 98,
	"./ms": 99,
	"./ms-my": 100,
	"./ms-my.js": 100,
	"./ms.js": 99,
	"./my": 101,
	"./my.js": 101,
	"./nb": 102,
	"./nb.js": 102,
	"./ne": 103,
	"./ne.js": 103,
	"./nl": 104,
	"./nl.js": 104,
	"./nn": 105,
	"./nn.js": 105,
	"./pa-in": 106,
	"./pa-in.js": 106,
	"./pl": 107,
	"./pl.js": 107,
	"./pt": 108,
	"./pt-br": 109,
	"./pt-br.js": 109,
	"./pt.js": 108,
	"./ro": 110,
	"./ro.js": 110,
	"./ru": 111,
	"./ru.js": 111,
	"./se": 112,
	"./se.js": 112,
	"./si": 113,
	"./si.js": 113,
	"./sk": 114,
	"./sk.js": 114,
	"./sl": 115,
	"./sl.js": 115,
	"./sq": 116,
	"./sq.js": 116,
	"./sr": 117,
	"./sr-cyrl": 118,
	"./sr-cyrl.js": 118,
	"./sr.js": 117,
	"./ss": 119,
	"./ss.js": 119,
	"./sv": 120,
	"./sv.js": 120,
	"./sw": 121,
	"./sw.js": 121,
	"./ta": 122,
	"./ta.js": 122,
	"./te": 123,
	"./te.js": 123,
	"./th": 124,
	"./th.js": 124,
	"./tl-ph": 125,
	"./tl-ph.js": 125,
	"./tlh": 126,
	"./tlh.js": 126,
	"./tr": 127,
	"./tr.js": 127,
	"./tzl": 128,
	"./tzl.js": 128,
	"./tzm": 129,
	"./tzm-latn": 130,
	"./tzm-latn.js": 130,
	"./tzm.js": 129,
	"./uk": 131,
	"./uk.js": 131,
	"./uz": 132,
	"./uz.js": 132,
	"./vi": 133,
	"./vi.js": 133,
	"./x-pseudo": 134,
	"./x-pseudo.js": 134,
	"./zh-cn": 135,
	"./zh-cn.js": 135,
	"./zh-tw": 136,
	"./zh-tw.js": 136
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 142;

/***/ }),
/* 143 */
/***/ (function(module, exports) {

exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}


/***/ }),
/* 144 */
/***/ (function(module, exports) {

var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};


/***/ }),
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _ramda = __webpack_require__(139);

var _ramda2 = _interopRequireDefault(_ramda);

var _simpleHeatmapLayer = __webpack_require__(231);

var _simpleHeatmapLayer2 = _interopRequireDefault(_simpleHeatmapLayer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TABLE = "tweets_nov_feb";
var MAP_STYLE = "mapbox://styles/mapbox/light-v8";
var WIDTH = document.documentElement.clientWidth - 30;
var HEIGHT = Math.max(document.documentElement.clientHeight, window.innerHeight || 0) - 200;
var UPDATE_INTERVAL = 750;

var shapeSize = function shapeSize(bins, size) {
  var gap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : GAP_SIZE;
  return size / bins;
};

var HeatLayer = void 0;

var Connector = new MapdCon().protocol("http").host("mahakali.mapd.com").port("9092").dbName("mapd").user("mapd").password("HyperInteractive");

Connector.logging(true);

function connect() {
  return new Promise(function (resolve, reject) {
    Connector.connect(function (error, connector) {
      if (error) {
        reject(error);
      } else {
        resolve(connector);
      }
    });
  });
}

function createCrossfilter(connector) {
  return crossfilter.crossfilter(connector, TABLE);
}

var colorDomainSetter = function colorDomainSetter(domain) {
  return function (state) {
    return _extends({}, state, {
      encoding: _extends({}, state.encoding, {
        color: _extends({}, state.encoding.color, {
          scale: _extends({}, state.encoding.color.scale, {
            domain: domain
          })
        })
      })
    });
  };
};

function polyfillColorsGetter() {
  var _this = this;

  var colorScale = null;
  this.colors = function (scale) {
    if (scale) {
      colorScale = scale;
      return _this;
    } else {
      return colorScale;
    }
  };

  this.colorDomain = function (colorDomain) {
    if (colorScale) {
      colorScale.domain(colorDomain);
    }

    _this.getLayer("heat").setState(colorDomainSetter(colorDomain));
    return _this;
  };
  this.colorAccessor = function () {
    return function (a) {
      return a;
    };
  };
  return this;
}

var colorRange = ["#0d0887", "#2a0593", "#41049d", "#5601a4", "#6a00a8", "#7e03a8", "#8f0da4", "#a11b9b", "#b12a90", "#bf3984", "#cb4679", "#d6556d", "#e16462", "#ea7457", "#f2844b", "#f89540", "#fca636", "#feba2c", "#fcce25", "#f7e425", "#f0f921"];

// function rasterChart(cf) {
//   var xDim = cf.dimension("lon")
//   var yDim = cf.dimension("lat")
//   const RasterChart = dc.rasterChart(document.getElementById("heatmap"), true)
//   HeatLayer = dc.rasterLayer("heat")

//   HeatLayer.crossfilter(cf).xDim(xDim).yDim(yDim).setState({
//     mark: "hex",
//     encoding: {
//       x: {
//         type: "quantitative",
//         field: "lon",
//         size: WIDTH
//       },
//       y: {
//         type: "quantitative",
//         field: "lat",
//         size: HEIGHT
//       },
//       color: {
//         type: "quantize",
//         aggregate: "count(lang)",
//         scale: {
//           domain: "auto",
//           range: colorRange,
//           default: "#0d0887",
//           nullValue: "#0d0887"
//         }
//       },
//       size: {
//         type: "manual",
//         value: 10
//       }
//     }
//   })

//   RasterChart
//     .con(Connector)
//     .useLonLat(true)
//     .height(HEIGHT)
//     .width(WIDTH)
//     .mapUpdateInterval(UPDATE_INTERVAL)
//     .mapStyle(MAP_STYLE)
//     .mapboxToken("pk.eyJ1IjoibWFwZCIsImEiOiJjaWV1a3NqanYwajVsbmdtMDZzc2pneDVpIn0.cJnk8c2AxdNiRNZWtx5A9g") // need a mapbox accessToken for loading the tiles

//   polyfillColorsGetter.apply(RasterChart)
//   RasterChart.colors(d3.scale.linear().range(colorRange))
//   RasterChart.pushLayer("heat", HeatLayer)

//   return RasterChart
// }


function createCharts(cf) {

  mapboxgl.accessToken = "pk.eyJ1IjoibWFwZCIsImEiOiJjaWV1a2Zza2IwaXY5dThtMDU2bm5xdTQ1In0.U7vvTzg4HBgUGAB_sy0xhw";
  var map = new mapboxgl.Map({
    container: "heatmap",
    style: MAP_STYLE,
    center: [-74.50, 40],
    zoom: 1
  });

  var state = {
    mark: "hex",
    encoding: {
      x: {
        type: "quantitative",
        field: "lon",
        size: WIDTH
      },
      y: {
        type: "quantitative",
        field: "lat",
        size: HEIGHT
      },
      color: {
        type: "quantize",
        aggregate: "count(lang)",
        scale: {
          domain: "auto",
          range: colorRange,
          default: "#0d0887",
          nullValue: "#0d0887"
        }
      },
      size: {
        type: "manual",
        value: 10
      }
    }
  };

  var xDim = cf.dimension("lon");
  var yDim = cf.dimension("lat");

  var data = (0, _simpleHeatmapLayer2.default)().setConfig({
    crossfilter: cf,
    connector: Connector,
    xDimension: xDim,
    yDimension: yDim,
    height: HEIGHT,
    width: WIDTH
  }).setState(state).getData(function (error, image) {
    var blobUrl = "data:image/png;base64," + image;
    console.log(blobUrl);

    var dummy = "data:image/jpeg;base64,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AAAAUGdQQwAAAABMZWZ0VW50RiNSbHQAAAAAAAAAAAAAAABUb3AgVW50RiNSbHQAAAAAAAAAAAAAAABTY2wgVW50RiNQcmNAWQAAAAAAAAAAABBjcm9wV2hlblByaW50aW5nYm9vbAAAAAAOY3JvcFJlY3RCb3R0b21sb25nAAAAAAAAAAxjcm9wUmVjdExlZnRsb25nAAAAAAAAAA1jcm9wUmVjdFJpZ2h0bG9uZwAAAAAAAAALY3JvcFJlY3RUb3Bsb25nAAAAAAA4QklNA+0AAAAAABABGAAAAAEAAgEYAAAAAQACOEJJTQQmAAAAAAAOAAAAAAAAAAAAAD+AAAA4QklNBA0AAAAAAAQAAAAeOEJJTQQZAAAAAAAEAAAAHjhCSU0D8wAAAAAACQAAAAAAAAAAAQA4QklNBAoAAAAAAAEBADhCSU0nEAAAAAAACgABAAAAAAAAAAI4QklNA/UAAAAAAEgAL2ZmAAEAbGZmAAYAAAAAAAEAL2ZmAAEAoZmaAAYAAAAAAAEAMgAAAAEAWgAAAAYAAAAAAAEANQAAAAEALQAAAAYAAAAAAAE4QklNA/gAAAAAAHAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAOEJJTQQIAAAAAAAQAAAAAQAAAkAAAAJAAAAAADhCSU0EHgAAAAAABAAAAAA4QklNBBoAAAAAA0UAAAAGAAAAAAAAAAAAAALeAAAC3QAAAAgAQwBIADQAeAA2AHIAZwBiAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAALdAAAC3gAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABAAAAABAAAAAAAAbnVsbAAAAAIAAAAGYm91bmRzT2JqYwAAAAEAAAAAAABSY3QxAAAABAAAAABUb3AgbG9uZwAAAAAAAAAATGVmdGxvbmcAAAAAAAAAAEJ0b21sb25nAAAC3gAAAABSZ2h0bG9uZwAAAt0AAAAGc2xpY2VzVmxMcwAAAAFPYmpjAAAAAQAAAAAABXNsaWNlAAAAEgAAAAdzbGljZUlEbG9uZwAA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AG8AcwBoAG8AcAAgAEMAQwAgADIAMAAxADQAAAABADhCSU0PoAAAAAABHG1hbmlJUkZSAAABEDhCSU1BbkRzAAAA8AAAABAAAAABAAAAAAAAbnVsbAAAAAMAAAAAQUZTdGxvbmcAAAAAAAAAAEZySW5WbExzAAAAAU9iamMAAAABAAAAAAAAbnVsbAAAAAMAAAAARnJJRGxvbmcJUe+NAAAAAEZyRGxsb25nAAAD6AAAAABGckdBZG91YkA+AAAAAAAAAAAAAEZTdHNWbExzAAAAAU9iamMAAAABAAAAAAAAbnVsbAAAAAQAAAAARnNJRGxvbmcAAAAAAAAAAEFGcm1sb25nAAAAAAAAAABGc0ZyVmxMcwAAAAFsb25nCVHvjQAAAABMQ250bG9uZwAAAAEAADhCSU1Sb2xsAAAACAAAAAAAAAAAOEJJTQ+hAAAAAAAcbWZyaQAAAAIAAAAQAAAAAQAAAAAAAAABAAAAADhCSU0EBgAAAAAABwAHAAAAAQEA/+EbC2h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmF1eD0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC9hdXgvIiB4bWxuczp4bXBSaWdodHM9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9yaWdodHMvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOmNycz0iaHR0cDovL25zLmFkb2JlLmNvbS9jYW1lcmEtcmF3LXNldHRpbmdzLzEuMC8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bXA6TW9kaWZ5RGF0ZT0iMjAxNS0wNC0xNlQxMToyODoyNC0wNDowMCIgeG1wOkNyZWF0ZURhdGU9IjIwMTUtMDQtMTNUMTM6NTI6MDYiIHhtcDpSYXRpbmc9IjQiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTMyBNYWNpbnRvc2giIHhtcDpNZXRhZGF0YURhdGU9IjIwMTUtMDQtMTZUMTE6Mjg6MjQtMDQ6MDAiIGF1eDpTZXJpYWxOdW1iZXI9IjMyMjMxNzkwMiIgYXV4OkxlbnNJbmZvPSI4NS8xIDg1LzEgMC8wIDAvMCIgYXV4OkxlbnM9IkVGODVtbSBmLzEuOCBVU00iIGF1eDpMZW5zSUQ9IjE1NSIgYXV4OkltYWdlTnVtYmVyPSIwIiBhdXg6Rmxhc2hDb21wZW5zYXRpb249IjQvMyIgYXV4OkZpcm13YXJlPSIyLjEuMiIgYXV4OkFwcHJveGltYXRlRm9jdXNEaXN0YW5jZT0iMjE1LzEwMCIgeG1wUmlnaHRzOk1hcmtlZD0iVHJ1ZSIgZGM6Zm9ybWF0PSJpbWFnZS9qcGVnIiBjcnM6VmVyc2lvbj0iNi4xIiBjcnM6UHJvY2Vzc1ZlcnNpb249IjUuNyIgY3JzOldoaXRlQmFsYW5jZT0iQ3VzdG9tIiBjcnM6VGVtcGVyYXR1cmU9IjQ1MDAiIGNyczpUaW50PSItNiIgY3JzOkV4cG9zdXJlPSIrMC43NSIgY3JzOlNoYWRvd3M9IjUiIGNyczpCcmlnaHRuZXNzPSIrNTAiIGNyczpDb250cmFzdD0iKzI1IiBjcnM6U2F0dXJhdGlvbj0iMCIgY3JzOlNoYXJwbmVzcz0iMjUiIGNyczpMdW1pbmFuY2VTbW9vdGhpbmc9IjAiIGNyczpDb2xvck5vaXNlUmVkdWN0aW9uPSIyNSIgY3JzOkNocm9tYXRpY0FiZXJyYXRpb25SPSIwIiBjcnM6Q2hyb21hdGljQWJlcnJhdGlvbkI9IjAiIGNyczpWaWduZXR0ZUFtb3VudD0iMCIgY3JzOlNoYWRvd1RpbnQ9IjAiIGNyczpSZWRIdWU9IjAiIGNyczpSZWRTYXR1cmF0aW9uPSIwIiBjcnM6R3JlZW5IdWU9IjAiIGNyczpHcmVlblNhdHVyYXRpb249IjAiIGNyczpCbHVlSHVlPSIwIiBjcnM6Qmx1ZVNhdHVyYXRpb249IjAiIGNyczpGaWxsTGlnaHQ9IjAiIGNyczpWaWJyYW5jZT0iMCIgY3JzOkhpZ2hsaWdodFJlY292ZXJ5PSIwIiBjcnM6Q2xhcml0eT0iMCIgY3JzOkRlZnJpbmdlPSIwIiBjcnM6SHVlQWRqdXN0bWVudFJlZD0iMCIgY3JzOkh1ZUFkanVzdG1lbnRPcmFuZ2U9IjAiIGNyczpIdWVBZGp1c3RtZW50WWVsbG93PSIwIiBjcnM6SHVlQWRqdXN0bWVudEdyZWVuPSIwIiBjcnM6SHVlQWRqdXN0bWVudEFxdWE9IjAiIGNyczpIdWVBZGp1c3RtZW50Qmx1ZT0iMCIgY3JzOkh1ZUFkanVzdG1lbnRQdXJwbGU9IjAiIGNyczpIdWVBZGp1c3RtZW50TWFnZW50YT0iMCIgY3JzOlNhdHVyYXRpb25BZGp1c3RtZW50UmVkPSIwIiBjcnM6U2F0dXJhdGlvbkFkanVzdG1lbnRPcmFuZ2U9IjAiIGNyczpTYXR1cmF0aW9uQWRqdXN0bWVudFllbGxvdz0iMCIgY3JzOlNhdHVyYXRpb25BZGp1c3RtZW50R3JlZW49IjAiIGNyczpTYXR1cmF0aW9uQWRqdXN0bWVudEFxdWE9IjAiIGNyczpTYXR1cmF0aW9uQWRqdXN0bWVudEJsdWU9IjAiIGNyczpTYXR1cmF0aW9uQWRqdXN0bWVudFB1cnBsZT0iMCIgY3JzOlNhdHVyYXRpb25BZGp1c3RtZW50TWFnZW50YT0iMCIgY3JzOkx1bWluYW5jZUFkanVzdG1lbnRSZWQ9IjAiIGNyczpMdW1pbmFuY2VBZGp1c3RtZW50T3JhbmdlPSIwIiBjcnM6THVtaW5hbmNlQWRqdXN0bWVudFllbGxvdz0iMCIgY3JzOkx1bWluYW5jZUFkanVzdG1lbnRHcmVlbj0iMCIgY3JzOkx1bWluYW5jZUFkanVzdG1lbnRBcXVhPSIwIiBjcnM6THVtaW5hbmNlQWRqdXN0bWVudEJsdWU9IjAiIGNyczpMdW1pbmFuY2VBZGp1c3RtZW50UHVycGxlPSIwIiBjcnM6THVtaW5hbmNlQWRqdXN0bWVudE1hZ2VudGE9IjAiIGNyczpTcGxpdFRvbmluZ1NoYWRvd0h1ZT0iMCIgY3JzOlNwbGl0VG9uaW5nU2hhZG93U2F0dXJhdGlvbj0iMCIgY3JzOlNwbGl0VG9uaW5nSGlnaGxpZ2h0SHVlPSIwIiBjcnM6U3BsaXRUb25pbmdIaWdobGlnaHRTYXR1cmF0aW9uPSIwIiBjcnM6U3BsaXRUb25pbmdCYWxhbmNlPSIwIiBjcnM6UGFyYW1ldHJpY1NoYWRvd3M9IjAiIGNyczpQYXJhbWV0cmljRGFya3M9IjAiIGNyczpQYXJhbWV0cmljTGlnaHRzPSIwIiBjcnM6UGFyYW1ldHJpY0hpZ2hsaWdodHM9IjAiIGNyczpQYXJhbWV0cmljU2hhZG93U3BsaXQ9IjI1IiBjcnM6UGFyYW1ldHJpY01pZHRvbmVTcGxpdD0iNTAiIGNyczpQYXJhbWV0cmljSGlnaGxpZ2h0U3BsaXQ9Ijc1IiBjcnM6U2hhcnBlblJhZGl1cz0iKzEuMCIgY3JzOlNoYXJwZW5EZXRhaWw9IjI1IiBjcnM6U2hhcnBlbkVkZ2VNYXNraW5nPSIwIiBjcnM6UG9zdENyb3BWaWduZXR0ZUFtb3VudD0iMCIgY3JzOkdyYWluQW1vdW50PSIwIiBjcnM6Q29sb3JOb2lzZVJlZHVjdGlvbkRldGFpbD0iNTAiIGNyczpMZW5zUHJvZmlsZUVuYWJsZT0iMCIgY3JzOkxlbnNNYW51YWxEaXN0b3J0aW9uQW1vdW50PSIwIiBjcnM6UGVyc3BlY3RpdmVWZXJ0aWNhbD0iMCIgY3JzOlBlcnNwZWN0aXZlSG9yaXpvbnRhbD0iMCIgY3JzOlBlcnNwZWN0aXZlUm90YXRlPSIwLjAiIGNyczpQZXJzcGVjdGl2ZVNjYWxlPSIxMDAiIGNyczpDb252ZXJ0VG9HcmF5c2NhbGU9IkZhbHNlIiBjcnM6VG9uZUN1cnZlTmFtZT0iTWVkaXVtIENvbnRyYXN0IiBjcnM6Q2FtZXJhUHJvZmlsZT0iQWRvYmUgU3RhbmRhcmQiIGNyczpDYW1lcmFQcm9maWxlRGlnZXN0PSIzREE4Q0U0QTYyNkNFMzZBMUQwQzU1QkYxNTc3OTNDOSIgY3JzOkxlbnNQcm9maWxlU2V0dXA9IkxlbnNEZWZhdWx0cyIgY3JzOkhhc1NldHRpbmdzPSJUcnVlIiBjcnM6SGFzQ3JvcD0iRmFsc2UiIGNyczpBbHJlYWR5QXBwbGllZD0iVHJ1ZSIgcGhvdG9zaG9wOkxlZ2FjeUlQVENEaWdlc3Q9IjhCMEE1MDBBRTczNDVFMUY0RkRCMjcwQTM3MjkyQjJGIiBwaG90b3Nob3A6RGF0ZUNyZWF0ZWQ9IjIwMTUtMDQtMTNUMTM6NTI6MDYuMDc3LTA0OjAwIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90b3Nob3A6SUNDUHJvZmlsZT0iQWRvYmUgUkdCICgxOTk4KSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpiZTcxMjFiNC0wOTA2LTQ5YWMtODg1Mi0wOGY2NDZmMzMyNzciIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo5ODVjMDI0MS0yNGRiLTExNzgtYmM1YS05YTRkZGY4MjEyMDAiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0idXVpZDo3OEI0MkM3RDI4RTRFNDExOTE4RkU5RkUxREFDMEE3OSI+IDxkYzpyaWdodHM+IDxyZGY6QWx0PiA8cmRmOmxpIHhtbDpsYW5nPSJ4LWRlZmF1bHQiPsKpIERhdmlkIE9zcGluYTwvcmRmOmxpPiA8L3JkZjpBbHQ+IDwvZGM6cmlnaHRzPiA8Y3JzOlRvbmVDdXJ2ZT4gPHJkZjpTZXE+IDxyZGY6bGk+MCwgMDwvcmRmOmxpPiA8cmRmOmxpPjMyLCAyMjwvcmRmOmxpPiA8cmRmOmxpPjY0LCA1NjwvcmRmOmxpPiA8cmRmOmxpPjEyOCwgMTI4PC9yZGY6bGk+IDxyZGY6bGk+MTkyLCAxOTY8L3JkZjpsaT4gPHJkZjpsaT4yNTUsIDI1NTwvcmRmOmxpPiA8L3JkZjpTZXE+IDwvY3JzOlRvbmVDdXJ2ZT4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InV1aWQ6NkUyRkE0M0UyNkU0RTQxMTkxOEZFOUZFMURBQzBBNzkiIHN0UmVmOmRvY3VtZW50SUQ9InV1aWQ6NkQyRkE0M0UyNkU0RTQxMTkxOEZFOUZFMURBQzBBNzkiLz4gPHhtcE1NOkhpc3Rvcnk+IDxyZGY6U2VxPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6OWE5Yjk4NjctNTQyZC00ZDQzLTlmYTgtMjYzNTVjYWU4NDA3IiBzdEV2dDp3aGVuPSIyMDE1LTA0LTE2VDExOjI4OjI0LTA0OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6YmU3MTIxYjQtMDkwNi00OWFjLTg4NTItMDhmNjQ2ZjMzMjc3IiBzdEV2dDp3aGVuPSIyMDE1LTA0LTE2VDExOjI4OjI0LTA0OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg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";

    var layerID = "heatmap-layer";
    map.addSource(layerID, {
      type: "image",
      url: dummy,
      coordinates: [[-80.425, 46.437], [-71.516, 46.437], [-71.516, 37.936], [-80.425, 37.936]]
      // url: blobUrl,
      // coordinates: [[-90, -90], [90, -90], [90, 90], [-90, 90]]
    });

    map.addLayer({
      id: layerID,
      source: layerID,
      type: "raster",
      paint: { "raster-opacity": 0.5, "raster-fade-duration": 0 }
    });
  });

  // const RasterChart = rasterChart(cf)
  // countWidget(cf)
  // return RasterChart.init().then(() => dc.renderAllAsync())
}

document.addEventListener("DOMContentLoaded", function init() {
  return connect().then(createCrossfilter).then(createCharts);
});

/***/ }),
/* 231 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["default"] = simpleGeo;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_utils_utils__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_utils_utils___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__src_utils_utils__);


function simpleGeo () {

  let config = {
    crossfilter: null,
    connector: null,
    xDimension: null,
    yDimension: null,
    cap: 1000,
    pixelRatio: 1,
    width: null,
    height: null
  }
  let state = {}

  const MIN_AREA_IN_METERS = 30
  const EARTH_DIAMETER = 40075000

  const xScaleName = "x"
  const yScaleName = "y"
  const xScaleType = "linear"
  const yScaleType = "linear"
  const xScaleDomain = [-14695477.307978824, 14695477.307978759]
  const yScaleDomain = [-7493598.288940868, 14500697.975036839]
  const minCoord = xScaleDomain
  const maxCoord = yScaleDomain

  function getPixelSize (neLat, width, zoom) {
    return Math.max(
      MIN_AREA_IN_METERS / (EARTH_DIAMETER * Math.cos(neLat * Math.PI / 180) / (width * Math.pow(2, zoom))),
      1.0
    )
  }

  function getMarkHeight (type, width) {
    switch (type) {
    case "hex":
      return 2 * config.width / Math.sqrt(3.0)
    default:
      return config.width
    }
  }

  function getMarkSize ({width, neLat, zoom, domain}) {
    const pixelSize = state.encoding.size.type === "manual" ? state.encoding.size.value : getPixelSize(neLat, width, zoom)
    const numBinsX = Math.round(width / pixelSize)
    const markWidth = width / numBinsX
    const markHeight = getMarkHeight(state.mark, markWidth)
    return {
      markWidth,
      markHeight
    }
  }

  function getMarkType (type) {
    switch (type) {
    case "hex":
      return "hexagon-horiz"
    default:
      return type
    }
  }

  const hardcodedQuery1 = {"width":751,"height":562,"data":[{"name":"heatmap_query","sql":"SELECT reg_hex_horiz_pixel_bin_x(conv_4326_900913_x(lon),-14695477.307978824,14695477.307978759,conv_4326_900913_y(lat),-7493598.288940868,14500697.975036839,10.013333333333334,11.562401390970907,0,0,751,562) as x, reg_hex_horiz_pixel_bin_y(conv_4326_900913_x(lon),-14695477.307978824,14695477.307978759,conv_4326_900913_y(lat),-7493598.288940868,14500697.975036839,10.013333333333334,11.562401390970907,0,0,751,562) as y, count(lang) as color FROM tweets_nov_feb WHERE ((lon >= -132.01171875000242 AND lon <= 132.01171875000182) AND (lat >= -55.67302825501289 AND lat <= 78.24408242825211)) GROUP BY x, y"}],"scales":[{"name":"x","type":"linear","domain":[-14695477.307978824,14695477.307978759],"range":"width"},{"name":"y","type":"linear","domain":[-7493598.288940868,14500697.975036839],"range":"height"},{"name":"heat_color","type":"quantize","domain":[1,3526.103445196304],"range":["#0d0887","#2a0593","#41049d","#5601a4","#6a00a8","#7e03a8","#8f0da4","#a11b9b","#b12a90","#bf3984","#cb4679","#d6556d","#e16462","#ea7457","#f2844b","#f89540","#fca636","#feba2c","#fcce25","#f7e425","#f0f921"],"default":"#0d0887","nullValue":"#0d0887"}],"marks":[{"type":"symbol","from":{"data":"heatmap_query"},"properties":{"shape":"hexagon-horiz","xc":{"field":"x"},"yc":{"field":"y"},"width":10.013333333333334,"height":11.562401390970907,"fillColor":{"scale":"heat_color","field":"color"}}}]}
  const hardcodedQuery2 = {"width":338,"height":562,"data":[{"name":"heatmap_query","sql":"SELECT * FROM tweets_nov_feb WHERE ((lon >= -14695477.307978824 AND lon <= -7493598.288940868) AND (lat >= 14695477.307978759 AND lat <= 14500697.975036839))"}],"scales":[{"name":"x","type":"linear","domain":[-14695477.307978824,14695477.307978759],"range":"width"},{"name":"y","type":"linear","domain":[-7493598.288940868,14500697.975036839],"range":"height"},{"name":"heat_color","type":"quantize","domain":[1,3526.103445196304],"range":["#0d0887","#2a0593","#41049d","#5601a4","#6a00a8","#7e03a8","#8f0da4","#a11b9b","#b12a90","#bf3984","#cb4679","#d6556d","#e16462","#ea7457","#f2844b","#f89540","#fca636","#feba2c","#fcce25","#f7e425","#f0f921"],"default":"#0d0887","nullValue":"#0d0887"}],"marks":[{"type":"symbol","from":{"data":"heatmap_query"},"properties":{"shape":"hexagon-horiz","xc":{"field":"x"},"yc":{"field":"y"},"width":9.941176470588236,"height":390.28878197218705,"fillColor":{"scale":"heat_color","field":"color"}}}]}
  console.log("test spec", hardcodedQuery2)

  function genSQL ({table, width, height, min, max, filter, neLat, zoom, domain}) {
    const {markWidth, markHeight} = getMarkSize({width, neLat, zoom, domain})
    return __WEBPACK_IMPORTED_MODULE_0__src_utils_utils__["parser"].writeSQL({
      type: "root",
      source: table,
      transform: [
        {
          type: "filter",
          expr: filter
        },
        {
          type: "pixel_bin",
          width,
          height,
          mark: {
            shape: state.mark,
            width: markWidth,
            height: markHeight
          },
          x: {
            field: `conv_4326_900913_x(${state.encoding.x.field})`,
            domain: [min[0], max[0]]
          },
          y: {
            field: `conv_4326_900913_y(${state.encoding.y.field})`,
            domain: [min[1], max[1]]
          },
          aggregate: state.encoding.color.aggregate
        }
      ]
    })
  }

  function _genVega ({table, width, height, min, max, filter, neLat, zoom, domain}) {
    const {markWidth, markHeight} = getMarkSize({width, neLat, zoom, domain})
    console.log(666, genSQL({table, width, height, min, max, filter, neLat, zoom, domain}))
    return {
      width,
      height,
      data:
      {
        name: "heatmap_query",
        sql: genSQL({table, width, height, min, max, filter, neLat, zoom, domain})
      },
      scales: [
        {
          name: "heat_color",
          type: state.encoding.color.type,
          domain: state.encoding.color.scale.domain === "auto" ? domain : state.encoding.color.scale.domain,
          range: state.encoding.color.scale.range,
          default: state.encoding.color.scale.default,
          nullValue: state.encoding.color.scale.nullValue
        }
      ],
      mark:
      {
        type: "symbol",
        from: {
          data: "heatmap_query"
        },
        properties: {
          shape: getMarkType(state.mark),
          xc: {
            field: "x"
          },
          yc: {
            field: "y"
          },
          width: markWidth,
          height: markHeight,
          fillColor: {
            scale: "heat_color",
            field: "color"
          }
        }
      }
    }
  }

  function genHeatConfigFromChart () {
    return {
      "table": "tweets_nov_feb",
      "width": 338,
      "height": 562,
      "min": [-6613943.182552361, -7493598.288940868],
      "max": [6613943.182552386, 14500697.975036839],
      "filter": "(lon >= -14695477.307978824 AND lon <= -7493598.288940868) AND (lat >= 14695477.307978759 AND lat <= 14500697.975036839) AND (lon >= -59.41406250000085 AND lon <= 59.41406250000108) AND (lat >= -55.67302825501289 AND lat <= 78.24408242825211)",
      "neLat": 78.24408242825211,
      "zoom": 1,
      "domain": [0, 0]
      // table: config.crossfilter.getTable()[0],
      // width: Math.round(config.width * config.pixelRatio),
      // height: Math.round(config.height * config.pixelRatio),
      // min: conv4326To900913(minCoord),
      // max: conv4326To900913(maxCoord),
      // filter: config.crossfilter.getFilterString(),
      // neLat: maxCoord[1],
      // zoom: 1,
      // domain: [1, 3526.103445196304]
    }
  }

  function genVega () {
    let query = ""
    const group = config.crossfilter.groupAll()
    if (group.type === "dimension") {
      query = group.writeTopQuery(config.cap, undefined, true)
    } else if (group.type === "group") {
      query = group.writeTopQuery(config.cap, undefined, false, true)
    }

    const vega = _genVega(genHeatConfigFromChart())
    console.log("genVega", vega)
    const sql = genSQL(genHeatConfigFromChart())
    console.log("sql", sql)
    return vega
  }

  function genLayeredVega () {
    const width = config.width * config.pixelRatio
    const height = config.height * config.pixelRatio

    const data = []

    let scales = [
          {name: xScaleName, type: xScaleType, domain: xScaleDomain, range: "width"},
          {name: yScaleName, type: yScaleType, domain: yScaleDomain, range: "height"}
    ]
    const marks = []

    const layerVega = genVega()
    data.push(layerVega.data)
    scales = scales.concat(layerVega.scales)
    marks.push(layerVega.mark)

    const vegaSpec = {
      width: Math.round(width),
      height: Math.round(height),
      data,
      scales,
      marks
    }

    return vegaSpec
  }

  function conv900913To4326X (x) {
    return x / 111319.490778
  }

  function conv900913To4326Y (y) {
    return 57.295779513 * (2 * Math.atan(Math.exp(y / 6378136.99911)) - 1.570796327)
  }

  function conv900913To4326 (coord) {
    return [conv900913To4326X(coord[0]), conv900913To4326Y(coord[1])]
  }

  function conv4326To900913X (x) {
    return x * 111319.490778
  }

  function conv4326To900913Y (y) {
    return 6378136.99911 * Math.log(Math.tan(0.00872664626 * y + 0.785398163397))
  }

  function conv4326To900913 (coord) {
    return [conv4326To900913X(coord[0]), conv4326To900913Y(coord[1])]
  }

  function setFilterBounds (bounds) {
    //   minCoord = [bounds._sw.lng, bounds._sw.lat]
    //   maxCoord = [bounds._ne.lng, bounds._ne.lat]

    config.xDimension.filter([minCoord[0], maxCoord[0]])
    config.yDimension.filter([minCoord[1], maxCoord[1]])
  }

  function setConfig (_config) {
    config = Object.assign({}, config, _config)
    return this
  }

  function setState (_state) {
    state = _state
    return this
  }

  function getData (callback) {
    setFilterBounds()
    const vegaSpec = genLayeredVega()
    console.log("vegaSpec", vegaSpec)
    const nonce = config.connector.renderVega(0, JSON.stringify(vegaSpec), {}, (error, result) => {
      if (error) {
        callback(error)
      } else {
        console.log(result)
        callback(error, result.image)
      }
    })
  }

  return {
    getData,
    setState,
    setConfig
  }
}


/***/ })
/******/ ]);
//# sourceMappingURL=simplegeoheat.bundle.js.map