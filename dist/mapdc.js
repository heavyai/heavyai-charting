(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("d3"));
	else if(typeof define === 'function' && define.amd)
		define(["d3"], factory);
	else if(typeof exports === 'object')
		exports["mapdc"] = factory(require("d3"));
	else
		root["mapdc"] = factory(root["d3"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 151);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {//! moment.js
//! version : 2.13.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
     true ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, function () { 'use strict';

    var hookCallback;

    function utils_hooks__hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            m._isValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                m._isValid = m._isValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid (flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    function isUndefined(input) {
        return input === void 0;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (utils_hooks__hooks.deprecationHandler != null) {
                utils_hooks__hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (utils_hooks__hooks.deprecationHandler != null) {
            utils_hooks__hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;
    utils_hooks__hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function isObject(input) {
        return Object.prototype.toString.call(input) === '[object Object]';
    }

    function locale_set__set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    // internal storage for locale config files
    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                __webpack_require__(174)("./" + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = locale_locales__getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale');
                config = mergeConfigs(locales[name]._config, config);
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    config = mergeConfigs(locales[config.parentLocale]._config, config);
                } else {
                    // treat as if there is no base config
                    deprecateSimple('parentLocaleUndefined',
                            'specified parentLocale is not defined yet');
                }
            }
            locales[name] = new Locale(config);

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale;
            if (locales[name] != null) {
                config = mergeConfigs(locales[name]._config, config);
            }
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function locale_locales__getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function locale_locales__listLocales() {
        return keys(locales);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function get_set__set (mom, unit, value) {
        if (mom.isValid()) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    // MOMENTS

    function getSet (units, value) {
        var unit;
        if (typeof units === 'object') {
            for (unit in units) {
                this.set(unit, units[unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        return isArray(this._months) ? this._months[m.month()] :
            this._months[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function units_month__handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = create_utc__createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return units_month__handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (typeof value !== 'number') {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    function createDate (y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));

        //the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(utils_hooks__hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    utils_hooks__hooks.ISO_8601 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (getParsingFlags(config).bigHour === true &&
                config._a[HOUR] <= 12 &&
                config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else if (isDate(input)) {
            config._d = input;
        } else {
            configFromInput(config);
        }

        if (!valid__isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date(utils_hooks__hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function local__createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
         'moment().min is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
         function () {
             var other = local__createLocal.apply(null, arguments);
             if (this.isValid() && other.isValid()) {
                 return other < this ? this : other;
             } else {
                 return valid__createInvalid();
             }
         }
     );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
        function () {
            var other = local__createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return valid__createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = ((string || '').match(matcher) || []);
        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
            } else if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            this.utcOffset(offsetFromString(matchOffset, this._i));
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? local__createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?\d*)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

    function create__createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])        * sign,
                h  : toInt(match[HOUR])        * sign,
                m  : toInt(match[MINUTE])      * sign,
                s  : toInt(match[SECOND])      * sign,
                ms : toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add      = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function moment_calendar__calendar (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            diff = this.diff(sod, 'days', true),
            format = diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format]() : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input,units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input,units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            delta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString () {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if (isFunction(Date.prototype.toISOString)) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }

        // 'date' is an alias for 'day', so it should be considered as such.
        if (units === 'date') {
            units = 'day';
        }

        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return this._offset ? new Date(this.valueOf()) : this._d;
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function moment_valid__isValid () {
        return valid__isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        return isArray(this._weekdays) ? this._weekdays[m.day()] :
            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return this._weekdaysShort[m.day()];
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return this._weekdaysMin[m.day()];
    }

    function day_of_week__handleStrictParse(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = create_utc__createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = create_utc__createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.
        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add               = add_subtract__add;
    momentPrototype__proto.calendar          = moment_calendar__calendar;
    momentPrototype__proto.clone             = clone;
    momentPrototype__proto.diff              = diff;
    momentPrototype__proto.endOf             = endOf;
    momentPrototype__proto.format            = format;
    momentPrototype__proto.from              = from;
    momentPrototype__proto.fromNow           = fromNow;
    momentPrototype__proto.to                = to;
    momentPrototype__proto.toNow             = toNow;
    momentPrototype__proto.get               = getSet;
    momentPrototype__proto.invalidAt         = invalidAt;
    momentPrototype__proto.isAfter           = isAfter;
    momentPrototype__proto.isBefore          = isBefore;
    momentPrototype__proto.isBetween         = isBetween;
    momentPrototype__proto.isSame            = isSame;
    momentPrototype__proto.isSameOrAfter     = isSameOrAfter;
    momentPrototype__proto.isSameOrBefore    = isSameOrBefore;
    momentPrototype__proto.isValid           = moment_valid__isValid;
    momentPrototype__proto.lang              = lang;
    momentPrototype__proto.locale            = locale;
    momentPrototype__proto.localeData        = localeData;
    momentPrototype__proto.max               = prototypeMax;
    momentPrototype__proto.min               = prototypeMin;
    momentPrototype__proto.parsingFlags      = parsingFlags;
    momentPrototype__proto.set               = getSet;
    momentPrototype__proto.startOf           = startOf;
    momentPrototype__proto.subtract          = add_subtract__subtract;
    momentPrototype__proto.toArray           = toArray;
    momentPrototype__proto.toObject          = toObject;
    momentPrototype__proto.toDate            = toDate;
    momentPrototype__proto.toISOString       = moment_format__toISOString;
    momentPrototype__proto.toJSON            = toJSON;
    momentPrototype__proto.toString          = toString;
    momentPrototype__proto.unix              = unix;
    momentPrototype__proto.valueOf           = to_type__valueOf;
    momentPrototype__proto.creationData      = creationData;

    // Year
    momentPrototype__proto.year       = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear    = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month       = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
    momentPrototype__proto.weeksInYear    = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date       = getSetDayOfMonth;
    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset            = getSetOffset;
    momentPrototype__proto.utc                  = setOffsetToUTC;
    momentPrototype__proto.local                = setOffsetToLocal;
    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST                = isDaylightSavingTime;
    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
    momentPrototype__proto.isLocal              = isLocal;
    momentPrototype__proto.isUtcOffset          = isUtcOffset;
    momentPrototype__proto.isUtc                = isUtc;
    momentPrototype__proto.isUTC                = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);

    var momentPrototype = momentPrototype__proto;

    function moment__createUnix (input) {
        return local__createLocal(input * 1000);
    }

    function moment__createInZone () {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function locale_calendar__calendar (key, mom, now) {
        var output = this._calendar[key];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    function preParsePostFormat (string) {
        return string;
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var prototype__proto = Locale.prototype;

    prototype__proto._calendar       = defaultCalendar;
    prototype__proto.calendar        = locale_calendar__calendar;
    prototype__proto._longDateFormat = defaultLongDateFormat;
    prototype__proto.longDateFormat  = longDateFormat;
    prototype__proto._invalidDate    = defaultInvalidDate;
    prototype__proto.invalidDate     = invalidDate;
    prototype__proto._ordinal        = defaultOrdinal;
    prototype__proto.ordinal         = ordinal;
    prototype__proto._ordinalParse   = defaultOrdinalParse;
    prototype__proto.preparse        = preParsePostFormat;
    prototype__proto.postformat      = preParsePostFormat;
    prototype__proto._relativeTime   = defaultRelativeTime;
    prototype__proto.relativeTime    = relative__relativeTime;
    prototype__proto.pastFuture      = pastFuture;
    prototype__proto.set             = locale_set__set;

    // Month
    prototype__proto.months            =        localeMonths;
    prototype__proto._months           = defaultLocaleMonths;
    prototype__proto.monthsShort       =        localeMonthsShort;
    prototype__proto._monthsShort      = defaultLocaleMonthsShort;
    prototype__proto.monthsParse       =        localeMonthsParse;
    prototype__proto._monthsRegex      = defaultMonthsRegex;
    prototype__proto.monthsRegex       = monthsRegex;
    prototype__proto._monthsShortRegex = defaultMonthsShortRegex;
    prototype__proto.monthsShortRegex  = monthsShortRegex;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto._week = defaultLocaleWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays       =        localeWeekdays;
    prototype__proto._weekdays      = defaultLocaleWeekdays;
    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

    prototype__proto._weekdaysRegex      = defaultWeekdaysRegex;
    prototype__proto.weekdaysRegex       =        weekdaysRegex;
    prototype__proto._weekdaysShortRegex = defaultWeekdaysShortRegex;
    prototype__proto.weekdaysShortRegex  =        weekdaysShortRegex;
    prototype__proto._weekdaysMinRegex   = defaultWeekdaysMinRegex;
    prototype__proto.weekdaysMinRegex    =        weekdaysMinRegex;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get (format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = lists__get(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = locale_locales__getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return lists__get(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = lists__get(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function lists__listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function lists__listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function lists__listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function lists__listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function lists__listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract (duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf () {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function duration_get__get (units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function () {
            return this._data[name];
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45,  // seconds to minute
        m: 45,  // minutes to hour
        h: 22,  // hours to day
        d: 26,  // days to month
        M: 11   // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds]  ||
                minutes <= 1           && ['m']           ||
                minutes < thresholds.m && ['mm', minutes] ||
                hours   <= 1           && ['h']           ||
                hours   < thresholds.h && ['hh', hours]   ||
                days    <= 1           && ['d']           ||
                days    < thresholds.d && ['dd', days]    ||
                months  <= 1           && ['M']           ||
                months  < thresholds.M && ['MM', months]  ||
                years   <= 1           && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize (withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days         = iso_string__abs(this._days);
        var months       = iso_string__abs(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs            = duration_abs__abs;
    duration_prototype__proto.add            = duration_add_subtract__add;
    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
    duration_prototype__proto.as             = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds      = asSeconds;
    duration_prototype__proto.asMinutes      = asMinutes;
    duration_prototype__proto.asHours        = asHours;
    duration_prototype__proto.asDays         = asDays;
    duration_prototype__proto.asWeeks        = asWeeks;
    duration_prototype__proto.asMonths       = asMonths;
    duration_prototype__proto.asYears        = asYears;
    duration_prototype__proto.valueOf        = duration_as__valueOf;
    duration_prototype__proto._bubble        = bubble;
    duration_prototype__proto.get            = duration_get__get;
    duration_prototype__proto.milliseconds   = milliseconds;
    duration_prototype__proto.seconds        = seconds;
    duration_prototype__proto.minutes        = minutes;
    duration_prototype__proto.hours          = hours;
    duration_prototype__proto.days           = days;
    duration_prototype__proto.weeks          = weeks;
    duration_prototype__proto.months         = months;
    duration_prototype__proto.years          = years;
    duration_prototype__proto.humanize       = humanize;
    duration_prototype__proto.toISOString    = iso_string__toISOString;
    duration_prototype__proto.toString       = iso_string__toISOString;
    duration_prototype__proto.toJSON         = iso_string__toISOString;
    duration_prototype__proto.locale         = locale;
    duration_prototype__proto.localeData     = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    utils_hooks__hooks.version = '2.13.0';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn                    = momentPrototype;
    utils_hooks__hooks.min                   = min;
    utils_hooks__hooks.max                   = max;
    utils_hooks__hooks.now                   = now;
    utils_hooks__hooks.utc                   = create_utc__createUTC;
    utils_hooks__hooks.unix                  = moment__createUnix;
    utils_hooks__hooks.months                = lists__listMonths;
    utils_hooks__hooks.isDate                = isDate;
    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid               = valid__createInvalid;
    utils_hooks__hooks.duration              = create__createDuration;
    utils_hooks__hooks.isMoment              = isMoment;
    utils_hooks__hooks.weekdays              = lists__listWeekdays;
    utils_hooks__hooks.parseZone             = moment__createInZone;
    utils_hooks__hooks.localeData            = locale_locales__getLocale;
    utils_hooks__hooks.isDuration            = isDuration;
    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale          = defineLocale;
    utils_hooks__hooks.updateLocale          = updateLocale;
    utils_hooks__hooks.locales               = locale_locales__listLocales;
    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
    utils_hooks__hooks.prototype             = momentPrototype;

    var _moment = utils_hooks__hooks;

    return _moment;

}));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(173)(module)))

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.round = exports.units = exports.chartRegistry = exports.constants = undefined;
exports.logging = logging;
exports.sampledCount = sampledCount;
exports.incrementSampledCount = incrementSampledCount;
exports.decrementSampledCount = decrementSampledCount;
exports.refreshDisabled = refreshDisabled;
exports.disableRefresh = disableRefresh;
exports.enableRefresh = enableRefresh;
exports.globalTransitionDuration = globalTransitionDuration;
exports.disableTransitions = disableTransitions;
exports.registerChart = registerChart;
exports.getChart = getChart;
exports.deregisterChart = deregisterChart;
exports.hasChart = hasChart;
exports.deregisterAllCharts = deregisterAllCharts;
exports.filterAll = filterAll;
exports.refocusAll = refocusAll;
exports.transition = transition;
exports.optionalTransition = optionalTransition;
exports.afterTransition = afterTransition;
exports.override = override;
exports.renderlet = renderlet;
exports.instanceOfChart = instanceOfChart;

var _utils = __webpack_require__(3);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var _logging = false;
var _sampledCount = 0;
var _refreshDisabled = false;
var _globalTransitionDuration = null;
var _renderlet = null;
var _disableTransitions = false;

var constants = exports.constants = {
  CHART_CLASS: "dc-chart",
  DEBUG_GROUP_CLASS: "debug",
  STACK_CLASS: "stack",
  DESELECTED_CLASS: "deselected",
  SELECTED_CLASS: "selected",
  NODE_INDEX_NAME: "__index__",
  GROUP_INDEX_NAME: "__group_index__",
  DEFAULT_CHART_GROUP: "__default_chart_group__",
  NEGLIGIBLE_NUMBER: 1e-10,
  ACCENT_CLASS: "accented",
  EVENT_DELAY: 0
};

function logging(_) {
  if (!arguments.length) {
    return _logging;
  }
  _logging = _;
}

function sampledCount(_) {
  if (!arguments.length) {
    return _sampledCount;
  }
  _sampledCount = _;
}

function incrementSampledCount() {
  return _sampledCount++;
}

function decrementSampledCount() {
  return _sampledCount--;
}

function refreshDisabled(_) {
  if (!arguments.length) {
    return _refreshDisabled;
  }
  _refreshDisabled = _;
}

function disableRefresh() {
  _refreshDisabled = true;
}

function enableRefresh() {
  _refreshDisabled = false;
}

function globalTransitionDuration(_) {
  if (!arguments.length) {
    return _globalTransitionDuration;
  }
  _globalTransitionDuration = _;
}

function disableTransitions(_) {
  if (!arguments.length) {
    return _disableTransitions;
  }
  _disableTransitions = _;
}

var chartRegistry = exports.chartRegistry = function () {
  // chartGroup:string => charts:array
  var _chartMap = {};

  function initializeChartGroup(group) {
    if (!group) {
      group = constants.DEFAULT_CHART_GROUP;
    }

    if (!_chartMap[group]) {
      _chartMap[group] = [];
    }

    return group;
  }

  return {
    has: function has(chart) {
      for (var e in _chartMap) {
        if (_chartMap[e].indexOf(chart) >= 0) {
          return true;
        }
      }
      return false;
    },
    register: function register(chart, group) {
      if (Array.isArray(group)) {
        group.forEach(function (g) {
          return _chartMap[initializeChartGroup(g)].push(chart);
        });
      } else {
        _chartMap[initializeChartGroup(group)].push(chart);
      }
    },
    deregister: function deregister(chart, group) {
      if (Array.isArray(group)) {
        group.forEach(function (g) {
          group = initializeChartGroup(g);
          for (var i = 0; i < _chartMap[group].length; i++) {
            if (_chartMap[group][i].anchorName() === chart.anchorName()) {
              _chartMap[group].splice(i, 1);
              break;
            }
          }
        });
      } else {
        group = initializeChartGroup(group);
        for (var i = 0; i < _chartMap[group].length; i++) {
          if (_chartMap[group][i].anchorName() === chart.anchorName()) {
            _chartMap[group].splice(i, 1);
            break;
          }
        }
      }
    },
    clear: function clear(group) {
      if (Array.isArray(group)) {
        group.forEach(function (g) {
          return delete _chartMap[g];
        });
      } else if (group) {
        delete _chartMap[group];
      } else {
        _chartMap = {};
      }
    },
    list: function list(group) {
      if (Array.isArray(group)) {
        return group.reduce(function (accum, g) {
          return [].concat(_toConsumableArray(accum), _toConsumableArray(_chartMap[initializeChartGroup(g)]));
        }, []).filter(function (item, i, self) {
          return self.indexOf(item) === i;
        });
      } else {
        group = initializeChartGroup(group);
        return _chartMap[group];
      }
    },
    listAll: function listAll() {
      return Object.keys(_chartMap).reduce(function (accum, key) {
        return accum.concat(_chartMap[key]);
      }, []).filter(function (item, i, self) {
        return self.indexOf(item) === i;
      });
    }
  };
}();

function registerChart(chart, group) {
  chartRegistry.register(chart, group);
}

function getChart(dcFlag) {
  return chartRegistry.listAll().reduce(function (accum, chrt) {
    return chrt.__dcFlag__ === dcFlag ? chrt : accum;
  }, null);
}

function deregisterChart(chart, group) {
  chartRegistry.deregister(chart, group);
}

function hasChart(chart) {
  return chartRegistry.has(chart);
}

function deregisterAllCharts(group) {
  chartRegistry.clear(group);
}

/**
 * Clear all filters on all charts within the given chart group. If the chart group is not given then
 * only charts that belong to the default chart group will be reset.
 * @memberof dc
 * @name filterAll
 * @param {String} [group]
 */
function filterAll(group) {
  var charts = chartRegistry.list(group);
  for (var i = 0; i < charts.length; ++i) {
    charts[i].filterAll();
  }
}

/**
 * Reset zoom level / focus on all charts that belong to the given chart group. If the chart group is
 * not given then only charts that belong to the default chart group will be reset.
 * @memberof dc
 * @name refocusAll
 * @param {String} [group]
 */
function refocusAll(group) {
  var charts = chartRegistry.list(group);
  for (var i = 0; i < charts.length; ++i) {
    if (charts[i].focus) {
      charts[i].focus();
    }
  }
}

function transition(selections, duration, callback, name) {
  if (duration <= 0 || duration === undefined || _disableTransitions) {
    return selections;
  }

  var s = selections.transition(name).duration(duration);

  if (typeof callback === "function") {
    callback(s);
  }

  return s;
}

/* somewhat silly, but to avoid duplicating logic */
function optionalTransition(enable, duration, callback, name) {
  if (enable) {
    return function (selection) {
      return transition(selection, duration, callback, name);
    };
  } else {
    return function (selection) {
      return selection;
    };
  }
}

// See http://stackoverflow.com/a/20773846
function afterTransition(_transition, callback) {
  if (_transition.empty() || !_transition.duration) {
    callback.call(_transition);
  } else {
    var n = 0;
    _transition.each(function () {
      ++n;
    }).each("end", function () {
      if (! --n) {
        callback.call(_transition);
      }
    });
  }
}

/**
 * @name units
 * @memberof dc
 * @type {{}}
 */
var units = exports.units = {};

/**
 * The default value for {@link #dc.coordinateGridMixin+xUnits .xUnits} for the
 * {@link #dc.coordinateGridMixin Coordinate Grid Chart} and should
 * be used when the x values are a sequence of integers.
 * It is a function that counts the number of integers in the range supplied in its start and end parameters.
 * @name integers
 * @memberof units
 * @see {@link #dc.coordinateGridMixin+xUnits coordinateGridMixin.xUnits}
 * @example
 * chart.xUnits(units.integers) // already the default
 * @param {Number} start
 * @param {Number} end
 * @return {Number}
 */
units.integers = function (start, end) {
  return Math.abs(end - start);
};

/**
 * This argument can be passed to the {@link #dc.coordinateGridMixin+xUnits .xUnits} function of the to
 * specify ordinal units for the x axis. Usually this parameter is used in combination with passing
 * {@link https://github.com/mbostock/d3/wiki/Ordinal-Scales d3.scale.ordinal} to
 * {@link #dc.coordinateGridMixin+x .x}.
 * It just returns the domain passed to it, which for ordinal charts is an array of all values.
 * @name ordinal
 * @memberof units
 * @see {@link https://github.com/mbostock/d3/wiki/Ordinal-Scales d3.scale.ordinal}
 * @see {@link #dc.coordinateGridMixin+xUnits coordinateGridMixin.xUnits}
 * @see {@link #dc.coordinateGridMixin+x coordinateGridMixin.x}
 * @example
 * chart.xUnits(dc.units.ordinal)
 *      .x(d3.scale.ordinal())
 * @param {*} start
 * @param {*} end
 * @param {Array<String>} domain
 * @return {Array<String>}
 */
units.ordinal = function (start, end, domain) {
  return domain;
};

/**
 * @name fp
 * @memberof units
 * @type {{}}
 */
units.fp = {};
/**
 * This function generates an argument for the {@link #dc.coordinateGridMixin Coordinate Grid Chart}
 * {@link #dc.coordinateGridMixin+xUnits .xUnits} function specifying that the x values are floating-point
 * numbers with the given precision.
 * The returned function determines how many values at the given precision will fit into the range
 * supplied in its start and end parameters.
 * @name precision
 * @memberof units.fp
 * @see {@link #dc.coordinateGridMixin+xUnits coordinateGridMixin.xUnits}
 * @example
 * // specify values (and ticks) every 0.1 units
 * chart.xUnits(units.fp.precision(0.1)
 * // there are 500 units between 0.5 and 1 if the precision is 0.001
 * var thousandths = units.fp.precision(0.001);
 * thousandths(0.5, 1.0) // returns 500
 * @param {Number} precision
 * @return {Function} start-end unit function
 */
units.fp.precision = function (precision) {
  var _f = function _f(s, e) {
    var d = Math.abs((e - s) / _f.resolution);
    if (_utils.utils.isNegligible(d - Math.floor(d))) {
      return Math.floor(d);
    } else {
      return Math.ceil(d);
    }
  };
  _f.resolution = precision;
  return _f;
};

var round = exports.round = {};
round.floor = function (n) {
  return Math.floor(n);
};
round.ceil = function (n) {
  return Math.ceil(n);
};
round.round = function (n) {
  return Math.round(n);
};

function override(obj, functionName, newFunction) {
  var existingFunction = obj[functionName];
  obj["_" + functionName] = existingFunction;
  obj[functionName] = newFunction;
}

function renderlet(_) {
  if (!arguments.length) {
    return _renderlet;
  }
  _renderlet = _;
}

function instanceOfChart(o) {
  return o instanceof Object && o.__dcFlag__ && true;
}

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utils = exports.pluck = exports.printers = exports.customTimeFormat = exports.TIME_UNITS = exports.deepClone = exports.deepEquals = exports.dateFormat = exports.parser = undefined;
exports.extractTickFormat = extractTickFormat;
exports.xDomain = xDomain;
exports.xScale = xScale;
exports.xAxisTickFormat = xAxisTickFormat;

var _mapdDataLayer = __webpack_require__(155);

var _formattingHelpers = __webpack_require__(6);

var _datesAndTimes = __webpack_require__(27);

var _deepEqual = __webpack_require__(128);

var _deepEqual2 = _interopRequireDefault(_deepEqual);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _core = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var parser = exports.parser = (0, _mapdDataLayer.createParser)();

function hexBinSQL(sql, _ref, parser) {
  var width = _ref.width,
      height = _ref.height,
      mark = _ref.mark,
      x = _ref.x,
      y = _ref.y,
      aggregate = _ref.aggregate;

  var hexoffsetx = 0;
  var hexoffsety = 0;

  var heximgwidth = width;
  var heximgheight = height;

  var hexminmercx = x.domain[0];
  var hexmaxmercx = x.domain[1];
  var hexminmercy = y.domain[0];
  var hexmaxmercy = y.domain[1];

  if (hexoffsetx) {
    var mercxdiff = hexoffsetx * (hexmaxmercx - hexminmercx) / heximgwidth;
    hexminmercx = hexminmercx - mercxdiff;
    hexmaxmercx = hexmaxmercx - mercxdiff;
  }

  if (hexoffsety) {
    var mercydiff = hexoffsety * (hexmaxmercy - hexminmercy) / heximgheight;
    hexminmercy = hexminmercy - mercydiff;
    hexmaxmercy = hexmaxmercy - mercydiff;
  }

  var args = parser.parseExpression(x.field) + "," + (hexminmercx + ",") + (hexmaxmercx + ",") + (parser.parseExpression(y.field) + ",") + (hexminmercy + ",") + (hexmaxmercy + ",") + (mark.width + ",") + (mark.height + ",") + (hexoffsetx + ",") + (hexoffsety + ",") + (width + ",") + ("" + height);

  sql.select.push("reg_" + mark.shape + "_horiz_pixel_bin_x(" + args + ") as x");
  sql.select.push("reg_" + mark.shape + "_horiz_pixel_bin_y(" + args + ") as y");
  sql.select.push(parser.parseExpression(aggregate) + " as color");
  sql.groupby.push("x");
  sql.groupby.push("y");

  return sql;
}

function rectBinSQL(sql, _ref2, parser) {
  var width = _ref2.width,
      height = _ref2.height,
      mark = _ref2.mark,
      x = _ref2.x,
      y = _ref2.y,
      aggregate = _ref2.aggregate;

  sql.select.push("rect_pixel_bin_x(" + parser.parseExpression(x.field) + ", " + x.domain[0] + ", " + x.domain[1] + ", " + mark.width + ", 0, " + width + ") as x");
  sql.select.push("rect_pixel_bin_y(" + parser.parseExpression(y.field) + ", " + y.domain[0] + ", " + y.domain[1] + ", " + mark.height + ", 0, " + height + ") as y");
  sql.select.push(parser.parseExpression(aggregate) + " as color");
  sql.groupby.push("x");
  sql.groupby.push("y");

  return sql;
}

parser.registerParser({
  meta: "transform",
  type: "pixel_bin"
}, function (sql, transform, parser) {
  switch (transform.mark.shape) {
    case "hex":
      return hexBinSQL(sql, transform, parser);
    case "square":
      return rectBinSQL(sql, transform, parser);
    default:
      return sql;
  }
});

parser.registerParser({
  meta: "transform",
  type: "rowid"
}, function (sql, transform) {
  var rowid = transform.table + ".rowid";
  sql.select.push(rowid);
  sql.groupby.push(rowid);
  return sql;
});

var dateFormat = exports.dateFormat = _d2.default.time.format("%m/%d/%Y");

var deepEquals = exports.deepEquals = __webpack_require__(128); // eslint-disable-line global-require

var deepClone = exports.deepClone = function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
};

var TIME_UNITS = exports.TIME_UNITS = {
  DATE: true,
  TIMESTAMP: true,
  date: true,
  datetime: true,
  timestamp: true,
  "timestamp without timezone": true,
  TIME: true

  /* istanbul ignore next */
};var customTimeFormat = exports.customTimeFormat = _d2.default.time.format.utc.multi([[".%L", function (d) {
  return d.getUTCMilliseconds();
}], [":%S", function (d) {
  return d.getUTCSeconds();
}], ["%I:%M", function (d) {
  return d.getUTCMinutes();
}], ["%I %p", function (d) {
  return d.getUTCHours();
}], ["%a %d", function (d) {
  return d.getUTCDay() && d.getUTCDate() != 1;
}], // eslint-disable-line eqeqeq
["%b %d", function (d) {
  return d.getUTCDate() != 1;
}], // eslint-disable-line eqeqeq
["%b", function (d) {
  return d.getUTCMonth();
}], ["%Y", function () {
  return true;
}]]);

function extractTickFormat(timeBin) {
  return function (tick) {
    switch (timeBin) {
      case "year":
        return Math.ceil(tick);
      case "isodow":
        return _datesAndTimes.DAYS[tick - 1];
      case "month":
        return _datesAndTimes.MONTHS[tick - 1];
      case "quarter":
        return _datesAndTimes.QUARTERS[tick - 1];
      case "hour":
      case "minute":
        return tick + 1;
      default:
        return tick;
    }
  };
}

function xDomain(extract, currentLowValue, currentHighValue, timeBin) {
  if (extract) {
    switch (timeBin) {
      case "year":
        return [currentLowValue.getFullYear(), currentHighValue.getFullYear()];
      case "quarter":
        return [1, 4]; // eslint-disable-line no-magic-numbers
      case "isodow":
        return [1, 7]; // eslint-disable-line no-magic-numbers
      case "month":
        return [1, 12]; // eslint-disable-line no-magic-numbers
      case "day":
        return [1, 31]; // eslint-disable-line no-magic-numbers
      case "hour":
        return [0, 23]; // eslint-disable-line no-magic-numbers
      case "minute":
        return [0, 59]; // eslint-disable-line no-magic-numbers
      default:
        return [1, 7]; // eslint-disable-line no-magic-numbers
    }
  } else {
    return [currentLowValue, currentHighValue];
  }
}

function xScale(extract, isChartDate) {
  if (extract || !isChartDate) {
    return _d2.default.scale.linear();
  } else {
    return _d2.default.time.scale.utc();
  }
}

function xAxisTickFormat(_ref3, isChartDate) {
  var extract = _ref3.extract,
      timeBin = _ref3.timeBin;

  if (extract) {
    return utils.extractTickFormat(timeBin);
  } else if (isChartDate) {
    return customTimeFormat;
  } else {
    return _d2.default.format(".2s");
  }
}

var printers = exports.printers = {};

printers.filters = function (filters) {
  var s = "";

  for (var i = 0; i < filters.length; ++i) {
    if (i > 0) {
      s = s + ", ";
    }
    s = s + printers.filter(filters[i]);
  }

  return s;
};

printers.filter = function (filter) {
  var s = "";

  if (typeof filter !== "undefined" && filter !== null) {
    if (filter instanceof Array) {
      if (filter.length >= 2) {
        s = "[" + utils.printSingleValue(filter[0]) + " -> " + utils.printSingleValue(filter[1]) + "]";
      } else if (filter.length >= 1) {
        s = utils.printSingleValue(filter[0]);
      }
    } else {
      s = utils.printSingleValue(filter);
    }
  }

  return s;
};

var pluck = exports.pluck = function pluck(n, f) {
  if (!f) {
    return function (d) {
      return d[n];
    };
  }
  return function (d, i) {
    return f.call(d, d[n], i);
  };
};

var utils = exports.utils = {};

utils.printSingleValue = function (filter) {
  var s = String(filter);

  if (filter instanceof Date) {
    s = dateFormat(filter);
  } else if (typeof filter === "string") {
    s = filter;
  } else if (utils.isFloat(filter)) {
    s = utils.printSingleValue.fformat(filter);
  } else if (utils.isInteger(filter)) {
    s = Math.round(filter);
  }

  return s;
};
utils.printSingleValue.fformat = _d2.default.format(".2f");

// FIXME: these assume than any string r is a percentage (whether or not it
// includes %).
utils.add = function (l, r, c) {
  if (typeof r === "string") {
    r = r.replace("%", "");
  }

  if (l instanceof Date) {
    if (typeof r === "string") {
      r = Number(r);
    }
    var d = new Date();
    d.setTime(l.getTime());
    d.setDate(l.getDate() + r);
    return d;
  } else if (typeof r === "string") {
    var percentage = Number(r) / 100;
    return l + c * percentage;
  } else {
    return l + r;
  }
};

utils.subtract = function (l, r, c) {
  if (typeof r === "string") {
    r = r.replace("%", "");
  }

  if (l instanceof Date) {
    if (typeof r === "string") {
      r = Number(r);
    }
    var d = new Date();
    d.setTime(l.getTime());
    d.setDate(l.getDate() - r);
    return d;
  } else if (typeof r === "string") {
    var percentage = Number(r) / 100;
    return l - c * percentage;
  } else {
    return l - r;
  }
};

utils.isNumber = function (n) {
  return n === Number(n);
};

utils.isFloat = function (n) {
  return n === Number(n) && n !== (n | 0);
};

utils.isInteger = function (n) {
  return n === Number(n) && n === (n | 0);
};

utils.isNegligible = function (n) {
  return !utils.isNumber(n) || n < _core.constants.NEGLIGIBLE_NUMBER && n > -_core.constants.NEGLIGIBLE_NUMBER;
};

utils.clamp = function (val, min, max) {
  return val < min ? min : val > max ? max : val;
};

var _idCounter = 0;
utils.uniqueId = function () {
  return ++_idCounter;
};

utils.nameToId = function (name) {
  if (parseFloat(name)) {
    return name;
  } else {
    return name.toLowerCase().replace(/[\s]/g, "_").replace(/[\.']/g, "");
  }
};

utils.appendOrSelect = function (parent, selector, tag) {
  tag = tag || selector;
  var element = parent.select(selector);
  if (element.empty()) {
    element = parent.append(tag);
  }
  return element;
};

utils.safeNumber = function (n) {
  return utils.isNumber(Number(n)) ? Number(n) : 0;
};

utils.b64toBlob = function (b64Data, contentType, sliceSize) {
  contentType = contentType || "";
  sliceSize = sliceSize || 512;

  var byteCharacters = atob(b64Data);
  var byteArrays = [];

  for (var offset = 0; offset < byteCharacters.length; offset = offset + sliceSize) {
    var slice = byteCharacters.slice(offset, offset + sliceSize);

    var byteNumbers = new Array(slice.length);
    for (var i = 0; i < slice.length; i++) {
      byteNumbers[i] = slice.charCodeAt(i);
    }

    var byteArray = new Uint8Array(byteNumbers);

    byteArrays.push(byteArray);
  }

  var blob = new Blob(byteArrays, { type: contentType });
  return blob;
};

utils.getFontSizeFromWidth = function (text, parent, chartWidth, chartHeight) {
  var BASE_FONT_SIZE = 12;
  var MIN_FONT_SIZE = 4;
  var tmpText = parent.append("span").style("font-size", BASE_FONT_SIZE + "px").style("position", "absolute").html(text);
  var node = tmpText.node();

  var textWidth = null;
  var textHeight = null;
  if (node.getBoundingClientRect) {
    var bbox = node.getBoundingClientRect();
    textWidth = bbox.width;
    textHeight = bbox.height;
  }

  tmpText.remove();

  var fontSizeWidth = BASE_FONT_SIZE * chartWidth / textWidth;
  var fontSizeHeight = BASE_FONT_SIZE * chartHeight / textHeight;

  return Math.max(Math.min(fontSizeWidth, fontSizeHeight), MIN_FONT_SIZE);
};

utils.isOrdinal = function (type) {
  var BOOL_TYPES = { BOOL: true };

  var TEXT_TYPES = {
    varchar: true,
    text: true,
    STR: true
  };

  var TEXT_AND_BOOL_TYPES = Object.assign({}, TEXT_TYPES, BOOL_TYPES);

  return type in TEXT_AND_BOOL_TYPES;
};

utils.isQuantitative = function (type) {
  var NUMERICAL_INTEGER_TYPES = {
    int2: true,
    int4: true,
    int8: true,
    SMALLINT: true,
    INT: true,
    BIGINT: true
  };

  var NUMERICAL_REAL_TYPES = {
    FLOAT: true,
    DOUBLE: true,
    DECIMAL: true
  };

  var NONCUSTOM_NUMERICAL_TYPES = Object.assign({}, NUMERICAL_INTEGER_TYPES, NUMERICAL_REAL_TYPES);

  return type in NONCUSTOM_NUMERICAL_TYPES;
};

utils.deepEquals = _deepEqual2.default;
utils.customTimeFormat = customTimeFormat;
utils.extractTickFormat = extractTickFormat;
utils.formatValue = _formattingHelpers.formatDataValue;
utils.maybeFormatInfinity = _formattingHelpers.maybeFormatInfinity;

utils.nullsFirst = function (sorting) {
  return function (a, b) {
    if (a === null) {
      return -1;
    } else if (b === null) {
      return 1;
    }

    return sorting(a, b);
  };
};

utils.nullsLast = function (sorting) {
  return function (a, b) {
    if (a === null) {
      return 1;
    } else if (b === null) {
      return -1;
    }

    return sorting(a, b);
  };
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.startRenderTime = startRenderTime;
exports.startRedrawTime = startRedrawTime;
exports.resetRedrawStack = resetRedrawStack;
exports.redrawStackEmpty = redrawStackEmpty;
exports.renderStackEmpty = renderStackEmpty;
exports.isEqualToRedrawCount = isEqualToRedrawCount;
exports.incrementRenderStack = incrementRenderStack;
exports.resetRenderStack = resetRenderStack;
exports.isEqualToRenderCount = isEqualToRenderCount;
exports.redrawAllAsync = redrawAllAsync;
exports.renderAllAsync = renderAllAsync;
exports.groupAll = groupAll;
exports.getLastFilteredSizeAsync = getLastFilteredSizeAsync;
exports.lastFilteredSize = lastFilteredSize;
exports.setLastFilteredSize = setLastFilteredSize;
exports.resetState = resetState;

var _core = __webpack_require__(2);

var _renderId = 0;
var _redrawId = 0;
var _renderCount = 0;
var _redrawCount = 0;
var _renderIdStack = null;
var _redrawIdStack = null;
var _renderStackEmpty = true;
var _redrawStackEmpty = true;
var _startRenderTime = null;
var _startRedrawTime = null;

var _groupAll = {};
var _lastFilteredSize = {};

function startRenderTime() {
  return _startRenderTime;
}

function startRedrawTime() {
  return _startRedrawTime;
}

function resetRedrawStack() {
  _redrawCount = 0;
  _redrawIdStack = null;
}

function redrawStackEmpty(isRedrawStackEmpty) {
  if (!arguments.length) {
    return _redrawStackEmpty;
  }
  _redrawStackEmpty = isRedrawStackEmpty;
  return _redrawStackEmpty;
}

function renderStackEmpty(isRenderStackEmpty) {
  if (!arguments.length) {
    return _renderStackEmpty;
  }
  _renderStackEmpty = isRenderStackEmpty;
  return _renderStackEmpty;
}

function isEqualToRedrawCount(queryCount) {
  return ++_redrawCount === queryCount;
}

function incrementRenderStack() {
  var queryGroupId = _renderId++;
  _renderIdStack = queryGroupId;
  return queryGroupId;
}

function resetRenderStack() {
  _renderCount = 0;
  _renderIdStack = null;
}

function isEqualToRenderCount(queryCount) {
  return ++_renderCount === queryCount;
}

function redrawAllAsync(group, allCharts) {
  if ((0, _core.refreshDisabled)()) {
    return Promise.resolve();
  }

  if (!startRenderTime()) {
    return Promise.reject("redrawAllAsync() is called before renderAllAsync(), please call renderAllAsync() first.");
  }

  var queryGroupId = _redrawId++;
  var stackEmpty = _redrawIdStack === null;
  _redrawIdStack = queryGroupId;

  if (!stackEmpty) {
    _redrawStackEmpty = false;
    return Promise.resolve();
  }

  _startRedrawTime = new Date();

  var charts = allCharts ? _core.chartRegistry.listAll() : _core.chartRegistry.list(group);

  var createRedrawPromises = function createRedrawPromises() {
    return charts.map(function (chart) {
      chart.expireCache();
      chart._invokeDataFetchListener();
      return chart.redrawAsync(queryGroupId, charts.length).catch(function (e) {
        chart._invokeDataErrorListener();
        throw e;
      });
    });
  };

  if ((0, _core.renderlet)() !== null) {
    (0, _core.renderlet)(group);
  }

  if (groupAll()) {
    return getLastFilteredSizeAsync().then(function () {
      return Promise.all(createRedrawPromises());
    }).catch(function (err) {
      console.log(err);
      resetRedrawStack();
      throw err;
    });
  } else {
    return Promise.all(createRedrawPromises()).catch(function (err) {
      console.log(err);
      resetRedrawStack();
      throw err;
    });
  }
}

function renderAllAsync(group, allCharts) {
  if ((0, _core.refreshDisabled)()) {
    return Promise.resolve();
  }

  var queryGroupId = _renderId++;
  var stackEmpty = _renderIdStack === null;
  _renderIdStack = queryGroupId;

  if (!stackEmpty) {
    _renderStackEmpty = false;
    return Promise.resolve();
  }

  _startRenderTime = new Date();

  var charts = allCharts ? _core.chartRegistry.listAll() : _core.chartRegistry.list(group);

  var createRenderPromises = function createRenderPromises() {
    return charts.map(function (chart) {
      chart.expireCache();
      return chart.renderAsync(queryGroupId, charts.length);
    });
  };

  if ((0, _core.renderlet)() !== null) {
    (0, _core.renderlet)(group);
  }

  if (groupAll()) {
    return getLastFilteredSizeAsync().then(function () {
      return Promise.all(createRenderPromises());
    });
  } else {
    return Promise.all(createRenderPromises());
  }
}

function groupAll(group) {
  if (!arguments.length) {
    for (var key in _groupAll) {
      if (_groupAll.hasOwnProperty(key)) {
        return _groupAll;
      }
    }
    return null;
  }

  _groupAll[group.getCrossfilterId()] = group;

  return _groupAll;
}

function getLastFilteredSizeAsync(arg) {
  var keyArray = [];
  var crossfilterId = null;
  if (typeof arg === "number") {
    crossfilterId = arg;
  } else if ((typeof arg === "undefined" ? "undefined" : _typeof(arg)) === "object" && typeof arg.getCrossfilterId === "function") {
    crossfilterId = arg.getCrossfilterId();
  }

  if (crossfilterId !== null) {
    var group = _groupAll[crossfilterId];
    if (group) {
      return group.valueAsync().then(function (value) {
        _lastFilteredSize[crossfilterId] = value;
        return value;
      });
    } else {
      return new Promise(function (reject) {
        return reject("The group with crossfilterId " + crossfilterId + " is not an active groupAll() group");
      });
    }
  } else if (arg) {
    return new Promise(function (reject) {
      return reject("The argument to getLastFilteredSizeAsync must be a crossfilterId or a group/groupAll object, or call getLastFilteredSizeAsync without an argument to calculate all groupAlls");
    });
  }

  return Promise.all(Object.keys(_groupAll).map(function (key) {
    keyArray.push(key);
    return _groupAll[key].valueAsync();
  })).then(function (values) {
    for (var i = 0; i < values.length; ++i) {
      _lastFilteredSize[keyArray[i]] = values[i];
    }
  });
}

function lastFilteredSize(crossfilterId) {
  return _lastFilteredSize[crossfilterId];
}

function setLastFilteredSize(crossfilterId, value) {
  _lastFilteredSize[crossfilterId] = value;
}

function resetState() {
  _groupAll = {};
  _lastFilteredSize = {};
  resetRedrawStack();
  resetRenderStack();
}

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = baseMixin;

var _utils = __webpack_require__(3);

var _core = __webpack_require__(2);

var _coreAsync = __webpack_require__(4);

var _asyncMixin = __webpack_require__(130);

var _asyncMixin2 = _interopRequireDefault(_asyncMixin);

var _legendMixin = __webpack_require__(178);

var _legendMixin2 = _interopRequireDefault(_legendMixin);

var _binningHelpers = __webpack_require__(17);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _errors = __webpack_require__(129);

var errors = _interopRequireWildcard(_errors);

var _filterMixin = __webpack_require__(179);

var _filterMixin2 = _interopRequireDefault(_filterMixin);

var _labelMixin = __webpack_require__(180);

var _labelMixin2 = _interopRequireDefault(_labelMixin);

var _logger = __webpack_require__(16);

var _multipleKeyAccessors = __webpack_require__(131);

var _multipleKeyLabelMixin = __webpack_require__(132);

var _multipleKeyLabelMixin2 = _interopRequireDefault(_multipleKeyLabelMixin);

var _spinnerMixin = __webpack_require__(133);

var _spinnerMixin2 = _interopRequireDefault(_spinnerMixin);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * `dc.baseMixin` is an abstract functional object representing a basic `dc` chart object
 * for all chart and widget implementations. Methods from the {@link #dc.baseMixin dc.baseMixin} are inherited
 * and available on all chart implementations in the `dc` library.
 * @name baseMixin
 * @memberof dc
 * @mixin
 * @param {Object} _chart
 * @return {dc.baseMixin}
 */
function baseMixin(_chart) {
  _chart.__dcFlag__ = _utils.utils.uniqueId();

  var _dimension = void 0;
  var _group = void 0;
  var _anchor = void 0;
  var _root = void 0;
  var _svg = void 0;
  var _isChild = void 0;
  var _popup = void 0;
  var _popupIsEnabled = true;
  var _redrawBrushFlag = false;
  var _isTargeting = false;
  var _colorByExpr = null;
  var _legendLock = null;
  var _legendUnlock = null;
  var _legendInputChange = null;

  var _minWidth = 200;

  var _defaultWidth = function _defaultWidth(element) {
    var width = element && element.getBoundingClientRect && element.getBoundingClientRect().width;
    return width && width > _minWidth ? width : _minWidth;
  };
  var _width = _defaultWidth;

  var _minHeight = 200;
  var _defaultHeight = function _defaultHeight(element) {
    var height = element && element.getBoundingClientRect && element.getBoundingClientRect().height;
    return height && height > _minHeight ? height : _minHeight;
  };
  var _height = _defaultHeight;

  var _keyAccessor = (0, _utils.pluck)("key");
  var _label = (0, _utils.pluck)("key");

  var _valueAccessor = (0, _utils.pluck)("val");
  var _orderSort = void 0;

  var _renderLabel = false;

  var _title = function _title(d) {
    return _chart.keyAccessor()(d) + ": " + _chart.valueAccessor()(d);
  };
  var _renderTitle = true;
  var _controlsUseVisibility = true;

  var _transitionDuration = 500;

  var _filterPrinter = _utils.printers.filters;

  var _mandatoryAttributes = ["dimension", "group"];

  var _chartGroup = _core.constants.DEFAULT_CHART_GROUP;

  var _listeners = _d2.default.dispatch("preRender", "postRender", "preRedraw", "postRedraw", "filtered", "zoomed", "renderlet", "pretransition");

  var _legend = void 0;
  var _commitHandler = void 0;
  var _valueFormatter = void 0;
  var _dateFormatter = void 0;

  /* OVERRIDE ---------------------------------------------------------------- */
  var _legendContinuous = void 0;

  var _topQueryCallback = null;

  var _registerQuery = function _registerQuery(callback) {
    var stackEmpty = _topQueryCallback == null;
    // need to check if max query?
    _topQueryCallback = callback;
    if (stackEmpty) {
      _topQueryCallback.func();
    }
  };

  var _popQueryStack = function _popQueryStack(id) {
    if (_topQueryCallback != null && id == _topQueryCallback.id) {
      _topQueryCallback = null;
    } else {
      _topQueryCallback.func();
    }
  };

  var _startNextQuery = function _startNextQuery() {
    _topQueryCallback.func();
    // var callback = _firstQueryCallback;
    // callback();
  };

  // override for count chart
  _chart.isCountChart = function () {
    return false;
  };
  /* ------------------------------------------------------------------------- */

  var _filters = [];

  var _filterHandler = function _filterHandler(dimension, filters) {
    if (filters.length === 0) {
      return filters;
    }
  };

  var _data = function _data(group) {
    return group.all();
  };
  /**
   * Set or get the height attribute of a chart. The height is applied to the SVGElement generated by
   * the chart when rendered (or re-rendered). If a value is given, then it will be used to calculate
   * the new height and the chart returned for method chaining.  The value can either be a numeric, a
   * function, or falsy. If no value is specified then the value of the current height attribute will
   * be returned.
   *
   * By default, without an explicit height being given, the chart will select the width of its
   * anchor element. If that isn't possible it defaults to 200 (provided by the
   * {@link #dc.baseMixin+minHeight minHeight} property). Setting the value falsy will return
   * the chart to the default behavior.
   * @name height
   * @memberof dc.baseMixin
   * @instance
   * @see {@link #dc.baseMixin+minHeight minHeight}
   * @example
   * // Default height
   * chart.height(function (element) {
   *     var height = element && element.getBoundingClientRect && element.getBoundingClientRect().height;
   *     return (height && height > chart.minHeight()) ? height : chart.minHeight();
   * });
   *
   * chart.height(250); // Set the chart's height to 250px;
   * chart.height(function(anchor) { return doSomethingWith(anchor); }); // set the chart's height with a function
   * chart.height(null); // reset the height to the default auto calculation
   * @param {Number|Function} [height]
   * @return {Number}
   * @return {dc.baseMixin}
   */
  _chart.height = function (height) {
    if (!arguments.length) {
      return _height(_root.node());
    }

    _height = _d2.default.functor(height || _defaultHeight);
    return _chart;
  };

  /**
   * Set or get the width attribute of a chart.
   * @name width
   * @memberof dc.baseMixin
   * @instance
   * @see {@link #dc.baseMixin+height height}
   * @see {@link #dc.baseMixin+minWidth minWidth}
   * @example
   * // Default width
   * chart.width(function (element) {
   *     var width = element && element.getBoundingClientRect && element.getBoundingClientRect().width;
   *     return (width && width > chart.minWidth()) ? width : chart.minWidth();
   * });
   * @param {Number|Function} [width]
   * @return {Number}
   * @return {dc.baseMixin}
   */
  _chart.width = function (width) {
    if (!arguments.length) {
      return _width(_root.node());
    }
    _width = _d2.default.functor(width || _defaultWidth);
    return _chart;
  };

  /* OVERRIDE ---------------------------------------------------------------- */
  _chart.accent = function () {}; // no-op
  _chart.unAccent = function () {}; // no-op
  /* ------------------------------------------------------------------------- */

  /**
   * Set or get the minimum width attribute of a chart. This only has effect when used with the default
   * {@link #dc.baseMixin+width width} function.
   * @name minWidth
   * @memberof dc.baseMixin
   * @instance
   * @see {@link #dc.baseMixin+width width}
   * @param {Number} [minWidth=200]
   * @return {Number}
   * @return {dc.baseMixin}
   */
  _chart.minWidth = function (minWidth) {
    if (!arguments.length) {
      return _minWidth;
    }
    _minWidth = minWidth;
    return _chart;
  };

  /**
   * Set or get the minimum height attribute of a chart. This only has effect when used with the default
   * {@link #dc.baseMixin+height height} function.
   * @name minHeight
   * @memberof dc.baseMixin
   * @instance
   * @see {@link #dc.baseMixin+height height}
   * @param {Number} [minHeight=200]
   * @return {Number}
   * @return {dc.baseMixin}
   */
  _chart.minHeight = function (minHeight) {
    if (!arguments.length) {
      return _minHeight;
    }
    _minHeight = minHeight;
    return _chart;
  };

  /**
   * **mandatory**
   *
   * Set or get the dimension attribute of a chart. In `dc`, a dimension can be any valid [crossfilter
   * dimension](https://github.com/square/crossfilter/wiki/API-Reference#wiki-dimension).
   *
   * If a value is given, then it will be used as the new dimension. If no value is specified then
   * the current dimension will be returned.
   * @name dimension
   * @memberof dc.baseMixin
   * @instance
   * @see {@link https://github.com/square/crossfilter/wiki/API-Reference#dimension crossfilter.dimension}
   * @example
   * var index = crossfilter([]);
   * var dimension = index.dimension(dc.pluck('key'));
   * chart.dimension(dimension);
   * @param {crossfilter.dimension} [dimension]
   * @return {crossfilter.dimension}
   * @return {dc.baseMixin}
   */
  _chart.dimension = function (dimension) {
    if (!arguments.length) {
      return _dimension;
    }
    _dimension = dimension;
    _chart.expireCache();
    return _chart;
  };

  /**
   * Set the data callback or retrieve the chart's data set. The data callback is passed the chart's
   * group and by default will return
   * {@link https://github.com/square/crossfilter/wiki/API-Reference#group_all group.all}.
   * This behavior may be modified to, for instance, return only the top 5 groups.
   * @name data
   * @memberof dc.baseMixin
   * @instance
   * @example
   * // Default data function
   * chart.data(function (group) { return group.all(); });
   *
   * chart.data(function (group) { return group.top(5); });
   * @param {Function} [callback]
   * @return {*}
   * @return {dc.baseMixin}
   */
  _chart.data = function (callback) {
    if (!arguments.length) {
      return _data.call(_chart, _group);
    }
    _data = _d2.default.functor(callback);
    _chart.expireCache();
    return _chart;
  };

  /**
   * **mandatory**
   *
   * Set or get the group attribute of a chart. In `dc` a group is a
   * {@link https://github.com/square/crossfilter/wiki/API-Reference#group-map-reduce crossfilter group}.
   * Usually the group should be created from the particular dimension associated with the same chart. If a value is
   * given, then it will be used as the new group.
   *
   * If no value specified then the current group will be returned.
   * If `name` is specified then it will be used to generate legend label.
   * @name group
   * @memberof dc.baseMixin
   * @instance
   * @see {@link https://github.com/square/crossfilter/wiki/API-Reference#group-map-reduce crossfilter.group}
   * @example
   * var index = crossfilter([]);
   * var dimension = index.dimension(dc.pluck('key'));
   * chart.dimension(dimension);
   * chart.group(dimension.group(crossfilter.reduceSum()));
   * @param {crossfilter.group} [group]
   * @param {String} [name]
   * @return {crossfilter.group}
   * @return {dc.baseMixin}
   */
  _chart.group = function (group, name) {
    if (!arguments.length) {
      return _group;
    }
    _group = group;
    _chart._groupName = name;
    _chart.expireCache();
    return _chart;
  };

  /**
   * Wrapper for binParams in Crossfilter.
   */
  _chart.binParams = function (binParams) {
    if (!arguments.length) {
      return _chart.group().binParams();
    }

    return (0, _binningHelpers.createBinParams)(_chart, binParams);
  };

  /**
   * Get or set an accessor to order ordinal dimensions.  This uses
   * {@link https://github.com/square/crossfilter/wiki/API-Reference#quicksort_by crossfilter.quicksort.by} as the
   * sort.
   * @name ordering
   * @memberof dc.baseMixin
   * @instance
   * @see {@link https://github.com/square/crossfilter/wiki/API-Reference#quicksort_by crossfilter.quicksort.by}
   * @example
   * // Default ordering accessor
   * _chart.ordering(dc.pluck('key'));
   * @param {Function} [orderFunction]
   * @return {Function}
   * @return {dc.baseMixin}
   */

  _chart.ordering = function (orderFunction) {
    if (!arguments.length) {
      return _ordering;
    }
    _ordering = orderFunction;
    _orderSort = crossfilter.quicksort.by(_ordering);
    _chart.expireCache();
    return _chart;
  };

  _chart._computeOrderedGroups = function (data) {
    var dataCopy = data.slice(0);

    /* OVERRIDE ---------------------------------------------------------------- */
    // if (dataCopy.length <= 1) {
    //     return dataCopy;
    // }
    //
    // if (!_orderSort) {
    //     _orderSort = crossfilter.quicksort.by(_ordering);
    // }
    //
    // return _orderSort(dataCopy, 0, dataCopy.length);
    /* ------------------------------------------------------------------------- */
    return dataCopy;
  };

  /**
   * Execute d3 single selection in the chart's scope using the given selector and return the d3
   * selection.
   *
   * This function is **not chainable** since it does not return a chart instance; however the d3
   * selection result can be chained to d3 function calls.
   * @name select
   * @memberof dc.baseMixin
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/Selections d3.selection}
   * @example
   * // Similar to:
   * d3.select('#chart-id').select(selector);
   * @return {d3.selection}
   */
  _chart.select = function (s) {
    return _root.select(s);
  };

  /**
   * Execute in scope d3 selectAll using the given selector and return d3 selection result.
   *
   * This function is **not chainable** since it does not return a chart instance; however the d3
   * selection result can be chained to d3 function calls.
   * @name selectAll
   * @memberof dc.baseMixin
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/Selections d3.selection}
   * @example
   * // Similar to:
   * d3.select('#chart-id').selectAll(selector);
   * @return {d3.selection}
   */
  _chart.selectAll = function (s) {
    return _root ? _root.selectAll(s) : null;
  };

  /**
   * Set the root SVGElement to either be an existing chart's root; or any valid [d3 single
   * selector](https://github.com/mbostock/d3/wiki/Selections#selecting-elements) specifying a dom
   * block element such as a div; or a dom element or d3 selection. Optionally registers the chart
   * within the chartGroup. This class is called internally on chart initialization, but be called
   * again to relocate the chart. However, it will orphan any previously created SVGElements.
   * @name anchor
   * @memberof dc.baseMixin
   * @instance
   * @param {anchorChart|anchorSelector|anchorNode} [parent]
   * @param {String} [chartGroup]
   * @return {String|node|d3.selection}
   * @return {dc.baseMixin}
   */
  _chart.anchor = function (parent, chartGroup) {
    if (!arguments.length) {
      return _anchor;
    }
    if ((0, _core.instanceOfChart)(parent)) {
      _anchor = parent.anchor();
      _root = parent.root();
      _isChild = true;
    } else if (parent) {
      if (parent.select && parent.classed) {
        // detect d3 selection
        _anchor = parent.node();
      } else {
        _anchor = parent;
      }
      _root = _d2.default.select(_anchor);
      _root.classed(_core.constants.CHART_CLASS, true);
      (0, _core.registerChart)(_chart, chartGroup);
      _isChild = false;
    } else {
      throw new errors.BadArgumentException("parent must be defined");
    }
    _chartGroup = chartGroup;
    return _chart;
  };

  /**
   * Returns the DOM id for the chart's anchored location.
   * @name anchorName
   * @memberof dc.baseMixin
   * @instance
   * @return {String}
   */
  _chart.anchorName = function () {
    var a = _chart.anchor();
    if (a && a.id) {
      return a.id;
    }
    if (a && a.replace) {
      return a.replace("#", "");
    }
    return "dc-chart" + _chart.chartID();
  };

  /**
   * Returns the root element where a chart resides. Usually it will be the parent div element where
   * the SVGElement was created. You can also pass in a new root element however this is usually handled by
   * dc internally. Resetting the root element on a chart outside of dc internals may have
   * unexpected consequences.
   * @name root
   * @memberof dc.baseMixin
   * @instance
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement HTMLElement}
   * @param {HTMLElement} [rootElement]
   * @return {HTMLElement}
   * @return {dc.baseMixin}
   */
  _chart.root = function (rootElement) {
    if (!arguments.length) {
      return _root;
    }
    _root = rootElement;
    return _chart;
  };

  /**
   * Returns the top SVGElement for this specific chart. You can also pass in a new SVGElement,
   * however this is usually handled by dc internally. Resetting the SVGElement on a chart outside
   * of dc internals may have unexpected consequences.
   * @name svg
   * @memberof dc.baseMixin
   * @instance
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/SVGElement SVGElement}
   * @param {SVGElement|d3.selection} [svgElement]
   * @return {SVGElement|d3.selection}
   * @return {dc.baseMixin}
   */
  _chart.svg = function (svgElement) {
    if (!arguments.length) {
      return _svg;
    }
    _svg = svgElement;
    return _chart;
  };

  /**
   * Remove the chart's SVGElements from the dom and recreate the container SVGElement.
   * @name resetSvg
   * @memberof dc.baseMixin
   * @instance
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/SVGElement SVGElement}
   * @return {SVGElement}
   */
  _chart.resetSvg = function () {
    /* OVERRIDE ---------------------------------------------------------------- */
    _chart.root().html("");
    /* ------------------------------------------------------------------------- */

    return _chart.generateSvg();
  };

  function sizeSvg() {
    if (_svg) {
      _svg.attr("width", _chart.width()).attr("height", _chart.height());
    }
  }

  _chart.generateSvg = function () {
    /* OVERRIDE ---------------------------------------------------------------- */
    _svg = _chart.root().append("div").attr("class", "svg-wrapper").append("svg");
    /* ------------------------------------------------------------------------- */

    sizeSvg();
    return _svg;
  };

  /* OVERRIDE ---------------------------------------------------------------- */
  function sizeRoot() {
    if (_root) {
      _root.style("height", _chart.height() + "px").style("width", _chart.width() + "px");
    }
  }

  _chart.popup = function (popupElement) {
    if (!arguments.length) {
      return _popup;
    }
    _popup = popupElement;
    return _chart;
  };

  _chart.enablePopup = function (popupIsEnabled) {
    _popupIsEnabled = popupIsEnabled;
    return _chart;
  };

  _chart.popupIsEnabled = function () {
    return _popupIsEnabled;
  };

  _chart.generatePopup = function () {
    _chart.select(".chart-popup").remove();

    _popup = _chart.root().append("div").attr("class", "chart-popup");

    _popup.append("div").attr("class", "chart-popup-box").append("div").attr("class", "chart-popup-content");

    return _popup;
  };

  _chart.popupCoordinates = function (coords) {
    var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") > -1;

    if (!isFirefox || _d2.default.selectAll(".react-grid-item.cssTransforms").empty() || !_d2.default.selectAll(".react-grid-layout.chart-edit-mode").empty()) {
      return coords;
    }

    var rootRect = _chart.root().node().getBoundingClientRect();
    var gridTop = _d2.default.select(".react-grid-layout").node().getBoundingClientRect().top;

    return [coords[0] - rootRect.x, coords[1] - Math.abs(gridTop - rootRect.y) + 40];
  };

  _chart.isTargeting = function (isTargeting) {
    if (!arguments.length) {
      return _isTargeting;
    }
    _isTargeting = isTargeting;
    return _chart;
  };

  _chart.colorByExpr = function (colorByExpr) {
    if (!arguments.length) {
      return _colorByExpr;
    }
    _colorByExpr = colorByExpr;
    return _chart;
  };
  /* ------------------------------------------------------------------------- */

  /**
   * Set or get the filter printer function. The filter printer function is used to generate human
   * friendly text for filter value(s) associated with the chart instance. By default dc charts use a
   * default filter printer `printers.filter` that provides simple printing support for both
   * single value and ranged filters.
   * @name filterPrinter
   * @memberof dc.baseMixin
   * @instance
   * @param {Function} [filterPrinterFunction=printers.filter]
   * @return {Function}
   * @return {dc.baseMixin}
   */
  _chart.filterPrinter = function (filterPrinterFunction) {
    if (!arguments.length) {
      return _filterPrinter;
    }
    _filterPrinter = filterPrinterFunction;
    return _chart;
  };

  /**
   * If set, use the `visibility` attribute instead of the `display` attribute for showing/hiding
   * chart reset and filter controls, for less disruption to the layout.
   * @name controlsUseVisibility
   * @memberof dc.baseMixin
   * @instance
   * @param {Boolean} [controlsUseVisibility=false]
   * @return {Boolean}
   * @return {dc.baseMixin}
   **/
  _chart.controlsUseVisibility = function (_) {
    if (!arguments.length) {
      return _controlsUseVisibility;
    }
    _controlsUseVisibility = _;
    return _chart;
  };

  /**
   * Turn on optional control elements within the root element. dc currently supports the
   * following html control elements.
   * * root.selectAll('.reset') - elements are turned on if the chart has an active filter. This type
   * of control element is usually used to store a reset link to allow user to reset filter on a
   * certain chart. This element will be turned off automatically if the filter is cleared.
   * * root.selectAll('.filter') elements are turned on if the chart has an active filter. The text
   * content of this element is then replaced with the current filter value using the filter printer
   * function. This type of element will be turned off automatically if the filter is cleared.
   * @name turnOnControls
   * @memberof dc.baseMixin
   * @instance
   * @return {dc.baseMixin}
   */
  _chart.turnOnControls = function () {
    if (_root) {
      var attribute = _chart.controlsUseVisibility() ? "visibility" : "display";
      _chart.selectAll(".reset").style(attribute, null);
      _chart.selectAll(".filter").text(_filterPrinter(_chart.filters())).style(attribute, null);
    }
    return _chart;
  };

  /**
   * Turn off optional control elements within the root element.
   * @name turnOffControls
   * @memberof dc.baseMixin
   * @see {@link #dc.baseMixin+turnOnControls turnOnControls}
   * @instance
   * @return {dc.baseMixin}
   */
  _chart.turnOffControls = function () {
    if (_root) {
      var attribute = _chart.controlsUseVisibility() ? "visibility" : "display";
      var value = _chart.controlsUseVisibility() ? "hidden" : "none";
      _chart.selectAll(".reset").style(attribute, value);
      _chart.selectAll(".filter").style(attribute, value).text(_chart.filter());
    }
    return _chart;
  };

  /**
   * Set or get the animation transition duration (in milliseconds) for this chart instance.
   * @name transitionDuration
   * @memberof dc.baseMixin
   * @instance
   * @param {Number} [duration=750]
   * @return {Number}
   * @return {dc.baseMixin}
   */
  _chart.transitionDuration = function (duration) {
    if (!arguments.length) {
      /* OVERRIDE ---------------------------------------------------------------- */
      return (0, _core.globalTransitionDuration)() != null ? (0, _core.globalTransitionDuration)() : _transitionDuration;
      /* ------------------------------------------------------------------------- */
    }
    _transitionDuration = duration;
    return _chart;
  };

  _chart._mandatoryAttributes = function (_) {
    if (!arguments.length) {
      return _mandatoryAttributes;
    }
    _mandatoryAttributes = _;
    return _chart;
  };

  function checkForMandatoryAttributes(a) {
    if (!_chart[a] || !_chart[a]()) {
      throw new errors.InvalidStateException("Mandatory attribute chart." + a + " is missing on chart[#" + _chart.anchorName() + "]");
    }
  }

  function maybeUpdateColorDomain(data) {
    var isFEQuantitativeColored = Array.isArray(data) && _chart.colorDomain && _legend && _legend.legendType() === "quantitative";

    if (isFEQuantitativeColored) {
      var isLegendLocked = _legend.isLocked && _legend.isLocked();

      if (!isLegendLocked) {
        var newColorDomain = _d2.default.extent(data, _chart.colorAccessor());
        _chart.colorDomain(newColorDomain);
      }
    }
  }

  /**
   * Invoking this method will force the chart to re-render everything from scratch. Generally it
   * should only be used to render the chart for the first time on the page or if you want to make
   * sure everything is redrawn from scratch instead of relying on the default incremental redrawing
   * behaviour.
   * @name render
   * @memberof dc.baseMixin
   * @instance
   * @param {Number} [id]
   * @param {Number} [queryGroupId]
   * @param {Number} [queryCount]
   * @param {Function} [callback]
   * @param {Any} [data]
   * @return {dc.baseMixin}
   */
  _chart.render = function (id, queryGroupId, queryCount, data, callback) {
    if ((0, _core.refreshDisabled)()) {
      return;
    }
    _chart.dataCache = typeof data !== "undefined" && data !== null ? data : null;

    sizeRoot();

    _listeners.preRender(_chart, data);

    if (_mandatoryAttributes) {
      _mandatoryAttributes.forEach(checkForMandatoryAttributes);
    }

    maybeUpdateColorDomain(data);

    var result = _chart._doRender(data);

    if (_legend && _chart.colorDomain) {
      _legend.render();
    }

    _chart.generatePopup();

    _chart._activateRenderlets("postRender", data);

    if (typeof queryGroupId !== "undefined" && queryGroupId !== null) {
      if ((0, _coreAsync.isEqualToRenderCount)(queryCount)) {
        if ((0, _core.logging)()) {
          var endTime = new Date();
          var elapsed = endTime - dc._startRenderTime;
          console.log("Render elapsed: " + elapsed + " ms");
        }

        (0, _core.globalTransitionDuration)(null);
        (0, _coreAsync.resetRenderStack)();

        if (!(0, _coreAsync.renderStackEmpty)()) {
          (0, _coreAsync.renderStackEmpty)(true);

          return (0, _coreAsync.renderAllAsync)(null).then(function (result) {
            callback(null, result);
          }).catch(function (error) {
            callback(error);
          });
        }
      }
    }

    callback && callback(null, result || _chart);
    return result;
  };

  _chart._activateRenderlets = function (event, data) {
    _listeners.pretransition(_chart, data);
    if (_chart.transitionDuration() > 0 && _svg) {
      _svg.transition().duration(_chart.transitionDuration()).each("end", function () {
        _listeners.renderlet(_chart, data);
        if (event) {
          _listeners[event](_chart, data);
        }
      });
    } else {
      _listeners.renderlet(_chart, data);
      if (event) {
        _listeners[event](_chart, data);
      }
    }
  };

  /**
   * Calling redraw will cause the chart to re-render data changes incrementally. If there is no
   * change in the underlying data dimension then calling this method will have no effect on the
   * chart. Most chart interaction in dc will automatically trigger this method through internal
   * events (in particular {@link #dc.redrawAll dc.redrawAll}; therefore, you only need to
   * manually invoke this function if data is manipulated outside of dc's control (for example if
   * data is loaded in the background using
   * {@link https://github.com/square/crossfilter/wiki/API-Reference#crossfilter_add crossfilter.add}.
   * @name redraw
   * @memberof dc.baseMixin
   * @instance
   * @param {Number} [id]
   * @param {Number} [queryGroupId]
   * @param {Number} [queryCount]
   * @param {Function} [callback]
   * @param {Any} [data]
   * @return {dc.baseMixin}
   */
  _chart.redraw = function (id, queryGroupId, queryCount, data, callback) {
    if ((0, _core.refreshDisabled)()) {
      return;
    }
    _chart.dataCache = typeof data !== "undefined" && data !== null ? data : null;

    sizeSvg();

    _listeners.preRedraw(_chart, data);

    maybeUpdateColorDomain(data);

    var result = _chart._doRedraw(data);

    if (_legend && _chart.colorDomain) {
      _legend.render();
    }

    _chart._activateRenderlets("postRedraw", data);
    if (typeof queryGroupId !== "undefined" && queryGroupId !== null) {
      if ((0, _coreAsync.isEqualToRedrawCount)(queryCount)) {
        if ((0, _core.logging)()) {
          var endTime = new Date();
          var elapsed = endTime - dc._startRedrawTime;
          console.log("Redraw elapsed: " + elapsed + " ms");
        }

        (0, _core.globalTransitionDuration)(null); // reset to null if was brush
        (0, _coreAsync.resetRedrawStack)();

        if (!(0, _coreAsync.redrawStackEmpty)()) {
          (0, _coreAsync.redrawStackEmpty)(true);

          return (0, _coreAsync.redrawAllAsync)(_chart.chartGroup()).then(function (result) {
            callback(null, result);
          }).catch(function (error) {
            callback(error);
          });
        }
      }
    }

    callback && callback(null, result || _chart);
    return result;
  };

  /**
   * Gets/sets the commit handler. If the chart has a commit handler, the handler will be called when
   * the chart's filters have changed, in order to send the filter data asynchronously to a server.
   *
   * Unlike other functions in dc.js, the commit handler is asynchronous. It takes two arguments:
   * a flag indicating whether this is a render (true) or a redraw (false), and a callback to be
   * triggered once the commit is filtered. The callback has the standard node.js continuation signature
   * with error first and result second.
   * @name commitHandler
   * @memberof dc.baseMixin
   * @instance
   * @return {dc.baseMixin}
   */
  _chart.commitHandler = function (commitHandler) {
    if (!arguments.length) {
      return _commitHandler;
    }
    _commitHandler = commitHandler;
    return _chart;
  };

  /**
   * Redraws all charts in the same group as this chart, typically in reaction to a filter
   * change. If the chart has a {@link dc.baseMixin.commitFilter commitHandler}, it will
   * be executed and waited for.
   * @name redrawGroup
   * @memberof dc.baseMixin
   * @instance
   * @return {dc.baseMixin}
   */
  _chart.redrawGroup = function (callback) {
    if (_commitHandler) {
      _commitHandler(false, function (error, result) {
        if (error) {
          console.log(error);
          callback && callback(error);
        } else {
          dc.redrawAll(_chart.chartGroup(), callback);
        }
      });
    } else {
      dc.redrawAll(_chart.chartGroup(), callback);
    }
    return _chart;
  };

  /**
   * Renders all charts in the same group as this chart. If the chart has a
   * {@link dc.baseMixin.commitFilter commitHandler}, it will be executed and waited for
   * @name renderGroup
   * @memberof dc.baseMixin
   * @instance
   * @return {dc.baseMixin}
   */
  _chart.renderGroup = function (callback) {
    if (_commitHandler) {
      _commitHandler(false, function (error, result) {
        if (error) {
          console.log(error);
          callback && callback(error);
        } else {
          dc.renderAll(_chart.chartGroup(), callback);
        }
      });
    } else {
      dc.renderAll(_chart.chartGroup(), callback);
    }
    return _chart;
  };

  _chart._invokeFilteredListener = function (f, i) {
    if (f !== undefined) {
      _listeners.filtered(_chart, f, i);
    }
  };

  _chart._invokeZoomedListener = function () {
    _listeners.zoomed(_chart);
  };

  var _hasFilterHandler = function _hasFilterHandler(filters, filter) {
    if (typeof filter === "undefined") {
      return filters.length > 0;
    }

    return filters.some(function (f) {
      return filter <= f && filter >= f;
    });
  };

  /**
   * Set or get the has filter handler. The has filter handler is a function that checks to see if
   * the chart's current filters include a specific filter.  Using a custom has filter handler allows
   * you to change the way filters are checked for and replaced.
   * @name hasFilterHandler
   * @memberof dc.baseMixin
   * @instance
   * @example
   * // default has filter handler
   * chart.hasFilterHandler(function (filters, filter) {
   *     if (filter === null || typeof(filter) === 'undefined') {
   *         return filters.length > 0;
   *     }
   *     return filters.some(function (f) {
   *         return filter <= f && filter >= f;
   *     });
   * });
   *
   * // custom filter handler (no-op)
   * chart.hasFilterHandler(function(filters, filter) {
   *     return false;
   * });
   * @param {Function} [hasFilterHandler]
   * @return {Function}
   * @return {dc.baseMixin}
   */
  _chart.hasFilterHandler = function (hasFilterHandler) {
    if (!arguments.length) {
      return _hasFilterHandler;
    }
    _hasFilterHandler = hasFilterHandler;
    return _chart;
  };

  /**
   * Check whether any active filter or a specific filter is associated with particular chart instance.
   * This function is **not chainable**.
   * @name hasFilter
   * @memberof dc.baseMixin
   * @instance
   * @see {@link #dc.baseMixin+hasFilterHandler hasFilterHandler}
   * @param {*} [filter]
   * @return {Boolean}
   */
  _chart.hasFilter = function (filter) {
    return _hasFilterHandler(_filters, filter);
  };

  var _removeFilterHandler = function _removeFilterHandler(filters, filter) {
    for (var i = 0; i < filters.length; i++) {
      if (_utils.utils.deepEquals(filters[i], filter)) {
        filters.splice(i, 1);
        break;
      }

      if (filters[i] <= filter && filters[i] >= filter) {
        filters.splice(i, 1);
        break;
      }
    }

    return filters;
  };

  /**
   * Set or get the remove filter handler. The remove filter handler is a function that removes a
   * filter from the chart's current filters. Using a custom remove filter handler allows you to
   * change how filters are removed or perform additional work when removing a filter, e.g. when
   * using a filter server other than crossfilter.
   *
   * Any changes should modify the `filters` array argument and return that array.
   * @name removeFilterHandler
   * @memberof dc.baseMixin
   * @instance
   * @example
   * // default remove filter handler
   * chart.removeFilterHandler(function (filters, filter) {
   *     for (var i = 0; i < filters.length; i++) {
   *         if (filters[i] <= filter && filters[i] >= filter) {
   *             filters.splice(i, 1);
   *             break;
   *         }
   *     }
   *     return filters;
   * });
   *
   * // custom filter handler (no-op)
   * chart.removeFilterHandler(function(filters, filter) {
   *     return filters;
   * });
   * @param {Function} [removeFilterHandler]
   * @return {Function}
   * @return {dc.baseMixin}
   */
  _chart.removeFilterHandler = function (removeFilterHandler) {
    if (!arguments.length) {
      return _removeFilterHandler;
    }
    _removeFilterHandler = removeFilterHandler;
    return _chart;
  };

  var _addFilterHandler = function _addFilterHandler(filters, filter) {
    filters.push(filter);
    return filters;
  };

  /**
   * Set or get the add filter handler. The add filter handler is a function that adds a filter to
   * the chart's filter list. Using a custom add filter handler allows you to change the way filters
   * are added or perform additional work when adding a filter, e.g. when using a filter server other
   * than crossfilter.
   *
   * Any changes should modify the `filters` array argument and return that array.
   * @name addFilterHandler
   * @memberof dc.baseMixin
   * @instance
   * @example
   * // default add filter handler
   * chart.addFilterHandler(function (filters, filter) {
   *     filters.push(filter);
   *     return filters;
   * });
   *
   * // custom filter handler (no-op)
   * chart.addFilterHandler(function(filters, filter) {
   *     return filters;
   * });
   * @param {Function} [addFilterHandler]
   * @return {Function}
   * @return {dc.baseMixin}
   */
  _chart.addFilterHandler = function (addFilterHandler) {
    if (!arguments.length) {
      return _addFilterHandler;
    }
    _addFilterHandler = addFilterHandler;
    return _chart;
  };

  var _resetFilterHandler = function _resetFilterHandler(filters) {
    return [];
  };

  /**
   * Set or get the reset filter handler. The reset filter handler is a function that resets the
   * chart's filter list by returning a new list. Using a custom reset filter handler allows you to
   * change the way filters are reset, or perform additional work when resetting the filters,
   * e.g. when using a filter server other than crossfilter.
   *
   * This function should return an array.
   * @name resetFilterHandler
   * @memberof dc.baseMixin
   * @instance
   * @example
   * // default remove filter handler
   * function (filters) {
   *     return [];
   * }
   *
   * // custom filter handler (no-op)
   * chart.resetFilterHandler(function(filters) {
   *     return filters;
   * });
   * @param {Function} [resetFilterHandler]
   * @return {dc.baseMixin}
   */
  _chart.resetFilterHandler = function (resetFilterHandler) {
    if (!arguments.length) {
      return _resetFilterHandler;
    }
    _resetFilterHandler = resetFilterHandler;
    return _chart;
  };

  function applyFilters() {
    if (_chart.dimension() && _chart.dimension().filter) {
      var fs = _filterHandler(_chart.dimension(), _filters);
      _filters = fs ? fs : _filters;
    }
  }

  _chart.replaceFilter = function (_) {
    _filters = [];
    _chart.filter(_);
  };

  /**
   * Filter the chart by the given value or return the current filter if the input parameter is missing.
   * If the passed filter is not currently in the chart's filters, it is added to the filters by the
   * {@link #dc.baseMixin+addFilterHandler addFilterHandler}.  If a filter exists already within the chart's
   * filters, it will be removed by the {@link #dc.baseMixin+removeFilterHandler removeFilterHandler}.  If
   * a `null` value was passed at the filter, this denotes that the filters should be reset, and is performed
   * by the {@link #dc.baseMixin+resetFilterHandler resetFilterHandler}.
   *
   * Once the filters array has been updated, the filters are applied to the crossfilter.dimension, using the
   * {@link #dc.baseMixin+filterHandler filterHandler}.
   * @name filter
   * @memberof dc.baseMixin
   * @instance
   * @see {@link #dc.baseMixin+addFilterHandler addFilterHandler}
   * @see {@link #dc.baseMixin+removeFilterHandler removeFilterHandler}
   * @see {@link #dc.baseMixin+resetFilterHandler resetFilterHandler}
   * @see {@link #dc.baseMixin+filterHandler filterHandler}
   * @example
   * // filter by a single string
   * chart.filter('Sunday');
   * // filter by a single age
   * chart.filter(18);
   * @param {*} [filter]
   * @return {dc.baseMixin}
   */
  _chart.filter = function (filter, isFilterInverse) {
    if (!arguments.length) {
      return _filters.length > 0 ? _filters[0] : null;
    }
    isFilterInverse = typeof isFilterInverse === "undefined" ? false : isFilterInverse;
    if (isFilterInverse !== _chart.filtersInverse()) {
      _filters = _resetFilterHandler(_filters);
      _chart.filtersInverse(isFilterInverse);
    }
    if (filter instanceof Array && filter[0] instanceof Array && !filter.isFiltered) {
      filter[0].forEach(function (d) {
        if (_chart.hasFilter(d)) {
          _removeFilterHandler(_filters, d);
        } else {
          _addFilterHandler(_filters, d);
        }
      });
    } else if (filter === Symbol.for("clear")) {
      filters = _resetFilterHandler(_filters);
    } else if (_chart.hasFilter(filter)) {
      _removeFilterHandler(_filters, filter);
    } else {
      _addFilterHandler(_filters, filter);
    }
    applyFilters();
    _chart._invokeFilteredListener(filter, isFilterInverse);

    if (_root !== null && _chart.hasFilter()) {
      _chart.turnOnControls();
    } else {
      _chart.turnOffControls();
    }

    return _chart;
  };

  /**
   * Returns all current filters. This method does not perform defensive cloning of the internal
   * filter array before returning, therefore any modification of the returned array will effect the
   * chart's internal filter storage.
   * @name filters
   * @memberof dc.baseMixin
   * @instance
   * @return {Array<*>}
   */
  _chart.filters = function () {
    return _filters;
  };

  /* OVERRIDE ---------------------------------------------------------------- */
  _chart.accentSelected = function (e) {
    _d2.default.select(e).classed(_core.constants.ACCENT_CLASS, true);
  };

  _chart.unAccentSelected = function (e) {
    _d2.default.select(e).classed(_core.constants.ACCENT_CLASS, false);
  };
  /* ------------------------------------------------------------------------- */

  _chart.highlightSelected = function (e) {
    _d2.default.select(e).classed(_core.constants.SELECTED_CLASS, true);
    _d2.default.select(e).classed(_core.constants.DESELECTED_CLASS, false);
  };

  _chart.fadeDeselected = function (e) {
    _d2.default.select(e).classed(_core.constants.SELECTED_CLASS, false);
    _d2.default.select(e).classed(_core.constants.DESELECTED_CLASS, true);
  };

  _chart.resetHighlight = function (e) {
    _d2.default.select(e).classed(_core.constants.SELECTED_CLASS, false);
    _d2.default.select(e).classed(_core.constants.DESELECTED_CLASS, false);
  };

  /**
   * This function is passed to d3 as the onClick handler for each chart. The default behavior is to
   * filter on the clicked datum (passed to the callback) and redraw the chart group.
   * @name onClick
   * @memberof dc.baseMixin
   * @instance
   * @param {*} datum
   */
  _chart.onClick = function (datum) {
    var filter = _chart.keyAccessor()(datum);
    _chart.handleFilterClick(_d2.default.event, filter);
  };

  /**
   * Set or get the filter handler. The filter handler is a function that performs the filter action
   * on a specific dimension. Using a custom filter handler allows you to perform additional logic
   * before or after filtering.
   * @name filterHandler
   * @memberof dc.baseMixin
   * @instance
   * @see {@link https://github.com/square/crossfilter/wiki/API-Reference#dimension_filter crossfilter.dimension.filter}
   * @example
   * // default filter handler
   * chart.filterHandler(function (dimension, filters) {
   *     dimension.filter(Symbol.for("clear"));
   *     if (filters.length === 0) {
   *         dimension.filter(Symbol.for("clear"));
   *     } else {
   *         dimension.filterFunction(function (d) {
   *             for (var i = 0; i < filters.length; i++) {
   *                 var filter = filters[i];
   *                 if (filter.isFiltered && filter.isFiltered(d)) {
   *                     return true;
   *                 } else if (filter <= d && filter >= d) {
   *                     return true;
   *                 }
   *             }
   *             return false;
   *         });
   *     }
   *     return filters;
   * });
   *
   * // custom filter handler
   * chart.filterHandler(function(dimension, filter){
   *     var newFilter = filter + 10;
   *     dimension.filter(newFilter);
   *     return newFilter; // set the actual filter value to the new value
   * });
   * @param {Function} [filterHandler]
   * @return {Function}
   * @return {dc.baseMixin}
   */
  _chart.filterHandler = function (filterHandler) {
    if (!arguments.length) {
      return _filterHandler;
    }
    _filterHandler = filterHandler;
    return _chart;
  };

  // abstract function stub
  _chart._doRender = function () {
    // do nothing in base, should be overridden by sub-function
    return _chart;
  };

  _chart._doRedraw = function () {
    // do nothing in base, should be overridden by sub-function
    return _chart;
  };

  _chart.legendables = function () {
    // do nothing in base, should be overridden by sub-function
    return [];
  };

  /* OVERRIDE -----------------------------------------------------------------*/

  _chart.legendLock = function (_) {
    if (!arguments.length) {
      return _legendLock;
    }
    _legendLock = _;
    return _chart;
  };

  _chart.legendUnlock = function (_) {
    if (!arguments.length) {
      return _legendUnlock;
    }
    _legendUnlock = _;
    return _chart;
  };

  _chart.legendInputChange = function (_) {
    if (!arguments.length) {
      return _legendInputChange;
    }
    _legendInputChange = _;
    return _chart;
  };

  /* ------------------------------------------------------------------------- */

  _chart.legendHighlight = function () {
    // do nothing in base, should be overridden by sub-function
  };

  _chart.legendReset = function () {
    // do nothing in base, should be overridden by sub-function
  };

  _chart.legendToggle = function () {
    // do nothing in base, should be overriden by sub-function
  };

  _chart.isLegendableHidden = function () {
    // do nothing in base, should be overridden by sub-function
    return false;
  };

  /**
   * Set or get the key accessor function. The key accessor function is used to retrieve the key
   * value from the crossfilter group. Key values are used differently in different charts, for
   * example keys correspond to slices in a pie chart and x axis positions in a grid coordinate chart.
   * @name keyAccessor
   * @memberof dc.baseMixin
   * @instance
   * @example
   * // default key accessor
   * chart.keyAccessor(function(d) { return d.key; });
   * // custom key accessor for a multi-value crossfilter reduction
   * chart.keyAccessor(function(p) { return p.value.absGain; });
   * @param {Function} [keyAccessor]
   * @return {Function}
   * @return {dc.baseMixin}
   */
  _chart.keyAccessor = function (keyAccessor) {
    if (!arguments.length) {
      return _keyAccessor;
    }
    _keyAccessor = keyAccessor;
    return _chart;
  };

  /**
   * Set or get the value accessor function. The value accessor function is used to retrieve the
   * value from the crossfilter group. Group values are used differently in different charts, for
   * example values correspond to slice sizes in a pie chart and y axis positions in a grid
   * coordinate chart.
   * @name valueAccessor
   * @memberof dc.baseMixin
   * @instance
   * @example
   * // default value accessor
   * chart.valueAccessor(function(d) { return d.value; });
   * // custom value accessor for a multi-value crossfilter reduction
   * chart.valueAccessor(function(p) { return p.value.percentageGain; });
   * @param {Function} [valueAccessor]
   * @return {Function}
   * @return {dc.baseMixin}
   */
  _chart.valueAccessor = function (valueAccessor) {
    if (!arguments.length) {
      return _valueAccessor;
    }
    _valueAccessor = valueAccessor;
    return _chart;
  };

  /**
   * Set or get the label function. The chart class will use this function to render labels for each
   * child element in the chart, e.g. slices in a pie chart or bubbles in a bubble chart. Not every
   * chart supports the label function, for example line chart does not use this function
   * at all. By default, enables labels; pass false for the second parameter if this is not desired.
   * @name label
   * @memberof dc.baseMixin
   * @instance
   * @example
   * // default label function just return the key
   * chart.label(function(d) { return d.key; });
   * // label function has access to the standard d3 data binding and can get quite complicated
   * chart.label(function(d) { return d.data.key + '(' + Math.floor(d.data.value / all.value() * 100) + '%)'; });
   * @param {Function} [labelFunction]
   * @param {Boolean} [enableLabels=true]
   * @return {Function}
   * @return {dc.baseMixin}
   */
  _chart.label = function (labelFunction, enableLabels) {
    if (!arguments.length) {
      return _label;
    }
    _label = labelFunction;
    if (enableLabels === undefined || enableLabels) {
      _renderLabel = true;
    }
    return _chart;
  };

  /**
   * Turn on/off label rendering
   * @name renderLabel
   * @memberof dc.baseMixin
   * @instance
   * @param {Boolean} [renderLabel=false]
   * @return {Boolean}
   * @return {dc.baseMixin}
   */
  _chart.renderLabel = function (renderLabel) {
    if (!arguments.length) {
      return _renderLabel;
    }
    _renderLabel = renderLabel;
    return _chart;
  };

  /**
   * Set or get the title function. The chart class will use this function to render the SVGElement title
   * (usually interpreted by browser as tooltips) for each child element in the chart, e.g. a slice
   * in a pie chart or a bubble in a bubble chart. Almost every chart supports the title function;
   * however in grid coordinate charts you need to turn off the brush in order to see titles, because
   * otherwise the brush layer will block tooltip triggering.
   * @name title
   * @memberof dc.baseMixin
   * @instance
   * @example
   * // default title function just return the key
   * chart.title(function(d) { return d.key + ': ' + d.value; });
   * // title function has access to the standard d3 data binding and can get quite complicated
   * chart.title(function(p) {
   *    return p.key.getFullYear()
   *        + '\n'
   *        + 'Index Gain: ' + numberFormat(p.value.absGain) + '\n'
   *        + 'Index Gain in Percentage: ' + numberFormat(p.value.percentageGain) + '%\n'
   *        + 'Fluctuation / Index Ratio: ' + numberFormat(p.value.fluctuationPercentage) + '%';
   * });
   * @param {Function} [titleFunction]
   * @return {Function}
   * @return {dc.baseMixin}
   */
  _chart.title = function (titleFunction) {
    if (!arguments.length) {
      return _title;
    }
    _title = titleFunction;
    return _chart;
  };

  /**
   * Turn on/off title rendering, or return the state of the render title flag if no arguments are
   * given.
   * @name renderTitle
   * @memberof dc.baseMixin
   * @instance
   * @param {Boolean} [renderTitle=true]
   * @return {Boolean}
   * @return {dc.baseMixin}
   */
  _chart.renderTitle = function (renderTitle) {
    if (!arguments.length) {
      return _renderTitle;
    }
    _renderTitle = renderTitle;
    return _chart;
  };

  /**
   * A renderlet is similar to an event listener on rendering event. Multiple renderlets can be added
   * to an individual chart.  Each time a chart is rerendered or redrawn the renderlets are invoked
   * right after the chart finishes its transitions, giving you a way to modify the SVGElements.
   * Renderlet functions take the chart instance as the only input parameter and you can
   * use the dc API or use raw d3 to achieve pretty much any effect.
   *
   * Use {@link #dc.baseMixin+on on} with a 'renderlet' prefix.
   * Generates a random key for the renderlet, which makes it hard to remove.
   * @name renderlet
   * @memberof dc.baseMixin
   * @instance
   * @deprecated
   * @example
   * // do this instead of .renderlet(function(chart) { ... })
   * chart.on("renderlet", function(chart){
   *     // mix of dc API and d3 manipulation
   *     chart.select('g.y').style('display', 'none');
   *     // its a closure so you can also access other chart variable available in the closure scope
   *     moveChart.filter(chart.filter());
   * });
   * @param {Function} renderletFunction
   * @return {dc.baseMixin}
   */
  _chart.renderlet = _logger.logger.deprecate(function (renderletFunction) {
    _chart.on("renderlet." + _utils.utils.uniqueId(), renderletFunction);
    return _chart;
  }, 'chart.renderlet has been deprecated.  Please use chart.on("renderlet.<renderletKey>", renderletFunction)');

  /**
   * Get or set the chart group to which this chart belongs. Chart groups are rendered or redrawn
   * together since it is expected they share the same underlying crossfilter data set.
   * @name chartGroup
   * @memberof dc.baseMixin
   * @instance
   * @param {String} [chartGroup]
   * @return {String}
   * @return {dc.baseMixin}
   */
  _chart.chartGroup = function (chartGroup) {
    if (!arguments.length) {
      return _chartGroup;
    }
    if (!_isChild) {
      (0, _core.deregisterChart)(_chart, _chartGroup);
    }
    _chartGroup = chartGroup;
    if (!_isChild) {
      (0, _core.registerChart)(_chart, _chartGroup);
    }
    return _chart;
  };

  /**
   * Expire the internal chart cache. dc charts cache some data internally on a per chart basis to
   * speed up rendering and avoid unnecessary calculation; however it might be useful to clear the
   * cache if you have changed state which will affect rendering.  For example if you invoke the
   * {@link https://github.com/square/crossfilter/wiki/API-Reference#crossfilter_add crossfilter.add}
   * function or reset group or dimension after rendering it is a good idea to
   * clear the cache to make sure charts are rendered properly.
   * @name expireCache
   * @memberof dc.baseMixin
   * @instance
   * @return {dc.baseMixin}
   */
  _chart.expireCache = function () {
    // do nothing in base, should be overridden by sub-function
    return _chart;
  };

  /**
   * MAPDC-extension function
   * Destroy all leftover parts of the chart.
   * @name destroyChart
   * @memberof dc.baseMixin
   * @instance
   * @return {dc.baseMixin}
   */
  _chart.destroyChart = function () {
    // do nothing in base, should be overridden by sub-function
    return _chart;
  };

  /**
   * Attach a dc.legend widget to this chart. The legend widget will automatically draw legend labels
   * based on the color setting and names associated with each group.
   * @name legend
   * @memberof dc.baseMixin
   * @instance
   * @example
   * chart.legend(dc.legend().x(400).y(10).itemHeight(13).gap(5))
   * @param {dc.legend} [legend]
   * @return {dc.legend}
   * @return {dc.baseMixin}
   */
  _chart.legend = function (legend) {
    if (!arguments.length) {
      return _legend;
    }
    _legend = legend;

    if (_legend) {
      _legend.parent(_chart);
    }

    return _chart;
  };

  /* OVERRIDE -----------------------------------------------------------------*/
  _chart.legendContinuous = function (legendContinuous) {
    if (!arguments.length) {
      return _legendContinuous;
    }
    _legendContinuous = legendContinuous;
    _legendContinuous.parent(_chart);
    return _chart;
  };
  /* --------------------------------------------------------------------------*/

  /**
   * Returns the internal numeric ID of the chart.
   * @name chartID
   * @memberof dc.baseMixin
   * @instance
   * @return {String}
   */
  _chart.chartID = function () {
    return _chart.__dcFlag__;
  };

  /**
   * Set chart options using a configuration object. Each key in the object will cause the method of
   * the same name to be called with the value to set that attribute for the chart.
   * @name options
   * @memberof dc.baseMixin
   * @instance
   * @example
   * chart.options({dimension: myDimension, group: myGroup});
   * @param {{}} opts
   * @return {dc.baseMixin}
   */
  _chart.options = function (opts) {
    var applyOptions = ["anchor", "group", "xAxisLabel", "yAxisLabel", "stack", "title", "point", "getColor", "overlayGeoJson"];

    for (var o in opts) {
      if (typeof _chart[o] === "function") {
        if (opts[o] instanceof Array && applyOptions.indexOf(o) !== -1) {
          _chart[o].apply(_chart, opts[o]);
        } else {
          _chart[o].call(_chart, opts[o]);
        }
      } else {
        dc.logger.debug("Not a valid option setter name: " + o);
      }
    }
    return _chart;
  };

  /**
   * All dc chart instance supports the following listeners.
   * Supports the following events:
   * * `renderlet` - This listener function will be invoked after transitions after redraw and render. Replaces the
   * deprecated {@link #dc.baseMixin+renderlet renderlet} method.
   * * `pretransition` - Like `.on('renderlet', ...)` but the event is fired before transitions start.
   * * `preRender` - This listener function will be invoked before chart rendering.
   * * `postRender` - This listener function will be invoked after chart finish rendering including
   * all renderlets' logic.
   * * `preRedraw` - This listener function will be invoked before chart redrawing.
   * * `postRedraw` - This listener function will be invoked after chart finish redrawing
   * including all renderlets' logic.
   * * `filtered` - This listener function will be invoked after a filter is applied, added or removed.
   * * `zoomed` - This listener function will be invoked after a zoom is triggered.
   * @name on
   * @memberof dc.baseMixin
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/Internals#dispatch_on d3.dispatch.on}
   * @example
   * .on('renderlet', function(chart, filter){...})
   * .on('pretransition', function(chart, filter){...})
   * .on('preRender', function(chart){...})
   * .on('postRender', function(chart){...})
   * .on('preRedraw', function(chart){...})
   * .on('postRedraw', function(chart){...})
   * .on('filtered', function(chart, filter){...})
   * .on('zoomed', function(chart, filter){...})
   * @param {String} event
   * @param {Function} listener
   * @return {dc.baseMixin}
   */
  _chart.on = function (event, listener) {
    _listeners.on(event, listener);
    return _chart;
  };

  _chart.debounce = function (func, wait, immediate) {
    var timeout = void 0;

    return function () {
      var context = this,
          args = arguments;
      var later = function later() {
        timeout = null;
        if (!immediate) {
          func.apply(context, args);
        }
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) {
        func.apply(context, args);
      }
    };
  };

  _chart.showNullDimensions = function (showNulls) {
    if (!arguments.length) {
      return !_chart.dimension().getEliminateNull();
    }

    _chart.expireCache();
    _chart.dimension().setEliminateNull(!showNulls);

    return _chart;
  };

  _chart.keyAccessor(_multipleKeyAccessors.multipleKeysAccessorForCap);
  _chart.ordering = function () {};
  _chart.rangeChartEnabled = function () {
    return false;
  };
  _chart.isTime = function () {
    return null;
  };

  _chart.isMulti = function () {
    return false;
  };

  _chart.valueFormatter = function (formatter) {
    if (!arguments.length) {
      return _valueFormatter;
    }
    _valueFormatter = formatter;
    return _chart;
  };

  _chart.dateFormatter = function (formatter) {
    if (!arguments.length) {
      return _dateFormatter;
    }
    _dateFormatter = formatter;
    return _chart;
  };

  _chart.getMeasureName = function () {
    var measure = _chart.group().reduce();
    return measure && measure[0] ? measure[0].measureName : null;
  };

  _chart = (0, _legendMixin2.default)((0, _filterMixin2.default)((0, _labelMixin2.default)((0, _multipleKeyLabelMixin2.default)((0, _spinnerMixin2.default)((0, _asyncMixin2.default)(_chart))))));

  return _chart;
}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizeArrayByValue = exports.isArrayOfObjects = exports.hasAllObjects = exports.isPlainObject = exports.genericDateTimeFormat = exports.momentUTCFormat = exports.nullLabelHtml = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.formatDataValue = formatDataValue;
exports.maybeFormatInfinity = maybeFormatInfinity;
exports.formatNumber = formatNumber;
exports.formatArrayValue = formatArrayValue;
exports.formatTimeBinValue = formatTimeBinValue;
exports.formatExtractValue = formatExtractValue;
exports.normalizeFiltersArray = normalizeFiltersArray;

var _datesAndTimes = __webpack_require__(27);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _moment = __webpack_require__(0);

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NUMBER_LENGTH = 4;

var numFormat = _d2.default.format(".2s");
var commafy = _d2.default.format(",");

var nullLabelHtml = exports.nullLabelHtml = '<tspan class="null-value"> NULL </tspan>';
var momentUTCFormat = exports.momentUTCFormat = function momentUTCFormat(d, f) {
  return _moment2.default.utc(d).locale("en").format(f);
};
var genericDateTimeFormat = exports.genericDateTimeFormat = function genericDateTimeFormat(d) {
  return momentUTCFormat(d, "MMM D, YYYY") + " \u205F" + momentUTCFormat(d, "HH:mm:ss");
};
var isPlainObject = exports.isPlainObject = function isPlainObject(value) {
  return !Array.isArray(value) && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" && !(value instanceof Date);
};
var hasAllObjects = exports.hasAllObjects = function hasAllObjects(collection) {
  return collection.reduce(function (accum, value) {
    return isPlainObject(value) && accum;
  }, true);
};
var isArrayOfObjects = exports.isArrayOfObjects = function isArrayOfObjects(value) {
  return Array.isArray(value) && hasAllObjects(value);
};
var normalizeArrayByValue = exports.normalizeArrayByValue = function normalizeArrayByValue(collection) {
  return isArrayOfObjects(collection) ? collection.map(function (data) {
    return data.value;
  }) : collection;
};

function formatDataValue(data, numAbbr) {
  if (typeof data === "number") {
    return formatNumber(data, numAbbr);
  } else if (Array.isArray(data)) {
    return formatArrayValue(data);
  } else if (data instanceof Date) {
    return genericDateTimeFormat(data);
  } else if (data === null) {
    return nullLabelHtml;
  }
  return data;
}

function maybeFormatInfinity(data) {
  return data.map(function (d) {
    if (d.val === "-Infinity" || d.val === "Infinity") {
      d.label = d.val;
      d.val = 0;
    }
    return d;
  });
}

function formatNumber(d, abbr) {
  var isLong = String(d).length > NUMBER_LENGTH;
  var formattedHasAlpha = numFormat(d).match(/[a-z]/i);
  var isLargeNumber = isLong && formattedHasAlpha;
  return isLargeNumber && abbr ? numFormat(d) : commafy(parseFloat(d.toFixed(2)));
}

function formatArrayValue(data) {
  if (_typeof(data[0]) === "object" && !(data[0] instanceof Date)) {
    return data[0].isExtract ? formatExtractValue(data[0].value, data[0].extractUnit) : formatTimeBinValue(data);
  } else {
    return data.map(function (d) {
      return formatDataValue(d);
    }).join(" \u2013 ");
  }
}

function formatTimeBinValue(data) {
  var startTime = data[0];
  var endTime = data[1];
  switch (startTime.timeBin) {
    case "decade":
      return momentUTCFormat(startTime.value, "YYYY") + " \u2013 " + momentUTCFormat(endTime.value, "YYYY");
    case "year":
      return momentUTCFormat(startTime.value, "YYYY");
    case "quarter":
      return _moment2.default.utc(startTime.value).locale("en").quarter() + "Q " + momentUTCFormat(startTime.value, "YYYY");
    case "month":
      return momentUTCFormat(startTime.value, "MMM YYYY");
    case "week":
      return momentUTCFormat(startTime.value, "MMM D") + " \u2013 " + momentUTCFormat(endTime.value, "MMM D, YYYY");
    case "day":
      return momentUTCFormat(startTime.value, "MMM D, YYYY");
    case "hour":
    case "minute":
      return momentUTCFormat(startTime.value, "MMM D, YYYY") + " \u205F" + momentUTCFormat(startTime.value, "HH:mm");
    default:
      return genericDateTimeFormat(startTime.value);
  }
}

function formatExtractValue(number, label) {
  switch (label) {
    case "isodow":
      return _datesAndTimes.DAYS[number - 1];
    case "month":
      return _datesAndTimes.MONTHS[number - 1];
    case "quarter":
      return _datesAndTimes.QUARTERS[number - 1];
    case "hour":
      return _datesAndTimes.HOURS[number];
    case "minute":
      return number + 1;
    default:
      return number;
  }
}

function normalizeFiltersArray(filters) {
  return filters.map(function (f) {
    if (isArrayOfObjects(f)) {
      return normalizeArrayByValue(f);
    } else {
      return f;
    }
  });
}

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = colorMixin;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The Color Mixin is an abstract chart functional class providing universal coloring support
 * as a mix-in for any concrete chart implementation.
 * @name colorMixin
 * @memberof dc
 * @mixin
 * @param {Object} _chart
 * @return {dc.colorMixin}
 */
function colorMixin(_chart) {
  var _colors = _d2.default.scale.category20c();
  var _defaultAccessor = true;

  var _colorAccessor = function _colorAccessor(d) {
    return _chart.keyAccessor()(d);
  };

  /**
   * Retrieve current color scale or set a new color scale. This methods accepts any function that
   * operates like a d3 scale.
   * @name colors
   * @memberof dc.colorMixin
   * @instance
   * @see {@link http://github.com/mbostock/d3/wiki/Scales d3.scale}
   * @example
   * // alternate categorical scale
   * chart.colors(d3.scale.category20b());
   * // ordinal scale
   * chart.colors(d3.scale.ordinal().range(['red','green','blue']));
   * // convenience method, the same as above
   * chart.ordinalColors(['red','green','blue']);
   * // set a linear scale
   * chart.linearColors(["#4575b4", "#ffffbf", "#a50026"]);
   * @param {d3.scale} [colorScale=d3.scale.category20c()]
   * @return {d3.scale}
   * @return {dc.colorMixin}
   */
  _chart.colors = function (colorScale) {
    if (!arguments.length) {
      return _colors;
    }
    if (colorScale instanceof Array) {
      _colors = _d2.default.scale.quantize().range(colorScale); // deprecated legacy support, note: this fails for ordinal domains
    } else {
      _colors = _d2.default.functor(colorScale);
    }
    return _chart;
  };

  /**
   * Convenience method to set the color scale to
   * {@link https://github.com/mbostock/d3/wiki/Ordinal-Scales#ordinal d3.scale.ordinal} with
   * range `r`.
   * @name ordinalColors
   * @memberof dc.colorMixin
   * @instance
   * @param {Array<String>} r
   * @return {dc.colorMixin}
   */
  _chart.ordinalColors = function (r) {
    return _chart.colors(_d2.default.scale.ordinal().range(r));
  };

  /**
   * Convenience method to set the color scale to an Hcl interpolated linear scale with range `r`.
   * @name linearColors
   * @memberof dc.colorMixin
   * @instance
   * @param {Array<Number>} r
   * @return {dc.colorMixin}
   */
  _chart.linearColors = function (r) {
    return _chart.colors(_d2.default.scale.linear().range(r).interpolate(_d2.default.interpolateHcl));
  };

  /**
   * Set or the get color accessor function. This function will be used to map a data point in a
   * crossfilter group to a color value on the color scale. The default function uses the key
   * accessor.
   * @name colorAccessor
   * @memberof dc.colorMixin
   * @instance
   * @example
   * // default index based color accessor
   * .colorAccessor(function (d, i){return i;})
   * // color accessor for a multi-value crossfilter reduction
   * .colorAccessor(function (d){return d.value.absGain;})
   * @param {Function} [colorAccessor]
   * @return {Function}
   * @return {dc.colorMixin}
   */
  _chart.colorAccessor = function (colorAccessor) {
    if (!arguments.length) {
      return _colorAccessor;
    }
    _colorAccessor = colorAccessor;
    _defaultAccessor = false;
    return _chart;
  };

  // what is this?
  _chart.defaultColorAccessor = function () {
    return _defaultAccessor;
  };

  /**
   * Set or get the current domain for the color mapping function. The domain must be supplied as an
   * array.
   *
   * Note: previously this method accepted a callback function. Instead you may use a custom scale
   * set by {@link #dc.colorMixin+colors .colors}.
   * @name colorDomain
   * @memberof dc.colorMixin
   * @instance
   * @param {Array<String>} [domain]
   * @return {Array<String>}
   * @return {dc.colorMixin}
   */
  _chart.colorDomain = function (domain) {
    if (!arguments.length) {
      return _colors.domain();
    }
    _colors.domain(domain);
    return _chart;
  };

  /**
   * Set the domain by determining the min and max values as retrieved by
   * {@link #dc.colorMixin+colorAccessor .colorAccessor} over the chart's dataset.
   * @name calculateColorDomain
   * @memberof dc.colorMixin
   * @instance
   * @return {dc.colorMixin}
   */
  _chart.calculateColorDomain = function () {
    var newDomain = [_d2.default.min(_chart.data(), _chart.colorAccessor()), _d2.default.max(_chart.data(), _chart.colorAccessor())];
    _colors.domain(newDomain);
    return _chart;
  };

  /**
   * Get the color for the datum d and counter i. This is used internally by charts to retrieve a color.
   * @name getColor
   * @memberof dc.colorMixin
   * @instance
   * @param {*} d
   * @param {Number} [i]
   * @return {String}
   */
  _chart.getColor = function (data, index) {
    if (typeof data === "undefined") {
      var GREY = "#e2e2e2";
      return GREY;
    }

    var range = _chart.colors().range();
    var middleColor = range[Math.floor(range.length / 2)];

    return _colors(_colorAccessor.call(this, data, index)) || middleColor;
  };

  /**
   * Get the color for the datum d and counter i. This is used internally by charts to retrieve a color.
   * @name colorCalculator
   * @memberof dc.colorMixin
   * @instance
   * @param {*} [colorCalculator]
   * @return {*}
   */
  _chart.colorCalculator = function (colorCalculator) {
    if (!arguments.length) {
      return _chart.getColor;
    }
    _chart.getColor = colorCalculator;
    return _chart;
  };

  return _chart;
}

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = createParser;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__parse_expression__ = __webpack_require__(156);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse_datastate__ = __webpack_require__(157);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__parse_transform__ = __webpack_require__(158);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__parse_source__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__write_sql__ = __webpack_require__(167);






/**
 * Creates a parser than can parse expressions, transforms, and intermediary
 * SQL representations. This parser is used internally by the data graph.
 * @see {@link Parser} for further information.
 * @memberof API
 */
function createParser() {
  var transformParsers = {};
  var expressionParsers = {};

  /**
   * A collection of functions used for parsing expressions, transforms, and
   * intermediary SQL representations
   * @namespace Parser
   */
  var parser = {
    parseExpression: parseExpression,
    parseTransform: parseTransform,
    parseDataState: parseDataState,
    parseSource: parseSource,
    writeSQL: writeSQL,
    write: __WEBPACK_IMPORTED_MODULE_4__write_sql__["b" /* write */],
    registerParser: registerParser
  };

  /**
   * Returns all child data node instances of the graph.
   * @memberof Parser
   * @inner
   */
  function registerParser(definition, typeParser) {
    if (definition.meta === "expression") {
      expressionParsers[definition.type] = typeParser;
    } else if (definition.meta === "transform") {
      transformParsers[definition.type] = typeParser;
    }
  }

  /**
   * Parses expressions and returns a valid SQL expression string
   * @memberof Parser
   * @inner
   * @see {@link Expression} for further information.
   */
  function parseExpression(expression) {
    if (expressionParsers[expression.type]) {
      return expressionParsers[expression.type](expression, parser);
    }
    return Object(__WEBPACK_IMPORTED_MODULE_0__parse_expression__["a" /* default */])(expression, parser);
  }

  /**
   * Parses transforms and returns an intermediary SQL representation
   * @memberof Parser
   * @inner
   * @see {@link Transform} for further information.
   */
  function parseTransform(sql, transform) {
    if (transformParsers[transform.type]) {
      return transformParsers[transform.type](sql, transform, parser);
    }
    return Object(__WEBPACK_IMPORTED_MODULE_2__parse_transform__["a" /* default */])(sql, transform, parser);
  }

  /**
   * Parses a data node state and returns an intermediary SQL representation
   * @memberof Parser
   * @inner
   */
  function parseDataState(data, sql) {
    return Object(__WEBPACK_IMPORTED_MODULE_1__parse_datastate__["a" /* default */])(data, parser, sql);
  }

  /**
   * Parses a source transform and returns a valid SQL FROM clause
   * @memberof Parser
   * @inner
   */
  function parseSource(sourceTransforms) {
    return Object(__WEBPACK_IMPORTED_MODULE_3__parse_source__["a" /* default */])(sourceTransforms, parser);
  }

  /**
  * Parses a data node state and returns a valid SQL string
   * @memberof Parser
   * @inner
   */
  function writeSQL(state) {
    return Object(__WEBPACK_IMPORTED_MODULE_4__write_sql__["a" /* default */])(state, parser);
  }

  return parser;
}

/* harmony default export */ __webpack_exports__["b"] = (createParser());

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var events = exports.events = {
  current: null

  /**
   * This function triggers a throttled event function with a specified delay (in milli-seconds).  Events
   * that are triggered repetitively due to user interaction such brush dragging might flood the library
   * and invoke more renders than can be executed in time. Using this function to wrap your event
   * function allows the library to smooth out the rendering by throttling events and only responding to
   * the most recent event.
   * @name events.trigger
   * @memberof dc
   * @example
   * chart.on('renderlet', function(chart) {
   *     // smooth the rendering through event throttling
   *     dc.events.trigger(function(){
   *         // focus some other chart to the range selected by user on this chart
   *         someOtherChart.focus(chart.filter());
   *     });
   * })
   * @param {Function} closure
   * @param {Number} [delay]
   */
};events.trigger = function (closure, delay) {
  if (!delay) {
    closure();
    return;
  }

  events.current = closure;

  setTimeout(function () {
    if (closure === events.current) {
      closure();
    }
  }, delay);
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = capMixin;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _core = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Cap is a mixin that groups small data elements below a _cap_ into an *others* grouping for both the
 * Row and Pie Charts.
 *
 * The top ordered elements in the group up to the cap amount will be kept in the chart, and the rest
 * will be replaced with an *others* element, with value equal to the sum of the replaced values. The
 * keys of the elements below the cap limit are recorded in order to filter by those keys when the
 * others* element is clicked.
 * @name capMixin
 * @memberof dc
 * @mixin
 * @param {Object} _chart
 * @return {dc.capMixin}
 */
function capMixin(_chart) {
  var _cap = void 0;
  var _ordering = "desc";

  var _othersLabel = "Others";

  var _othersGrouper = function _othersGrouper(topRows) {
    var topRowsSum = _d2.default.sum(topRows, _chart.valueAccessor()),
        allRows = _chart.group().all(),
        allRowsSum = _d2.default.sum(allRows, _chart.valueAccessor()),
        topKeys = topRows.map(_chart.keyAccessor()),
        allKeys = allRows.map(_chart.keyAccessor()),
        topSet = _d2.default.set(topKeys),
        others = allKeys.filter(function (d) {
      return !topSet.has(d);
    });
    if (allRowsSum > topRowsSum) {
      return topRows.concat([{ others: others, key: _othersLabel, value: allRowsSum - topRowsSum }]);
    }
    return topRows;
  };

  _chart._mandatoryAttributes().push("cap");

  _chart.cappedKeyAccessor = function (d, i) {
    if (d.others) {
      /* OVERRIDE ---------------------------------------------------------------- */
      return d.key0;
      /* ------------------------------------------------------------------------- */
    }
    return _chart.keyAccessor()(d, i);
  };

  _chart.cappedValueAccessor = function (d, i) {
    if (d.others) {
      return d.value;
    }
    return _chart.valueAccessor()(d, i);
  };

  /* OVERRIDE EXTEND --------------------------------------------------------- */
  _chart.ordering = function (order) {
    _chart.expireCache();
    if (!order) {
      return _ordering;
    }
    _ordering = order;
    return _chart;
  };

  _chart.setDataAsync(function (group, callback) {
    function resultCallback(error, result) {
      if (error) {
        callback(error);
        return;
      }
      var rows = _chart._computeOrderedGroups(result);
      if (_othersGrouper) {
        callback(null, _othersGrouper(rows));
      } else {
        callback(null, rows);
      }
    }

    if (_cap === undefined) {
      if (_chart.dataCache != null) {
        callback(null, _chart._computeOrderedGroups(_chart.dataCache));
      } else {
        group.allAsync(function (error, result) {
          if (error) {
            callback(error);
            return;
          }
          callback(null, _chart._computeOrderedGroups(result));
        });
      }
    } else if (_chart.dataCache != null) {
      resultCallback(null, _chart.dataCache);
    } else if (_ordering === "desc") {
      return group.topAsync(_cap).then(function (result) {
        resultCallback(null, result);
      }).catch(function (error) {
        resultCallback(error);
      });
    } else if (_ordering === "asc") {
      group.bottomAsync(_cap, undefined, undefined, resultCallback); // ordered by crossfilter group order (default value)
    }
  });

  _chart.expireCache = function () {
    _chart.dataCache = null;
  };

  _chart.data(function (group) {
    if (!_chart.dataCache) {
      console.warn("Empty dataCache. Please fetch new data");
    }
    if (_cap === undefined) {
      return _chart._computeOrderedGroups(_chart.dataCache);
    } else {
      var rows = _chart.dataCache;
      if (_othersGrouper) {
        return _othersGrouper(rows);
      }
      return rows;
    }
  });

  /* ------------------------------------------------------------------------- */

  /**
   * Get or set the count of elements to that will be included in the cap.
   * @name cap
   * @memberof dc.capMixin
   * @instance
   * @param {Number} [count=Infinity]
   * @return {Number}
   * @return {dc.capMixin}
   */
  _chart.cap = function (count) {
    if (!arguments.length) {
      return _cap;
    }
    _cap = count;
    _chart.expireCache();
    return _chart;
  };

  /**
   * Get or set the label for *Others* slice when slices cap is specified
   * @name othersLabel
   * @memberof dc.capMixin
   * @instance
   * @param {String} [label="Others"]
   * @return {String}
   * @return {dc.capMixin}
   */
  _chart.othersLabel = function (label) {
    if (!arguments.length) {
      return _othersLabel;
    }
    _othersLabel = label;
    return _chart;
  };

  /**
   * Get or set the grouper function that will perform the insertion of data for the *Others* slice
   * if the slices cap is specified. If set to a falsy value, no others will be added. By default the
   * grouper function computes the sum of all values below the cap.
   * @name othersGrouper
   * @memberof dc.capMixin
   * @instance
   * @example
   * // Default others grouper
   * chart.othersGrouper(function (topRows) {
   *    var topRowsSum = d3.sum(topRows, _chart.valueAccessor()),
   *        allRows = _chart.group().all(),
   *        allRowsSum = d3.sum(allRows, _chart.valueAccessor()),
   *        topKeys = topRows.map(_chart.keyAccessor()),
   *        allKeys = allRows.map(_chart.keyAccessor()),
   *        topSet = d3.set(topKeys),
   *        others = allKeys.filter(function (d) {return !topSet.has(d);});
   *    if (allRowsSum > topRowsSum) {
   *        return topRows.concat([{'others': others, 'key': _othersLabel, 'value': allRowsSum - topRowsSum}]);
   *    }
   *    return topRows;
   * });
   * // Custom others grouper
   * chart.othersGrouper(function (data) {
   *     // compute the value for others, presumably the sum of all values below the cap
   *     var othersSum  = yourComputeOthersValueLogic(data)
   *
   *     // the keys are needed to properly filter when the others element is clicked
   *     var othersKeys = yourComputeOthersKeysArrayLogic(data);
   *
   *     // add the others row to the dataset
   *     data.push({'key': 'Others', 'value': othersSum, 'others': othersKeys });
   *
   *     return data;
   * });
   * @param {Function} [grouperFunction]
   * @return {Function}
   * @return {dc.capMixin}
   */
  _chart.othersGrouper = function (grouperFunction) {
    if (!arguments.length) {
      return _othersGrouper;
    }
    _othersGrouper = grouperFunction;
    return _chart;
  };

  (0, _core.override)(_chart, "onClick", function (d) {
    if (d.others) {
      _chart.filter([d.others]);
    }
    if (_chart._onClick) {
      _chart._onClick(d);
    }
  });

  return _chart;
}

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = coordinateGridMixin;

var _core = __webpack_require__(2);

var _baseMixin = __webpack_require__(5);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

var _binningMixin = __webpack_require__(184);

var _binningMixin2 = _interopRequireDefault(_binningMixin);

var _colorMixin = __webpack_require__(7);

var _colorMixin2 = _interopRequireDefault(_colorMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _events = __webpack_require__(9);

var _filters = __webpack_require__(13);

var _lockAxisMixin = __webpack_require__(135);

var _lockAxisMixin2 = _interopRequireDefault(_lockAxisMixin);

var _marginMixin = __webpack_require__(12);

var _marginMixin2 = _interopRequireDefault(_marginMixin);

var _utils = __webpack_require__(3);

var _coreAsync = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
  * Coordinate Grid is an abstract base chart designed to support a number of coordinate grid based
  * concrete chart types, e.g. bar chart, line chart, and bubble chart.
  * @name coordinateGridMixin
  * @memberof dc
  * @mixin
  * @mixes dc.colorMixin
  * @mixes dc.marginMixin
  * @mixes dc.baseMixin
  * @param {Object} _chart
  * @return {dc.coordinateGridMixin}
  */

var DEFAULT_NUM_TICKS = 10;
var MAX_TICK_WIDTH = 64;
var DEFAULT_TIME_DIMENSION_INDEX = 0;
var ENTER_KEY = 13;
var ONE_SECOND_IN_MS = 1000;

function coordinateGridMixin(_chart) {
  var GRID_LINE_CLASS = "grid-line";
  var HORIZONTAL_CLASS = "horizontal";
  var VERTICAL_CLASS = "vertical";
  var Y_AXIS_LABEL_CLASS = "y-axis-label";
  var X_AXIS_LABEL_CLASS = "x-axis-label";
  var DEFAULT_AXIS_LABEL_PADDING = 12;

  /* OVERRIDE EXTEND ----------------------------------------------------------*/
  var _hasBeenRendered = false;
  /* --------------------------------------------------------------------------*/

  _chart = (0, _lockAxisMixin2.default)((0, _colorMixin2.default)((0, _marginMixin2.default)((0, _baseMixin2.default)(_chart))));

  _chart.colors(_d2.default.scale.category10());
  _chart._mandatoryAttributes().push("x");
  _chart._rangeFocused = false;
  _chart._rangeInput = false;
  _chart._binInput = false;
  _chart._binSnap = false;

  var NO_CACHE = false;
  var cachedXTickFormat = NO_CACHE;
  var cachedYTickFormat = NO_CACHE;

  function zoomHandler() {
    _refocused = true;
    if (_zoomOutRestrict) {
      _chart.x().domain(constrainRange(_chart.x().domain(), _xOriginalDomain));
      if (_rangeChart) {
        _chart.x().domain(constrainRange(_chart.x().domain(), _rangeChart.x().domain()));
      }
    }

    var domain = _chart.x().domain();
    var domFilter = _filters.filters.RangedFilter(domain[0], domain[1]);

    _chart.replaceFilter(domFilter);
    _chart.rescale();
    (0, _coreAsync.redrawAllAsync)(_chart.chartGroup());
  }

  var _parent = void 0;
  var _g = void 0;
  var _chartBodyG = void 0;

  var _x = void 0;
  var _xOriginalDomain = void 0;
  var _xAxis = _d2.default.svg.axis().orient("bottom");
  var _xUnits = _core.units.integers;
  var _xAxisPadding = 0;
  var _xElasticity = false;
  var _xAxisLabel = void 0;
  var _xAxisLabelPadding = 0;
  var _lastXDomain = void 0;

  var _y = void 0;
  var _yAxis = _d2.default.svg.axis().orient("left");
  var _yAxisPadding = 0;
  var _yElasticity = false;
  var _yAxisLabel = void 0;
  var _yAxisLabelPadding = 0;

  var _brush = _d2.default.svg.brush();
  var _brushOn = true;
  var _isBrushing = false;
  var _round = void 0;

  var _renderHorizontalGridLine = false;
  var _renderVerticalGridLine = false;

  var _refocused = false,
      _resizing = false;

  var _unitCount = void 0;

  var _zoomScale = [1, Infinity];
  var _zoomOutRestrict = true;

  var _zoom = _d2.default.behavior.zoom().on("zoom", zoomHandler);
  var _nullZoom = _d2.default.behavior.zoom().on("zoom", null);
  var _hasBeenMouseZoomable = false;

  var _rangeChart = void 0;
  var _focusChart = void 0;

  var _mouseZoomable = false;
  var _clipPadding = 0;

  var _outerRangeBandPadding = 0.5;
  var _rangeBandPadding = 0;

  var _useRightYAxis = false;

  /**
      * When changing the domain of the x or y scale, it is necessary to tell the chart to recalculate
      * and redraw the axes. (`.rescale()` is called automatically when the x or y scale is replaced
      * with {@link #dc.coordinateGridMixin+x .x()} or {@link #dc.coordinateGridMixin+y .y()}, and has
      * no effect on elastic scales.)
      * @name rescale
      * @memberof dc.coordinateGridMixin
      * @instance
      * @return {dc.coordinateGridMixin}
      */
  _chart.rescale = function () {
    _unitCount = undefined;
    _resizing = true;
    return _chart;
  };

  _chart.resizing = function () {
    return _resizing;
  };

  /**
      * Get or set the range selection chart associated with this instance. Setting the range selection
      * chart using this function will automatically update its selection brush when the current chart
      * zooms in. In return the given range chart will also automatically attach this chart as its focus
      * chart hence zoom in when range brush updates.
      * @name rangeChart
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {dc.coordinateGridMixin} [rangeChart]
      * @return {dc.coordinateGridMixin}
      */
  _chart.rangeChart = function (rangeChart) {
    if (!arguments.length) {
      return _rangeChart;
    }
    _rangeChart = rangeChart;

    if (_rangeChart) {
      _rangeChart.focusChart(_chart);
    }

    return _chart;
  };

  /**
      * Get or set the scale extent for mouse zooms.
      * @name zoomScale
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {Array<Number|Date>} [extent=[1, Infinity]]
      * @return {Array<Number|Date>}
      * @return {dc.coordinateGridMixin}
      */
  _chart.zoomScale = function (extent) {
    if (!arguments.length) {
      return _zoomScale;
    }
    _zoomScale = extent;
    return _chart;
  };

  /**
      * Get or set the zoom restriction for the chart. If true limits the zoom to origional domain of the chart.
      * @name zoomOutRestrict
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {Boolean} [zoomOutRestrict=true]
      * @return {Boolean}
      * @return {dc.coordinateGridMixin}
      */
  _chart.zoomOutRestrict = function (zoomOutRestrict) {
    if (!arguments.length) {
      return _zoomOutRestrict;
    }
    _zoomScale[0] = zoomOutRestrict ? 1 : 0;
    _zoomOutRestrict = zoomOutRestrict;
    return _chart;
  };

  _chart._generateG = function (parent) {
    if (parent === undefined) {
      _parent = _chart.svg();
    } else {
      _parent = parent;
    }

    _g = _parent.append("g");

    _chartBodyG = _g.append("g").attr("class", "chart-body").attr("transform", "translate(" + _chart.margins().left + ", " + _chart.margins().top + ")").attr("clip-path", "url(#" + getClipPathId() + ")");

    return _g;
  };

  /**
      * Get or set the root g element. This method is usually used to retrieve the g element in order to
      * overlay custom svg drawing programatically. **Caution**: The root g element is usually generated
      * by dc.js internals, and resetting it might produce unpredictable result.
      * @name g
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {SVGElement} [gElement]
      * @return {SVGElement}
      * @return {dc.coordinateGridMixin}
      */
  _chart.g = function (gElement) {
    if (!arguments.length) {
      return _g;
    }
    _g = gElement;
    return _chart;
  };

  /**
      * Set or get mouse zoom capability flag (default: false). When turned on the chart will be
      * zoomable using the mouse wheel. If the range selector chart is attached zooming will also update
      * the range selection brush on the associated range selector chart.
      * @name mouseZoomable
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {Boolean} [mouseZoomable=false]
      * @return {Boolean}
      * @return {dc.coordinateGridMixin}
      */
  _chart.mouseZoomable = function (mouseZoomable) {
    if (!arguments.length) {
      return _mouseZoomable;
    }
    _mouseZoomable = mouseZoomable;
    return _chart;
  };

  /**
      * Retrieve the svg group for the chart body.
      * @name chartBodyG
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {SVGElement} [chartBodyG]
      * @return {SVGElement}
      */
  _chart.chartBodyG = function (chartBodyG) {
    if (!arguments.length) {
      return _chartBodyG;
    }
    _chartBodyG = chartBodyG;
    return _chart;
  };

  /**
      * **mandatory**
      *
      * Get or set the x scale. The x scale can be any d3
      * {@link https://github.com/mbostock/d3/wiki/Quantitative-Scales quantitive scale} or
      * {@link https://github.com/mbostock/d3/wiki/Ordinal-Scales ordinal scale}.
      * @name x
      * @memberof dc.coordinateGridMixin
      * @instance
      * @see {@link http://github.com/mbostock/d3/wiki/Scales d3.scale}
      * @example
      * // set x to a linear scale
      * chart.x(d3.scale.linear().domain([-2500, 2500]))
      * // set x to a time scale to generate histogram
      * chart.x(d3.time.scale().domain([new Date(1985, 0, 1), new Date(2012, 11, 31)]))
      * @param {d3.scale} [xScale]
      * @return {d3.scale}
      * @return {dc.coordinateGridMixin}
      */
  _chart.x = function (xScale) {
    if (!arguments.length) {
      return _x;
    }
    _x = xScale;
    _xOriginalDomain = _x.domain();
    _chart.rescale();
    return _chart;
  };

  _chart.xOriginalDomain = function (domain) {
    if (!arguments.length) {
      return _xOriginalDomain;
    }
    _xOriginalDomain = domain;
    return _chart;
  };

  /**
      * Set or get the xUnits function. The coordinate grid chart uses the xUnits function to calculate
      * the number of data projections on x axis such as the number of bars for a bar chart or the
      * number of dots for a line chart. This function is expected to return a Javascript array of all
      * data points on x axis, or the number of points on the axis. [d3 time range functions
      * d3.time.days, d3.time.months, and
      * d3.time.years](https://github.com/mbostock/d3/wiki/Time-Intervals#aliases) are all valid xUnits
      * function. dc.js also provides a few units function, see the {@link #utilities Utilities} section for
      * a list of built-in units functions. The default xUnits function is dc.units.integers.
      * @name xUnits
      * @memberof dc.coordinateGridMixin
      * @instance
      * @todo Add docs for utilities
      * @example
      * // set x units to count days
      * chart.xUnits(d3.time.days);
      * // set x units to count months
      * chart.xUnits(d3.time.months);
      *
      * // A custom xUnits function can be used as long as it follows the following interface:
      * // units in integer
      * function(start, end, xDomain) {
      *      // simply calculates how many integers in the domain
      *      return Math.abs(end - start);
      * };
      *
      * // fixed units
      * function(start, end, xDomain) {
      *      // be aware using fixed units will disable the focus/zoom ability on the chart
      *      return 1000;
      * @param {Function} [xUnits]
      * @return {Function}
      * @return {dc.coordinateGridMixin}
      */
  _chart.xUnits = function (xUnits) {
    if (!arguments.length) {
      return _xUnits;
    }
    _xUnits = xUnits;
    return _chart;
  };

  /**
      * Set or get the x axis used by a particular coordinate grid chart instance. This function is most
      * useful when x axis customization is required. The x axis in dc.js is an instance of a [d3
      * axis object](https://github.com/mbostock/d3/wiki/SVG-Axes#wiki-axis); therefore it supports any
      * valid d3 axis manipulation. **Caution**: The x axis is usually generated internally by dc;
      * resetting it may cause unexpected results.
      * @name xAxis
      * @memberof dc.coordinateGridMixin
      * @instance
      * @see {@link http://github.com/mbostock/d3/wiki/SVG-Axes d3.svg.axis}
      * @example
      * // customize x axis tick format
      * chart.xAxis().tickFormat(function(v) {return v + '%';});
      * // customize x axis tick values
      * chart.xAxis().tickValues([0, 100, 200, 300]);
      * @param {d3.svg.axis} [xAxis=d3.svg.axis().orient('bottom')]
      * @return {d3.svg.axis}
      * @return {dc.coordinateGridMixin}
      */
  _chart.xAxis = function (xAxis) {
    if (!arguments.length) {
      return _xAxis;
    }
    _xAxis = xAxis;
    return _chart;
  };

  /**
      * Turn on/off elastic x axis behavior. If x axis elasticity is turned on, then the grid chart will
      * attempt to recalculate the x axis range whenever a redraw event is triggered.
      * @name elasticX
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {Boolean} [elasticX=false]
      * @return {Boolean}
      * @return {dc.coordinateGridMixin}
      */
  _chart.elasticX = function (elasticX) {
    if (!arguments.length) {
      return _xElasticity;
    }
    _xElasticity = elasticX;
    return _chart;
  };

  /**
      * Set or get x axis padding for the elastic x axis. The padding will be added to both end of the x
      * axis if elasticX is turned on; otherwise it is ignored.
      *
      * padding can be an integer or percentage in string (e.g. '10%'). Padding can be applied to
      * number or date x axes.  When padding a date axis, an integer represents number of days being padded
      * and a percentage string will be treated the same as an integer.
      * @name xAxisPadding
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {Number|String} [padding=0]
      * @return {Number|String}
      * @return {dc.coordinateGridMixin}
      */
  _chart.xAxisPadding = function (padding) {
    if (!arguments.length) {
      return _xAxisPadding;
    }
    _xAxisPadding = padding;
    return _chart;
  };

  /**
      * Returns the number of units displayed on the x axis using the unit measure configured by
      * .xUnits.
      * @name xUnitCount
      * @memberof dc.coordinateGridMixin
      * @instance
      * @return {Number}
      */
  _chart.xUnitCount = function () {
    if (_unitCount === undefined) {
      var _units = _chart.xUnits()(_chart.x().domain()[0], _chart.x().domain()[1], _chart.x().domain());

      if (_units instanceof Array) {
        _unitCount = _units.length;
      } else {
        _unitCount = _units;
      }
    }

    return _unitCount;
  };

  /**
      * Gets or sets whether the chart should be drawn with a right axis instead of a left axis. When
      * used with a chart in a composite chart, allows both left and right Y axes to be shown on a
      * chart.
      * @name useRightYAxis
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {Boolean} [useRightYAxis=false]
      * @return {Boolean}
      * @return {dc.coordinateGridMixin}
      */
  _chart.useRightYAxis = function (useRightYAxis) {
    if (!arguments.length) {
      return _useRightYAxis;
    }
    _useRightYAxis = useRightYAxis;
    return _chart;
  };

  /**
      * Returns true if the chart is using ordinal xUnits ({@link #dc.units.ordinal dc.units.ordinal}, or false
      * otherwise. Most charts behave differently with ordinal data and use the result of this method to
      * trigger the appropriate logic.
      * @name isOrdinal
      * @memberof dc.coordinateGridMixin
      * @instance
      * @return {Boolean}
      */
  _chart.isOrdinal = function () {
    return _chart.xUnits() === _core.units.ordinal;
  };

  _chart._useOuterPadding = function () {
    return true;
  };

  _chart._ordinalXDomain = function () {
    var groups = _chart._computeOrderedGroups(_chart.data());
    return groups.map(_chart.keyAccessor());
  };

  function compareDomains(d1, d2) {
    return !d1 || !d2 || d1.length !== d2.length || d1.some(function (elem, i) {
      return elem && d2[i] ? elem.toString() !== d2[i].toString() : elem === d2[i];
    });
  }

  function prepareXAxis(g, render) {
    if (!_chart.isOrdinal()) {
      if (_chart.elasticX() && (!_chart.rangeChart() || _chart.rangeChart() && !_chart.rangeChart().filters().length)) {
        _x.domain([_chart.xAxisMin(), _chart.xAxisMax()]);
      }
    } else if (_chart.elasticX() || _x.domain().length === 0) {
      _x.domain(_chart._ordinalXDomain());
    }

    var xdom = _x.domain();
    if (render || compareDomains(_lastXDomain, xdom)) {
      _chart.rescale();
    }
    _lastXDomain = xdom;

    if (_chart.isOrdinal()) {
      _x.rangeBands([0, _chart.xAxisLength()], _rangeBandPadding, _chart._useOuterPadding() ? _outerRangeBandPadding : 0);
    } else {
      _x.range([0, _chart.xAxisLength()]);
    }

    _chart.xAxis().ticks(_chart.getNumTicksForXAxis());

    renderVerticalGridLines(g);
    _chart.prepareLabelEdit("x");
    _chart.prepareLockAxis("x");
  }

  /* istanbul ignore next */
  _chart.renderXAxis = function (g) {
    var axisXG = g.selectAll("g.x");

    setXAxisFormat();

    if (axisXG.empty()) {
      axisXG = g.append("g").attr("class", "axis x").attr("transform", "translate(" + _chart.margins().left + "," + _chart._xAxisY() + ")");
    }

    /* OVERRIDE -----------------------------------------------------------------*/
    var root = _chart.root();

    if (_chart.rangeInput()) {
      var rangeDisplay = root.selectAll(".range-display");

      if (rangeDisplay.empty()) {
        rangeDisplay = root.append("div").attr("class", "range-display").style("right", _chart.margins().right + "px");

        var group1 = rangeDisplay.append("div");

        rangeDisplay.append("span").html(" &mdash; ");

        var group2 = rangeDisplay.append("div");

        group1.append("input").attr("class", "range-start-day range-day");

        group1.append("input").attr("class", "range-start-time range-time");

        group2.append("input").attr("class", "range-end-day range-day");

        group2.append("input").attr("class", "range-end-time range-time");

        rangeDisplay.selectAll("input").each(function () {
          bindRangeInputEvents(this);
        });

        if (_chart.group().binParams()[0] && _chart.group().binParams()[0].timeBin) {
          _chart.updateRangeInput();
        }

        _chart.root().select("div > .svg-wrapper").on("mouseover", function () {
          rangeDisplay.selectAll("input").classed("active", true);
        }).on("mouseleave", function () {
          rangeDisplay.selectAll("input").classed("active", false);
        });
      }
    }

    var xLabel = root.selectAll(".x-axis-label");

    var shouldAppendLabel = _chart.rangeChart() ? false : xLabel.empty();
    if (shouldAppendLabel) {
      xLabel = root.append("div").attr("class", "x-axis-label");
    }

    if (!_chart.rangeChart()) {
      xLabel.style("left", _chart.effectiveWidth() / 2 + _chart.margins().left + "px").text(_chart.xAxisLabel());
    }

    (0, _core.transition)(axisXG, _chart.transitionDuration()).attr("transform", "translate(" + _chart.margins().left + "," + _chart._xAxisY() + ")").call(_chart.xAxis());

    _chart.updateBinInput();
  };

  function renderVerticalGridLines(g) {
    var gridLineG = g.selectAll("g." + VERTICAL_CLASS);

    if (_renderVerticalGridLine) {
      if (gridLineG.empty()) {
        gridLineG = g.insert("g", ":first-child").attr("class", GRID_LINE_CLASS + " " + VERTICAL_CLASS).attr("transform", "translate(" + _chart.margins().left + "," + _chart.margins().top + ")");
      }

      var ticks = _xAxis.tickValues() ? _xAxis.tickValues() : typeof _x.ticks === "function" ? _x.ticks(_xAxis.ticks()[0]) : _x.domain();

      var lines = gridLineG.selectAll("line").data(ticks);

      var linesGEnter = lines.enter().append("line").attr("x1", function (d) {
        return _x(d);
      }).attr("y1", _chart._xAxisY() - _chart.margins().top).attr("x2", function (d) {
        return _x(d);
      }).attr("y2", 0).attr("opacity", 0);
      (0, _core.transition)(linesGEnter, _chart.transitionDuration()).attr("opacity", 1);

      (0, _core.transition)(lines, _chart.transitionDuration()).attr("x1", function (d) {
        return _x(d);
      }).attr("y1", _chart._xAxisY() - _chart.margins().top).attr("x2", function (d) {
        return _x(d);
      }).attr("y2", 0);

      lines.exit().remove();
    } else {
      gridLineG.selectAll("line").remove();
    }
  }

  _chart._xAxisY = function () {
    return _chart.height() - _chart.margins().bottom;
  };

  _chart.xAxisLength = function () {
    return _chart.effectiveWidth();
  };

  /**
      * Set or get the x axis label. If setting the label, you may optionally include additional padding to
      * the margin to make room for the label. By default the padded is set to 12 to accomodate the text height.
      * @name xAxisLabel
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {String} [labelText]
      * @param {Number} [padding=12]
      * @return {String}
      */
  _chart.xAxisLabel = function (labelText, padding) {
    if (!arguments.length) {
      return _xAxisLabel;
    }
    _xAxisLabel = labelText;
    _chart.margins().bottom -= _xAxisLabelPadding;
    _xAxisLabelPadding = padding === undefined ? DEFAULT_AXIS_LABEL_PADDING : padding;
    _chart.margins().bottom += _xAxisLabelPadding;
    return _chart;
  };

  _chart._prepareYAxis = function (g) {
    if (_y === undefined || _chart.elasticY()) {
      if (_y === undefined) {
        _y = _d2.default.scale.linear();
      }
      var min = _chart.yAxisMin() || 0,
          max = _chart.yAxisMax() || 0;
      _y.domain([min, max]).rangeRound([_chart.yAxisHeight(), 0]);
    }

    _y.range([_chart.yAxisHeight(), 0]);
    _yAxis = _yAxis.scale(_y);

    _yAxis.ticks(_chart.effectiveHeight() / _yAxis.scale().ticks().length < 16 ? Math.ceil(_chart.effectiveHeight() / 16) : 10);

    if (_useRightYAxis) {
      _yAxis.orient("right");
    }

    _chart._renderHorizontalGridLinesForAxis(g, _y, _yAxis);
    _chart.prepareLockAxis("y");
  };

  function setYTickFormat(tickFormat, options) {
    if (options.toCache && cachedYTickFormat === NO_CACHE) {
      cachedYTickFormat = _yAxis.tickFormat();
    }

    _yAxis.tickFormat(tickFormat);

    if (options.fromCache) {
      cachedYTickFormat = NO_CACHE;
    }
  }

  function setYAxisFormat() {
    var numberFormatter = _chart.valueFormatter();
    var formatExistsForThisKey = numberFormatter && numberFormatter(null, _chart.yAxisLabel());

    if (formatExistsForThisKey) {
      setYTickFormat(function (d) {
        return numberFormatter(d, _chart.yAxisLabel());
      }, { toCache: true });
    } else if (cachedYTickFormat !== NO_CACHE) {
      setYTickFormat(cachedYTickFormat, { fromCache: true });
    }
  }

  function setXTickFormat(tickFormat, options) {
    if (options.toCache && cachedXTickFormat === NO_CACHE) {
      cachedXTickFormat = _xAxis.tickFormat();
    }

    _xAxis.tickFormat(tickFormat);

    if (options.fromCache) {
      cachedXTickFormat = NO_CACHE;
    }
  }

  function setXAxisFormat() {
    var timeBinParam = _chart.group().binParams()[DEFAULT_TIME_DIMENSION_INDEX] || {};

    var domain = _chart.x().domain();

    var dateFormatter = _chart.dateFormatter();
    var numberFormatter = _chart.valueFormatter();
    var dateFormatExistsForThisKey = Boolean(dateFormatter && dateFormatter(new Date(), _chart.xAxisLabel()));
    var numberFormatExistsForThisKey = Boolean(numberFormatter && numberFormatter(null, _chart.xAxisLabel()));

    if (domain && domain[0] && domain[0] instanceof Date && !timeBinParam.extract && dateFormatExistsForThisKey) {
      setXTickFormat(function (d) {
        return dateFormatter(d, _chart.xAxisLabel());
      }, { toCache: true });
    } else if (!timeBinParam.extract && numberFormatExistsForThisKey) {
      setXTickFormat(function (d) {
        return numberFormatter(d, _chart.xAxisLabel());
      }, { toCache: true });
    } else if (cachedXTickFormat !== NO_CACHE) {
      setXTickFormat(cachedXTickFormat, { fromCache: true });
    }
  }

  _chart.renderYAxisAt = function (axisClass, axis, position) {
    var axisYG = _chart.g().selectAll("g." + axisClass);
    if (axisYG.empty()) {
      axisYG = _chart.g().append("g").attr("class", "axis " + axisClass).attr("transform", "translate(" + position + "," + _chart.margins().top + ")");
    }

    (0, _core.transition)(axisYG, _chart.transitionDuration()).attr("transform", "translate(" + position + "," + _chart.margins().top + ")").call(axis);
  };

  _chart.renderYAxis = function () {
    var axisPosition = _useRightYAxis ? _chart.width() - _chart.margins().right : _chart._yAxisX();
    setYAxisFormat();
    _chart.renderYAxisAt("y", _yAxis, axisPosition);
    var labelPosition = _useRightYAxis ? _chart.width() - _yAxisLabelPadding : _yAxisLabelPadding;
    var rotation = _useRightYAxis ? 90 : -90;
    _chart.renderYAxisLabel("y", _chart.yAxisLabel(), rotation, labelPosition);
  };

  _chart._renderHorizontalGridLinesForAxis = function (g, scale, axis) {
    var gridLineG = g.selectAll("g." + HORIZONTAL_CLASS);

    if (_renderHorizontalGridLine) {
      var ticks = axis.tickValues() ? axis.tickValues() : scale.ticks(axis.ticks()[0]);

      if (gridLineG.empty()) {
        gridLineG = g.insert("g", ":first-child").attr("class", GRID_LINE_CLASS + " " + HORIZONTAL_CLASS).attr("transform", "translate(" + _chart.margins().left + "," + _chart.margins().top + ")");
      }

      var lines = gridLineG.selectAll("line").data(ticks);

      var linesGEnter = lines.enter().append("line").attr("x1", 1).attr("y1", function (d) {
        return scale(d);
      }).attr("x2", _chart.xAxisLength()).attr("y2", function (d) {
        return scale(d);
      }).attr("opacity", 0);
      (0, _core.transition)(linesGEnter, _chart.transitionDuration()).attr("opacity", 1);

      (0, _core.transition)(lines, _chart.transitionDuration()).attr("x1", 1).attr("y1", function (d) {
        return scale(d);
      }).attr("x2", _chart.xAxisLength()).attr("y2", function (d) {
        return scale(d);
      });

      lines.exit().remove();
    } else {
      gridLineG.selectAll("line").remove();
    }
  };

  _chart._yAxisX = function () {
    return _chart.useRightYAxis() ? _chart.width() - _chart.margins().right : _chart.margins().left;
  };

  /**
      * Set or get the y axis label. If setting the label, you may optionally include additional padding
      * to the margin to make room for the label. By default the padded is set to 12 to accomodate the
      * text height.
      * @name yAxisLabel
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {String} [labelText]
      * @param {Number} [padding=12]
      * @return {String}
      * @return {dc.coordinateGridMixin}
      */
  _chart.yAxisLabel = function (labelText, padding) {
    if (!arguments.length) {
      return _yAxisLabel;
    }
    _yAxisLabel = labelText;
    _chart.margins().left -= _yAxisLabelPadding;
    _yAxisLabelPadding = padding === undefined ? DEFAULT_AXIS_LABEL_PADDING : padding;
    _chart.margins().left += _yAxisLabelPadding;
    return _chart;
  };

  /**
      * Get or set the y scale. The y scale is typically automatically determined by the chart implementation.
      * @name y
      * @memberof dc.coordinateGridMixin
      * @instance
      * @see {@link http://github.com/mbostock/d3/wiki/Scales d3.scale}
      * @param {d3.scale} [yScale]
      * @return {d3.scale}
      * @return {dc.coordinateGridMixin}
      */
  _chart.y = function (yScale) {
    if (!arguments.length) {
      return _y;
    }
    _y = yScale;
    _chart.rescale();
    return _chart;
  };

  /**
      * Set or get the y axis used by the coordinate grid chart instance. This function is most useful
      * when y axis customization is required. The y axis in dc.js is simply an instance of a [d3 axis
      * object](https://github.com/mbostock/d3/wiki/SVG-Axes#wiki-_axis); therefore it supports any
      * valid d3 axis manipulation. **Caution**: The y axis is usually generated internally by dc;
      * resetting it may cause unexpected results.
      * @name yAxis
      * @memberof dc.coordinateGridMixin
      * @instance
      * @see {@link http://github.com/mbostock/d3/wiki/SVG-Axes d3.svg.axis}
      * @example
      * // customize y axis tick format
      * chart.yAxis().tickFormat(function(v) {return v + '%';});
      * // customize y axis tick values
      * chart.yAxis().tickValues([0, 100, 200, 300]);
      * @param {d3.svg.axis} [yAxis=d3.svg.axis().orient('left')]
      * @return {d3.svg.axis}
      * @return {dc.coordinateGridMixin}
      */
  _chart.yAxis = function (yAxis) {
    if (!arguments.length) {
      return _yAxis;
    }
    _yAxis = yAxis;
    return _chart;
  };

  /**
      * Turn on/off elastic y axis behavior. If y axis elasticity is turned on, then the grid chart will
      * attempt to recalculate the y axis range whenever a redraw event is triggered.
      * @name elasticY
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {Boolean} [elasticY=false]
      * @return {Boolean}
      * @return {dc.coordinateGridMixin}
      */
  _chart.elasticY = function (elasticY) {
    if (!arguments.length) {
      return _yElasticity;
    }
    _yElasticity = elasticY;
    return _chart;
  };

  /**
      * Turn on/off horizontal grid lines.
      * @name renderHorizontalGridLines
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {Boolean} [renderHorizontalGridLines=false]
      * @return {Boolean}
      * @return {dc.coordinateGridMixin}
      */
  _chart.renderHorizontalGridLines = function (renderHorizontalGridLines) {
    if (!arguments.length) {
      return _renderHorizontalGridLine;
    }
    _renderHorizontalGridLine = renderHorizontalGridLines;
    return _chart;
  };

  /**
      * Turn on/off vertical grid lines.
      * @name renderVerticalGridLines
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {Boolean} [renderVerticalGridLines=false]
      * @return {Boolean}
      * @return {dc.coordinateGridMixin}
      */
  _chart.renderVerticalGridLines = function (renderVerticalGridLines) {
    if (!arguments.length) {
      return _renderVerticalGridLine;
    }
    _renderVerticalGridLine = renderVerticalGridLines;
    return _chart;
  };

  /**
      * Calculates the minimum x value to display in the chart. Includes xAxisPadding if set.
      * @name xAxisMin
      * @memberof dc.coordinateGridMixin
      * @instance
      * @return {*}
      */
  _chart.xAxisMin = function () {
    var min = _d2.default.min(_chart.data(), function (e) {
      return _chart.keyAccessor()(e);
    });
    var max = _d2.default.max(_chart.data(), function (e) {
      return _chart.keyAccessor()(e);
    });
    return _utils.utils.subtract(min, _xAxisPadding, max - min);
  };

  /**
      * Calculates the maximum x value to display in the chart. Includes xAxisPadding if set.
      * @name xAxisMax
      * @memberof dc.coordinateGridMixin
      * @instance
      * @return {*}
      */
  _chart.xAxisMax = function () {
    var max = _d2.default.max(_chart.data(), function (e) {
      return _chart.keyAccessor()(e);
    });
    var min = _d2.default.min(_chart.data(), function (e) {
      return _chart.keyAccessor()(e);
    });
    return _utils.utils.add(max, _xAxisPadding, max - min);
  };

  /**
      * Calculates the minimum y value to display in the chart. Includes yAxisPadding if set.
      * @name yAxisMin
      * @memberof dc.coordinateGridMixin
      * @instance
      * @return {*}
      */
  _chart.yAxisMin = function () {
    var min = _d2.default.min(_chart.data(), function (e) {
      return _chart.valueAccessor()(e);
    });
    var max = _d2.default.max(_chart.data(), function (e) {
      return _chart.valueAccessor()(e);
    });
    return _utils.utils.subtract(min, _yAxisPadding, max - min);
  };

  /**
      * Calculates the maximum y value to display in the chart. Includes yAxisPadding if set.
      * @name yAxisMax
      * @memberof dc.coordinateGridMixin
      * @instance
      * @return {*}
      */
  _chart.yAxisMax = function () {
    var max = _d2.default.max(_chart.data(), function (e) {
      return _chart.valueAccessor()(e);
    });
    var min = _d2.default.min(_chart.data(), function (e) {
      return _chart.valueAccessor()(e);
    });
    return _utils.utils.add(max, _yAxisPadding, max - min);
  };

  /**
      * Set or get y axis padding for the elastic y axis. The padding will be added to the top of the y
      * axis if elasticY is turned on; otherwise it is ignored.
      *
      * padding can be an integer or percentage in string (e.g. '10%'). Padding can be applied to
      * number or date axes. When padding a date axis, an integer represents number of days being padded
      * and a percentage string will be treated the same as an integer.
      * @name yAxisPadding
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {Number|String} [padding=0]
      * @return {Number}
      * @return {dc.coordinateGridMixin}
      */
  _chart.yAxisPadding = function (padding) {
    if (!arguments.length) {
      return _yAxisPadding;
    }
    _yAxisPadding = padding;
    return _chart;
  };

  _chart.yAxisHeight = function () {
    var height = _chart.effectiveHeight();
    return height < 0 ? 0 : height;
  };

  /**
      * Set or get the rounding function used to quantize the selection when brushing is enabled.
      * @name round
      * @memberof dc.coordinateGridMixin
      * @instance
      * @example
      * // set x unit round to by month, this will make sure range selection brush will
      * // select whole months
      * chart.round(d3.time.month.round);
      * @param {Function} [round]
      * @return {Function}
      * @return {dc.coordinateGridMixin}
      */
  _chart.round = function (round) {
    if (!arguments.length) {
      return _round;
    }
    _round = round;
    return _chart;
  };

  _chart._rangeBandPadding = function (_) {
    if (!arguments.length) {
      return _rangeBandPadding;
    }
    _rangeBandPadding = _;
    return _chart;
  };

  _chart._outerRangeBandPadding = function (_) {
    if (!arguments.length) {
      return _outerRangeBandPadding;
    }
    _outerRangeBandPadding = _;
    return _chart;
  };

  function updateBinParamsForChart(_chart, filter) {
    var extract = _chart.binParams()[0] ? _chart.binParams()[0].extract : false;
    if (_chart.focusChart() && filter.length && !extract) {
      var FocusChart = _chart.focusChart();
      var currentBinParams = FocusChart.binParams();
      if (currentBinParams[0]) {
        currentBinParams[0].binBounds = filter;
        FocusChart.binParams(currentBinParams);
      }
      _chart.brush().extent(filter);
    }
  }

  function resetBinParamsForChart(_chart) {
    if (_chart.binParams()[0]) {
      var extract = _chart.binParams()[0].extract;
      var isRangeAndIsNotFiltered = _chart.focusChart() && !_chart.filters().length && !extract;

      if (isRangeAndIsNotFiltered) {
        var chartBinParams = _chart.focusChart().binParams().map(function (p) {
          return p;
        });
        chartBinParams[0].binBounds = _chart.binParams()[0].binBounds;
        _chart.focusChart().binParams(chartBinParams);
        _chart.focusChart().x().domain(_chart.x().domain().slice(0));
      }
    }
  }

  (0, _core.override)(_chart, "filter", function (filter, isInverseFilter) {
    if (!arguments.length) {
      return _chart._filter();
    }
    _chart._filter(filter, isInverseFilter);
    if (filter.length) {
      updateBinParamsForChart(_chart, filter);
      _chart.brush().extent(filter);
    } else {
      resetBinParamsForChart(_chart);
      _chart.brush().clear();
    }

    if (_chart.rangeInput()) {
      _chart.updateRangeInput();
    }
    return _chart;
  });

  _chart.brush = function (_) {
    if (!arguments.length) {
      return _brush;
    }
    _brush = _;
    return _chart;
  };

  _chart.isBrushing = function (_) {
    if (!arguments.length) {
      return _isBrushing;
    }
    _isBrushing = _;
    return _chart;
  };

  function brushHeight() {
    var height = _chart._xAxisY() - _chart.margins().top;
    return height < 0 ? 0 : height;
  }

  _chart.renderBrush = function (g) {
    if (_brushOn) {
      var gBrush = g.select("g.brush").empty() ? g.append("g") : g.select("g.brush");

      gBrush.attr("class", "brush").attr("transform", "translate(" + _chart.margins().left + "," + _chart.margins().top + ")").call(_brush.x(_chart.x()));

      gBrush.select("rect.extent").attr("clip-path", "url(#" + getClipPathId() + ")");

      _chart.setBrushY(gBrush, false);
      _chart.setHandlePaths(gBrush);

      _brush.on("brush", _chart._brushing);
      _brush.on("brushstart", function () {
        _isBrushing = true;
        _chart._disableMouseZoom();
        (0, _core.disableTransitions)(true);
      });
      _brush.on("brushend", function () {
        _isBrushing = false;
        configureMouseZoom();
        (0, _core.disableTransitions)(false);
      });

      if (_chart.hasFilter()) {
        _chart.redrawBrush(g, false);
      }
    }
  };

  _chart.brushSnap = function () {
    if (!_d2.default.event.sourceEvent) {
      return;
    } // only transition after input
    _chart.binBrush();
  };

  _chart.triggerReplaceFilter = function (shouldSetSizingFalse) {
    _resizing = false;
  };

  _chart.setHandlePaths = function (gBrush) {
    gBrush.selectAll(".resize").append("path").attr("d", _chart.resizeHandlePath);
  };

  _chart.setBrushY = function (gBrush) {
    gBrush.selectAll(".brush rect").attr("height", brushHeight());
    gBrush.selectAll(".resize path").attr("d", _chart.resizeHandlePath);
  };

  _chart.extendBrush = function () {
    var extent = _brush.extent();
    if (_chart.round()) {
      extent[0] = extent.map(_chart.round())[0];
      extent[1] = extent.map(_chart.round())[1];

      _g.select(".brush").call(_brush.extent(extent));
    }
    return extent;
  };

  _chart.brushIsEmpty = function (extent) {
    return _brush.empty() || !extent || extent[1] <= extent[0];
  };

  _chart._brushing = function () {
    _chart.brushSnap();
    var extent = _chart.extendBrush();

    _chart.redrawBrush(_g, false);

    if (_chart.brushIsEmpty(extent)) {
      _events.events.trigger(function () {
        if (_chart.focusChart()) {
          _chart.focusChart().filterAll();
        }
        _chart.filterAll();
        _chart.redrawGroup();
      }, _core.constants.EVENT_DELAY);
    } else {
      var rangedFilter = _filters.filters.RangedFilter(extent[0], extent[1]);

      _events.events.trigger(function () {
        /* OVERRIDE ---------------------------------------------------------------- */
        (0, _core.globalTransitionDuration)(10);
        /* ------------------------------------------------------------------------- */
        _chart.replaceFilter(rangedFilter);
        _chart.redrawGroup();
      }, _core.constants.EVENT_DELAY);
    }

    if (_chart.rangeInput()) {
      _chart.updateRangeInput();
    } else if (_chart.focusChart() && _chart.focusChart().rangeInput()) {
      _chart.focusChart().updateRangeInput();
    }
  };

  _chart.redrawBrush = function (g, doTransition) {
    if (_brushOn) {
      /* OVERRIDE ---------------------------------------------------------------- */
      if (_chart.filter() && (_chart.brush().empty() || _chart._redrawBrushFlag)) {
        _chart._redrawBrushFlag = false;
        /* ------------------------------------------------------------------------- */

        _chart.brush().extent(_chart.filter());
      }

      var gBrush = (0, _core.optionalTransition)(doTransition, _chart.transitionDuration())(g.select("g.brush"));
      _chart.setBrushY(gBrush);
      gBrush.call(_chart.brush().x(_chart.x()).extent(_chart.brush().extent()));
    }

    _chart.fadeDeselectedArea();
  };

  _chart.fadeDeselectedArea = function () {}
  // do nothing, sub-chart should override this function


  // borrowed from Crossfilter example
  ;_chart.resizeHandlePath = function (d) {
    var e = Number(d === "e"),
        x = e ? 1 : -1,
        y = brushHeight() / 3;
    return "M" + 0.5 * x + "," + y + "A6,6 0 0 " + e + " " + 6.5 * x + "," + (y + 6) + "V" + (2 * y - 6) + "A6,6 0 0 " + e + " " + 0.5 * x + "," + 2 * y + "Z" + "M" + 2.5 * x + "," + (y + 8) + "V" + (2 * y - 8) + "M" + 4.5 * x + "," + (y + 8) + "V" + (2 * y - 8);
  };

  function getClipPathId() {
    return _chart.anchorName().replace(/[ .#=\[\]]/g, "-") + "-clip";
  }

  /**
      * Get or set the padding in pixels for the clip path. Once set padding will be applied evenly to
      * the top, left, right, and bottom when the clip path is generated. If set to zero, the clip area
      * will be exactly the chart body area minus the margins.
      * @name clipPadding
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {Number} [padding=5]
      * @return {Number}
      * @return {dc.coordinateGridMixin}
      */
  _chart.clipPadding = function (padding) {
    if (!arguments.length) {
      return _clipPadding;
    }
    _clipPadding = padding;
    return _chart;
  };

  function generateClipPath() {
    var defs = _utils.utils.appendOrSelect(_parent, "defs");
    // cannot select <clippath> elements; bug in WebKit, must select by id
    // https://groups.google.com/forum/#!topic/d3-js/6EpAzQ2gU9I
    var id = getClipPathId();
    var chartBodyClip = _utils.utils.appendOrSelect(defs, "#" + id, "clipPath").attr("id", id);

    var padding = _clipPadding * 2;

    _utils.utils.appendOrSelect(chartBodyClip, "rect").attr("width", _chart.xAxisLength() + padding).attr("height", _chart.yAxisHeight() + padding).attr("transform", "translate(-" + _clipPadding + ", -" + _clipPadding + ")");
  }

  _chart._preprocessData = function (data) {};

  _chart._doRender = function () {
    _chart._redrawBrushFlag = true;

    _chart.resetSvg();

    _chart._preprocessData();

    _chart._generateG();

    _chart.root().classed("coordinate-chart", true);

    generateClipPath();

    drawChart(true);

    configureMouseZoom();

    /* OVERRIDE ---------------------------------------------------------------- */
    _hasBeenRendered = true;
    /* ------------------------------------------------------------------------- */
    return _chart;
  };

  _chart._doRedraw = function () {
    /* OVERRIDE ---------------------------------------------------------------- */
    if (!_hasBeenRendered) {
      // guard to prevent a redraw before a render
      return _chart._doRender();
    }
    /* ------------------------------------------------------------------------- */
    _chart._preprocessData();

    drawChart(false);
    generateClipPath();

    return _chart;
  };

  function drawChart(render) {
    if (_chart.isOrdinal()) {
      _brushOn = false;
    }

    prepareXAxis(_chart.g(), render);
    _chart._prepareYAxis(_chart.g());

    _chart.plotData();

    if (_chart.elasticX() || _resizing || render) {
      _chart.renderXAxis(_chart.g());
    }

    if (_chart.elasticY() || _resizing || render) {
      _chart.renderYAxis(_chart.g());
    }

    if (render) {
      _chart.renderBrush(_chart.g(), false);
    } else {
      _chart.redrawBrush(_chart.g(), _resizing);
    }
    _chart.fadeDeselectedArea();
    _resizing = false;
  }

  function configureMouseZoom() {
    if (_mouseZoomable) {
      _chart._enableMouseZoom();
    } else if (_hasBeenMouseZoomable) {
      _chart._disableMouseZoom();
    }
  }

  _chart._enableMouseZoom = function () {
    _hasBeenMouseZoomable = true;
    _zoom.x(_chart.x()).scaleExtent(_zoomScale).size([_chart.width(), _chart.height()]).duration(_chart.transitionDuration());
    _chart.root().call(_zoom);
  };

  _chart._disableMouseZoom = function () {
    _chart.root().call(_nullZoom);
  };

  function constrainRange(range, constraint) {
    var constrainedRange = [];
    constrainedRange[0] = _d2.default.max([range[0], constraint[0]]);
    constrainedRange[1] = _d2.default.min([range[1], constraint[1]]);
    return constrainedRange;
  }

  /**
      * Zoom this chart to focus on the given range. The given range should be an array containing only
      * 2 elements (`[start, end]`) defining a range in the x domain. If the range is not given or set
      * to null, then the zoom will be reset. _For focus to work elasticX has to be turned off;
      * otherwise focus will be ignored.
      * @name focus
      * @memberof dc.coordinateGridMixin
      * @instance
      * @example
      * chart.on('renderlet', function(chart) {
      *     // smooth the rendering through event throttling
      *     events.trigger(function(){
      *          // focus some other chart to the range selected by user on this chart
      *          someOtherChart.focus(chart.filter());
      *     });
      * })
      * @param {Array<Number>} [range]
      */
  _chart.focus = function (range) {
    if (hasRangeSelected(range)) {
      _chart.x().domain(range);
    } else {
      _chart.x().domain(_xOriginalDomain);
    }

    _zoom.x(_chart.x());

    zoomHandler();
  };

  _chart.refocused = function () {
    return _refocused;
  };

  _chart.focusChart = function (c) {
    if (!arguments.length) {
      return _focusChart;
    }
    _focusChart = c;
    _chart.on("filtered", function (chart) {
      /* OVERRIDE ---------------------------------------------------------------- */
      _focusChart.rangeFocused(true);
      /* ------------------------------------------------------------------------- */

      if (!chart.filter()) {
        _events.events.trigger(function () {
          _focusChart.x().domain(_focusChart.xOriginalDomain());
        });
      } else if (!rangesEqual(chart.filter(), _focusChart.filter())) {
        _events.events.trigger(function () {
          _focusChart.focus(chart.filter());
        });
      }

      /* OVERRIDE ---------------------------------------------------------------- */
      _focusChart.rangeFocused(false);
      /* ------------------------------------------------------------------------- */
    });
    return _chart;
  };

  function rangesEqual(range1, range2) {
    if (!range1 && !range2) {
      return true;
    } else if (!range1 || !range2) {
      return false;
    } else if (range1.length === 0 && range2.length === 0) {
      return true;
    } else if (range1[0].valueOf() === range2[0].valueOf() && range1[1].valueOf() === range2[1].valueOf()) {
      return true;
    }
    return false;
  }

  /**
      * Turn on/off the brush-based range filter. When brushing is on then user can drag the mouse
      * across a chart with a quantitative scale to perform range filtering based on the extent of the
      * brush, or click on the bars of an ordinal bar chart or slices of a pie chart to filter and
      * un-filter them. However turning on the brush filter will disable other interactive elements on
      * the chart such as highlighting, tool tips, and reference lines. Zooming will still be possible
      * if enabled, but only via scrolling (panning will be disabled.)
      * @name brushOn
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {Boolean} [brushOn=true]
      * @return {Boolean}
      * @return {dc.coordinateGridMixin}
      */
  _chart.brushOn = function (brushOn) {
    if (!arguments.length) {
      return _brushOn;
    }
    _brushOn = brushOn;
    return _chart;
  };

  function hasRangeSelected(range) {
    return range instanceof Array && range.length > 1;
  }

  _chart.popupTextAccessor = function (arr) {
    return function () {
      var dateFormatter = _chart.dateFormatter();
      var customFormatter = null;
      var value = arr[0].datum.data.key0;
      if (Array.isArray(value) && value[0]) {
        value = typeof value[0].value !== "undefined" ? value[0].value : value[0];
      }

      if (dateFormatter && value instanceof Date) {
        customFormatter = dateFormatter;
      }

      return customFormatter && customFormatter(value) || _utils.utils.formatValue(value);
    };
  };

  _chart.getNumTicksForXAxis = function () {
    var xDomain = _chart.x().domain();
    var timeBinParam = _chart.group().binParams()[DEFAULT_TIME_DIMENSION_INDEX];
    if (timeBinParam && timeBinParam.extract) {
      return xDomain[xDomain.length - 1] - xDomain[0];
    } else {
      var effectiveWidth = _chart.effectiveWidth();
      var numTicks = _chart.xAxis().scale().ticks().length;
      return effectiveWidth / numTicks < MAX_TICK_WIDTH ? Math.ceil(effectiveWidth / MAX_TICK_WIDTH) : DEFAULT_NUM_TICKS;
    }
  };

  _chart.rangeFocused = function (_) {
    if (!arguments.length) {
      return _chart._rangeFocused;
    }
    _chart._rangeFocused = _;

    return _chart;
  };

  _chart.rangeInput = function (_) {
    if (!arguments.length) {
      return _chart._rangeInput;
    }
    _chart._rangeInput = _;

    return _chart;
  };

  _chart.binInput = function (_) {
    if (!arguments.length) {
      return _chart._binInput;
    }
    _chart._binInput = _;

    return _chart;
  };

  /* istanbul ignore next */
  _chart.updateRangeInput = function () {
    var dateFormat = _d2.default.time.format.utc("%b %d, %Y");
    var timeFormat = _d2.default.time.format.utc("%I:%M%p");

    var extent = _chart.filter() || _chart.x().domain();
    var rangeDisplay = _chart.root().selectAll(".range-display");
    var binNumSecs = _chart.binInputOptions().filter(function (d) {
      return _chart.group().binParams()[0].timeBin === d.val;
    })[0].numSeconds;

    rangeDisplay.select(".range-start-day").property("value", dateFormat(extent[0])).attr("value", dateFormat(extent[0]));

    rangeDisplay.select(".range-start-time").classed("disable", binNumSecs > 3600).property("value", timeFormat(extent[0])).attr("value", timeFormat(extent[0]));

    rangeDisplay.select(".range-end-day").property("value", dateFormat(extent[1])).attr("value", dateFormat(extent[1]));

    rangeDisplay.select(".range-end-time").classed("disable", binNumSecs > 3600).property("value", timeFormat(extent[1])).attr("value", timeFormat(extent[1]));
  };

  /* istanbul ignore next */
  function rangeInputOnFocus() {
    this.select();

    var dateInputFormat = _d2.default.time.format.utc("%m-%d-%Y");
    var timeInputFormat = _d2.default.time.format.utc("%I:%M%p");
    var currentInput = _d2.default.select(this);

    var extent = _chart.filter() || _chart.x().domain();
    var index = currentInput.attr("class").indexOf("start") >= 0 ? 0 : 1;

    currentInput.property("value", currentInput.classed("range-day") ? dateInputFormat(extent[index]) : timeInputFormat(extent[index]));
  }

  /* istanbul ignore next */
  function rangeInputChange(input) {
    var thisInput = this || input;
    var currentInput = _d2.default.select(thisInput);
    var currentValue = currentInput.attr("value");
    var newValue = currentInput.property("value");

    var currentExtent = _chart.filter() || _chart.x().domain();

    var binNumSecs = _chart.binInputOptions().filter(function (d) {
      return _chart.group().binParams()[0].timeBin === d.val;
    })[0].numSeconds;

    var inputFormat = binNumSecs > 3600 ? _d2.default.time.format.utc("%m-%d-%Y") : currentInput.attr("class").indexOf("day") >= 0 ? _d2.default.time.format.utc("%m-%d-%Y %I:%M%p") : _d2.default.time.format.utc("%b %d, %Y %I:%M%p");

    var inputStr = binNumSecs > 3600 ? newValue : _d2.default.select(thisInput.parentNode).selectAll(".range-day").property("value") + " " + _d2.default.select(thisInput.parentNode).selectAll(".range-time").property("value");

    var date = inputFormat.parse(inputStr);

    if (!date) {
      currentInput.property("value", currentValue);
      thisInput.blur();
      return;
    }

    var extentChart = _chart.rangeChart() ? _chart.rangeChart() : _chart;

    var extent = extentChart.filter() || extentChart.x().domain();

    var index = currentInput.attr("class").indexOf("start") >= 0 ? 0 : 1;

    var other = index === 0 ? 1 : 0;

    extent[index] = date < extentChart.xAxisMin() ? extentChart.xAxisMin() : date > extentChart.xAxisMax() ? extentChart.xAxisMax() : date;

    if (binNumSecs > 3600) {
      extent[other] = _d2.default.time.day.utc.round(extent[other]);
    }

    extent.sort(function (a, b) {
      return a - b;
    });

    if (extent[0].getTime() === extent[1].getTime()) {
      extent[1] = new Date(extent[1].getTime() + binNumSecs * ONE_SECOND_IN_MS);
    }

    if (_chart._binInput) {
      extent[1] = new Date(extent[1].getTime());
    }

    var domFilter = _filters.filters.RangedFilter(extent[0], extent[1]);

    extentChart.replaceFilter(domFilter);
    extentChart.rescale();
    extentChart.redrawAsync().then(function () {
      if (_chart.rangeChart()) {
        _chart._binSnap = _chart._binInput;
        _chart.focus(domFilter);
        _chart.replaceFilter(domFilter);
      }

      thisInput.blur();
      _chart.updateRangeInput();

      _chart.redrawGroup();
    });
  }

  /* istanbul ignore next */
  _chart.renderYAxisLabel = function (axisClass, text, rotation) {
    var root = _chart.root();

    var yLabel = root.selectAll(".y-axis-label");

    if (yLabel.empty()) {
      yLabel = root.append("div").attr("class", "y-axis-label");
    }

    if (text !== "") {
      var yOffset = _chart.rangeChart() ? _chart.rangeChart().height() - _chart.rangeChart().margins().bottom + _chart.margins().bottom : _chart.margins().bottom;

      yLabel.style("top", (_chart.effectiveHeight() + yOffset) / 2 + _chart.margins().top + "px").text(text);
    }
    _chart.prepareLabelEdit("y");
  };

  /* istanbul ignore next */
  _chart.updateBinInput = function () {
    if (_chart.binInput() && _chart.group().binParams()[0]) {
      var root = _chart.root();

      var binRow = root.selectAll(".bin-row");

      if (binRow.empty()) {
        binRow = root.append("div").attr("class", "bin-row").style("left", _chart.margins().left + "px");
      }

      binRow.html("").append("span").text("BIN:");

      var binRowItems = binRow.selectAll(".bin-row-item").data(_chart.binInputOptions()).enter();

      var rangeInSeconds = Math.abs((_chart.x().domain()[0].getTime() - _chart.x().domain()[1].getTime()) / ONE_SECOND_IN_MS);

      var _chart$group$binParam = _chart.group().binParams()[0],
          auto = _chart$group$binParam.auto,
          timeBin = _chart$group$binParam.timeBin,
          numBins = _chart$group$binParam.numBins;

      var shouldShowTimeBinOption = function shouldShowTimeBinOption(d) {
        return d.numSeconds && rangeInSeconds / d.numSeconds > numBins || d.numSeconds && rangeInSeconds / d.numSeconds < 2;
      };

      binRowItems.append("div").attr("class", "bin-row-item").classed("inactive", function (d) {
        return shouldShowTimeBinOption(d);
      }).classed("active", function (d) {
        if (d.val === "auto" && auto) {
          return true;
        } else if (!auto) {
          return d.val === timeBin;
        }
      }).classed("underline", function (d) {
        return auto && d.val === timeBin;
      }).text(function (d) {
        return d.label;
      }).on("click", function (d) {
        return _chart.changeBinVal(d.val);
      });
    }
  };

  /* istanbul ignore next */
  function bindRangeInputEvents(input) {
    _d2.default.select(input).on("focus", rangeInputOnFocus).on("keydown", function () {
      if (_d2.default.event.keyCode === ENTER_KEY) {
        rangeInputChange(this);
      }
    });
  }

  _chart = (0, _binningMixin2.default)(_chart);

  return _chart;
}

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = marginMixin;
/**
 * Margin is a mixin that provides margin utility functions for both the Row Chart and Coordinate Grid
 * Charts.
 * @name marginMixin
 * @memberof dc
 * @mixin
 * @param {Object} _chart
 * @return {dc.marginMixin}
 */
function marginMixin(_chart) {
  /* OVERRIDE ---------------------------------------------------------------- */
  var _margin = { top: 10, right: 50, bottom: 48, left: 60
    /* ------------------------------------------------------------------------- */

    /**
     * Get or set the margins for a particular coordinate grid chart instance. The margins is stored as
     * an associative Javascript array.
     * @name margins
     * @memberof dc.marginMixin
     * @instance
     * @example
     * var leftMargin = chart.margins().left; // 30 by default
     * chart.margins().left = 50;
     * leftMargin = chart.margins().left; // now 50
     * @param {{top: Number, right: Number, left: Number, bottom: Number}} [margins={top: 10, right: 50, bottom: 30, left: 30}]
     * @return {{top: Number, right: Number, left: Number, bottom: Number}}
     * @return {dc.marginMixin}
     */
  };_chart.margins = function (margins) {
    if (!arguments.length) {
      return _margin;
    }
    _margin = margins;
    return _chart;
  };

  _chart.effectiveWidth = function () {
    return _chart.width() - _chart.margins().left - _chart.margins().right;
  };

  _chart.effectiveHeight = function () {
    return _chart.height() - _chart.margins().top - _chart.margins().bottom;
  };

  return _chart;
}

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.filters = undefined;

var _formattingHelpers = __webpack_require__(6);

/**
 * The dc.js filters are functions which are passed into crossfilter to chose which records will be
 * accumulated to produce values for the charts.  In the crossfilter model, any filters applied on one
 * dimension will affect all the other dimensions but not that one.  dc always applies a filter
 * function to the dimension; the function combines multiple filters and if any of them accept a
 * record, it is filtered in.
 *
 * These filter constructors are used as appropriate by the various charts to implement brushing.  We
 * mention below which chart uses which filter.  In some cases, many instances of a filter will be added.
 *
 * Each of the dc.js filters is an object with the following properties:
 * * `isFiltered` - a function that returns true if a value is within the filter
 * * `filterType` - a string identifying the filter, here the name of the constructor
 *
 * Currently these filter objects are also arrays, but this is not a requirement. Custom filters
 * can be used as long as they have the properties above.
 * @name filters
 * @memberof dc
 * @type {{}}
 */
var filters = exports.filters = {};

/**
 * RangedFilter is a filter which accepts keys between `low` and `high`.  It is used to implement X
 * axis brushing for the {@link #dc.coordinateGridMixin coordinate grid charts}.
 *
 * Its `filterType` is 'RangedFilter'
 * @name RangedFilter
 * @memberof dc.filters
 * @param {Number} low
 * @param {Number} high
 * @return {Array<Number>}
 * @constructor
 */
filters.RangedFilter = function (low, high) {
  var range = new Array(low, high);
  range.isFiltered = function (value) {
    return value >= this[0] && value <= this[1];
  };
  range.filterType = "RangedFilter";

  return range;
};

/**
 * TwoDimensionalFilter is a filter which accepts a single two-dimensional value.  It is used by the
 * {@link #dc.heatMap heat map chart} to include particular cells as they are clicked.  (Rows and columns are
 * filtered by filtering all the cells in the row or column.)
 *
 * Its `filterType` is 'TwoDimensionalFilter'
 * @name TwoDimensionalFilter
 * @memberof filters
 * @param {Array<Number>} filter
 * @return {Array<Number>}
 * @constructor
 */
filters.TwoDimensionalFilter = function () {
  var filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  if (filter === null) {
    return null;
  }
  if (filter === Symbol.for("clear")) {
    return filter;
  }

  var f = (0, _formattingHelpers.normalizeFiltersArray)(filter);
  f.isFiltered = function (value) {
    return value.length && value.length === f.length && value[0] === f[0] && value[1] === f[1];
  };
  f.filterType = "TwoDimensionalFilter";

  return f;
};

/**
 * The RangedTwoDimensionalFilter allows filtering all values which fit within a rectangular
 * region. It is used by the {@link #dc.scatterPlot scatter plot} to implement rectangular brushing.
 *
 * It takes two two-dimensional points in the form `[[x1,y1],[x2,y2]]`, and normalizes them so that
 * `x1 <= x2` and `y1 <- y2`. It then returns a filter which accepts any points which are in the
 * rectangular range including the lower values but excluding the higher values.
 *
 * If an array of two values are given to the RangedTwoDimensionalFilter, it interprets the values as
 * two x coordinates `x1` and `x2` and returns a filter which accepts any points for which `x1 <= x <
 * x2`.
 *
 * Its `filterType` is 'RangedTwoDimensionalFilter'
 * @name RangedTwoDimensionalFilter
 * @memberof filters
 * @param {Array<Array<Number>>} filter
 * @return {Array<Array<Number>>}
 * @constructor
 */
filters.RangedTwoDimensionalFilter = function (filter) {
  if (filter === null) {
    return null;
  }
  if (filter === Symbol.for("clear")) {
    return filter;
  }

  var f = filter;
  var fromBottomLeft = void 0;

  if (f[0] instanceof Array) {
    fromBottomLeft = [[Math.min(filter[0][0], filter[1][0]), Math.min(filter[0][1], filter[1][1])], [Math.max(filter[0][0], filter[1][0]), Math.max(filter[0][1], filter[1][1])]];
  } else {
    fromBottomLeft = [[filter[0], -Infinity], [filter[1], Infinity]];
  }

  f.isFiltered = function (value) {
    var x = void 0,
        y = void 0;

    if (value instanceof Array) {
      if (value.length !== 2) {
        return false;
      }
      x = value[0];
      y = value[1];
    } else {
      x = value;
      y = fromBottomLeft[0][1];
    }

    return x >= fromBottomLeft[0][0] && x < fromBottomLeft[1][0] && y >= fromBottomLeft[0][1] && y < fromBottomLeft[1][1];
  };
  f.filterType = "RangedTwoDimensionalFilter";

  return f;
};

/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__formatDecimal__ = __webpack_require__(23);


/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return x = Object(__WEBPACK_IMPORTED_MODULE_0__formatDecimal__["a" /* default */])(Math.abs(x)), x ? x[1] : NaN;
});


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.notNull = notNull;
exports.adjustOpacity = adjustOpacity;
exports.adjustRGBAOpacity = adjustRGBAOpacity;
exports.createVegaAttrMixin = createVegaAttrMixin;
exports.createRasterLayerGetterSetter = createRasterLayerGetterSetter;

var _d2 = __webpack_require__(1);

var _d3 = _interopRequireDefault(_d2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function notNull(value) {
  return value != null; /* double-equals also catches undefined */
}

function adjustOpacity(color) {
  var opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

  if (!/#/.test(color)) {
    return color;
  }
  var hex = color.replace("#", "");
  var r = parseInt(hex.substring(0, 2), 16);
  var g = parseInt(hex.substring(2, 4), 16);
  var b = parseInt(hex.substring(4, 6), 16);
  return "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
}

function adjustRGBAOpacity(rgba, opacity) {
  var _rgba$split$1$split$ = rgba.split("(")[1].split(")")[0].split(","),
      _rgba$split$1$split$2 = _slicedToArray(_rgba$split$1$split$, 4),
      r = _rgba$split$1$split$2[0],
      g = _rgba$split$1$split$2[1],
      b = _rgba$split$1$split$2[2],
      a = _rgba$split$1$split$2[3];

  if (a) {
    var relativeOpacity = parseFloat(a) - (1 - opacity);
    a = "" + (relativeOpacity > 0 ? relativeOpacity : 0.01);
  } else {
    a = opacity;
  }
  return "rgba(" + r + "," + g + "," + b + "," + a + ")";
}

var ordScale = _d3.default.scale.ordinal();
var quantScale = _d3.default.scale.quantize();

var capAttrMap = {
  FillColor: "color",
  Size: "size"
};

function createVegaAttrMixin(layerObj, attrName, defaultVal, nullVal, useScale, prePostFuncs) {
  var scaleFunc = "",
      fieldAttrFunc = "";
  var capAttrName = attrName.charAt(0).toUpperCase() + attrName.slice(1);
  var defaultFunc = "default" + capAttrName;
  var nullFunc = "null" + capAttrName;
  layerObj[defaultFunc] = createRasterLayerGetterSetter(layerObj, defaultVal, prePostFuncs ? prePostFuncs.preDefault : null, prePostFuncs ? prePostFuncs.postDefault : null);
  layerObj[nullFunc] = createRasterLayerGetterSetter(layerObj, nullVal, prePostFuncs ? prePostFuncs.preNull : null, prePostFuncs ? prePostFuncs.postNull : null);

  if (useScale) {
    scaleFunc = attrName + "Scale";
    fieldAttrFunc = attrName + "Attr";
    layerObj[scaleFunc] = createRasterLayerGetterSetter(layerObj, null, prePostFuncs ? prePostFuncs.preScale : null, prePostFuncs ? prePostFuncs.postScale : null);
    layerObj[fieldAttrFunc] = createRasterLayerGetterSetter(layerObj, null, prePostFuncs ? prePostFuncs.preField : null, prePostFuncs ? prePostFuncs.postField : null);

    layerObj["_build" + capAttrName + "Scale"] = function (chart, layerName) {
      var scale = layerObj[scaleFunc]();
      if (scale && scale.domain && scale.domain().length && scale.range().length && scaleFunc === "fillColorScale") {
        var colorScaleName = layerName + "_" + attrName;
        var rtnObj = {
          name: colorScaleName,
          type: chart._determineScaleType(scale),
          domain: scale.domain().filter(notNull),
          range: scale.range(),
          default: layerObj[defaultFunc](),
          nullValue: layerObj[nullFunc]()
        };

        if (scale.clamp) {
          rtnObj.clamp = scale.clamp();
        }

        return rtnObj;
      } else if (layerObj.densityAccumulatorEnabled()) {
        var _colorScaleName = layerName + "_" + attrName,
            colorsToUse = layerObj.defaultFillColor(),
            domainInterval = 100 / (colorsToUse.length - 1),
            linearScale = colorsToUse.map(function (color, i) {
          return i * domainInterval / 100;
        }),
            range = colorsToUse.map(function (color, i, colorArray) {
          var normVal = i / (colorArray.length - 1);
          var interp = Math.min(normVal / 0.65, 1.0);
          interp = interp * 0.375 + 0.625;
          return convertHexToRGBA(color, interp * 100);
        });

        var _rtnObj = {
          name: _colorScaleName,
          type: "linear",
          domain: linearScale,
          range: range,
          accumulator: "density",
          minDensityCnt: "-2ndStdDev",
          maxDensityCnt: "2ndStdDev",
          clamp: true
        };

        return _rtnObj;
      }
    };
  }

  var getValFunc = "get" + capAttrName + "Val";
  layerObj[getValFunc] = function (input) {
    var rtnVal = layerObj[defaultFunc]();
    if (input === null) {
      rtnVal = layerObj[nullFunc]();
    } else if (input !== undefined && useScale) {
      var capAttrObj = layerObj.getState().encoding[capAttrMap[capAttrName]];
      if (capAttrObj && capAttrObj.domain && capAttrObj.domain.length && capAttrObj.range.length) {
        if (capAttrObj.type === "ordinal") {
          ordScale.domain(capAttrObj.domain).range(capAttrObj.range);
          rtnVal = ordScale(input);
        } else {
          quantScale.domain(capAttrObj.domain).range(capAttrObj.range);
          rtnVal = quantScale(input);
        }
      }
    }

    return rtnVal;
  };
}

function createRasterLayerGetterSetter(layerObj, attrVal, preSetFunc, postSetFunc) {
  return function (newVal) {
    if (!arguments.length) {
      return attrVal;
    }
    if (preSetFunc) {
      var rtnVal = preSetFunc(newVal, attrVal);
      if (rtnVal !== undefined) {
        newVal = rtnVal;
      }
    }
    attrVal = newVal;
    if (postSetFunc) {
      var rtnVal = postSetFunc(attrVal);
      if (rtnVal !== undefined) {
        attrVal = rtnVal;
      }
    }
    return layerObj;
  };
}

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var logger = exports.logger = {};

logger.enableDebugLog = false;

/* istanbul ignore next */
logger.warn = function (msg) {
  if (console) {
    if (console.warn) {
      console.warn(msg);
    } else if (console.log) {
      console.log(msg);
    }
  }

  return logger;
};

/* istanbul ignore next */
logger.debug = function (msg) {
  if (logger.enableDebugLog && console) {
    if (console.debug) {
      console.debug(msg);
    } else if (console.log) {
      console.log(msg);
    }
  }

  return logger;
};

/* istanbul ignore next */
logger.deprecate = function (fn, msg) {
  // Allow logging of deprecation
  var warned = false;
  function deprecated() {
    if (!warned) {
      logger.warn(msg);
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.autoBinParams = autoBinParams;
exports.checkIfTimeBinInRange = checkIfTimeBinInRange;
var SEC = 1;
var MIN_IN_SECS = 60;
var HOUR_IN_SECS = 3600;
var DAY_IN_SECS = 86400;
var WEEK_IN_SECS = 604800;
var MONTH_IN_SECS = 2592000;
var QUARTER_IN_SECS = 10368000;
var YEAR_IN_SECS = 31536000;
var DECADE_IN_SECS = 315360000;

var DEFAULT_EXTRACT_INTERVAL = exports.DEFAULT_EXTRACT_INTERVAL = "isodow";

var TIME_LABELS = ["second", "minute", "hour", "day", "week", "month", "quarter", "year", "decade"];

var TIME_LABEL_TO_SECS = exports.TIME_LABEL_TO_SECS = {
  second: SEC,
  minute: MIN_IN_SECS,
  hour: HOUR_IN_SECS,
  day: DAY_IN_SECS,
  week: WEEK_IN_SECS,
  month: MONTH_IN_SECS,
  quarter: QUARTER_IN_SECS,
  year: YEAR_IN_SECS,
  decade: DECADE_IN_SECS
};

var TIME_SPANS = exports.TIME_SPANS = TIME_LABELS.map(function (label) {
  return {
    label: label,
    numSeconds: TIME_LABEL_TO_SECS[label]
  };
});

var BIN_INPUT_OPTIONS = exports.BIN_INPUT_OPTIONS = [{ val: "auto", label: "auto", numSeconds: null }, { val: "century", label: "1c", numSeconds: 3153600000 }, { val: "decade", label: "10y", numSeconds: 315360000 }, { val: "year", label: "1y", numSeconds: 31536000 }, { val: "quarter", label: "1q", numSeconds: 10368000 }, { val: "month", label: "1mo", numSeconds: 2592000 }, { val: "week", label: "1w", numSeconds: 604800 }, { val: "day", label: "1d", numSeconds: 86400 }, { val: "hour", label: "1h", numSeconds: 3600 }, { val: "minute", label: "1m", numSeconds: 60 }, { val: "second", label: "1s", numSeconds: 1 }];

function autoBinParams(timeBounds, maxNumBins, reverse) {
  var epochTimeBounds = [timeBounds[0] * 0.001, timeBounds[1] * 0.001];
  var timeRange = epochTimeBounds[1] - epochTimeBounds[0]; // in seconds
  var timeSpans = reverse ? TIME_SPANS.slice().reverse() : TIME_SPANS;
  for (var s = 0; s < timeSpans.length; s++) {
    if (timeRange / timeSpans[s].numSeconds < maxNumBins && timeRange / timeSpans[s].numSeconds > 2) {
      return timeSpans[s].label;
    }
  }
  return "century"; // default;
}

function checkIfTimeBinInRange(timeBounds, timeBin, maxNumBins) {
  var epochTimeBounds = [timeBounds[0] * 0.001, timeBounds[1] * 0.001];
  var timeRange = epochTimeBounds[1] - epochTimeBounds[0]; // in seconds
  var timeLabelToSecs = TIME_LABEL_TO_SECS;
  if (timeRange / timeLabelToSecs[timeBin] > maxNumBins) {
    return autoBinParams(timeBounds, maxNumBins);
  } else if (timeRange / timeLabelToSecs[timeBin] < 2) {
    return autoBinParams(timeBounds, maxNumBins, true);
  } else {
    return timeBin;
  }
}

var createBinParams = exports.createBinParams = function createBinParams(chart, binParams) {
  if (!chart.group() || !chart.group().binParams) {
    return;
  }

  binParams = Array.isArray(binParams) ? binParams : [binParams];

  var parsedBinParams = binParams.map(function (param) {
    if (param) {
      var _param$timeBin = param.timeBin,
          timeBin = _param$timeBin === undefined ? "auto" : _param$timeBin,
          binBounds = param.binBounds,
          numBins = param.numBins;

      var extract = param.extract || false;
      var isDate = binBounds[0] instanceof Date;
      if (isDate && timeBin === "auto") {
        var bounds = binBounds.map(function (date) {
          return date.getTime();
        });
        return Object.assign({}, param, {
          extract: extract,
          timeBin: extract ? DEFAULT_EXTRACT_INTERVAL : autoBinParams(bounds, numBins),
          binBounds: binBounds.slice(),
          auto: true // hightlights the "auto" UI button
        });
      } else {
        return Object.assign({}, param, {
          extract: extract,
          timeBin: timeBin,
          binBounds: binBounds.slice()
        });
      }
    }
    return param;
  });

  chart.group().binParams(parsedBinParams);
  return chart;
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = bubbleMixin;

var _colorMixin = __webpack_require__(7);

var _colorMixin2 = _interopRequireDefault(_colorMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _core = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This Mixin provides reusable functionalities for any chart that needs to visualize data using bubbles.
 * @name bubbleMixin
 * @memberof dc
 * @mixin
 * @mixes dc.colorMixin
 * @param {Object} _chart
 * @return {dc.bubbleMixin}
 */
function bubbleMixin(_chart) {
  var _maxBubbleRelativeSize = 0.3;

  /* OVERRIDE ---------------------------------------------------------------- */
  var _minRadiusWithLabel = 2;
  /* ------------------------------------------------------------------------- */

  _chart.BUBBLE_NODE_CLASS = "node";
  _chart.BUBBLE_CLASS = "bubble";
  _chart.MIN_RADIUS = 10;

  /* OVERRIDE ---------------------------------------------------------------- */
  _chart.accent = accentBubble;
  _chart.unAccent = unAccentBubble;
  /* ------------------------------------------------------------------------- */

  _chart = (0, _colorMixin2.default)(_chart);

  _chart.renderLabel(true);

  /* OVERRIDE ---------------------------------------------------------------- */
  _chart.setDataAsync(function (group, callbacks) {
    if (_chart.cap() !== undefined) {
      return group.topAsync(_chart.cap()).then(function (result) {
        callbacks(null, result);
      }).catch(function (error) {
        callbacks(error);
      });
    } else {
      group.allAsync(callbacks);
    }
  });
  /* ------------------------------------------------------------------------- */

  _chart.data(function (group) {
    /* OVERRIDE ---------------------------------------------------------------- */
    if (_chart.dataCache !== null) {
      return _chart.dataCache;
    } else {
      return group.top(_chart.cap() !== undefined ? _chart.cap() : Infinity);
    }
    /* ------------------------------------------------------------------------- */
  });

  var _r = _d2.default.scale.linear().domain([0, 100]);

  var _rValueAccessor = function _rValueAccessor(d) {
    return d.r;
  };

  /**
   * Get or set the bubble radius scale. By default the bubble chart uses
   * {@link https://github.com/mbostock/d3/wiki/Quantitative-Scales#linear d3.scale.linear().domain([0, 100])}
   * as its radius scale.
   * @name r
   * @memberof dc.bubbleMixin
   * @instance
   * @see {@link http://github.com/mbostock/d3/wiki/Scales d3.scale}
   * @param {d3.scale} [bubbleRadiusScale=d3.scale.linear().domain([0, 100])]
   * @return {d3.scale}
   * @return {dc.bubbleMixin}
   */
  _chart.r = function (bubbleRadiusScale) {
    if (!arguments.length) {
      return _r;
    }
    _r = bubbleRadiusScale;
    return _chart;
  };

  /**
   * Get or set the radius value accessor function. If set, the radius value accessor function will
   * be used to retrieve a data value for each bubble. The data retrieved then will be mapped using
   * the r scale to the actual bubble radius. This allows you to encode a data dimension using bubble
   * size.
   * @name radiusValueAccessor
   * @memberof dc.bubbleMixin
   * @instance
   * @param {Function} [radiusValueAccessor]
   * @return {Function}
   * @return {dc.bubbleMixin}
   */
  _chart.radiusValueAccessor = function (radiusValueAccessor) {
    if (!arguments.length) {
      return _rValueAccessor;
    }
    _rValueAccessor = radiusValueAccessor;
    return _chart;
  };

  _chart.rMin = function () {
    var min = _d2.default.min(_chart.data(), function (e) {
      return _chart.radiusValueAccessor()(e);
    });
    return min;
  };

  _chart.rMax = function () {
    var max = _d2.default.max(_chart.data(), function (e) {
      return _chart.radiusValueAccessor()(e);
    });
    return max;
  };

  _chart.bubbleR = function (d) {
    var value = _chart.radiusValueAccessor()(d);
    var r = _chart.r()(value);
    if (isNaN(r) || value <= 0) {
      r = 0;
    }
    return r;
  };

  var labelFunction = function labelFunction(d) {
    return _chart.label()(d);
  };

  var shouldLabel = function shouldLabel(d) {
    return _chart.bubbleR(d) > _minRadiusWithLabel;
  };

  var labelOpacity = function labelOpacity(d) {
    return shouldLabel(d) ? 1 : 0;
  };

  var labelPointerEvent = function labelPointerEvent(d) {
    return shouldLabel(d) ? "all" : "none";
  };

  _chart._doRenderLabel = function (bubbleGEnter) {
    if (_chart.renderLabel()) {
      var label = bubbleGEnter.select("text");

      if (label.empty()) {
        label = bubbleGEnter.append("text").attr("text-anchor", "middle").attr("dy", ".3em").on("click", _chart.onClick);
      }

      label.attr("opacity", 0).attr("pointer-events", labelPointerEvent).html(labelFunction);

      (0, _core.transition)(label, _chart.transitionDuration()).attr("opacity", 1);

      _chart.hideOverlappedLabels();
    }
  };

  _chart.doUpdateLabels = function (bubbleGEnter) {
    _chart._doRenderLabel(bubbleGEnter);
  };

  var titleFunction = function titleFunction(d) {
    return _chart.title()(d);
  };

  _chart._doRenderTitles = function (g) {
    if (_chart.renderTitle()) {
      var title = g.select("title");

      if (title.empty()) {
        g.append("title").text(titleFunction);
      }
    }
  };

  _chart.doUpdateTitles = function (g) {
    if (_chart.renderTitle()) {
      g.selectAll("title").text(titleFunction);
    }
  };

  /**
   * Get or set the minimum radius. This will be used to initialize the radius scale's range.
   * @name minRadius
   * @memberof dc.bubbleMixin
   * @instance
   * @param {Number} [radius=10]
   * @return {Number}
   * @return {dc.bubbleMixin}
   */
  _chart.minRadius = function (radius) {
    if (!arguments.length) {
      return _chart.MIN_RADIUS;
    }
    _chart.MIN_RADIUS = radius;
    return _chart;
  };

  /**
   * Get or set the minimum radius for label rendering. If a bubble's radius is less than this value
   * then no label will be rendered.
   * @name minRadiusWithLabel
   * @memberof dc.bubbleMixin
   * @instance
   * @param {Number} [radius=10]
   * @return {Number}
   * @return {dc.bubbleMixin}
   */

  _chart.minRadiusWithLabel = function (radius) {
    if (!arguments.length) {
      return _minRadiusWithLabel;
    }
    _minRadiusWithLabel = radius;
    return _chart;
  };

  /**
   * Get or set the maximum relative size of a bubble to the length of x axis. This value is useful
   * when the difference in radius between bubbles is too great.
   * @name maxBubbleRelativeSize
   * @memberof dc.bubbleMixin
   * @instance
   * @param {Number} [relativeSize=0.3]
   * @return {Number}
   * @return {dc.bubbleMixin}
   */
  _chart.maxBubbleRelativeSize = function (relativeSize) {
    if (!arguments.length) {
      return _maxBubbleRelativeSize;
    }
    _maxBubbleRelativeSize = relativeSize;
    return _chart;
  };

  _chart.fadeDeselectedArea = function () {
    if (_chart.hasFilter()) {
      _chart.selectAll("g." + _chart.BUBBLE_NODE_CLASS).each(function (d) {
        if (_chart.isSelectedNode(d)) {
          _chart.highlightSelected(this);
        } else {
          _chart.fadeDeselected(this);
        }
      });
    } else {
      _chart.selectAll("g." + _chart.BUBBLE_NODE_CLASS).each(function () {
        _chart.resetHighlight(this);
      });
    }
  };

  _chart.isSelectedNode = function (d) {
    /* OVERRIDE -----------------------------------------------------------------*/
    return _chart.hasFilter(d.key0) ^ _chart.filtersInverse();
    /* --------------------------------------------------------------------------*/
  };

  _chart.onClick = function (d) {
    /* OVERRIDE -----------------------------------------------------------------*/
    var filter = d.key0;
    /* --------------------------------------------------------------------------*/
    _chart.handleFilterClick(_d2.default.event, filter);
    _chart.updatePopup(d);
  };

  /* OVERRIDE -----------------------------------------------------------------*/
  function accentBubble(label) {
    _chart.selectAll("g." + _chart.BUBBLE_NODE_CLASS).each(function (d) {
      if (d.key0 === label) {
        _chart.accentSelected(this);
      }
    });
  }

  function unAccentBubble(label) {
    _chart.selectAll("g." + _chart.BUBBLE_NODE_CLASS).each(function (d) {
      if (d.key0 === label) {
        _chart.unAccentSelected(this);
      }
    });
  }
  /* --------------------------------------------------------------------------*/

  return _chart;
}

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = stackMixin;

var _binningHelpers = __webpack_require__(17);

var _utils = __webpack_require__(3);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _core = __webpack_require__(2);

var _multipleKeyAccessors = __webpack_require__(131);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Stack Mixin is an mixin that provides cross-chart support of stackability using d3.layout.stack.
 * @name stackMixin
 * @memberof dc
 * @mixin
 * @param {Object} _chart
 * @return {dc.stackMixin}
 */

function stackMixin(_chart) {
  function prepareValues(layer, layerIdx) {
    var valAccessor = layer.accessor || _chart.valueAccessor();
    layer.name = String(layer.name || "series_" + (layerIdx + 1));
    layer.layer = layer.name;
    layer.idx = layerIdx;

    /* OVERRIDE ---------------------------------------------------------------- */
    // WARNING: probably destroys stack functionality: find workaround
    var preValues = _chart.dataCache != null ? _chart.dataCache : layer.group.all();
    // layer.values = layer.group.all().map(function (d, i) {
    layer.values = preValues.map(function (d, i) {
      return {
        x: _chart.keyAccessor()(d, i),
        y: layer.hidden ? null : valAccessor(d, i) || 0,
        idx: layerIdx,
        data: d,
        layer: layer.name,
        hidden: layer.hidden
      };
    });
    /* ------------------------------------------------------------------------- */
    layer.values = layer.values.filter(domainFilter());
    return layer.values;
  }

  var _stackLayout = _d2.default.layout.stack().values(prepareValues);

  var _stack = [];
  var _titles = {};

  var _hidableStacks = false;
  var _colorByLayerId = false;

  function domainFilter() {
    if (!_chart.x()) {
      return _d2.default.functor(true);
    }
    var xDomain = _chart.x().domain();
    if (_chart.isOrdinal()) {
      // TODO #416
      // var domainSet = d3.set(xDomain);
      return function () {
        return true; // domainSet.has(p.x);
      };
    }
    if (_chart.elasticX()) {
      return function () {
        return true;
      };
    }
    return function (p) {
      return true;
    };
  }

  /**
   * Stack a new crossfilter group onto this chart with an optional custom value accessor. All stacks
   * in the same chart will share the same key accessor and therefore the same set of keys.
   *
   * For example, in a stacked bar chart, the bars of each stack will be positioned using the same set
   * of keys on the x axis, while stacked vertically. If name is specified then it will be used to
   * generate the legend label.
   * @name stack
   * @memberof dc.stackMixin
   * @instance
   * @see {@link https://github.com/square/crossfilter/wiki/API-Reference#group-map-reduce crossfilter.group}
   * @example
   * // stack group using default accessor
   * chart.stack(valueSumGroup)
   * // stack group using custom accessor
   * .stack(avgByDayGroup, function(d){return d.value.avgByDay;});
   * @param {crossfilter.group} group
   * @param {String} [name]
   * @param {Function} [accessor]
   * @return {Array<{group: crossfilter.group, name: String, accessor: Function}>}
   * @return {dc.stackMixin}
   */
  _chart.stack = function (group, name, accessor) {
    if (!arguments.length) {
      return _stack;
    }

    if (arguments.length <= 2) {
      accessor = name;
    }

    var layer = { group: group };
    if (typeof name === "string") {
      layer.name = name;
    }
    if (typeof accessor === "function") {
      layer.accessor = accessor;
    }
    _stack.push(layer);

    return _chart;
  };

  (0, _core.override)(_chart, "group", function (g, n, f) {
    if (!arguments.length) {
      return _chart._group();
    }
    _stack = [];
    _titles = {};
    _chart.stack(g, n);
    if (f) {
      _chart.valueAccessor(f);
    }
    return _chart._group(g, n);
  });

  /**
   * Allow named stacks to be hidden or shown by clicking on legend items.
   * This does not affect the behavior of hideStack or showStack.
   * @name hidableStacks
   * @memberof dc.stackMixin
   * @instance
   * @param {Boolean} [hidableStacks=false]
   * @return {Boolean}
   * @return {dc.stackMixin}
   */
  _chart.hidableStacks = function (hidableStacks) {
    if (!arguments.length) {
      return _hidableStacks;
    }
    _hidableStacks = hidableStacks;
    return _chart;
  };

  function findLayerByName(n) {
    var i = _stack.map((0, _utils.pluck)("name")).indexOf(n);
    return _stack[i];
  }

  /**
   * Hide all stacks on the chart with the given name.
   * The chart must be re-rendered for this change to appear.
   * @name hideStack
   * @memberof dc.stackMixin
   * @instance
   * @param {String} stackName
   * @return {dc.stackMixin}
   */
  _chart.hideStack = function (stackName) {
    var layer = findLayerByName(stackName);
    if (layer) {
      layer.hidden = true;
    }
    return _chart;
  };

  /**
   * Show all stacks on the chart with the given name.
   * The chart must be re-rendered for this change to appear.
   * @name showStack
   * @memberof dc.stackMixin
   * @instance
   * @param {String} stackName
   * @return {dc.stackMixin}
   */
  _chart.showStack = function (stackName) {
    var layer = findLayerByName(stackName);
    if (layer) {
      layer.hidden = false;
    }
    return _chart;
  };

  _chart.getValueAccessorByIndex = function (index) {
    return _stack[index].accessor || _chart.valueAccessor();
  };

  _chart.yAxisMin = function () {
    var min = _d2.default.min(flattenStack(), function (p) {
      /* OVERRIDE ---------------------------------------------------------------- */
      if (_chart.renderArea === undefined || _chart.renderArea()) {
        return p.y + p.y0 < p.y0 ? p.y + p.y0 : p.y0;
      } else {
        return p.y;
      }
    });
    /* ------------------------------------------------------------------------- */

    return _utils.utils.subtract(min, _chart.yAxisPadding());
  };

  _chart.yAxisMax = function () {
    var max = _d2.default.max(flattenStack(), function (p) {
      /* OVERRIDE ---------------------------------------------------------------- */
      if (_chart.renderArea === undefined || _chart.renderArea()) {
        return p.y + p.y0;
      } else {
        return p.y;
      }
      /* ------------------------------------------------------------------------- */
    });

    return _utils.utils.add(max, _chart.yAxisPadding());
  };

  function flattenStack() {
    var valueses = _chart.data().map(function (layer) {
      return layer.values;
    });
    return Array.prototype.concat.apply([], valueses);
  }

  _chart.xAxisMin = function () {
    var min = _d2.default.min(flattenStack(), (0, _utils.pluck)("x"));
    return _utils.utils.subtract(min, _chart.xAxisPadding());
  };

  _chart.xAxisMax = function () {
    var max = _d2.default.max(flattenStack(), (0, _utils.pluck)("x"));
    return _utils.utils.add(max, _chart.xAxisPadding());
  };

  /**
   * Set or get the title function. Chart class will use this function to render svg title (usually interpreted by
   * browser as tooltips) for each child element in the chart, i.e. a slice in a pie chart or a bubble in a bubble chart.
   * Almost every chart supports title function however in grid coordinate chart you need to turn off brush in order to
   * use title otherwise the brush layer will block tooltip trigger.
   *
   * If the first argument is a stack name, the title function will get or set the title for that stack. If stackName
   * is not provided, the first stack is implied.
   * @name title
   * @memberof dc.stackMixin
   * @instance
   * @example
   * // set a title function on 'first stack'
   * chart.title('first stack', function(d) { return d.key + ': ' + d.value; });
   * // get a title function from 'second stack'
   * var secondTitleFunction = chart.title('second stack');
   * @param {String} [stackName]
   * @param {Function} [titleAccessor]
   * @return {String}
   * @return {dc.stackMixin}
   */
  (0, _core.override)(_chart, "title", function (stackName, titleAccessor) {
    if (!stackName) {
      return _chart._title();
    }

    if (typeof stackName === "function") {
      return _chart._title(stackName);
    }
    if (stackName === _chart._groupName && typeof titleAccessor === "function") {
      return _chart._title(titleAccessor);
    }

    if (typeof titleAccessor !== "function") {
      return _titles[stackName] || _chart._title();
    }

    _titles[stackName] = titleAccessor;

    return _chart;
  });

  /**
   * Gets or sets the stack layout algorithm, which computes a baseline for each stack and
   * propagates it to the next
   * @name stackLayout
   * @memberof dc.stackMixin
   * @instance
   * @see {@link http://github.com/mbostock/d3/wiki/Stack-Layout d3.layout.stack}
   * @param {Function} [stack=d3.layout.stack]
   * @return {Function}
   * @return {dc.stackMixin}
   */
  _chart.stackLayout = function (stack) {
    if (!arguments.length) {
      return _stackLayout;
    }
    _stackLayout = stack;
    return _chart;
  };

  function visability(l) {
    return !l.hidden;
  }

  _chart.data(function () {
    var layers = _stack.filter(visability);
    return layers.length ? _chart.stackLayout()(layers) : [];
  });

  _chart._ordinalXDomain = function () {
    var flat = flattenStack().map((0, _utils.pluck)("data"));
    var ordered = _chart._computeOrderedGroups(flat);
    return ordered.map(_chart.keyAccessor());
  };

  _chart.colorByLayerId = function (_) {
    if (!arguments.length) {
      return _colorByLayerId;
    }
    _colorByLayerId = _;
    return _chart;
  };

  _chart.colorAccessor(function (d) {
    /* OVERRIDE ---------------------------------------------------------------- */
    var layer = null;
    if (_colorByLayerId) {
      layer = this.idx;
    } else {
      layer = this.layer || this.name || d.name || d.layer;
    }
    /* ------------------------------------------------------------------------- */
    return layer;
  });

  _chart.legendables = function () {
    return _stack.map(function (layer, i) {
      return {
        chart: _chart,
        name: layer.name,
        hidden: layer.hidden || false,
        color: _chart.getColor.call(layer, layer.values, i)
      };
    });
  };

  _chart.isLegendableHidden = function (d) {
    var layer = findLayerByName(d.name);
    return layer ? layer.hidden : false;
  };

  _chart.legendToggle = function (d) {
    if (_hidableStacks) {
      if (_chart.isLegendableHidden(d)) {
        _chart.showStack(d.name);
      } else {
        _chart.hideStack(d.name);
      }
      _chart.renderGroup();
    }
  };

  (0, _core.override)(_chart, "binParams", function (binParams) {
    if (!arguments.length) {
      return _chart.group().binParams();
    }

    binParams = Array.isArray(binParams) ? binParams : [binParams];

    var parsedBinParams = binParams.map(function (param) {
      if (param) {
        var _param$timeBin = param.timeBin,
            timeBin = _param$timeBin === undefined ? "auto" : _param$timeBin,
            binBounds = param.binBounds,
            numBins = param.numBins,
            auto = param.auto;

        var extract = param.extract || false;
        var isDate = binBounds[0] instanceof Date;
        if (isDate && timeBin && !extract) {
          var bounds = binBounds.map(function (date) {
            return date.getTime();
          });
          return Object.assign({}, param, {
            extract: extract,
            timeBin: (0, _binningHelpers.checkIfTimeBinInRange)(bounds, timeBin, numBins),
            binBounds: binBounds.slice()
          });
        } else {
          return param;
        }
      }
      return null;
    });

    return (0, _binningHelpers.createBinParams)(_chart, parsedBinParams);
  });

  _chart.keyAccessor(_multipleKeyAccessors.multipleKeysAccessorForStack);

  return _chart;
}

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = mapMixin;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _coreAsync = __webpack_require__(4);

var _utils = __webpack_require__(3);

var _mapDrawMixin = __webpack_require__(191);

var _rasterDrawMixin = __webpack_require__(21);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function valuesOb(obj) {
  return Object.keys(obj).map(function (key) {
    return obj[key];
  });
}

function mapMixin(_chart, chartDivId, _mapboxgl) {
  var mixinDraw = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  var DEFAULT_ZOOM_LEVEL = 15;
  var EASE_DURATION_MS = 1500;
  var SMALL_AMOUNT = 0.00001; // Mapbox doesn't like coords being exactly on the edge.
  var LONMAX = 180 - SMALL_AMOUNT;
  var LONMIN = -180 + SMALL_AMOUNT;
  var LATMAX = 90 - SMALL_AMOUNT;
  var LATMIN = -90 + SMALL_AMOUNT;

  var _mapboxgl = typeof _mapboxgl === "undefined" ? mapboxgl : _mapboxgl;
  var _map = null;
  var _mapboxAccessToken = null;
  var _lastWidth = null;
  var _lastHeight = null;
  var _mapId = chartDivId;

  _chart._xDimName = null;
  _chart._yDimName = null;
  var hasAppliedInitialBounds = false;
  var _hasRendered = false;
  var _activeLayer = null;
  var _mapInitted = false;
  var _xDim = null;
  var _yDim = null;
  var _lastMapMoveType = null;
  var _lastMapUpdateTime = 0;
  var _isFirstMoveEvent = true;
  var _mapUpdateInterval = 100; // default
  var _mapStyle = "mapbox://styles/mapbox/light-v8";
  var _center = [0, 30];
  var _zoom = 1;
  var _attribLocation = "bottom-right";
  var _popupFunction = null;
  var _colorBy = null;
  var _mouseLeave = false;
  var _useLonLat = true;
  _chart._minCoord = null;
  _chart._maxCoord = null;
  _chart._reProjMapbox = true;

  var _clientClickX = null;
  var _clientClickY = null;

  var _arr = [[-180, -85], [180, 85]];

  var _llb = _mapboxgl.LngLatBounds.convert(_arr);

  var _geocoder = null;

  var _minMaxCache = {};
  var _interactionsEnabled = true;

  _chart.useLonLat = function (useLonLat) {
    if (!arguments.length) {
      return _useLonLat;
    }
    _useLonLat = useLonLat;
    return _chart;
  };
  _chart.map = function () {
    return _map;
  };

  _chart.enableInteractions = function (enableInteractions) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!arguments.length) {
      return _interactionsEnabled;
    }

    var mapboxInteractionProps = ["scrollZoom", "boxZoom", "dragRotate", "dragPan", "keyboard", "doubleClickZoom", "touchZoomRotate"];
    _interactionsEnabled = Boolean(enableInteractions);

    if (_mapInitted) {
      mapboxInteractionProps.forEach(function (prop) {
        if (_map[prop]) {
          var enable = typeof opts[prop] !== "undefined" ? Boolean(opts[prop]) : _interactionsEnabled;
          if (enable) {
            _map[prop].enable();
          } else {
            _map[prop].disable();

            if (prop === "dragPan") {
              // force a clear of the current event state on the map
              // to fully disable pans
              _map[prop]._onMouseUp({
                button: 0
              });
            }
          }
        }
      });
    }
    return _chart;
  };

  _chart.getDataRenderBounds = function () {
    var bounds = _map.getBounds();

    if (!hasAppliedInitialBounds) {
      _chart.setFilterBounds(bounds);
    }

    var renderBounds = [valuesOb(bounds.getNorthWest()), valuesOb(bounds.getNorthEast()), valuesOb(bounds.getSouthEast()), valuesOb(bounds.getSouthWest())];

    if (!_useLonLat) {
      renderBounds = [_chart.conv4326To900913(renderBounds[0]), _chart.conv4326To900913(renderBounds[1]), _chart.conv4326To900913(renderBounds[2]), _chart.conv4326To900913(renderBounds[3])];
    }
    hasAppliedInitialBounds = true;
    return renderBounds;
  };

  _chart.xDim = function (xDim) {
    if (!arguments.length) {
      return _xDim;
    }
    _xDim = xDim;
    if (_xDim) {
      _chart._xDimName = _xDim.value()[0];
    }
    return _chart;
  };

  _chart.yDim = function (yDim) {
    if (!arguments.length) {
      return _yDim;
    }
    _yDim = yDim;
    if (_yDim) {
      _chart._yDimName = _yDim.value()[0];
    }
    return _chart;
  };

  _chart.resetLayer = function () {
    if (typeof _chart._resetRenderBounds === "function") {
      _chart._resetRenderBounds();
    }

    _activeLayer = null;
  };

  _chart.colorBy = function (_) {
    if (!arguments.length) {
      return _colorBy;
    }
    _colorBy = _;
    return _chart;
  };

  _chart.mapUpdateInterval = function (mapUpdateInterval) {
    if (!arguments.length) {
      return _mapUpdateInterval;
    }
    _mapUpdateInterval = mapUpdateInterval;
    return _chart;
  };

  _chart.conv900913To4326X = function (x) {
    return x / 111319.490778;
  };

  _chart.conv900913To4326Y = function (y) {
    return 57.295779513 * (2 * Math.atan(Math.exp(y / 6378136.99911)) - 1.570796327);
  };

  _chart.conv900913To4326 = function (coord) {
    return [_chart.conv900913To4326X(coord[0]), _chart.conv900913To4326Y(coord[1])];
  };

  _chart.conv4326To900913X = function (x) {
    return x * 111319.490778;
  };

  _chart.conv4326To900913Y = function (y) {
    return 6378136.99911 * Math.log(Math.tan(0.00872664626 * y + 0.785398163397));
  };

  _chart.conv4326To900913 = function (coord) {
    return [_chart.conv4326To900913X(coord[0]), _chart.conv4326To900913Y(coord[1])];
  };

  function onLoad(e) {
    _map.addControl(new _mapboxgl.AttributionControl(), _attribLocation);

    var mapboxlogo = document.createElement("a");
    mapboxlogo.className = "mapbox-maplogo";
    mapboxlogo.href = "http://mapbox.com/about/maps";
    mapboxlogo.target = "_blank";
    mapboxlogo.innerHTML = "Mapbox";

    _chart.root()[0][0].appendChild(mapboxlogo);

    if (_geocoder) {
      initGeocoder();
    }
  }

  function onMapMove(e) {
    if (e.type === "moveend" && _lastMapMoveType === "moveend" || !_hasRendered || e.skipRedraw) {
      return;
    }

    _lastMapMoveType = e.type;
    var curTime = new Date().getTime();

    var bounds = _map.getBounds();

    if (!_useLonLat) {
      _chart._minCoord = _chart.conv4326To900913([bounds._sw.lng, bounds._sw.lat]);
      _chart._maxCoord = _chart.conv4326To900913([bounds._ne.lng, bounds._ne.lat]);
    } else {
      _chart._minCoord = [bounds._sw.lng, bounds._sw.lat];
      _chart._maxCoord = [bounds._ne.lng, bounds._ne.lat];
    }

    if (e.type === "move") {
      if (_isFirstMoveEvent) {
        _lastMapUpdateTime = curTime;
        _isFirstMoveEvent = false;
      }
      if (_mapUpdateInterval === Infinity || curTime - _lastMapUpdateTime < _mapUpdateInterval) {
        return;
      }
    } else if (e.type === "moveend") {
      _isFirstMoveEvent = true;
    }
    _lastMapUpdateTime = curTime;

    var redrawall = false;
    if (typeof _chart.getLayers === "function") {
      _chart.getLayers().forEach(function (layer) {
        if (typeof layer.xDim === "function" && typeof layer.yDim === "function") {
          var xdim = layer.xDim();
          var ydim = layer.yDim();
          if (xdim !== null && ydim !== null) {
            redrawall = true;
            xdim.filter([_chart._minCoord[0], _chart._maxCoord[0]]);
            ydim.filter([_chart._minCoord[1], _chart._maxCoord[1]]);
          }
        }
      });
    }

    if (_xDim !== null && _yDim !== null) {
      _xDim.filter([_chart._minCoord[0], _chart._maxCoord[0]]);
      _yDim.filter([_chart._minCoord[1], _chart._maxCoord[1]]);
      (0, _coreAsync.redrawAllAsync)(_chart.chartGroup()).catch(function (error) {
        (0, _coreAsync.resetRedrawStack)();
        console.log("on move event redrawall error:", error);
      });
    } else if (redrawall) {
      (0, _coreAsync.redrawAllAsync)(_chart.chartGroup()).catch(function (error) {
        (0, _coreAsync.resetRedrawStack)();
        console.log("on move event redrawall error:", error);
      });
    } else {
      _chart._projectionFlag = true;
      _chart.redrawAsync();
    }
  }

  _chart.mapStyle = function (style) {
    if (!arguments.length) {
      return _mapStyle;
    }
    _mapStyle = style;
    if (_map) {
      _map.setStyle(_mapStyle);
      if (typeof _chart.resetLayer !== "undefined") {
        _chart.resetLayer();
      }
    }

    return _chart;
  };

  _chart.mapboxToken = function (mapboxToken) {
    if (!arguments.length) {
      return _mapboxAccessToken;
    }
    _mapboxAccessToken = mapboxToken;
    return _chart;
  };

  _chart.center = function (_) {
    if (!arguments.length) {
      _center = _map.getCenter();
      return _center;
    }
    _center = _;
    if (_mapInitted) {
      _map.setCenter(_center);
    }
    return _chart;
  };

  _chart.zoom = function (_) {
    if (!arguments.length) {
      _zoom = _map.getZoom();
      return _zoom;
    }
    _zoom = _;
    if (_mapInitted) {
      _map.setZoom(_zoom);
    }
    return _chart;
  };

  _chart.attribLocation = function (_) {
    if (!arguments.length) {
      return _attribLocation;
    }
    _attribLocation = _;
    return _chart;
  };

  _chart.resetSvg = function () {
    if (_chart.svg()) {
      _chart.svg().remove();
    }
    var mapContainer = _d2.default.select(_chart.map().getCanvasContainer());
    var svg = mapContainer.append("svg").attr("class", "poly-svg");
    svg.attr("width", _chart.width()).attr("height", _chart.height());
    _chart.svg(svg);
  };

  _chart.mapProject = function (input) {
    // keep both methods before now until we can establish performance
    // profiles of each - seem about equally fast at first glance
    if (_chart._reProjMapbox == false) {
      var xDiff = this._maxCoord[0] - this._minCoord[0];
      var yDiff = this._maxCoord[1] - this._minCoord[1];
      var projectedPoint = this.conv4326To900913(input);
      return [(projectedPoint[0] - this._minCoord[0]) / xDiff * this.width(), (1.0 - (projectedPoint[1] - this._minCoord[1]) / yDiff) * this.height()];
    } else {
      var projectedPoint = this.map().project(input);
      return [projectedPoint.x, projectedPoint.y];
    }
  };

  _chart._setOverlay = function (data, bounds, browser, redraw) {
    var map = _chart.map();

    var boundsToUse = bounds;
    if (boundsToUse === undefined) {
      return;
    } else if (!_useLonLat) {
      boundsToUse = [_chart.conv900913To4326(bounds[0]), _chart.conv900913To4326(bounds[1]), _chart.conv900913To4326(bounds[2]), _chart.conv900913To4326(bounds[3])];
    }

    if (browser.isSafari || browser.isIE || browser.isEdge) {
      var blob = utilss.b64toBlob(data, "image/png");
      var blobUrl = URL.createObjectURL(blob);
    } else {
      var blobUrl = "data:image/png;base64," + data;
    }

    if (!_activeLayer) {
      _activeLayer = "_points";
      var toBeAddedOverlay = "overlay" + _activeLayer;
      map.addSource(toBeAddedOverlay, {
        type: "image",
        url: blobUrl,
        coordinates: boundsToUse
      });

      map.addLayer({
        id: toBeAddedOverlay,
        source: toBeAddedOverlay,
        type: "raster",
        paint: { "raster-opacity": 1, "raster-fade-duration": 0 }
      });
    } else {
      var overlayName = "overlay" + _activeLayer;
      var imageSrc = map.getSource(overlayName);
      imageSrc.updateImage({
        url: blobUrl,
        coordinates: boundsToUse
      });
    }
  };

  _chart._removeOverlay = function () {
    var map = _chart.map();

    var overlay = "overlay" + _activeLayer;
    map.removeLayer(overlay);
    map.removeSource(overlay);
  };

  _chart.isLoaded = function () {
    return _map._loaded && _map.style && _map.style._loaded;
  };

  function initMap() {
    if (_mapInitted) {
      return;
    }
    _mapboxgl.accessToken = _mapboxAccessToken;

    _chart.root().style("width", _chart.width() + "px").style("height", _chart.height() + "px");

    _map = new _mapboxgl.Map({
      container: _mapId, // container id
      style: _mapStyle,
      interactive: true,
      center: _center, // starting position
      zoom: _zoom, // starting zoom
      maxBounds: _llb,
      preserveDrawingBuffer: true,
      attributionControl: false
    });

    _map.dragRotate.disable();
    _map.touchZoomRotate.disableRotation();
    _chart.addMapListeners();
    _mapInitted = true;
    _chart.enableInteractions(_interactionsEnabled);
  }

  _chart.addMapListeners = function () {
    _map.on("move", onMapMove);
    _map.on("moveend", onMapMove);
  };

  _chart.removeMapListeners = function () {
    _map.off("move", onMapMove);
    _map.off("moveend", onMapMove);
  };

  _chart.on("postRender", function () {
    _hasRendered = true;
  });

  _chart.on("preRender", function (chart) {
    var width = chart.width();
    var height = chart.height();

    if (width !== _lastWidth || height !== _lastHeight) {
      _chart.root().select("#" + _mapId + " canvas").attr("width", width).attr("height", height);

      _lastWidth = width;
      _lastHeight = height;
      _map.resize();
    }
  });

  function getMinMax(value) {
    return _chart.crossfilter().groupAll().reduce([{ expression: value, agg_mode: "min", name: "minimum" }, { expression: value, agg_mode: "max", name: "maximum" }]).valuesAsync(true, true).then(function (bounds) {
      return [bounds.minimum, bounds.maximum];
    });
  }

  function createRangeMinMaxPromises(promises, value) {
    if (!_minMaxCache[value]) {
      return promises.concat(getMinMax(value).then(function (bounds) {
        _minMaxCache[value] = bounds;
      }));
    } else {
      return promises;
    }
  }

  var _fitInitialBounds = void 0;

  _chart.fitInitialBounds = function (callback) {
    if (!arguments.length) {
      _fitInitialBounds();
    }
    _fitInitialBounds = callback;
    return _chart;
  };

  function init(_bounds) {
    return Promise.resolve();
  }

  _chart.init = function (bounds) {
    if (_mapInitted) {
      return;
    }

    var styleLoaded = false;
    var loaded = false;

    initMap();

    return new Promise(function (resolve, reject) {
      _map.on("load", function (e) {
        onLoad(e);
        loaded = true;
        if (styleLoaded) {
          init(bounds).then(function () {
            resolve(_chart);
          });
        }
      });

      _map.on("style.load", function () {
        styleLoaded = true;
        if (loaded) {
          init(bounds).then(function () {
            resolve(_chart);
          });
        }
      });

      _map.on("mousedown", function (event) {
        _clientClickX = event.point.x;
        _clientClickY = event.point.y;
      });

      _map.on("mouseup", function (event) {
        // Make sure that the user is clicking to filter, and not dragging or panning the map
        if (_clientClickX === event.point.x && _clientClickY === event.point.y) {
          _chart.getClosestResult(event.point, function (result) {
            var data = result.row_set[0];
            _chart.getLayerNames().forEach(function (layerName) {
              var layer = _chart.getLayer(layerName);
              if (typeof layer.onClick === "function") {
                layer.onClick(_chart, data, event.originalEvent);
              }
            });
          });
        }
      });
    });
  };

  _chart.setFilterBounds = function (bounds) {
    if (!_useLonLat) {
      _chart._minCoord = _chart.conv4326To900913([bounds._sw.lng, bounds._sw.lat]);
      _chart._maxCoord = _chart.conv4326To900913([bounds._ne.lng, bounds._ne.lat]);
    } else {
      _chart._minCoord = [bounds._sw.lng, bounds._sw.lat];
      _chart._maxCoord = [bounds._ne.lng, bounds._ne.lat];
    }

    _chart.getLayers().forEach(function (layer) {
      if (typeof layer.xDim === "function" && typeof layer.yDim === "function") {
        var xdim = layer.xDim();
        var ydim = layer.yDim();
        if (xdim !== null && ydim !== null) {
          xdim.filter([_chart._minCoord[0], _chart._maxCoord[0]]);
          ydim.filter([_chart._minCoord[1], _chart._maxCoord[1]]);
        }
      }
    });
  };

  function boundsRoughlyEqual(a, b) {
    return a.getSouthWest().lat === b.getSouthWest().lat || a.getSouthWest().lng === b.getSouthWest().lng || a.getNorthEast().lat === b.getNorthEast().lat || a.getNorthEast().lng === b.getNorthEast().lng;
  }

  _chart.geocoder = function (geocoder) {
    if (!arguments.length) {
      return _geocoder;
    }
    if (typeof geocoder.locate !== "function") {
      throw new Error("Geocoder must have a location function");
    }
    _geocoder = geocoder;
    return _chart;
  };

  function initGeocoder() {
    _chart.root().append("input").attr("type", "text").attr("placeholder", "Zoom to").classed("geocoder-input", true).style("top", "5px").style("right", "5px").style("float", "right").style("position", "absolute").on("keydown", function () {
      if (_d2.default.event.key === "Enter" || _d2.default.event.keyCode === 13) {
        _geocoder.locate(this.value).then(_chart.zoomToLocation);
      }
    });
  }

  function validateBounds(data) {
    var sw = data.bounds.sw;
    var ne = data.bounds.ne;
    /* eslint-disable operator-linebreak */
    return !isNaN(sw[0]) && !isNaN(ne[0]) && !isNaN(sw[1]) && !isNaN(ne[1]) && sw[0] <= ne[0] && sw[1] < ne[1] && sw[0] >= -180 && sw[0] <= 180 && sw[1] >= -90 && sw[1] <= 90 && ne[0] >= -180 && ne[0] <= 180 && ne[1] >= -90 && ne[1] <= 90;
    /* eslint-enable operator-linebreak */
  }

  _chart.zoomToLocation = function (data) {
    if (!_mapInitted) {
      return _chart;
    }
    if (data.bounds) {
      if (validateBounds(data)) {
        _map.fitBounds([data.bounds.sw, data.bounds.ne], {
          linear: true,
          duration: EASE_DURATION_MS
        });
      }
    } else {
      var center = data.center;
      _map.setCenter(center);
      _map.setZoom(DEFAULT_ZOOM_LEVEL);
    }
    return _chart;
  };

  if (mixinDraw) {
    _chart = (0, _rasterDrawMixin.rasterDrawMixin)(_chart);
  }

  return _chart;
}

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rasterDrawMixin = rasterDrawMixin;

var _utilsLatlon = __webpack_require__(138);

var LatLonUtils = _interopRequireWildcard(_utilsLatlon);

var _lassoToolUi = __webpack_require__(193);

var _lassoToolUi2 = _interopRequireDefault(_lassoToolUi);

var _earcut = __webpack_require__(137);

var _earcut2 = _interopRequireDefault(_earcut);

var _mapdDraw = __webpack_require__(22);

var MapdDraw = _interopRequireWildcard(_mapdDraw);

var _coreAsync = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/* istanbul ignore next */
function writePointInTriangleSqlTest(p0, p1, p2, px, py) {
  var cast = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

  function writeSign(p0, p1) {
    if (cast) {
      return "((CAST(" + px + " AS FLOAT)-(" + p1[0] + "))*(" + (p0[1] - p1[1]) + ") - " + ("(" + (p0[0] - p1[0]) + ")*(CAST(" + py + " AS FLOAT)-(" + p1[1] + ")) < 0.0)");
    } else {
      return "((" + px + "-(" + p1[0] + "))*(" + (p0[1] - p1[1]) + ") - " + ("(" + (p0[0] - p1[0]) + ")*(" + py + "-(" + p1[1] + ")) < 0.0)");
    }
  }

  var b1 = writeSign(p0, p1);
  var b2 = writeSign(p1, p2);
  var b3 = writeSign(p2, p0);
  return "(" + b1 + " = " + b2 + ") AND (" + b2 + " = " + b3 + ")";
}

/* istanbul ignore next */
function createUnlikelyStmtFromShape(shape, xAttr, yAttr, useLonLat) {
  var aabox = shape.aabox;
  var xmin = aabox[MapdDraw.AABox2d.MINX];
  var xmax = aabox[MapdDraw.AABox2d.MAXX];
  var ymin = aabox[MapdDraw.AABox2d.MINY];
  var ymax = aabox[MapdDraw.AABox2d.MAXY];
  var cast = true;
  if (useLonLat) {
    xmin = LatLonUtils.conv900913To4326X(xmin);
    xmax = LatLonUtils.conv900913To4326X(xmax);
    ymin = LatLonUtils.conv900913To4326Y(ymin);
    ymax = LatLonUtils.conv900913To4326Y(ymax);
    cast = false;
  }

  if (cast) {
    return "UNLIKELY(CAST(" + xAttr + " AS FLOAT) >= " + xmin + " AND CAST(" + xAttr + " AS FLOAT) <= " + xmax + " AND CAST(" + yAttr + " AS FLOAT) >= " + ymin + " AND CAST(" + yAttr + " AS FLOAT) <= " + ymax + ")";
  } else {
    return "UNLIKELY(" + xAttr + " >= " + xmin + " AND " + xAttr + " <= " + xmax + " AND " + yAttr + " >= " + ymin + " AND " + yAttr + " <= " + ymax + ")";
  }
}

/* istanbul ignore next */
function rasterDrawMixin(chart) {
  var drawEngine = null;
  var buttonController = null;
  var currXRange = null;
  var currYRange = null;
  var coordFilters = new Map();
  var origFilterFunc = null;
  var origFilterAll = null;

  var defaultStyle = {
    fillColor: "#22a7f0",
    fillOpacity: 0.1,
    strokeColor: "#22a7f0",
    strokeWidth: 1.5,
    dashPattern: []
  };

  var defaultSelectStyle = {
    fillColor: "#ef9b20",
    fillOpacity: 0.1,
    strokeColor: "#ef9b20",
    strokeWidth: 2,
    dashPattern: [8, 2]
  };

  function applyFilter() {
    var NUM_SIDES = 3;
    var useLonLat = typeof chart.useLonLat === "function" && chart.useLonLat();
    var shapes = drawEngine.sortedShapes;
    var LatLonCircle = (0, _lassoToolUi.getLatLonCircleClass)();

    var layers = chart.getLayers && typeof chart.getLayers === "function" ? chart.getLayers() : [chart];
    layers.forEach(function (layer) {
      if (!layer.layerType || typeof layer.layerType !== "function" || layer.layerType() === "points" || layer.layerType() === "heat") {
        var crossFilter = null;
        var filterObj = null;
        var group = layer.group();
        if (group) {
          crossFilter = group.getCrossfilter();
        } else {
          var dim = layer.dimension();
          if (dim) {
            crossFilter = dim.getCrossfilter();
          } else {
            crossFilter = layer.crossfilter();
          }
        }
        if (crossFilter) {
          filterObj = coordFilters.get(crossFilter);
          if (!filterObj) {
            filterObj = {
              coordFilter: crossFilter.filter(),
              px: [],
              py: []
            };
            coordFilters.set(crossFilter, filterObj);
            filterObj.shapeFilters = [];
          }
          var xdim = layer.xDim();
          var ydim = layer.yDim();
          if (xdim && ydim) {
            var px = xdim.value()[0];
            var py = ydim.value()[0];
            filterObj.px.push(px);
            filterObj.py.push(py);
            shapes.forEach(function (shape) {
              if (shape instanceof LatLonCircle) {
                var pos = shape.getWorldPosition();
                // convert from mercator to lat-lon
                LatLonUtils.conv900913To4326(pos, pos);
                var meters = shape.radius * 1000;
                filterObj.shapeFilters.push("DISTANCE_IN_METERS(" + pos[0] + ", " + pos[1] + ", " + px + ", " + py + ") < " + meters);
              } else if (shape instanceof MapdDraw.Circle) {
                var radsqr = Math.pow(shape.radius, 2);
                var mat = MapdDraw.Mat2d.clone(shape.globalXform);
                MapdDraw.Mat2d.invert(mat, mat);
                filterObj.shapeFilters.push(createUnlikelyStmtFromShape(shape, px, py, useLonLat) + " AND (POWER(" + mat[0] + " * CAST(" + px + " AS FLOAT) + " + mat[2] + " * CAST(" + py + " AS FLOAT) + " + mat[4] + ", 2.0) + POWER(" + mat[1] + " * CAST(" + px + " AS FLOAT) + " + mat[3] + " * CAST(" + py + " AS FLOAT) + " + mat[5] + ", 2.0)) / " + radsqr + " <= 1.0");
              } else if (shape instanceof MapdDraw.Poly) {
                var p0 = [0, 0];
                var p1 = [0, 0];
                var p2 = [0, 0];
                var earcutverts = [];
                var verts = shape.vertsRef;
                var xform = shape.globalXform;
                verts.forEach(function (vert) {
                  MapdDraw.Point2d.transformMat2d(p0, vert, xform);
                  if (useLonLat) {
                    LatLonUtils.conv900913To4326(p0, p0);
                  }
                  earcutverts.push(p0[0], p0[1]);
                });

                var triangles = (0, _earcut2.default)(earcutverts);
                var triangleTests = [];
                var idx = 0;
                for (var j = 0; j < triangles.length; j = j + NUM_SIDES) {
                  idx = triangles[j] * 2;
                  MapdDraw.Point2d.set(p0, earcutverts[idx], earcutverts[idx + 1]);

                  idx = triangles[j + 1] * 2;
                  MapdDraw.Point2d.set(p1, earcutverts[idx], earcutverts[idx + 1]);

                  idx = triangles[j + 2] * 2;
                  MapdDraw.Point2d.set(p2, earcutverts[idx], earcutverts[idx + 1]);

                  triangleTests.push(writePointInTriangleSqlTest(p0, p1, p2, px, py, !useLonLat));
                }

                if (triangleTests.length) {
                  filterObj.shapeFilters.push(createUnlikelyStmtFromShape(shape, px, py, useLonLat) + " AND (" + triangleTests.join(" OR ") + ")");
                }
              }
            });
          }
        }
      }
    });

    coordFilters.forEach(function (filterObj) {
      if (filterObj.px.length && filterObj.py.length && filterObj.shapeFilters.length) {
        var shapeFilterStmt = filterObj.shapeFilters.join(" OR ");
        var filterStmt = filterObj.px.map(function (e, i) {
          return { px: e, py: filterObj.py[i] };
        }).reduce(function (acc, e) {
          return acc.some(function (e1) {
            return e1.px === e.px && e1.py === e.py;
          }) ? acc : [].concat(_toConsumableArray(acc), [e]);
        }, []).map(function (e, i) {
          return "(" + e.px + " IS NOT NULL AND " + e.py + " IS NOT NULL AND (" + shapeFilterStmt + "))";
        }).join(" AND ");
        filterObj.coordFilter.filter([filterStmt]);
        filterObj.px = [];
        filterObj.py = [];
        filterObj.shapeFilters = [];
      } else {
        filterObj.coordFilter.filter();
      }
    });

    chart._invokeFilteredListener(chart.filters(), false);
  }

  function drawEventHandler() {
    applyFilter();
    (0, _coreAsync.redrawAllAsync)(chart.chartGroup());
  }

  var debounceRedraw = chart.debounce(function () {
    drawEventHandler();
  }, 50);

  function updateDrawFromGeom() {
    debounceRedraw();
  }

  chart.addFilterShape = function (shape) {
    shape.on(["changed:geom", "changed:xform", "changed:visibility"], updateDrawFromGeom);
    updateDrawFromGeom();
  };

  chart.deleteFilterShape = function (shape) {
    shape.off(["changed"], updateDrawFromGeom);
    updateDrawFromGeom();
  };

  function filters() {
    var shapes = drawEngine.getShapesAsJSON();
    if (shapes[0]) {
      return chart.nonDrawFilters().concat(Array.from(shapes));
    }
    return chart.nonDrawFilters();
  }

  function filter(filterArg) {
    if (!arguments.length) {
      return drawEngine.getShapesAsJSON();
    }

    if (filterArg === null) {
      drawEngine.deleteAllShapes();
      applyFilter();
    } else if (typeof filterArg.type !== "undefined") {
      var newShape = null;
      if (filterArg.type === "Feature") {
        console.log("WARNING - trying to load an incompatible lasso dashboard. All filters will be cleared.");
        return;
      }
      var selectOpts = {};
      if (filterArg.type === "LatLonCircle") {
        var LatLonCircle = (0, _lassoToolUi.getLatLonCircleClass)();
        newShape = new LatLonCircle(filterArg);
        selectOpts.uniformScaleOnly = true;
        selectOpts.centerScaleOnly = true;
        selectOpts.rotatable = false;
      } else if (typeof MapdDraw[filterArg.type] !== "undefined") {
        newShape = new MapdDraw[filterArg.type](filterArg);
      } else {
        origFilterFunc(filterArg);
      }

      if (newShape) {
        drawEngine.addShape(newShape, selectOpts);
        chart.addFilterShape(newShape);
        applyFilter();
      }
    } else {
      origFilterFunc(filterArg);
    }

    if (!buttonController || !buttonController.isActive()) {
      drawEngine.enableInteractions();
    }
  }

  chart.addDrawControl = function () {
    if (drawEngine) {
      return chart;
    }

    var parent = chart.root().node();

    var xscale = chart.x();
    var yscale = chart.y();
    if (!xscale || !yscale) {
      chart._updateXAndYScales(chart.getDataRenderBounds());
      xscale = chart.x();
      yscale = chart.y();
    }
    currXRange = xscale.domain();
    currYRange = yscale.domain();

    var projDims = [Math.abs(currXRange[1] - currXRange[0]), Math.abs(currYRange[1] - currYRange[0])];

    var engineOpts = {
      enableInteractions: true,
      projectionDimensions: projDims,
      cameraPosition: [currXRange[0] + 0.5 * projDims[0], Math.min(currYRange[0], currYRange[1]) + 0.5 * projDims[1]],
      flipY: true,
      selectStyle: defaultSelectStyle,
      xformStyle: {
        fillColor: "white",
        strokeColor: "#555555",
        strokeWidth: 1
      }
    };

    var margins = null;
    if (typeof chart.margins === "function") {
      margins = chart.margins();
      engineOpts.margins = margins;
    }

    drawEngine = new MapdDraw.ShapeBuilder(parent, engineOpts);
    buttonController = new _lassoToolUi2.default(parent, chart, drawEngine, defaultStyle, defaultSelectStyle);

    function updateDraw() {
      var bounds = chart.getDataRenderBounds();
      currXRange = [bounds[0][0], bounds[1][0]];
      currYRange = [bounds[0][1], bounds[2][1]];
      if (typeof chart.useLonLat === "function" && chart.useLonLat()) {
        currXRange[0] = LatLonUtils.conv4326To900913X(currXRange[0]);
        currXRange[1] = LatLonUtils.conv4326To900913X(currXRange[1]);
        currYRange[0] = LatLonUtils.conv4326To900913Y(currYRange[0]);
        currYRange[1] = LatLonUtils.conv4326To900913Y(currYRange[1]);
      }

      var newProjDims = [Math.abs(currXRange[1] - currXRange[0]), Math.abs(currYRange[1] - currYRange[0])];
      drawEngine.projectionDimensions = newProjDims;
      drawEngine.cameraPosition = [currXRange[0] + 0.5 * newProjDims[0], Math.min(currYRange[0], currYRange[1]) + 0.5 * newProjDims[1]];

      // debounceRedraw()
    }

    function updateDrawResize(eventObj) {
      // make sure all buttons and events are deactivated when resizing
      // so shape creation/modification events aren't unintentionally
      // triggered
      buttonController.deactivateButtons();

      // NOTE: in the scatterplot case, there's no guarantee that the parent div will have been properly
      // resized by the time we reach here. Getting the effectiveWidth of the chart is a safer
      // bet. That method should be defined on a scatterplot chart.
      // Do we need to be concerned with margins/padding on the div? I don't believe we
      // do since we're only setting the viewport here, which should cover the entire
      // width/height of the canvas.
      var widthToUse = typeof chart.effectiveWidth === "function" ? chart.effectiveWidth() : parent.offsetWidth;
      var heightToUse = typeof chart.effectiveHeight === "function" ? chart.effectiveHeight() : parent.offsetHeight;
      drawEngine.viewport = [0, 0, widthToUse, heightToUse];
      updateDraw();
    }

    if (typeof chart.useLonLat === "function") {
      // using a mapbox map, it works better to rerender
      // on move here
      chart.map().on("move", updateDraw);
    } else {
      // using a dc coordinate grid, redraws work better
      // on the render event
      chart.map().on("render", updateDraw);
    }
    chart.map().on("resize", updateDrawResize);

    origFilterFunc = chart.filter;
    origFilterAll = chart.filterAll;
    chart.filter = filter;
    chart.nonDrawFilters = chart.filters;
    chart.filters = filters;

    chart.filterAll = function () {
      origFilterAll();
      chart.getLayerNames().forEach(function (layerName) {
        var layer = chart.getLayer(layerName);
        if (layer.hasOwnProperty("filterAll")) {
          layer.filterAll();
        }
      });
      if (coordFilters) {
        coordFilters.forEach(function (filterObj) {
          filterObj.shapeFilters = [];
          filterObj.coordFilter.filter();
        });
      }
      var shapes = drawEngine.sortedShapes;
      drawEngine.deleteAllShapes();

      origFilterFunc(Symbol.for("clear"));

      shapes.forEach(function (shape) {
        chart.deleteFilterShape(shape);
      });

      if (typeof chart.useLonLat === "function") {
        // pointmap should preserve the zoom filter
        chart.setFilterBounds(chart.map().getBounds());
      }
      return chart;
    };

    return chart;
  };

  chart.coordFilter = function (filter) {
    // noop - for backwards compatibility
  };

  return chart;
}

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

!function(t,e){ true?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.MapdDraw=e():t.MapdDraw=e()}(this,function(){return function(t){function e(n){if(r[n])return r[n].exports;var a=r[n]={exports:{},id:n,loaded:!1};return t[n].call(a.exports,a,a.exports,e),a.loaded=!0,a.exports}var r={};return e.m=t,e.c=r,e.p="",e(0)}([function(t,e,r){"use strict";function n(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function a(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(e,"__esModule",{value:!0}),e.simpleHull_2D=e.Math=e.Point=e.PolyLine=e.Poly=e.Rect=e.Circle=e.Vec2d=e.BasicStyle=e.Mat2=e.Point2d=e.Mat2d=e.AABox2d=e.DrawEngine=e.ShapeBuilder=e.version=void 0;var i=r(39);Object.defineProperty(e,"version",{enumerable:!0,get:function(){return i.version}});var o=r(1);Object.defineProperty(e,"Mat2",{enumerable:!0,get:function(){return o.mat2}});var s=r(15);Object.defineProperty(e,"simpleHull_2D",{enumerable:!0,get:function(){return s.simpleHull_2D}});var l=r(23),u=a(l),c=r(14),f=a(c),h=r(2),d=n(h),p=r(5),_=a(p),v=r(4),y=n(v),m=r(9),M=a(m),b=r(10),x=a(b),g=r(27),S=a(g),I=r(16),D=a(I),w=r(29),F=a(w),O=r(11),k=a(O),E=r(28),P=a(E),C=r(6),A=a(C);e.ShapeBuilder=u.default,e.DrawEngine=f.default,e.AABox2d=d,e.Mat2d=_.default,e.Point2d=y,e.BasicStyle=M.default,e.Vec2d=x.default,e.Circle=S.default,e.Rect=D.default,e.Poly=F.default,e.PolyLine=k.default,e.Point=P.default,e.Math=A.default},function(t,e,r){e.glMatrix=r(3),e.mat2=r(34),e.mat2d=r(35),e.mat3=r(20),e.mat4=r(36),e.quat=r(37),e.vec2=r(38),e.vec3=r(21),e.vec4=r(22)},function(t,e,r){"use strict";function n(t,e,r,n,a){return t[P]="number"==typeof e?e:1/0,t[C]="number"==typeof r?r:1/0,t[A]="number"==typeof n?n:-(1/0),t[j]="number"==typeof a?a:-(1/0),t}function a(t,e,r,a){var i=new E.glMatrix.ARRAY_TYPE(z.BOX_SIDES);return n(i,t,e,r,a)}function i(t){var e=new E.glMatrix.ARRAY_TYPE(z.BOX_SIDES);return e[P]=t[P],e[C]=t[C],e[A]=t[A],e[j]=t[j],e}function o(t,e){return t[P]=e[P],t[C]=e[C],t[A]=e[A],t[j]=e[j],t}function s(t){return t[P]=1/0,t[C]=1/0,t[A]=-(1/0),t[j]=-(1/0),t}function l(t){return t[P]=-(1/0),t[C]=-(1/0),t[A]=1/0,t[j]=1/0,t}function u(t,e){return e[0]<0?(t[P]=-e[0],t[A]=0):(t[P]=0,t[A]=e[0]),e[1]<0?(t[C]=-e[1],t[j]=0):(t[C]=0,t[j]=e[1]),t}function c(t,e,r){for(var n=0;n<2;n+=1)r[n]<0?(t[n]=e[n]-r[n],t[n+2]=e[n]):(t[n]=e[n],t[n+2]=e[n]+r[n]);return t}function f(t,e,r){for(var n=0;n<2;n+=1)r[n]<0?(t[n]=e[n]+r[n],t[n+2]=e[n]-r[n]):(t[n]=e[n]-r[n],t[n+2]=e[n]+r[n]);return t}function h(t){return t[P]>t[A]||t[C]>t[j]}function d(t){return!(isFinite(t[P])&&isFinite(t[C])&&isFinite(t[A])&&isFinite(t[j]))}function p(t,e){var r=t[0],n=t[1],a=t[2],i=t[3],o=e[0],s=e[1],l=e[2],u=e[3];return Math.abs(r-o)<=E.glMatrix.EPSILON&&Math.abs(n-s)<=E.glMatrix.EPSILON&&Math.abs(a-l)<=E.glMatrix.EPSILON&&Math.abs(i-u)<=E.glMatrix.EPSILON}function _(t,e){return E.vec2.set(t,e[A]-e[P],e[j]-e[C])}function v(t,e){return _(t,e),E.vec2.scale(t,t,.5)}function y(t,e){return v(t,e),t[P]+=e[P],t[C]+=e[C],t}function m(t,e,r){t[P]=e[P]-r[0],t[A]=e[A]+r[0],t[C]=e[C]-r[1],t[j]=e[j]+r[1]}function M(t){return(t[A]-t[P])*(t[j]-t[C])}function b(t,e,r){return a(Math.min(e[P],r[P]),Math.min(e[C],r[C]),Math.max(e[A],r[A]),Math.max(e[j],r[j]))}function x(t,e,r){var n=t;t===e&&(n=a());for(var i=P,l=A;i<=C&&!(e[l]<r[i]||e[i]>r[l]);i+=1,l+=1)n[i]=Math.max(e[i],r[i]),n[l]=Math.min(e[l],r[l]);return i!==C+1&&s(n),t===e&&o(t,n),t}function g(t,e){return!(t[A]<=e[P]||t[P]>=e[A]||t[j]<=e[C]||t[C]>=e[j])}function S(t,e){return!(e[P]<t[P]||e[A]>t[A]||e[C]<t[C]||e[j]>t[j])}function I(t,e){return e[P]>=t[P]&&e[P]<=t[A]&&e[C]>=t[C]&&e[C]<=t[j]}function D(t,e,r){return t!==e&&o(t,e),h(e)?(t[P]=r[P],t[A]=r[P],t[C]=r[C],t[j]=r[C]):(r[P]<t[P]?t[P]=r[P]:r[P]>t[A]&&(t[A]=r[P]),r[C]<t[C]?t[C]=r[C]:r[C]>t[j]&&(t[j]=r[C])),t}function w(t,e,r){t[P]=e[P]+r[0],t[C]=e[C]+r[1],t[A]=e[A]+r[0],t[j]=e[j]+r[1]}function F(t,e,r,n){var i=t;t===e&&(i=a()),s(i);var l=E.vec2.set(E.vec2.create(),e[P],e[C]),u=E.vec2.create();return n(u,l,r),D(i,i,u),l[P]=e[A],n(u,l,r),D(i,i,u),l[C]=e[j],n(u,l,r),D(i,i,u),l[P]=e[P],n(u,l,r),D(i,i,u),t===e&&o(t,i),t}function O(t,e,r){return F(t,e,r,E.vec2.transformMat2)}function k(t,e,r){return F(t,e,r,E.vec2.transformMat2d)}Object.defineProperty(e,"__esModule",{value:!0}),e.MAXY=e.MAXX=e.MINY=e.MINX=void 0,e.set=n,e.create=a,e.clone=i,e.copy=o,e.initEmpty=s,e.initInfinity=l,e.initSizeFromOrigin=u,e.initSizeFromLocation=c,e.initCenterExtents=f,e.isEmpty=h,e.isInfinite=d,e.equals=p,e.getSize=_,e.getExtents=v,e.getCenter=y,e.expand=m,e.area=M,e.hull=b,e.intersection=x,e.overlaps=g,e.contains=S,e.containsPt=I,e.encapsulatePt=D,e.translate=w,e.transformMat2=O,e.transformMat2d=k;var E=r(1),P=e.MINX=0,C=e.MINY=1,A=e.MAXX=2,j=e.MAXY=3,z={BOX_SIDES:4}},function(t,e){var r={};r.EPSILON=1e-6,r.ARRAY_TYPE="undefined"!=typeof Float32Array?Float32Array:Array,r.RANDOM=Math.random,r.ENABLE_SIMD=!1,r.SIMD_AVAILABLE=r.ARRAY_TYPE===Float32Array&&"SIMD"in this,r.USE_SIMD=r.ENABLE_SIMD&&r.SIMD_AVAILABLE,r.setMatrixArrayType=function(t){r.ARRAY_TYPE=t};var n=Math.PI/180;r.toRadian=function(t){return t*n},r.equals=function(t,e){return Math.abs(t-e)<=r.EPSILON*Math.max(1,Math.abs(t),Math.abs(e))},t.exports=r},function(t,e,r){"use strict";function n(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return t[M]=e,t[b]=r,t}function a(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=new m.glMatrix.ARRAY_TYPE(2);return n(r,t,e)}function i(t){var e=new m.glMatrix.ARRAY_TYPE(2);return e[M]=t[M],e[b]=t[b],e}function o(t,e){return t[M]=e[M],t[b]=e[b],t}function s(t,e){return a(t,e)}function l(t,e,r){return m.vec2.add(t,e,r)}function u(t,e,r){return m.vec2.sub(t,e,r)}function c(t,e,r){return m.vec2.transformMat2(t,e,r)}function f(t,e,r){return m.vec2.transformMat2d(t,e,r)}function h(t){return"point2d("+t[0]+" , "+t[1]+")"}function d(t,e){return m.vec2.distance(t,e)}function p(t,e){return m.vec2.squaredDistance(t,e)}function _(t,e,r,n){return m.vec2.lerp(t,e,r,n)}function v(t,e){return m.vec2.equals(t,e)}function y(t,e){return m.vec2.exactEquals(t,e)}Object.defineProperty(e,"__esModule",{value:!0}),e.sqrDist=e.dist=void 0,e.set=n,e.create=a,e.clone=i,e.copy=o,e.initFromValues=s,e.addVec2=l,e.sub=u,e.transformMat2=c,e.transformMat2d=f,e.str=h,e.distance=d,e.squaredDistance=p,e.lerp=_,e.equals=v,e.exactEquals=y;var m=r(1),M=0,b=1;e.dist=d,e.sqrDist=p},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=r(1);n.mat2d.svd=function(t,e,r,n){if(t&&(t[0]=n[4],t[1]=n[5]),e||r){var a=(n[0]+n[3])/2,i=(n[0]-n[3])/2,o=(n[1]+n[2])/2,s=(n[1]-n[2])/2;if(e){var l=Math.sqrt(a*a+s*s),u=Math.sqrt(i*i+o*o);e[0]=l+u,e[1]=l-u}if(r){var c=Math.atan2(o,i),f=Math.atan2(s,a);r[0]=(f-c)/2,r[1]=(f+c)/2}}},e.default=n.mat2d},function(t,e){"use strict";function r(t,e,r){return t<e?e:t>r?r:t}function n(t){return t<0?0:t>1?1:t}function a(t,e,r){return t*(1-r)+e*r}Object.defineProperty(e,"__esModule",{value:!0});var i=1e-5,o=.25,s=.5,l=2;Math.QUATER_PI=o*Math.PI,Math.HALF_PI=s*Math.PI,Math.HALF_NPI=-s*Math.PI,Math.TWO_PI=l*Math.PI,Math.NPI=-Math.PI,Math.NQUATER_PI=o*Math.NPI,Math.NHALF_PI=s*Math.NPI,Math.NTWO_PI=l*Math.NPI,Math.INV_PI=1/Math.PI,Math.RAD_TO_DEG=180/Math.PI,Math.DEG_TO_RAD=Math.PI/180,Math.EPS=i,Math.clamp=r,Math.clamp01=n,Math.lerp=a,e.default=Math},function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function a(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var l=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),u=r(2),c=a(u),f=r(18),h=n(f),d=r(19),p=n(d),_=r(12),v=n(_),y=r(8),m=n(y),M=r(9),b=n(M),x=r(13),g=n(x),S=r(1),I=function(t){function e(t){i(this,e);var r=o(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,["changed:xform","changed:style","changed:order","changed:visibility","changed:geom"]));return r._aabox=c.create(),r._zIndex=t&&t.zIndex?t.zIndex:0,r._visible=!0,r._geomDirty=!1,r._fullXform=S.mat2d.create(),r}return s(e,t),l(e,[{key:"zIndex",set:function(t){if(!Number.isInteger(t))throw new Error("zIndex must be an integer");if(t!==this._zIndex){var e=this._zIndex;this._zIndex=t,this.fire("changed:order",{attr:"zIndex",prevVal:e,currVal:this._zIndex})}return this},get:function(){return this._zIndex}},{key:"aabox",get:function(){return this._updateAABox(),this._aabox}},{key:"visible",set:function(t){if("boolean"!=typeof t)throw new Error("visible must be a boolean");return t!==this._visible&&(this._visible=t,this.fire("changed:visibility",{attr:"visible",prevVal:!this._visible,currVal:this._visible})),this},get:function(){return this._visible}}]),e}(g.default),D=function(t){function e(t){i(this,e);var r=o(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));return r._stateStack=[],r}return s(e,t),l(e,[{key:"save",value:function(){var t=new b.default;return b.default.copyBasicStyle(this,t),t.zIndex=this.zIndex,this._stateStack.push(t),this}},{key:"restore",value:function(){var t=this._stateStack.pop();return t&&(b.default.copyBasicStyle(t,this),this.zIndex=t.zIndex),this}},{key:"getGlobalDimensions",value:function(){var t=[0,0];return S.mat2d.svd(null,t,null,this.globalXform),t[0]*=this.width,t[1]*=this.height,t}},{key:"containsPoint",value:function(t,e,r,n){var a=!1,i=this.aabox;return this.visible&&c.containsPt(i,e)&&(n.save(),n.setTransform(this._fullXform[0],this._fullXform[1],this._fullXform[2],this._fullXform[3],this._fullXform[4],this._fullXform[5]),n.beginPath(),this._draw(n),n.strokeStyle="rgba(0,0,0,0)",n.lineWidth=this.strokeWidth+5,n.dashPattern=[],n.setTransform(1,0,0,1,0,0),n.stroke(),(this.isFillVisible()&&n.isPointInPath(t[0],t[1])||this.isStrokeVisible()&&n.isPointInStroke(t[0],t[1]))&&(a=!0),n.restore()),a}},{key:"renderBounds",value:function(t,e,r){t.save(),t.setTransform(e[0],e[1],e[2],e[3],e[4],e[5]),r.setStrokeCtx(t);var n=[0,0],a=[0,0],i=this.aabox;c.getCenter(n,i),c.getExtents(a,i),t.beginPath(),t.rect(n[0]-a[0],n[1]-a[1],2*a[0],2*a[1]),t.setTransform(1,0,0,1,0,0),t.stroke(),t.restore()}},{key:"_localXformUpdated",value:function(){this._boundsOutOfDate=!0}},{key:"_globalXformUpdated",value:function(){this._boundsOutOfDate=!0}},{key:"render",value:function(t,e,r){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.transformCtx(t,this._fullXform,e),t.beginPath();var i=this._draw(t);(i||"undefined"==typeof i)&&(this.isFillVisible()&&(null===n||Boolean(n))&&(r.setFillStyle(t,this),t.fill()),this.isStrokeVisible()&&(null===a||Boolean(a))&&(r.setStrokeStyle(t,this),t.setTransform(1,0,0,1,0,0),t.stroke()))}},{key:"setStyle",value:function(t){return b.default.copyBasicStyle(t,this),this}},{key:"toJSON",value:function(){var t=this;return this._stateStack&&this._stateStack.length&&(t=this._stateStack[0]),Object.assign({visible:this.visible,zIndex:t.zIndex},b.default.toJSON(t),v.default.toJSON(this))}},{key:"visible",get:function(){return this._visible&&(this.isFillVisible()||this.isStrokeVisible())}}],[{key:"shapeCompare",value:function(t,e){var r=t.zIndex,n=e.zIndex;if(r<n)return-1;if(r>n)return 1;var a=h.default.compareFillStyle(t,e);return a||(a=p.default.compareStrokeStyle(t,e)),a}}]),e}((0,m.default)(I,(0,_.createEventedTransform2dMixin)("changed:xform"),(0,f.createEventedFillStyleMixin)("changed:style"),(0,d.createEventedStrokeStyleMixin)("changed:style")));e.default=D},function(t,e){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function n(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var i=function(t){for(var e=arguments.length,i=Array(e>1?e-1:0),o=1;o<e;o++)i[o-1]=arguments[o];var s=t?function(t){function e(){for(var t,a=arguments.length,o=Array(a),s=0;s<a;s++)o[s]=arguments[s];r(this,e);var l=n(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(o)));return i.forEach(function(t){if("function"==typeof t.prototype.initializer){var e;(e=t.prototype.initializer).call.apply(e,[l].concat(o))}}),l}return a(e,t),e}(t):function(){},l=function(e,r){Object.getOwnPropertyNames(r).concat(Object.getOwnPropertySymbols(r)).forEach(function(n){n.match(/^(?:constructor|prototype|arguments|caller|name|bind|call|apply|toString|length)$/)||t&&n.match(/^(?:initializer)$/)||Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))})};return i.forEach(function(t){l(s.prototype,t.prototype),l(s,t)}),s};e.default=i},function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function a(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function o(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),l=r(8),u=n(l),c=r(18),f=n(c),h=r(19),d=n(h),p=function(t){function e(){return a(this,e),i(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return o(e,t),s(e,null,[{key:"copyBasicStyle",value:function(t,e){f.default.copyFillStyle(t,e),d.default.copyStrokeStyle(t,e)}},{key:"toJSON",value:function(t){return Object.assign(f.default.toJSON(t),d.default.toJSON(t))}}]),e}((0,u.default)(function t(){a(this,t)},f.default,d.default));e.default=p},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=r(1);n.vec2.cross2d=function(t,e){return t[0]*e[1]-t[1]*e[0]},n.vec2.angleFast=function(t,e){return Math.acos(n.vec2.dot(t,e))},n.vec2.angle=function(t,e){var r=n.vec2.dot(t,e),a=n.vec2.cross2d(t,e),i=Math.atan2(a,r);return i},n.vec2.anglePosX=function(t){var e=Math.atan2(t[1],t[0]);return e<0&&(e*=-1),e},e.default=n.vec2},function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function a(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function l(t,e,r,n){p.isEmpty(t)?(t[0]=e[0],t[2]=e[0],n[0]=n[2]=r,t[1]=e[1],t[3]=e[1],n[1]=n[3]=r):(e[0]<t[0]?(t[0]=e[0],n[0]=r):e[0]>t[2]&&(t[2]=e[0],n[2]=r),e[1]<t[1]?(t[1]=e[1],n[1]=r):e[1]>t[3]&&(t[3]=e[1],n[3]=r))}function u(t,e,r){var n=e[0]*r[1]-r[0]*e[1];return t[0]+=(e[0]+r[0])*n,t[1]+=(e[1]+r[1])*n,n}function c(t){return Array.isArray(t)||ArrayBuffer&&ArrayBuffer.isView(t)}Object.defineProperty(e,"__esModule",{value:!0});var f=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),h=function t(e,r,n){null===e&&(e=Function.prototype);var a=Object.getOwnPropertyDescriptor(e,r);if(void 0===a){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,r,n)}if("value"in a)return a.value;var o=a.get;if(void 0!==o)return o.call(n)},d=r(2),p=a(d),_=r(4),v=a(_),y=r(7),m=n(y),M=r(1),b=r(6),x=n(b),g=r(15),S=M.mat2d.create(),I=function(t){function e(t){i(this,e);var r=t.verts||[],n=o(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));if(!c(r)||0===r.length||c(r[0])&&r.length<1||!c(r[0])&&(r.length<2||r.length%2!==0))throw new Error("PolyLine shapes must be initialized with an array of 2d points and contain at least 1 points");n._extentIndices=[-1,-1,-1,-1],n._localaabox=p.create(),n._verts=[],n._centroid=[0,0],p.initEmpty(n._aabox);var a=0,s=0;if(c(r[0])){for(s=0;s<r.length-1;s+=1)n._verts.push(v.clone(r[s])),l(n._aabox,r[s],s,n._extentIndices),a+=u(n._centroid,r[s],r[s+1]);n._verts.push(v.clone(r[s])),l(n._aabox,r[s],s,n._extentIndices),a+=u(n._centroid,r[s],r[0])}else{n._verts.push(v.create(r[0],r[1])),l(n._aabox,n._verts[0],0,n._extentIndices);var f=1;for(s=2;s<r.length-2;s+=2,f+=1)n._verts.push(v.create(r[s],r[s+1])),l(n._aabox,n._verts[f],f,n._extentIndices),a+=u(n._centroid,n._verts[f-1],n._verts[f]);n._verts.push(v.create(r[s],r[s+1])),l(n._aabox,n._verts[f],f,n._extentIndices),a+=u(n._centroid,n._verts[f],n._verts[0])}a*=.5,n._centroid[0]/=6*a,n._centroid[1]/=6*a;var h=v.create();return p.getCenter(h,n._aabox),n.pivot=h,n._verts.length<3?n._convexHull=n._verts.map(function(t,e){return e}):n._convexHull=(0,g.simpleHull_2D)(n._verts),n}return s(e,t),f(e,[{key:"getDimensions",value:function(){return[this.width,this.height]}},{key:"_collapseVerts",value:function(){var t=this;v.set(this._pivot,0,0);var e=this.localXform;if(M.mat2d.equals(e,S))return!1;p.initEmpty(this._aabox);for(var r=0;r<this._verts.length;r+=1)v.transformMat2d(this._verts[r],this._verts[r],e);return this._verts.length<3?this._convexHull=this._verts.map(function(t,e){return e}):this._convexHull=(0,g.simpleHull_2D)(this._verts),this._convexHull.forEach(function(e){l(t._aabox,t._verts[e],e,t._extentIndices)}),this.setTransformations(0,0,1,1,0),!0}},{key:"translateVert",value:function(t,e){if(t>=this._verts.length)throw new Error("Cannot translate vertex at index "+t+". There are only "+this._verts.length+" vertices in the polygon.");if(e[0]||e[1]){var r=v.clone(this._verts[t]),n=v.clone(this._verts[t]);v.addVec2(n,n,e),this._collapseVerts(),this._resetAABox=!0,this._geomDirty=!0,v.copy(n),this.fire("changed:geom",{attr:"verts["+t+"]",prevVal:r,currVal:n})}return this}},{key:"setVertPosition",value:function(t,e){if(t>=this._verts.length)throw new Error("Cannot translate vertex at index "+t+". There are only "+this._verts.length+" vertices in the polygon.");if(!v.equals(e,this._verts[t])){var r=v.clone(this._verts[t]);this._collapseVerts(),v.copy(this._verts[t],e),this._resetAABox=!0,this._geomDirty=!0,this.fire("changed:geom",{attr:"verts["+t+"]",prevVal:r,currVal:e})}}},{key:"insertVert",value:function(t,e){var r=x.default.min(x.default.max(t,0),this._verts.length);return this._collapseVerts(),t>=this._verts.length?(this._verts.push(v.clone(e)),r=this._verts.length-1):this._verts.splice(t,0,v.clone(e)),this._resetAABox=!0,this._geomDirty=!0,this.fire("changed:geom:addvert",{attr:"verts["+r+"]",currVal:e}),r}},{key:"appendVert",value:function(t){return this.insertVert(this._verts.length,t)}},{key:"removeVert",value:function(t){if(t>=this._verts.length||t<0)throw new Error("Cannot remove vertex "+t+". Invalid index. There are only "+this._verts.length+" vertices in the shape.");var e=this._verts[t];return this._verts.splice(t,1),this._collapseVerts(),this._resetAABox=!0,this._geomDirty=!0,this.fire("changed:geom:removevert",{attr:"verts["+t+"]",currVal:e}),t}},{key:"_rebuildAABox",value:function(){var t=this;p.initEmpty(this._aabox),this._verts.length<3?this._convexHull=this._verts.map(function(t,e){return e}):this._convexHull=(0,g.simpleHull_2D)(this._verts),this._convexHull.forEach(function(e){l(t._aabox,t._verts[e],e,t._extentIndices)});var e=v.create(0,0);p.getCenter(e,this._aabox),this.pivot=e}},{key:"_updateAABox",value:function(){var t=this;if(this._resetAABox&&(this._rebuildAABox(),this._resetAABox=!1),this._boundsOutOfDate||this._geomDirty){p.initEmpty(this._aabox);var e=[0,0],r=this.globalXform;if(this._convexHull.forEach(function(n){p.encapsulatePt(t._aabox,t._aabox,v.transformMat2d(e,t._verts[n],r))}),this._boundsOutOfDate=!1,this._geomDirty){var n=v.create();n[0]=this._verts[this._extentIndices[0]][0]+.5*(this._verts[this._extentIndices[2]][0]-this._verts[this._extentIndices[0]][0]),n[1]=this._verts[this._extentIndices[1]][1]+.5*(this._verts[this._extentIndices[3]][1]-this._verts[this._extentIndices[1]][1]),this.pivot=n,this._geomDirty=!1}}}},{key:"_draw",value:function(t){var e=!1;if(this._verts.length>=2){t.moveTo(this._verts[0][0],this._verts[0][1]);for(var r=1;r<this._verts.length;r+=1)t.lineTo(this._verts[r][0],this._verts[r][1]);e=!0}return e}},{key:"toJSON",value:function(){return Object.assign({type:"PolyLine",verts:this.vertsRef.map(function(t){return[t[0],t[1]]})},h(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"toJSON",this).call(this))}},{key:"width",get:function(){return this._updateAABox(),!this._verts.length||this._extentIndices[0]<0||this._extentIndices[2]<0?0:this._verts[this._extentIndices[2]][0]-this._verts[this._extentIndices[0]][0]}},{key:"height",get:function(){return this._updateAABox(),!this._verts.length||this._extentIndices[0]<0||this._extentIndices[2]<0?0:this._verts[this._extentIndices[3]][1]-this._verts[this._extentIndices[1]][1]}},{key:"vertsRef",get:function(){return this._verts}},{key:"numVerts",get:function(){return this._verts.length}}]),e}(m.default);e.default=I,I.aaboxEncapsulatePt=l},function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function a(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e,r,n,a){return h.mat2d.identity(t),h.mat2d.translate(t,t,[n[0]+a[0],n[1]+a[1]]),h.mat2d.rotate(t,t,v.default.DEG_TO_RAD*e),h.mat2d.scale(t,t,r),h.mat2d.translate(t,t,[-a[0],-a[1]]),t}function s(t){t.forEach(function(t){t._xformDirty=!0,s(t._children)})}function l(t){return(0,p.default)(null,y,function(){function e(){i(this,e)}return u(e,[{key:"setPosition",value:function(e){if(!f.equals(e,this._pos)){var r=[this._pos[0],this._pos[1]];f.copy(this._pos,e),this._lxformDirty=!0,s(this._children),this.fire(t,{attr:"position",prevVal:r,currVal:e})}return this}},{key:"translate",value:function(e){if(e[0]||e[1]){var r=[this._pos[0],this._pos[1]];f.addVec2(this._pos,this._pos,e),this._lxformDirty=!0,s(this._children),this.fire(t,{attr:"position",prevVal:r,currVal:[this._pos[0],this._pos[1]]})}return this}},{key:"setScale",value:function(e){if(!h.vec2.equals(e,this._scale)){var r=[this._scale[0],this._scale[1]];h.vec2.copy(this._scale,e),this._lxformDirty=!0,s(this._children),this.fire(t,{attr:"size",prevVal:r,currVal:e})}return this}},{key:"scale",value:function(e){if(1!==e[0]||1!==e[1]){var r=[this._scale[0],this._scale[1]];h.vec2.multiply(this._scale,this._scale,e),this._lxformDirty=!0,s(this._children),this.fire(t,{attr:"size",prevVal:r,currVal:[this._scale[0],this._scale[1]]})}return this}},{key:"setRotation",value:function(e){var r=e%360;if(r!==this._rotDeg){var n=this._rotDeg;this._rotDeg=r,this._lxformDirty=!0,s(this._children),this.fire(t,{attr:"orientation",prevVal:n,curral:this._rotDeg})}}},{key:"rotate",value:function(e){if(e){var r=this._rotDeg;this._rotDeg+=e,this._rotDeg%=360,this._lxformDirty=!0,s(this._children),this.fire(t,{attr:"orientation",prevVal:r,curral:this._rotDeg})}return this}},{key:"setTransformations",value:function(e,r,n,a,i){var o=[],l=[],u=[];if(!("undefined"==typeof e||"undefined"==typeof r||h.glMatrix.equals(e,this._pos[0])&&h.glMatrix.equals(r,this._pos[1]))){var c=f.clone(this._pos);this._pos[0]=e,this._pos[1]=r,o.push("position"),l.push(c),u.push(f.clone(this._pos))}if(!("undefined"==typeof n||"undefined"==typeof a||h.glMatrix.equals(n,this._scale[0])&&h.glMatrix.equals(a,this._scale[1]))){var d=h.vec2.clone(this._scale);h.vec2.set(this._scale,n,a),o.push("size"),l.push(d),u.push(h.vec2.clone(this._scale))}if("undefined"!=typeof i){var p=i%360;if(!h.glMatrix.equals(p,this._rotDeg)){var _=this._rotDeg;this._rotDeg=p,o.push("orientation"),l.push(_),u.push(this._rotDeg)}}return o.length&&(this._lxformDirty=!0,s(this._children),this.fire(t,{attrs:o,prevVals:l,currVals:u})),this}},{key:"pivot",set:function(e){if(!f.equals(e,this._pivot)){var r=[this._pivot[0],this._pivot[1]];f.copy(this._pivot,e),this._lxformDirty=!0,s(this._children),this.fire(t,{attr:"pivot",prevVal:r,currVal:e})}return this},get:function(){return f.clone(this._pivot)}}]),e}())}Object.defineProperty(e,"__esModule",{value:!0});var u=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}();e.buildXformMatrix=o,e.createEventedTransform2dMixin=l;var c=r(4),f=a(c),h=r(1),d=r(8),p=n(d),_=r(6),v=n(_),y=function(){function t(e){i(this,t),this.initializer(e)}return u(t,[{key:"_initTransformFromOptions",value:function(t){t&&("undefined"!=typeof t.position&&this.setPosition(t.position),"undefined"!=typeof t.scale&&this.setScale(t.scale),"undefined"!=typeof t.rotation&&this.setRotation(t.rotation),"undefined"!=typeof t.pivot&&(this.pivot=t.pivot))}},{key:"initializer",value:function(t){this._localXform=h.mat2d.create(),this._lxformDirty=!1,this._pivot=f.create(0,0),this._pos=f.create(0,0),this._scale=h.vec2.fromValues(1,1),this._rotDeg=0,this._globalXform=h.mat2d.create(),this._xformDirty=!1,this._parent=null,this._children=new Set,this._initTransformFromOptions(t)}},{key:"addChildXform",value:function(t){this._children.has(t)||(this._children.add(t),t._parent&&t._parent.removeChild(t),t._parent=this,t._xformDirty=!0,s(t._children))}},{key:"removeChildXform",value:function(t){this._children.delete(t)}},{key:"unparentXform",value:function(){this._parent&&(this._parent.removeChild(this),this._parent=null,h.mat2d.copy(this._globalXform,this.localXform))}},{key:"getPosition",value:function(){return h.vec2.clone(this._pos)}},{key:"getPositionRef",value:function(){return this._pos}},{key:"getWorldPosition",value:function(){var t=this.globalXform;return f.create(t[4],t[5])}},{key:"setPosition",value:function(t){f.copy(this._pos,t),this._lxformDirty=!0,s(this._children)}},{key:"translate",value:function(t){return(t[0]||t[1])&&(f.addVec2(this._pos,this._pos,t),this._lxformDirty=!0,s(this._children)),this}},{key:"getScale",value:function(){return h.vec2.clone(this._scale)}},{key:"getScaleRef",value:function(){return this._scale}},{key:"setScale",value:function(t){return h.vec2.copy(this._scale,t),this._lxformDirty=!0,s(this._children),this}},{key:"scale",value:function(t){return 1===t[0]&&1===t[1]||(h.vec2.multiply(this._scale,this._scale,t),this._lxformDirty=!0,s(this._children)),this}},{key:"getRotation",value:function(){return this._rotDeg}},{key:"setRotation",value:function(t){return this._rotDeg=t,this._lxformDirty=!0,s(this._children),this}},{key:"rotate",value:function(t){return t&&(this._rotDeg+=t,this._lxformDirty=!0,s(this._children)),this}},{key:"_dirtyChildren",value:function(){s(this._children)}},{key:"_updatelocalxform",value:function(){this._lxformDirty&&(o(this._localXform,this._rotDeg,this._scale,this._pos,this._pivot),this._localXformUpdated&&this._localXformUpdated(),this._lxformDirty=!1)}},{key:"_updateglobalxform",value:function(){(this._lxformDirty||this._xformDirty)&&(this._updatelocalxform(),this._parent?h.mat2d.multiply(this._globalXform,this._parent.globalXform,this._localXform):h.mat2d.copy(this._globalXform,this._localXform),this._globalXformUpdated&&this._globalXformUpdated(),this._xformDirty=!1)}},{key:"transformCtx",value:function(t,e,r){h.mat2d.multiply(e,r,this.globalXform),t.setTransform(e[0],e[1],e[2],e[3],e[4],e[5])}},{key:"pivot",set:function(t){return f.copy(this._pivot,t),this._lxformDirty=!0,s(this._children),this},get:function(){return f.clone(this._pivot)}},{key:"pivotRef",get:function(){return this._pivot}},{key:"parent",get:function(){return this._parent}},{key:"localXform",get:function(){return this._updatelocalxform(),this._localXform}},{key:"globalXform",get:function(){return this._updateglobalxform(),this._globalXform}}],[{key:"toJSON",value:function(t){var e=t.getPositionRef(),r=t.getScaleRef(),n=t.pivotRef;return{position:[e[0],e[1]],scale:[r[0],r[1]],rotation:t.getRotation(),pivot:[n[0],n[1]]}}}]),t}();e.default=y},function(t,e){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function n(t,e,r,a){var i=this;if(r>=e.length)return 0;var o=0,s=null;return s=t.get(e[r]),s&&(o=n(s[0],e,r+1,a),s[1].forEach(function(t){return t.call(i,a)}),o+=s[1].length),o}function a(t,e){var r=-1,n=t[0],i=t[1];i.length&&e.forEach(function(t){(r=i.indexOf(t))>=0&&i.splice(r,1)}),n.forEach(function(t){a(t,e)})}function i(t){var e=t;if("string"==typeof t)e=[t];else if(!Array.isArray(t))throw new Error("Input must be an array of strings");return e}Object.defineProperty(e,"__esModule",{value:!0});var o=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),s=function(){function t(e){r(this,t),this.initializer(e)}return o(t,[{key:"initializer",value:function(t){this._listeners=new Map,this.registerEvents(t)}},{key:"registerEvents",value:function(t){var e=this;if(t){var r=i(t);if("string"==typeof t)r=[t];else if(!Array.isArray(t))throw new Error("Events must be an array of strings");r.forEach(function(t){for(var r=t.split(":"),n=e._listeners,a=0;a<r.length;a+=1){var i=n.get(r[a]);i||(i=[new Map,[]],n.set(r[a],i)),n=i[0]}})}}},{key:"on",value:function(t,e){var r=this,n=i(t);return n.forEach(function(t){var n=t.split(":"),a=r._listeners,i=null;n.forEach(function(e){if(i=a.get(e),!i){var r=[];throw a.forEach(function(t,e){return r.push(e)}),new Error(t+" is not a valid event type. The registered event types at this level are ["+r+"]")}a=i[0]}),i[1].indexOf(e)<0&&i[1].push(e);
}),this}},{key:"off",value:function(t,e){var r=this,n=i(t),o=e;return Array.isArray(o)||(o=[e]),n.forEach(function(t){var e=t.split(":"),n=r._listeners,i=null,s=0;for(s=0;s<e.length&&(i=n.get(e[s]),i);s+=1)n=i[0];i&&a(i,o)}),this}},{key:"once",value:function(t,e){var r=this,n=function n(a){r.off(t,n),e.call(r,a)};return this.on(t,n),this}},{key:"fire",value:function(t,e){var r=t.split(":"),a={type:t,target:this};return Object.assign(a,e),n(this._listeners,r,0,a),this._eventParent&&(a={},Object.getOwnPropertyNames(e).forEach(function(t){a[t]=e[t]}),this._eventParent.fire(t,a)),this}},{key:"listens",value:function(t){for(var e=t.split(":"),r=this._listeners,n=null,a=0;a<e.length&&(n=r.get(e[a]),n);a+=1)r=n[0];return n||this._eventParent&&this._eventParent.listens(t)}},{key:"setEventedParent",value:function(t,e){return this._eventParent=t,this._eventParentData=e,this}}]),t}();e.default=s},function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function a(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function l(t,e){t&&(" "+t.className+" ").indexOf(" "+e+" ")<0&&(t.className+=(t.className?" ":"")+e)}function u(t){var e=document.createElement("div");l(e,"mapd-draw-canvas-container");var r=document.createElement("canvas"),n=r.getContext("2d"),a=p.makeCanvasAutoHighDPI(n);return l(r,"mapd-draw-canvas"),r.style.position="absolute",r.style.pointerEvents="none",e.appendChild(r),t.appendChild(e),{canvasContainer:e,canvas:r,canvasContext:n,ratio:a}}function c(t,e,r,n,a){t.forEach(function(t){e.set(t,{shapeObj:t,shapeId:r.shapeId,shapeIdx:-1}),t.on(["changed:order","changed:visibility","changed:style"],n),t.on(["changed:geom","changed:visibility","changed:xform"],a),r.shapeId+=1})}function f(t,e,r,n){var a=[];return t.forEach(function(t){var i=e.get(t);i&&a.push(i.shapeIdx),e.delete(t),t.off(["changed"],[r,n])}),a}Object.defineProperty(e,"__esModule",{value:!0}),e.EventConstants=void 0;var h=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),d=r(30),p=a(d),_=r(4),v=a(_),y=r(7),m=n(y),M=r(9),b=n(M),x=r(31),g=r(32),S=n(g),I=r(13),D=n(I),w=r(33),F=n(w),O=["mousedown","mouseup","mousemove","click","dblclick","mouseover","mouseout"],k=["top","bottom","left","right"],E=e.EventConstants={MOUSEDOWN:"mousedown",MOUSEUP:"mouseup",MOUSEMOVE:"mousemove",CLICK:"click",DBLCLICK:"dblclick",MOUSEOVER:"mouseover",MOUSEOUT:"mouseout",SHAPE_ADD:"shape:add",SHAPE_DELETE:"shape:delete"},P=function(t){function e(){var t;i(this,e);for(var r=arguments.length,n=Array(r),a=0;a<r;a++)n[a]=arguments[a];var s=o(this,(t=e.__proto__||Object.getPrototypeOf(e)).call.apply(t,[this].concat(n)));return s._defaults={packedFillColor:s.packedFillColor,packedStrokeColor:s.packedStrokeColor,strokeWidth:s.strokeWidth,lineJoin:s.lineJoin,lineCap:s.lineCap,dashPattern:s.dashPattern,dashOffset:s.dashOffset},s}return s(e,t),h(e,[{key:"setFillStyle",value:function(t,e){e.packedFillColor!==this.packedFillColor&&(this.packedFillColor=e.packedFillColor,t.fillStyle=this.fillColor)}},{key:"setStrokeStyle",value:function(t,e){e.packedStrokeColor!==this.packedStrokeColor&&(this.packedStrokeColor=e.packedStrokeColor,t.strokeStyle=this.strokeColor),e.strokeWidth!==this._strokeWidth&&(this.strokeWidth=e.strokeWidth,t.lineWidth=this._strokeWidth),e.lineJoin!==this._lineJoin&&(this.lineJoin=e.lineJoin,t.lineJoin=this._lineJoin),e.lineCap!==this._lineCap&&(this.lineCap=e.lineCap,t.lineCap=this._lineCap);var r=e._dashPattern,n=!1;if(r.length===this._dashPattern.length){for(var a=0;a<r.length;a+=1)if(r[a]!==this._dashPattern[a]){n=!0;break}}else n=!0;n&&(this.dashPattern=r,t.setLineDash(this._dashPattern)),e.dashOffset!==this._dashOffset&&(this.dashOffset=e.dashOffset,t.lineDashOffset=this._dashOffset)}},{key:"applyDefaults",value:function(t){var e=this;Object.getOwnPropertyNames(this._defaults).forEach(function(t){e[t]=e._defaults[t]}),this.setFillCtx(t),this.setStrokeCtx(t)}}]),e}(b.default),C=function(t){function e(t,r){i(this,e);var n=o(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return n._init(t,r),n}return s(e,t),h(e,[{key:"destroy",value:function(){var t=this;this._destroyCanvas(),this._objects&&(this._objects.forEach(function(e,r){r.off("changed",[t._reorderCb,t._redrawCb])}),this._objects.clear(),this._sortedObjs=[],this._reorderedObjIdxs.clear())}},{key:"_resize",value:function(t){var e=0;this._parent.offsetWidth&&(e=Math.max(e,this._parent.offsetWidth-this._margins.left-this._margins.right));var r=0;if(this._parent.offsetHeight&&(r=Math.max(r,this._parent.offsetHeight-this._margins.top-this._margins.bottom)),this._drawCanvas.width=e*this._pixelRatio,this._drawCanvas.height=r*this._pixelRatio,this._drawCanvas.style.left=this._margins.left+"px",this._drawCanvas.style.top=this._margins.top+"px",this._drawCanvas.style.width=e+"px",this._drawCanvas.style.height=r+"px",this._camera);else{var n=t&&t.projectionDimensions?t.projectionDimensions:[e,r];this._camera=new S.default([0,0,e,r],n,!!t.flipY&&Boolean(t.flipY)),this._camera.setPosition(t&&t.cameraPosition?t.cameraPosition:[e/2,r/2]),this._camera.on("changed",this._rerenderCb)}this._rerenderCb()}},{key:"_mousedownCB",value:function(t){t.target===this._parent&&this.fire("mousedown",{originalEvent:t})}},{key:"_mouseupCB",value:function(t){t.target===this._parent&&this.fire("mouseup",{originalEvent:t})}},{key:"_mousemoveCB",value:function(t){t.target===this._parent&&this.fire("mousemove",{originalEvent:t})}},{key:"_clickCB",value:function(t){t.target===this._parent&&this.fire("click",{originalEvent:t})}},{key:"_dblclickCB",value:function(t){t.target===this._parent&&this.fire("dblclick",{originalEvent:t})}},{key:"_mouseoverCB",value:function(t){t.target===this._parent&&this.fire("mouseover",{originalEvent:t})}},{key:"_mouseoutCB",value:function(t){t.target===this._parent&&this.fire("mouseout",{originalEvent:t})}},{key:"_enableEvents",value:function(){this.registerEvents(O);for(var t=O.map(function(t){return"_"+t+"CB"}),e=0;e<O.length;e+=1)document.addEventListener(O[e],this[t[e]],!0)}},{key:"_disableEvents",value:function(){for(var t=O.map(function(t){return"_"+t+"CB"}),e=0;e<O.length;e+=1)document.removeEventListener(O[e],this[t[e]],!0)}},{key:"_initCanvas",value:function(t,e){var r=this,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;this._margins=e&&e.margins?Object.assign({},e.margins):{},k.forEach(function(t){"number"!=typeof r._margins[t]&&(r._margins[t]=0)});var a=u(t),i=a.canvasContainer,o=a.canvas,s=a.canvasContext,l=a.ratio;this._container=i,this._drawCanvas=o,this._drawCtx=s,this._pixelRatio=l,this._parent=t,(0,x.bindAll)(["_resize"],this),this._resize(e),this._resizeSensor=new F.default(t,this._resize),(n||null===n&&e&&e.enableEvents)&&this._enableEvents()}},{key:"_destroyCanvas",value:function(){this._drawCanvas&&this._disableEvents(),this._parent&&(this._parent.removeChild(this._drawCanvas),this._resizeSensor&&this._resizeSensor.detach(this._parent,this._resize)),this._drawCanvas=null,this._drawCtx=null,this._parent=null}},{key:"_init",value:function(t,e){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;this.registerEvents([E.SHAPE_ADD,E.SHAPE_DELETE]),(0,x.bindAll)(["_reorderCb","_rerenderCb"],this),(0,x.bindAll)(["_mousedownCB","_mouseupCB","_mousemoveCB","_clickCB","_dblclickCB","_mouseoverCB","_mouseoutCB"],this),this._renderFrameCb=this.renderAll.bind(this),this._renderRequestId=0,this._ids={shapeId:1},this._objects=new Map,this._sortedObjs=[],this._reorderedObjIdxs=new Set,this._initCanvas(t,e,r),this._styleState=new P({fillColor:"red"})}},{key:"getContainer",value:function(){return this._parent}},{key:"getCanvasContainer",value:function(){return this._container}},{key:"getCanvas",value:function(){return this._drawCanvas}},{key:"project",value:function(t,e){var r=this._camera.screenToWorldMatrix;return v.transformMat2d(t,e,r)}},{key:"unproject",value:function(t,e){var r=this._camera.worldToScreenMatrix;return v.transformMat2d(t,e,r)}},{key:"hasShape",value:function(t){return this._objects.has(t)}},{key:"addShape",value:function(t){var e=t;Array.isArray(e)||(e=[t]),c(e,this._objects,this._ids,this._reorderCb,this._rerenderCb),this.fire("shape:add",{shape:e});var r={target:e};return this._reorderCb(r),this}},{key:"deleteShape",value:function(t){var e=t;Array.isArray(e)||(e=[t]);for(var r=f(e,this._objects,this._reorderCb,this._rerenderCb),n=-1,a=0;a<e.length;a+=1)(n=this._sortedObjs.indexOf(e[a]))>=0&&this._sortedObjs.splice(n,1),this._reorderedObjIdxs.add(r[a]);return this._rerenderCb(),this.fire("shape:delete",{shape:e}),this}},{key:"deleteAllShapes",value:function(){return this.deleteShape(this.sortedShapes.slice()),this}},{key:"moveShapeToTop",value:function(t){if(this._objects.has(t)){var e=this.sortedShapes,r=e[e.length-1].zIndex;t.zIndex=r+1}}},{key:"moveShapeToBack",value:function(t){if(this._objects.has(t)){var e=this.sortedShapes,r=e[0].zIndex;t.zIndex=r}}},{key:"getShapesAsJSON",value:function(){var t=this.sortedShapes;return t.map(function(t){return t.toJSON()})}},{key:"_rerenderCb",value:function(){this._renderRequestId&&window.cancelAnimationFrame(this._renderRequestId),this._renderRequestId=window.requestAnimationFrame(this._renderFrameCb)}},{key:"_reorderCb",value:function(t){var e=this,r=t.target;Array.isArray(r)||(r=[t.target]),r.forEach(function(t){console.assert(t,"A changed event doesn't have an object");var r=e._objects.get(t);console.assert(r,"A changed event target isn't in the list of shapes "+t),r.shapeIdx<0&&(r.shapeIdx=e._sortedObjs.push(t)-1),e._reorderedObjIdxs.add(r.shapeIdx)}),this._rerenderCb()}},{key:"_renderShapes",value:function(t,e,r){var n=this,a=r.worldToScreenMatrix;e.forEach(function(e){e.visible&&e.render(t,a,n._styleState)})}},{key:"renderAll",value:function(){var t=this._drawCtx;if(t.clearRect(0,0,this._drawCanvas.offsetWidth,this._drawCanvas.offsetHeight),this._objects.size){t.save();var e=this.sortedShapes;this._styleState.applyDefaults(t),this._renderShapes(t,e,this._camera),t.restore()}}},{key:"sortedShapes",get:function(){return this._reorderedObjIdxs.size&&(console.assert(this._sortedObjs.length===this._objects.size,"Size mismatch when rendering objets. Something got out of sync - sorted objs length: "+this._sortedObjs.length+", objects length: "+this._objects.size),this._sortedObjs.sort(m.default.shapeCompare),this._reorderedObjIdxs.clear()),this._sortedObjs}},{key:"margins",get:function(){var t=this,e={};return k.forEach(function(r){e[r]=t._margins[r]}),e},set:function(t){var e=this;k.forEach(function(r){"number"==typeof t[r]&&t[r]!==e._margins[r]&&(e._margins[r]=t.prop)}),this._resize()}},{key:"viewport",get:function(){return this._camera.viewport},set:function(t){this._camera.viewport=t}},{key:"projectionDimensions",get:function(){return this._camera.projectionDimensions},set:function(t){return this._camera.projectionDimensions=t,this}},{key:"cameraPosition",get:function(){return this._camera.getPosition()},set:function(t){return this._camera.setPosition(t),this}}]),e}(D.default);e.default=C,C.EventConstants=E},function(t,e){"use strict";function r(t,e,r){return(e[a]-t[a])*(r[i]-t[i])-(r[a]-t[a])*(e[i]-t[i])}function n(t){var e=[],n=t.length;if(n<3){for(var a=0;a<n;a+=1)e[a]=a;return e}var i=new Array(2*n+1);i.fill(-1);var o=n-2,s=o+3;i[o]=i[s]=2,r(t[0],t[1],t[2])>0?(i[o+1]=0,i[o+2]=1):(i[o+1]=1,i[o+2]=0);for(var l=3;l<n;l+=1)if(r(t[i[o]],t[i[o+1]],t[l])<=0||r(t[i[s-1]],t[i[s]],t[l])<=0){for(;i[o]>=0&&i[o+1]>=0&&r(t[i[o]],t[i[o+1]],t[l])<=0;)o+=1;for(o-=1,i[o]=l;i[s]>=0&&i[s+1]>=0&&r(t[i[s-1]],t[i[s]],t[l])<=0;)s-=1;s+=1,i[s]=l}var u=0;for(u=0;u<=s-o-1;u+=1)e[u]=i[o+u];return i[o+u]!==e[0]&&(e[u]=i[o+u]),e}Object.defineProperty(e,"__esModule",{value:!0}),e.simpleHull_2D=n;var a=0,i=1},function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function a(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var l=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),u=function t(e,r,n){null===e&&(e=Function.prototype);var a=Object.getOwnPropertyDescriptor(e,r);if(void 0===a){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,r,n)}if("value"in a)return a.value;var o=a.get;if(void 0!==o)return o.call(n)},c=r(2),f=a(c),h=r(7),d=n(h),p=function(t){function e(t){i(this,e);var r=o(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));return r._width=0,r._height=0,"undefined"!=typeof t.width&&(r.width=t.width),"undefined"!=typeof t.height&&(r.height=t.height),r}return s(e,t),l(e,[{key:"getDimensions",value:function(){return[this._width,this._height]}},{key:"_updateAABox",value:function(){(this._geomDirty||this._boundsOutOfDate)&&(f.initCenterExtents(this._aabox,[0,0],[this._width/2,this._height/2]),f.transformMat2d(this._aabox,this._aabox,this.globalXform),this._geomDirty=this._boundsOutOfDate=!1)}},{key:"_draw",value:function(t){t.rect(0-this.width/2,0-this.height/2,this.width,this.height)}},{key:"toJSON",value:function(){return Object.assign({type:"Rect",width:this.width,height:this.height},u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"toJSON",this).call(this))}},{key:"width",set:function(t){if("number"!=typeof t)throw new Error("Width must be a number");if(t!==this._width){var e=this._width;this._width=t,this._geomDirty=!0,this.fire("changed:geom",{attr:"width",prevVal:e,currVal:this._width})}return this},get:function(){return this._width}},{key:"height",set:function(t){if("number"!=typeof t)throw new Error("Height must be a number");if(t!==this._height){var e=this._height;this._height=t,this._geomDirty=!0,this.fire("changed:geom",{attr:"height",prevVal:e,currVal:this._height})}return this},get:function(){return this._height}}]),e}(d.default);e.default=p},function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function s(t){return(255&t)/255}function l(t){return _.default.floor(255*_.default.clamp01(t))}function u(t){return"rgba("+(t>>>24)+", "+((16711680&t)>>16)+", "+((65280&t)>>8)+", "+s(t)+")"}function c(t){if("string"!=typeof t)throw new Error(t+" is not a valid color string");var e=0,r=null;if(r=t.match(y))e=255,e|=_.default.clamp(Number.parseInt(r[3],10),0,255)<<8,e|=_.default.clamp(Number.parseInt(r[2],10),0,255)<<16,e|=_.default.clamp(Number.parseInt(r[1],10),0,255)<<24;else if(r=t.match(m))e=l(Number.parseFloat(r[4],10)),e|=_.default.clamp(Number.parseInt(r[3],10),0,255)<<8,e|=_.default.clamp(Number.parseInt(r[2],10),0,255)<<16,e|=_.default.clamp(Number.parseInt(r[1],10),0,255)<<24;else if(r=t.match(M))e=255,e|=_.default.clamp(Number.parseInt(r[3],16),0,255)<<8,e|=_.default.clamp(Number.parseInt(r[2],16),0,255)<<16,e|=_.default.clamp(Number.parseInt(r[1],16),0,255)<<24;else{if(!v.has(t))throw new Error(t+" is not a valid color string");r=v.get(t).match(M),e=255,e|=_.default.clamp(Number.parseInt(r[3],16),0,255)<<8,e|=_.default.clamp(Number.parseInt(r[2],16),0,255)<<16,e|=_.default.clamp(Number.parseInt(r[1],16),0,255)<<24}return e}function f(t,e){return function(r){function n(){return o(this,n),a(this,(n.__proto__||Object.getPrototypeOf(n)).apply(this,arguments))}return i(n,r),d(n,[{key:"initializer",value:function(t,e){this._eventHandler=e,h(n.prototype.__proto__||Object.getPrototypeOf(n.prototype),"initializer",this).call(this,t)}},{key:"_checkPackedColorChanged",value:function(r){if(r!==this._color){var n=this._color,a=s(n),i=s(r);this._color=r,this._eventHandler.fire(t,{attr:e,prevVal:u(n),currVal:u(this._color)}),i!==a&&this._eventHandler.fire(t,{attr:"opacity",prevVal:a,currVal:i})}}},{key:"value",set:function(t){var e=c(t);return this._checkPackedColorChanged(e),this},get:function(){return u(this._color)}},{key:"packedValue",set:function(t){var e=0;return e|=t,this._checkPackedColorChanged(e),this},get:function(){return this._color}},{key:"opacity",set:function(e){if("number"!=typeof e)throw new Error("Opacity must be a number between 0-1");var r=255&this._color,n=l(e);return n!==r&&(this._color&=4294967040,this._color|=n,this._eventHandler.fire(t,{attr:"opacity",prevVal:r/255,currVal:n/255})),this},get:function(){return s(this._color)}}]),n}(b)}Object.defineProperty(e,"__esModule",{value:!0});var h=function t(e,r,n){null===e&&(e=Function.prototype);var a=Object.getOwnPropertyDescriptor(e,r);if(void 0===a){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,r,n)}if("value"in a)return a.value;var o=a.get;if(void 0!==o)return o.call(n)},d=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}();e.createEventedColorRGBAClass=f;var p=r(6),_=n(p),v=new Map([["aliceblue","#F0F8FF"],["antiquewhite","#FAEBD7"],["aqua","#00FFFF"],["aquamarine","#7FFFD4"],["azure","#F0FFFF"],["beige","#F5F5DC"],["bisque","#FFE4C4"],["black","#000000"],["blanchedalmond","#FFEBCD"],["blue","#0000FF"],["blueviolet","#8A2BE2"],["brown","#A52A2A"],["burlywood","#DEB887"],["cadetblue","#5F9EA0"],["chartreuse","#7FFF00"],["chocolate","#D2691E"],["coral","#FF7F50"],["cornflowerblue","#6495ED"],["cornsilk","#FFF8DC"],["crimson","#DC143C"],["cyan","#00FFFF"],["darkblue","#00008B"],["darkcyan","#008B8B"],["darkgoldenrod","#B8860B"],["darkgray","#A9A9A9"],["darkgreen","#006400"],["darkkhaki","#BDB76B"],["darkmagenta","#8B008B"],["darkolivegreen","#556B2F"],["darkorange","#FF8C00"],["darkorchid","#9932CC"],["darkred","#8B0000"],["darksalmon","#E9967A"],["darkseagreen","#8FBC8F"],["darkslateblue","#483D8B"],["darkslategray","#2F4F4F"],["darkturquoise","#00CED1"],["darkviolet","#9400D3"],["deeppink","#FF1493"],["deepskyblue","#00BFFF"],["dimgray","#696969"],["dodgerblue","#1E90FF"],["firebrick","#B22222"],["floralwhite","#FFFAF0"],["forestgreen","#228B22"],["fuchsia","#FF00FF"],["gainsboro","#DCDCDC"],["ghostwhite","#F8F8FF"],["gold","#FFD700"],["goldenrod","#DAA520"],["gray","#808080"],["green","#008000"],["greenyellow","#ADFF2F"],["honeydew","#F0FFF0"],["hotpink","#FF69B4"],["indianred","#CD5C5C"],["indigo","#4B0082"],["ivory","#FFFFF0"],["khaki","#F0E68C"],["lavender","#E6E6FA"],["lavenderblush","#FFF0F5"],["lawngreen","#7CFC00"],["lemonchiffon","#FFFACD"],["lightblue","#ADD8E6"],["lightcoral","#F08080"],["lightcyan","#E0FFFF"],["lightgoldenrodyellow","#FAFAD2"],["lightgray","#D3D3D3"],["lightgreen","#90EE90"],["lightpink","#FFB6C1"],["lightsalmon","#FFA07A"],["lightseagreen","#20B2AA"],["lightskyblue","#87CEFA"],["lightslategray","#778899"],["lightsteelblue","#B0C4DE"],["lightyellow","#FFFFE0"],["lime","#00FF00"],["limegreen","#32CD32"],["linen","#FAF0E6"],["magenta","#FF00FF"],["maroon","#800000"],["mediumaquamarine","#66CDAA"],["mediumblue","#0000CD"],["mediumorchid","#BA55D3"],["mediumpurple","#9370DB"],["mediumseagreen","#3CB371"],["mediumslateblue","#7B68EE"],["mediumspringgreen","#00FA9A"],["mediumturquoise","#48D1CC"],["mediumvioletred","#C71585"],["midnightblue","#191970"],["mintcream","#F5FFFA"],["mistyrose","#FFE4E1"],["moccasin","#FFE4B5"],["navajowhite","#FFDEAD"],["navy","#000080"],["oldlace","#FDF5E6"],["olive","#808000"],["olivedrab","#6B8E23"],["orange","#FFA500"],["orangered","#FF4500"],["orchid","#DA70D6"],["palegoldenrod","#EEE8AA"],["palegreen","#98FB98"],["paleturquoise","#AFEEEE"],["palevioletred","#DB7093"],["papayawhip","#FFEFD5"],["peachpuff","#FFDAB9"],["peru","#CD853F"],["pink","#FFC0CB"],["plum","#DDA0DD"],["powderblue","#B0E0E6"],["purple","#800080"],["rebeccapurple","#663399"],["red","#FF0000"],["rosybrown","#BC8F8F"],["royalblue","#4169E1"],["saddlebrown","#8B4513"],["salmon","#FA8072"],["sandybrown","#F4A460"],["seagreen","#2E8B57"],["seashell","#FFF5EE"],["sienna","#A0522D"],["silver","#C0C0C0"],["skyblue","#87CEEB"],["slateblue","#6A5ACD"],["slategray","#708090"],["snow","#FFFAFA"],["springgreen","#00FF7F"],["steelblue","#4682B4"],["tan","#D2B48C"],["teal","#008080"],["thistle","#D8BFD8"],["tomato","#FF6347"],["turquoise","#40E0D0"],["violet","#EE82EE"],["wheat","#F5DEB3"],["white","#FFFFFF"],["whitesmoke","#F5F5F5"],["yellow","#FFFF00"],["yellowgreen","#9ACD32"]]),y=/^rgb\s*\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)\s*$/i,m=/^rgba\s*\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*([0,1](?:\.\d*)?)\s*\)\s*$/i,M=/^#([0-9,a-f,A-F]{2})([0-9,a-f,A-F]{2})([0-9,a-f,A-F]{2})\s*$/i,b=function(){function t(e){o(this,t);for(var r=arguments.length,n=Array(r>1?r-1:0),a=1;a<r;a++)n[a-1]=arguments[a];this.initializer.apply(this,[e].concat(n))}return d(t,[{key:"initializer",value:function(t){this._color=0,t&&(this.value=t)}},{key:"isTransparent",value:function(){return s(this._color)<1}},{key:"value",set:function(t){return this._color=c(t),this},get:function(){return u(this._color)}},{key:"packedValue",set:function(t){return this._color=0,this._color|=t,this},get:function(){return this._color}},{key:"opacity",set:function(t){if("number"!=typeof t)throw new Error("Opacity must be a number between 0-1");var e=255&this._color,r=l(t);return r!==e&&(this._color&=4294967040,this._color|=r),this},get:function(){return s(this._color)}}]),t}();e.default=b},function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function a(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t){var e=(0,s.createEventedColorRGBAClass)(t,"fillColor");return(0,c.default)(null,f,function(){function t(){a(this,t)}return o(t,[{key:"initializer",value:function(t){this._fillColor=new e("red",this),this._initFillStyleFromOptions(t)}}]),t}())}Object.defineProperty(e,"__esModule",{value:!0});var o=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}();e.createEventedFillStyleMixin=i;var s=r(17),l=n(s),u=r(8),c=n(u),f=function(){function t(e){a(this,t),this.initializer(e)}return o(t,[{key:"_initFillStyleFromOptions",value:function(t){t&&("undefined"!=typeof t.fillColor&&(this.fillColor=t.fillColor),"undefined"!=typeof t.fillOpacity&&(this.fillOpacity=t.fillOpacity))}},{key:"initializer",value:function(t){this._fillColor=new l.default("black"),this._initFillStyleFromOptions(t)}},{key:"isFillVisible",value:function(){return this._fillColor.opacity>0}},{key:"isTransparent",value:function(){return this._fillColor.isTransparent()}},{key:"setFillCtx",value:function(t){t.fillStyle=this.fillColor}},{key:"fillColor",set:function(t){return this._fillColor.value=t,this},get:function(){return this._fillColor.value}},{key:"fillOpacity",set:function(t){return this._fillColor.opacity=t,this},get:function(){return this._fillColor.opacity}},{key:"packedFillColor",set:function(t){return this._fillColor.packedValue=t,this},get:function(){return this._fillColor.packedValue}}],[{key:"copyFillStyle",value:function(t,e){"undefined"==typeof t.packedFillColor?("undefined"!=typeof t.fillColor&&(e.fillColor=t.fillColor),"undefined"!=typeof t.fillOpacity&&(e.fillOpacity=t.fillOpacity)):e.packedFillColor=t.packedFillColor}},{key:"compareFillStyle",value:function(t,e){var r=t.isFillVisible(),n=e.isFillVisible();return r!==n?r-n:t.packedFillColor-e.packedFillColor}},{key:"toJSON",value:function(t){return{fillColor:t.fillColor}}}]),t}();e.default=f},function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function a(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t){if("number"!=typeof t)throw new Error("Stroke width must be a number")}function o(t){var e=-1;if("string"!=typeof t||(e=y.indexOf(t.toLowerCase()))<0)throw new Error("Line join must be a string and must be one of ["+y.join(", ")+"]");return e}function s(t){var e=-1;if("string"!=typeof t||(e=M.indexOf(t.toLowerCase()))<0)throw new Error("Line cap must be a string and must be one of ["+M.join(", ")+"]");return e}function l(t){if(!t||!Array.isArray(t)||t.length%2!==0)throw new Error("The dash pattern must be an array with an even number of numbers (or an empty array)")}function u(t){if("number"!=typeof t)throw new Error("The dash offset must be a number")}function c(t){var e=(0,h.createEventedColorRGBAClass)(t,"strokeColor");return(0,_.default)(null,b,function(){function r(){a(this,r)}return f(r,[{key:"initializer",value:function(t){this._strokeColor=new e("black",this),this._strokeWidth=0,this._lineJoin=v.MITER,this._lineCap=m.BUTT,this._dashPattern=[],this._dashOffset=0,this._initStrokeStyleFromOptions(t)}},{key:"strokeWidth",set:function(e){if(i(e),e!==this._strokeWidth){var r=this._strokeWidth;this._strokeWidth=e,this.fire(t,{attr:"strokeWidth",prevVal:r,curral:this._strokeWidth})}return this},get:function(){return this._strokeWidth}},{key:"lineJoin",set:function(e){var r=o(e);if(r!==this._lineJoin){var n=this._lineJoin;this._lineJoin=r,this.fire(t,{attr:"lineJoin",prevVal:n,curral:this._lineJoin})}return this},get:function(){return y[this._lineJoin]}},{key:"lineCap",set:function(e){var r=s(e);if(r!==this._lineCap){var n=this._lineCap;this._lineCap=r,this.fire(t,{attr:"lineCap",prevVal:n,curral:this._lineCap})}return this},get:function(){return M[this._lineCap]}},{key:"dashPattern",set:function(e){l(e);var r=!1;if(e.length===this._dashPattern.length){for(var n=0;n<e.length;n+=1)if(e[n]!==this._dashPattern[n]){r=!0;break}}else r=!0;if(r){var a=this._dashPattern;this._dashPattern=e.slice(),this.fire(t,{attr:"dashPattern",prevVal:a,curral:this._dashPattern.slice()})}return this},get:function(){return this._dashPattern.slice()}},{key:"dashOffset",set:function(e){if(u(e),e!==this._dashOffset){var r=this._dashOffset;this._dashOffset=e,this._dashPattern.length&&this.fire(t,{attr:"dashOffset",prevVal:r,curral:this._dashOffset})}return this},get:function(){return this._dashOffset}}]),r}())}Object.defineProperty(e,"__esModule",{value:!0});var f=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}();e.createEventedStrokeStyleMixin=c;var h=r(17),d=n(h),p=r(8),_=n(p),v={MITER:0,BEVEL:1,ROUND:2},y=["miter","bevel","round"],m={BUTT:0,SQUARE:1,ROUND:2},M=["butt","square","round"],b=function(){function t(e){a(this,t),this.initializer(e)}return f(t,[{key:"_initStrokeStyleFromOptions",value:function(t){t&&("undefined"!=typeof t.strokeColor&&(this.strokeColor=t.strokeColor),"undefined"!=typeof t.strokeOpacity&&(this.strokeOpacity=t.strokeOpacity),"undefined"!=typeof t.strokeWidth&&(this.strokeWidth=t.strokeWidth),"undefined"!=typeof t.lineMiter&&(this.lineJoin=t.lineMiter),"undefined"!=typeof t.lineCap&&(this.lineCap=t.lineCap),"undefined"!=typeof t.dashPattern&&(this.dashPattern=t.dashPattern),"undefined"!=typeof t.dashOffset&&(this.dashOffset=t.dashOffset))}},{key:"initializer",value:function(t){this._strokeColor=new d.default("black"),this._strokeWidth=0,this._lineJoin=v.MITER,this._lineCap=m.BUTT,this._dashPattern=[],this._dashOffset=0,this._initStrokeStyleFromOptions(t)}},{key:"isStrokeVisible",value:function(){return this._strokeColor.opacity>0&&this._strokeWidth>0}},{key:"isTransparent",value:function(){return this._strokeColor.isTransparent()}},{key:"setStrokeCtx",value:function(t){t.strokeStyle=this.strokeColor,t.lineWidth=this._strokeWidth,t.lineJoin=this._lineJoin,t.lineCap=this._lineCap,t.setLineDash(this._dashPattern),t.lineDashOffset=this._dashOffset}},{key:"strokeColor",set:function(t){return this._strokeColor.value=t,this},get:function(){return this._strokeColor.value}},{key:"strokeOpacity",set:function(t){this._strokeColor.opacity=t},get:function(){return this._strokeColor.opacity}},{key:"packedStrokeColor",set:function(t){this._strokeColor.packedValue=t},get:function(){return this._strokeColor.packedValue}},{key:"strokeWidth",set:function(t){return i(t),this._strokeWidth=t,this},get:function(){return this._strokeWidth}},{key:"lineJoin",set:function(t){var e=o(t);return this._lineJoin=e,this},get:function(){return y[this._lineJoin]}},{key:"lineCap",set:function(t){var e=s(t);return this._lineCap=e,this},get:function(){return M[this._lineJoin]}},{key:"dashPattern",set:function(t){return l(t),this._dashPattern=t.slice(),this},get:function(){return this._dashPattern.slice()}},{key:"dashOffset",set:function(t){return u(t),this._dashOffset=t,this},get:function(){return this._dashOffset}}],[{key:"copyStrokeStyle",value:function(t,e){"undefined"==typeof t.packedStrokeColor?("undefined"!=typeof t.strokeColor&&(e.strokeColor=t.strokeColor),"undefined"!=typeof t.strokeOpacity&&(e.strokeOpacity=t.strokeOpacity)):e.packedStrokeColor=t.packedStrokeColor,"undefined"!=typeof t.strokeWidth&&(e.strokeWidth=t.strokeWidth),"undefined"!=typeof t.lineJoin&&(e.lineJoin=t.lineJoin),"undefined"!=typeof t.lineCap&&(e.lineCap=t.lineCap),"undefined"!=typeof t.dashPattern&&(e.dashPattern=t.dashPattern),"undefined"!=typeof t.dashOffset&&(e.dashOffset=t.dashOffset)}},{key:"compareStrokeStyle",value:function(t,e){var r=t.isStrokeVisible(),n=e.isStrokeVisible();if(r!==n)return r-n;if(r=t.packedStrokeColor,n=e.packedStrokeColor,r!==n)return r-n;if(r=t.strokeWidth,n=e.strokeWidth,r!==n)return r-n;if(r=t._lineJoin,n=e._lineJoin,r!==n)return r-n;if(r=t._lineCap,n=e._lineCap,r!==n)return r-n;if(r=t._dashPattern,n=e._dashPattern,r.length===n.length&&r.length>0){for(var a=0;a<r.length;a+=1)if(r[a]!==n[a])return r[a]-n[a];return t.dashOffset-e.dashOffset}return r.length-n.length}},{key:"toJSON",value:function(t){return{strokeColor:t.strokeColor,strokeWidth:t.strokeWidth,lineJoin:t.lineJoin,lineCap:t.lineCap,dashPattern:t.dashPattern,dashOffset:t.dashOffset}}}]),
t}();e.default=b},function(t,e,r){var n=r(3),a={};a.create=function(){var t=new n.ARRAY_TYPE(9);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},a.fromMat4=function(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[4],t[4]=e[5],t[5]=e[6],t[6]=e[8],t[7]=e[9],t[8]=e[10],t},a.clone=function(t){var e=new n.ARRAY_TYPE(9);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e},a.copy=function(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t},a.fromValues=function(t,e,r,a,i,o,s,l,u){var c=new n.ARRAY_TYPE(9);return c[0]=t,c[1]=e,c[2]=r,c[3]=a,c[4]=i,c[5]=o,c[6]=s,c[7]=l,c[8]=u,c},a.set=function(t,e,r,n,a,i,o,s,l,u){return t[0]=e,t[1]=r,t[2]=n,t[3]=a,t[4]=i,t[5]=o,t[6]=s,t[7]=l,t[8]=u,t},a.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},a.transpose=function(t,e){if(t===e){var r=e[1],n=e[2],a=e[5];t[1]=e[3],t[2]=e[6],t[3]=r,t[5]=e[7],t[6]=n,t[7]=a}else t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8];return t},a.invert=function(t,e){var r=e[0],n=e[1],a=e[2],i=e[3],o=e[4],s=e[5],l=e[6],u=e[7],c=e[8],f=c*o-s*u,h=-c*i+s*l,d=u*i-o*l,p=r*f+n*h+a*d;return p?(p=1/p,t[0]=f*p,t[1]=(-c*n+a*u)*p,t[2]=(s*n-a*o)*p,t[3]=h*p,t[4]=(c*r-a*l)*p,t[5]=(-s*r+a*i)*p,t[6]=d*p,t[7]=(-u*r+n*l)*p,t[8]=(o*r-n*i)*p,t):null},a.adjoint=function(t,e){var r=e[0],n=e[1],a=e[2],i=e[3],o=e[4],s=e[5],l=e[6],u=e[7],c=e[8];return t[0]=o*c-s*u,t[1]=a*u-n*c,t[2]=n*s-a*o,t[3]=s*l-i*c,t[4]=r*c-a*l,t[5]=a*i-r*s,t[6]=i*u-o*l,t[7]=n*l-r*u,t[8]=r*o-n*i,t},a.determinant=function(t){var e=t[0],r=t[1],n=t[2],a=t[3],i=t[4],o=t[5],s=t[6],l=t[7],u=t[8];return e*(u*i-o*l)+r*(-u*a+o*s)+n*(l*a-i*s)},a.multiply=function(t,e,r){var n=e[0],a=e[1],i=e[2],o=e[3],s=e[4],l=e[5],u=e[6],c=e[7],f=e[8],h=r[0],d=r[1],p=r[2],_=r[3],v=r[4],y=r[5],m=r[6],M=r[7],b=r[8];return t[0]=h*n+d*o+p*u,t[1]=h*a+d*s+p*c,t[2]=h*i+d*l+p*f,t[3]=_*n+v*o+y*u,t[4]=_*a+v*s+y*c,t[5]=_*i+v*l+y*f,t[6]=m*n+M*o+b*u,t[7]=m*a+M*s+b*c,t[8]=m*i+M*l+b*f,t},a.mul=a.multiply,a.translate=function(t,e,r){var n=e[0],a=e[1],i=e[2],o=e[3],s=e[4],l=e[5],u=e[6],c=e[7],f=e[8],h=r[0],d=r[1];return t[0]=n,t[1]=a,t[2]=i,t[3]=o,t[4]=s,t[5]=l,t[6]=h*n+d*o+u,t[7]=h*a+d*s+c,t[8]=h*i+d*l+f,t},a.rotate=function(t,e,r){var n=e[0],a=e[1],i=e[2],o=e[3],s=e[4],l=e[5],u=e[6],c=e[7],f=e[8],h=Math.sin(r),d=Math.cos(r);return t[0]=d*n+h*o,t[1]=d*a+h*s,t[2]=d*i+h*l,t[3]=d*o-h*n,t[4]=d*s-h*a,t[5]=d*l-h*i,t[6]=u,t[7]=c,t[8]=f,t},a.scale=function(t,e,r){var n=r[0],a=r[1];return t[0]=n*e[0],t[1]=n*e[1],t[2]=n*e[2],t[3]=a*e[3],t[4]=a*e[4],t[5]=a*e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t},a.fromTranslation=function(t,e){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=e[0],t[7]=e[1],t[8]=1,t},a.fromRotation=function(t,e){var r=Math.sin(e),n=Math.cos(e);return t[0]=n,t[1]=r,t[2]=0,t[3]=-r,t[4]=n,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},a.fromScaling=function(t,e){return t[0]=e[0],t[1]=0,t[2]=0,t[3]=0,t[4]=e[1],t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},a.fromMat2d=function(t,e){return t[0]=e[0],t[1]=e[1],t[2]=0,t[3]=e[2],t[4]=e[3],t[5]=0,t[6]=e[4],t[7]=e[5],t[8]=1,t},a.fromQuat=function(t,e){var r=e[0],n=e[1],a=e[2],i=e[3],o=r+r,s=n+n,l=a+a,u=r*o,c=n*o,f=n*s,h=a*o,d=a*s,p=a*l,_=i*o,v=i*s,y=i*l;return t[0]=1-f-p,t[3]=c-y,t[6]=h+v,t[1]=c+y,t[4]=1-u-p,t[7]=d-_,t[2]=h-v,t[5]=d+_,t[8]=1-u-f,t},a.normalFromMat4=function(t,e){var r=e[0],n=e[1],a=e[2],i=e[3],o=e[4],s=e[5],l=e[6],u=e[7],c=e[8],f=e[9],h=e[10],d=e[11],p=e[12],_=e[13],v=e[14],y=e[15],m=r*s-n*o,M=r*l-a*o,b=r*u-i*o,x=n*l-a*s,g=n*u-i*s,S=a*u-i*l,I=c*_-f*p,D=c*v-h*p,w=c*y-d*p,F=f*v-h*_,O=f*y-d*_,k=h*y-d*v,E=m*k-M*O+b*F+x*w-g*D+S*I;return E?(E=1/E,t[0]=(s*k-l*O+u*F)*E,t[1]=(l*w-o*k-u*D)*E,t[2]=(o*O-s*w+u*I)*E,t[3]=(a*O-n*k-i*F)*E,t[4]=(r*k-a*w+i*D)*E,t[5]=(n*w-r*O-i*I)*E,t[6]=(_*S-v*g+y*x)*E,t[7]=(v*b-p*S-y*M)*E,t[8]=(p*g-_*b+y*m)*E,t):null},a.str=function(t){return"mat3("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+")"},a.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+Math.pow(t[6],2)+Math.pow(t[7],2)+Math.pow(t[8],2))},a.add=function(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t[2]=e[2]+r[2],t[3]=e[3]+r[3],t[4]=e[4]+r[4],t[5]=e[5]+r[5],t[6]=e[6]+r[6],t[7]=e[7]+r[7],t[8]=e[8]+r[8],t},a.subtract=function(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t[2]=e[2]-r[2],t[3]=e[3]-r[3],t[4]=e[4]-r[4],t[5]=e[5]-r[5],t[6]=e[6]-r[6],t[7]=e[7]-r[7],t[8]=e[8]-r[8],t},a.sub=a.subtract,a.multiplyScalar=function(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t[4]=e[4]*r,t[5]=e[5]*r,t[6]=e[6]*r,t[7]=e[7]*r,t[8]=e[8]*r,t},a.multiplyScalarAndAdd=function(t,e,r,n){return t[0]=e[0]+r[0]*n,t[1]=e[1]+r[1]*n,t[2]=e[2]+r[2]*n,t[3]=e[3]+r[3]*n,t[4]=e[4]+r[4]*n,t[5]=e[5]+r[5]*n,t[6]=e[6]+r[6]*n,t[7]=e[7]+r[7]*n,t[8]=e[8]+r[8]*n,t},a.exactEquals=function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]&&t[4]===e[4]&&t[5]===e[5]&&t[6]===e[6]&&t[7]===e[7]&&t[8]===e[8]},a.equals=function(t,e){var r=t[0],a=t[1],i=t[2],o=t[3],s=t[4],l=t[5],u=t[6],c=t[7],f=t[8],h=e[0],d=e[1],p=e[2],_=e[3],v=e[4],y=e[5],m=t[6],M=e[7],b=e[8];return Math.abs(r-h)<=n.EPSILON*Math.max(1,Math.abs(r),Math.abs(h))&&Math.abs(a-d)<=n.EPSILON*Math.max(1,Math.abs(a),Math.abs(d))&&Math.abs(i-p)<=n.EPSILON*Math.max(1,Math.abs(i),Math.abs(p))&&Math.abs(o-_)<=n.EPSILON*Math.max(1,Math.abs(o),Math.abs(_))&&Math.abs(s-v)<=n.EPSILON*Math.max(1,Math.abs(s),Math.abs(v))&&Math.abs(l-y)<=n.EPSILON*Math.max(1,Math.abs(l),Math.abs(y))&&Math.abs(u-m)<=n.EPSILON*Math.max(1,Math.abs(u),Math.abs(m))&&Math.abs(c-M)<=n.EPSILON*Math.max(1,Math.abs(c),Math.abs(M))&&Math.abs(f-b)<=n.EPSILON*Math.max(1,Math.abs(f),Math.abs(b))},t.exports=a},function(t,e,r){var n=r(3),a={};a.create=function(){var t=new n.ARRAY_TYPE(3);return t[0]=0,t[1]=0,t[2]=0,t},a.clone=function(t){var e=new n.ARRAY_TYPE(3);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e},a.fromValues=function(t,e,r){var a=new n.ARRAY_TYPE(3);return a[0]=t,a[1]=e,a[2]=r,a},a.copy=function(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t},a.set=function(t,e,r,n){return t[0]=e,t[1]=r,t[2]=n,t},a.add=function(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t[2]=e[2]+r[2],t},a.subtract=function(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t[2]=e[2]-r[2],t},a.sub=a.subtract,a.multiply=function(t,e,r){return t[0]=e[0]*r[0],t[1]=e[1]*r[1],t[2]=e[2]*r[2],t},a.mul=a.multiply,a.divide=function(t,e,r){return t[0]=e[0]/r[0],t[1]=e[1]/r[1],t[2]=e[2]/r[2],t},a.div=a.divide,a.ceil=function(t,e){return t[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t[2]=Math.ceil(e[2]),t},a.floor=function(t,e){return t[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t[2]=Math.floor(e[2]),t},a.min=function(t,e,r){return t[0]=Math.min(e[0],r[0]),t[1]=Math.min(e[1],r[1]),t[2]=Math.min(e[2],r[2]),t},a.max=function(t,e,r){return t[0]=Math.max(e[0],r[0]),t[1]=Math.max(e[1],r[1]),t[2]=Math.max(e[2],r[2]),t},a.round=function(t,e){return t[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t[2]=Math.round(e[2]),t},a.scale=function(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t},a.scaleAndAdd=function(t,e,r,n){return t[0]=e[0]+r[0]*n,t[1]=e[1]+r[1]*n,t[2]=e[2]+r[2]*n,t},a.distance=function(t,e){var r=e[0]-t[0],n=e[1]-t[1],a=e[2]-t[2];return Math.sqrt(r*r+n*n+a*a)},a.dist=a.distance,a.squaredDistance=function(t,e){var r=e[0]-t[0],n=e[1]-t[1],a=e[2]-t[2];return r*r+n*n+a*a},a.sqrDist=a.squaredDistance,a.length=function(t){var e=t[0],r=t[1],n=t[2];return Math.sqrt(e*e+r*r+n*n)},a.len=a.length,a.squaredLength=function(t){var e=t[0],r=t[1],n=t[2];return e*e+r*r+n*n},a.sqrLen=a.squaredLength,a.negate=function(t,e){return t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t},a.inverse=function(t,e){return t[0]=1/e[0],t[1]=1/e[1],t[2]=1/e[2],t},a.normalize=function(t,e){var r=e[0],n=e[1],a=e[2],i=r*r+n*n+a*a;return i>0&&(i=1/Math.sqrt(i),t[0]=e[0]*i,t[1]=e[1]*i,t[2]=e[2]*i),t},a.dot=function(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]},a.cross=function(t,e,r){var n=e[0],a=e[1],i=e[2],o=r[0],s=r[1],l=r[2];return t[0]=a*l-i*s,t[1]=i*o-n*l,t[2]=n*s-a*o,t},a.lerp=function(t,e,r,n){var a=e[0],i=e[1],o=e[2];return t[0]=a+n*(r[0]-a),t[1]=i+n*(r[1]-i),t[2]=o+n*(r[2]-o),t},a.hermite=function(t,e,r,n,a,i){var o=i*i,s=o*(2*i-3)+1,l=o*(i-2)+i,u=o*(i-1),c=o*(3-2*i);return t[0]=e[0]*s+r[0]*l+n[0]*u+a[0]*c,t[1]=e[1]*s+r[1]*l+n[1]*u+a[1]*c,t[2]=e[2]*s+r[2]*l+n[2]*u+a[2]*c,t},a.bezier=function(t,e,r,n,a,i){var o=1-i,s=o*o,l=i*i,u=s*o,c=3*i*s,f=3*l*o,h=l*i;return t[0]=e[0]*u+r[0]*c+n[0]*f+a[0]*h,t[1]=e[1]*u+r[1]*c+n[1]*f+a[1]*h,t[2]=e[2]*u+r[2]*c+n[2]*f+a[2]*h,t},a.random=function(t,e){e=e||1;var r=2*n.RANDOM()*Math.PI,a=2*n.RANDOM()-1,i=Math.sqrt(1-a*a)*e;return t[0]=Math.cos(r)*i,t[1]=Math.sin(r)*i,t[2]=a*e,t},a.transformMat4=function(t,e,r){var n=e[0],a=e[1],i=e[2],o=r[3]*n+r[7]*a+r[11]*i+r[15];return o=o||1,t[0]=(r[0]*n+r[4]*a+r[8]*i+r[12])/o,t[1]=(r[1]*n+r[5]*a+r[9]*i+r[13])/o,t[2]=(r[2]*n+r[6]*a+r[10]*i+r[14])/o,t},a.transformMat3=function(t,e,r){var n=e[0],a=e[1],i=e[2];return t[0]=n*r[0]+a*r[3]+i*r[6],t[1]=n*r[1]+a*r[4]+i*r[7],t[2]=n*r[2]+a*r[5]+i*r[8],t},a.transformQuat=function(t,e,r){var n=e[0],a=e[1],i=e[2],o=r[0],s=r[1],l=r[2],u=r[3],c=u*n+s*i-l*a,f=u*a+l*n-o*i,h=u*i+o*a-s*n,d=-o*n-s*a-l*i;return t[0]=c*u+d*-o+f*-l-h*-s,t[1]=f*u+d*-s+h*-o-c*-l,t[2]=h*u+d*-l+c*-s-f*-o,t},a.rotateX=function(t,e,r,n){var a=[],i=[];return a[0]=e[0]-r[0],a[1]=e[1]-r[1],a[2]=e[2]-r[2],i[0]=a[0],i[1]=a[1]*Math.cos(n)-a[2]*Math.sin(n),i[2]=a[1]*Math.sin(n)+a[2]*Math.cos(n),t[0]=i[0]+r[0],t[1]=i[1]+r[1],t[2]=i[2]+r[2],t},a.rotateY=function(t,e,r,n){var a=[],i=[];return a[0]=e[0]-r[0],a[1]=e[1]-r[1],a[2]=e[2]-r[2],i[0]=a[2]*Math.sin(n)+a[0]*Math.cos(n),i[1]=a[1],i[2]=a[2]*Math.cos(n)-a[0]*Math.sin(n),t[0]=i[0]+r[0],t[1]=i[1]+r[1],t[2]=i[2]+r[2],t},a.rotateZ=function(t,e,r,n){var a=[],i=[];return a[0]=e[0]-r[0],a[1]=e[1]-r[1],a[2]=e[2]-r[2],i[0]=a[0]*Math.cos(n)-a[1]*Math.sin(n),i[1]=a[0]*Math.sin(n)+a[1]*Math.cos(n),i[2]=a[2],t[0]=i[0]+r[0],t[1]=i[1]+r[1],t[2]=i[2]+r[2],t},a.forEach=function(){var t=a.create();return function(e,r,n,a,i,o){var s,l;for(r||(r=3),n||(n=0),l=a?Math.min(a*r+n,e.length):e.length,s=n;s<l;s+=r)t[0]=e[s],t[1]=e[s+1],t[2]=e[s+2],i(t,t,o),e[s]=t[0],e[s+1]=t[1],e[s+2]=t[2];return e}}(),a.angle=function(t,e){var r=a.fromValues(t[0],t[1],t[2]),n=a.fromValues(e[0],e[1],e[2]);a.normalize(r,r),a.normalize(n,n);var i=a.dot(r,n);return i>1?0:Math.acos(i)},a.str=function(t){return"vec3("+t[0]+", "+t[1]+", "+t[2]+")"},a.exactEquals=function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]},a.equals=function(t,e){var r=t[0],a=t[1],i=t[2],o=e[0],s=e[1],l=e[2];return Math.abs(r-o)<=n.EPSILON*Math.max(1,Math.abs(r),Math.abs(o))&&Math.abs(a-s)<=n.EPSILON*Math.max(1,Math.abs(a),Math.abs(s))&&Math.abs(i-l)<=n.EPSILON*Math.max(1,Math.abs(i),Math.abs(l))},t.exports=a},function(t,e,r){var n=r(3),a={};a.create=function(){var t=new n.ARRAY_TYPE(4);return t[0]=0,t[1]=0,t[2]=0,t[3]=0,t},a.clone=function(t){var e=new n.ARRAY_TYPE(4);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e},a.fromValues=function(t,e,r,a){var i=new n.ARRAY_TYPE(4);return i[0]=t,i[1]=e,i[2]=r,i[3]=a,i},a.copy=function(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t},a.set=function(t,e,r,n,a){return t[0]=e,t[1]=r,t[2]=n,t[3]=a,t},a.add=function(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t[2]=e[2]+r[2],t[3]=e[3]+r[3],t},a.subtract=function(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t[2]=e[2]-r[2],t[3]=e[3]-r[3],t},a.sub=a.subtract,a.multiply=function(t,e,r){return t[0]=e[0]*r[0],t[1]=e[1]*r[1],t[2]=e[2]*r[2],t[3]=e[3]*r[3],t},a.mul=a.multiply,a.divide=function(t,e,r){return t[0]=e[0]/r[0],t[1]=e[1]/r[1],t[2]=e[2]/r[2],t[3]=e[3]/r[3],t},a.div=a.divide,a.ceil=function(t,e){return t[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t[2]=Math.ceil(e[2]),t[3]=Math.ceil(e[3]),t},a.floor=function(t,e){return t[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t[2]=Math.floor(e[2]),t[3]=Math.floor(e[3]),t},a.min=function(t,e,r){return t[0]=Math.min(e[0],r[0]),t[1]=Math.min(e[1],r[1]),t[2]=Math.min(e[2],r[2]),t[3]=Math.min(e[3],r[3]),t},a.max=function(t,e,r){return t[0]=Math.max(e[0],r[0]),t[1]=Math.max(e[1],r[1]),t[2]=Math.max(e[2],r[2]),t[3]=Math.max(e[3],r[3]),t},a.round=function(t,e){return t[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t[2]=Math.round(e[2]),t[3]=Math.round(e[3]),t},a.scale=function(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t},a.scaleAndAdd=function(t,e,r,n){return t[0]=e[0]+r[0]*n,t[1]=e[1]+r[1]*n,t[2]=e[2]+r[2]*n,t[3]=e[3]+r[3]*n,t},a.distance=function(t,e){var r=e[0]-t[0],n=e[1]-t[1],a=e[2]-t[2],i=e[3]-t[3];return Math.sqrt(r*r+n*n+a*a+i*i)},a.dist=a.distance,a.squaredDistance=function(t,e){var r=e[0]-t[0],n=e[1]-t[1],a=e[2]-t[2],i=e[3]-t[3];return r*r+n*n+a*a+i*i},a.sqrDist=a.squaredDistance,a.length=function(t){var e=t[0],r=t[1],n=t[2],a=t[3];return Math.sqrt(e*e+r*r+n*n+a*a)},a.len=a.length,a.squaredLength=function(t){var e=t[0],r=t[1],n=t[2],a=t[3];return e*e+r*r+n*n+a*a},a.sqrLen=a.squaredLength,a.negate=function(t,e){return t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=-e[3],t},a.inverse=function(t,e){return t[0]=1/e[0],t[1]=1/e[1],t[2]=1/e[2],t[3]=1/e[3],t},a.normalize=function(t,e){var r=e[0],n=e[1],a=e[2],i=e[3],o=r*r+n*n+a*a+i*i;return o>0&&(o=1/Math.sqrt(o),t[0]=r*o,t[1]=n*o,t[2]=a*o,t[3]=i*o),t},a.dot=function(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]+t[3]*e[3]},a.lerp=function(t,e,r,n){var a=e[0],i=e[1],o=e[2],s=e[3];return t[0]=a+n*(r[0]-a),t[1]=i+n*(r[1]-i),t[2]=o+n*(r[2]-o),t[3]=s+n*(r[3]-s),t},a.random=function(t,e){return e=e||1,t[0]=n.RANDOM(),t[1]=n.RANDOM(),t[2]=n.RANDOM(),t[3]=n.RANDOM(),a.normalize(t,t),a.scale(t,t,e),t},a.transformMat4=function(t,e,r){var n=e[0],a=e[1],i=e[2],o=e[3];return t[0]=r[0]*n+r[4]*a+r[8]*i+r[12]*o,t[1]=r[1]*n+r[5]*a+r[9]*i+r[13]*o,t[2]=r[2]*n+r[6]*a+r[10]*i+r[14]*o,t[3]=r[3]*n+r[7]*a+r[11]*i+r[15]*o,t},a.transformQuat=function(t,e,r){var n=e[0],a=e[1],i=e[2],o=r[0],s=r[1],l=r[2],u=r[3],c=u*n+s*i-l*a,f=u*a+l*n-o*i,h=u*i+o*a-s*n,d=-o*n-s*a-l*i;return t[0]=c*u+d*-o+f*-l-h*-s,t[1]=f*u+d*-s+h*-o-c*-l,t[2]=h*u+d*-l+c*-s-f*-o,t[3]=e[3],t},a.forEach=function(){var t=a.create();return function(e,r,n,a,i,o){var s,l;for(r||(r=4),n||(n=0),l=a?Math.min(a*r+n,e.length):e.length,s=n;s<l;s+=r)t[0]=e[s],t[1]=e[s+1],t[2]=e[s+2],t[3]=e[s+3],i(t,t,o),e[s]=t[0],e[s+1]=t[1],e[s+2]=t[2],e[s+3]=t[3];return e}}(),a.str=function(t){return"vec4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},a.exactEquals=function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]},a.equals=function(t,e){var r=t[0],a=t[1],i=t[2],o=t[3],s=e[0],l=e[1],u=e[2],c=e[3];return Math.abs(r-s)<=n.EPSILON*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(a-l)<=n.EPSILON*Math.max(1,Math.abs(a),Math.abs(l))&&Math.abs(i-u)<=n.EPSILON*Math.max(1,Math.abs(i),Math.abs(u))&&Math.abs(o-c)<=n.EPSILON*Math.max(1,Math.abs(o),Math.abs(c))},t.exports=a},function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function a(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function l(t,e,r){var n=t.getBoundingClientRect(),a=0,i=0,o=(a=e-n.left-t.clientLeft)>=0&&a<=t.clientWidth&&(i=r-n.top-t.clientTop)>=0&&i<=t.clientHeight;return o}function u(t,e,r){var n=e.getBoundingClientRect();t[0]=r.clientX-n.left-e.clientLeft,t[1]=r.clientY-n.top-e.clientTop}function c(t,e,r,n){u(Y,t,e),D.transformMat2d(H,Y,n.screenToWorldMatrix);var a=r.shape;a instanceof N.default?S.transformXformShape(a,r,Y,H,n):a instanceof z.default?S.translateVert(a,r,Y,H,n):S.translateShape(a,r,Y,H,n)}function f(t,e){e.keys={altKey:t.altKey,ctrlKey:t.ctrlKey,shiftKey:t.shiftKey,metaKey:t.metaKey}}function h(t){var e=[];return t.forEach(function(t,r){e.push(r)}),e}function d(t,e,r,n,a,i){var o={unselectedShapes:h(r)};p(r),t.save();var s=e[e.length-1].zIndex;t.zIndex=s+1,F.default.copyBasicStyle(n,t),t.selected=!0;var l=null;return(i.scalable||i.rotatable)&&(l=new N.default(a||G,i),t.addChildXform(l)),r.set(t,l),o.selectedShapes=[t],o}function p(t){t.forEach(function(t,e){e.restore(),e.selected=!1,e.removeChildXform(t)}),t.clear()}function _(t,e){var r=[];return e.forEach(function(e){var n=t.get(e);e.restore(),e.selected=!1,e.removeChildXform(n),t.delete(e),r.push(e)}),r}function v(t,e){var r=document.querySelector(""+("#"+e.id+" canvas")),n={x:t.offsetX+r.offsetLeft,y:t.offsetY+r.offsetTop};return n}function y(t,e,r){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:W.SVG_OFFSET,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:W.SVG_OFFSET,i=document.getElementById("cursor"),o=v(t,e);if(null===i){var s=document.createElement("span");s.setAttribute("id","cursor"),s.setAttribute("style","position: absolute; top: "+(o.y+"px")+"; left: "+(o.x+"px")+"; width: 28px; height: 28px; background: "+r+"; cursor: none; z-index: 10; pointer-events: none; transform: translate("+n+"px, "+a+"px)"),e.appendChild(s)}else i.style.background===r?M(t,e):(i.style.background=r,M(t,e))}function m(){var t=document.getElementById("cursor");null!==t&&t.parentNode.removeChild(t)}function M(t,e){var r=document.getElementById("cursor"),n=v(t,e);null!==r&&(r.style.top=""+(n.y+"px"),r.style.left=""+(n.x+"px"))}Object.defineProperty(e,"__esModule",{value:!0});var b=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),x=function t(e,r,n){null===e&&(e=Function.prototype);var a=Object.getOwnPropertyDescriptor(e,r);if(void 0===a){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,r,n)}if("value"in a)return a.value;var o=a.get;if(void 0!==o)return o.call(n)},g=r(24),S=a(g),I=r(4),D=a(I),w=r(9),F=n(w),O=r(14),k=n(O),E=r(5),P=n(E),C=r(11),A=n(C),j=r(25),z=n(j),T=r(26),N=n(T),R="url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Cg transform='rotate(<degrees>,24,24)'%3E%3Cpolygon style='fill:%23ffffff;' points='16,20 16,12 4,24 16,36 16,28 32,28 32,36 44,24 32,12 32,20 '/%3E%3Cpolygon points='14,22 14,17 7,24 14,31 14,26 34,26 34,31 41,24 34,17 34,22 '/%3E%3C/g%3E%3C/svg%3E\") no-repeat",B="url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Cg transform='rotate(<degrees>,24,24)'%3E%3Cpath style='fill:%23ffffff;' d='M25.9,4C16.6,4,8.8,11.2,7.4,20.8H6.7H3.3l1.6,2.9l3.8,7.1l1.8,3.3l1.8-3.3l3.8-7.1l1.6-2.9h-3.3h-0.1 c1.3-5.7,6.1-9.9,11.7-9.9c8,0,12.1,4.4,12.1,13.1c0,7.2-5.4,13.1-12.1,13.1h-2v2V42v2h2c10.4,0,18.8-9,18.8-20 C44.7,11.7,37.5,4,25.9,4L25.9,4z'/%3E%3Cpath d='M25.9,6c10.5,0,16.8,6.7,16.8,18c0,9.9-7.5,18-16.8,18v-2.9c7.8,0,14.1-6.8,14.1-15.1c0-5.6-1.8-15.1-14.1-15.1 c-7.4,0-13.4,6.1-14,13.9h2.4l-3.8,7.1l-3.8-7.1h2.5C9.7,13.4,17,6,25.9,6'/%3E%3C/g%3E%3C/svg%3E\") no-repeat",V="url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Cpolygon style='fill:%23ffffff;' points='31.2,28 24.8,28 24.8,32.8 20,32.8 20,39.2 24.8,39.2 24.8,44 31.2,44 31.2,39.2 36,39.2 36,32.8 31.2,32.8 '/%3E %3Cpolygon style='fill:%23ffffff' points='12,32 12,4 32.3,24.3 20,24.3 19.7,24.6 '/%3E%3Cpolygon points='13.8,8.2 13.8,27.8 19,22.8 19.2,22.5 28,22.5 '/%3E%3Cpolyline points='29.6,29.6 29.6,34.4 34.4,34.4 34.4,37.6 29.6,37.6 29.6,42.4 26.4,42.4 26.4,37.6 21.6,37.6 21.6,34.4 26.4,34.4 26.4,29.6 29.6,29.6  '/%3E%3C/svg%3E\") no-repeat",L="url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Crect style='fill:%23ffffff;' x='20' y='32.8' width='16' height='6.4'/%3E%3Cpolygon  style='fill:%23ffffff;' points='12,32 12,4 32.3,24.3 20,24.3 19.7,24.6 '/%3E%3Cpolygon points='13.8,8.2 13.8,27.8 19,22.8 19.2,22.5 28,22.5 '/%3E%3Cpolyline points='34.4,34.4 34.4,37.6 21.6,37.6 21.6,34.4 '/%3E%3C/svg%3E\") no-repeat",q="url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Cpath style='fill:%23ffffff;' d='M24,17.5c-3.6,0-6.5,2.9-6.5,6.5s2.9,6.5,6.5,6.5s6.5-2.9,6.5-6.5S27.6,17.5,24,17.5L24,17.5z'/%3E%3Cpath style='fill:%23ffffff;' d='M24,4L4,24l20,20l20-20L24,4z M31.5,31.5h-15v-15h15V31.5z'/%3E%3Cpolygon points='17,34 24,40.5 31,34  '/%3E%3Cpolygon points='31,14 24,7.5 17,14     '/%3E%3Cpolygon points='14,17 7.5,24 14,31   '/%3E%3Cpolygon points='34,31 40.5,24 34,17    '/%3E%3Cpath d='M24,20c2.2,0,4,1.8,4,4s-1.8,4-4,4s-4-1.8-4-4S21.8,20,24,20'/%3E%3C/svg%3E\") no-repeat",X={SELECTION_CHANGED:"draw:selectionChanged",DRAG_BEGIN:"draw:drag:begin",DRAG_END:"draw:drag:end"},W={SVG_OFFSET:-14,QUICK_CLICK_TIME:500,RIGHT_ANGLE:90,STRAIGHT_ANGLE:180,FORTY_FIVE_ANGLE:45},Y=D.create(0,0),H=D.create(0,0),G={fillColor:"white",strokeColor:"black",strokeWidth:2},J=function(){var t=document.getElementById("cursor");null!==t&&(t.style.display="none")},U=function(){var t=document.getElementById("cursor");null!==t&&(t.style.display="block")},K=function(t){t.target.parentNode.style.cursor="default",J()},Q=function(t){t.target.parentNode.style.cursor="none",U()},Z=function(t){function e(){return i(this,e),o(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return s(e,t),b(e,[{key:"_mousedownCB",value:function(t){if(l(this._drawCanvas,t.clientX,t.clientY)){this.timer=performance.now(),D.set(Y,t.offsetX,t.offsetY),D.transformMat2d(H,Y,this._camera.screenToWorldMatrix);var e=this._camera.worldToScreenMatrix,r=this.sortedShapes,n=-1,a=null,i=null;for(n=r.length-1;n>=0;n-=1){var o=this._objects.get(r[n]);if(r[n].selected){a=this._selectedShapes.get(r[n]),i=o;var s=null;if(a&&(s=a.containsPoint(Y,H,e,this._drawCtx)).hit){if(a instanceof z.default&&t.altKey&&s.controlIndex<r[n].numVerts)r[n].removeVert(s.controlIndex),a=null;else{var u=a.parent.localXform,c=P.default.clone(u);P.default.invert(c,c);var d=D.clone(H);D.transformMat2d(d,d,c),this._dragInfo=Object.assign({rotate:Boolean(s.rotate),controlIndex:s.controlIndex,startObjectPos:d,worldToObjectMatrix:c,startLocalPos:a.parent.getPosition(),startLocalScale:a.parent.getScale(),startLocalRot:a.parent.getRotation(),shapeWidth:a.parent.width,shapeHeight:a.parent.height},i)}break}if(r[n].containsPoint(Y,H,e,this._drawCtx)){a=r[n];break}}}if(n<0&&this._selectedShapes.size)this._selectedShapes.size&&this.fire(X.SELECTION_CHANGED,{unselectedShapes:h(this._selectedShapes),selectedShapes:[]}),this._dragInfo=null,p(this._selectedShapes);else if(a&&i&&(i.movable||i.rotatable||i.scalable)){var _=document.querySelector(""+("#"+this._parent.id+" > canvas"));null===_?(this._parent.addEventListener("mouseout",J),this._parent.addEventListener("mouseover",U)):(_.addEventListener("mouseout",K),_.addEventListener("mouseover",Q)),!this._dragInfo&&i.movable&&(this._dragInfo={startLocalPos:a.getPosition()}),this._dragInfo&&(this._dragInfo.shape=a,this._dragInfo.startPos=D.clone(Y),this._dragInfo.startWorldPos=D.clone(H),this._dragInfo.objectToWorldMatrix=P.default.clone(a.globalXform),f(t,this._dragInfo),t.stopImmediatePropagation(),this.fire(X.DRAG_BEGIN,{shapes:h(this._selectedShapes)})),t.preventDefault()}}}},{key:"_mouseupCB",value:function(t){if(this._dragInfo&&this._dragInfo.shape){t.stopImmediatePropagation(),t.preventDefault();var e=document.querySelector(""+("#"+this._parent.id+" > canvas"));null===e?(this._parent.removeEventListener("mouseout",J),this._parent.removeEventListener("mouseover",U)):(e.removeEventListener("mouseout",K),e.removeEventListener("mouseover",Q)),this._dragInfo=null,this.fire(X.DRAG_END,{shapes:h(this._selectedShapes)})}else if(performance.now()-this.timer<W.QUICK_CLICK_TIME){D.set(Y,t.offsetX,t.offsetY),D.transformMat2d(H,Y,this._camera.screenToWorldMatrix);for(var r=this._camera.worldToScreenMatrix,n=this.sortedShapes,a=null,i=null,o=n.length-1;o>=0;o-=1)if(i=this._objects.get(n[o]),i.selectable&&n[o].containsPoint(Y,H,r,this._drawCtx)){a=n[o];break}if(a&&!a.selected){var s=d(a,n,this._selectedShapes,this._selectStyle,this._xformStyle,i);this.fire(X.SELECTION_CHANGED,s)}}}},{key:"_mousemoveCB",value:function(t){if(l(this._drawCanvas,t.clientX,t.clientY)||this._dragInfo)if(this._dragInfo&&this._dragInfo.shape)M(t,this._parent),f(t,this._dragInfo),c(this._drawCanvas,t,this._dragInfo,this._camera),t.stopImmediatePropagation(),t.preventDefault();else if(!t.buttons&&this._selectedShapes.size){D.set(Y,t.offsetX,t.offsetY),D.transformMat2d(H,Y,this._camera.screenToWorldMatrix);var e=this._camera.worldToScreenMatrix,r=this.sortedShapes,n=0,a=this._camera.isYFlipped();for(n=r.length-1;n>=0;n-=1)if(r[n].selected){var i=this._objects.get(r[n]),o=this._selectedShapes.get(r[n]),s=null;this._parent.style.cursor="none";for(var u=0;u<this._parent.childNodes.length;u+=1)this._parent.childNodes[u].style.cursor="none","canvas"!==this._parent.childNodes[u].nodeName.toLowerCase()&&(this._parent.childNodes[u].style.pointerEvents="none");if(o&&(s=o.containsPoint(Y,H,e,this._drawCtx)).hit){if(o instanceof N.default)if(s.rotate){var h=r[n].getRotation();a?(h*=-1,1===s.controlIndex?h-=W.RIGHT_ANGLE:0===s.controlIndex?h+=W.STRAIGHT_ANGLE:2===s.controlIndex&&(h+=W.RIGHT_ANGLE)):0===s.controlIndex?h-=W.RIGHT_ANGLE:1===s.controlIndex?h+=W.STRAIGHT_ANGLE:3===s.controlIndex&&(h+=W.RIGHT_ANGLE),y(t,this._parent,""+B.replace(/<degrees>/g,""+h))}else s.controlIndex<4?0===s.controlIndex||3===s.controlIndex?y(t,this._parent,""+R.replace(/<degrees>/g,""+(-r[n].getRotation()-W.FORTY_FIVE_ANGLE))):1!==s.controlIndex&&2!==s.controlIndex||y(t,this._parent,""+R.replace(/<degrees>/g,""+(-r[n].getRotation()+W.FORTY_FIVE_ANGLE))):s.controlIndex%2===0?y(t,this._parent,""+R.replace(/<degrees>/g,""+-r[n].getRotation())):y(t,this._parent,""+R.replace(/<degrees>/g,""+(-r[n].getRotation()+W.RIGHT_ANGLE)));else if(o instanceof z.default){this._parent.style.cursor="none";for(var d=0;d<this._parent.childNodes.length;d+=1)this._parent.childNodes[d].style.cursor="none","canvas"!==this._parent.childNodes[d].nodeName.toLowerCase()&&(this._parent.childNodes[d].style.pointerEvents="none");s.controlIndex>=r[n].numVerts?y(t,this._parent,V,-8,-6):t.altKey?y(t,this._parent,L,-8,-6):y(t,this._parent,q,W.SVG_OFFSET,W.SVG_OFFSET)}t.stopImmediatePropagation(),t.preventDefault();break}if(r[n].containsPoint(Y,H,e,this._drawCtx)){if(i&&i.movable){var p=document.getElementById("cursor");null!==p&&p.parentNode.removeChild(p),this._parent.style.cursor="move";for(var _=0;_<this._parent.childNodes.length;_+=1)this._parent.childNodes[_].style.cursor="move";t.stopImmediatePropagation(),t.preventDefault()}break}}if(n<0){m(),this._parent.style.cursor="default";for(var v=0;v<this._parent.childNodes.length;v+=1)this._parent.childNodes[v].style.cursor="default","canvas"!==this._parent.childNodes[v].nodeName.toLowerCase()&&(this._parent.childNodes[v].style.pointerEvents="auto")}}}},{key:"_clickCB",value:function(){}},{key:"_dblclickCB",value:function(t){if(l(this._drawCanvas,t.clientX,t.clientY)){D.set(Y,t.offsetX,t.offsetY),D.transformMat2d(H,Y,this._camera.screenToWorldMatrix);var e=this._camera.worldToScreenMatrix,r=this.sortedShapes,n=-1;for(n=r.length-1;n>=0;n-=1){var a=this._objects.get(r[n]);if(a.selectable&&r[n].containsPoint(Y,H,e,this._drawCtx)){if(a.editable&&r[n]instanceof A.default){var i=r[n],o=!1;if(r[n].selected){var s=this._selectedShapes.get(r[n]);s&&(i.restore(),i.removeChildXform(s),o=!(s instanceof N.default))}i.selected=!0,i.save();var u=r[r.length-1].zIndex;i.zIndex=u+1,F.default.copyBasicStyle(this._selectStyle,i);var c=null;o?(a.rotatable||a.scalable)&&(c=new N.default(this._xformStyle||G,a),i.addChildXform(c)):(c=new z.default(i,this._xformStyle),i.addChildXform(c)),this._selectedShapes.set(i,c)}else if(!r[n].selected){var f=d(r[n],r,this._selectedShapes,this._selectStyle,this._xformStyle,a);this.fire(X.SELECTION_CHANGED,f)}break}}n<0&&this._selectedShapes.size?(this._selectedShapes.size&&this.fire(X.SELECTION_CHANGED,{unselectedShapes:h(this._selectedShapes),selectedShapes:[]}),this._dragInfo=null,p(this._selectedShapes)):t.stopImmediatePropagation(),t.preventDefault()}}},{key:"_mouseoverCB",value:function(){}},{key:"_mouseoutCB",value:function(){}},{key:"_init",value:function(t,r){this._activated=r&&r.enableInteractions,x(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"_init",this).call(this,t,r,this._activated);var n=Object.getOwnPropertyNames(X).map(function(t){return X[t]});this.registerEvents(n),this._dragInfo=null,this._selectedShapes=new Map,this._selectStyle=new F.default(r&&r.selectStyle?r.selectStyle:{fillColor:"orange"}),this._xformStyle=new F.default(r&&r.xformStyle?r.xformStyle:{fillColor:"white",strokeColor:"black",strokeWidth:2}),this.timer=0}},{key:"_renderShapes",value:function(t,e,r){var n=this,a=r.worldToScreenMatrix;e.forEach(function(e){if(e.visible&&(e.render(t,a,n._styleState),e.selected)){var r=n._selectedShapes.get(e);r&&r.render(t,a,n._styleState)}})}},{key:"selectShape",value:function(t){var e=this._objects.get(t);if(e&&e.selectable){var r=d(t,this.sortedShapes,this._selectedShapes,this._selectStyle,this._xformStyle,e);this.fire(X.SELECTION_CHANGED,r)}}},{key:"clearSelection",value:function(){if(this._selectedShapes.size){var t=h(this._selectedShapes);p(this._selectedShapes),this.fire(X.SELECTION_CHANGED,{unselectedShapes:t,selectedShapes:[]}),this._rerenderCb()}}},{key:"addShape",value:function(t){var r=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,a=arguments.length>2&&void 0!==arguments[2]&&arguments[2],i=t;if(Array.isArray(i)||(i=[t]),x(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"addShape",this).call(this,i),i.forEach(function(t){var e=r._objects.get(t);e&&(e.selectable=!n||"undefined"==typeof n.selectable||Boolean(n.selectable),e.movable=!n||"undefined"==typeof n.movable||Boolean(n.movable),e.rotatable=!n||"undefined"==typeof n.rotatable||Boolean(n.rotatable),e.scalable=!n||"undefined"==typeof n.scalable||Boolean(n.scalable),e.uniformScaleOnly=!(!n||"undefined"==typeof n.uniformScaleOnly)&&Boolean(n.uniformScaleOnly),e.centerScaleOnly=!(!n||"undefined"==typeof n.centerScaleOnly)&&Boolean(n.centerScaleOnly),e.editable=!n||"undefined"==typeof n.editable||Boolean(n.editable))}),a){var o={unselectedShapes:h(this._selectedShapes)},s=[];i.forEach(function(t){var e=r._objects.get(t);e.selectable&&(d(t,r.sortedShapes,r._selectedShapes,r._selectStyle,r._xformStyle,e),s.push(t))}),s.length&&(o.selectedShapes=s,this.fire(X.SELECTION_CHANGED,o))}return this}},{key:"deleteShape",value:function(t){var r=t;Array.isArray(r)||(r=[t]);var n=_(this._selectedShapes,r);this.fire(X.SELECTION_CHANGED,{unselectedShapes:n,selectedShapes:h(this._selectedShapes)}),m(),this._parent.style.cursor="default";for(var a=0;a<this._parent.childNodes.length;a+=1)this._parent.childNodes[a].style.cursor="default",this._parent.childNodes[a].style.pointerEvents="auto";return x(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"deleteShape",this).call(this,r)}},{key:"deleteSelectedShapes",value:function(){var t=h(this._selectedShapes);p(this._selectedShapes),this.fire(X.SELECTION_CHANGED,{unselectedShapes:t,selectedShapes:[]}),m(),this._parent.style.cursor="default";for(var r=0;r<this._parent.childNodes.length;r+=1)this._parent.childNodes[r].style.cursor="default",this._parent.childNodes[r].style.pointerEvents="auto";return x(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"deleteShape",this).call(this,t)}},{key:"enableInteractions",
value:function(){return this._enableEvents(),this._activated=!0,this}},{key:"disableInteractions",value:function(){var t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return t&&this.clearSelection(),this._disableEvents(),this._activated=!1,this}},{key:"selectStyle",set:function(t){F.default.copyBasicStyle(t,this._selectStyle)},get:function(){return this._selectStyle}},{key:"selectedShapes",get:function(){return h(this._selectedShapes)}},{key:"interactionsEnabled",get:function(){return this._activated}}]),e}(k.default);e.default=Z,Object.assign(X,k.default.EventConstants),Z.EventConstants=X},function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function a(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t,e,r,n,a){var i=[0,0],o=[0,0];h.default.svd(i,o,null,r.objectToWorldMatrix);var s=[0,0];c.sub(s,r.startWorldPos,i),p.default.normalize(s,s);var l=i;c.sub(l,a,i),p.default.normalize(l,l);var u=p.default.angle(s,l);r.keys.shiftKey&&(u=Math.round(u/Math.QUATER_PI)*Math.QUATER_PI),e.setRotation(r.startLocalRot+Math.RAD_TO_DEG*u)}function o(t,e,r,n,a){var o=t.parent,s=[0,0],l=[0,0],u=[0,0];if(e.rotate)return void i(t,o,e,r,n,a);var f=e.keys.shiftKey||e.uniformScaleOnly,d=e.keys.altKey||e.centerScaleOnly,_=[0,0];if(h.default.svd(_,null,null,e.objectToWorldMatrix),p.default.sub(l,n,e.startWorldPos),f&&e.controlIndex<4){var v=[e.objectToWorldMatrix[0],e.objectToWorldMatrix[1]],y=[e.objectToWorldMatrix[2],e.objectToWorldMatrix[3]],m=[0,0];e.controlIndex<2&&p.default.negate(v,v),e.controlIndex%2===0&&p.default.negate(y,y),p.default.normalize(v,v),p.default.normalize(y,y),p.default.add(m,v,y),p.default.normalize(m,m);var M=p.default.cross2d(l,m),b=null;0===e.controlIndex||3===e.controlIndex?(b=y,M<0&&(b=v)):(b=v,M<0&&(b=y));var x=p.default.dot(l,b);x=Math.sign(x)*Math.sqrt(2*x*x),p.default.scale(l,m,x),c.addVec2(n,e.startWorldPos,l)}c.copy(s,n),c.transformMat2d(s,s,e.worldToObjectMatrix),p.default.sub(u,s,e.startObjectPos),c.copy(_,e.startLocalPos);var g=0,S=0;if(e.controlIndex<4)g=e.controlIndex<2?-1:1,S=e.controlIndex%2===0?-1:1,d||c.addVec2(_,_,p.default.scale(l,l,.5)),o.setPosition(_);else{var I=e.controlIndex-4,D=[0,0];I%2===0?(p.default.set(D,e.objectToWorldMatrix[0],e.objectToWorldMatrix[1]),S=0,g=I<2?-1:1,f&&(S=g,u[1]=u[0])):(p.default.set(D,e.objectToWorldMatrix[2],e.objectToWorldMatrix[3]),g=0,S=I<2?-1:1,f&&(g=S,u[0]=u[1])),d||(p.default.normalize(D,D),p.default.scale(D,D,p.default.dot(l,D)),c.addVec2(_,_,p.default.scale(D,D,.5))),o.setPosition(_)}d&&(g*=2,S*=2),o.setScale([e.startLocalScale[0]*(1+g*u[0]/e.shapeWidth),e.startLocalScale[1]*(1+S*u[1]/e.shapeHeight)])}function s(t,e,r,n,a){var i=[0,0],o=[0,0];if(h.default.svd(o,null,null,e.objectToWorldMatrix),e.keys.shiftKey){c.sub(i,r,e.startPos);var s=Math.atan2(i[1],i[0]);s=Math.round(s/Math.QUATER_PI)*Math.QUATER_PI;var l=[Math.cos(s),Math.sin(s)];p.default.scale(i,l,p.default.dot(i,l)),p.default.transformMat2(i,i,a.screenToWorldMatrix)}else p.default.sub(i,n,e.startWorldPos);c.addVec2(o,e.startLocalPos,i),t.setPosition(o)}function l(t,e,r,n){var a=t.parent,i=a.numVerts;if(e.controlIndex>=i){var o=Math.min(e.controlIndex-i,i-1),s=o===i-1?0:o+1,l=[0,0],u=[0,0],f=[0,0],h=[0,0],d=a.vertsRef,_=a.globalXform;c.transformMat2d(u,d[o],_),c.transformMat2d(f,d[s],_),c.sub(h,f,u),p.default.scale(h,h,.5),c.addVec2(l,u,h),e.controlIndex=a.insertVert(o+1,l)}else a.setVertPosition(e.controlIndex,n)}Object.defineProperty(e,"__esModule",{value:!0}),e.transformXformShape=o,e.translateShape=s,e.translateVert=l;var u=r(4),c=a(u),f=r(5),h=n(f),d=r(10),p=n(d)},function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function a(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var l=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),u=r(2),c=a(u),f=r(4),h=a(f),d=r(1),p=r(7),_=n(p),v=function(t){function e(t,r){i(this,e);var n=o(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,r));return n._baseVertShape=t,n._vertRadius=4,n._transformedVerts=[],n._baseaabox=c.create(),n._worldToScreenMatrix=d.mat2d.create(),n}return s(e,t),l(e,[{key:"_updateAABox",value:function(t){var e=this._baseVertShape.aabox;if(!c.equals(e,this._baseaabox)||!d.mat2d.equals(t,this._worldToScreenMatrix)){c.copy(this._baseaabox,e),d.mat2d.copy(this._worldToScreenMatrix,t),c.transformMat2d(this._aabox,this._baseaabox,this._worldToScreenMatrix);var r=this._vertRadius+this.strokeWidth;c.expand(this._aabox,this._aabox,[r,r])}}},{key:"containsPoint",value:function(t,e,r,n){var a={hit:!1,controlIndex:-1};if(this._updateAABox(r),this.visible&&c.containsPt(this._aabox,t)){var i=c.create(),o=this._vertRadius+this.strokeWidth/2,s=[o,o],l=0;for(l=0;l<this._transformedVerts.length;l+=1)if(c.initCenterExtents(i,this._transformedVerts[l],s),c.containsPt(i,t)){a.hit=!0,a.controlIndex=l;break}if(!a.hit){var u=[0,0],f=[0,0],p=1.5*n.lineWidth;for(d.vec2.set(s,p,p),l=0;l<this._transformedVerts.length-1;l+=1)if(h.sub(f,this._transformedVerts[l+1],this._transformedVerts[l]),d.vec2.scale(f,f,.5),h.addVec2(u,this._transformedVerts[l],f),c.initCenterExtents(i,u,s),c.containsPt(i,t)){a.hit=!0,a.controlIndex=this._transformedVerts.length+l;break}l>0&&l===this._transformedVerts.length-1&&(h.sub(f,this._transformedVerts[0],this._transformedVerts[l]),d.vec2.scale(f,f,.5),h.addVec2(u,this._transformedVerts[l],f),c.initCenterExtents(i,u,s),c.containsPt(i,t)&&(a.hit=!0,a.controlIndex=this._transformedVerts.length+l))}}return a}},{key:"renderBounds",value:function(t,e,r){this._updateAABox(e),t.save(),t.setTransform(1,0,0,1,0,0),r.setStrokeCtx(t);var n=[0,0],a=[0,0];c.getCenter(n,this._aabox),c.getExtents(a,this._aabox),t.beginPath(),t.rect(n[0]-a[0],n[1]-a[1],2*a[0],2*a[1]),t.stroke(),t.restore()}},{key:"render",value:function(t){var e=this;t.save(),t.setTransform(1,0,0,1,0,0);var r=this._baseVertShape._fullXform,n=this._baseVertShape.vertsRef;this._transformedVerts=new Array(n.length);var a=[0,0],i=[0,0];t.beginPath();var o=0;this._transformedVerts[o]=[0,0],h.transformMat2d(this._transformedVerts[o],n[o],r);var s=Math.max(1.5*t.lineWidth,2.5);for(o=0;o<n.length-1;o+=1)this._transformedVerts[o+1]=[0,0],h.transformMat2d(this._transformedVerts[o+1],n[o+1],r),h.sub(i,this._transformedVerts[o+1],this._transformedVerts[o]),d.vec2.scale(i,i,.5),h.addVec2(a,this._transformedVerts[o],i),t.moveTo(a[0]+s,a[1]),t.arc(a[0],a[1],s,0,Math.TWO_PI);o>0&&(h.sub(i,this._transformedVerts[0],this._transformedVerts[o]),d.vec2.scale(i,i,.5),h.addVec2(a,this._transformedVerts[o],i),t.moveTo(a[0]+s,a[1]),t.arc(a[0],a[1],s,0,Math.TWO_PI),t.fillStyle=t.strokeStyle,t.fill()),t.beginPath(),this._transformedVerts.forEach(function(r){t.moveTo(r[0]+e._vertRadius,r[1]),t.arc(r[0],r[1],e._vertRadius,0,Math.TWO_PI)}),this.isFillVisible()&&(this.setFillCtx(t),t.fill()),this.isStrokeVisible()&&(this.setStrokeCtx(t),t.stroke()),t.restore()}}]),e}(_.default);e.default=v},function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function a(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function l(t,e,r,n,a,i,o){_.transformMat2d(e,e,r),t.setTransform(1,0,0,1,0,0),t.translate(e[0],e[1]),t.rotate(i[1]),t.scale(o[0],o[1]),t.rotate(i[0]),t.translate(-e[0],-e[1]),t.rect(e[0]-a,e[1]-a,n,n)}function u(t,e,r,n,a,i,o,s,l,u){var c=!1,f=!1;if(_.transformMat2d(e,e,r),_.distance(e,t)<=s){g.default.negate(e,e),n[4]=n[0]*e[0]+n[2]*e[1],n[5]=n[1]*e[0]+n[3]*e[1];var h=0,d=0;_.transformMat2d(e,t,n),(Math.abs(e[0])<=a&&Math.abs(e[1])<=a||Boolean(l)&&Boolean(u)&&(f=(h=l*e[0])>-a&&h<=o&&(d=u*e[1])>-a&&d<=o))&&(c=!0)}return{hit:c,rotate:f}}Object.defineProperty(e,"__esModule",{value:!0});var c=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),f=function t(e,r,n){null===e&&(e=Function.prototype);var a=Object.getOwnPropertyDescriptor(e,r);if(void 0===a){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,r,n)}if("value"in a)return a.value;var o=a.get;if(void 0!==o)return o.call(n)},h=r(2),d=a(h),p=r(4),_=a(p),v=r(12),y=r(5),m=n(y),M=r(16),b=n(M),x=r(10),g=n(x),S={SIDES:4},I=function(t){function e(t){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{scalable:!0,rotatable:!0};i(this,e);var n=o(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));return n._interactiveBoxSize=8,n._interactiveBoxPadding=10,t&&"undefined"!=typeof t.vertexSize&&(n._interactiveBoxSize=t.vertexSize),n._scalable=!0,n._rotatable=!0,r&&("undefined"!=typeof r.scalable&&(n._scalable=Boolean(r.scalable)),"undefined"!=typeof r.rotatable&&(n._rotatable=Boolean(r.rotatable))),n}return s(e,t),c(e,[{key:"containsPoint",value:function(t){var e={hit:!1,rotate:!1,controlIndex:-1},r=this.aabox;if((this._rotatable||this._scalable)&&this.visible&&d.containsPt(r,t)){var n=[0,0],a=[0,0];m.default.svd(null,n,a,this._fullXform);var i=m.default.create();n[0]=n[0]<0?-1:1,n[1]=n[1]<0?-1:1,n[0]*n[1]>0&&g.default.negate(a,a),m.default.rotate(i,i,a[1]),m.default.scale(i,i,n),m.default.rotate(i,i,a[0]);for(var o=this._rotatable?this._interactiveBoxPadding:0,s=this._interactiveBoxSize/2,l=this.width/2,c=this.height/2,f=[0,0],h=s+o,p=Math.sqrt(2*h*h),v=0,y=0,M=0;M<S.SIDES;M+=1)if(v=M<2?-1:1,y=M%2===0?-1:1,_.set(f,v*l,y*c),e=u(t,f,this._fullXform,i,s,this._interactiveBoxSize,h,p,v,y,n),e.hit){e.controlIndex=M;break}if(!e.hit&&this._scalable)for(var b=0;b<S.SIDES;b+=1)if(v=b%2===0?b<2?-1:1:0,y=b%2===0?0:b<2?-1:1,_.set(f,v*l,y*c),e=u(t,f,this._fullXform,i,s,this._interactiveBoxSize,h,p,v,y,n),e.hit){e.controlIndex=b+S.SIDES;break}e.rotate&&!this._rotatable?e.rotate=!1:e.rotate||this._scalable||(e.rotate=!0)}return e}},{key:"_updatelocalxform",value:function(t){if(this._lxformDirty||t){var e=_.clone(this._pos);_.addVec2(e,e,this._parent.pivotRef),(0,v.buildXformMatrix)(this._localXform,this._rotDeg,this._scale,e,this._pivot),this._localXformUpdated&&this._localXformUpdated(),this._lxformDirty=!1}}},{key:"_updateglobalxform",value:function(){(this._lxformDirty||this._xformDirty)&&(this._updatelocalxform(!0),this._parent?m.default.multiply(this._globalXform,this._parent.globalXform,this._localXform):m.default.copy(this._globalXform,this._localXform),this._globalXformUpdated&&this._globalXformUpdated(),this._xformDirty=!1)}},{key:"_updateAABox",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(t||this._geomDirty||this._boundsOutOfDate){var e=this._rotatable?this._interactiveBoxPadding:0,r=e+this._interactiveBoxSize/2;d.initCenterExtents(this._aabox,[0,0],[this.width/2,this.height/2]),d.transformMat2d(this._aabox,this._aabox,this._fullXform),d.expand(this._aabox,this._aabox,[r,r]),this._aaboxUpdated=!0,this._geomDirty=this._boundsOutOfDate=!1}}},{key:"renderBounds",value:function(t,e,r){var n=this.aabox;t.save(),t.setTransform(1,0,0,1,0,0),r.setStrokeCtx(t);var a=[0,0],i=[0,0];d.getCenter(a,n),d.getExtents(i,n),t.beginPath(),t.rect(a[0]-i[0],a[1]-i[1],2*i[0],2*i[1]),t.stroke(),t.restore()}},{key:"render",value:function(t,r,n){if(this.parent&&"undefined"!=typeof this.parent.width&&"undefined"!==this.parent.height){this._aaboxUpdated=!1,f(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"render",this).call(this,t,r,n,!1),this._aaboxUpdated||this._updateAABox(!0);var a=[0,0],i=[0,0];m.default.svd(null,a,i,this._fullXform),a[0]=a[0]<0?-1:1,a[1]=a[1]<0?-1:1;var o=this._interactiveBoxSize/2,s=this.width/2,u=this.height/2,c=[s,u];t.save(),t.beginPath(),l(t,c,this._fullXform,this._interactiveBoxSize,o,i,a,"3"),_.set(c,s,-u),l(t,c,this._fullXform,this._interactiveBoxSize,o,i,a,"2"),_.set(c,-s,-u),l(t,c,this._fullXform,this._interactiveBoxSize,o,i,a,"0"),_.set(c,-s,u),l(t,c,this._fullXform,this._interactiveBoxSize,o,i,a,"1"),this._scalable&&(_.set(c,0,u),l(t,c,this._fullXform,this._interactiveBoxSize,o,i,a),_.set(c,0,-u),l(t,c,this._fullXform,this._interactiveBoxSize,o,i,a),_.set(c,s,0),l(t,c,this._fullXform,this._interactiveBoxSize,o,i,a),_.set(c,-s,0),l(t,c,this._fullXform,this._interactiveBoxSize,o,i,a)),this.isFillVisible()&&(n.setFillStyle(t,this),t.fill()),this.isStrokeVisible()&&(n.setStrokeStyle(t,this),t.setTransform(1,0,0,1,0,0),t.stroke()),t.restore()}}},{key:"width",get:function(){return this.parent&&"undefined"!==this.parent.width?this.parent.width:0}},{key:"height",get:function(){return this.parent&&"undefined"!==this.parent.height?this.parent.height:0}}]),e}(b.default);e.default=I},function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function a(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var l=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),u=function t(e,r,n){null===e&&(e=Function.prototype);var a=Object.getOwnPropertyDescriptor(e,r);if(void 0===a){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,r,n)}if("value"in a)return a.value;var o=a.get;if(void 0!==o)return o.call(n)},c=r(2),f=a(c),h=r(7),d=n(h),p=r(6),_=n(p),v=function(t){function e(t){i(this,e);var r=o(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));return r._radius=10,"undefined"!=typeof t.radius&&(r.radius=t.radius),f.initCenterExtents(r._aabox,[0,0],[r._radius,r._radius]),r}return s(e,t),l(e,[{key:"getDimensions",value:function(){var t=2*this.radius;return[t,t]}},{key:"_updateAABox",value:function(){if(this._geomDirty||this._boundsOutOfDate){var t=this._pos,e=this._scale,r=_.default.DEG_TO_RAD*this._rotDeg,n=_.default.pow(_.default.cos(r),2),a=_.default.pow(_.default.sin(r),2),i=_.default.pow(e[0]*this._radius,2),o=_.default.pow(e[1]*this._radius,2),s=_.default.sqrt(o*a+i*n),l=_.default.sqrt(i*a+o*n);f.initCenterExtents(this._aabox,t,[s,l]),this._geomDirty=!1,this._boundsOutOfDate=!1}}},{key:"_draw",value:function(t){t.arc(0,0,this._radius,0,_.default.TWO_PI,!1)}},{key:"toJSON",value:function(){return Object.assign({type:"Circle",radius:this.radius},u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"toJSON",this).call(this))}},{key:"radius",set:function(t){if("number"!=typeof t)throw new Error("Radius must be a number");if(t!==this._radius){var e=this._radius;this._radius=t,this._geomDirty=!0,this.fire("changed:geom",{attr:"radius",prevVal:e,currVal:this._radius})}return this},get:function(){return this._radius}},{key:"width",get:function(){return 2*this.radius}},{key:"height",get:function(){return 2*this.radius}}]),e}(d.default);e.default=v},function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function a(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var l=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),u=function t(e,r,n){null===e&&(e=Function.prototype);var a=Object.getOwnPropertyDescriptor(e,r);if(void 0===a){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,r,n)}if("value"in a)return a.value;var o=a.get;if(void 0!==o)return o.call(n)},c=r(2),f=a(c),h=r(7),d=n(h),p=r(5),_=n(p),v=r(6),y=n(v),m=function(t){function e(t){i(this,e);var r=o(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));return r._size=5,"undefined"!=typeof t.size&&(r.size=t.size),f.initCenterExtents(r._aabox,[0,0],[r._radius,r._radius]),r.translate(t.x||0,t.y||0),r}return s(e,t),l(e,[{key:"_updateAABox",value:function(){if(this._geomDirty||this._boundsOutOfDate){var t=this._pos,e=this._scale,r=y.default.DEG_TO_RAD*this._rotDeg,n=y.default.pow(y.default.cos(r),2),a=y.default.pow(y.default.sin(r),2),i=y.default.pow(e[0]*this._size,2),o=y.default.pow(e[1]*this._size,2),s=y.default.sqrt(o*a+i*n),l=y.default.sqrt(i*a+o*n);f.initCenterExtents(this._aabox,t,[s,l]),this._geomDirty=!1,this._boundsOutOfDate=!1}}},{key:"_draw",value:function(t){t.setTransform(1,0,0,1,0,0);var e=[0,0];_.default.svd(e,null,null,this._fullXform),t.arc(e[0],e[1],this._size,0,y.default.TWO_PI,!1)}},{key:"toJSON",value:function(){return Object.assign({type:"Point",size:this.size},u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"toJSON",this).call(this))}},{key:"size",set:function(t){if("number"!=typeof t)throw new Error("Radius must be a number");if(t!==this._size){var e=this._size;this._size=t,this._geomDirty=!0,this.fire("changed:geom",{attr:"size",prevVal:e,currVal:this._size})}},get:function(){return this._size}}]),e}(d.default);e.default=m},function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function a(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function o(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),l=function t(e,r,n){null===e&&(e=Function.prototype);var a=Object.getOwnPropertyDescriptor(e,r);if(void 0===a){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,r,n)}if("value"in a)return a.value;var o=a.get;if(void 0!==o)return o.call(n)},u=r(11),c=n(u),f={MINIMUM_POINTS:3},h=function(t){function e(t){a(this,e);var r=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));if(r._verts.length<f.MINIMUM_POINTS)throw new Error("Poly shapes must be initialized with an array of 2d points and contain at least 3 points");return r}return o(e,t),s(e,[{key:"removeVert",value:function(t){if(this._verts.length<f.MINIMUM_POINTS)throw new Error("Cannot remove vertex "+t+". It would result in a poly with < 3 points. A poly must contain at least 3 points.");l(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"removeVert",this).call(this,t)}},{key:"_draw",value:function(t){var e=!1;if(this._verts.length>=f.MINIMUM_POINTS){t.moveTo(this._verts[0][0],this._verts[0][1]);for(var r=1;r<this._verts.length;r+=1)t.lineTo(this._verts[r][0],this._verts[r][1]);t.closePath(),e=!0}return e}},{key:"toJSON",value:function(){return Object.assign(l(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"toJSON",this).call(this),{type:"Poly"})}}]),e}(c.default);e.default=h},function(t,e){"use strict";function r(t){var e=t.backingStorePixelRatio||t.webkitBackingStorePixelRatio||t.mozBackingStorePixelRatio||t.msBackingStorePixelRatio||t.oBackingStorePixelRatio||t.backingStorePixelRatio||1;return(window.devicePixelRatio||1)/e}function n(t){var e=r(t);if(1===e)return 1;var n=["fillRect","clearRect","strokeRect","isPointInPath","isPointInStroke"];n.forEach(function(r){t[r]=function(t){return function(){for(var r=arguments.length,n=Array(r),a=0;a<r;a++)n[a]=arguments[a];return n=n.map(function(t){return t*e}),t.apply(this,n)}}(t[r])});var a=[e,0,0,e,0,0];return t.setTransform=function(t){return function(){t.apply(this,a),this.transform.apply(this,arguments)}}(t.setTransform),e}Object.defineProperty(e,"__esModule",{value:!0}),e.getPixelRatio=r,e.makeCanvasAutoHighDPI=n},function(t,e){"use strict";function r(t,e){t.forEach(function(t){e[t]&&(e[t]=e[t].bind(e))})}Object.defineProperty(e,"__esModule",{value:!0}),e.bindAll=r},function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function a(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var l=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),u=r(2),c=a(u),f=r(8),h=n(f),d=r(12),p=r(13),_=n(p),v=r(5),y=n(v),m=r(1),M=function(t){function e(t,r){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];i(this,e);var a=o(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,["changed","changed:xform"]));return a._viewport=c.clone(t),a._projectionDimensions=m.vec2.clone(r),a._yflip=n,a._screenMatrix=y.default.create(),a._screenDirty=!0,a}return s(e,t),l(e,[{key:"isYFlipped",value:function(){return this._yflip}},{key:"viewport",set:function(t){if(!c.equals(t,this._viewport)){var e=c.clone(this._viewport);c.copy(this._viewport,t),this._screenDirty=!0,this._worldToScreenOutdated=!0,this.fire("changed",{attr:"viewport",prevVal:e,currVal:t})}return this},get:function(){return c.clone(this._viewport)}},{key:"viewportRef",get:function(){return this._viewport}},{key:"screenMatrix",get:function(){if(this._screenDirty){var t=[0,0],e=[0,0];c.getCenter(t,this._viewport),c.getExtents(e,this._viewport),y.default.set(this._screenMatrix,e[0],0,0,e[1],t[0],t[1]),this._worldToScreenOutdated=!0,this._screenDirty=!1}return this._screenMatrix}}]),e}(_.default),b=function(t){function e(t,r,n){i(this,e);var a=o(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,r,n));return a._viewMatrix=y.default.create(),a._viewDirty=!0,a._projMatrix=y.default.create(),a._projDirty=!0,a}return s(e,t),l(e,[{key:"_localXformUpdated",value:function(){this._boundsOutOfDate=!0}},{key:"_globalXformUpdated",value:function(){this._boundsOutOfDate=!0}},{key:"_matricesDirty",value:function(){return this._boundsOutOfDate||this._lxformDirty||this._xformDirty||this._viewDirty||this._projDirty||this._screenDirty}},{key:"projectionDimensions",set:function(t){if(!m.vec2.equals(t,this._projectionDimensions)){var e=m.vec2.clone(this._projectionDimensions);c.copy(this._projectionDimensions,t),this._viewDirty=!0,this._projDirty=!0,this.fire("changed",{attr:"projectionDimensions",prevVal:e,currVal:t})}return this},get:function(){return m.vec2.clone(this._projectionDimensions)}},{key:"projectionDimensionsRef",get:function(){return this._projectionDimensions}},{key:"viewMatrix",get:function(){if(this._viewDirty||this._boundsOutOfDate||this._xformDirty||this._lxformDirty){var t=[0,0],e=[0,0],r=[0,0],n=this.globalXform;y.default.svd(t,e,r,n),y.default.fromTranslation(this._viewMatrix,m.vec2.negate(t,t)),y.default.rotate(this._viewMatrix,this._viewMatrix,-r[0]),y.default.scale(this._viewMatrix,this._viewMatrix,e),y.default.rotate(this._viewMatrix,this._viewMatrix,-r[1]),this._worldToScreenOutdated=!0,this._viewDirty=!1}return this._viewMatrix}},{key:"projMatrix",get:function(){if(this._projDirty){var t=this._yflip?-1:1;y.default.set(this._projMatrix,2/this._projectionDimensions[0],0,0,2*t/this._projectionDimensions[1],0,0),this._worldToScreenOutdated=!0,this._projDirty=!1}return this._projMatrix}},{key:"worldToScreenMatrix",get:function(){return(!this._worldToScreenMatrix||this._worldToScreenOutdated||this._matricesDirty())&&(this._worldToScreenMatrix||(this._worldToScreenMatrix=y.default.create()),y.default.copy(this._worldToScreenMatrix,this.viewMatrix),y.default.multiply(this._worldToScreenMatrix,this.projMatrix,this._worldToScreenMatrix),y.default.multiply(this._worldToScreenMatrix,this.screenMatrix,this._worldToScreenMatrix),this._worldToScreenOutdated=!1,this._screenToWorldOutdated=!0),this._worldToScreenMatrix}},{key:"screenToWorldMatrix",get:function(){return(!this._screenToWorld||this._screenToWorldOutdated||this._matricesDirty())&&(this._screenToWorld||(this._screenToWorld=y.default.create()),y.default.copy(this._screenToWorld,this.worldToScreenMatrix),y.default.invert(this._screenToWorld,this._screenToWorld),this._screenToWorldOutdated=!1),this._screenToWorld}}]),e}((0,h.default)(M,(0,d.createEventedTransform2dMixin)("changed:xform")));e.default=b},function(t,e,r){var n,a;!function(i,o){n=o,a="function"==typeof n?n.call(e,r,e,t):n,!(void 0!==a&&(t.exports=a))}(this,function(){function t(t,e){var r=Object.prototype.toString.call(t),n="[object Array]"===r||"[object NodeList]"===r||"[object HTMLCollection]"===r||"[object Object]"===r||"undefined"!=typeof jQuery&&t instanceof jQuery||"undefined"!=typeof Elements&&t instanceof Elements,a=0,i=t.length;if(n)for(;a<i;a++)e(t[a]);else e(t)}if("undefined"==typeof window)return null;var e=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||function(t){return window.setTimeout(t,20)},r=function(n,a){function i(){var t=[];this.add=function(e){t.push(e)};var e,r;this.call=function(){for(e=0,r=t.length;e<r;e++)t[e].call()},this.remove=function(n){var a=[];for(e=0,r=t.length;e<r;e++)t[e]!==n&&a.push(t[e]);t=a},this.length=function(){return t.length}}function o(t,e){return t.currentStyle?t.currentStyle[e]:window.getComputedStyle?window.getComputedStyle(t,null).getPropertyValue(e):t.style[e]}function s(t,r){if(t.resizedAttached){if(t.resizedAttached)return void t.resizedAttached.add(r)}else t.resizedAttached=new i,t.resizedAttached.add(r);t.resizeSensor=document.createElement("div"),t.resizeSensor.className="resize-sensor";var n="position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;",a="position: absolute; left: 0; top: 0; transition: 0s;";t.resizeSensor.style.cssText=n,t.resizeSensor.innerHTML='<div class="resize-sensor-expand" style="'+n+'"><div style="'+a+'"></div></div><div class="resize-sensor-shrink" style="'+n+'"><div style="'+a+' width: 200%; height: 200%"></div></div>',t.appendChild(t.resizeSensor),"static"==o(t,"position")&&(t.style.position="relative");var s,l,u,c,f=t.resizeSensor.childNodes[0],h=f.childNodes[0],d=t.resizeSensor.childNodes[1],p=t.offsetWidth,_=t.offsetHeight,v=function(){h.style.width="100000px",h.style.height="100000px",f.scrollLeft=1e5,f.scrollTop=1e5,d.scrollLeft=1e5,d.scrollTop=1e5};v();var y=function(){l=0,s&&(p=u,_=c,t.resizedAttached&&t.resizedAttached.call())},m=function(){u=t.offsetWidth,c=t.offsetHeight,s=u!=p||c!=_,s&&!l&&(l=e(y)),v()},M=function(t,e,r){t.attachEvent?t.attachEvent("on"+e,r):t.addEventListener(e,r)};M(f,"scroll",m),M(d,"scroll",m)}t(n,function(t){s(t,a)}),this.detach=function(t){r.detach(n,t)}};return r.detach=function(e,r){t(e,function(t){t.resizedAttached&&"function"==typeof r&&(t.resizedAttached.remove(r),t.resizedAttached.length())||t.resizeSensor&&(t.contains(t.resizeSensor)&&t.removeChild(t.resizeSensor),delete t.resizeSensor,delete t.resizedAttached)})},r})},function(t,e,r){var n=r(3),a={};a.create=function(){var t=new n.ARRAY_TYPE(4);return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t},a.clone=function(t){var e=new n.ARRAY_TYPE(4);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e},a.copy=function(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t},a.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t},a.fromValues=function(t,e,r,a){var i=new n.ARRAY_TYPE(4);return i[0]=t,i[1]=e,i[2]=r,i[3]=a,i},a.set=function(t,e,r,n,a){return t[0]=e,t[1]=r,t[2]=n,t[3]=a,t},a.transpose=function(t,e){if(t===e){var r=e[1];t[1]=e[2],t[2]=r}else t[0]=e[0],t[1]=e[2],t[2]=e[1],t[3]=e[3];return t},a.invert=function(t,e){var r=e[0],n=e[1],a=e[2],i=e[3],o=r*i-a*n;return o?(o=1/o,t[0]=i*o,t[1]=-n*o,t[2]=-a*o,t[3]=r*o,t):null},a.adjoint=function(t,e){var r=e[0];return t[0]=e[3],t[1]=-e[1],t[2]=-e[2],t[3]=r,t},a.determinant=function(t){return t[0]*t[3]-t[2]*t[1]},a.multiply=function(t,e,r){var n=e[0],a=e[1],i=e[2],o=e[3],s=r[0],l=r[1],u=r[2],c=r[3];return t[0]=n*s+i*l,t[1]=a*s+o*l,t[2]=n*u+i*c,t[3]=a*u+o*c,t},a.mul=a.multiply,a.rotate=function(t,e,r){var n=e[0],a=e[1],i=e[2],o=e[3],s=Math.sin(r),l=Math.cos(r);return t[0]=n*l+i*s,t[1]=a*l+o*s,t[2]=n*-s+i*l,t[3]=a*-s+o*l,t},a.scale=function(t,e,r){var n=e[0],a=e[1],i=e[2],o=e[3],s=r[0],l=r[1];return t[0]=n*s,t[1]=a*s,t[2]=i*l,t[3]=o*l,t},a.fromRotation=function(t,e){var r=Math.sin(e),n=Math.cos(e);return t[0]=n,t[1]=r,t[2]=-r,t[3]=n,t},a.fromScaling=function(t,e){return t[0]=e[0],
t[1]=0,t[2]=0,t[3]=e[1],t},a.str=function(t){return"mat2("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},a.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2))},a.LDU=function(t,e,r,n){return t[2]=n[2]/n[0],r[0]=n[0],r[1]=n[1],r[3]=n[3]-t[2]*r[1],[t,e,r]},a.add=function(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t[2]=e[2]+r[2],t[3]=e[3]+r[3],t},a.subtract=function(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t[2]=e[2]-r[2],t[3]=e[3]-r[3],t},a.sub=a.subtract,a.exactEquals=function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]},a.equals=function(t,e){var r=t[0],a=t[1],i=t[2],o=t[3],s=e[0],l=e[1],u=e[2],c=e[3];return Math.abs(r-s)<=n.EPSILON*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(a-l)<=n.EPSILON*Math.max(1,Math.abs(a),Math.abs(l))&&Math.abs(i-u)<=n.EPSILON*Math.max(1,Math.abs(i),Math.abs(u))&&Math.abs(o-c)<=n.EPSILON*Math.max(1,Math.abs(o),Math.abs(c))},a.multiplyScalar=function(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t},a.multiplyScalarAndAdd=function(t,e,r,n){return t[0]=e[0]+r[0]*n,t[1]=e[1]+r[1]*n,t[2]=e[2]+r[2]*n,t[3]=e[3]+r[3]*n,t},t.exports=a},function(t,e,r){var n=r(3),a={};a.create=function(){var t=new n.ARRAY_TYPE(6);return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t},a.clone=function(t){var e=new n.ARRAY_TYPE(6);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e},a.copy=function(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t},a.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t},a.fromValues=function(t,e,r,a,i,o){var s=new n.ARRAY_TYPE(6);return s[0]=t,s[1]=e,s[2]=r,s[3]=a,s[4]=i,s[5]=o,s},a.set=function(t,e,r,n,a,i,o){return t[0]=e,t[1]=r,t[2]=n,t[3]=a,t[4]=i,t[5]=o,t},a.invert=function(t,e){var r=e[0],n=e[1],a=e[2],i=e[3],o=e[4],s=e[5],l=r*i-n*a;return l?(l=1/l,t[0]=i*l,t[1]=-n*l,t[2]=-a*l,t[3]=r*l,t[4]=(a*s-i*o)*l,t[5]=(n*o-r*s)*l,t):null},a.determinant=function(t){return t[0]*t[3]-t[1]*t[2]},a.multiply=function(t,e,r){var n=e[0],a=e[1],i=e[2],o=e[3],s=e[4],l=e[5],u=r[0],c=r[1],f=r[2],h=r[3],d=r[4],p=r[5];return t[0]=n*u+i*c,t[1]=a*u+o*c,t[2]=n*f+i*h,t[3]=a*f+o*h,t[4]=n*d+i*p+s,t[5]=a*d+o*p+l,t},a.mul=a.multiply,a.rotate=function(t,e,r){var n=e[0],a=e[1],i=e[2],o=e[3],s=e[4],l=e[5],u=Math.sin(r),c=Math.cos(r);return t[0]=n*c+i*u,t[1]=a*c+o*u,t[2]=n*-u+i*c,t[3]=a*-u+o*c,t[4]=s,t[5]=l,t},a.scale=function(t,e,r){var n=e[0],a=e[1],i=e[2],o=e[3],s=e[4],l=e[5],u=r[0],c=r[1];return t[0]=n*u,t[1]=a*u,t[2]=i*c,t[3]=o*c,t[4]=s,t[5]=l,t},a.translate=function(t,e,r){var n=e[0],a=e[1],i=e[2],o=e[3],s=e[4],l=e[5],u=r[0],c=r[1];return t[0]=n,t[1]=a,t[2]=i,t[3]=o,t[4]=n*u+i*c+s,t[5]=a*u+o*c+l,t},a.fromRotation=function(t,e){var r=Math.sin(e),n=Math.cos(e);return t[0]=n,t[1]=r,t[2]=-r,t[3]=n,t[4]=0,t[5]=0,t},a.fromScaling=function(t,e){return t[0]=e[0],t[1]=0,t[2]=0,t[3]=e[1],t[4]=0,t[5]=0,t},a.fromTranslation=function(t,e){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=e[0],t[5]=e[1],t},a.str=function(t){return"mat2d("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+")"},a.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+1)},a.add=function(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t[2]=e[2]+r[2],t[3]=e[3]+r[3],t[4]=e[4]+r[4],t[5]=e[5]+r[5],t},a.subtract=function(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t[2]=e[2]-r[2],t[3]=e[3]-r[3],t[4]=e[4]-r[4],t[5]=e[5]-r[5],t},a.sub=a.subtract,a.multiplyScalar=function(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t[4]=e[4]*r,t[5]=e[5]*r,t},a.multiplyScalarAndAdd=function(t,e,r,n){return t[0]=e[0]+r[0]*n,t[1]=e[1]+r[1]*n,t[2]=e[2]+r[2]*n,t[3]=e[3]+r[3]*n,t[4]=e[4]+r[4]*n,t[5]=e[5]+r[5]*n,t},a.exactEquals=function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]&&t[4]===e[4]&&t[5]===e[5]},a.equals=function(t,e){var r=t[0],a=t[1],i=t[2],o=t[3],s=t[4],l=t[5],u=e[0],c=e[1],f=e[2],h=e[3],d=e[4],p=e[5];return Math.abs(r-u)<=n.EPSILON*Math.max(1,Math.abs(r),Math.abs(u))&&Math.abs(a-c)<=n.EPSILON*Math.max(1,Math.abs(a),Math.abs(c))&&Math.abs(i-f)<=n.EPSILON*Math.max(1,Math.abs(i),Math.abs(f))&&Math.abs(o-h)<=n.EPSILON*Math.max(1,Math.abs(o),Math.abs(h))&&Math.abs(s-d)<=n.EPSILON*Math.max(1,Math.abs(s),Math.abs(d))&&Math.abs(l-p)<=n.EPSILON*Math.max(1,Math.abs(l),Math.abs(p))},t.exports=a},function(t,e,r){var n=r(3),a={scalar:{},SIMD:{}};a.create=function(){var t=new n.ARRAY_TYPE(16);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},a.clone=function(t){var e=new n.ARRAY_TYPE(16);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e},a.copy=function(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t},a.fromValues=function(t,e,r,a,i,o,s,l,u,c,f,h,d,p,_,v){var y=new n.ARRAY_TYPE(16);return y[0]=t,y[1]=e,y[2]=r,y[3]=a,y[4]=i,y[5]=o,y[6]=s,y[7]=l,y[8]=u,y[9]=c,y[10]=f,y[11]=h,y[12]=d,y[13]=p,y[14]=_,y[15]=v,y},a.set=function(t,e,r,n,a,i,o,s,l,u,c,f,h,d,p,_,v){return t[0]=e,t[1]=r,t[2]=n,t[3]=a,t[4]=i,t[5]=o,t[6]=s,t[7]=l,t[8]=u,t[9]=c,t[10]=f,t[11]=h,t[12]=d,t[13]=p,t[14]=_,t[15]=v,t},a.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},a.scalar.transpose=function(t,e){if(t===e){var r=e[1],n=e[2],a=e[3],i=e[6],o=e[7],s=e[11];t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=r,t[6]=e[9],t[7]=e[13],t[8]=n,t[9]=i,t[11]=e[14],t[12]=a,t[13]=o,t[14]=s}else t[0]=e[0],t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=e[1],t[5]=e[5],t[6]=e[9],t[7]=e[13],t[8]=e[2],t[9]=e[6],t[10]=e[10],t[11]=e[14],t[12]=e[3],t[13]=e[7],t[14]=e[11],t[15]=e[15];return t},a.SIMD.transpose=function(t,e){var r,n,a,i,o,s,l,u,c,f;return r=SIMD.Float32x4.load(e,0),n=SIMD.Float32x4.load(e,4),a=SIMD.Float32x4.load(e,8),i=SIMD.Float32x4.load(e,12),o=SIMD.Float32x4.shuffle(r,n,0,1,4,5),s=SIMD.Float32x4.shuffle(a,i,0,1,4,5),l=SIMD.Float32x4.shuffle(o,s,0,2,4,6),u=SIMD.Float32x4.shuffle(o,s,1,3,5,7),SIMD.Float32x4.store(t,0,l),SIMD.Float32x4.store(t,4,u),o=SIMD.Float32x4.shuffle(r,n,2,3,6,7),s=SIMD.Float32x4.shuffle(a,i,2,3,6,7),c=SIMD.Float32x4.shuffle(o,s,0,2,4,6),f=SIMD.Float32x4.shuffle(o,s,1,3,5,7),SIMD.Float32x4.store(t,8,c),SIMD.Float32x4.store(t,12,f),t},a.transpose=n.USE_SIMD?a.SIMD.transpose:a.scalar.transpose,a.scalar.invert=function(t,e){var r=e[0],n=e[1],a=e[2],i=e[3],o=e[4],s=e[5],l=e[6],u=e[7],c=e[8],f=e[9],h=e[10],d=e[11],p=e[12],_=e[13],v=e[14],y=e[15],m=r*s-n*o,M=r*l-a*o,b=r*u-i*o,x=n*l-a*s,g=n*u-i*s,S=a*u-i*l,I=c*_-f*p,D=c*v-h*p,w=c*y-d*p,F=f*v-h*_,O=f*y-d*_,k=h*y-d*v,E=m*k-M*O+b*F+x*w-g*D+S*I;return E?(E=1/E,t[0]=(s*k-l*O+u*F)*E,t[1]=(a*O-n*k-i*F)*E,t[2]=(_*S-v*g+y*x)*E,t[3]=(h*g-f*S-d*x)*E,t[4]=(l*w-o*k-u*D)*E,t[5]=(r*k-a*w+i*D)*E,t[6]=(v*b-p*S-y*M)*E,t[7]=(c*S-h*b+d*M)*E,t[8]=(o*O-s*w+u*I)*E,t[9]=(n*w-r*O-i*I)*E,t[10]=(p*g-_*b+y*m)*E,t[11]=(f*b-c*g-d*m)*E,t[12]=(s*D-o*F-l*I)*E,t[13]=(r*F-n*D+a*I)*E,t[14]=(_*M-p*x-v*m)*E,t[15]=(c*x-f*M+h*m)*E,t):null},a.SIMD.invert=function(t,e){var r,n,a,i,o,s,l,u,c,f,h=SIMD.Float32x4.load(e,0),d=SIMD.Float32x4.load(e,4),p=SIMD.Float32x4.load(e,8),_=SIMD.Float32x4.load(e,12);return o=SIMD.Float32x4.shuffle(h,d,0,1,4,5),n=SIMD.Float32x4.shuffle(p,_,0,1,4,5),r=SIMD.Float32x4.shuffle(o,n,0,2,4,6),n=SIMD.Float32x4.shuffle(n,o,1,3,5,7),o=SIMD.Float32x4.shuffle(h,d,2,3,6,7),i=SIMD.Float32x4.shuffle(p,_,2,3,6,7),a=SIMD.Float32x4.shuffle(o,i,0,2,4,6),i=SIMD.Float32x4.shuffle(i,o,1,3,5,7),o=SIMD.Float32x4.mul(a,i),o=SIMD.Float32x4.swizzle(o,1,0,3,2),s=SIMD.Float32x4.mul(n,o),l=SIMD.Float32x4.mul(r,o),o=SIMD.Float32x4.swizzle(o,2,3,0,1),s=SIMD.Float32x4.sub(SIMD.Float32x4.mul(n,o),s),l=SIMD.Float32x4.sub(SIMD.Float32x4.mul(r,o),l),l=SIMD.Float32x4.swizzle(l,2,3,0,1),o=SIMD.Float32x4.mul(n,a),o=SIMD.Float32x4.swizzle(o,1,0,3,2),s=SIMD.Float32x4.add(SIMD.Float32x4.mul(i,o),s),c=SIMD.Float32x4.mul(r,o),o=SIMD.Float32x4.swizzle(o,2,3,0,1),s=SIMD.Float32x4.sub(s,SIMD.Float32x4.mul(i,o)),c=SIMD.Float32x4.sub(SIMD.Float32x4.mul(r,o),c),c=SIMD.Float32x4.swizzle(c,2,3,0,1),o=SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(n,2,3,0,1),i),o=SIMD.Float32x4.swizzle(o,1,0,3,2),a=SIMD.Float32x4.swizzle(a,2,3,0,1),s=SIMD.Float32x4.add(SIMD.Float32x4.mul(a,o),s),u=SIMD.Float32x4.mul(r,o),o=SIMD.Float32x4.swizzle(o,2,3,0,1),s=SIMD.Float32x4.sub(s,SIMD.Float32x4.mul(a,o)),u=SIMD.Float32x4.sub(SIMD.Float32x4.mul(r,o),u),u=SIMD.Float32x4.swizzle(u,2,3,0,1),o=SIMD.Float32x4.mul(r,n),o=SIMD.Float32x4.swizzle(o,1,0,3,2),u=SIMD.Float32x4.add(SIMD.Float32x4.mul(i,o),u),c=SIMD.Float32x4.sub(SIMD.Float32x4.mul(a,o),c),o=SIMD.Float32x4.swizzle(o,2,3,0,1),u=SIMD.Float32x4.sub(SIMD.Float32x4.mul(i,o),u),c=SIMD.Float32x4.sub(c,SIMD.Float32x4.mul(a,o)),o=SIMD.Float32x4.mul(r,i),o=SIMD.Float32x4.swizzle(o,1,0,3,2),l=SIMD.Float32x4.sub(l,SIMD.Float32x4.mul(a,o)),u=SIMD.Float32x4.add(SIMD.Float32x4.mul(n,o),u),o=SIMD.Float32x4.swizzle(o,2,3,0,1),l=SIMD.Float32x4.add(SIMD.Float32x4.mul(a,o),l),u=SIMD.Float32x4.sub(u,SIMD.Float32x4.mul(n,o)),o=SIMD.Float32x4.mul(r,a),o=SIMD.Float32x4.swizzle(o,1,0,3,2),l=SIMD.Float32x4.add(SIMD.Float32x4.mul(i,o),l),c=SIMD.Float32x4.sub(c,SIMD.Float32x4.mul(n,o)),o=SIMD.Float32x4.swizzle(o,2,3,0,1),l=SIMD.Float32x4.sub(l,SIMD.Float32x4.mul(i,o)),c=SIMD.Float32x4.add(SIMD.Float32x4.mul(n,o),c),f=SIMD.Float32x4.mul(r,s),f=SIMD.Float32x4.add(SIMD.Float32x4.swizzle(f,2,3,0,1),f),f=SIMD.Float32x4.add(SIMD.Float32x4.swizzle(f,1,0,3,2),f),o=SIMD.Float32x4.reciprocalApproximation(f),f=SIMD.Float32x4.sub(SIMD.Float32x4.add(o,o),SIMD.Float32x4.mul(f,SIMD.Float32x4.mul(o,o))),(f=SIMD.Float32x4.swizzle(f,0,0,0,0))?(SIMD.Float32x4.store(t,0,SIMD.Float32x4.mul(f,s)),SIMD.Float32x4.store(t,4,SIMD.Float32x4.mul(f,l)),SIMD.Float32x4.store(t,8,SIMD.Float32x4.mul(f,u)),SIMD.Float32x4.store(t,12,SIMD.Float32x4.mul(f,c)),t):null},a.invert=n.USE_SIMD?a.SIMD.invert:a.scalar.invert,a.scalar.adjoint=function(t,e){var r=e[0],n=e[1],a=e[2],i=e[3],o=e[4],s=e[5],l=e[6],u=e[7],c=e[8],f=e[9],h=e[10],d=e[11],p=e[12],_=e[13],v=e[14],y=e[15];return t[0]=s*(h*y-d*v)-f*(l*y-u*v)+_*(l*d-u*h),t[1]=-(n*(h*y-d*v)-f*(a*y-i*v)+_*(a*d-i*h)),t[2]=n*(l*y-u*v)-s*(a*y-i*v)+_*(a*u-i*l),t[3]=-(n*(l*d-u*h)-s*(a*d-i*h)+f*(a*u-i*l)),t[4]=-(o*(h*y-d*v)-c*(l*y-u*v)+p*(l*d-u*h)),t[5]=r*(h*y-d*v)-c*(a*y-i*v)+p*(a*d-i*h),t[6]=-(r*(l*y-u*v)-o*(a*y-i*v)+p*(a*u-i*l)),t[7]=r*(l*d-u*h)-o*(a*d-i*h)+c*(a*u-i*l),t[8]=o*(f*y-d*_)-c*(s*y-u*_)+p*(s*d-u*f),t[9]=-(r*(f*y-d*_)-c*(n*y-i*_)+p*(n*d-i*f)),t[10]=r*(s*y-u*_)-o*(n*y-i*_)+p*(n*u-i*s),t[11]=-(r*(s*d-u*f)-o*(n*d-i*f)+c*(n*u-i*s)),t[12]=-(o*(f*v-h*_)-c*(s*v-l*_)+p*(s*h-l*f)),t[13]=r*(f*v-h*_)-c*(n*v-a*_)+p*(n*h-a*f),t[14]=-(r*(s*v-l*_)-o*(n*v-a*_)+p*(n*l-a*s)),t[15]=r*(s*h-l*f)-o*(n*h-a*f)+c*(n*l-a*s),t},a.SIMD.adjoint=function(t,e){var r,n,a,i,o,s,l,u,c,f,h,d,p,r=SIMD.Float32x4.load(e,0),n=SIMD.Float32x4.load(e,4),a=SIMD.Float32x4.load(e,8),i=SIMD.Float32x4.load(e,12);return c=SIMD.Float32x4.shuffle(r,n,0,1,4,5),s=SIMD.Float32x4.shuffle(a,i,0,1,4,5),o=SIMD.Float32x4.shuffle(c,s,0,2,4,6),s=SIMD.Float32x4.shuffle(s,c,1,3,5,7),c=SIMD.Float32x4.shuffle(r,n,2,3,6,7),u=SIMD.Float32x4.shuffle(a,i,2,3,6,7),l=SIMD.Float32x4.shuffle(c,u,0,2,4,6),u=SIMD.Float32x4.shuffle(u,c,1,3,5,7),c=SIMD.Float32x4.mul(l,u),c=SIMD.Float32x4.swizzle(c,1,0,3,2),f=SIMD.Float32x4.mul(s,c),h=SIMD.Float32x4.mul(o,c),c=SIMD.Float32x4.swizzle(c,2,3,0,1),f=SIMD.Float32x4.sub(SIMD.Float32x4.mul(s,c),f),h=SIMD.Float32x4.sub(SIMD.Float32x4.mul(o,c),h),h=SIMD.Float32x4.swizzle(h,2,3,0,1),c=SIMD.Float32x4.mul(s,l),c=SIMD.Float32x4.swizzle(c,1,0,3,2),f=SIMD.Float32x4.add(SIMD.Float32x4.mul(u,c),f),p=SIMD.Float32x4.mul(o,c),c=SIMD.Float32x4.swizzle(c,2,3,0,1),f=SIMD.Float32x4.sub(f,SIMD.Float32x4.mul(u,c)),p=SIMD.Float32x4.sub(SIMD.Float32x4.mul(o,c),p),p=SIMD.Float32x4.swizzle(p,2,3,0,1),c=SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(s,2,3,0,1),u),c=SIMD.Float32x4.swizzle(c,1,0,3,2),l=SIMD.Float32x4.swizzle(l,2,3,0,1),f=SIMD.Float32x4.add(SIMD.Float32x4.mul(l,c),f),d=SIMD.Float32x4.mul(o,c),c=SIMD.Float32x4.swizzle(c,2,3,0,1),f=SIMD.Float32x4.sub(f,SIMD.Float32x4.mul(l,c)),d=SIMD.Float32x4.sub(SIMD.Float32x4.mul(o,c),d),d=SIMD.Float32x4.swizzle(d,2,3,0,1),c=SIMD.Float32x4.mul(o,s),c=SIMD.Float32x4.swizzle(c,1,0,3,2),d=SIMD.Float32x4.add(SIMD.Float32x4.mul(u,c),d),p=SIMD.Float32x4.sub(SIMD.Float32x4.mul(l,c),p),c=SIMD.Float32x4.swizzle(c,2,3,0,1),d=SIMD.Float32x4.sub(SIMD.Float32x4.mul(u,c),d),p=SIMD.Float32x4.sub(p,SIMD.Float32x4.mul(l,c)),c=SIMD.Float32x4.mul(o,u),c=SIMD.Float32x4.swizzle(c,1,0,3,2),h=SIMD.Float32x4.sub(h,SIMD.Float32x4.mul(l,c)),d=SIMD.Float32x4.add(SIMD.Float32x4.mul(s,c),d),c=SIMD.Float32x4.swizzle(c,2,3,0,1),h=SIMD.Float32x4.add(SIMD.Float32x4.mul(l,c),h),d=SIMD.Float32x4.sub(d,SIMD.Float32x4.mul(s,c)),c=SIMD.Float32x4.mul(o,l),c=SIMD.Float32x4.swizzle(c,1,0,3,2),h=SIMD.Float32x4.add(SIMD.Float32x4.mul(u,c),h),p=SIMD.Float32x4.sub(p,SIMD.Float32x4.mul(s,c)),c=SIMD.Float32x4.swizzle(c,2,3,0,1),h=SIMD.Float32x4.sub(h,SIMD.Float32x4.mul(u,c)),p=SIMD.Float32x4.add(SIMD.Float32x4.mul(s,c),p),SIMD.Float32x4.store(t,0,f),SIMD.Float32x4.store(t,4,h),SIMD.Float32x4.store(t,8,d),SIMD.Float32x4.store(t,12,p),t},a.adjoint=n.USE_SIMD?a.SIMD.adjoint:a.scalar.adjoint,a.determinant=function(t){var e=t[0],r=t[1],n=t[2],a=t[3],i=t[4],o=t[5],s=t[6],l=t[7],u=t[8],c=t[9],f=t[10],h=t[11],d=t[12],p=t[13],_=t[14],v=t[15],y=e*o-r*i,m=e*s-n*i,M=e*l-a*i,b=r*s-n*o,x=r*l-a*o,g=n*l-a*s,S=u*p-c*d,I=u*_-f*d,D=u*v-h*d,w=c*_-f*p,F=c*v-h*p,O=f*v-h*_;return y*O-m*F+M*w+b*D-x*I+g*S},a.SIMD.multiply=function(t,e,r){var n=SIMD.Float32x4.load(e,0),a=SIMD.Float32x4.load(e,4),i=SIMD.Float32x4.load(e,8),o=SIMD.Float32x4.load(e,12),s=SIMD.Float32x4.load(r,0),l=SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(s,0,0,0,0),n),SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(s,1,1,1,1),a),SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(s,2,2,2,2),i),SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(s,3,3,3,3),o))));SIMD.Float32x4.store(t,0,l);var u=SIMD.Float32x4.load(r,4),c=SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(u,0,0,0,0),n),SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(u,1,1,1,1),a),SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(u,2,2,2,2),i),SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(u,3,3,3,3),o))));SIMD.Float32x4.store(t,4,c);var f=SIMD.Float32x4.load(r,8),h=SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(f,0,0,0,0),n),SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(f,1,1,1,1),a),SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(f,2,2,2,2),i),SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(f,3,3,3,3),o))));SIMD.Float32x4.store(t,8,h);var d=SIMD.Float32x4.load(r,12),p=SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(d,0,0,0,0),n),SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(d,1,1,1,1),a),SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(d,2,2,2,2),i),SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(d,3,3,3,3),o))));return SIMD.Float32x4.store(t,12,p),t},a.scalar.multiply=function(t,e,r){var n=e[0],a=e[1],i=e[2],o=e[3],s=e[4],l=e[5],u=e[6],c=e[7],f=e[8],h=e[9],d=e[10],p=e[11],_=e[12],v=e[13],y=e[14],m=e[15],M=r[0],b=r[1],x=r[2],g=r[3];return t[0]=M*n+b*s+x*f+g*_,t[1]=M*a+b*l+x*h+g*v,t[2]=M*i+b*u+x*d+g*y,t[3]=M*o+b*c+x*p+g*m,M=r[4],b=r[5],x=r[6],g=r[7],t[4]=M*n+b*s+x*f+g*_,t[5]=M*a+b*l+x*h+g*v,t[6]=M*i+b*u+x*d+g*y,t[7]=M*o+b*c+x*p+g*m,M=r[8],b=r[9],x=r[10],g=r[11],t[8]=M*n+b*s+x*f+g*_,t[9]=M*a+b*l+x*h+g*v,t[10]=M*i+b*u+x*d+g*y,t[11]=M*o+b*c+x*p+g*m,M=r[12],b=r[13],x=r[14],g=r[15],t[12]=M*n+b*s+x*f+g*_,t[13]=M*a+b*l+x*h+g*v,t[14]=M*i+b*u+x*d+g*y,t[15]=M*o+b*c+x*p+g*m,t},a.multiply=n.USE_SIMD?a.SIMD.multiply:a.scalar.multiply,a.mul=a.multiply,a.scalar.translate=function(t,e,r){var n,a,i,o,s,l,u,c,f,h,d,p,_=r[0],v=r[1],y=r[2];return e===t?(t[12]=e[0]*_+e[4]*v+e[8]*y+e[12],t[13]=e[1]*_+e[5]*v+e[9]*y+e[13],t[14]=e[2]*_+e[6]*v+e[10]*y+e[14],t[15]=e[3]*_+e[7]*v+e[11]*y+e[15]):(n=e[0],a=e[1],i=e[2],o=e[3],s=e[4],l=e[5],u=e[6],c=e[7],f=e[8],h=e[9],d=e[10],p=e[11],t[0]=n,t[1]=a,t[2]=i,t[3]=o,t[4]=s,t[5]=l,t[6]=u,t[7]=c,t[8]=f,t[9]=h,t[10]=d,t[11]=p,t[12]=n*_+s*v+f*y+e[12],t[13]=a*_+l*v+h*y+e[13],t[14]=i*_+u*v+d*y+e[14],t[15]=o*_+c*v+p*y+e[15]),t},a.SIMD.translate=function(t,e,r){var n=SIMD.Float32x4.load(e,0),a=SIMD.Float32x4.load(e,4),i=SIMD.Float32x4.load(e,8),o=SIMD.Float32x4.load(e,12),s=SIMD.Float32x4(r[0],r[1],r[2],0);e!==t&&(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11]),n=SIMD.Float32x4.mul(n,SIMD.Float32x4.swizzle(s,0,0,0,0)),a=SIMD.Float32x4.mul(a,SIMD.Float32x4.swizzle(s,1,1,1,1)),i=SIMD.Float32x4.mul(i,SIMD.Float32x4.swizzle(s,2,2,2,2));var l=SIMD.Float32x4.add(n,SIMD.Float32x4.add(a,SIMD.Float32x4.add(i,o)));return SIMD.Float32x4.store(t,12,l),t},a.translate=n.USE_SIMD?a.SIMD.translate:a.scalar.translate,a.scalar.scale=function(t,e,r){var n=r[0],a=r[1],i=r[2];return t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n,t[3]=e[3]*n,t[4]=e[4]*a,t[5]=e[5]*a,t[6]=e[6]*a,t[7]=e[7]*a,t[8]=e[8]*i,t[9]=e[9]*i,t[10]=e[10]*i,t[11]=e[11]*i,t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t},a.SIMD.scale=function(t,e,r){var n,a,i,o=SIMD.Float32x4(r[0],r[1],r[2],0);return n=SIMD.Float32x4.load(e,0),SIMD.Float32x4.store(t,0,SIMD.Float32x4.mul(n,SIMD.Float32x4.swizzle(o,0,0,0,0))),a=SIMD.Float32x4.load(e,4),SIMD.Float32x4.store(t,4,SIMD.Float32x4.mul(a,SIMD.Float32x4.swizzle(o,1,1,1,1))),i=SIMD.Float32x4.load(e,8),SIMD.Float32x4.store(t,8,SIMD.Float32x4.mul(i,SIMD.Float32x4.swizzle(o,2,2,2,2))),t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t},a.scale=n.USE_SIMD?a.SIMD.scale:a.scalar.scale,a.rotate=function(t,e,r,a){var i,o,s,l,u,c,f,h,d,p,_,v,y,m,M,b,x,g,S,I,D,w,F,O,k=a[0],E=a[1],P=a[2],C=Math.sqrt(k*k+E*E+P*P);return Math.abs(C)<n.EPSILON?null:(C=1/C,k*=C,E*=C,P*=C,i=Math.sin(r),o=Math.cos(r),s=1-o,l=e[0],u=e[1],c=e[2],f=e[3],h=e[4],d=e[5],p=e[6],_=e[7],v=e[8],y=e[9],m=e[10],M=e[11],b=k*k*s+o,x=E*k*s+P*i,g=P*k*s-E*i,S=k*E*s-P*i,I=E*E*s+o,D=P*E*s+k*i,w=k*P*s+E*i,F=E*P*s-k*i,O=P*P*s+o,t[0]=l*b+h*x+v*g,t[1]=u*b+d*x+y*g,t[2]=c*b+p*x+m*g,t[3]=f*b+_*x+M*g,t[4]=l*S+h*I+v*D,t[5]=u*S+d*I+y*D,t[6]=c*S+p*I+m*D,t[7]=f*S+_*I+M*D,t[8]=l*w+h*F+v*O,t[9]=u*w+d*F+y*O,t[10]=c*w+p*F+m*O,t[11]=f*w+_*F+M*O,e!==t&&(t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t)},a.scalar.rotateX=function(t,e,r){var n=Math.sin(r),a=Math.cos(r),i=e[4],o=e[5],s=e[6],l=e[7],u=e[8],c=e[9],f=e[10],h=e[11];return e!==t&&(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[4]=i*a+u*n,t[5]=o*a+c*n,t[6]=s*a+f*n,t[7]=l*a+h*n,t[8]=u*a-i*n,t[9]=c*a-o*n,t[10]=f*a-s*n,t[11]=h*a-l*n,t},a.SIMD.rotateX=function(t,e,r){var n=SIMD.Float32x4.splat(Math.sin(r)),a=SIMD.Float32x4.splat(Math.cos(r));e!==t&&(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]);var i=SIMD.Float32x4.load(e,4),o=SIMD.Float32x4.load(e,8);return SIMD.Float32x4.store(t,4,SIMD.Float32x4.add(SIMD.Float32x4.mul(i,a),SIMD.Float32x4.mul(o,n))),SIMD.Float32x4.store(t,8,SIMD.Float32x4.sub(SIMD.Float32x4.mul(o,a),SIMD.Float32x4.mul(i,n))),t},a.rotateX=n.USE_SIMD?a.SIMD.rotateX:a.scalar.rotateX,a.scalar.rotateY=function(t,e,r){var n=Math.sin(r),a=Math.cos(r),i=e[0],o=e[1],s=e[2],l=e[3],u=e[8],c=e[9],f=e[10],h=e[11];return e!==t&&(t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=i*a-u*n,t[1]=o*a-c*n,t[2]=s*a-f*n,t[3]=l*a-h*n,t[8]=i*n+u*a,t[9]=o*n+c*a,t[10]=s*n+f*a,t[11]=l*n+h*a,t},a.SIMD.rotateY=function(t,e,r){var n=SIMD.Float32x4.splat(Math.sin(r)),a=SIMD.Float32x4.splat(Math.cos(r));e!==t&&(t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]);var i=SIMD.Float32x4.load(e,0),o=SIMD.Float32x4.load(e,8);return SIMD.Float32x4.store(t,0,SIMD.Float32x4.sub(SIMD.Float32x4.mul(i,a),SIMD.Float32x4.mul(o,n))),SIMD.Float32x4.store(t,8,SIMD.Float32x4.add(SIMD.Float32x4.mul(i,n),SIMD.Float32x4.mul(o,a))),t},a.rotateY=n.USE_SIMD?a.SIMD.rotateY:a.scalar.rotateY,a.scalar.rotateZ=function(t,e,r){var n=Math.sin(r),a=Math.cos(r),i=e[0],o=e[1],s=e[2],l=e[3],u=e[4],c=e[5],f=e[6],h=e[7];return e!==t&&(t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=i*a+u*n,t[1]=o*a+c*n,t[2]=s*a+f*n,t[3]=l*a+h*n,t[4]=u*a-i*n,t[5]=c*a-o*n,t[6]=f*a-s*n,t[7]=h*a-l*n,t},a.SIMD.rotateZ=function(t,e,r){var n=SIMD.Float32x4.splat(Math.sin(r)),a=SIMD.Float32x4.splat(Math.cos(r));e!==t&&(t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]);var i=SIMD.Float32x4.load(e,0),o=SIMD.Float32x4.load(e,4);return SIMD.Float32x4.store(t,0,SIMD.Float32x4.add(SIMD.Float32x4.mul(i,a),SIMD.Float32x4.mul(o,n))),SIMD.Float32x4.store(t,4,SIMD.Float32x4.sub(SIMD.Float32x4.mul(o,a),SIMD.Float32x4.mul(i,n))),t},a.rotateZ=n.USE_SIMD?a.SIMD.rotateZ:a.scalar.rotateZ,a.fromTranslation=function(t,e){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t},a.fromScaling=function(t,e){return t[0]=e[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=e[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},a.fromRotation=function(t,e,r){var a,i,o,s=r[0],l=r[1],u=r[2],c=Math.sqrt(s*s+l*l+u*u);return Math.abs(c)<n.EPSILON?null:(c=1/c,s*=c,l*=c,u*=c,a=Math.sin(e),i=Math.cos(e),o=1-i,t[0]=s*s*o+i,t[1]=l*s*o+u*a,t[2]=u*s*o-l*a,t[3]=0,t[4]=s*l*o-u*a,t[5]=l*l*o+i,t[6]=u*l*o+s*a,t[7]=0,t[8]=s*u*o+l*a,t[9]=l*u*o-s*a,t[10]=u*u*o+i,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t)},a.fromXRotation=function(t,e){var r=Math.sin(e),n=Math.cos(e);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n,t[6]=r,t[7]=0,t[8]=0,t[9]=-r,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},a.fromYRotation=function(t,e){var r=Math.sin(e),n=Math.cos(e);return t[0]=n,t[1]=0,t[2]=-r,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=r,t[9]=0,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},a.fromZRotation=function(t,e){var r=Math.sin(e),n=Math.cos(e);return t[0]=n,t[1]=r,t[2]=0,t[3]=0,t[4]=-r,t[5]=n,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},a.fromRotationTranslation=function(t,e,r){var n=e[0],a=e[1],i=e[2],o=e[3],s=n+n,l=a+a,u=i+i,c=n*s,f=n*l,h=n*u,d=a*l,p=a*u,_=i*u,v=o*s,y=o*l,m=o*u;return t[0]=1-(d+_),t[1]=f+m,t[2]=h-y,t[3]=0,t[4]=f-m,t[5]=1-(c+_),t[6]=p+v,t[7]=0,t[8]=h+y,t[9]=p-v,t[10]=1-(c+d),t[11]=0,t[12]=r[0],t[13]=r[1],t[14]=r[2],t[15]=1,t},a.getTranslation=function(t,e){return t[0]=e[12],t[1]=e[13],t[2]=e[14],t},a.getRotation=function(t,e){var r=e[0]+e[5]+e[10],n=0;return r>0?(n=2*Math.sqrt(r+1),t[3]=.25*n,t[0]=(e[6]-e[9])/n,t[1]=(e[8]-e[2])/n,t[2]=(e[1]-e[4])/n):e[0]>e[5]&e[0]>e[10]?(n=2*Math.sqrt(1+e[0]-e[5]-e[10]),t[3]=(e[6]-e[9])/n,t[0]=.25*n,t[1]=(e[1]+e[4])/n,t[2]=(e[8]+e[2])/n):e[5]>e[10]?(n=2*Math.sqrt(1+e[5]-e[0]-e[10]),t[3]=(e[8]-e[2])/n,t[0]=(e[1]+e[4])/n,t[1]=.25*n,t[2]=(e[6]+e[9])/n):(n=2*Math.sqrt(1+e[10]-e[0]-e[5]),t[3]=(e[1]-e[4])/n,t[0]=(e[8]+e[2])/n,t[1]=(e[6]+e[9])/n,t[2]=.25*n),t},a.fromRotationTranslationScale=function(t,e,r,n){var a=e[0],i=e[1],o=e[2],s=e[3],l=a+a,u=i+i,c=o+o,f=a*l,h=a*u,d=a*c,p=i*u,_=i*c,v=o*c,y=s*l,m=s*u,M=s*c,b=n[0],x=n[1],g=n[2];return t[0]=(1-(p+v))*b,t[1]=(h+M)*b,t[2]=(d-m)*b,t[3]=0,t[4]=(h-M)*x,t[5]=(1-(f+v))*x,t[6]=(_+y)*x,t[7]=0,t[8]=(d+m)*g,t[9]=(_-y)*g,t[10]=(1-(f+p))*g,t[11]=0,t[12]=r[0],t[13]=r[1],t[14]=r[2],t[15]=1,t},a.fromRotationTranslationScaleOrigin=function(t,e,r,n,a){var i=e[0],o=e[1],s=e[2],l=e[3],u=i+i,c=o+o,f=s+s,h=i*u,d=i*c,p=i*f,_=o*c,v=o*f,y=s*f,m=l*u,M=l*c,b=l*f,x=n[0],g=n[1],S=n[2],I=a[0],D=a[1],w=a[2];return t[0]=(1-(_+y))*x,t[1]=(d+b)*x,t[2]=(p-M)*x,t[3]=0,t[4]=(d-b)*g,t[5]=(1-(h+y))*g,t[6]=(v+m)*g,t[7]=0,t[8]=(p+M)*S,t[9]=(v-m)*S,t[10]=(1-(h+_))*S,t[11]=0,t[12]=r[0]+I-(t[0]*I+t[4]*D+t[8]*w),t[13]=r[1]+D-(t[1]*I+t[5]*D+t[9]*w),t[14]=r[2]+w-(t[2]*I+t[6]*D+t[10]*w),t[15]=1,t},a.fromQuat=function(t,e){var r=e[0],n=e[1],a=e[2],i=e[3],o=r+r,s=n+n,l=a+a,u=r*o,c=n*o,f=n*s,h=a*o,d=a*s,p=a*l,_=i*o,v=i*s,y=i*l;return t[0]=1-f-p,t[1]=c+y,t[2]=h-v,t[3]=0,t[4]=c-y,t[5]=1-u-p,t[6]=d+_,t[7]=0,t[8]=h+v,t[9]=d-_,t[10]=1-u-f,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},a.frustum=function(t,e,r,n,a,i,o){var s=1/(r-e),l=1/(a-n),u=1/(i-o);return t[0]=2*i*s,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=2*i*l,t[6]=0,t[7]=0,t[8]=(r+e)*s,t[9]=(a+n)*l,t[10]=(o+i)*u,t[11]=-1,t[12]=0,t[13]=0,t[14]=o*i*2*u,t[15]=0,t},a.perspective=function(t,e,r,n,a){var i=1/Math.tan(e/2),o=1/(n-a);return t[0]=i/r,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=i,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=(a+n)*o,t[11]=-1,t[12]=0,t[13]=0,t[14]=2*a*n*o,t[15]=0,t},a.perspectiveFromFieldOfView=function(t,e,r,n){var a=Math.tan(e.upDegrees*Math.PI/180),i=Math.tan(e.downDegrees*Math.PI/180),o=Math.tan(e.leftDegrees*Math.PI/180),s=Math.tan(e.rightDegrees*Math.PI/180),l=2/(o+s),u=2/(a+i);return t[0]=l,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=u,t[6]=0,t[7]=0,t[8]=-((o-s)*l*.5),t[9]=(a-i)*u*.5,t[10]=n/(r-n),t[11]=-1,t[12]=0,t[13]=0,t[14]=n*r/(r-n),t[15]=0,t},a.ortho=function(t,e,r,n,a,i,o){var s=1/(e-r),l=1/(n-a),u=1/(i-o);return t[0]=-2*s,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*l,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*u,t[11]=0,t[12]=(e+r)*s,t[13]=(a+n)*l,t[14]=(o+i)*u,t[15]=1,t},a.lookAt=function(t,e,r,i){var o,s,l,u,c,f,h,d,p,_,v=e[0],y=e[1],m=e[2],M=i[0],b=i[1],x=i[2],g=r[0],S=r[1],I=r[2];return Math.abs(v-g)<n.EPSILON&&Math.abs(y-S)<n.EPSILON&&Math.abs(m-I)<n.EPSILON?a.identity(t):(h=v-g,d=y-S,p=m-I,_=1/Math.sqrt(h*h+d*d+p*p),h*=_,d*=_,p*=_,o=b*p-x*d,s=x*h-M*p,l=M*d-b*h,_=Math.sqrt(o*o+s*s+l*l),_?(_=1/_,o*=_,s*=_,l*=_):(o=0,s=0,l=0),u=d*l-p*s,c=p*o-h*l,f=h*s-d*o,_=Math.sqrt(u*u+c*c+f*f),_?(_=1/_,u*=_,c*=_,f*=_):(u=0,c=0,f=0),t[0]=o,t[1]=u,t[2]=h,t[3]=0,t[4]=s,t[5]=c,t[6]=d,t[7]=0,t[8]=l,t[9]=f,t[10]=p,t[11]=0,t[12]=-(o*v+s*y+l*m),t[13]=-(u*v+c*y+f*m),t[14]=-(h*v+d*y+p*m),t[15]=1,t)},a.str=function(t){return"mat4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+", "+t[9]+", "+t[10]+", "+t[11]+", "+t[12]+", "+t[13]+", "+t[14]+", "+t[15]+")"},a.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+Math.pow(t[6],2)+Math.pow(t[7],2)+Math.pow(t[8],2)+Math.pow(t[9],2)+Math.pow(t[10],2)+Math.pow(t[11],2)+Math.pow(t[12],2)+Math.pow(t[13],2)+Math.pow(t[14],2)+Math.pow(t[15],2))},a.add=function(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t[2]=e[2]+r[2],t[3]=e[3]+r[3],t[4]=e[4]+r[4],t[5]=e[5]+r[5],t[6]=e[6]+r[6],t[7]=e[7]+r[7],t[8]=e[8]+r[8],t[9]=e[9]+r[9],t[10]=e[10]+r[10],t[11]=e[11]+r[11],t[12]=e[12]+r[12],t[13]=e[13]+r[13],t[14]=e[14]+r[14],t[15]=e[15]+r[15],t},a.subtract=function(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t[2]=e[2]-r[2],t[3]=e[3]-r[3],t[4]=e[4]-r[4],t[5]=e[5]-r[5],t[6]=e[6]-r[6],t[7]=e[7]-r[7],t[8]=e[8]-r[8],t[9]=e[9]-r[9],t[10]=e[10]-r[10],t[11]=e[11]-r[11],t[12]=e[12]-r[12],t[13]=e[13]-r[13],t[14]=e[14]-r[14],t[15]=e[15]-r[15],t},a.sub=a.subtract,a.multiplyScalar=function(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t[4]=e[4]*r,t[5]=e[5]*r,t[6]=e[6]*r,t[7]=e[7]*r,t[8]=e[8]*r,t[9]=e[9]*r,t[10]=e[10]*r,t[11]=e[11]*r,t[12]=e[12]*r,t[13]=e[13]*r,t[14]=e[14]*r,t[15]=e[15]*r,t},a.multiplyScalarAndAdd=function(t,e,r,n){return t[0]=e[0]+r[0]*n,t[1]=e[1]+r[1]*n,t[2]=e[2]+r[2]*n,t[3]=e[3]+r[3]*n,t[4]=e[4]+r[4]*n,t[5]=e[5]+r[5]*n,t[6]=e[6]+r[6]*n,t[7]=e[7]+r[7]*n,t[8]=e[8]+r[8]*n,t[9]=e[9]+r[9]*n,t[10]=e[10]+r[10]*n,t[11]=e[11]+r[11]*n,t[12]=e[12]+r[12]*n,t[13]=e[13]+r[13]*n,t[14]=e[14]+r[14]*n,t[15]=e[15]+r[15]*n,t},a.exactEquals=function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]&&t[4]===e[4]&&t[5]===e[5]&&t[6]===e[6]&&t[7]===e[7]&&t[8]===e[8]&&t[9]===e[9]&&t[10]===e[10]&&t[11]===e[11]&&t[12]===e[12]&&t[13]===e[13]&&t[14]===e[14]&&t[15]===e[15]},a.equals=function(t,e){var r=t[0],a=t[1],i=t[2],o=t[3],s=t[4],l=t[5],u=t[6],c=t[7],f=t[8],h=t[9],d=t[10],p=t[11],_=t[12],v=t[13],y=t[14],m=t[15],M=e[0],b=e[1],x=e[2],g=e[3],S=e[4],I=e[5],D=e[6],w=e[7],F=e[8],O=e[9],k=e[10],E=e[11],P=e[12],C=e[13],A=e[14],j=e[15];return Math.abs(r-M)<=n.EPSILON*Math.max(1,Math.abs(r),Math.abs(M))&&Math.abs(a-b)<=n.EPSILON*Math.max(1,Math.abs(a),Math.abs(b))&&Math.abs(i-x)<=n.EPSILON*Math.max(1,Math.abs(i),Math.abs(x))&&Math.abs(o-g)<=n.EPSILON*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(s-S)<=n.EPSILON*Math.max(1,Math.abs(s),Math.abs(S))&&Math.abs(l-I)<=n.EPSILON*Math.max(1,Math.abs(l),Math.abs(I))&&Math.abs(u-D)<=n.EPSILON*Math.max(1,Math.abs(u),Math.abs(D))&&Math.abs(c-w)<=n.EPSILON*Math.max(1,Math.abs(c),Math.abs(w))&&Math.abs(f-F)<=n.EPSILON*Math.max(1,Math.abs(f),Math.abs(F))&&Math.abs(h-O)<=n.EPSILON*Math.max(1,Math.abs(h),Math.abs(O))&&Math.abs(d-k)<=n.EPSILON*Math.max(1,Math.abs(d),Math.abs(k))&&Math.abs(p-E)<=n.EPSILON*Math.max(1,Math.abs(p),Math.abs(E))&&Math.abs(_-P)<=n.EPSILON*Math.max(1,Math.abs(_),Math.abs(P))&&Math.abs(v-C)<=n.EPSILON*Math.max(1,Math.abs(v),Math.abs(C))&&Math.abs(y-A)<=n.EPSILON*Math.max(1,Math.abs(y),Math.abs(A))&&Math.abs(m-j)<=n.EPSILON*Math.max(1,Math.abs(m),Math.abs(j))},t.exports=a},function(t,e,r){var n=r(3),a=r(20),i=r(21),o=r(22),s={};s.create=function(){var t=new n.ARRAY_TYPE(4);return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t},s.rotationTo=function(){var t=i.create(),e=i.fromValues(1,0,0),r=i.fromValues(0,1,0);return function(n,a,o){var l=i.dot(a,o);return l<-.999999?(i.cross(t,e,a),i.length(t)<1e-6&&i.cross(t,r,a),i.normalize(t,t),s.setAxisAngle(n,t,Math.PI),n):l>.999999?(n[0]=0,n[1]=0,n[2]=0,n[3]=1,n):(i.cross(t,a,o),n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=1+l,s.normalize(n,n))}}(),s.setAxes=function(){var t=a.create();return function(e,r,n,a){return t[0]=n[0],t[3]=n[1],t[6]=n[2],t[1]=a[0],t[4]=a[1],t[7]=a[2],t[2]=-r[0],t[5]=-r[1],t[8]=-r[2],s.normalize(e,s.fromMat3(e,t))}}(),s.clone=o.clone,s.fromValues=o.fromValues,s.copy=o.copy,s.set=o.set,s.identity=function(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t},s.setAxisAngle=function(t,e,r){r*=.5;var n=Math.sin(r);return t[0]=n*e[0],t[1]=n*e[1],t[2]=n*e[2],t[3]=Math.cos(r),t},s.getAxisAngle=function(t,e){var r=2*Math.acos(e[3]),n=Math.sin(r/2);return 0!=n?(t[0]=e[0]/n,t[1]=e[1]/n,t[2]=e[2]/n):(t[0]=1,t[1]=0,t[2]=0),r},s.add=o.add,s.multiply=function(t,e,r){var n=e[0],a=e[1],i=e[2],o=e[3],s=r[0],l=r[1],u=r[2],c=r[3];return t[0]=n*c+o*s+a*u-i*l,t[1]=a*c+o*l+i*s-n*u,t[2]=i*c+o*u+n*l-a*s,t[3]=o*c-n*s-a*l-i*u,t},s.mul=s.multiply,s.scale=o.scale,s.rotateX=function(t,e,r){r*=.5;var n=e[0],a=e[1],i=e[2],o=e[3],s=Math.sin(r),l=Math.cos(r);return t[0]=n*l+o*s,t[1]=a*l+i*s,t[2]=i*l-a*s,t[3]=o*l-n*s,t},s.rotateY=function(t,e,r){r*=.5;var n=e[0],a=e[1],i=e[2],o=e[3],s=Math.sin(r),l=Math.cos(r);return t[0]=n*l-i*s,t[1]=a*l+o*s,t[2]=i*l+n*s,t[3]=o*l-a*s,t},s.rotateZ=function(t,e,r){r*=.5;var n=e[0],a=e[1],i=e[2],o=e[3],s=Math.sin(r),l=Math.cos(r);return t[0]=n*l+a*s,t[1]=a*l-n*s,t[2]=i*l+o*s,t[3]=o*l-i*s,t},s.calculateW=function(t,e){var r=e[0],n=e[1],a=e[2];return t[0]=r,t[1]=n,t[2]=a,t[3]=Math.sqrt(Math.abs(1-r*r-n*n-a*a)),t},s.dot=o.dot,s.lerp=o.lerp,s.slerp=function(t,e,r,n){var a,i,o,s,l,u=e[0],c=e[1],f=e[2],h=e[3],d=r[0],p=r[1],_=r[2],v=r[3];return i=u*d+c*p+f*_+h*v,i<0&&(i=-i,d=-d,p=-p,_=-_,v=-v),1-i>1e-6?(a=Math.acos(i),o=Math.sin(a),s=Math.sin((1-n)*a)/o,l=Math.sin(n*a)/o):(s=1-n,l=n),t[0]=s*u+l*d,t[1]=s*c+l*p,t[2]=s*f+l*_,t[3]=s*h+l*v,t},s.sqlerp=function(){var t=s.create(),e=s.create();return function(r,n,a,i,o,l){return s.slerp(t,n,o,l),s.slerp(e,a,i,l),s.slerp(r,t,e,2*l*(1-l)),r}}(),s.invert=function(t,e){var r=e[0],n=e[1],a=e[2],i=e[3],o=r*r+n*n+a*a+i*i,s=o?1/o:0;return t[0]=-r*s,t[1]=-n*s,t[2]=-a*s,t[3]=i*s,t},s.conjugate=function(t,e){return t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=e[3],t},s.length=o.length,s.len=s.length,s.squaredLength=o.squaredLength,s.sqrLen=s.squaredLength,
s.normalize=o.normalize,s.fromMat3=function(t,e){var r,n=e[0]+e[4]+e[8];if(n>0)r=Math.sqrt(n+1),t[3]=.5*r,r=.5/r,t[0]=(e[5]-e[7])*r,t[1]=(e[6]-e[2])*r,t[2]=(e[1]-e[3])*r;else{var a=0;e[4]>e[0]&&(a=1),e[8]>e[3*a+a]&&(a=2);var i=(a+1)%3,o=(a+2)%3;r=Math.sqrt(e[3*a+a]-e[3*i+i]-e[3*o+o]+1),t[a]=.5*r,r=.5/r,t[3]=(e[3*i+o]-e[3*o+i])*r,t[i]=(e[3*i+a]+e[3*a+i])*r,t[o]=(e[3*o+a]+e[3*a+o])*r}return t},s.str=function(t){return"quat("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},s.exactEquals=o.exactEquals,s.equals=o.equals,t.exports=s},function(t,e,r){var n=r(3),a={};a.create=function(){var t=new n.ARRAY_TYPE(2);return t[0]=0,t[1]=0,t},a.clone=function(t){var e=new n.ARRAY_TYPE(2);return e[0]=t[0],e[1]=t[1],e},a.fromValues=function(t,e){var r=new n.ARRAY_TYPE(2);return r[0]=t,r[1]=e,r},a.copy=function(t,e){return t[0]=e[0],t[1]=e[1],t},a.set=function(t,e,r){return t[0]=e,t[1]=r,t},a.add=function(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t},a.subtract=function(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t},a.sub=a.subtract,a.multiply=function(t,e,r){return t[0]=e[0]*r[0],t[1]=e[1]*r[1],t},a.mul=a.multiply,a.divide=function(t,e,r){return t[0]=e[0]/r[0],t[1]=e[1]/r[1],t},a.div=a.divide,a.ceil=function(t,e){return t[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t},a.floor=function(t,e){return t[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t},a.min=function(t,e,r){return t[0]=Math.min(e[0],r[0]),t[1]=Math.min(e[1],r[1]),t},a.max=function(t,e,r){return t[0]=Math.max(e[0],r[0]),t[1]=Math.max(e[1],r[1]),t},a.round=function(t,e){return t[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t},a.scale=function(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t},a.scaleAndAdd=function(t,e,r,n){return t[0]=e[0]+r[0]*n,t[1]=e[1]+r[1]*n,t},a.distance=function(t,e){var r=e[0]-t[0],n=e[1]-t[1];return Math.sqrt(r*r+n*n)},a.dist=a.distance,a.squaredDistance=function(t,e){var r=e[0]-t[0],n=e[1]-t[1];return r*r+n*n},a.sqrDist=a.squaredDistance,a.length=function(t){var e=t[0],r=t[1];return Math.sqrt(e*e+r*r)},a.len=a.length,a.squaredLength=function(t){var e=t[0],r=t[1];return e*e+r*r},a.sqrLen=a.squaredLength,a.negate=function(t,e){return t[0]=-e[0],t[1]=-e[1],t},a.inverse=function(t,e){return t[0]=1/e[0],t[1]=1/e[1],t},a.normalize=function(t,e){var r=e[0],n=e[1],a=r*r+n*n;return a>0&&(a=1/Math.sqrt(a),t[0]=e[0]*a,t[1]=e[1]*a),t},a.dot=function(t,e){return t[0]*e[0]+t[1]*e[1]},a.cross=function(t,e,r){var n=e[0]*r[1]-e[1]*r[0];return t[0]=t[1]=0,t[2]=n,t},a.lerp=function(t,e,r,n){var a=e[0],i=e[1];return t[0]=a+n*(r[0]-a),t[1]=i+n*(r[1]-i),t},a.random=function(t,e){e=e||1;var r=2*n.RANDOM()*Math.PI;return t[0]=Math.cos(r)*e,t[1]=Math.sin(r)*e,t},a.transformMat2=function(t,e,r){var n=e[0],a=e[1];return t[0]=r[0]*n+r[2]*a,t[1]=r[1]*n+r[3]*a,t},a.transformMat2d=function(t,e,r){var n=e[0],a=e[1];return t[0]=r[0]*n+r[2]*a+r[4],t[1]=r[1]*n+r[3]*a+r[5],t},a.transformMat3=function(t,e,r){var n=e[0],a=e[1];return t[0]=r[0]*n+r[3]*a+r[6],t[1]=r[1]*n+r[4]*a+r[7],t},a.transformMat4=function(t,e,r){var n=e[0],a=e[1];return t[0]=r[0]*n+r[4]*a+r[12],t[1]=r[1]*n+r[5]*a+r[13],t},a.forEach=function(){var t=a.create();return function(e,r,n,a,i,o){var s,l;for(r||(r=2),n||(n=0),l=a?Math.min(a*r+n,e.length):e.length,s=n;s<l;s+=r)t[0]=e[s],t[1]=e[s+1],i(t,t,o),e[s]=t[0],e[s+1]=t[1];return e}}(),a.str=function(t){return"vec2("+t[0]+", "+t[1]+")"},a.exactEquals=function(t,e){return t[0]===e[0]&&t[1]===e[1]},a.equals=function(t,e){var r=t[0],a=t[1],i=e[0],o=e[1];return Math.abs(r-i)<=n.EPSILON*Math.max(1,Math.abs(r),Math.abs(i))&&Math.abs(a-o)<=n.EPSILON*Math.max(1,Math.abs(a),Math.abs(o))},t.exports=a},function(t,e){t.exports={name:"@mapd/mapd-draw",description:"A Utility Library for drawing and interacting with shapes using canvas",version:"1.1.0",homepage:"http://mapd.com",bugs:"https://github.com/map-d/mapd-draw.js/issues",main:"dist/mapd-draw.js",author:"MapD Technologies",license:"MIT",engines:{node:">=4.0.0"},repository:{type:"git",url:"git+https://github.com/map-d/mapd-draw.js.git"},dependencies:{"gl-matrix":"^2.3.2","css-element-queries":"^0.4.0"},devDependencies:{"babel-core":"^6.10.4","babel-loader":"^6.2.4","babel-plugin-lodash":"^3.1.2","babel-preset-es2015":"^6.9.0","babel-preset-stage-0":"^6.5.0",eslint:"^3.0.1","http-server":"^0.9.0","json-loader":"0.5.4",webpack:"^1.13.1"},scripts:{build:"npm run build:prod; npm run build:dev","build:prod":"npm run webpack","build:dev":"npm run webpack:dev",clean:"bash scripts/clean.sh",eslint:"eslint -c ./.eslintrc.json","lint-fix":"eslint --fix $(find src -name \"*.js\" ! -name '*.spec.js')",lint:"eslint $(find src -name \"*.js\" ! -name '*.spec.js')",start:"npm run build; http-server -p 8080 -o;","watch:dev":"node node_modules/webpack/bin/webpack.js --progress --colors --watch --config webpack.dev.config.js",webpack:"node node_modules/webpack/bin/webpack.js","webpack:dev":"node node_modules/webpack/bin/webpack.js --config webpack.dev.config.js",test:"node_modules/.bin/mocha ./test --require ./test/config --require ./test/setup"},"pre-commit":["lint"]}}])});
//# sourceMappingURL=mapd-draw.js.map

/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
/* harmony default export */ __webpack_exports__["a"] = (function(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
});


/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseFilter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__create_parser__ = __webpack_require__(8);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };




function parseFilter(sql, transform) {
  var parser = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : __WEBPACK_IMPORTED_MODULE_0__create_parser__["b" /* default */];

  switch (transform.type) {
    case "filter":
      sql.where.push("(" + (_typeof(transform.expr) === "object" ? parser.parseExpression(transform.expr) : transform.expr) + ")");
    default:
      return sql;
  }
}

/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseSource;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__create_parser__ = __webpack_require__(8);


function joinRelation(type) {
  switch (type) {
    case "join.left":
      return "LEFT JOIN";
    case "join.right":
      return "RIGHT JOIN";
    case "join.inner":
      return "INNER JOIN";
    case "join":
    default:
      return "JOIN";
  }
}

function parseSource(transforms) {
  var parser = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : __WEBPACK_IMPORTED_MODULE_0__create_parser__["b" /* default */];

  return transforms.reduce(function (stmt, transform, index) {
    if (typeof transform.table === "string" && transform.type === "scan") {
      return stmt.concat(transform.table);
    } else if (transform.type === "join" || transform.type === "join.inner" || transform.type === "join.left" || transform.type === "join.right") {
      var right = stmt.pop();
      var left = stmt.pop();
      var joinType = typeof transform.type === "string" ? transform.type : "join";
      // $FlowFixMe
      var joinStmt = left + " " + joinRelation(joinType) + " " + right;
      var aliasStmt = typeof transform.as === "string" ? " as " + transform.as : "";
      return stmt.concat(joinStmt + aliasStmt);
    } else if (transform.type === "data" || transform.type === "root") {
      // $FlowFixMe
      var subquery = parser.writeSQL(transform);
      return stmt.concat("(" + subquery + ")");
    } else {
      return stmt;
    }
  }, []).join();
}

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (false) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var DAYS = exports.DAYS = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];

var MONTHS = exports.MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

var QUARTERS = exports.QUARTERS = ["Q1", "Q2", "Q3", "Q4"];

var HOURS = exports.HOURS = ["12AM", "1AM", "2AM", "3AM", "4AM", "5AM", "6AM", "7AM", "8AM", "9AM", "10AM", "11AM", "12PM", "1PM", "2PM", "3PM", "4PM", "5PM", "6PM", "7PM", "8PM", "9PM", "10PM", "11PM"];

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : afrikaans (af)
//! author : Werner Mollentze : https://github.com/wernerm

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var af = moment.defineLocale('af', {
        months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
        weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
        weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
        weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
        meridiemParse: /vm|nm/i,
        isPM : function (input) {
            return /^nm$/i.test(input);
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? 'vm' : 'VM';
            } else {
                return isLower ? 'nm' : 'NM';
            }
        },
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Vandag om] LT',
            nextDay : '[Mre om] LT',
            nextWeek : 'dddd [om] LT',
            lastDay : '[Gister om] LT',
            lastWeek : '[Laas] dddd [om] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'oor %s',
            past : '%s gelede',
            s : '\'n paar sekondes',
            m : '\'n minuut',
            mm : '%d minute',
            h : '\'n uur',
            hh : '%d ure',
            d : '\'n dag',
            dd : '%d dae',
            M : '\'n maand',
            MM : '%d maande',
            y : '\'n jaar',
            yy : '%d jaar'
        },
        ordinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter
        },
        week : {
            dow : 1, // Maandag is die eerste dag van die week.
            doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
        }
    });

    return af;

}));

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! Locale: Arabic (ar)
//! Author: Abdel Said: https://github.com/abdelsaid
//! Changes in months, weekdays: Ahmed Elkhatib
//! Native plural forms: forabi https://github.com/forabi

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    }, pluralForm = function (n) {
        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    }, plurals = {
        s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
    }, pluralize = function (u) {
        return function (number, withoutSuffix, string, isFuture) {
            var f = pluralForm(number),
                str = plurals[u][pluralForm(number)];
            if (f === 2) {
                str = str[withoutSuffix ? 0 : 1];
            }
            return str.replace(/%d/i, number);
        };
    }, months = [
        '  ',
        ' ',
        ' ',
        ' ',
        ' ',
        ' ',
        ' ',
        ' ',
        ' ',
        '  ',
        '  ',
        '  '
    ];

    var ar = moment.defineLocale('ar', {
        months : months,
        monthsShort : months,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'D/\u200FM/\u200FYYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM : function (input) {
            return '' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : pluralize('s'),
            m : pluralize('m'),
            mm : pluralize('m'),
            h : pluralize('h'),
            hh : pluralize('h'),
            d : pluralize('d'),
            dd : pluralize('d'),
            M : pluralize('M'),
            MM : pluralize('M'),
            y : pluralize('y'),
            yy : pluralize('y')
        },
        preparse: function (string) {
            return string.replace(/\u200f/g, '').replace(/[]/g, function (match) {
                return numberMap[match];
            }).replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '');
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ar;

}));

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Moroccan Arabic (ar-ma)
//! author : ElFadili Yassine : https://github.com/ElFadiliY
//! author : Abdel Said : https://github.com/abdelsaid

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var ar_ma = moment.defineLocale('ar-ma', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : '',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ar_ma;

}));

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic Saudi Arabia (ar-sa)
//! author : Suhail Alkowaileet : https://github.com/xsoh

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var ar_sa = moment.defineLocale('ar-sa', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM : function (input) {
            return '' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : '',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            }).replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '');
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ar_sa;

}));

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale  : Tunisian Arabic (ar-tn)

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var ar_tn = moment.defineLocale('ar-tn', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s',
            past: ' %s',
            s: '',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return ar_tn;

}));

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : azerbaijani (az)
//! author : topchiyev : https://github.com/topchiyev

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var suffixes = {
        1: '-inci',
        5: '-inci',
        8: '-inci',
        70: '-inci',
        80: '-inci',
        2: '-nci',
        7: '-nci',
        20: '-nci',
        50: '-nci',
        3: '-nc',
        4: '-nc',
        100: '-nc',
        6: '-nc',
        9: '-uncu',
        10: '-uncu',
        30: '-uncu',
        60: '-nc',
        90: '-nc'
    };

    var az = moment.defineLocale('az', {
        months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
        monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
        weekdays : 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),
        weekdaysShort : 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),
        weekdaysMin : 'Bz_BE_A__CA_C_'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[bugn saat] LT',
            nextDay : '[sabah saat] LT',
            nextWeek : '[gln hft] dddd [saat] LT',
            lastDay : '[dnn] LT',
            lastWeek : '[ken hft] dddd [saat] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s sonra',
            past : '%s vvl',
            s : 'birne saniyy',
            m : 'bir dqiq',
            mm : '%d dqiq',
            h : 'bir saat',
            hh : '%d saat',
            d : 'bir gn',
            dd : '%d gn',
            M : 'bir ay',
            MM : '%d ay',
            y : 'bir il',
            yy : '%d il'
        },
        meridiemParse: /gec|shr|gndz|axam/,
        isPM : function (input) {
            return /^(gndz|axam)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'gec';
            } else if (hour < 12) {
                return 'shr';
            } else if (hour < 17) {
                return 'gndz';
            } else {
                return 'axam';
            }
        },
        ordinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
        ordinal : function (number) {
            if (number === 0) {  // special case for zero
                return number + '-nc';
            }
            var a = number % 10,
                b = number % 100 - a,
                c = number >= 100 ? 100 : null;
            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return az;

}));

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : belarusian (be)
//! author : Dmitry Demidov : https://github.com/demidov91
//! author: Praleska: http://praleska.pro/
//! Author : Menelion Elensle : https://github.com/Oire

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'mm': withoutSuffix ? '__' : '__',
            'hh': withoutSuffix ? '__' : '__',
            'dd': '__',
            'MM': '__',
            'yy': '__'
        };
        if (key === 'm') {
            return withoutSuffix ? '' : '';
        }
        else if (key === 'h') {
            return withoutSuffix ? '' : '';
        }
        else {
            return number + ' ' + plural(format[key], +number);
        }
    }

    var be = moment.defineLocale('be', {
        months : {
            format: '___________'.split('_'),
            standalone: '___________'.split('_')
        },
        monthsShort : '___________'.split('_'),
        weekdays : {
            format: '______'.split('_'),
            standalone: '______'.split('_'),
            isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/
        },
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY .',
            LLL : 'D MMMM YYYY ., HH:mm',
            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
        },
        calendar : {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            lastDay: '[ ] LT',
            nextWeek: function () {
                return '[] dddd [] LT';
            },
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                case 3:
                case 5:
                case 6:
                    return '[ ] dddd [] LT';
                case 1:
                case 2:
                case 4:
                    return '[ ] dddd [] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            m : relativeTimeWithPlural,
            mm : relativeTimeWithPlural,
            h : relativeTimeWithPlural,
            hh : relativeTimeWithPlural,
            d : '',
            dd : relativeTimeWithPlural,
            M : '',
            MM : relativeTimeWithPlural,
            y : '',
            yy : relativeTimeWithPlural
        },
        meridiemParse: /|||/,
        isPM : function (input) {
            return /^(|)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return '';
            } else {
                return '';
            }
        },
        ordinalParse: /\d{1,2}-(||)/,
        ordinal: function (number, period) {
            switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
            case 'w':
            case 'W':
                return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-' : number + '-';
            case 'D':
                return number + '-';
            default:
                return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return be;

}));

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : bulgarian (bg)
//! author : Krasen Borisov : https://github.com/kraz

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var bg = moment.defineLocale('bg', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'D.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd, D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ] LT',
            lastWeek : function () {
                switch (this.day()) {
                case 0:
                case 3:
                case 6:
                    return '[ ] dddd [] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[ ] dddd [] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : ' ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        ordinalParse: /\d{1,2}-(|||||)/,
        ordinal : function (number) {
            var lastDigit = number % 10,
                last2Digits = number % 100;
            if (number === 0) {
                return number + '-';
            } else if (last2Digits === 0) {
                return number + '-';
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + '-';
            } else if (lastDigit === 1) {
                return number + '-';
            } else if (lastDigit === 2) {
                return number + '-';
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + '-';
            } else {
                return number + '-';
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return bg;

}));

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bengali (bn)
//! author : Kaushik Gandhi : https://github.com/kaushikgandhi

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var bn = moment.defineLocale('bn', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm ',
            LTS : 'A h:mm:ss ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm '
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /||||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if ((meridiem === '' && hour >= 4) ||
                    (meridiem === '' && hour < 5) ||
                    meridiem === '') {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return bn;

}));

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : tibetan (bo)
//! author : Thupten N. Chakrishar : https://github.com/vajradog

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var bo = moment.defineLocale('bo', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm',
            LTS : 'A h:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm',
            LLLL : 'dddd, D MMMM YYYY, A h:mm'
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : '[], LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : '',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /||||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if ((meridiem === '' && hour >= 4) ||
                    (meridiem === '' && hour < 5) ||
                    meridiem === '') {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return bo;

}));

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : breton (br)
//! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function relativeTimeWithMutation(number, withoutSuffix, key) {
        var format = {
            'mm': 'munutenn',
            'MM': 'miz',
            'dd': 'devezh'
        };
        return number + ' ' + mutation(format[key], number);
    }
    function specialMutationForYears(number) {
        switch (lastNumber(number)) {
        case 1:
        case 3:
        case 4:
        case 5:
        case 9:
            return number + ' bloaz';
        default:
            return number + ' vloaz';
        }
    }
    function lastNumber(number) {
        if (number > 9) {
            return lastNumber(number % 10);
        }
        return number;
    }
    function mutation(text, number) {
        if (number === 2) {
            return softMutation(text);
        }
        return text;
    }
    function softMutation(text) {
        var mutationTable = {
            'm': 'v',
            'b': 'v',
            'd': 'z'
        };
        if (mutationTable[text.charAt(0)] === undefined) {
            return text;
        }
        return mutationTable[text.charAt(0)] + text.substring(1);
    }

    var br = moment.defineLocale('br', {
        months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
        monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
        weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
        weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
        weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'h[e]mm A',
            LTS : 'h[e]mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D [a viz] MMMM YYYY',
            LLL : 'D [a viz] MMMM YYYY h[e]mm A',
            LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'
        },
        calendar : {
            sameDay : '[Hiziv da] LT',
            nextDay : '[Warc\'hoazh da] LT',
            nextWeek : 'dddd [da] LT',
            lastDay : '[Dec\'h da] LT',
            lastWeek : 'dddd [paset da] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'a-benn %s',
            past : '%s \'zo',
            s : 'un nebeud segondenno',
            m : 'ur vunutenn',
            mm : relativeTimeWithMutation,
            h : 'un eur',
            hh : '%d eur',
            d : 'un devezh',
            dd : relativeTimeWithMutation,
            M : 'ur miz',
            MM : relativeTimeWithMutation,
            y : 'ur bloaz',
            yy : specialMutationForYears
        },
        ordinalParse: /\d{1,2}(a|vet)/,
        ordinal : function (number) {
            var output = (number === 1) ? 'a' : 'vet';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return br;

}));

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : bosnian (bs)
//! author : Nedim Cholich : https://github.com/frontyard
//! based on (hr) translation by Bojan Markovi

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
        case 'm':
            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
        case 'mm':
            if (number === 1) {
                result += 'minuta';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'minute';
            } else {
                result += 'minuta';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'jedan sat' : 'jednog sata';
        case 'hh':
            if (number === 1) {
                result += 'sat';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'sata';
            } else {
                result += 'sati';
            }
            return result;
        case 'dd':
            if (number === 1) {
                result += 'dan';
            } else {
                result += 'dana';
            }
            return result;
        case 'MM':
            if (number === 1) {
                result += 'mjesec';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'mjeseca';
            } else {
                result += 'mjeseci';
            }
            return result;
        case 'yy':
            if (number === 1) {
                result += 'godina';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'godine';
            } else {
                result += 'godina';
            }
            return result;
        }
    }

    var bs = moment.defineLocale('bs', {
        months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
        weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
        weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD. MM. YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[danas u] LT',
            nextDay  : '[sutra u] LT',
            nextWeek : function () {
                switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[juer u] LT',
            lastWeek : function () {
                switch (this.day()) {
                case 0:
                case 3:
                    return '[prolu] dddd [u] LT';
                case 6:
                    return '[prole] [subote] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[proli] dddd [u] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'par sekundi',
            m      : translate,
            mm     : translate,
            h      : translate,
            hh     : translate,
            d      : 'dan',
            dd     : translate,
            M      : 'mjesec',
            MM     : translate,
            y      : 'godinu',
            yy     : translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return bs;

}));

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : catalan (ca)
//! author : Juan G. Hurtado : https://github.com/juanghurtado

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var ca = moment.defineLocale('ca', {
        months : 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
        monthsShort : 'gen._febr._mar._abr._mai._jun._jul._ag._set._oct._nov._des.'.split('_'),
        monthsParseExact : true,
        weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
        weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
        weekdaysMin : 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay : function () {
                return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            nextDay : function () {
                return '[dem a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            lastDay : function () {
                return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'en %s',
            past : 'fa %s',
            s : 'uns segons',
            m : 'un minut',
            mm : '%d minuts',
            h : 'una hora',
            hh : '%d hores',
            d : 'un dia',
            dd : '%d dies',
            M : 'un mes',
            MM : '%d mesos',
            y : 'un any',
            yy : '%d anys'
        },
        ordinalParse: /\d{1,2}(r|n|t||a)/,
        ordinal : function (number, period) {
            var output = (number === 1) ? 'r' :
                (number === 2) ? 'n' :
                (number === 3) ? 'r' :
                (number === 4) ? 't' : '';
            if (period === 'w' || period === 'W') {
                output = 'a';
            }
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return ca;

}));

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : czech (cs)
//! author : petrbela : https://github.com/petrbela

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var months = 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_'),
        monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_');
    function plural(n) {
        return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
        case 's':  // a few seconds / in a few seconds / a few seconds ago
            return (withoutSuffix || isFuture) ? 'pr sekund' : 'pr sekundami';
        case 'm':  // a minute / in a minute / a minute ago
            return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'minuty' : 'minut');
            } else {
                return result + 'minutami';
            }
            break;
        case 'h':  // an hour / in an hour / an hour ago
            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
        case 'hh': // 9 hours / in 9 hours / 9 hours ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'hodiny' : 'hodin');
            } else {
                return result + 'hodinami';
            }
            break;
        case 'd':  // a day / in a day / a day ago
            return (withoutSuffix || isFuture) ? 'den' : 'dnem';
        case 'dd': // 9 days / in 9 days / 9 days ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'dny' : 'dn');
            } else {
                return result + 'dny';
            }
            break;
        case 'M':  // a month / in a month / a month ago
            return (withoutSuffix || isFuture) ? 'msc' : 'mscem';
        case 'MM': // 9 months / in 9 months / 9 months ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'msce' : 'msc');
            } else {
                return result + 'msci';
            }
            break;
        case 'y':  // a year / in a year / a year ago
            return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
        case 'yy': // 9 years / in 9 years / 9 years ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'roky' : 'let');
            } else {
                return result + 'lety';
            }
            break;
        }
    }

    var cs = moment.defineLocale('cs', {
        months : months,
        monthsShort : monthsShort,
        monthsParse : (function (months, monthsShort) {
            var i, _monthsParse = [];
            for (i = 0; i < 12; i++) {
                // use custom parser to solve problem with July (ervenec)
                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
            }
            return _monthsParse;
        }(months, monthsShort)),
        shortMonthsParse : (function (monthsShort) {
            var i, _shortMonthsParse = [];
            for (i = 0; i < 12; i++) {
                _shortMonthsParse[i] = new RegExp('^' + monthsShort[i] + '$', 'i');
            }
            return _shortMonthsParse;
        }(monthsShort)),
        longMonthsParse : (function (months) {
            var i, _longMonthsParse = [];
            for (i = 0; i < 12; i++) {
                _longMonthsParse[i] = new RegExp('^' + months[i] + '$', 'i');
            }
            return _longMonthsParse;
        }(months)),
        weekdays : 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),
        weekdaysShort : 'ne_po_t_st_t_p_so'.split('_'),
        weekdaysMin : 'ne_po_t_st_t_p_so'.split('_'),
        longDateFormat : {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay: '[dnes v] LT',
            nextDay: '[ztra v] LT',
            nextWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[v nedli v] LT';
                case 1:
                case 2:
                    return '[v] dddd [v] LT';
                case 3:
                    return '[ve stedu v] LT';
                case 4:
                    return '[ve tvrtek v] LT';
                case 5:
                    return '[v ptek v] LT';
                case 6:
                    return '[v sobotu v] LT';
                }
            },
            lastDay: '[vera v] LT',
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[minulou nedli v] LT';
                case 1:
                case 2:
                    return '[minul] dddd [v] LT';
                case 3:
                    return '[minulou stedu v] LT';
                case 4:
                case 5:
                    return '[minul] dddd [v] LT';
                case 6:
                    return '[minulou sobotu v] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : 'ped %s',
            s : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        ordinalParse : /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return cs;

}));

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : chuvash (cv)
//! author : Anatoly Mironov : https://github.com/mirontoli

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var cv = moment.defineLocale('cv', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'YYYY [] MMMM [] D[-]',
            LLL : 'YYYY [] MMMM [] D[-], HH:mm',
            LLLL : 'dddd, YYYY [] MMMM [] D[-], HH:mm'
        },
        calendar : {
            sameDay: '[] LT []',
            nextDay: '[] LT []',
            lastDay: '[] LT []',
            nextWeek: '[] dddd LT []',
            lastWeek: '[] dddd LT []',
            sameElse: 'L'
        },
        relativeTime : {
            future : function (output) {
                var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';
                return output + affix;
            },
            past : '%s ',
            s : '- ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        ordinalParse: /\d{1,2}-/,
        ordinal : '%d-',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return cv;

}));

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Welsh (cy)
//! author : Robert Allen

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var cy = moment.defineLocale('cy', {
        months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
        monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
        weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
        weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
        weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
        weekdaysParseExact : true,
        // time formats are the same as en-gb
        longDateFormat: {
            LT: 'HH:mm',
            LTS : 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[Heddiw am] LT',
            nextDay: '[Yfory am] LT',
            nextWeek: 'dddd [am] LT',
            lastDay: '[Ddoe am] LT',
            lastWeek: 'dddd [diwethaf am] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'mewn %s',
            past: '%s yn l',
            s: 'ychydig eiliadau',
            m: 'munud',
            mm: '%d munud',
            h: 'awr',
            hh: '%d awr',
            d: 'diwrnod',
            dd: '%d diwrnod',
            M: 'mis',
            MM: '%d mis',
            y: 'blwyddyn',
            yy: '%d flynedd'
        },
        ordinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
        // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
        ordinal: function (number) {
            var b = number,
                output = '',
                lookup = [
                    '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
                    'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
                ];
            if (b > 20) {
                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                    output = 'fed'; // not 30ain, 70ain or 90ain
                } else {
                    output = 'ain';
                }
            } else if (b > 0) {
                output = lookup[b];
            }
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return cy;

}));

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : danish (da)
//! author : Ulrik Nielsen : https://github.com/mrbase

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var da = moment.defineLocale('da', {
        months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
        weekdaysShort : 'sn_man_tir_ons_tor_fre_lr'.split('_'),
        weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY HH:mm',
            LLLL : 'dddd [d.] D. MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[I dag kl.] LT',
            nextDay : '[I morgen kl.] LT',
            nextWeek : 'dddd [kl.] LT',
            lastDay : '[I gr kl.] LT',
            lastWeek : '[sidste] dddd [kl] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : '%s siden',
            s : 'f sekunder',
            m : 'et minut',
            mm : '%d minutter',
            h : 'en time',
            hh : '%d timer',
            d : 'en dag',
            dd : '%d dage',
            M : 'en mned',
            MM : '%d mneder',
            y : 'et r',
            yy : '%d r'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return da;

}));

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : german (de)
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensle: https://github.com/Oire
//! author : Mikolaj Dadela : https://github.com/mik01aj

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var de = moment.defineLocale('de', {
        months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort : 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        monthsParseExact : true,
        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY HH:mm',
            LLLL : 'dddd, D. MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime : {
            future : 'in %s',
            past : 'vor %s',
            s : 'ein paar Sekunden',
            m : processRelativeTime,
            mm : '%d Minuten',
            h : processRelativeTime,
            hh : '%d Stunden',
            d : processRelativeTime,
            dd : processRelativeTime,
            M : processRelativeTime,
            MM : processRelativeTime,
            y : processRelativeTime,
            yy : processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return de;

}));

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : austrian german (de-at)
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensle: https://github.com/Oire
//! author : Martin Groller : https://github.com/MadMG
//! author : Mikolaj Dadela : https://github.com/mik01aj

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var de_at = moment.defineLocale('de-at', {
        months : 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort : 'Jn._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        monthsParseExact : true,
        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY HH:mm',
            LLLL : 'dddd, D. MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime : {
            future : 'in %s',
            past : 'vor %s',
            s : 'ein paar Sekunden',
            m : processRelativeTime,
            mm : '%d Minuten',
            h : processRelativeTime,
            hh : '%d Stunden',
            d : processRelativeTime,
            dd : processRelativeTime,
            M : processRelativeTime,
            MM : processRelativeTime,
            y : processRelativeTime,
            yy : processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return de_at;

}));

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : dhivehi (dv)
//! author : Jawish Hameed : https://github.com/jawish

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var months = [
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        ''
    ], weekdays = [
        '',
        '',
        '',
        '',
        '',
        '',
        ''
    ];

    var dv = moment.defineLocale('dv', {
        months : months,
        monthsShort : months,
        weekdays : weekdays,
        weekdaysShort : weekdays,
        weekdaysMin : '______'.split('_'),
        longDateFormat : {

            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'D/M/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM : function (input) {
            return '' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : '',
            m : '',
            mm : ' %d',
            h : '',
            hh : ' %d',
            d : '',
            dd : ' %d',
            M : '',
            MM : ' %d',
            y : '',
            yy : ' %d'
        },
        preparse: function (string) {
            return string.replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/,/g, '');
        },
        week : {
            dow : 7,  // Sunday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return dv;

}));

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : modern greek (el)
//! author : Aggelos Karalias : https://github.com/mehiel

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }


    var el = moment.defineLocale('el', {
        monthsNominativeEl : '___________'.split('_'),
        monthsGenitiveEl : '___________'.split('_'),
        months : function (momentToFormat, format) {
            if (/D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
                return this._monthsGenitiveEl[momentToFormat.month()];
            } else {
                return this._monthsNominativeEl[momentToFormat.month()];
            }
        },
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? '' : '';
            } else {
                return isLower ? '' : '';
            }
        },
        isPM : function (input) {
            return ((input + '').toLowerCase()[0] === '');
        },
        meridiemParse : /[]\.??\.?/i,
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendarEl : {
            sameDay : '[ {}] LT',
            nextDay : '[ {}] LT',
            nextWeek : 'dddd [{}] LT',
            lastDay : '[ {}] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 6:
                        return '[ ] dddd [{}] LT';
                    default:
                        return '[ ] dddd [{}] LT';
                }
            },
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendarEl[key],
                hours = mom && mom.hours();
            if (isFunction(output)) {
                output = output.apply(mom);
            }
            return output.replace('{}', (hours % 12 === 1 ? '' : ''));
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        ordinalParse: /\d{1,2}/,
        ordinal: '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4st is the first week of the year.
        }
    });

    return el;

}));

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : australian english (en-au)

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var en_au = moment.defineLocale('en-au', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return en_au;

}));

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : canadian english (en-ca)
//! author : Jonathan Abourbih : https://github.com/jonbca

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var en_ca = moment.defineLocale('en-ca', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'YYYY-MM-DD',
            LL : 'MMMM D, YYYY',
            LLL : 'MMMM D, YYYY h:mm A',
            LLLL : 'dddd, MMMM D, YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    return en_ca;

}));

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : great britain english (en-gb)
//! author : Chris Gedrim : https://github.com/chrisgedrim

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var en_gb = moment.defineLocale('en-gb', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return en_gb;

}));

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Irish english (en-ie)
//! author : Chris Cartlidge : https://github.com/chriscartlidge

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var en_ie = moment.defineLocale('en-ie', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return en_ie;

}));

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : New Zealand english (en-nz)

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var en_nz = moment.defineLocale('en-nz', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return en_nz;

}));

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : esperanto (eo)
//! author : Colin Dean : https://github.com/colindean
//! komento: Mi estas malcerta se mi korekte traktis akuzativojn en tiu traduko.
//!          Se ne, bonvolu korekti kaj avizi min por ke mi povas lerni!

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var eo = moment.defineLocale('eo', {
        months : 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_ag_sep_okt_nov_dec'.split('_'),
        weekdays : 'Dimano_Lundo_Mardo_Merkredo_ado_Vendredo_Sabato'.split('_'),
        weekdaysShort : 'Dim_Lun_Mard_Merk_a_Ven_Sab'.split('_'),
        weekdaysMin : 'Di_Lu_Ma_Me_a_Ve_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'D[-an de] MMMM, YYYY',
            LLL : 'D[-an de] MMMM, YYYY HH:mm',
            LLLL : 'dddd, [la] D[-an de] MMMM, YYYY HH:mm'
        },
        meridiemParse: /[ap]\.t\.m/i,
        isPM: function (input) {
            return input.charAt(0).toLowerCase() === 'p';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'p.t.m.' : 'P.T.M.';
            } else {
                return isLower ? 'a.t.m.' : 'A.T.M.';
            }
        },
        calendar : {
            sameDay : '[Hodia je] LT',
            nextDay : '[Morga je] LT',
            nextWeek : 'dddd [je] LT',
            lastDay : '[Hiera je] LT',
            lastWeek : '[pasinta] dddd [je] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'je %s',
            past : 'anta %s',
            s : 'sekundoj',
            m : 'minuto',
            mm : '%d minutoj',
            h : 'horo',
            hh : '%d horoj',
            d : 'tago',//ne 'diurno', ar estas uzita por proksimumo
            dd : '%d tagoj',
            M : 'monato',
            MM : '%d monatoj',
            y : 'jaro',
            yy : '%d jaroj'
        },
        ordinalParse: /\d{1,2}a/,
        ordinal : '%da',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return eo;

}));

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : spanish (es)
//! author : Julio Napur : https://github.com/julionc

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

    var es = moment.defineLocale('es', {
        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
        monthsShort : function (m, format) {
            if (/-MMM-/.test(format)) {
                return monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        monthsParseExact : true,
        weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
        weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
        weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY H:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
        },
        calendar : {
            sameDay : function () {
                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextDay : function () {
                return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastDay : function () {
                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'en %s',
            past : 'hace %s',
            s : 'unos segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'una hora',
            hh : '%d horas',
            d : 'un da',
            dd : '%d das',
            M : 'un mes',
            MM : '%d meses',
            y : 'un ao',
            yy : '%d aos'
        },
        ordinalParse : /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return es;

}));

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : estonian (et)
//! author : Henry Kehlmann : https://github.com/madhenry
//! improvements : Illimar Tambek : https://github.com/ragulka

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            's' : ['mne sekundi', 'mni sekund', 'paar sekundit'],
            'm' : ['he minuti', 'ks minut'],
            'mm': [number + ' minuti', number + ' minutit'],
            'h' : ['he tunni', 'tund aega', 'ks tund'],
            'hh': [number + ' tunni', number + ' tundi'],
            'd' : ['he peva', 'ks pev'],
            'M' : ['kuu aja', 'kuu aega', 'ks kuu'],
            'MM': [number + ' kuu', number + ' kuud'],
            'y' : ['he aasta', 'aasta', 'ks aasta'],
            'yy': [number + ' aasta', number + ' aastat']
        };
        if (withoutSuffix) {
            return format[key][2] ? format[key][2] : format[key][1];
        }
        return isFuture ? format[key][0] : format[key][1];
    }

    var et = moment.defineLocale('et', {
        months        : 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
        monthsShort   : 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
        weekdays      : 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),
        weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
        weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
        longDateFormat : {
            LT   : 'H:mm',
            LTS : 'H:mm:ss',
            L    : 'DD.MM.YYYY',
            LL   : 'D. MMMM YYYY',
            LLL  : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[Tna,] LT',
            nextDay  : '[Homme,] LT',
            nextWeek : '[Jrgmine] dddd LT',
            lastDay  : '[Eile,] LT',
            lastWeek : '[Eelmine] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s prast',
            past   : '%s tagasi',
            s      : processRelativeTime,
            m      : processRelativeTime,
            mm     : processRelativeTime,
            h      : processRelativeTime,
            hh     : processRelativeTime,
            d      : processRelativeTime,
            dd     : '%d peva',
            M      : processRelativeTime,
            MM     : processRelativeTime,
            y      : processRelativeTime,
            yy     : processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return et;

}));

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : euskara (eu)
//! author : Eneko Illarramendi : https://github.com/eillarra

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var eu = moment.defineLocale('eu', {
        months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
        monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
        monthsParseExact : true,
        weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
        weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
        weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'YYYY[ko] MMMM[ren] D[a]',
            LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',
            LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
            l : 'YYYY-M-D',
            ll : 'YYYY[ko] MMM D[a]',
            lll : 'YYYY[ko] MMM D[a] HH:mm',
            llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'
        },
        calendar : {
            sameDay : '[gaur] LT[etan]',
            nextDay : '[bihar] LT[etan]',
            nextWeek : 'dddd LT[etan]',
            lastDay : '[atzo] LT[etan]',
            lastWeek : '[aurreko] dddd LT[etan]',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s barru',
            past : 'duela %s',
            s : 'segundo batzuk',
            m : 'minutu bat',
            mm : '%d minutu',
            h : 'ordu bat',
            hh : '%d ordu',
            d : 'egun bat',
            dd : '%d egun',
            M : 'hilabete bat',
            MM : '%d hilabete',
            y : 'urte bat',
            yy : '%d urte'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return eu;

}));

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Persian (fa)
//! author : Ebrahim Byagowi : https://github.com/ebraminio

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var fa = moment.defineLocale('fa', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '\u200c__\u200c__\u200c__'.split('_'),
        weekdaysShort : '\u200c__\u200c__\u200c__'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        meridiemParse: /  |  /,
        isPM: function (input) {
            return /  /.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '  ';
            } else {
                return '  ';
            }
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ] LT',
            lastWeek : 'dddd [] [] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[-]/g, function (match) {
                return numberMap[match];
            }).replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '');
        },
        ordinalParse: /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return fa;

}));

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : finnish (fi)
//! author : Tarmo Aidantausta : https://github.com/bleadof

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' '),
        numbersFuture = [
            'nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden',
            numbersPast[7], numbersPast[8], numbersPast[9]
        ];
    function translate(number, withoutSuffix, key, isFuture) {
        var result = '';
        switch (key) {
        case 's':
            return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
        case 'm':
            return isFuture ? 'minuutin' : 'minuutti';
        case 'mm':
            result = isFuture ? 'minuutin' : 'minuuttia';
            break;
        case 'h':
            return isFuture ? 'tunnin' : 'tunti';
        case 'hh':
            result = isFuture ? 'tunnin' : 'tuntia';
            break;
        case 'd':
            return isFuture ? 'pivn' : 'piv';
        case 'dd':
            result = isFuture ? 'pivn' : 'piv';
            break;
        case 'M':
            return isFuture ? 'kuukauden' : 'kuukausi';
        case 'MM':
            result = isFuture ? 'kuukauden' : 'kuukautta';
            break;
        case 'y':
            return isFuture ? 'vuoden' : 'vuosi';
        case 'yy':
            result = isFuture ? 'vuoden' : 'vuotta';
            break;
        }
        result = verbalNumber(number, isFuture) + ' ' + result;
        return result;
    }
    function verbalNumber(number, isFuture) {
        return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
    }

    var fi = moment.defineLocale('fi', {
        months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
        monthsShort : 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),
        weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
        weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
        weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD.MM.YYYY',
            LL : 'Do MMMM[ta] YYYY',
            LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',
            LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
            l : 'D.M.YYYY',
            ll : 'Do MMM YYYY',
            lll : 'Do MMM YYYY, [klo] HH.mm',
            llll : 'ddd, Do MMM YYYY, [klo] HH.mm'
        },
        calendar : {
            sameDay : '[tnn] [klo] LT',
            nextDay : '[huomenna] [klo] LT',
            nextWeek : 'dddd [klo] LT',
            lastDay : '[eilen] [klo] LT',
            lastWeek : '[viime] dddd[na] [klo] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s pst',
            past : '%s sitten',
            s : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fi;

}));

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : faroese (fo)
//! author : Ragnar Johannesen : https://github.com/ragnar123

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var fo = moment.defineLocale('fo', {
        months : 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays : 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),
        weekdaysShort : 'sun_mn_ts_mik_hs_fr_ley'.split('_'),
        weekdaysMin : 'su_m_t_mi_h_fr_le'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D. MMMM, YYYY HH:mm'
        },
        calendar : {
            sameDay : '[ dag kl.] LT',
            nextDay : '[ morgin kl.] LT',
            nextWeek : 'dddd [kl.] LT',
            lastDay : '[ gjr kl.] LT',
            lastWeek : '[sstu] dddd [kl] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'um %s',
            past : '%s sani',
            s : 'f sekund',
            m : 'ein minutt',
            mm : '%d minuttir',
            h : 'ein tmi',
            hh : '%d tmar',
            d : 'ein dagur',
            dd : '%d dagar',
            M : 'ein mnai',
            MM : '%d mnair',
            y : 'eitt r',
            yy : '%d r'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fo;

}));

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : french (fr)
//! author : John Fischer : https://github.com/jfroffice

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var fr = moment.defineLocale('fr', {
        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
        monthsParseExact : true,
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Aujourd\'hui ] LT',
            nextDay: '[Demain ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[Hier ] LT',
            lastWeek: 'dddd [dernier ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        ordinalParse: /\d{1,2}(er|)/,
        ordinal : function (number) {
            return number + (number === 1 ? 'er' : '');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fr;

}));

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : canadian french (fr-ca)
//! author : Jonathan Abourbih : https://github.com/jonbca

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var fr_ca = moment.defineLocale('fr-ca', {
        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
        monthsParseExact : true,
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Aujourd\'hui ] LT',
            nextDay: '[Demain ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[Hier ] LT',
            lastWeek: 'dddd [dernier ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        ordinalParse: /\d{1,2}(er|e)/,
        ordinal : function (number) {
            return number + (number === 1 ? 'er' : 'e');
        }
    });

    return fr_ca;

}));

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : swiss french (fr)
//! author : Gaspard Bucher : https://github.com/gaspard

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var fr_ch = moment.defineLocale('fr-ch', {
        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
        monthsParseExact : true,
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Aujourd\'hui ] LT',
            nextDay: '[Demain ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[Hier ] LT',
            lastWeek: 'dddd [dernier ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        ordinalParse: /\d{1,2}(er|e)/,
        ordinal : function (number) {
            return number + (number === 1 ? 'er' : 'e');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fr_ch;

}));

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : frisian (fy)
//! author : Robin van der Vliet : https://github.com/robin0van0der0v

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),
        monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');

    var fy = moment.defineLocale('fy', {
        months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
        monthsShort : function (m, format) {
            if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots[m.month()];
            } else {
                return monthsShortWithDots[m.month()];
            }
        },
        monthsParseExact : true,
        weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
        weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
        weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[hjoed om] LT',
            nextDay: '[moarn om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[juster om] LT',
            lastWeek: '[frne] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'oer %s',
            past : '%s lyn',
            s : 'in pear sekonden',
            m : 'ien mint',
            mm : '%d minuten',
            h : 'ien oere',
            hh : '%d oeren',
            d : 'ien dei',
            dd : '%d dagen',
            M : 'ien moanne',
            MM : '%d moannen',
            y : 'ien jier',
            yy : '%d jierren'
        },
        ordinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fy;

}));

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : great britain scottish gealic (gd)
//! author : Jon Ashdown : https://github.com/jonashdown

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var months = [
        'Am Faoilleach', 'An Gearran', 'Am Mrt', 'An Giblean', 'An Citean', 'An t-gmhios', 'An t-Iuchar', 'An Lnastal', 'An t-Sultain', 'An Dmhair', 'An t-Samhain', 'An Dbhlachd'
    ];

    var monthsShort = ['Faoi', 'Gear', 'Mrt', 'Gibl', 'Cit', 'gmh', 'Iuch', 'Ln', 'Sult', 'Dmh', 'Samh', 'Dbh'];

    var weekdays = ['Didmhnaich', 'Diluain', 'Dimirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];

    var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];

    var weekdaysMin = ['D', 'Lu', 'M', 'Ci', 'Ar', 'Ha', 'Sa'];

    var gd = moment.defineLocale('gd', {
        months : months,
        monthsShort : monthsShort,
        monthsParseExact : true,
        weekdays : weekdays,
        weekdaysShort : weekdaysShort,
        weekdaysMin : weekdaysMin,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[An-diugh aig] LT',
            nextDay : '[A-mireach aig] LT',
            nextWeek : 'dddd [aig] LT',
            lastDay : '[An-d aig] LT',
            lastWeek : 'dddd [seo chaidh] [aig] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'ann an %s',
            past : 'bho chionn %s',
            s : 'beagan diogan',
            m : 'mionaid',
            mm : '%d mionaidean',
            h : 'uair',
            hh : '%d uairean',
            d : 'latha',
            dd : '%d latha',
            M : 'mos',
            MM : '%d mosan',
            y : 'bliadhna',
            yy : '%d bliadhna'
        },
        ordinalParse : /\d{1,2}(d|na|mh)/,
        ordinal : function (number) {
            var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return gd;

}));

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : galician (gl)
//! author : Juan G. Hurtado : https://github.com/juanghurtado

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var gl = moment.defineLocale('gl', {
        months : 'Xaneiro_Febreiro_Marzo_Abril_Maio_Xuo_Xullo_Agosto_Setembro_Outubro_Novembro_Decembro'.split('_'),
        monthsShort : 'Xan._Feb._Mar._Abr._Mai._Xu._Xul._Ago._Set._Out._Nov._Dec.'.split('_'),
        monthsParseExact: true,
        weekdays : 'Domingo_Luns_Martes_Mrcores_Xoves_Venres_Sbado'.split('_'),
        weekdaysShort : 'Dom._Lun._Mar._Mr._Xov._Ven._Sb.'.split('_'),
        weekdaysMin : 'Do_Lu_Ma_M_Xo_Ve_S'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay : function () {
                return '[hoxe ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextDay : function () {
                return '[ma ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
            },
            lastDay : function () {
                return '[onte ' + ((this.hours() !== 1) ? '' : 'a') + '] LT';
            },
            lastWeek : function () {
                return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : function (str) {
                if (str === 'uns segundos') {
                    return 'nuns segundos';
                }
                return 'en ' + str;
            },
            past : 'hai %s',
            s : 'uns segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'unha hora',
            hh : '%d horas',
            d : 'un da',
            dd : '%d das',
            M : 'un mes',
            MM : '%d meses',
            y : 'un ano',
            yy : '%d anos'
        },
        ordinalParse : /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return gl;

}));

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hebrew (he)
//! author : Tomer Cohen : https://github.com/tomer
//! author : Moshe Simantov : https://github.com/DevelopmentIL
//! author : Tal Ater : https://github.com/TalAter

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var he = moment.defineLocale('he', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D []MMMM YYYY',
            LLL : 'D []MMMM YYYY HH:mm',
            LLLL : 'dddd, D []MMMM YYYY HH:mm',
            l : 'D/M/YYYY',
            ll : 'D MMM YYYY',
            lll : 'D MMM YYYY HH:mm',
            llll : 'ddd, D MMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[ ]LT',
            nextDay : '[ ]LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ]LT',
            lastWeek : '[] dddd [ ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : ' ',
            m : '',
            mm : '%d ',
            h : '',
            hh : function (number) {
                if (number === 2) {
                    return '';
                }
                return number + ' ';
            },
            d : '',
            dd : function (number) {
                if (number === 2) {
                    return '';
                }
                return number + ' ';
            },
            M : '',
            MM : function (number) {
                if (number === 2) {
                    return '';
                }
                return number + ' ';
            },
            y : '',
            yy : function (number) {
                if (number === 2) {
                    return '';
                } else if (number % 10 === 0 && number !== 10) {
                    return number + ' ';
                }
                return number + ' ';
            }
        },
        meridiemParse: /"|"| | | ||/i,
        isPM : function (input) {
            return /^("| |)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 5) {
                return ' ';
            } else if (hour < 10) {
                return '';
            } else if (hour < 12) {
                return isLower ? '"' : ' ';
            } else if (hour < 18) {
                return isLower ? '"' : ' ';
            } else {
                return '';
            }
        }
    });

    return he;

}));

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : hindi (hi)
//! author : Mayank Singhal : https://github.com/mayanksinghal

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var hi = moment.defineLocale('hi', {
        months : '___________'.split('_'),
        monthsShort : '._.__.___._._._._._.'.split('_'),
        monthsParseExact: true,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm ',
            LTS : 'A h:mm:ss ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm '
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : '  ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // Hindi notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
        meridiemParse: /|||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return hi;

}));

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : hrvatski (hr)
//! author : Bojan Markovi : https://github.com/bmarkovic

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
        case 'm':
            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
        case 'mm':
            if (number === 1) {
                result += 'minuta';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'minute';
            } else {
                result += 'minuta';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'jedan sat' : 'jednog sata';
        case 'hh':
            if (number === 1) {
                result += 'sat';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'sata';
            } else {
                result += 'sati';
            }
            return result;
        case 'dd':
            if (number === 1) {
                result += 'dan';
            } else {
                result += 'dana';
            }
            return result;
        case 'MM':
            if (number === 1) {
                result += 'mjesec';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'mjeseca';
            } else {
                result += 'mjeseci';
            }
            return result;
        case 'yy':
            if (number === 1) {
                result += 'godina';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'godine';
            } else {
                result += 'godina';
            }
            return result;
        }
    }

    var hr = moment.defineLocale('hr', {
        months : {
            format: 'sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
            standalone: 'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
        },
        monthsShort : 'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
        monthsParseExact: true,
        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
        weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
        weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD. MM. YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[danas u] LT',
            nextDay  : '[sutra u] LT',
            nextWeek : function () {
                switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[juer u] LT',
            lastWeek : function () {
                switch (this.day()) {
                case 0:
                case 3:
                    return '[prolu] dddd [u] LT';
                case 6:
                    return '[prole] [subote] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[proli] dddd [u] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'par sekundi',
            m      : translate,
            mm     : translate,
            h      : translate,
            hh     : translate,
            d      : 'dan',
            dd     : translate,
            M      : 'mjesec',
            MM     : translate,
            y      : 'godinu',
            yy     : translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return hr;

}));

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : hungarian (hu)
//! author : Adam Brunner : https://github.com/adambrunner

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');
    function translate(number, withoutSuffix, key, isFuture) {
        var num = number,
            suffix;
        switch (key) {
        case 's':
            return (isFuture || withoutSuffix) ? 'nhny msodperc' : 'nhny msodperce';
        case 'm':
            return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
        case 'mm':
            return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
        case 'h':
            return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');
        case 'hh':
            return num + (isFuture || withoutSuffix ? ' ra' : ' rja');
        case 'd':
            return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
        case 'dd':
            return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
        case 'M':
            return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
        case 'MM':
            return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
        case 'y':
            return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');
        case 'yy':
            return num + (isFuture || withoutSuffix ? ' v' : ' ve');
        }
        return '';
    }
    function week(isFuture) {
        return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
    }

    var hu = moment.defineLocale('hu', {
        months : 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),
        monthsShort : 'jan_feb_mrc_pr_mj_jn_jl_aug_szept_okt_nov_dec'.split('_'),
        weekdays : 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),
        weekdaysShort : 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),
        weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'YYYY.MM.DD.',
            LL : 'YYYY. MMMM D.',
            LLL : 'YYYY. MMMM D. H:mm',
            LLLL : 'YYYY. MMMM D., dddd H:mm'
        },
        meridiemParse: /de|du/i,
        isPM: function (input) {
            return input.charAt(1).toLowerCase() === 'u';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower === true ? 'de' : 'DE';
            } else {
                return isLower === true ? 'du' : 'DU';
            }
        },
        calendar : {
            sameDay : '[ma] LT[-kor]',
            nextDay : '[holnap] LT[-kor]',
            nextWeek : function () {
                return week.call(this, true);
            },
            lastDay : '[tegnap] LT[-kor]',
            lastWeek : function () {
                return week.call(this, false);
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s mlva',
            past : '%s',
            s : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return hu;

}));

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Armenian (hy-am)
//! author : Armendarabyan : https://github.com/armendarabyan

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var hy_am = moment.defineLocale('hy-am', {
        months : {
            format: '___________'.split('_'),
            standalone: '___________'.split('_')
        },
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY .',
            LLL : 'D MMMM YYYY ., HH:mm',
            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
        },
        calendar : {
            sameDay: '[] LT',
            nextDay: '[] LT',
            lastDay: '[] LT',
            nextWeek: function () {
                return 'dddd [ ] LT';
            },
            lastWeek: function () {
                return '[] dddd [ ] LT';
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : '  ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        meridiemParse: /|||/,
        isPM: function (input) {
            return /^(|)$/.test(input);
        },
        meridiem : function (hour) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return '';
            } else {
                return '';
            }
        },
        ordinalParse: /\d{1,2}|\d{1,2}-(|)/,
        ordinal: function (number, period) {
            switch (period) {
            case 'DDD':
            case 'w':
            case 'W':
            case 'DDDo':
                if (number === 1) {
                    return number + '-';
                }
                return number + '-';
            default:
                return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return hy_am;

}));

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bahasa Indonesia (id)
//! author : Mohammad Satrio Utomo : https://github.com/tyok
//! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var id = moment.defineLocale('id', {
        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
        weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
        weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|siang|sore|malam/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'siang') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'sore' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'siang';
            } else if (hours < 19) {
                return 'sore';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Besok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kemarin pukul] LT',
            lastWeek : 'dddd [lalu pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lalu',
            s : 'beberapa detik',
            m : 'semenit',
            mm : '%d menit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return id;

}));

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : icelandic (is)
//! author : Hinrik rn Sigursson : https://github.com/hinrik

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function plural(n) {
        if (n % 100 === 11) {
            return true;
        } else if (n % 10 === 1) {
            return false;
        }
        return true;
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
        case 's':
            return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';
        case 'm':
            return withoutSuffix ? 'mnta' : 'mntu';
        case 'mm':
            if (plural(number)) {
                return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');
            } else if (withoutSuffix) {
                return result + 'mnta';
            }
            return result + 'mntu';
        case 'hh':
            if (plural(number)) {
                return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
            }
            return result + 'klukkustund';
        case 'd':
            if (withoutSuffix) {
                return 'dagur';
            }
            return isFuture ? 'dag' : 'degi';
        case 'dd':
            if (plural(number)) {
                if (withoutSuffix) {
                    return result + 'dagar';
                }
                return result + (isFuture ? 'daga' : 'dgum');
            } else if (withoutSuffix) {
                return result + 'dagur';
            }
            return result + (isFuture ? 'dag' : 'degi');
        case 'M':
            if (withoutSuffix) {
                return 'mnuur';
            }
            return isFuture ? 'mnu' : 'mnui';
        case 'MM':
            if (plural(number)) {
                if (withoutSuffix) {
                    return result + 'mnuir';
                }
                return result + (isFuture ? 'mnui' : 'mnuum');
            } else if (withoutSuffix) {
                return result + 'mnuur';
            }
            return result + (isFuture ? 'mnu' : 'mnui');
        case 'y':
            return withoutSuffix || isFuture ? 'r' : 'ri';
        case 'yy':
            if (plural(number)) {
                return result + (withoutSuffix || isFuture ? 'r' : 'rum');
            }
            return result + (withoutSuffix || isFuture ? 'r' : 'ri');
        }
    }

    var is = moment.defineLocale('is', {
        months : 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),
        weekdays : 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),
        weekdaysShort : 'sun_mn_ri_mi_fim_fs_lau'.split('_'),
        weekdaysMin : 'Su_M_r_Mi_Fi_F_La'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY [kl.] H:mm',
            LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'
        },
        calendar : {
            sameDay : '[ dag kl.] LT',
            nextDay : '[ morgun kl.] LT',
            nextWeek : 'dddd [kl.] LT',
            lastDay : '[ gr kl.] LT',
            lastWeek : '[sasta] dddd [kl.] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'eftir %s',
            past : 'fyrir %s san',
            s : translate,
            m : translate,
            mm : translate,
            h : 'klukkustund',
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return is;

}));

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : italian (it)
//! author : Lorenzo : https://github.com/aliem
//! author: Mattia Larentis: https://github.com/nostalgiaz

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var it = moment.defineLocale('it', {
        months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
        monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
        weekdays : 'Domenica_Luned_Marted_Mercoled_Gioved_Venerd_Sabato'.split('_'),
        weekdaysShort : 'Dom_Lun_Mar_Mer_Gio_Ven_Sab'.split('_'),
        weekdaysMin : 'Do_Lu_Ma_Me_Gi_Ve_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Oggi alle] LT',
            nextDay: '[Domani alle] LT',
            nextWeek: 'dddd [alle] LT',
            lastDay: '[Ieri alle] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[la scorsa] dddd [alle] LT';
                    default:
                        return '[lo scorso] dddd [alle] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : function (s) {
                return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
            },
            past : '%s fa',
            s : 'alcuni secondi',
            m : 'un minuto',
            mm : '%d minuti',
            h : 'un\'ora',
            hh : '%d ore',
            d : 'un giorno',
            dd : '%d giorni',
            M : 'un mese',
            MM : '%d mesi',
            y : 'un anno',
            yy : '%d anni'
        },
        ordinalParse : /\d{1,2}/,
        ordinal: '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return it;

}));

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : japanese (ja)
//! author : LI Long : https://github.com/baryon

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var ja = moment.defineLocale('ja', {
        months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'Ahm',
            LTS : 'Ahms',
            L : 'YYYY/MM/DD',
            LL : 'YYYYMD',
            LLL : 'YYYYMDAhm',
            LLLL : 'YYYYMDAhm dddd'
        },
        meridiemParse: /|/i,
        isPM : function (input) {
            return input === '';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : '[]dddd LT',
            lastDay : '[] LT',
            lastWeek : '[]dddd LT',
            sameElse : 'L'
        },
        ordinalParse : /\d{1,2}/,
        ordinal : function (number, period) {
            switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
                return number + '';
            default:
                return number;
            }
        },
        relativeTime : {
            future : '%s',
            past : '%s',
            s : '',
            m : '1',
            mm : '%d',
            h : '1',
            hh : '%d',
            d : '1',
            dd : '%d',
            M : '1',
            MM : '%d',
            y : '1',
            yy : '%d'
        }
    });

    return ja;

}));

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Boso Jowo (jv)
//! author : Rony Lantip : https://github.com/lantip
//! reference: http://jv.wikipedia.org/wiki/Basa_Jawa

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var jv = moment.defineLocale('jv', {
        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
        weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
        weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /enjing|siyang|sonten|ndalu/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'enjing') {
                return hour;
            } else if (meridiem === 'siyang') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'enjing';
            } else if (hours < 15) {
                return 'siyang';
            } else if (hours < 19) {
                return 'sonten';
            } else {
                return 'ndalu';
            }
        },
        calendar : {
            sameDay : '[Dinten puniko pukul] LT',
            nextDay : '[Mbenjang pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kala wingi pukul] LT',
            lastWeek : 'dddd [kepengker pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'wonten ing %s',
            past : '%s ingkang kepengker',
            s : 'sawetawis detik',
            m : 'setunggal menit',
            mm : '%d menit',
            h : 'setunggal jam',
            hh : '%d jam',
            d : 'sedinten',
            dd : '%d dinten',
            M : 'sewulan',
            MM : '%d wulan',
            y : 'setaun',
            yy : '%d taun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return jv;

}));

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Georgian (ka)
//! author : Irakli Janiashvili : https://github.com/irakli-janiashvili

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var ka = moment.defineLocale('ka', {
        months : {
            standalone: '___________'.split('_'),
            format: '___________'.split('_')
        },
        monthsShort : '___________'.split('_'),
        weekdays : {
            standalone: '______'.split('_'),
            format: '______'.split('_'),
            isFormat: /(|)/
        },
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[] LT[-]',
            nextDay : '[] LT[-]',
            lastDay : '[] LT[-]',
            nextWeek : '[] dddd LT[-]',
            lastWeek : '[] dddd LT-',
            sameElse : 'L'
        },
        relativeTime : {
            future : function (s) {
                return (/(|||)/).test(s) ?
                    s.replace(/$/, '') :
                    s + '';
            },
            past : function (s) {
                if ((/(||||)/).test(s)) {
                    return s.replace(/(|)$/, ' ');
                }
                if ((//).test(s)) {
                    return s.replace(/$/, ' ');
                }
            },
            s : ' ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        ordinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
        ordinal : function (number) {
            if (number === 0) {
                return number;
            }
            if (number === 1) {
                return number + '-';
            }
            if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
                return '-' + number;
            }
            return number + '-';
        },
        week : {
            dow : 1,
            doy : 7
        }
    });

    return ka;

}));

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : kazakh (kk)
//! authors : Nurlan Rakhimzhanov : https://github.com/nurlan

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var suffixes = {
        0: '-',
        1: '-',
        2: '-',
        3: '-',
        4: '-',
        5: '-',
        6: '-',
        7: '-',
        8: '-',
        9: '-',
        10: '-',
        20: '-',
        30: '-',
        40: '-',
        50: '-',
        60: '-',
        70: '-',
        80: '-',
        90: '-',
        100: '-'
    };

    var kk = moment.defineLocale('kk', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ] LT',
            lastWeek : '[ ] dddd [] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        ordinalParse: /\d{1,2}-(|)/,
        ordinal : function (number) {
            var a = number % 10,
                b = number >= 100 ? 100 : null;
            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return kk;

}));

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : khmer (km)
//! author : Kruy Vanna : https://github.com/kruyvanna

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var km = moment.defineLocale('km', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS : 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[ ] LT',
            lastWeek: 'dddd [] [] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s',
            past: '%s',
            s: '',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return km;

}));

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : korean (ko)
//!
//! authors
//!
//! - Kyungwook, Park : https://github.com/kyungw00k
//! - Jeeeyul Lee <jeeeyul@gmail.com>

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var ko = moment.defineLocale('ko', {
        months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h m',
            LTS : 'A h m s',
            L : 'YYYY.MM.DD',
            LL : 'YYYY MMMM D',
            LLL : 'YYYY MMMM D A h m',
            LLLL : 'YYYY MMMM D dddd A h m'
        },
        calendar : {
            sameDay : ' LT',
            nextDay : ' LT',
            nextWeek : 'dddd LT',
            lastDay : ' LT',
            lastWeek : ' dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            ss : '%d',
            m : '',
            mm : '%d',
            h : ' ',
            hh : '%d',
            d : '',
            dd : '%d',
            M : ' ',
            MM : '%d',
            y : ' ',
            yy : '%d'
        },
        ordinalParse : /\d{1,2}/,
        ordinal : '%d',
        meridiemParse : /|/,
        isPM : function (token) {
            return token === '';
        },
        meridiem : function (hour, minute, isUpper) {
            return hour < 12 ? '' : '';
        }
    });

    return ko;

}));

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : kyrgyz (ky)
//! author : Chyngyz Arystan uulu : https://github.com/chyngyz

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';



    var suffixes = {
        0: '-',
        1: '-',
        2: '-',
        3: '-',
        4: '-',
        5: '-',
        6: '-',
        7: '-',
        8: '-',
        9: '-',
        10: '-',
        20: '-',
        30: '-',
        40: '-',
        50: '-',
        60: '-',
        70: '-',
        80: '-',
        90: '-',
        100: '-'
    };

    var ky = moment.defineLocale('ky', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ] LT',
            lastWeek : '[ ] dddd [] [] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        ordinalParse: /\d{1,2}-(|||)/,
        ordinal : function (number) {
            var a = number % 10,
                b = number >= 100 ? 100 : null;
            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ky;

}));

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Luxembourgish (lb)
//! author : mweimerskirch : https://github.com/mweimerskirch, David Raison : https://github.com/kwisatz

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eng Minutt', 'enger Minutt'],
            'h': ['eng Stonn', 'enger Stonn'],
            'd': ['een Dag', 'engem Dag'],
            'M': ['ee Mount', 'engem Mount'],
            'y': ['ee Joer', 'engem Joer']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }
    function processFutureTime(string) {
        var number = string.substr(0, string.indexOf(' '));
        if (eifelerRegelAppliesToNumber(number)) {
            return 'a ' + string;
        }
        return 'an ' + string;
    }
    function processPastTime(string) {
        var number = string.substr(0, string.indexOf(' '));
        if (eifelerRegelAppliesToNumber(number)) {
            return 'viru ' + string;
        }
        return 'virun ' + string;
    }
    /**
     * Returns true if the word before the given number loses the '-n' ending.
     * e.g. 'an 10 Deeg' but 'a 5 Deeg'
     *
     * @param number {integer}
     * @returns {boolean}
     */
    function eifelerRegelAppliesToNumber(number) {
        number = parseInt(number, 10);
        if (isNaN(number)) {
            return false;
        }
        if (number < 0) {
            // Negative Number --> always true
            return true;
        } else if (number < 10) {
            // Only 1 digit
            if (4 <= number && number <= 7) {
                return true;
            }
            return false;
        } else if (number < 100) {
            // 2 digits
            var lastDigit = number % 10, firstDigit = number / 10;
            if (lastDigit === 0) {
                return eifelerRegelAppliesToNumber(firstDigit);
            }
            return eifelerRegelAppliesToNumber(lastDigit);
        } else if (number < 10000) {
            // 3 or 4 digits --> recursively check first digit
            while (number >= 10) {
                number = number / 10;
            }
            return eifelerRegelAppliesToNumber(number);
        } else {
            // Anything larger than 4 digits: recursively check first n-3 digits
            number = number / 1000;
            return eifelerRegelAppliesToNumber(number);
        }
    }

    var lb = moment.defineLocale('lb', {
        months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        monthsParseExact : true,
        weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
        weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),
        weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'H:mm [Auer]',
            LTS: 'H:mm:ss [Auer]',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm [Auer]',
            LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
        },
        calendar: {
            sameDay: '[Haut um] LT',
            sameElse: 'L',
            nextDay: '[Muer um] LT',
            nextWeek: 'dddd [um] LT',
            lastDay: '[Gschter um] LT',
            lastWeek: function () {
                // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
                switch (this.day()) {
                    case 2:
                    case 4:
                        return '[Leschten] dddd [um] LT';
                    default:
                        return '[Leschte] dddd [um] LT';
                }
            }
        },
        relativeTime : {
            future : processFutureTime,
            past : processPastTime,
            s : 'e puer Sekonnen',
            m : processRelativeTime,
            mm : '%d Minutten',
            h : processRelativeTime,
            hh : '%d Stonnen',
            d : processRelativeTime,
            dd : '%d Deeg',
            M : processRelativeTime,
            MM : '%d Mint',
            y : processRelativeTime,
            yy : '%d Joer'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return lb;

}));

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : lao (lo)
//! author : Ryan Hart : https://github.com/ryanhart2

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var lo = moment.defineLocale('lo', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM: function (input) {
            return input === '';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : '[]dddd[] LT',
            lastDay : '[] LT',
            lastWeek : '[]dddd[] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s',
            s : '',
            m : '1 ',
            mm : '%d ',
            h : '1 ',
            hh : '%d ',
            d : '1 ',
            dd : '%d ',
            M : '1 ',
            MM : '%d ',
            y : '1 ',
            yy : '%d '
        },
        ordinalParse: /()\d{1,2}/,
        ordinal : function (number) {
            return '' + number;
        }
    });

    return lo;

}));

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Lithuanian (lt)
//! author : Mindaugas Mozras : https://github.com/mmozuras

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var units = {
        'm' : 'minut_minuts_minut',
        'mm': 'minuts_minui_minutes',
        'h' : 'valanda_valandos_valand',
        'hh': 'valandos_valand_valandas',
        'd' : 'diena_dienos_dien',
        'dd': 'dienos_dien_dienas',
        'M' : 'mnuo_mnesio_mnes',
        'MM': 'mnesiai_mnesi_mnesius',
        'y' : 'metai_met_metus',
        'yy': 'metai_met_metus'
    };
    function translateSeconds(number, withoutSuffix, key, isFuture) {
        if (withoutSuffix) {
            return 'kelios sekunds';
        } else {
            return isFuture ? 'keli sekundi' : 'kelias sekundes';
        }
    }
    function translateSingular(number, withoutSuffix, key, isFuture) {
        return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
    }
    function special(number) {
        return number % 10 === 0 || (number > 10 && number < 20);
    }
    function forms(key) {
        return units[key].split('_');
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        if (number === 1) {
            return result + translateSingular(number, withoutSuffix, key[0], isFuture);
        } else if (withoutSuffix) {
            return result + (special(number) ? forms(key)[1] : forms(key)[0]);
        } else {
            if (isFuture) {
                return result + forms(key)[1];
            } else {
                return result + (special(number) ? forms(key)[1] : forms(key)[2]);
            }
        }
    }
    var lt = moment.defineLocale('lt', {
        months : {
            format: 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_'),
            standalone: 'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split('_')
        },
        monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
        weekdays : {
            format: 'sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien'.split('_'),
            standalone: 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_'),
            isFormat: /dddd HH:mm/
        },
        weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),
        weekdaysMin : 'S_P_A_T_K_Pn_'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'YYYY [m.] MMMM D [d.]',
            LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
            LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
            l : 'YYYY-MM-DD',
            ll : 'YYYY [m.] MMMM D [d.]',
            lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
            llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
        },
        calendar : {
            sameDay : '[iandien] LT',
            nextDay : '[Rytoj] LT',
            nextWeek : 'dddd LT',
            lastDay : '[Vakar] LT',
            lastWeek : '[Prajus] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'po %s',
            past : 'prie %s',
            s : translateSeconds,
            m : translateSingular,
            mm : translate,
            h : translateSingular,
            hh : translate,
            d : translateSingular,
            dd : translate,
            M : translateSingular,
            MM : translate,
            y : translateSingular,
            yy : translate
        },
        ordinalParse: /\d{1,2}-oji/,
        ordinal : function (number) {
            return number + '-oji';
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return lt;

}));

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : latvian (lv)
//! author : Kristaps Karlsons : https://github.com/skakri
//! author : Jnis Elmeris : https://github.com/JanisE

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var units = {
        'm': 'mintes_mintm_minte_mintes'.split('_'),
        'mm': 'mintes_mintm_minte_mintes'.split('_'),
        'h': 'stundas_stundm_stunda_stundas'.split('_'),
        'hh': 'stundas_stundm_stunda_stundas'.split('_'),
        'd': 'dienas_dienm_diena_dienas'.split('_'),
        'dd': 'dienas_dienm_diena_dienas'.split('_'),
        'M': 'mnea_mneiem_mnesis_mnei'.split('_'),
        'MM': 'mnea_mneiem_mnesis_mnei'.split('_'),
        'y': 'gada_gadiem_gads_gadi'.split('_'),
        'yy': 'gada_gadiem_gads_gadi'.split('_')
    };
    /**
     * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
     */
    function format(forms, number, withoutSuffix) {
        if (withoutSuffix) {
            // E.g. "21 minte", "3 mintes".
            return number % 10 === 1 && number !== 11 ? forms[2] : forms[3];
        } else {
            // E.g. "21 mintes" as in "pc 21 mintes".
            // E.g. "3 mintm" as in "pc 3 mintm".
            return number % 10 === 1 && number !== 11 ? forms[0] : forms[1];
        }
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        return number + ' ' + format(units[key], number, withoutSuffix);
    }
    function relativeTimeWithSingular(number, withoutSuffix, key) {
        return format(units[key], number, withoutSuffix);
    }
    function relativeSeconds(number, withoutSuffix) {
        return withoutSuffix ? 'daas sekundes' : 'dam sekundm';
    }

    var lv = moment.defineLocale('lv', {
        months : 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),
        weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
        weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY.',
            LL : 'YYYY. [gada] D. MMMM',
            LLL : 'YYYY. [gada] D. MMMM, HH:mm',
            LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'
        },
        calendar : {
            sameDay : '[odien pulksten] LT',
            nextDay : '[Rt pulksten] LT',
            nextWeek : 'dddd [pulksten] LT',
            lastDay : '[Vakar pulksten] LT',
            lastWeek : '[Pagju] dddd [pulksten] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'pc %s',
            past : 'pirms %s',
            s : relativeSeconds,
            m : relativeTimeWithSingular,
            mm : relativeTimeWithPlural,
            h : relativeTimeWithSingular,
            hh : relativeTimeWithPlural,
            d : relativeTimeWithSingular,
            dd : relativeTimeWithPlural,
            M : relativeTimeWithSingular,
            MM : relativeTimeWithPlural,
            y : relativeTimeWithSingular,
            yy : relativeTimeWithPlural
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return lv;

}));

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Montenegrin (me)
//! author : Miodrag Nika <miodrag@restartit.me> : https://github.com/miodragnikac

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var translator = {
        words: { //Different grammatical cases
            m: ['jedan minut', 'jednog minuta'],
            mm: ['minut', 'minuta', 'minuta'],
            h: ['jedan sat', 'jednog sata'],
            hh: ['sat', 'sata', 'sati'],
            dd: ['dan', 'dana', 'dana'],
            MM: ['mjesec', 'mjeseca', 'mjeseci'],
            yy: ['godina', 'godine', 'godina']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var me = moment.defineLocale('me', {
        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
        monthsParseExact : true,
        weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
        weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L: 'DD. MM. YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sjutra u] LT',

            nextWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[jue u] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[prole] [nedjelje] [u] LT',
                    '[prolog] [ponedjeljka] [u] LT',
                    '[prolog] [utorka] [u] LT',
                    '[prole] [srijede] [u] LT',
                    '[prolog] [etvrtka] [u] LT',
                    '[prolog] [petka] [u] LT',
                    '[prole] [subote] [u] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'nekoliko sekundi',
            m      : translator.translate,
            mm     : translator.translate,
            h      : translator.translate,
            hh     : translator.translate,
            d      : 'dan',
            dd     : translator.translate,
            M      : 'mjesec',
            MM     : translator.translate,
            y      : 'godinu',
            yy     : translator.translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return me;

}));

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : macedonian (mk)
//! author : Borislav Mickov : https://github.com/B0k0

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var mk = moment.defineLocale('mk', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : 'e_o_____a'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'D.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd, D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : '[] dddd [] LT',
            lastDay : '[ ] LT',
            lastWeek : function () {
                switch (this.day()) {
                case 0:
                case 3:
                case 6:
                    return '[] dddd [] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[] dddd [] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : ' ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        ordinalParse: /\d{1,2}-(|||||)/,
        ordinal : function (number) {
            var lastDigit = number % 10,
                last2Digits = number % 100;
            if (number === 0) {
                return number + '-';
            } else if (last2Digits === 0) {
                return number + '-';
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + '-';
            } else if (lastDigit === 1) {
                return number + '-';
            } else if (lastDigit === 2) {
                return number + '-';
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + '-';
            } else {
                return number + '-';
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return mk;

}));

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : malayalam (ml)
//! author : Floyd Pink : https://github.com/floydpink

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var ml = moment.defineLocale('ml', {
        months : '___________'.split('_'),
        monthsShort : '._._._.___._._._._._.'.split('_'),
        monthsParseExact : true,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm -',
            LTS : 'A h:mm:ss -',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm -',
            LLLL : 'dddd, D MMMM YYYY, A h:mm -'
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        meridiemParse: /|| ||/i,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if ((meridiem === '' && hour >= 4) ||
                    meridiem === ' ' ||
                    meridiem === '') {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return ' ';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        }
    });

    return ml;

}));

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Marathi (mr)
//! author : Harshad Kale : https://github.com/kalehv
//! author : Vivek Athalye : https://github.com/vnathalye

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    function relativeTimeMr(number, withoutSuffix, string, isFuture)
    {
        var output = '';
        if (withoutSuffix) {
            switch (string) {
                case 's': output = ' '; break;
                case 'm': output = ' '; break;
                case 'mm': output = '%d '; break;
                case 'h': output = ' '; break;
                case 'hh': output = '%d '; break;
                case 'd': output = ' '; break;
                case 'dd': output = '%d '; break;
                case 'M': output = ' '; break;
                case 'MM': output = '%d '; break;
                case 'y': output = ' '; break;
                case 'yy': output = '%d '; break;
            }
        }
        else {
            switch (string) {
                case 's': output = ' '; break;
                case 'm': output = ' '; break;
                case 'mm': output = '%d '; break;
                case 'h': output = ' '; break;
                case 'hh': output = '%d '; break;
                case 'd': output = ' '; break;
                case 'dd': output = '%d '; break;
                case 'M': output = ' '; break;
                case 'MM': output = '%d '; break;
                case 'y': output = ' '; break;
                case 'yy': output = '%d '; break;
            }
        }
        return output.replace(/%d/i, number);
    }

    var mr = moment.defineLocale('mr', {
        months : '___________'.split('_'),
        monthsShort: '._._._._._._._._._._._.'.split('_'),
        monthsParseExact : true,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm ',
            LTS : 'A h:mm:ss ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm '
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek: '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future: '%s',
            past: '%s',
            s: relativeTimeMr,
            m: relativeTimeMr,
            mm: relativeTimeMr,
            h: relativeTimeMr,
            hh: relativeTimeMr,
            d: relativeTimeMr,
            dd: relativeTimeMr,
            M: relativeTimeMr,
            MM: relativeTimeMr,
            y: relativeTimeMr,
            yy: relativeTimeMr
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /|||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return mr;

}));

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bahasa Malaysia (ms-MY)
//! author : Weldan Jamili : https://github.com/weldan

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var ms = moment.defineLocale('ms', {
        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'tengahari') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'petang' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'tengahari';
            } else if (hours < 19) {
                return 'petang';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Esok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kelmarin pukul] LT',
            lastWeek : 'dddd [lepas pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lepas',
            s : 'beberapa saat',
            m : 'seminit',
            mm : '%d minit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ms;

}));

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bahasa Malaysia (ms-MY)
//! author : Weldan Jamili : https://github.com/weldan

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var ms_my = moment.defineLocale('ms-my', {
        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'tengahari') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'petang' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'tengahari';
            } else if (hours < 19) {
                return 'petang';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Esok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kelmarin pukul] LT',
            lastWeek : 'dddd [lepas pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lepas',
            s : 'beberapa saat',
            m : 'seminit',
            mm : '%d minit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ms_my;

}));

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Burmese (my)
//! author : Squar team, mysquar.com

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var my = moment.defineLocale('my', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),

        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[.] LT []',
            nextDay: '[] LT []',
            nextWeek: 'dddd LT []',
            lastDay: '[.] LT []',
            lastWeek: '[] dddd LT []',
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s ',
            past: ' %s ',
            s: '.',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return my;

}));

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : norwegian bokml (nb)
//! authors : Espen Hovlandsdal : https://github.com/rexxars
//!           Sigurd Gartmann : https://github.com/sigurdga

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var nb = moment.defineLocale('nb', {
        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
        monthsParseExact : true,
        weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
        weekdaysShort : 's._ma._ti._on._to._fr._l.'.split('_'),
        weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY [kl.] HH:mm',
            LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
        },
        calendar : {
            sameDay: '[i dag kl.] LT',
            nextDay: '[i morgen kl.] LT',
            nextWeek: 'dddd [kl.] LT',
            lastDay: '[i gr kl.] LT',
            lastWeek: '[forrige] dddd [kl.] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : '%s siden',
            s : 'noen sekunder',
            m : 'ett minutt',
            mm : '%d minutter',
            h : 'en time',
            hh : '%d timer',
            d : 'en dag',
            dd : '%d dager',
            M : 'en mned',
            MM : '%d mneder',
            y : 'ett r',
            yy : '%d r'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return nb;

}));

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : nepali/nepalese
//! author : suvash : https://github.com/suvash

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var ne = moment.defineLocale('ne', {
        months : '___________'.split('_'),
        monthsShort : '._.__.___._._._._._.'.split('_'),
        monthsParseExact : true,
        weekdays : '______'.split('_'),
        weekdaysShort : '._._._._._._.'.split('_'),
        weekdaysMin : '._._._._._._.'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'A h:mm ',
            LTS : 'A h:mm:ss ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /|||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 3) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 16) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : '[] dddd[,] LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd[,] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s',
            past : '%s ',
            s : ' ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ne;

}));

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : dutch (nl)
//! author : Joris Rling : https://github.com/jjupiter

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

    var nl = moment.defineLocale('nl', {
        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
        monthsShort : function (m, format) {
            if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots[m.month()];
            } else {
                return monthsShortWithDots[m.month()];
            }
        },
        monthsParseExact : true,
        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
        weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[vandaag om] LT',
            nextDay: '[morgen om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[gisteren om] LT',
            lastWeek: '[afgelopen] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'over %s',
            past : '%s geleden',
            s : 'een paar seconden',
            m : 'n minuut',
            mm : '%d minuten',
            h : 'n uur',
            hh : '%d uur',
            d : 'n dag',
            dd : '%d dagen',
            M : 'n maand',
            MM : '%d maanden',
            y : 'n jaar',
            yy : '%d jaar'
        },
        ordinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return nl;

}));

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : norwegian nynorsk (nn)
//! author : https://github.com/mechuwind

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var nn = moment.defineLocale('nn', {
        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays : 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
        weekdaysShort : 'sun_mn_tys_ons_tor_fre_lau'.split('_'),
        weekdaysMin : 'su_m_ty_on_to_fr_l'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY [kl.] H:mm',
            LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
        },
        calendar : {
            sameDay: '[I dag klokka] LT',
            nextDay: '[I morgon klokka] LT',
            nextWeek: 'dddd [klokka] LT',
            lastDay: '[I gr klokka] LT',
            lastWeek: '[Fregande] dddd [klokka] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : '%s sidan',
            s : 'nokre sekund',
            m : 'eit minutt',
            mm : '%d minutt',
            h : 'ein time',
            hh : '%d timar',
            d : 'ein dag',
            dd : '%d dagar',
            M : 'ein mnad',
            MM : '%d mnader',
            y : 'eit r',
            yy : '%d r'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return nn;

}));

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : punjabi india (pa-in)
//! author : Harpreet Singh : https://github.com/harpreetkhalsagtbit

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var pa_in = moment.defineLocale('pa-in', {
        // There are months name as per Nanakshahi Calender but they are not used as rigidly in modern Punjabi.
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm ',
            LTS : 'A h:mm:ss ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm '
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
        meridiemParse: /|||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return pa_in;

}));

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : polish (pl)
//! author : Rafal Hirsz : https://github.com/evoL

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_'),
        monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_');
    function plural(n) {
        return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
    }
    function translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
        case 'm':
            return withoutSuffix ? 'minuta' : 'minut';
        case 'mm':
            return result + (plural(number) ? 'minuty' : 'minut');
        case 'h':
            return withoutSuffix  ? 'godzina'  : 'godzin';
        case 'hh':
            return result + (plural(number) ? 'godziny' : 'godzin');
        case 'MM':
            return result + (plural(number) ? 'miesice' : 'miesicy');
        case 'yy':
            return result + (plural(number) ? 'lata' : 'lat');
        }
    }

    var pl = moment.defineLocale('pl', {
        months : function (momentToFormat, format) {
            if (format === '') {
                // Hack: if format empty we know this is used to generate
                // RegExp by moment. Give then back both valid forms of months
                // in RegExp ready format.
                return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
            } else if (/D MMMM/.test(format)) {
                return monthsSubjective[momentToFormat.month()];
            } else {
                return monthsNominative[momentToFormat.month()];
            }
        },
        monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),
        weekdays : 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),
        weekdaysShort : 'nie_pon_wt_r_czw_pt_sb'.split('_'),
        weekdaysMin : 'Nd_Pn_Wt_r_Cz_Pt_So'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Dzi o] LT',
            nextDay: '[Jutro o] LT',
            nextWeek: '[W] dddd [o] LT',
            lastDay: '[Wczoraj o] LT',
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[W zesz niedziel o] LT';
                case 3:
                    return '[W zesz rod o] LT';
                case 6:
                    return '[W zesz sobot o] LT';
                default:
                    return '[W zeszy] dddd [o] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : '%s temu',
            s : 'kilka sekund',
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : '1 dzie',
            dd : '%d dni',
            M : 'miesic',
            MM : translate,
            y : 'rok',
            yy : translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return pl;

}));

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : portuguese (pt)
//! author : Jefferson : https://github.com/jalex79

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var pt = moment.defineLocale('pt', {
        months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays : 'Domingo_Segunda-Feira_Tera-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sbado'.split('_'),
        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
        weekdaysMin : 'Dom_2_3_4_5_6_Sb'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY HH:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Hoje s] LT',
            nextDay: '[Amanh s] LT',
            nextWeek: 'dddd [s] LT',
            lastDay: '[Ontem s] LT',
            lastWeek: function () {
                return (this.day() === 0 || this.day() === 6) ?
                    '[ltimo] dddd [s] LT' : // Saturday + Sunday
                    '[ltima] dddd [s] LT'; // Monday - Friday
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'em %s',
            past : 'h %s',
            s : 'segundos',
            m : 'um minuto',
            mm : '%d minutos',
            h : 'uma hora',
            hh : '%d horas',
            d : 'um dia',
            dd : '%d dias',
            M : 'um ms',
            MM : '%d meses',
            y : 'um ano',
            yy : '%d anos'
        },
        ordinalParse: /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return pt;

}));

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : brazilian portuguese (pt-br)
//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var pt_br = moment.defineLocale('pt-br', {
        months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays : 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
        weekdaysMin : 'Dom_2_3_4_5_6_Sb'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY [s] HH:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY [s] HH:mm'
        },
        calendar : {
            sameDay: '[Hoje s] LT',
            nextDay: '[Amanh s] LT',
            nextWeek: 'dddd [s] LT',
            lastDay: '[Ontem s] LT',
            lastWeek: function () {
                return (this.day() === 0 || this.day() === 6) ?
                    '[ltimo] dddd [s] LT' : // Saturday + Sunday
                    '[ltima] dddd [s] LT'; // Monday - Friday
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'em %s',
            past : '%s atrs',
            s : 'poucos segundos',
            m : 'um minuto',
            mm : '%d minutos',
            h : 'uma hora',
            hh : '%d horas',
            d : 'um dia',
            dd : '%d dias',
            M : 'um ms',
            MM : '%d meses',
            y : 'um ano',
            yy : '%d anos'
        },
        ordinalParse: /\d{1,2}/,
        ordinal : '%d'
    });

    return pt_br;

}));

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : romanian (ro)
//! author : Vlad Gurdiga : https://github.com/gurdiga
//! author : Valentin Agachi : https://github.com/avaly

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
                'mm': 'minute',
                'hh': 'ore',
                'dd': 'zile',
                'MM': 'luni',
                'yy': 'ani'
            },
            separator = ' ';
        if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
            separator = ' de ';
        }
        return number + separator + format[key];
    }

    var ro = moment.defineLocale('ro', {
        months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
        monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays : 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),
        weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),
        weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd, D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay: '[azi la] LT',
            nextDay: '[mine la] LT',
            nextWeek: 'dddd [la] LT',
            lastDay: '[ieri la] LT',
            lastWeek: '[fosta] dddd [la] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'peste %s',
            past : '%s n urm',
            s : 'cteva secunde',
            m : 'un minut',
            mm : relativeTimeWithPlural,
            h : 'o or',
            hh : relativeTimeWithPlural,
            d : 'o zi',
            dd : relativeTimeWithPlural,
            M : 'o lun',
            MM : relativeTimeWithPlural,
            y : 'un an',
            yy : relativeTimeWithPlural
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ro;

}));

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : russian (ru)
//! author : Viktorminator : https://github.com/Viktorminator
//! Author : Menelion Elensle : https://github.com/Oire
//! author :   : https://github.com/socketpair

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'mm': withoutSuffix ? '__' : '__',
            'hh': '__',
            'dd': '__',
            'MM': '__',
            'yy': '__'
        };
        if (key === 'm') {
            return withoutSuffix ? '' : '';
        }
        else {
            return number + ' ' + plural(format[key], +number);
        }
    }
    var monthsParse = [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i];

    // http://new.gramota.ru/spravka/rules/139-prop :  103
    //  : http://new.gramota.ru/spravka/buro/search-answer?s=242637
    // CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
    var ru = moment.defineLocale('ru', {
        months : {
            format: '___________'.split('_'),
            standalone: '___________'.split('_')
        },
        monthsShort : {
            //  CLDR  "."  ".",        ?
            format: '._._._.____._._._._.'.split('_'),
            standalone: '._.__.____._._._._.'.split('_')
        },
        weekdays : {
            standalone: '______'.split('_'),
            format: '______'.split('_'),
            isFormat: /\[ ?[] ?(?:||)? ?\] ?dddd/
        },
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        monthsParse : monthsParse,
        longMonthsParse : monthsParse,
        shortMonthsParse : monthsParse,
        monthsRegex: /^([]|[]|[]|[]|[]|[]|?|[]|\.|\.|\.||.||.|.|.||[.]|.|[]|[]|[])/i,
        monthsShortRegex: /^([]|[]|[]|[]|[]|[]|?|[]|\.|\.|\.||.||.|.|.||[.]|.|[]|[]|[])/i,
        monthsStrictRegex: /^([]|[]|[]|[]|[]|[]|?|[]|?|[]|[]|[])/i,
        monthsShortStrictRegex: /^(\.|\.|\.||\.|[]|[.]|\.|\.|\.|\.|[])/i,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY .',
            LLL : 'D MMMM YYYY ., HH:mm',
            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
        },
        calendar : {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            lastDay: '[ ] LT',
            nextWeek: function (now) {
                if (now.week() !== this.week()) {
                    switch (this.day()) {
                    case 0:
                        return '[ ] dddd [] LT';
                    case 1:
                    case 2:
                    case 4:
                        return '[ ] dddd [] LT';
                    case 3:
                    case 5:
                    case 6:
                        return '[ ] dddd [] LT';
                    }
                } else {
                    if (this.day() === 2) {
                        return '[] dddd [] LT';
                    } else {
                        return '[] dddd [] LT';
                    }
                }
            },
            lastWeek: function (now) {
                if (now.week() !== this.week()) {
                    switch (this.day()) {
                    case 0:
                        return '[ ] dddd [] LT';
                    case 1:
                    case 2:
                    case 4:
                        return '[ ] dddd [] LT';
                    case 3:
                    case 5:
                    case 6:
                        return '[ ] dddd [] LT';
                    }
                } else {
                    if (this.day() === 2) {
                        return '[] dddd [] LT';
                    } else {
                        return '[] dddd [] LT';
                    }
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            m : relativeTimeWithPlural,
            mm : relativeTimeWithPlural,
            h : '',
            hh : relativeTimeWithPlural,
            d : '',
            dd : relativeTimeWithPlural,
            M : '',
            MM : relativeTimeWithPlural,
            y : '',
            yy : relativeTimeWithPlural
        },
        meridiemParse: /|||/i,
        isPM : function (input) {
            return /^(|)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return '';
            } else {
                return '';
            }
        },
        ordinalParse: /\d{1,2}-(||)/,
        ordinal: function (number, period) {
            switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
                return number + '-';
            case 'D':
                return number + '-';
            case 'w':
            case 'W':
                return number + '-';
            default:
                return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ru;

}));

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Northern Sami (se)
//! authors : Brd Rolstad Henriksen : https://github.com/karamell

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';



    var se = moment.defineLocale('se', {
        months : 'oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu'.split('_'),
        monthsShort : 'oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov'.split('_'),
        weekdays : 'sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat'.split('_'),
        weekdaysShort : 'sotn_vuos_ma_gask_duor_bear_lv'.split('_'),
        weekdaysMin : 's_v_m_g_d_b_L'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'MMMM D. [b.] YYYY',
            LLL : 'MMMM D. [b.] YYYY [ti.] HH:mm',
            LLLL : 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
        },
        calendar : {
            sameDay: '[otne ti] LT',
            nextDay: '[ihttin ti] LT',
            nextWeek: 'dddd [ti] LT',
            lastDay: '[ikte ti] LT',
            lastWeek: '[ovddit] dddd [ti] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s geaes',
            past : 'mait %s',
            s : 'moadde sekunddat',
            m : 'okta minuhta',
            mm : '%d minuhtat',
            h : 'okta diimmu',
            hh : '%d diimmut',
            d : 'okta beaivi',
            dd : '%d beaivvit',
            M : 'okta mnnu',
            MM : '%d mnut',
            y : 'okta jahki',
            yy : '%d jagit'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return se;

}));

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Sinhalese (si)
//! author : Sampath Sitinamaluwa : https://github.com/sampathsris

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    /*jshint -W100*/
    var si = moment.defineLocale('si', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'a h:mm',
            LTS : 'a h:mm:ss',
            L : 'YYYY/MM/DD',
            LL : 'YYYY MMMM D',
            LLL : 'YYYY MMMM D, a h:mm',
            LLLL : 'YYYY MMMM D [] dddd, a h:mm:ss'
        },
        calendar : {
            sameDay : '[] LT[]',
            nextDay : '[] LT[]',
            nextWeek : 'dddd LT[]',
            lastDay : '[] LT[]',
            lastWeek : '[] dddd LT[]',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s',
            past : '%s ',
            s : ' ',
            m : '',
            mm : ' %d',
            h : '',
            hh : ' %d',
            d : '',
            dd : ' %d',
            M : '',
            MM : ' %d',
            y : '',
            yy : ' %d'
        },
        ordinalParse: /\d{1,2} /,
        ordinal : function (number) {
            return number + ' ';
        },
        meridiemParse : / | |.|../,
        isPM : function (input) {
            return input === '..' || input === ' ';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? '..' : ' ';
            } else {
                return isLower ? '..' : ' ';
            }
        }
    });

    return si;

}));

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : slovak (sk)
//! author : Martin Minka : https://github.com/k2s
//! based on work of petrbela : https://github.com/petrbela

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var months = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_'),
        monthsShort = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');
    function plural(n) {
        return (n > 1) && (n < 5);
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
        case 's':  // a few seconds / in a few seconds / a few seconds ago
            return (withoutSuffix || isFuture) ? 'pr seknd' : 'pr sekundami';
        case 'm':  // a minute / in a minute / a minute ago
            return withoutSuffix ? 'minta' : (isFuture ? 'mintu' : 'mintou');
        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'minty' : 'mint');
            } else {
                return result + 'mintami';
            }
            break;
        case 'h':  // an hour / in an hour / an hour ago
            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
        case 'hh': // 9 hours / in 9 hours / 9 hours ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'hodiny' : 'hodn');
            } else {
                return result + 'hodinami';
            }
            break;
        case 'd':  // a day / in a day / a day ago
            return (withoutSuffix || isFuture) ? 'de' : 'dom';
        case 'dd': // 9 days / in 9 days / 9 days ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'dni' : 'dn');
            } else {
                return result + 'dami';
            }
            break;
        case 'M':  // a month / in a month / a month ago
            return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
        case 'MM': // 9 months / in 9 months / 9 months ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'mesiace' : 'mesiacov');
            } else {
                return result + 'mesiacmi';
            }
            break;
        case 'y':  // a year / in a year / a year ago
            return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
        case 'yy': // 9 years / in 9 years / 9 years ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'roky' : 'rokov');
            } else {
                return result + 'rokmi';
            }
            break;
        }
    }

    var sk = moment.defineLocale('sk', {
        months : months,
        monthsShort : monthsShort,
        weekdays : 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),
        weekdaysShort : 'ne_po_ut_st_t_pi_so'.split('_'),
        weekdaysMin : 'ne_po_ut_st_t_pi_so'.split('_'),
        longDateFormat : {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay: '[dnes o] LT',
            nextDay: '[zajtra o] LT',
            nextWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[v nedeu o] LT';
                case 1:
                case 2:
                    return '[v] dddd [o] LT';
                case 3:
                    return '[v stredu o] LT';
                case 4:
                    return '[vo tvrtok o] LT';
                case 5:
                    return '[v piatok o] LT';
                case 6:
                    return '[v sobotu o] LT';
                }
            },
            lastDay: '[vera o] LT',
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[minul nedeu o] LT';
                case 1:
                case 2:
                    return '[minul] dddd [o] LT';
                case 3:
                    return '[minul stredu o] LT';
                case 4:
                case 5:
                    return '[minul] dddd [o] LT';
                case 6:
                    return '[minul sobotu o] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : 'pred %s',
            s : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return sk;

}));

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : slovenian (sl)
//! author : Robert Sedovek : https://github.com/sedovsek

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
        case 's':
            return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
        case 'm':
            return withoutSuffix ? 'ena minuta' : 'eno minuto';
        case 'mm':
            if (number === 1) {
                result += withoutSuffix ? 'minuta' : 'minuto';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'minute' : 'minutami';
            } else {
                result += withoutSuffix || isFuture ? 'minut' : 'minutami';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'ena ura' : 'eno uro';
        case 'hh':
            if (number === 1) {
                result += withoutSuffix ? 'ura' : 'uro';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'uri' : 'urama';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'ure' : 'urami';
            } else {
                result += withoutSuffix || isFuture ? 'ur' : 'urami';
            }
            return result;
        case 'd':
            return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
        case 'dd':
            if (number === 1) {
                result += withoutSuffix || isFuture ? 'dan' : 'dnem';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
            } else {
                result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
            }
            return result;
        case 'M':
            return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
        case 'MM':
            if (number === 1) {
                result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
            } else {
                result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
            }
            return result;
        case 'y':
            return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
        case 'yy':
            if (number === 1) {
                result += withoutSuffix || isFuture ? 'leto' : 'letom';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'leti' : 'letoma';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'leta' : 'leti';
            } else {
                result += withoutSuffix || isFuture ? 'let' : 'leti';
            }
            return result;
        }
    }

    var sl = moment.defineLocale('sl', {
        months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays : 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),
        weekdaysShort : 'ned._pon._tor._sre._et._pet._sob.'.split('_'),
        weekdaysMin : 'ne_po_to_sr_e_pe_so'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD. MM. YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[danes ob] LT',
            nextDay  : '[jutri ob] LT',

            nextWeek : function () {
                switch (this.day()) {
                case 0:
                    return '[v] [nedeljo] [ob] LT';
                case 3:
                    return '[v] [sredo] [ob] LT';
                case 6:
                    return '[v] [soboto] [ob] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[v] dddd [ob] LT';
                }
            },
            lastDay  : '[veraj ob] LT',
            lastWeek : function () {
                switch (this.day()) {
                case 0:
                    return '[prejnjo] [nedeljo] [ob] LT';
                case 3:
                    return '[prejnjo] [sredo] [ob] LT';
                case 6:
                    return '[prejnjo] [soboto] [ob] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[prejnji] dddd [ob] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'ez %s',
            past   : 'pred %s',
            s      : processRelativeTime,
            m      : processRelativeTime,
            mm     : processRelativeTime,
            h      : processRelativeTime,
            hh     : processRelativeTime,
            d      : processRelativeTime,
            dd     : processRelativeTime,
            M      : processRelativeTime,
            MM     : processRelativeTime,
            y      : processRelativeTime,
            yy     : processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return sl;

}));

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Albanian (sq)
//! author : Flakrim Ismani : https://github.com/flakerimi
//! author: Menelion Elensle: https://github.com/Oire (tests)
//! author : Oerd Cukalla : https://github.com/oerd (fixes)

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var sq = moment.defineLocale('sq', {
        months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),
        monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),
        weekdays : 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),
        weekdaysShort : 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),
        weekdaysMin : 'D_H_Ma_M_E_P_Sh'.split('_'),
        weekdaysParseExact : true,
        meridiemParse: /PD|MD/,
        isPM: function (input) {
            return input.charAt(0) === 'M';
        },
        meridiem : function (hours, minutes, isLower) {
            return hours < 12 ? 'PD' : 'MD';
        },
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Sot n] LT',
            nextDay : '[Nesr n] LT',
            nextWeek : 'dddd [n] LT',
            lastDay : '[Dje n] LT',
            lastWeek : 'dddd [e kaluar n] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'n %s',
            past : '%s m par',
            s : 'disa sekonda',
            m : 'nj minut',
            mm : '%d minuta',
            h : 'nj or',
            hh : '%d or',
            d : 'nj dit',
            dd : '%d dit',
            M : 'nj muaj',
            MM : '%d muaj',
            y : 'nj vit',
            yy : '%d vite'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return sq;

}));

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Serbian-latin (sr)
//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var translator = {
        words: { //Different grammatical cases
            m: ['jedan minut', 'jedne minute'],
            mm: ['minut', 'minute', 'minuta'],
            h: ['jedan sat', 'jednog sata'],
            hh: ['sat', 'sata', 'sati'],
            dd: ['dan', 'dana', 'dana'],
            MM: ['mesec', 'meseca', 'meseci'],
            yy: ['godina', 'godine', 'godina']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var sr = moment.defineLocale('sr', {
        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays: 'nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota'.split('_'),
        weekdaysShort: 'ned._pon._uto._sre._et._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L: 'DD. MM. YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sutra u] LT',
            nextWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[u] [nedelju] [u] LT';
                case 3:
                    return '[u] [sredu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[jue u] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[prole] [nedelje] [u] LT',
                    '[prolog] [ponedeljka] [u] LT',
                    '[prolog] [utorka] [u] LT',
                    '[prole] [srede] [u] LT',
                    '[prolog] [etvrtka] [u] LT',
                    '[prolog] [petka] [u] LT',
                    '[prole] [subote] [u] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'pre %s',
            s      : 'nekoliko sekundi',
            m      : translator.translate,
            mm     : translator.translate,
            h      : translator.translate,
            hh     : translator.translate,
            d      : 'dan',
            dd     : translator.translate,
            M      : 'mesec',
            MM     : translator.translate,
            y      : 'godinu',
            yy     : translator.translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return sr;

}));

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Serbian-cyrillic (sr-cyrl)
//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var translator = {
        words: { //Different grammatical cases
            m: [' ', ' '],
            mm: ['', '', ''],
            h: [' ', ' '],
            hh: ['', '', ''],
            dd: ['', '', ''],
            MM: ['', '', ''],
            yy: ['', '', '']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var sr_cyrl = moment.defineLocale('sr-cyrl', {
        months: '___________'.split('_'),
        monthsShort: '._._._.____._._._._.'.split('_'),
        monthsParseExact: true,
        weekdays: '______'.split('_'),
        weekdaysShort: '._._._._._._.'.split('_'),
        weekdaysMin: '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L: 'DD. MM. YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[] [] [] LT';
                case 3:
                    return '[] [] [] LT';
                case 6:
                    return '[] [] [] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[] dddd [] LT';
                }
            },
            lastDay  : '[ ] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past   : ' %s',
            s      : ' ',
            m      : translator.translate,
            mm     : translator.translate,
            h      : translator.translate,
            hh     : translator.translate,
            d      : '',
            dd     : translator.translate,
            M      : '',
            MM     : translator.translate,
            y      : '',
            yy     : translator.translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return sr_cyrl;

}));

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : siSwati (ss)
//! author : Nicolai Davies<mail@nicolai.io> : https://github.com/nicolaidavies

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';



    var ss = moment.defineLocale('ss', {
        months : "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
        monthsShort : 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
        weekdays : 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
        weekdaysShort : 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
        weekdaysMin : 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Namuhla nga] LT',
            nextDay : '[Kusasa nga] LT',
            nextWeek : 'dddd [nga] LT',
            lastDay : '[Itolo nga] LT',
            lastWeek : 'dddd [leliphelile] [nga] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'nga %s',
            past : 'wenteka nga %s',
            s : 'emizuzwana lomcane',
            m : 'umzuzu',
            mm : '%d emizuzu',
            h : 'lihora',
            hh : '%d emahora',
            d : 'lilanga',
            dd : '%d emalanga',
            M : 'inyanga',
            MM : '%d tinyanga',
            y : 'umnyaka',
            yy : '%d iminyaka'
        },
        meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'ekuseni';
            } else if (hours < 15) {
                return 'emini';
            } else if (hours < 19) {
                return 'entsambama';
            } else {
                return 'ebusuku';
            }
        },
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'ekuseni') {
                return hour;
            } else if (meridiem === 'emini') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
                if (hour === 0) {
                    return 0;
                }
                return hour + 12;
            }
        },
        ordinalParse: /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return ss;

}));

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : swedish (sv)
//! author : Jens Alm : https://github.com/ulmus

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var sv = moment.defineLocale('sv', {
        months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),
        weekdaysShort : 'sn_mn_tis_ons_tor_fre_lr'.split('_'),
        weekdaysMin : 's_m_ti_on_to_fr_l'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [kl.] HH:mm',
            LLLL : 'dddd D MMMM YYYY [kl.] HH:mm',
            lll : 'D MMM YYYY HH:mm',
            llll : 'ddd D MMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Idag] LT',
            nextDay: '[Imorgon] LT',
            lastDay: '[Igr] LT',
            nextWeek: '[P] dddd LT',
            lastWeek: '[I] dddd[s] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : 'fr %s sedan',
            s : 'ngra sekunder',
            m : 'en minut',
            mm : '%d minuter',
            h : 'en timme',
            hh : '%d timmar',
            d : 'en dag',
            dd : '%d dagar',
            M : 'en mnad',
            MM : '%d mnader',
            y : 'ett r',
            yy : '%d r'
        },
        ordinalParse: /\d{1,2}(e|a)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'e' :
                (b === 1) ? 'a' :
                (b === 2) ? 'a' :
                (b === 3) ? 'e' : 'e';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return sv;

}));

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : swahili (sw)
//! author : Fahad Kassim : https://github.com/fadsel

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var sw = moment.defineLocale('sw', {
        months : 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
        weekdays : 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
        weekdaysShort : 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
        weekdaysMin : 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[leo saa] LT',
            nextDay : '[kesho saa] LT',
            nextWeek : '[wiki ijayo] dddd [saat] LT',
            lastDay : '[jana] LT',
            lastWeek : '[wiki iliyopita] dddd [saat] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s baadaye',
            past : 'tokea %s',
            s : 'hivi punde',
            m : 'dakika moja',
            mm : 'dakika %d',
            h : 'saa limoja',
            hh : 'masaa %d',
            d : 'siku moja',
            dd : 'masiku %d',
            M : 'mwezi mmoja',
            MM : 'miezi %d',
            y : 'mwaka mmoja',
            yy : 'miaka %d'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return sw;

}));

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : tamil (ta)
//! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var ta = moment.defineLocale('ta', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, HH:mm',
            LLLL : 'dddd, D MMMM YYYY, HH:mm'
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[ ] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : '  ',
            m : ' ',
            mm : '%d ',
            h : '  ',
            hh : '%d  ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        ordinalParse: /\d{1,2}/,
        ordinal : function (number) {
            return number + '';
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // refer http://ta.wikipedia.org/s/1er1
        meridiemParse: /|||||/,
        meridiem : function (hour, minute, isLower) {
            if (hour < 2) {
                return ' ';
            } else if (hour < 6) {
                return ' ';  // 
            } else if (hour < 10) {
                return ' '; // 
            } else if (hour < 14) {
                return ' '; // 
            } else if (hour < 18) {
                return ' '; // 
            } else if (hour < 22) {
                return ' '; // 
            } else {
                return ' ';
            }
        },
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 2 ? hour : hour + 12;
            } else if (meridiem === '' || meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else {
                return hour + 12;
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ta;

}));

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : telugu (te)
//! author : Krishna Chaitanya Thota : https://github.com/kcthota

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var te = moment.defineLocale('te', {
        months : '___________'.split('_'),
        monthsShort : '._.__.____._._._._.'.split('_'),
        monthsParseExact : true,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm',
            LTS : 'A h:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm',
            LLLL : 'dddd, D MMMM YYYY, A h:mm'
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        ordinalParse : /\d{1,2}/,
        ordinal : '%d',
        meridiemParse: /|||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return te;

}));

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : thai (th)
//! author : Kridsada Thanabulpong : https://github.com/sirn

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var th = moment.defineLocale('th', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        monthsParseExact: true,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'), // yes, three characters difference
        weekdaysMin : '._._._._._._.'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H  m ',
            LTS : 'H  m  s ',
            L : 'YYYY/MM/DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY  H  m ',
            LLLL : 'dddd D MMMM YYYY  H  m '
        },
        meridiemParse: /|/,
        isPM: function (input) {
            return input === '';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd[ ] LT',
            lastDay : '[ ] LT',
            lastWeek : '[]dddd[ ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s',
            s : '',
            m : '1 ',
            mm : '%d ',
            h : '1 ',
            hh : '%d ',
            d : '1 ',
            dd : '%d ',
            M : '1 ',
            MM : '%d ',
            y : '1 ',
            yy : '%d '
        }
    });

    return th;

}));

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tagalog/Filipino (tl-ph)
//! author : Dan Hagman

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var tl_ph = moment.defineLocale('tl-ph', {
        months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
        monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
        weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
        weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
        weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'MM/D/YYYY',
            LL : 'MMMM D, YYYY',
            LLL : 'MMMM D, YYYY HH:mm',
            LLLL : 'dddd, MMMM DD, YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Ngayon sa] LT',
            nextDay: '[Bukas sa] LT',
            nextWeek: 'dddd [sa] LT',
            lastDay: '[Kahapon sa] LT',
            lastWeek: 'dddd [huling linggo] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'sa loob ng %s',
            past : '%s ang nakalipas',
            s : 'ilang segundo',
            m : 'isang minuto',
            mm : '%d minuto',
            h : 'isang oras',
            hh : '%d oras',
            d : 'isang araw',
            dd : '%d araw',
            M : 'isang buwan',
            MM : '%d buwan',
            y : 'isang taon',
            yy : '%d taon'
        },
        ordinalParse: /\d{1,2}/,
        ordinal : function (number) {
            return number;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return tl_ph;

}));

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Klingon (tlh)
//! author : Dominika Kruk : https://github.com/amaranthrose

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var numbersNouns = 'pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

    function translateFuture(output) {
        var time = output;
        time = (output.indexOf('jaj') !== -1) ?
    	time.slice(0, -3) + 'leS' :
    	(output.indexOf('jar') !== -1) ?
    	time.slice(0, -3) + 'waQ' :
    	(output.indexOf('DIS') !== -1) ?
    	time.slice(0, -3) + 'nem' :
    	time + ' pIq';
        return time;
    }

    function translatePast(output) {
        var time = output;
        time = (output.indexOf('jaj') !== -1) ?
    	time.slice(0, -3) + 'Hu' :
    	(output.indexOf('jar') !== -1) ?
    	time.slice(0, -3) + 'wen' :
    	(output.indexOf('DIS') !== -1) ?
    	time.slice(0, -3) + 'ben' :
    	time + ' ret';
        return time;
    }

    function translate(number, withoutSuffix, string, isFuture) {
        var numberNoun = numberAsNoun(number);
        switch (string) {
            case 'mm':
                return numberNoun + ' tup';
            case 'hh':
                return numberNoun + ' rep';
            case 'dd':
                return numberNoun + ' jaj';
            case 'MM':
                return numberNoun + ' jar';
            case 'yy':
                return numberNoun + ' DIS';
        }
    }

    function numberAsNoun(number) {
        var hundred = Math.floor((number % 1000) / 100),
    	ten = Math.floor((number % 100) / 10),
    	one = number % 10,
    	word = '';
        if (hundred > 0) {
            word += numbersNouns[hundred] + 'vatlh';
        }
        if (ten > 0) {
            word += ((word !== '') ? ' ' : '') + numbersNouns[ten] + 'maH';
        }
        if (one > 0) {
            word += ((word !== '') ? ' ' : '') + numbersNouns[one];
        }
        return (word === '') ? 'pagh' : word;
    }

    var tlh = moment.defineLocale('tlh', {
        months : 'tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha'.split('_'),
        monthsShort : 'jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha'.split('_'),
        monthsParseExact : true,
        weekdays : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
        weekdaysShort : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
        weekdaysMin : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[DaHjaj] LT',
            nextDay: '[waleS] LT',
            nextWeek: 'LLL',
            lastDay: '[waHu] LT',
            lastWeek: 'LLL',
            sameElse: 'L'
        },
        relativeTime : {
            future : translateFuture,
            past : translatePast,
            s : 'puS lup',
            m : 'wa tup',
            mm : translate,
            h : 'wa rep',
            hh : translate,
            d : 'wa jaj',
            dd : translate,
            M : 'wa jar',
            MM : translate,
            y : 'wa DIS',
            yy : translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return tlh;

}));

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : turkish (tr)
//! authors : Erhan Gundogan : https://github.com/erhangundogan,
//!           Burak Yiit Kaya: https://github.com/BYK

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var suffixes = {
        1: '\'inci',
        5: '\'inci',
        8: '\'inci',
        70: '\'inci',
        80: '\'inci',
        2: '\'nci',
        7: '\'nci',
        20: '\'nci',
        50: '\'nci',
        3: '\'nc',
        4: '\'nc',
        100: '\'nc',
        6: '\'nc',
        9: '\'uncu',
        10: '\'uncu',
        30: '\'uncu',
        60: '\'nc',
        90: '\'nc'
    };

    var tr = moment.defineLocale('tr', {
        months : 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),
        monthsShort : 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),
        weekdays : 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),
        weekdaysShort : 'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),
        weekdaysMin : 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[bugn saat] LT',
            nextDay : '[yarn saat] LT',
            nextWeek : '[haftaya] dddd [saat] LT',
            lastDay : '[dn] LT',
            lastWeek : '[geen hafta] dddd [saat] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s sonra',
            past : '%s nce',
            s : 'birka saniye',
            m : 'bir dakika',
            mm : '%d dakika',
            h : 'bir saat',
            hh : '%d saat',
            d : 'bir gn',
            dd : '%d gn',
            M : 'bir ay',
            MM : '%d ay',
            y : 'bir yl',
            yy : '%d yl'
        },
        ordinalParse: /\d{1,2}'(inci|nci|nc|nc|uncu|nc)/,
        ordinal : function (number) {
            if (number === 0) {  // special case for zero
                return number + '\'nc';
            }
            var a = number % 10,
                b = number % 100 - a,
                c = number >= 100 ? 100 : null;
            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return tr;

}));

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : talossan (tzl)
//! author : Robin van der Vliet : https://github.com/robin0van0der0v with the help of Iust Canun

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';



    // After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
    // This is currently too difficult (maybe even impossible) to add.
    var tzl = moment.defineLocale('tzl', {
        months : 'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
        weekdays : 'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),
        weekdaysShort : 'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),
        weekdaysMin : 'S_L_Ma_M_Xh_Vi_S'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM [dallas] YYYY',
            LLL : 'D. MMMM [dallas] YYYY HH.mm',
            LLLL : 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
        },
        meridiemParse: /d\'o|d\'a/i,
        isPM : function (input) {
            return 'd\'o' === input.toLowerCase();
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'd\'o' : 'D\'O';
            } else {
                return isLower ? 'd\'a' : 'D\'A';
            }
        },
        calendar : {
            sameDay : '[oxhi ] LT',
            nextDay : '[dem ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ieiri ] LT',
            lastWeek : '[sr el] dddd [lasteu ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'osprei %s',
            past : 'ja%s',
            s : processRelativeTime,
            m : processRelativeTime,
            mm : processRelativeTime,
            h : processRelativeTime,
            hh : processRelativeTime,
            d : processRelativeTime,
            dd : processRelativeTime,
            M : processRelativeTime,
            MM : processRelativeTime,
            y : processRelativeTime,
            yy : processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            's': ['viensas secunds', '\'iensas secunds'],
            'm': ['\'n mut', '\'iens mut'],
            'mm': [number + ' muts', '' + number + ' muts'],
            'h': ['\'n ora', '\'iensa ora'],
            'hh': [number + ' oras', '' + number + ' oras'],
            'd': ['\'n ziua', '\'iensa ziua'],
            'dd': [number + ' ziuas', '' + number + ' ziuas'],
            'M': ['\'n mes', '\'iens mes'],
            'MM': [number + ' mesen', '' + number + ' mesen'],
            'y': ['\'n ar', '\'iens ar'],
            'yy': [number + ' ars', '' + number + ' ars']
        };
        return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);
    }

    return tzl;

}));

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Morocco Central Atlas Tamazit (tzm)
//! author : Abdel Said : https://github.com/abdelsaid

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var tzm = moment.defineLocale('tzm', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[ ] LT',
            lastWeek: 'dddd [] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : '   %s',
            past : ' %s',
            s : '',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d o',
            M : 'o',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return tzm;

}));

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Morocco Central Atlas Tamazit in Latin (tzm-latn)
//! author : Abdel Said : https://github.com/abdelsaid

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var tzm_latn = moment.defineLocale('tzm-latn', {
        months : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
        monthsShort : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
        weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
        weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
        weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[asdkh g] LT',
            nextDay: '[aska g] LT',
            nextWeek: 'dddd [g] LT',
            lastDay: '[assant g] LT',
            lastWeek: 'dddd [g] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'dadkh s yan %s',
            past : 'yan %s',
            s : 'imik',
            m : 'minu',
            mm : '%d minu',
            h : 'saa',
            hh : '%d tassain',
            d : 'ass',
            dd : '%d ossan',
            M : 'ayowr',
            MM : '%d iyyirn',
            y : 'asgas',
            yy : '%d isgasn'
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return tzm_latn;

}));

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : ukrainian (uk)
//! author : zemlanin : https://github.com/zemlanin
//! Author : Menelion Elensle : https://github.com/Oire

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'mm': withoutSuffix ? '__' : '__',
            'hh': withoutSuffix ? '__' : '__',
            'dd': '__',
            'MM': '__',
            'yy': '__'
        };
        if (key === 'm') {
            return withoutSuffix ? '' : '';
        }
        else if (key === 'h') {
            return withoutSuffix ? '' : '';
        }
        else {
            return number + ' ' + plural(format[key], +number);
        }
    }
    function weekdaysCaseReplace(m, format) {
        var weekdays = {
            'nominative': '______'.split('_'),
            'accusative': '______'.split('_'),
            'genitive': '______'.split('_')
        },
        nounCase = (/(\[[]\]) ?dddd/).test(format) ?
            'accusative' :
            ((/\[?(?:|)? ?\] ?dddd/).test(format) ?
                'genitive' :
                'nominative');
        return weekdays[nounCase][m.day()];
    }
    function processHoursFunction(str) {
        return function () {
            return str + '' + (this.hours() === 11 ? '' : '') + '] LT';
        };
    }

    var uk = moment.defineLocale('uk', {
        months : {
            'format': '___________'.split('_'),
            'standalone': '___________'.split('_')
        },
        monthsShort : '___________'.split('_'),
        weekdays : weekdaysCaseReplace,
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY .',
            LLL : 'D MMMM YYYY ., HH:mm',
            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
        },
        calendar : {
            sameDay: processHoursFunction('[ '),
            nextDay: processHoursFunction('[ '),
            lastDay: processHoursFunction('[ '),
            nextWeek: processHoursFunction('[] dddd ['),
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                case 3:
                case 5:
                case 6:
                    return processHoursFunction('[] dddd [').call(this);
                case 1:
                case 2:
                case 4:
                    return processHoursFunction('[] dddd [').call(this);
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            m : relativeTimeWithPlural,
            mm : relativeTimeWithPlural,
            h : '',
            hh : relativeTimeWithPlural,
            d : '',
            dd : relativeTimeWithPlural,
            M : '',
            MM : relativeTimeWithPlural,
            y : '',
            yy : relativeTimeWithPlural
        },
        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
        meridiemParse: /|||/,
        isPM: function (input) {
            return /^(|)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return '';
            } else {
                return '';
            }
        },
        ordinalParse: /\d{1,2}-(|)/,
        ordinal: function (number, period) {
            switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
            case 'w':
            case 'W':
                return number + '-';
            case 'D':
                return number + '-';
            default:
                return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    return uk;

}));

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : uzbek (uz)
//! author : Sardor Muminov : https://github.com/muminoff

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var uz = moment.defineLocale('uz', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'D MMMM YYYY, dddd HH:mm'
        },
        calendar : {
            sameDay : '[ ] LT []',
            nextDay : '[] LT []',
            nextWeek : 'dddd [ ] LT []',
            lastDay : '[ ] LT []',
            lastWeek : '[] dddd [ ] LT []',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s ',
            past : '  %s ',
            s : '',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return uz;

}));

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : vietnamese (vi)
//! author : Bang Nguyen : https://github.com/bangnk

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var vi = moment.defineLocale('vi', {
        months : 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),
        monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
        monthsParseExact : true,
        weekdays : 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),
        weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysParseExact : true,
        meridiemParse: /sa|ch/i,
        isPM : function (input) {
            return /^ch$/i.test(input);
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? 'sa' : 'SA';
            } else {
                return isLower ? 'ch' : 'CH';
            }
        },
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM [nm] YYYY',
            LLL : 'D MMMM [nm] YYYY HH:mm',
            LLLL : 'dddd, D MMMM [nm] YYYY HH:mm',
            l : 'DD/M/YYYY',
            ll : 'D MMM YYYY',
            lll : 'D MMM YYYY HH:mm',
            llll : 'ddd, D MMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Hm nay lc] LT',
            nextDay: '[Ngy mai lc] LT',
            nextWeek: 'dddd [tun ti lc] LT',
            lastDay: '[Hm qua lc] LT',
            lastWeek: 'dddd [tun ri lc] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s ti',
            past : '%s trc',
            s : 'vi giy',
            m : 'mt pht',
            mm : '%d pht',
            h : 'mt gi',
            hh : '%d gi',
            d : 'mt ngy',
            dd : '%d ngy',
            M : 'mt thng',
            MM : '%d thng',
            y : 'mt nm',
            yy : '%d nm'
        },
        ordinalParse: /\d{1,2}/,
        ordinal : function (number) {
            return number;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return vi;

}));

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : pseudo (x-pseudo)
//! author : Andrew Hood : https://github.com/andrewhood125

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var x_pseudo = moment.defineLocale('x-pseudo', {
        months : 'J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr'.split('_'),
        monthsShort : 'J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc'.split('_'),
        monthsParseExact : true,
        weekdays : 'S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d'.split('_'),
        weekdaysShort : 'S~_~M_~T_~Wd_~Th_~Fr_~St'.split('_'),
        weekdaysMin : 'S~_M~_T_~W_T~h_Fr~_S'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[T~d~ t] LT',
            nextDay : '[T~m~rr~w t] LT',
            nextWeek : 'dddd [t] LT',
            lastDay : '[~st~rd~ t] LT',
            lastWeek : '[L~st] dddd [t] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '~ %s',
            past : '%s ~g',
            s : ' ~fw ~sc~ds',
            m : ' ~m~t',
            mm : '%d m~~ts',
            h : '~ h~r',
            hh : '%d h~rs',
            d : ' ~d',
            dd : '%d d~s',
            M : ' ~m~th',
            MM : '%d m~t~hs',
            y : ' ~r',
            yy : '%d ~rs'
        },
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return x_pseudo;

}));

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : chinese (zh-cn)
//! author : suupic : https://github.com/suupic
//! author : Zeno Zeng : https://github.com/zenozeng

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var zh_cn = moment.defineLocale('zh-cn', {
        months : '___________'.split('_'),
        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'Ahmm',
            LTS : 'Ahms',
            L : 'YYYY-MM-DD',
            LL : 'YYYYMMMD',
            LLL : 'YYYYMMMDAhmm',
            LLLL : 'YYYYMMMDddddAhmm',
            l : 'YYYY-MM-DD',
            ll : 'YYYYMMMD',
            lll : 'YYYYMMMDAhmm',
            llll : 'YYYYMMMDddddAhmm'
        },
        meridiemParse: /|||||/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '' || meridiem === '' ||
                    meridiem === '') {
                return hour;
            } else if (meridiem === '' || meridiem === '') {
                return hour + 12;
            } else {
                // ''
                return hour >= 11 ? hour : hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '';
            } else if (hm < 900) {
                return '';
            } else if (hm < 1130) {
                return '';
            } else if (hm < 1230) {
                return '';
            } else if (hm < 1800) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : function () {
                return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
            },
            nextDay : function () {
                return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
            },
            lastDay : function () {
                return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
            },
            nextWeek : function () {
                var startOfWeek, prefix;
                startOfWeek = moment().startOf('week');
                prefix = this.diff(startOfWeek, 'days') >= 7 ? '[]' : '[]';
                return this.minutes() === 0 ? prefix + 'dddAh' : prefix + 'dddAhmm';
            },
            lastWeek : function () {
                var startOfWeek, prefix;
                startOfWeek = moment().startOf('week');
                prefix = this.unix() < startOfWeek.unix()  ? '[]' : '[]';
                return this.minutes() === 0 ? prefix + 'dddAh' : prefix + 'dddAhmm';
            },
            sameElse : 'LL'
        },
        ordinalParse: /\d{1,2}(||)/,
        ordinal : function (number, period) {
            switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
                return number + '';
            case 'M':
                return number + '';
            case 'w':
            case 'W':
                return number + '';
            default:
                return number;
            }
        },
        relativeTime : {
            future : '%s',
            past : '%s',
            s : '',
            m : '1 ',
            mm : '%d ',
            h : '1 ',
            hh : '%d ',
            d : '1 ',
            dd : '%d ',
            M : '1 ',
            MM : '%d ',
            y : '1 ',
            yy : '%d '
        },
        week : {
            // GB/T 7408-1994ISO 8601:1988
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return zh_cn;

}));

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : traditional chinese (zh-tw)
//! author : Ben : https://github.com/ben-lin

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var zh_tw = moment.defineLocale('zh-tw', {
        months : '___________'.split('_'),
        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'Ahmm',
            LTS : 'Ahms',
            L : 'YYYYMMMD',
            LL : 'YYYYMMMD',
            LLL : 'YYYYMMMDAhmm',
            LLLL : 'YYYYMMMDddddAhmm',
            l : 'YYYYMMMD',
            ll : 'YYYYMMMD',
            lll : 'YYYYMMMDAhmm',
            llll : 'YYYYMMMDddddAhmm'
        },
        meridiemParse: /||||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '' || meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === '' || meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 900) {
                return '';
            } else if (hm < 1130) {
                return '';
            } else if (hm < 1230) {
                return '';
            } else if (hm < 1800) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[]LT',
            nextDay : '[]LT',
            nextWeek : '[]ddddLT',
            lastDay : '[]LT',
            lastWeek : '[]ddddLT',
            sameElse : 'L'
        },
        ordinalParse: /\d{1,2}(||)/,
        ordinal : function (number, period) {
            switch (period) {
            case 'd' :
            case 'D' :
            case 'DDD' :
                return number + '';
            case 'M' :
                return number + '';
            case 'w' :
            case 'W' :
                return number + '';
            default :
                return number;
            }
        },
        relativeTime : {
            future : '%s',
            past : '%s',
            s : '',
            m : '1',
            mm : '%d',
            h : '1',
            hh : '%d',
            d : '1',
            dd : '%d',
            M : '1',
            MM : '%d',
            y : '1',
            yy : '%d'
        }
    });

    return zh_tw;

}));

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var pSlice = Array.prototype.slice;
var objectKeys = __webpack_require__(175);
var isArguments = __webpack_require__(176);

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Exception = Exception;
exports.InvalidStateException = InvalidStateException;
exports.BadArgumentException = BadArgumentException;
function Exception(msg) {
  var _msg = msg || "Unexpected internal error";

  this.message = _msg;

  this.toString = function () {
    return _msg;
  };
  this.stack = new Error().stack;
}

Exception.prototype = Object.create(Error.prototype);
Exception.prototype.constructor = Exception;

function InvalidStateException() {
  Exception.apply(this, arguments);
}

InvalidStateException.prototype = Object.create(Exception.prototype);
InvalidStateException.prototype.constructor = InvalidStateException;

function BadArgumentException() {
  Exception.apply(this, arguments);
}

BadArgumentException.prototype = Object.create(Exception.prototype);
BadArgumentException.prototype.constructor = BadArgumentException;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = asyncMixin;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _coreAsync = __webpack_require__(4);

var _core = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NON_INDEX = -1;

function asyncMixin(_chart) {
  var events = ["dataFetch", "dataError"];
  var _listeners = _d2.default.dispatch.apply(_d2.default, events);
  var _on = _chart.on.bind(_chart);

  _chart.dataCache = null;
  _chart.queryId = 0;

  var _dataAsync = function _dataAsync(group, callback) {
    group.allAsync(callback);
  };

  _chart.on = function (event, listener) {
    var baseEvent = event.includes(".") ? event.slice(0, event.indexOf(".")) : event;
    if (events.indexOf(baseEvent) === NON_INDEX) {
      _on(event, listener);
    } else {
      _listeners.on(event, listener);
    }
    return _chart;
  };

  _chart._invokeDataFetchListener = function () {
    _listeners.dataFetch(_chart);
  };

  _chart._invokeDataErrorListener = function () {
    _listeners.dataError(_chart);
  };

  _chart.dataAsync = function (callback) {
    return _dataAsync.call(_chart, _chart.group(), callback);
  };

  _chart.getDataAsync = function () {
    return _dataAsync;
  };

  _chart.setDataAsync = function (callback) {
    _dataAsync = callback;
    _chart.expireCache();
    return _chart;
  };

  _chart.data(function (group) {
    if (_chart.dataCache !== null) {
      // eslint-disable-line no-negated-condition
      return _chart.dataCache;
    } else {
      console.log("Warning: Deprecate sync method .data()"); // eslint-disable-line no-console
      return group.all();
    }
  });

  _chart.renderAsync = function (queryGroupId, queryCount) {
    if ((0, _core.refreshDisabled)()) {
      return Promise.resolve();
    }

    if (_chart.hasOwnProperty("setSample")) {
      _chart.setSample();
    }
    var id = _chart.queryId++;

    return new Promise(function (resolve, reject) {
      var renderCallback = function renderCallback(error, data) {
        if (error) {
          reject(error);
        } else {
          resolve(data);
        }
      };

      var dataCallback = function dataCallback(error, data) {
        if (error) {
          _chart._invokeDataErrorListener();
          (0, _coreAsync.resetRenderStack)();
          reject(error);
        } else {
          _chart.render(id, queryGroupId, queryCount, data, renderCallback);
        }
      };
      _chart._invokeDataFetchListener();
      return _chart.dataAsync(dataCallback);
    });
  };

  _chart.redrawAsync = function (queryGroupId, queryCount) {
    if ((0, _core.refreshDisabled)()) {
      return Promise.resolve();
    }

    if (_chart.hasOwnProperty("setSample")) {
      _chart.setSample();
    }
    var id = _chart.queryId++;

    return new Promise(function (resolve, reject) {
      var redrawCallback = function redrawCallback(error, data) {
        if (error) {
          reject(error);
        } else {
          resolve(data);
        }
      };

      var dataCallback = function dataCallback(error, data) {
        if (error) {
          _chart._invokeDataErrorListener();
          (0, _coreAsync.resetRedrawStack)();
          reject(error);
        } else {
          _chart.redraw(id, queryGroupId, queryCount, data, redrawCallback);
        }
      };
      _chart._invokeDataFetchListener();
      _chart.dataAsync(dataCallback);
    });
  };

  _chart.redrawGroup = function () {
    function logRedrawGroupError(e) {
      if ((0, _core.logging)()) {
        console.log("Redraw Group Error", e); // eslint-disable-line no-console
      }
    }

    if (_chart.commitHandler()) {
      _chart.commitHandler()(false, function (error) {
        if (error) {
          logRedrawGroupError(error);
        } else {
          (0, _coreAsync.redrawAllAsync)(_chart.chartGroup()).catch(function (e) {
            return logRedrawGroupError(e);
          });
        }
      });
    } else {
      (0, _coreAsync.redrawAllAsync)(_chart.chartGroup()).catch(function (e) {
        return logRedrawGroupError(e);
      });
    }
    return _chart;
  };

  return _chart;
}

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.multipleKeysAccessorForStack = exports.multipleKeysAccessorForCap = undefined;

var _formattingHelpers = __webpack_require__(6);

var INDEX_NONE = -1;
var identity = function identity(a) {
  return a;
};

function normalize(data) {
  if ((0, _formattingHelpers.isArrayOfObjects)(data)) {
    return data.map(function (d) {
      return d.value;
    });
  } else {
    return data;
  }
}

function getMinOfRange(d) {
  if (Array.isArray(d)) {
    return d[0];
  } else {
    return d;
  }
}

function createAccessor() {
  var transform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;

  return function multipleKeyAccessor(d) {
    var filteredKeys = [];
    for (var key in d) {
      if (d.hasOwnProperty(key) && key.indexOf("key") > INDEX_NONE) {
        filteredKeys.push(transform(normalize(d[key])));
      }
    }
    if (filteredKeys.length === 1) {
      filteredKeys = filteredKeys[0];
    }
    return filteredKeys;
  };
}

var multipleKeysAccessorForCap = exports.multipleKeysAccessorForCap = createAccessor();
var multipleKeysAccessorForStack = exports.multipleKeysAccessorForStack = createAccessor(getMinOfRange);

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = multipleKeysLabelMixin;

var _formattingHelpers = __webpack_require__(6);

var INDEX_NONE = -1;
var SHOULD_RENDER_LABELS = true;

function format(_value, _key, numberFormatter, dateFormatter) {
  var customFormatter = null;

  var key = _key;
  var value = _value;
  var isExtract = false;

  if (Array.isArray(_value) && _value[0]) {
    value = _value[0].value || _value[0];
    if (_value[0].isExtract) {
      key = null;
      isExtract = true;
    }
  }

  if (dateFormatter && value instanceof Date) {
    customFormatter = dateFormatter;
  } else if (numberFormatter && typeof value === "number") {
    customFormatter = numberFormatter;
  }

  return !isExtract && customFormatter && customFormatter(value, key) || (0, _formattingHelpers.formatDataValue)(_value);
}

function multipleKeysLabelMixin(_chart) {

  function label(d) {
    var numberFormatter = _chart && _chart.valueFormatter();
    var dateFormatter = _chart && _chart.dateFormatter();
    var dimensionNames = _chart.dimension().value();

    if (dimensionNames.length === 1) {
      return format(d.key0, dimensionNames[0], numberFormatter, dateFormatter);
    }

    var keysStr = [];
    var i = 0;
    for (var key in d) {
      if (d.hasOwnProperty(key) && key.indexOf("key") > INDEX_NONE) {
        var formatted = format(d[key], dimensionNames[i], numberFormatter, dateFormatter);
        keysStr.push(formatted);
      }
      i++;
    }
    return keysStr.join(" / ");
  }

  _chart.label(label, SHOULD_RENDER_LABELS);
  return _chart;
}

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setCursorSpinner = exports.areAnySpinnersShowing = undefined;
exports.default = spinnerMixin;

var _core = __webpack_require__(2);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _dcConstants = __webpack_require__(181);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var areAnySpinnersShowing = exports.areAnySpinnersShowing = function areAnySpinnersShowing() {
  return _core.chartRegistry.list().some(function (chart) {
    return chart.isSpinnerShowing();
  });
};
var setCursorSpinner = exports.setCursorSpinner = function setCursorSpinner() {
  return _d2.default.select("body").classed("waiting", areAnySpinnersShowing());
};

function spinnerMixin(_chart) {
  var _spinnerDelay = _dcConstants.SPINNER_DELAY;
  var _spinnerTimeout = null;
  var _spinnerIsVisible = false;

  _chart.isSpinnerShowing = function () {
    return _spinnerIsVisible;
  };

  var _dataFetchRequestCallback = function _dataFetchRequestCallback() {
    var anchor = _chart.anchor();
    var selectedAnchor = _d2.default.select(anchor);

    selectedAnchor.classed("chart-loading-overlay", true);

    var loadingWidget = selectedAnchor.append("div").classed("loading-widget-dc", true);

    loadingWidget.append("div").classed("main-loading-icon", true);
  };

  var _dataFetchSuccessfulCallback = function _dataFetchSuccessfulCallback() {
    var anchor = _chart.anchor();

    var selectedAnchor = _d2.default.select(anchor);

    selectedAnchor.classed("chart-loading-overlay", false);

    selectedAnchor.selectAll(function () {
      return [].concat(_toConsumableArray(this.childNodes)).filter(function (node) {
        return node.className === "loading-widget-dc";
      });
    }).remove();

    _d2.default.select("body").classed("waiting", areAnySpinnersShowing());
  };

  _chart.spinnerDelay = function (delay) {
    if (!arguments.length) {
      return _spinnerDelay;
    }

    _spinnerDelay = delay;
    return _chart;
  };

  _chart.dataFetchSuccessfulCallback = function (func) {
    if (!arguments.length) {
      return _dataFetchSuccessfulCallback;
    }

    _dataFetchSuccessfulCallback = func;
    return _chart;
  };

  _chart.dataFetchRequestCallback = function (func) {
    if (!arguments.length) {
      return _dataFetchRequestCallback;
    }

    _dataFetchRequestCallback = func;
    return _chart;
  };

  function initSpinner() {
    if (_spinnerTimeout) {
      window.clearTimeout(_spinnerTimeout);
    }

    _spinnerTimeout = window.setTimeout(function () {
      _spinnerIsVisible = true;
      _dataFetchRequestCallback();
      setCursorSpinner();
    }, _spinnerDelay);
  }

  function tearDownSpinner() {
    if (_spinnerIsVisible) {
      _spinnerIsVisible = false;
      _dataFetchSuccessfulCallback();
      setCursorSpinner();
    }
    window.clearTimeout(_spinnerTimeout);
  }

  _chart.on("dataFetch.spinner", initSpinner);

  _chart.on("postRedraw.spinner", tearDownSpinner);
  _chart.on("postRender.spinner", tearDownSpinner);

  _chart.on("dataError.spinner", function () {
    console.log(_chart.__dcFlag__, ": error");
  });

  return _chart;
}

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = elasticDimensionMixin;

var _ramda = __webpack_require__(183);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function elasticDimensionMixin(_chart) {
  var NON_INDEX = -1;
  var _binEvents = ["updateBinBounds"];
  var _listeners = _d2.default.dispatch.apply(_d2.default, _binEvents);
  var _on = _chart.on.bind(_chart);
  var _dataAsync = _chart.getDataAsync();

  _chart.on = function (event, listener) {
    var baseEvent = event.includes(".") ? event.slice(0, event.indexOf(".")) : event;
    if (_binEvents.indexOf(baseEvent) === NON_INDEX) {
      _on(event, listener);
    } else {
      _listeners.on(event, listener);
    }
    return _chart;
  };

  _chart._invokeBinBoundsListener = function (binBounds) {
    if (typeof binBounds !== "undefined") {
      _listeners.updateBinBounds(_chart, binBounds);
    }
  };

  function updateBinRange(group, callback) {
    if (!_chart.elasticX() || !_chart.binParams()[0] || _chart.rangeChart() && _chart.rangeChart().filter()) {
      return _dataAsync(group, callback);
    }

    group.getMinMaxWithFilters().then(function (bounds) {
      if (!bounds) {
        return _dataAsync(group, callback);
      }

      _chart.binParams((0, _ramda.adjust)((0, _ramda.set)((0, _ramda.lensProp)("binBounds"), [bounds.min_val, bounds.max_val]), 0, _chart.binParams()));

      if (_chart.focusChart() && _chart.filter()) {
        _chart.focusChart()._invokeBinBoundsListener([bounds.min_val, bounds.max_val]);
      } else {
        _chart._invokeBinBoundsListener([bounds.min_val, bounds.max_val]);
      }
      _dataAsync(group, callback);
    }).catch(function (err) {
      return callback(err);
    });
  }

  _chart.on("dataFetch.reBin", function () {
    if (_chart.elasticX() && _chart.getDataAsync() !== updateBinRange) {
      _dataAsync = _chart.getDataAsync();
      _chart.setDataAsync(updateBinRange);
    }
  });

  return _chart;
}

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = lockAxisMixin;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _formattingHelpers = __webpack_require__(6);

var _moment = __webpack_require__(0);

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CHART_HEIGHT = 0.75;
var TOGGLE_SIZE = 24;
var NON_INDEX = -1;
var RETURN_KEY = 13;
var DATE_FORMAT = "MM-DD-YYYY";

function formatVal(val) {
  return val instanceof Date ? _d2.default.time.format.utc("%m-%d-%Y")(val) : (0, _formattingHelpers.formatDataValue)(val);
}

function parseFloatStrict(value) {
  if (/^(\-|\+)?([0-9]+(\.[0-9]+)?)$/.test(value)) {
    return Number(value);
  } else {
    return NaN;
  }
}

function lockAxisMixin(chart) {
  var events = ["elasticX", "elasticY", "xDomain", "yDomain"];
  var _listeners = _d2.default.dispatch.apply(_d2.default, events);
  var _on = chart.on.bind(chart);

  chart.on = function (event, listener) {
    var baseEvent = event.includes(".") ? event.slice(0, event.indexOf(".")) : event;
    if (events.indexOf(baseEvent) === NON_INDEX) {
      _on(event, listener);
    } else {
      _listeners.on(event, listener);
    }
    return chart;
  };

  chart._invokeelasticYListener = function () {
    _listeners.elasticY(chart);
  };
  chart._invokeYDomainListener = function (minMax) {
    _listeners.yDomain(chart, minMax);
  };

  chart._invokeelasticXListener = function () {
    _listeners.elasticX(chart);
  };
  chart._invokeXDomainListener = function (minMax) {
    _listeners.xDomain(chart, minMax);
  };

  function handleRangeFocus(chart, minMax) {
    if (chart.filters().length) {
      if (minMax[0] <= chart.filter()[0] && chart.filter()[1] <= minMax[1]) {
        var preserveFilter = chart.filter().slice();
        chart.rangeChart().replaceFilter(minMax);
        chart.replaceFilter(preserveFilter);
      } else {
        chart.rangeChart().replaceFilter(minMax);
      }
    } else {
      chart.rangeChart().filter(minMax);
    }
  }

  function setAxis(type, minMax) {
    if (type === "y") {
      chart.elasticY(false);
      chart._invokeelasticYListener();
      chart.y().domain(minMax);
      chart._invokeYDomainListener(minMax);
    } else {
      if (chart.rangeChart && chart.rangeChart()) {
        return handleRangeFocus(chart, minMax);
      }

      chart.elasticX(false);
      chart._invokeelasticXListener();
      chart.x().domain(minMax);
      chart._invokeXDomainListener(minMax);
      if (chart.focusChart && chart.focusChart()) {
        chart.focusChart().elasticX(false);
        chart.focusChart()._invokeelasticXListener();
        chart.focusChart()._invokeXDomainListener(minMax);
        if (!chart.filters().length) {
          chart.focusChart().x().domain(minMax);
        }
        chart.focusChart().xOriginalDomain(minMax);
        chart.focusChart().renderAsync();
      }
    }
    chart.renderAsync();
  }

  function toggleLock(type) {
    if (type === "y") {
      chart.elasticY(!chart.elasticY());
      chart._invokeelasticYListener();
      if (chart.elasticY()) {
        chart._invokeYDomainListener(null);
      } else {
        chart._invokeYDomainListener(chart.y().domain().slice(0));
      }
    } else {
      chart.elasticX(!chart.elasticX());
      chart._invokeelasticXListener();
      if (chart.elasticX()) {
        chart._invokeXDomainListener(null);
      } else {
        chart._invokeXDomainListener(chart.x().domain().slice());
      }
      if (chart.focusChart && chart.focusChart()) {
        chart.focusChart().elasticX(!chart.focusChart().elasticX());
        chart.focusChart()._invokeelasticXListener();
        if (chart.elasticX()) {
          chart.focusChart()._invokeXDomainListener(null);
        } else {
          chart.focusChart()._invokeXDomainListener(chart.x().domain().slice());
        }
        chart.focusChart().redrawAsync();
      }
    }
    chart.redrawAsync();
  }

  function updateMinMax(type, value) {
    if (value.some(isNaN) || value[1] <= value[0] || type === "x" && chart.rangeChart && chart.rangeChart() && (value[0] < chart.rangeChart().x().domain()[0] || value[1] > chart.rangeChart().x().domain()[1])) {
      chart.prepareLockAxis(type);
    } else {
      setAxis(type, value);
    }
  }

  chart.prepareLockAxis = function () {
    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "y";

    if (chart.focusChart && chart.focusChart() && type === "y") {
      return;
    }

    var iconPosition = {
      left: type === "y" ? chart.margins().left - TOGGLE_SIZE / 2 + "px" : chart.width() - chart.margins().right + "px",
      top: type === "y" ? chart.margins().top - TOGGLE_SIZE + "px" : chart.height() - chart.margins().bottom + "px"
    };

    var inputsPosition = {
      minLeft: chart.margins().left + "px",
      minTop: chart.height() - chart.margins().bottom + "px",
      maxLeft: type === "y" ? chart.margins().left + "px" : chart.width() - chart.margins().right + "px",
      maxTop: type === "y" ? chart.margins().top + "px" : chart.height() - chart.margins().bottom + "px"
    };

    var hitBoxDim = {
      top: type === "y" ? 0 : chart.height() - chart.margins().bottom + "px",
      left: type === "y" ? 0 : chart.margins().left + "px",
      width: type === "y" ? chart.margins().left + "px" : chart.width() - chart.margins().left + "px",
      height: type === "y" ? chart.height() + "px" : chart.margins().bottom + "px"
    };

    var minMax = chart[type]().domain().slice();

    chart.root().selectAll(".axis-lock.type-" + type).remove();

    var lockWrapper = chart.root().append("div").attr("class", "axis-lock type-" + type);

    lockWrapper.append("div").attr("class", "hit-box").style("width", hitBoxDim.width).style("height", hitBoxDim.height).style("top", hitBoxDim.top).style("left", hitBoxDim.left);

    lockWrapper.append("div").attr("class", "lock-toggle type-" + type).classed("is-locked", function () {
      return type === "y" ? !chart.elasticY() : !chart.elasticX();
    }).style("top", iconPosition.top).style("left", iconPosition.left).on("click", function () {
      return toggleLock(type);
    });

    if (chart.rangeChart && chart.rangeChart() && type === "x") {
      lockWrapper.selectAll(".lock-toggle.type-x").remove();
    }

    var axisMax = lockWrapper.append("div").attr("class", "axis-input max").style("top", inputsPosition.maxTop).style("left", inputsPosition.maxLeft);

    axisMax.append("input").attr("pattern", "[0-9-]").attr("value", formatVal(minMax[1])).on("focus", function () {
      this.select();
    }).on("change", function () {
      var val = minMax[1] instanceof Date ? (0, _moment2.default)(this.value, DATE_FORMAT).toDate() : parseFloatStrict(this.value.replace(/,/g, ""));
      updateMinMax(type, [minMax[0], val]);
    }).on("keyup", function () {
      if (_d2.default.event.keyCode === RETURN_KEY) {
        this.blur();
      }
    });

    axisMax.append("div").text(formatVal(minMax[1]));

    var axisMin = lockWrapper.append("div").attr("class", "axis-input min").style("top", inputsPosition.minTop).style("left", inputsPosition.minLeft);

    axisMin.append("input").attr("value", formatVal(minMax[0])).on("focus", function () {
      this.select();
    }).on("change", function () {
      var val = minMax[0] instanceof Date ? (0, _moment2.default)(this.value, DATE_FORMAT).toDate() : parseFloatStrict(this.value.replace(/,/g, ""));
      updateMinMax(type, [val, minMax[1]]);
    }).on("keyup", function () {
      if (_d2.default.event.keyCode === RETURN_KEY) {
        this.blur();
      }
    });

    axisMin.append("div").text(formatVal(minMax[0]));
  };

  return chart;
}

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = multiSeriesMixin;

var _core = __webpack_require__(2);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var LIMIT = 21;
var OFFSET = 0;
var TOP = 5;
var MULTI_DIMENSION_INDEX = 1;

function processMultiSeriesResults(results) {
  return results.reduce(function (accum, _ref) {
    var key1 = _ref.key1,
        key0 = _ref.key0,
        val = _ref.val;

    if (accum.keys[key1]) {
      accum.keys[key1] = accum.keys[key1];
    } else if (key1 === "other") {
      accum.keys[key1] = key1;
    } else {
      accum.keys[key1] = "series_" + (Object.keys(accum.keys).length + 1);
    }

    if (Array.isArray(key0)) {
      var isExtract = key0[0].isExtract;

      var min = isExtract ? key0[0].value : key0[0].value || key0[0];
      var alias = key0[0].alias || min;

      if (typeof accum.ranges[alias] !== "number") {
        // eslint-disable-line no-negated-condition
        accum.data[accum.data.length] = _defineProperty({
          key0: key0
        }, accum.keys[key1], val);
        accum.ranges[alias] = accum.data.length - 1;
      } else {
        accum.data[accum.ranges[alias]][accum.keys[key1]] = val;
      }
    } else if (typeof accum.ranges[key0] !== "number") {
      // eslint-disable-line
      accum.data[accum.data.length] = _defineProperty({
        key0: key0
      }, accum.keys[key1], val);
      accum.ranges[key0] = accum.data.length - 1;
    } else {
      accum.data[accum.ranges[key0]][accum.keys[key1]] = val;
    }

    return accum;
  }, {
    keys: {},
    ranges: {},
    data: []
  });
}

function selectWithCase(dimension, values) {
  if (dimension.slice(0, 9) === "CASE when") {
    return dimension;
  } else {
    var set = values.map(function (val) {
      return "'" + val.replace(/'/, "''") + "'";
    }).join(",");
    return "CASE when " + dimension + " IN (" + set + ") then " + dimension + " ELSE 'other' END";
  }
}

function setDimensionsWithColumns(columns, selected) {
  return function setDimensions(crossfilterDimensionArray) {
    return [crossfilterDimensionArray[0], selectWithCase(columns[MULTI_DIMENSION_INDEX], selected)];
  };
}

function flipKeys(keys) {
  return Object.keys(keys).reduce(function (accum, val) {
    accum[keys[val]] = val;
    return accum;
  }, {});
}

function multiSeriesMixin(chart) {
  var columns = null;
  var showOther = false;

  var series = {
    group: null,
    values: null,
    selected: null,
    keys: null
  };

  var seriesApi = {
    group: seriesMethodWithKey("group"),
    values: seriesMethodWithKey("values"),
    selected: seriesMethodWithKey("selected"),
    keys: seriesMethodWithKey("keys")
  };

  function seriesMethodWithKey(key) {
    return function seriesMethod(value) {
      if (typeof value === "undefined") {
        return series[key];
      }
      series[key] = value;
      return seriesApi;
    };
  }

  (0, _core.override)(chart, "_doRedraw", function () {
    if (chart.isMulti()) {
      setUpMultiStack();
      var rendered = chart.__doRedraw();
      chart.generatePopup();
      return rendered;
    } else {
      return chart.__doRedraw();
    }
  });

  (0, _core.override)(chart, "dimension", function (dimension) {
    if (!dimension) {
      return chart._dimension();
    }

    columns = dimension.value().slice();
    return chart._dimension(dimension);
  });

  chart.series = function () {
    return seriesApi;
  };

  chart.isMulti = function () {
    return chart.dimension().value().length > MULTI_DIMENSION_INDEX;
  };

  chart.showOther = function (other) {
    if (typeof other === "boolean") {
      showOther = other;
      return chart;
    }
    return showOther;
  };

  function dataAsync(group, callback) {
    if (chart.isMulti()) {
      return chart.series().group().topAsync(LIMIT, OFFSET).then(function (topValues) {
        var currentSelected = chart.series().selected();
        var hasSelected = Boolean(currentSelected && currentSelected.length);

        chart.series().values(topValues.map(function (result) {
          return result.key0;
        })).selected(hasSelected ? currentSelected : chart.series().values().slice(0, TOP));

        chart.group().dimension().set(setDimensionsWithColumns(columns, chart.series().selected()));

        chart.group().dimension().multiDim(false);

        return chart.group().reduce(chart.group().reduce()).all(function (error, results) {
          if (error) {
            return callback(error);
          } else {
            var _processMultiSeriesRe = processMultiSeriesResults(results),
                data = _processMultiSeriesRe.data,
                keys = _processMultiSeriesRe.keys;

            chart.series().keys(flipKeys(keys));
            return callback(error, data);
          }
        });
      }).catch(function (e) {
        return callback(e);
      });
    } else {
      return group.all(callback);
    }
  }

  function emptyStackMutation() {
    while (chart.stack().length) {
      chart.stack().pop();
    }
  }

  function addValuesWithNoKeysToKeysMutation() {
    function valuesWithNoKeys() {
      var keys = chart.series().keys();
      var selected = chart.series().selected() || [];
      var values = selected.slice();
      var indexes = Object.keys(keys).reduce(function (accum, key) {
        return accum.concat(selected.indexOf(keys[key]));
      }, []);
      indexes.forEach(function (index) {
        return values.splice(index, 1);
      });
      return values;
    }

    valuesWithNoKeys().forEach(function (select) {
      var currentLength = Object.keys(chart.series().keys()).length;
      var key = "series_" + (currentLength + 1);
      chart.series().keys()[key] = select;
    });
  }

  function stackFromSelected() {
    var keys = chart.series().keys();
    chart.series().selected().forEach(function (value) {
      var seriesName = Object.keys(keys).reduce(function (accum, v) {
        return keys[v] === value ? v : accum;
      }, null);
      chart.stack(chart.group(), seriesName, function (d) {
        return d[seriesName];
      });
    });
  }

  function setUpMultiStack() {
    if (chart.isMulti()) {
      emptyStackMutation();
      stackFromSelected();
      if (Object.keys(chart.series().keys()).length !== chart.stack().length && !chart.series().keys().other) {
        addValuesWithNoKeysToKeysMutation();
      }
      if (chart.showOther()) {
        chart.stack(chart.group(), "other", function (d) {
          return d.other;
        });
      }
    }
  }

  chart.setDataAsync(dataAsync);
  chart.on("preRender", setUpMultiStack);

  return chart;
}

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = earcut;
module.exports.default = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertice leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize),
        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return p;
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m.next;

    while (p !== stop) {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    }

    return m;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if ((equals(p1, q1) && equals(p2, q2)) ||
        (equals(p1, q2) && equals(p2, q1))) return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertice index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertice nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.distance_in_meters = distance_in_meters;
exports.conv900913To4326X = conv900913To4326X;
exports.conv900913To4326Y = conv900913To4326Y;
exports.conv900913To4326 = conv900913To4326;
exports.conv4326To900913X = conv4326To900913X;
exports.conv4326To900913Y = conv4326To900913Y;
exports.conv4326To900913 = conv4326To900913;

var _mapdDraw = __webpack_require__(22);

var MapdDraw = _interopRequireWildcard(_mapdDraw);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Calculates the distance in meters between two lon/lat coordinates
 * @param  {number} fromlon Longitude to start from
 * @param  {number} fromlat Latitude to start from
 * @param  {number} tolon   Longitude to end at
 * @param  {number} tolat   Latitude to end at
 * @return {number}         Distance in meters from two lon/lat coords
 */
function distance_in_meters(fromlon, fromlat, tolon, tolat) {
  var latitudeArc = (fromlat - tolat) * MapdDraw.Math.DEG_TO_RAD;
  var longitudeArc = (fromlon - tolon) * MapdDraw.Math.DEG_TO_RAD;
  var latitudeH = Math.sin(latitudeArc * 0.5);
  latitudeH = latitudeH * latitudeH;
  var lontitudeH = Math.sin(longitudeArc * 0.5);
  lontitudeH = lontitudeH * lontitudeH;
  var tmp = Math.cos(fromlat * MapdDraw.Math.DEG_TO_RAD) * Math.cos(tolat * MapdDraw.Math.DEG_TO_RAD);
  return 6372797.560856 * (2.0 * Math.asin(Math.sqrt(latitudeH + tmp * lontitudeH)));
}

/**
 * Converts mercator x coordinate to longitude
 * @param  {number} x X coordinate in mercator projected space
 * @return {number}   Longitude
 */
function conv900913To4326X(x) {
  return x / 111319.490778;
}

/**
 * Converts mercator y coordinate to latitude
 * @param  {number} y Y coordinate in mercator projected space
 * @return {number}   Latitude
 */
function conv900913To4326Y(y) {
  return 57.295779513 * (2 * Math.atan(Math.exp(y / 6378136.99911)) - 1.570796327);
}

/**
 * Converts 2d point in mercator projected space to a lon/lat coordinate
 * @param  {Point2d} out   2d point to store the converted lat/lon coordinate
 * @param  {Point2d} coord 2d point in mercator projected space to convert
 * @return {Point2d}       Point referred to by the out arg
 */
function conv900913To4326(out, coord) {
  return MapdDraw.Point2d.set(out, conv900913To4326X(coord[0]), conv900913To4326Y(coord[1]));
}

/**
 * Converts a longitude coordinate to an x coordinate in mercator projected space
 * @param  {number} x Longitude
 * @return {number}   X coordinate in mercator projected space
 */
function conv4326To900913X(x) {
  return x * 111319.490778;
}

/**
 * Converts a latitude coordinate to a y coordinate in mercator projected space
 * @param  {number} x Latitude
 * @return {number}   Y coordinate in mercator projected space
 */
function conv4326To900913Y(y) {
  return 6378136.99911 * Math.log(Math.tan(0.00872664626 * y + 0.785398163397));
}

/**
 * Converts 2d lon/lat point to a point in mercator projected space
 * @param  {Point2d} out   2d point to store the converted mercator coordinate
 * @param  {Point2d} coord 2d point in lon/lat to convert
 * @return {Point2d}       Point referred to by the out arg
 */
function conv4326To900913(out, coord) {
  return MapdDraw.Point2d.set(out, conv4326To900913X(coord[0]), conv4326To900913Y(coord[1]));
}

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = coordinateGridRasterMixin;

var _core = __webpack_require__(2);

var _baseMixin = __webpack_require__(5);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

var _coordinateGridRasterMixinUi = __webpack_require__(204);

var _coordinateGridRasterMixinUi2 = _interopRequireDefault(_coordinateGridRasterMixinUi);

var _colorMixin = __webpack_require__(7);

var _colorMixin2 = _interopRequireDefault(_colorMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _marginMixin = __webpack_require__(12);

var _marginMixin2 = _interopRequireDefault(_marginMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Coordinate Grid Raster is an abstract base chart designed to support coordinate grid based
 * chart types when the data is backend rendered.
 * @name coordinateGridRasterMixin
 * @memberof dc
 * @mixin
 * @mixes dc.colorMixin
 * @mixes dc.marginMixin
 * @mixes dc.baseMixin
 * @param {Object} _chart
 * @return {dc.coordinateGridRasterMixin}
 */
function coordinateGridRasterMixin(_chart, _mapboxgl, browser) {
  var _mapboxgl = typeof mapboxgl === "undefined" ? _mapboxgl : mapboxgl;

  var GRID_LINE_CLASS = "grid-line";
  var HORIZONTAL_CLASS = "horizontal";
  var VERTICAL_CLASS = "vertical";
  var Y_AXIS_LABEL_CLASS = "y-axis-label";
  var X_AXIS_LABEL_CLASS = "x-axis-label";
  var DEFAULT_AXIS_LABEL_PADDING = 12;

  var _brush = _d2.default.svg.brush();
  var _hasBeenRendered = false;
  var _scale = [1, 1];
  var _offset = [0, 0];
  var _currDataBounds = [[0, 1], [0, 1]];
  var _queryId = null;
  var _filters = [];
  var _initialFilters = null;
  var _gridInitted = false;

  var NO_CACHE = false;
  var cachedXTickFormat = NO_CACHE;
  var cachedYTickFormat = NO_CACHE;

  _chart = (0, _colorMixin2.default)((0, _marginMixin2.default)((0, _baseMixin2.default)(_chart)));
  _chart._mandatoryAttributes().push("x", "y");

  _chart.resetSvg = function () {
    _chart.root().selectAll("*:not(.legend)").remove();

    return _chart.generateSvg();
  };

  _chart.filters = function () {
    return _filters;
  };

  _chart.filter = function (filters) {
    if (typeof filters === "undefined" || filters === null || filters === Symbol.for("clear")) {
      _initialFilters = _initialFilters || [[]];
      filterChartDimensions(_initialFilters[0][0], _initialFilters[0][1], true);
    } else if (Array.isArray(filters) && filters.length === 2) {
      filterChartDimensions(filters[0], filters[1], false);
    } else {
      throw new Error("Invalid filter applied. Filter must be an array with two elements");
    }

    return _chart;
  };

  function filterChartDimensions(xrange, yrange, shouldReset) {
    if (!_initialFilters) {
      _initialFilters = [[xrange, yrange]];
    }

    var xdim = _chart.xDim();
    var ydim = _chart.yDim();

    if (xdim) {
      xdim.filter(xrange);
    }

    if (ydim) {
      ydim.filter(yrange);
    }

    if (typeof _chart.getLayers === "function") {
      _chart.getLayers().forEach(function (layer) {
        if (typeof layer.xDim === "function" && typeof layer.yDim === "function") {
          xdim = layer.xDim();
          ydim = layer.yDim();
          if (xdim !== null && ydim !== null) {
            xdim.filter(xrange);
            ydim.filter(yrange);
          }
        }
      });
    }

    _filters = shouldReset ? [] : [[xrange, yrange]];
    _chart._invokeFilteredListener(_filters, false);
    _chart.xRangeFilter(xrange);
    _chart.yRangeFilter(yrange);
  }

  var _parent = void 0;
  var _g = void 0;
  var _chartBody = void 0;
  var _gl = void 0;
  var _shaderProgram = void 0,
      _fragShader = void 0,
      _vertShader = void 0;
  var _vbo = void 0;
  var _tex = void 0;
  var _img = void 0;

  var _eventHandler = void 0;
  var _interactionsEnabled = false;

  var _xOriginalDomain = void 0;
  var _xAxis = _d2.default.svg.axis().orient("bottom");
  var _xUnits = _core.units.integers;
  var _xAxisPadding = 0;
  var _xElasticity = false;
  var _xAxisLabel = void 0;
  var _xAxisLabelPadding = 0;
  var _lastXDomain = void 0;

  var _yAxis = _d2.default.svg.axis().orient("left");
  var _yAxisPadding = 0;
  var _yElasticity = false;
  var _yAxisLabel = void 0;
  var _yAxisLabelPadding = 0;

  var _renderHorizontalGridLine = false;
  var _renderVerticalGridLine = false;

  var _resizing = false;

  var _unitCount = void 0;

  var _outerRangeBandPadding = 0.5;
  var _rangeBandPadding = 0;

  var _useRightYAxis = false;

  var _maxBounds = [[-Infinity, -Infinity], [Infinity, Infinity]];

  _chart._fitToMaxBounds = function (currBounds, resizeToScale) {
    var xmin = currBounds[0][0];
    var ymin = currBounds[0][1];
    var xmax = currBounds[1][0];
    var ymax = currBounds[1][1];
    var xdiff = xmax - xmin;
    var ydiff = ymax - ymin;

    var bounds_xmin = _maxBounds[0][0];
    var bounds_ymin = _maxBounds[0][1];
    var bounds_xmax = _maxBounds[1][0];
    var bounds_ymax = _maxBounds[1][1];

    var newbounds = [[Math.max(xmin, bounds_xmin), Math.max(ymin, bounds_ymin)], [Math.min(xmax, bounds_xmax), Math.min(ymax, bounds_ymax)]];

    if (resizeToScale) {
      var newxdiff = newbounds[1][0] - newbounds[0][0];
      var newydiff = newbounds[1][1] - newbounds[0][1];

      var deltax = xdiff - newxdiff;
      var deltay = ydiff - newydiff;

      // NOTE: deltax & deltay should be >= 0
      if (deltax !== 0) {
        if (newbounds[0][0] !== bounds_xmin) {
          newbounds[0][0] = Math.max(newbounds[0][0] - deltax, bounds_xmin);
        } else if (newbounds[1][0] !== bounds_xmax) {
          newbounds[1][0] = Math.min(newbounds[1][0] + deltax, bounds_xmax);
        }
      }

      if (deltay !== 0) {
        if (newbounds[0][1] !== bounds_ymin) {
          newbounds[0][1] = Math.max(newbounds[0][1] - deltay, bounds_ymin);
        } else if (newbounds[1][1] !== bounds_ymax) {
          newbounds[1][1] = Math.min(newbounds[1][1] + deltay, bounds_ymax);
        }
      }
    }

    return newbounds;
  };

  _chart.maxBounds = function (maxBounds) {
    if (!arguments.length) {
      return _maxBounds;
    }

    // TODO(croot): verify max bounds?
    if (!(maxBounds instanceof Array) || maxBounds.length !== 2 || !(maxBounds[0] instanceof Array) || maxBounds[0].length !== 2 || !(maxBounds[1] instanceof Array) || maxBounds[1].length !== 2) {
      throw new Error("Invalid bounds argument. A bounds object should be: [[xmin, ymin], [xmax, ymax]]");
    }

    _maxBounds = [[Math.min(maxBounds[0][0], maxBounds[1][0]), Math.min(maxBounds[0][1], maxBounds[1][1])], [Math.max(maxBounds[0][0], maxBounds[1][0]), Math.max(maxBounds[0][1], maxBounds[1][1])]];

    return _chart;
  };

  _chart.unproject = function (pt) {
    var xscale = _chart.x(),
        yscale = _chart.y();
    var x = xscale ? xscale.invert(pt.x) : 0;
    var y = yscale ? yscale.invert(pt.y) : 0;
    return new _mapboxgl.Point(x, y);
  };

  _chart.enableInteractions = function (enableInteractions) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!arguments.length) {
      return _interactionsEnabled;
    }

    _interactionsEnabled = Boolean(enableInteractions);
    if (_eventHandler) {
      var map = _chart.map();
      _eventHandler.getInteractionPropNames().forEach(function (prop) {
        if (map[prop]) {
          var enable = typeof opts[prop] === "undefined" ? _interactionsEnabled : Boolean(opts[prop]);
          if (enable) {
            map[prop].enable();
          } else {
            map[prop].disable();

            if (prop === "dragPan") {
              // force a clear of the current event state on the map
              // to fully disable pans
              map[prop].onMouseUp({
                button: 0
              });
            }
          }
        }
      });
    }

    return _chart;
  };

  /**
   * When changing the domain of the x or y scale, it is necessary to tell the chart to recalculate
   * and redraw the axes. (`.rescale()` is called automatically when the x or y scale is replaced
   * with {@link #dc.coordinateGridRasterMixin+x .x()} or {@link #dc.coordinateGridRasterMixin+y .y()}, and has
   * no effect on elastic scales.)
   * @name rescale
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.rescale = function () {
    _unitCount = undefined;
    _resizing = true;
    return _chart;
  };

  _chart.resizing = function () {
    return _resizing;
  };

  function initWebGL(canvas) {
    var webglAttrs = {
      alpha: true,
      antialias: true,
      // premultipliedAlpha: false,
      depth: false,
      stencil: false,
      failIfMajorPerformanceCaveat: false,
      preserveDrawingBuffer: false
    };
    _gl = canvas.getContext("webgl", webglAttrs) || canvas.getContext("experimental-webgl", webglAttrs);

    var vertShaderSrc = "" + "precision mediump float;\n" + "attribute vec2 a_pos;\n" + "attribute vec2 a_texCoords;\n" + "\n" + "varying vec2 v_texCoords;\n" + "uniform vec2 u_texCoordsScale;\n" + "uniform vec2 u_texCoordsOffset;\n" + "\n" + "void main(void) {\n" + "    gl_Position = vec4(a_pos, 0, 1);\n" + "\n" + "    v_texCoords = u_texCoordsScale * a_texCoords + u_texCoordsOffset;\n" +
    // NOTE: right now it seems that unpacking the base64 array via the
    // createImageBitmap() call puts pixel 0,0 in the upper left-hand
    // corner rather than the lower left-hand corner in the way that
    // webgl expects, so flipping the y texture coords below.
    // If another way of extracing the base64 image data is done
    // that doesn"t flip the image, then flip the y tex coords
    "    v_texCoords.y = (1.0 - v_texCoords.y);\n" + "}";

    var fragShaderSrc = "" + "precision mediump float;\n" + "\n" + "uniform sampler2D u_sampler;\n" + "\n" + "varying vec2 v_texCoords;\n" + "\n" + "void main() {\n" + "    if (v_texCoords[0] >= 0.0 && v_texCoords[0] <= 1.0 &&\n" + "        v_texCoords[1] >= 0.0 && v_texCoords[1] <= 1.0) {\n" + "        gl_FragColor = texture2D(u_sampler, v_texCoords);\n" + "    }\n" + "}";

    var gl = _gl;

    var program = _shaderProgram = gl.createProgram();

    var fragShader = _fragShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragShader, fragShaderSrc);
    gl.compileShader(fragShader);
    if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
      throw new Error("Error compiling fragment shader: " + gl.getShaderInfoLog(fragShader));
    }
    gl.attachShader(program, fragShader);

    var vertShader = _vertShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertShader, vertShaderSrc);
    gl.compileShader(vertShader);
    if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
      throw new Error("Error compiling vertex shader: " + gl.getShaderInfoLog(vertShader));
    }
    gl.attachShader(program, vertShader);

    gl.linkProgram(program);
    gl.validateProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      throw new Error("Error linking shader program: " + gl.getProgramInfoLog(program));
    }

    program.a_pos = gl.getAttribLocation(program, "a_pos");
    program.a_texCoords = gl.getAttribLocation(program, "a_texCoords");
    gl.enableVertexAttribArray(program.a_pos);
    gl.enableVertexAttribArray(program.a_texCoords);

    program.u_texCoordsScale = gl.getUniformLocation(program, "u_texCoordsScale");
    program.u_texCoordsOffset = gl.getUniformLocation(program, "u_texCoordsOffset");
    program.u_sampler = gl.getUniformLocation(program, "u_sampler");

    gl.useProgram(program);

    var vbo = _vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);

    var vertData = [-1, -1, 0, 0, 1, -1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1]; // unflipped

    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertData), gl.STATIC_DRAW);
    gl.vertexAttribPointer(_shaderProgram.a_pos, 2, gl.FLOAT, false, 16, 0);
    gl.vertexAttribPointer(_shaderProgram.a_texCoords, 2, gl.FLOAT, false, 16, 8);

    createGLTexture();
  }

  function destroy() {
    destroyWebGL();

    if (_eventHandler) {
      _eventHandler.destroy();
    }
    _eventHandler = null;

    if (_chartBody && _chartBody.parentNode) {
      _chartBody.parentNode.removeChild(node);
    }

    _chartBody = null;
  }

  function destroyWebGL() {
    var gl = _gl;
    if ((typeof _shaderProgram === "undefined" ? "undefined" : _typeof(_shaderProgram)) !== "object") {
      return;
    }
    gl.deleteProgram(_shaderProgram);
    if (_fragShader) {
      gl.deleteShader(_fragShader);
    }
    if (_vertShader) {
      gl.deleteShader(_vertShader);
    }
    if (_vbo) {
      gl.deleteBuffer(_vbo);
    }

    _shaderProgram = _fragShader = _vertShader = _vbo = 0;

    removeGLTexture();
  }

  function createGLTexture() {
    if (!_tex) {
      var gl = _gl;

      // use cyan as the default color.
      var initialColor = new Uint8Array([0, 0, 0, 0]);

      // make a texture with 1x1 pixels so we can use the texture immediately
      // while we wait for the image to load
      var tex = _tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, initialColor);
    }
  }

  function removeGLTexture() {
    if (_tex) {
      _gl.deleteTexture(_tex);
      _tex = 0;
    }

    // destroy our image cache
    _img = null;
  }

  _chart._removeOverlay = function () {
    removeGLTexture();
  };

  _chart._generateG = function (parent) {
    if (parent === undefined) {
      parent = _chart.svg();
    }

    var reset = parent !== _parent;
    _parent = parent;

    if (!_g || reset) {
      _g = _parent.append("g");
    }

    if (!_chartBody) {
      var root = _chart.root();

      _chartBody = root.append("canvas").attr("class", "webgl-canvas").style("position", "absolute");

      var containerNode = root.node();
      var chartNode = _chartBody.node();

      initWebGL(chartNode);
      _eventHandler = (0, _coordinateGridRasterMixinUi2.default)(_chart, containerNode, _currDataBounds, _scale, _offset, filterChartDimensions, doChartRedraw, browser, _mapboxgl, _interactionsEnabled);
    } else if (reset) {
      var root = _chart.root().node();
      var _node = _chartBody.node();
      root.appendChild(_node);
    }

    return _g;
  };

  /**
   * Get or set the root g element. This method is usually used to retrieve the g element in order to
   * overlay custom svg drawing programatically. **Caution**: The root g element is usually generated
   * by dc.js internals, and resetting it might produce unpredictable result.
   * @name g
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @param {SVGElement} [gElement]
   * @return {SVGElement}
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.g = function (gElement) {
    if (!arguments.length) {
      return _g;
    }
    _g = gElement;
    return _chart;
  };

  /**
   * Retrieve the canvas for the chart body.
   * @param {SVGElement} [chartBody]
   * @return {SVGElement}
   */
  _chart.chartBody = function (chartBody) {
    return _chartBody;
  };

  _chart.xOriginalDomain = function () {
    return _xOriginalDomain;
  };

  /**
   * Set or get the xUnits function. The coordinate grid chart uses the xUnits function to calculate
   * the number of data projections on x axis such as the number of bars for a bar chart or the
   * number of dots for a line chart. This function is expected to return a Javascript array of all
   * data points on x axis, or the number of points on the axis. [d3 time range functions
   * d3.time.days, d3.time.months, and
   * d3.time.years](https://github.com/mbostock/d3/wiki/Time-Intervals#aliases) are all valid xUnits
   * function. dc.js also provides a few units function, see the {@link #utilities Utilities} section for
   * a list of built-in units functions. The default xUnits function is units.integers.
   * @name xUnits
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @todo Add docs for utilities
   * @example
   * // set x units to count days
   * chart.xUnits(d3.time.days)
   * // set x units to count months
   * chart.xUnits(d3.time.months)
   *
   * // A custom xUnits function can be used as long as it follows the following interface:
   * // units in integer
   * function(start, end, xDomain) {
   *      // simply calculates how many integers in the domain
   *      return Math.abs(end - start)
   * }
   *
   * // fixed units
   * function(start, end, xDomain) {
   *      // be aware using fixed units will disable the focus/zoom ability on the chart
   *      return 1000
   * }
   * @param {Function} [xUnits]
   * @return {Function}
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.xUnits = function (xUnits) {
    if (!arguments.length) {
      return _xUnits;
    }
    _xUnits = xUnits;
    return _chart;
  };

  /**
   * Set or get the x axis used by a particular coordinate grid chart instance. This function is most
   * useful when x axis customization is required. The x axis in dc.js is an instance of a [d3
   * axis object](https://github.com/mbostock/d3/wiki/SVG-Axes#wiki-axis); therefore it supports any
   * valid d3 axis manipulation. **Caution**: The x axis is usually generated internally by dc
   * resetting it may cause unexpected results.
   * @name xAxis
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @see {@link http://github.com/mbostock/d3/wiki/SVG-Axes d3.svg.axis}
   * @example
   * // customize x axis tick format
   * chart.xAxis().tickFormat(function(v) {return v + "%";})
   * // customize x axis tick values
   * chart.xAxis().tickValues([0, 100, 200, 300])
   * @param {d3.svg.axis} [xAxis=d3.svg.axis().orient("bottom")]
   * @return {d3.svg.axis}
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.xAxis = function (xAxis) {
    if (!arguments.length) {
      return _xAxis;
    }
    _xAxis = xAxis;
    return _chart;
  };

  /**
   * Turn on/off elastic x axis behavior. If x axis elasticity is turned on, then the grid chart will
   * attempt to recalculate the x axis range whenever a redraw event is triggered.
   * @name elasticX
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @param {Boolean} [elasticX=false]
   * @return {Boolean}
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.elasticX = function (elasticX) {
    if (!arguments.length) {
      return _xElasticity;
    }
    _xElasticity = elasticX;
    return _chart;
  };

  /**
   * Set or get x axis padding for the elastic x axis. The padding will be added to both end of the x
   * axis if elasticX is turned on; otherwise it is ignored.
   *
   * padding can be an integer or percentage in string (e.g. "10%"). Padding can be applied to
   * number or date x axes.  When padding a date axis, an integer represents number of days being padded
   * and a percentage string will be treated the same as an integer.
   * @name xAxisPadding
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @param {Number|String} [padding=0]
   * @return {Number|String}
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.xAxisPadding = function (padding) {
    if (!arguments.length) {
      return _xAxisPadding;
    }
    _xAxisPadding = padding;
    return _chart;
  };

  /**
   * Returns the number of units displayed on the x axis using the unit measure configured by
   * .xUnits.
   * @name xUnitCount
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @return {Number}
   */
  _chart.xUnitCount = function () {
    if (_unitCount === undefined) {
      var _units = _chart.xUnits()(_chart.x().domain()[0], _chart.x().domain()[1], _chart.x().domain());

      if (_units instanceof Array) {
        _unitCount = _units.length;
      } else {
        _unitCount = _units;
      }
    }

    return _unitCount;
  };

  /**
   * Gets or sets whether the chart should be drawn with a right axis instead of a left axis. When
   * used with a chart in a composite chart, allows both left and right Y axes to be shown on a
   * chart.
   * @name useRightYAxis
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @param {Boolean} [useRightYAxis=false]
   * @return {Boolean}
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.useRightYAxis = function (useRightYAxis) {
    if (!arguments.length) {
      return _useRightYAxis;
    }
    _useRightYAxis = useRightYAxis;
    return _chart;
  };

  /**
   * Returns true if the chart is using ordinal xUnits ({@link #units.ordinal units.ordinal}, or false
   * otherwise. Most charts behave differently with ordinal data and use the result of this method to
   * trigger the appropriate logic.
   * @name isOrdinal
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @return {Boolean}
   */
  _chart.isOrdinal = function () {
    return _chart.xUnits() === _core.units.ordinal;
  };

  _chart._useOuterPadding = function () {
    return true;
  };

  function compareDomains(d1, d2) {
    return !d1 || !d2 || d1.length !== d2.length || d1.some(function (elem, i) {
      return elem && d2[i] ? elem.toString() !== d2[i].toString() : elem === d2[i];
    });
  }

  function prepareChartBody() {
    var width = _chart.effectiveWidth();
    var height = _chart.effectiveHeight();
    var margins = _chart.margins();
    var left = margins.left;
    var right = margins.right;
    var top = margins.top;
    var bottom = margins.bottom;
    var pixelRatio = window.devicePixelRatio || 1;

    var prevWidth = _chartBody.style("width");
    var prevHeight = _chartBody.style("height");

    // set the actual canvas size, taking pixel ratio into account
    _chartBody.style("width", width + "px").style("height", height + "px").style("left", left + "px").style("top", top + "px").attr("width", width * pixelRatio).attr("height", height * pixelRatio);

    _parent.style("width", width + (right + left) + "px").style("height", height + (top + bottom) + "px").attr("width", (width + (right + left)) * pixelRatio).attr("height", (height + (top + bottom)) * pixelRatio);

    if (prevWidth !== _chartBody.style("width") || prevHeight !== _chartBody.style("height")) {
      // TODO(croot): What about when the margins change?
      // That's not truly a resize event
      _chart.map().fire("resize", {
        width: width,
        height: height,
        top: top,
        left: left
      });
    }
  }

  function renderChart(imgUrl, renderBounds, queryId) {
    var gl = _gl;

    if (imgUrl) {
      // should we check to see if the imgUrl is the same from the previous render?
      _mapboxgl.util.getImage(imgUrl, function (err, img) {
        if (queryId === _queryId) {
          var xdom = _chart.x().domain();
          var ydom = _chart.y().domain();

          if (xdom[0] === renderBounds[0][0] && xdom[1] === renderBounds[1][0] && ydom[0] === renderBounds[2][1] && ydom[1] === renderBounds[0][1]) {

            if (!_tex) {
              createGLTexture();
            }

            if (!_img || img.width != _img.width || img.height != _img.height) {
              // Image was updated and dimensions changed.
              gl.bindTexture(gl.TEXTURE_2D, _tex);
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);

              if (!_img) {
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
              }
            } else {
              // Image was updated but dimensions unchanged.
              gl.bindTexture(gl.TEXTURE_2D, _tex);
              gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, img);
            }
            _img = img;

            _scale[0] = 1;
            _scale[1] = 1;
            _offset[0] = 0;
            _offset[1] = 0;
            var xrange = _chart.xRange();
            var yrange = _chart.yRange();
            _currDataBounds[0][0] = xrange[0];
            _currDataBounds[0][1] = xrange[1];
            _currDataBounds[1][0] = yrange[0];
            _currDataBounds[1][1] = yrange[1];

            renderChart();
          }
        }
      });
    }

    if (queryId !== null && queryId !== undefined) {
      _queryId = queryId;
    }

    var pixelRatio = window.devicePixelRatio || 1;
    gl.viewport(0, 0, _chart.effectiveWidth() * pixelRatio, _chart.effectiveHeight() * pixelRatio);

    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.enable(gl.BLEND);

    gl.useProgram(_shaderProgram);
    gl.bindBuffer(gl.ARRAY_BUFFER, _vbo);

    gl.uniform2fv(_shaderProgram.u_texCoordsScale, _scale);
    gl.uniform2fv(_shaderProgram.u_texCoordsOffset, _offset);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, _tex);
    gl.uniform1i(_shaderProgram.u_sampler, 0);

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }

  var customTimeFormat = _d2.default.time.format.utc.multi([[".%L", function (d) {
    return d.getUTCMilliseconds();
  }], [":%S", function (d) {
    return d.getUTCSeconds();
  }], ["%I:%M", function (d) {
    return d.getUTCMinutes();
  }], ["%I %p", function (d) {
    return d.getUTCHours();
  }], ["%a %d", function (d) {
    return d.getUTCDay() && d.getUTCDate() != 1;
  }], ["%b %d", function (d) {
    return d.getUTCDate() != 1;
  }], ["%b", function (d) {
    return d.getUTCMonth();
  }], ["%Y", function () {
    return true;
  }]]);

  function setXTickFormat(tickFormat, options) {
    if (options.toCache && cachedXTickFormat === NO_CACHE) {
      cachedXTickFormat = _xAxis.tickFormat();
    }

    _xAxis.tickFormat(tickFormat);

    if (options.fromCache) {
      cachedXTickFormat = NO_CACHE;
    }
  }

  function setXAxisFormat(needsDateFormat) {
    var dateFormatter = _chart.dateFormatter();
    var numberFormatter = _chart.valueFormatter();
    var dateFormatExistsForThisKey = Boolean(dateFormatter && dateFormatter(new Date(), _chart.xAxisLabel()));
    var numberFormatExistsForThisKey = Boolean(numberFormatter && numberFormatter(null, _chart.xAxisLabel()));

    if (needsDateFormat && dateFormatExistsForThisKey) {
      setXTickFormat(function (d) {
        return dateFormatter(d, _chart.xAxisLabel());
      }, { toCache: true });
    } else if (needsDateFormat) {
      setXTickFormat(customTimeFormat);
    } else if (numberFormatExistsForThisKey) {
      setXTickFormat(function (d) {
        return numberFormatter(d, _chart.xAxisLabel());
      }, { toCache: true });
    } else if (cachedXTickFormat !== NO_CACHE) {
      setXTickFormat(cachedXTickFormat, { fromCache: true });
    }
  }

  function prepareXAxis(g, x, render, transitionDuration) {
    // has the domain changed?
    var xdom = x.domain();
    if (render || compareDomains(_lastXDomain, xdom)) {
      _chart.rescale();
    }
    _lastXDomain = xdom;

    // TODO(croot): support ordinal scales?
    // If BE supports ordinal scales for X axis, use
    // rangeBands here: i.e. x.rangeBands([0, _chart.xAxisLength()], ...)

    // currently only supports quantitative scal
    x.range([0, Math.round(_chart.xAxisLength())]);

    _xAxis = _xAxis.scale(x);

    var needsDateFormat = xdom[0] instanceof Date;
    setXAxisFormat(needsDateFormat);

    _xAxis.ticks(_chart.effectiveWidth() / _xAxis.scale().ticks().length < 64 ? Math.ceil(_chart.effectiveWidth() / 64) : 10);

    _chart.prepareLabelEdit("x");

    renderVerticalGridLines(g, x, transitionDuration);
  }

  _chart.renderXAxis = function (g, transitionDuration) {
    var axisXG = g.selectAll("g.x");

    if (axisXG.empty()) {
      axisXG = g.append("g").attr("class", "axis x").attr("transform", "translate(" + _chart.margins().left + "," + _chart._xAxisY() + ")");
    }

    var root = _chart.root();
    var xLabel = root.selectAll(".x-axis-label");

    if (xLabel.empty()) {
      xLabel = root.append("div").attr("class", "x-axis-label");
    }

    xLabel.style("left", _chart.effectiveWidth() / 2 + _chart.margins().left + "px").text(_chart.xAxisLabel());

    if (transitionDuration === undefined) {
      transitionDuration = _chart.transitionDuration();
    }
    (0, _core.transition)(axisXG, transitionDuration).attr("transform", "translate(" + _chart.margins().left + "," + _chart._xAxisY() + ")").call(_xAxis);
  };

  function renderVerticalGridLines(g, x, transitionDuration) {
    var gridLineG = g.selectAll("g." + VERTICAL_CLASS);

    if (_renderVerticalGridLine) {
      if (gridLineG.empty()) {
        gridLineG = g.insert("g", ":first-child").attr("class", GRID_LINE_CLASS + " " + VERTICAL_CLASS).attr("transform", "translate(" + _chart.margins().left + "," + _chart.margins().top + ")");
      }

      var ticks = _xAxis.tickValues() ? _xAxis.tickValues() : typeof x.ticks === "function" ? x.ticks(_xAxis.ticks()[0]) : x.domain();

      var lines = gridLineG.selectAll("line").data(ticks);

      // enter
      var linesGEnter = lines.enter().append("line").attr("x1", function (d) {
        return x(d);
      }).attr("y1", _chart._xAxisY() - _chart.margins().top).attr("x2", function (d) {
        return x(d);
      }).attr("y2", 0).attr("opacity", 0);

      if (transitionDuration === undefined) {
        transitionDuration = _chart.transitionDuration();
      }

      (0, _core.transition)(linesGEnter, transitionDuration).attr("opacity", 1);

      // update
      (0, _core.transition)(lines, transitionDuration).attr("x1", function (d) {
        return x(d);
      }).attr("y1", _chart._xAxisY() - _chart.margins().top).attr("x2", function (d) {
        return x(d);
      }).attr("y2", 0);

      // exit
      lines.exit().remove();
    } else {
      gridLineG.selectAll("line").remove();
    }
  }

  _chart._xAxisY = function () {
    return _chart.height() - _chart.margins().bottom;
  };

  _chart.xAxisLength = function () {
    return _chart.effectiveWidth();
  };

  /**
   * Set or get the x axis label. If setting the label, you may optionally include additional padding to
   * the margin to make room for the label. By default the padded is set to 12 to accomodate the text height.
   * @name xAxisLabel
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @param {String} [labelText]
   * @param {Number} [padding=12]
   * @return {String}
   */
  _chart.xAxisLabel = function (labelText, padding) {
    if (!arguments.length) {
      return _xAxisLabel;
    }
    _xAxisLabel = labelText;
    _chart.margins().bottom -= _xAxisLabelPadding;
    _xAxisLabelPadding = padding === undefined ? DEFAULT_AXIS_LABEL_PADDING : padding;
    _chart.margins().bottom += _xAxisLabelPadding;
    return _chart;
  };

  function setYTickFormat(tickFormat, options) {
    if (options.toCache && cachedYTickFormat === NO_CACHE) {
      cachedYTickFormat = _yAxis.tickFormat();
    }

    _yAxis.tickFormat(tickFormat);

    if (options.fromCache) {
      cachedYTickFormat = NO_CACHE;
    }
  }

  function setYAxisFormat(needsDateFormat) {
    var dateFormatter = _chart.dateFormatter();
    var numberFormatter = _chart.valueFormatter();
    var dateFormatExistsForThisKey = Boolean(dateFormatter && dateFormatter(new Date(), _chart.yAxisLabel()));
    var numberFormatExistsForThisKey = Boolean(numberFormatter && numberFormatter(null, _chart.yAxisLabel()));

    if (needsDateFormat && dateFormatExistsForThisKey) {
      setYTickFormat(function (d) {
        return dateFormatter(d, _chart.yAxisLabel());
      }, { toCache: true });
    } else if (needsDateFormat) {
      setYTickFormat(customTimeFormat);
    } else if (!needsDateFormat && numberFormatExistsForThisKey) {
      setYTickFormat(function (d) {
        return numberFormatter(d, _chart.yAxisLabel());
      }, { toCache: true });
    } else if (cachedYTickFormat !== NO_CACHE) {
      setYTickFormat(cachedYTickFormat, { fromCache: true });
    }
  }

  _chart._prepareYAxis = function (g, y, transitionDuration) {
    y.range([Math.round(_chart.yAxisHeight()), 0]);

    _yAxis = _yAxis.scale(y);

    _yAxis.ticks(_chart.effectiveHeight() / _yAxis.scale().ticks().length < 16 ? Math.ceil(_chart.effectiveHeight() / 16) : 10);

    if (_useRightYAxis) {
      _yAxis.orient("right");
    }

    setYAxisFormat();

    _chart._renderHorizontalGridLinesForAxis(g, y, _yAxis, transitionDuration);
    _chart.prepareLabelEdit("y");
  };

  _chart.renderYAxisLabel = function (axisClass, text, rotation, labelXPosition) {
    var root = _chart.root();

    var yLabel = root.selectAll(".y-axis-label");

    if (yLabel.empty()) {
      yLabel = root.append("div").attr("class", "y-axis-label");
    }

    if (text !== "") {
      // TODO(croot): should add the rotation and labelXPosition here
      // As of now (09/02/2016) the chart.css is breaking this.

      yLabel.style("top", _chart.effectiveHeight() / 2 + _chart.margins().top + "px").text(text);
    }
  };

  _chart.renderYAxisAt = function (axisClass, axis, position, transitionDuration) {
    var axisYG = _chart.g().selectAll("g." + axisClass);
    if (axisYG.empty()) {
      axisYG = _chart.g().append("g").attr("class", "axis " + axisClass).attr("transform", "translate(" + position + "," + _chart.margins().top + ")");
    }

    if (transitionDuration === undefined) {
      transitionDuration = _chart.transitionDuration();
    }

    (0, _core.transition)(axisYG, transitionDuration).attr("transform", "translate(" + position + "," + _chart.margins().top + ")").call(axis);
  };

  _chart.renderYAxis = function (g, transitionDuration) {
    var axisPosition = _useRightYAxis ? _chart.width() - _chart.margins().right : _chart._yAxisX();
    _chart.renderYAxisAt("y", _yAxis, axisPosition, transitionDuration);
    var labelPosition = _useRightYAxis ? _chart.width() - _yAxisLabelPadding : _yAxisLabelPadding;
    var rotation = _useRightYAxis ? 90 : -90;
    _chart.renderYAxisLabel("y", _chart.yAxisLabel(), rotation, labelPosition);
  };

  _chart._renderHorizontalGridLinesForAxis = function (g, scale, axis, transitionDuration) {
    var gridLineG = g.selectAll("g." + HORIZONTAL_CLASS);

    if (_renderHorizontalGridLine) {
      var ticks = axis.tickValues() ? axis.tickValues() : scale.ticks(axis.ticks()[0]);

      if (gridLineG.empty()) {
        gridLineG = g.insert("g", ":first-child").attr("class", GRID_LINE_CLASS + " " + HORIZONTAL_CLASS).attr("transform", "translate(" + _chart.margins().left + "," + _chart.margins().top + ")");
      }

      var lines = gridLineG.selectAll("line").data(ticks);

      // enter
      var linesGEnter = lines.enter().append("line").attr("x1", 1).attr("y1", function (d) {
        return scale(d);
      }).attr("x2", _chart.xAxisLength()).attr("y2", function (d) {
        return scale(d);
      }).attr("opacity", 0);

      if (transitionDuration === undefined) {
        transitionDuration = _chart.transitionDuration();
      }

      (0, _core.transition)(linesGEnter, transitionDuration).attr("opacity", 1);

      // update
      (0, _core.transition)(lines, transitionDuration).attr("x1", 1).attr("y1", function (d) {
        return scale(d);
      }).attr("x2", _chart.xAxisLength()).attr("y2", function (d) {
        return scale(d);
      });

      // exit
      lines.exit().remove();
    } else {
      gridLineG.selectAll("line").remove();
    }
  };

  _chart._yAxisX = function () {
    return _chart.useRightYAxis() ? _chart.width() - _chart.margins().right : _chart.margins().left;
  };

  /**
   * Set or get the y axis label. If setting the label, you may optionally include additional padding
   * to the margin to make room for the label. By default the padded is set to 12 to accomodate the
   * text height.
   * @name yAxisLabel
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @param {String} [labelText]
   * @param {Number} [padding=12]
   * @return {String}
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.yAxisLabel = function (labelText, padding) {
    if (!arguments.length) {
      return _yAxisLabel;
    }
    _yAxisLabel = labelText;
    _chart.margins().left -= _yAxisLabelPadding;
    _yAxisLabelPadding = padding === undefined ? DEFAULT_AXIS_LABEL_PADDING : padding;
    _chart.margins().left += _yAxisLabelPadding;
    return _chart;
  };

  /**
   * Set or get the y axis used by the coordinate grid chart instance. This function is most useful
   * when y axis customization is required. The y axis in dc.js is simply an instance of a [d3 axis
   * object](https://github.com/mbostock/d3/wiki/SVG-Axes#wiki-_axis); therefore it supports any
   * valid d3 axis manipulation. **Caution**: The y axis is usually generated internally by dc
   * resetting it may cause unexpected results.
   * @name yAxis
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @see {@link http://github.com/mbostock/d3/wiki/SVG-Axes d3.svg.axis}
   * @example
   * // customize y axis tick format
   * chart.yAxis().tickFormat(function(v) {return v + "%";})
   * // customize y axis tick values
   * chart.yAxis().tickValues([0, 100, 200, 300])
   * @param {d3.svg.axis} [yAxis=d3.svg.axis().orient("left")]
   * @return {d3.svg.axis}
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.yAxis = function (yAxis) {
    if (!arguments.length) {
      return _yAxis;
    }
    _yAxis = yAxis;
    return _chart;
  };

  /**
   * Turn on/off elastic y axis behavior. If y axis elasticity is turned on, then the grid chart will
   * attempt to recalculate the y axis range whenever a redraw event is triggered.
   * @name elasticY
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @param {Boolean} [elasticY=false]
   * @return {Boolean}
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.elasticY = function (elasticY) {
    if (!arguments.length) {
      return _yElasticity;
    }
    _yElasticity = elasticY;
    return _chart;
  };

  /**
   * Turn on/off horizontal grid lines.
   * @name renderHorizontalGridLines
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @param {Boolean} [renderHorizontalGridLines=false]
   * @return {Boolean}
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.renderHorizontalGridLines = function (renderHorizontalGridLines) {
    if (!arguments.length) {
      return _renderHorizontalGridLine;
    }
    _renderHorizontalGridLine = renderHorizontalGridLines;
    return _chart;
  };

  /**
   * Turn on/off vertical grid lines.
   * @name renderVerticalGridLines
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @param {Boolean} [renderVerticalGridLines=false]
   * @return {Boolean}
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.renderVerticalGridLines = function (renderVerticalGridLines) {
    if (!arguments.length) {
      return _renderVerticalGridLine;
    }
    _renderVerticalGridLine = renderVerticalGridLines;
    return _chart;
  };

  /**
   * Set or get y axis padding for the elastic y axis. The padding will be added to the top of the y
   * axis if elasticY is turned on; otherwise it is ignored.
   *
   * padding can be an integer or percentage in string (e.g. "10%"). Padding can be applied to
   * number or date axes. When padding a date axis, an integer represents number of days being padded
   * and a percentage string will be treated the same as an integer.
   * @name yAxisPadding
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @param {Number|String} [padding=0]
   * @return {Number}
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.yAxisPadding = function (padding) {
    if (!arguments.length) {
      return _yAxisPadding;
    }
    _yAxisPadding = padding;
    return _chart;
  };

  _chart.yAxisHeight = function () {
    return _chart.effectiveHeight();
  };

  _chart._rangeBandPadding = function (_) {
    if (!arguments.length) {
      return _rangeBandPadding;
    }
    _rangeBandPadding = _;
    return _chart;
  };

  _chart._outerRangeBandPadding = function (_) {
    if (!arguments.length) {
      return _outerRangeBandPadding;
    }
    _outerRangeBandPadding = _;
    return _chart;
  };

  (0, _core.override)(_chart, "filter", function (filter, isInverseFilter) {
    if (!arguments.length) {
      return _chart._filter();
    }

    _chart._filter(filter, isInverseFilter);

    if (filter) {
      _chart.brush().extent(filter);
    } else {
      _chart.brush().clear();
    }

    return _chart;
  });

  _chart.brush = function (_) {
    if (!arguments.length) {
      return _brush;
    }
    _brush = _;
    return _chart;
  };

  _chart.isBrushing = function (_) {
    if (!arguments.length) {
      return _isBrushing;
    }
    _isBrushing = _;
    return _chart;
  };

  function brushHeight() {
    return _chart._xAxisY() - _chart.margins().top;
  }

  _chart.fadeDeselectedArea = function () {}
  // do nothing, sub-chart should override this function


  // borrowed from Crossfilter example
  ;_chart.resizeHandlePath = function (d) {
    var e = Number(d === "e"),
        x = e ? 1 : -1,
        y = brushHeight() / 3;
    return "M" + 0.5 * x + "," + y + "A6,6 0 0 " + e + " " + 6.5 * x + "," + (y + 6) + "V" + (2 * y - 6) + "A6,6 0 0 " + e + " " + 0.5 * x + "," + 2 * y + "Z" + "M" + 2.5 * x + "," + (y + 8) + "V" + (2 * y - 8) + "M" + 4.5 * x + "," + (y + 8) + "V" + (2 * y - 8);
  };

  function getClipPathId() {
    return _chart.anchorName().replace(/[ .#=\[\]]/g, "-") + "-clip";
  }

  _chart._preprocessData = function () {};

  function initGrid() {
    if (_gridInitted) {
      return;
    }
    _chart.resetSvg();
    _chart.svg().style("position", "absolute");
    _chart._generateG();
    _gridInitted = true;
  }

  function doChartRender(imgUrl, renderBounds, queryId) {
    initGrid();
    _chart._preprocessData();
    drawChart(true, imgUrl, renderBounds, queryId);
    _hasBeenRendered = true;
    return _chart;
  }

  _chart._doRender = function () {
    doChartRender();
  };

  function doChartRedraw(imgUrl, renderBounds, queryId) {
    if (!_hasBeenRendered) // guard to prevent a redraw before a render
      {
        return doChartRender(imgUrl, renderBounds, queryId);
      }

    _chart._preprocessData();

    drawChart(false, imgUrl, renderBounds, queryId);

    return _chart;
  }

  _chart._doRedraw = function () {
    doChartRedraw();
  };

  _chart._drawScatterPlot = function (doFullRender, imgUrl, renderBounds, queryId) {
    if (doFullRender) {
      doChartRender(imgUrl, renderBounds, queryId);
    } else {
      doChartRedraw(imgUrl, renderBounds, queryId);
    }
  };

  _chart._destroyScatterPlot = function () {
    destroy();
  };

  function drawChart(render, imgUrl, renderBounds, queryId) {
    // prepare and render the chart first so the grid lines/axes
    // are drawn on top
    prepareChartBody();
    renderChart(imgUrl, renderBounds, queryId);

    var transitionDuration = render ? _chart.transitionDuration() : 10;

    prepareXAxis(_chart.g(), _chart.x(), render, transitionDuration);
    _chart._prepareYAxis(_chart.g(), _chart.y(), transitionDuration);

    if (_chart.elasticX() || _resizing || render) {
      _chart.renderXAxis(_chart.g(), transitionDuration);
    }

    if (_chart.elasticY() || _resizing || render) {
      _chart.renderYAxis(_chart.g(), transitionDuration);
    }

    _chart.fadeDeselectedArea();
    _resizing = false;
    _chart.map().fire("render", {});
  }

  _chart.init = function () {
    initGrid();
    return new Promise(function (resolve, reject) {
      resolve(_chart);
    });
  };

  return _chart;
}

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = scatterMixin;

var _utils = __webpack_require__(3);

var _rasterDrawMixin = __webpack_require__(21);

function extend(destination, source) {
  for (var k in source) {
    if (source.hasOwnProperty(k)) {
      destination[k] = source[k];
    }
  }
  return destination;
}

function scatterMixin(_chart, _mapboxgl) {
  var mixinDraw = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

  var _mapboxgl = typeof mapboxgl === "undefined" ? _mapboxgl : mapboxgl;

  _chart._xDimName = null;
  _chart._yDimName = null;
  var _xDim = null;
  var _yDim = null;

  var _xRange = null;
  var _yRange = null;

  var _map = {
    remove: function remove() {
      _chart._destroyScatterPlot();
    },
    resize: function resize() {
      // noop
      // TODO(croot): send any events to notify the user of a change?
    }
  };

  // add event functionality to our dummy _map object
  extend(_map, _mapboxgl.Evented.prototype);

  _chart.map = function () {
    // just a getter - don't let user set map
    // this is to appease bubbleRasterChart
    // which was initially only setup to
    // do renders with mapbox (hence the name 'map')
    return _map;
  };

  function addDimAndRange(dim, dims, ranges) {
    if (dim) {
      dims.push(dim);
      var range = dim.getFilter();
      if (range !== null) {
        range.forEach(function (rangesArray) {
          ranges.push(rangesArray);
        });
      }
    }
  }

  function initializeXYDimsAndRanges(chart) {
    var xDims = [];
    var yDims = [];
    var xRanges = [];
    var yRanges = [];

    addDimAndRange(chart.xDim(), xDims, xRanges);
    addDimAndRange(chart.yDim(), yDims, yRanges);

    if (typeof chart.getLayers === "function") {
      _chart.getLayers().forEach(function (layer) {
        if (typeof layer.xDim === "function") {
          addDimAndRange(layer.xDim(), xDims, xRanges);
        }

        if (typeof layer.yDim === "function") {
          addDimAndRange(layer.yDim(), yDims, yRanges);
        }
      });
    }

    return {
      xDims: xDims,
      yDims: yDims,
      xRanges: xRanges,
      yRanges: yRanges
    };
  }

  _chart.getDataRenderBounds = function () {
    var dimRangeData = initializeXYDimsAndRanges(_chart);
    var xRanges = dimRangeData.xRanges;
    var yRanges = dimRangeData.yRanges;

    if (!xRanges.length) {
      // default to a 0-1 range
      _xRange = [0, 1];

      // TODO(croot): automatically determine the min/max of the x dimension
      // If we do this, we should cache the x scale and only
      // do this if the scale or dimension has changed
    } else {
      _xRange = xRanges.reduce(function (prevVal, currVal) {
        return [Math.min(prevVal[0], currVal[0]), Math.max(prevVal[1], currVal[1])];
      }, [Number.MAX_VALUE, -Number.MAX_VALUE]);

      if (_chart.elasticX()) {
        var xPadding = _chart.xAxisPadding();
        _xRange[0] = _utils.utils.subtract(_xRange[0], xPadding) || 0;
        _xRange[1] = _utils.utils.add(_xRange[1], xPadding) || 0;
      }
    }

    if (!yRanges.length) {
      // default to a 0-1 range
      _yRange = [0, 1];

      // TODO: automatically determine the min/max of the y dimension?
      // If we do this, we should cache the y scale and only
      // do this if the scale or dimension has changed
    } else {
      _yRange = yRanges.reduce(function (prevVal, currVal) {
        return [Math.min(prevVal[0], currVal[0]), Math.max(prevVal[1], currVal[1])];
      }, [Number.MAX_VALUE, -Number.MAX_VALUE]);

      if (_chart.elasticY()) {
        var yPadding = _chart.yAxisPadding();
        _yRange[0] = _utils.utils.subtract(_yRange[0], yPadding) || 0;
        _yRange[1] = _utils.utils.add(_yRange[1], yPadding) || 0;
      }
    }

    var bounds = _chart._fitToMaxBounds([[_xRange[0], _yRange[0]], [_xRange[1], _yRange[1]]]);
    _xRange[0] = bounds[0][0];
    _xRange[1] = bounds[1][0];
    _yRange[0] = bounds[0][1];
    _yRange[1] = bounds[1][1];

    var renderBounds = [[_xRange[0], _yRange[1]], // top left
    [_xRange[1], _yRange[1]], // top right
    [_xRange[1], _yRange[0]], // bottom right
    [_xRange[0], _yRange[0]]]; // bottom left

    return renderBounds;
  };

  _chart.xRange = function () {
    return _xRange;
  };

  _chart.yRange = function () {
    return _yRange;
  };

  _chart.xDim = function (xDim) {
    if (!arguments.length) {
      return _xDim;
    }
    _xDim = xDim;
    if (_xDim) {
      _chart._xDimName = _xDim.value()[0];
    }

    // force a refresh of the render bounds,
    // this currently doesn't improve anything.
    // We'd want to do this if we do a min/max
    // query during the getDataRenderBounds()
    // function
    _xRange = null;
    return _chart;
  };

  _chart.yDim = function (yDim) {
    if (!arguments.length) {
      return _yDim;
    }
    _yDim = yDim;
    if (_yDim) {
      _chart._yDimName = _yDim.value()[0];
    }

    // force a refresh of the render bounds
    // this currently doesn't improve anything.
    // We'd want to do this if we do a min/max
    // query during the getDataRenderBounds()
    // function
    _yRange = null;
    return _chart;
  };

  _chart._setOverlay = function (data, bounds, nonce, browser, redraw) {
    if (bounds === undefined) {
      return;
    }

    var blob = null;

    if (data) {
      if (browser.isSafari || browser.isIE || browser.isEdge) {
        blob = _utils.utils.b64toBlob(data, "image/png");
        var blobUrl = URL.createObjectURL(blob);
      } else {
        var blobUrl = "data:image/png;base64," + data;
      }
    }

    _chart._drawScatterPlot(!redraw, blobUrl, bounds, nonce);
  };

  _chart.isLoaded = function () {
    return _xRange && _yRange;
  };

  if (mixinDraw) {
    _chart = (0, _rasterDrawMixin.rasterDrawMixin)(_chart);
  }

  return _chart;
}

/***/ }),
/* 141 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = vnode;
function vnode(sel, data, children, text, elm) {
    var key = data === undefined ? undefined : data.key;
    return { sel: sel, data: data, children: children,
        text: text, elm: elm, key: key };
}
/* harmony default export */ __webpack_exports__["a"] = (vnode);
//# sourceMappingURL=vnode.js.map

/***/ }),
/* 142 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return array; });
/* harmony export (immutable) */ __webpack_exports__["b"] = primitive;
var array = Array.isArray;
function primitive(s) {
    return typeof s === 'string' || typeof s === 'number';
}
//# sourceMappingURL=is.js.map

/***/ }),
/* 143 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = h;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vnode__ = __webpack_require__(141);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__is__ = __webpack_require__(142);


function addNS(data, children, sel) {
    data.ns = 'http://www.w3.org/2000/svg';
    if (sel !== 'foreignObject' && children !== undefined) {
        for (var i = 0; i < children.length; ++i) {
            var childData = children[i].data;
            if (childData !== undefined) {
                addNS(childData, children[i].children, children[i].sel);
            }
        }
    }
}
function h(sel, b, c) {
    var data = {}, children, text, i;
    if (c !== undefined) {
        data = b;
        if (__WEBPACK_IMPORTED_MODULE_1__is__["a" /* array */](c)) {
            children = c;
        }
        else if (__WEBPACK_IMPORTED_MODULE_1__is__["b" /* primitive */](c)) {
            text = c;
        }
        else if (c && c.sel) {
            children = [c];
        }
    }
    else if (b !== undefined) {
        if (__WEBPACK_IMPORTED_MODULE_1__is__["a" /* array */](b)) {
            children = b;
        }
        else if (__WEBPACK_IMPORTED_MODULE_1__is__["b" /* primitive */](b)) {
            text = b;
        }
        else if (b && b.sel) {
            children = [b];
        }
        else {
            data = b;
        }
    }
    if (__WEBPACK_IMPORTED_MODULE_1__is__["a" /* array */](children)) {
        for (i = 0; i < children.length; ++i) {
            if (__WEBPACK_IMPORTED_MODULE_1__is__["b" /* primitive */](children[i]))
                children[i] = Object(__WEBPACK_IMPORTED_MODULE_0__vnode__["b" /* vnode */])(undefined, undefined, undefined, children[i], undefined);
        }
    }
    if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g' &&
        (sel.length === 3 || sel[3] === '.' || sel[3] === '#')) {
        addNS(data, children, sel);
    }
    return Object(__WEBPACK_IMPORTED_MODULE_0__vnode__["b" /* vnode */])(sel, data, children, text, undefined);
}
;
/* unused harmony default export */ var _unused_webpack_default_export = (h);
//# sourceMappingURL=h.js.map

/***/ }),
/* 144 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__exponent__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__formatGroup__ = __webpack_require__(223);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__formatNumerals__ = __webpack_require__(224);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__formatSpecifier__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__formatTypes__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__formatPrefixAuto__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__identity__ = __webpack_require__(227);








var prefixes = ["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ __webpack_exports__["a"] = (function(locale) {
  var group = locale.grouping && locale.thousands ? Object(__WEBPACK_IMPORTED_MODULE_1__formatGroup__["a" /* default */])(locale.grouping, locale.thousands) : __WEBPACK_IMPORTED_MODULE_6__identity__["a" /* default */],
      currency = locale.currency,
      decimal = locale.decimal,
      numerals = locale.numerals ? Object(__WEBPACK_IMPORTED_MODULE_2__formatNumerals__["a" /* default */])(locale.numerals) : __WEBPACK_IMPORTED_MODULE_6__identity__["a" /* default */],
      percent = locale.percent || "%";

  function newFormat(specifier) {
    specifier = Object(__WEBPACK_IMPORTED_MODULE_3__formatSpecifier__["a" /* default */])(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        type = specifier.type;

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = __WEBPACK_IMPORTED_MODULE_4__formatTypes__["a" /* default */][type],
        maybeSuffix = !type || /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision == null ? (type ? 6 : 12)
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Perform the initial formatting.
        var valueNegative = value < 0;
        value = formatType(Math.abs(value), precision);

        // If a negative value rounds to zero during formatting, treat as positive.
        if (valueNegative && +value === 0) valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + __WEBPACK_IMPORTED_MODULE_5__formatPrefixAuto__["b" /* prefixExponent */] / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer value part that can be
        // grouped, and fractional or exponential suffix part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = Object(__WEBPACK_IMPORTED_MODULE_3__formatSpecifier__["a" /* default */])(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(Object(__WEBPACK_IMPORTED_MODULE_0__exponent__["a" /* default */])(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
});


/***/ }),
/* 145 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = formatSpecifier;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__formatTypes__ = __webpack_require__(146);


// [[fill]align][sign][symbol][0][width][,][.precision][type]
var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  return new FormatSpecifier(specifier);
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);

  var match,
      fill = match[1] || " ",
      align = match[2] || ">",
      sign = match[3] || "-",
      symbol = match[4] || "",
      zero = !!match[5],
      width = match[6] && +match[6],
      comma = !!match[7],
      precision = match[8] && +match[8].slice(1),
      type = match[9] || "";

  // The "n" type is an alias for ",g".
  if (type === "n") comma = true, type = "g";

  // Map invalid types to the default format.
  else if (!__WEBPACK_IMPORTED_MODULE_0__formatTypes__["a" /* default */][type]) type = "";

  // If zero fill is specified, padding goes after sign and before digits.
  if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

  this.fill = fill;
  this.align = align;
  this.sign = sign;
  this.symbol = symbol;
  this.zero = zero;
  this.width = width;
  this.comma = comma;
  this.precision = precision;
  this.type = type;
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width == null ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
      + this.type;
};


/***/ }),
/* 146 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__formatDefault__ = __webpack_require__(225);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__formatPrefixAuto__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__formatRounded__ = __webpack_require__(226);




/* harmony default export */ __webpack_exports__["a"] = ({
  "": __WEBPACK_IMPORTED_MODULE_0__formatDefault__["a" /* default */],
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return Object(__WEBPACK_IMPORTED_MODULE_2__formatRounded__["a" /* default */])(x * 100, p); },
  "r": __WEBPACK_IMPORTED_MODULE_2__formatRounded__["a" /* default */],
  "s": __WEBPACK_IMPORTED_MODULE_1__formatPrefixAuto__["a" /* default */],
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
});


/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return prefixExponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__formatDecimal__ = __webpack_require__(23);


var prefixExponent;

/* harmony default export */ __webpack_exports__["a"] = (function(x, p) {
  var d = Object(__WEBPACK_IMPORTED_MODULE_0__formatDecimal__["a" /* default */])(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + Object(__WEBPACK_IMPORTED_MODULE_0__formatDecimal__["a" /* default */])(x, Math.max(0, p + i - 1))[0]; // less than 1y!
});


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rasterLayerHeatmapMixin;

var _utilsVega = __webpack_require__(15);

var _utils = __webpack_require__(3);

var MIN_AREA_IN_METERS = 30;
var EARTH_DIAMETER = 40075000;

function getPixelSize(neLat, width, zoom) {
  return Math.max(MIN_AREA_IN_METERS / (EARTH_DIAMETER * Math.cos(neLat * Math.PI / 180) / (width * Math.pow(2, zoom))), 1.0);
}

function getMarkHeight(type, width) {
  switch (type) {
    case "hex":
      return 2 * width / Math.sqrt(3.0);
    default:
      return width;
  }
}

function getMarkType(type) {
  switch (type) {
    case "hex":
      return "hexagon-horiz";
    default:
      return type;
  }
}

function rasterLayerHeatmapMixin(_layer) {
  var state = {};

  _layer.type = "heatmap";
  _layer.crossfilter = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);
  _layer.xDim = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);
  _layer.yDim = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);
  _layer.dynamicSize = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);
  _layer.dynamicBinning = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);
  _layer.colorDomain = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);
  _layer._mandatoryAttributes([]);

  _layer.setState = function (setterOrState) {
    if (typeof setterOrState === "function") {
      state = setterOrState(state);
    } else {
      state = setterOrState;
    }
  };

  _layer.getState = function () {
    return JSON.parse(JSON.stringify(state));
  };

  function getMarkSize(_ref) {
    var width = _ref.width,
        neLat = _ref.neLat,
        zoom = _ref.zoom;

    var pixelSize = state.encoding.size.type === "manual" ? state.encoding.size.value : getPixelSize(neLat, width, zoom);
    var numBinsX = Math.round(width / pixelSize);
    var markWidth = width / numBinsX;
    var markHeight = getMarkHeight(state.mark, markWidth);
    return {
      markWidth: markWidth,
      markHeight: markHeight
    };
  }

  _layer.genSQL = function (_ref2) {
    var table = _ref2.table,
        width = _ref2.width,
        height = _ref2.height,
        min = _ref2.min,
        max = _ref2.max,
        filter = _ref2.filter,
        globalFilter = _ref2.globalFilter,
        neLat = _ref2.neLat,
        zoom = _ref2.zoom;

    var _getMarkSize = getMarkSize({
      width: width,
      neLat: neLat,
      zoom: zoom
    }),
        markWidth = _getMarkSize.markWidth,
        markHeight = _getMarkSize.markHeight;

    var transforms = [];

    if (typeof filter === "string" && filter.length) {
      transforms.push({
        type: "filter",
        expr: filter
      });
    }

    if (typeof globalFilter === "string" && globalFilter.length) {
      transforms.push({
        type: "filter",
        expr: globalFilter
      });
    }

    return _utils.parser.writeSQL({
      type: "root",
      source: table,
      transform: [].concat(transforms, [{
        type: "pixel_bin",
        width: width,
        height: height,
        mark: {
          shape: state.mark,
          width: markWidth,
          height: markHeight
        },
        x: {
          field: "conv_4326_900913_x(" + state.encoding.x.field + ")",
          domain: [min[0], max[0]]
        },
        y: {
          field: "conv_4326_900913_y(" + state.encoding.y.field + ")",
          domain: [min[1], max[1]]
        },
        aggregate: state.encoding.color.aggregate
      }])
    });
  };

  function getColorScaleName(layerName) {
    return "heat_color" + layerName;
  }

  function usesAutoColors() {
    return state.encoding.color.scale.domain === "auto";
  }

  _layer._updateFromMetadata = function (metadata) {
    var layerName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

    if (usesAutoColors() && Array.isArray(metadata.scales)) {
      var colorScaleName = getColorScaleName(layerName);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = metadata.scales[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var scale = _step.value;

          if (scale.name === colorScaleName) {
            _layer.colorDomain(scale.domain);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  };

  _layer._genVega = function (_ref3) {
    var table = _ref3.table,
        width = _ref3.width,
        height = _ref3.height,
        min = _ref3.min,
        max = _ref3.max,
        filter = _ref3.filter,
        globalFilter = _ref3.globalFilter,
        neLat = _ref3.neLat,
        zoom = _ref3.zoom,
        _ref3$layerName = _ref3.layerName,
        layerName = _ref3$layerName === undefined ? "" : _ref3$layerName;

    var _getMarkSize2 = getMarkSize({
      width: width,
      neLat: neLat,
      zoom: zoom
    }),
        markWidth = _getMarkSize2.markWidth,
        markHeight = _getMarkSize2.markHeight;

    var datalayerName = "heatmap_query" + layerName;

    var autocolors = usesAutoColors();
    var getStatsLayerName = function getStatsLayerName() {
      return datalayerName + "_stats";
    };

    var vega = {
      width: width,
      height: height
    };

    vega.data = [{
      name: datalayerName,
      sql: _layer.genSQL({
        table: table,
        width: width,
        height: height,
        min: min,
        max: max,
        filter: filter,
        globalFilter: globalFilter,
        neLat: neLat,
        zoom: zoom
      })
    }];

    if (autocolors) {
      vega.data.push({
        name: getStatsLayerName(),
        source: datalayerName,
        transform: [{
          type: "aggregate",
          fields: ["color", "color", "color", "color"],
          ops: ["min", "max", "avg", "stddev"],
          as: ["minimum", "maximum", "mean", "deviation"]
        }, {
          type: "formula",
          expr: "max(minimum, mean-2*deviation)",
          as: "mincolor"
        }, {
          type: "formula",
          expr: "min(maximum, mean+2*deviation)",
          as: "maxcolor"
        }]
      });
    }

    var colorScaleName = getColorScaleName(layerName);
    vega.scales = [{
      name: colorScaleName,
      type: state.encoding.color.type,
      domain: autocolors ? { data: getStatsLayerName(), fields: ["mincolor", "maxcolor"] } : state.encoding.color.scale.domain,
      range: state.encoding.color.scale.range.map(function (c) {
        return (0, _utilsVega.adjustOpacity)(c, state.encoding.color.scale.opacity);
      }),
      default: (0, _utilsVega.adjustOpacity)(state.encoding.color.scale.default, state.encoding.color.scale.opacity),
      nullValue: (0, _utilsVega.adjustOpacity)(state.encoding.color.scale.nullValue, state.encoding.color.scale.opacity)
    }];

    vega.marks = [{
      type: "symbol",
      from: {
        data: datalayerName
      },
      properties: {
        shape: getMarkType(state.mark),
        xc: {
          field: "x"
        },
        yc: {
          field: "y"
        },
        width: markWidth,
        height: markHeight,
        fillColor: {
          scale: colorScaleName,
          field: "color"
        }
      }
    }];

    return vega;
  };

  _layer._destroyLayer = function () {
    var xDim = _layer.xDim();
    if (xDim) {
      xDim.dispose();
    }

    var yDim = _layer.yDim();
    if (yDim) {
      yDim.dispose();
    }
  };

  return _layer;
}

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = rasterLayerPointMixin;

var _core = __webpack_require__(2);

var _coreAsync = __webpack_require__(4);

var _utilsVega = __webpack_require__(15);

var _utils = __webpack_require__(3);

var _d = __webpack_require__(1);

var d3 = _interopRequireWildcard(_d);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var AUTOSIZE_DOMAIN_DEFAULTS = [100000, 0];
var AUTOSIZE_RANGE_DEFAULTS = [2.0, 5.0];
var AUTOSIZE_RANGE_MININUM = [1, 1];
var SIZING_THRESHOLD_FOR_AUTOSIZE_RANGE_MININUM = 1500000;

function validSymbol(type) {
  switch (type) {
    case "circle":
    case "cross":
    case "diamond":
    case "hexagon":
    case "square":
    case "triangle-down":
    case "triangle-left":
    case "triangle-right":
    case "triangle-up":
    case "hexagon-vert":
    case "hexagon-horiz":
      return true;
    default:
      return false;
  }
}

function getMarkType() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { point: {} };

  if (validSymbol(config.point.shape)) {
    return config.point.shape;
  } else {
    return "circle";
  }
}

function getSizing(sizeAttr, cap) {
  var lastFilteredSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : cap;
  var pixelRatio = arguments[3];
  var layerName = arguments[4];

  if (typeof sizeAttr === "number") {
    return sizeAttr;
  } else if ((typeof sizeAttr === "undefined" ? "undefined" : _typeof(sizeAttr)) === "object" && sizeAttr.type === "quantitative") {
    return {
      scale: layerName + "_size",
      field: "size"
    };
  } else if (sizeAttr === "auto") {
    var size = Math.min(lastFilteredSize, cap);
    var dynamicRScale = d3.scale.sqrt().domain(AUTOSIZE_DOMAIN_DEFAULTS).range(size > SIZING_THRESHOLD_FOR_AUTOSIZE_RANGE_MININUM ? AUTOSIZE_RANGE_MININUM : AUTOSIZE_RANGE_DEFAULTS).clamp(true);
    return Math.round(dynamicRScale(size) * pixelRatio);
  } else {
    return null;
  }
}

function getColor(color, layerName) {
  if ((typeof color === "undefined" ? "undefined" : _typeof(color)) === "object" && color.type === "density") {
    return {
      scale: layerName + "_fillColor",
      value: 0
    };
  } else if ((typeof color === "undefined" ? "undefined" : _typeof(color)) === "object" && (color.type === "ordinal" || color.type === "quantitative")) {
    return {
      scale: layerName + "_fillColor",
      field: "color"
    };
  } else if ((typeof color === "undefined" ? "undefined" : _typeof(color)) === "object") {
    return (0, _utilsVega.adjustOpacity)(color.value, color.opacity);
  } else {
    return color;
  }
}

function getTransforms(table, filter, globalFilter, _ref, lastFilteredSize) {
  var transform = _ref.transform,
      _ref$encoding = _ref.encoding,
      x = _ref$encoding.x,
      y = _ref$encoding.y,
      size = _ref$encoding.size,
      color = _ref$encoding.color;

  var transforms = [];

  if ((typeof transform === "undefined" ? "undefined" : _typeof(transform)) === "object" && _typeof(transform.groupby) === "object" && transform.groupby.length) {
    var fields = [x.field, y.field];
    var alias = ["x", "y"];
    var ops = [x.aggregate, y.aggregate];

    if ((typeof size === "undefined" ? "undefined" : _typeof(size)) === "object" && size.type === "quantitative") {
      fields.push(size.field);
      alias.push("size");
      ops.push(size.aggregate);
    }

    if ((typeof color === "undefined" ? "undefined" : _typeof(color)) === "object" && (color.type === "quantitative" || color.type === "ordinal")) {
      fields.push(color.field);
      alias.push("color");
      ops.push(color.aggregate);
    }

    transforms.push({
      type: "aggregate",
      fields: fields,
      ops: ops,
      as: alias,
      groupby: transform.groupby.map(function (g, i) {
        return {
          type: "project",
          expr: g,
          as: "key" + i
        };
      })
    });
  } else {
    transforms.push({
      type: "project",
      expr: x.field,
      as: "x"
    });
    transforms.push({
      type: "project",
      expr: y.field,
      as: "y"
    });

    if (typeof transform.limit === "number") {
      transforms.push({
        type: "limit",
        row: transform.limit
      });
      if (transform.sample) {
        transforms.push({
          type: "sample",
          method: "multiplicative",
          size: lastFilteredSize || transform.tableSize,
          limit: transform.limit
        });
      }
    }

    if ((typeof size === "undefined" ? "undefined" : _typeof(size)) === "object" && size.type === "quantitative") {
      transforms.push({
        type: "project",
        expr: size.field,
        as: "size"
      });
    }

    if ((typeof color === "undefined" ? "undefined" : _typeof(color)) === "object" && (color.type === "quantitative" || color.type === "ordinal")) {
      transforms.push({
        type: "project",
        expr: color.field,
        as: "color"
      });
    }

    transforms.push({
      type: "project",
      expr: table + ".rowid"
    });
  }

  if (typeof filter === "string" && filter.length) {
    transforms.push({
      type: "filter",
      expr: filter
    });
  }

  if (typeof globalFilter === "string" && globalFilter.length) {
    transforms.push({
      type: "filter",
      expr: globalFilter
    });
  }

  return transforms;
}

function getScales(_ref2, layerName) {
  var size = _ref2.size,
      color = _ref2.color;

  var scales = [];

  if ((typeof size === "undefined" ? "undefined" : _typeof(size)) === "object" && size.type === "quantitative") {
    scales.push({
      name: layerName + "_size",
      type: "linear",
      domain: size.domain,
      range: size.range,
      clamp: true
    });
  }

  if ((typeof color === "undefined" ? "undefined" : _typeof(color)) === "object" && color.type === "density") {
    scales.push({
      name: layerName + "_fillColor",
      type: "linear",
      domain: color.range.map(function (c, i) {
        return i * 100 / (color.range.length - 1) / 100;
      }),
      range: color.range.map(function (c) {
        return (0, _utilsVega.adjustOpacity)(c, color.opacity);
      }).map(function (c, i, colorArray) {
        var normVal = i / (colorArray.length - 1);
        var interp = Math.min(normVal / 0.65, 1.0);
        interp = interp * 0.375 + 0.625;
        return (0, _utilsVega.adjustRGBAOpacity)(c, interp);
      }),
      accumulator: "density",
      minDensityCnt: "-2ndStdDev",
      maxDensityCnt: "2ndStdDev",
      clamp: true
    });
  }

  if ((typeof color === "undefined" ? "undefined" : _typeof(color)) === "object" && color.type === "ordinal") {
    scales.push({
      name: layerName + "_fillColor",
      type: "ordinal",
      domain: color.domain,
      range: color.range.map(function (c) {
        return (0, _utilsVega.adjustOpacity)(c, color.opacity);
      }),
      default: (0, _utilsVega.adjustOpacity)(color.range[color.range.length - 1], color.opacity), // in current implementation 'Other' is always added as last element in the array
      nullValue: (0, _utilsVega.adjustOpacity)("#CACACA", color.opacity)
    });
  }

  if ((typeof color === "undefined" ? "undefined" : _typeof(color)) === "object" && color.type === "quantitative") {
    scales.push({
      name: layerName + "_fillColor",
      type: "quantize",
      domain: color.domain.map(function (c) {
        return (0, _utilsVega.adjustOpacity)(c, color.opacity);
      }),
      range: color.range,
      clamp: true
    });
  }

  return scales;
}

function rasterLayerPointMixin(_layer) {
  var state = null;

  _layer.setState = function (setter) {
    if (typeof setter === "function") {
      state = setter(state);
    } else {
      state = setter;
    }

    if (!state.hasOwnProperty("transform")) {
      state.transform = {};
    }

    return _layer;
  };

  _layer.getState = function () {
    return state;
  };

  _layer.getProjections = function () {
    return getTransforms("", "", "", state, (0, _coreAsync.lastFilteredSize)(_layer.crossfilter().getId())).filter(function (transform) {
      return transform.type === "project" && transform.hasOwnProperty("as");
    }).map(function (projection) {
      return _utils.parser.parseTransform({ select: [] }, projection);
    }).map(function (sql) {
      return sql.select[0];
    });
  };

  _layer.__genVega = function (_ref3) {
    var table = _ref3.table,
        filter = _ref3.filter,
        lastFilteredSize = _ref3.lastFilteredSize,
        globalFilter = _ref3.globalFilter,
        pixelRatio = _ref3.pixelRatio,
        layerName = _ref3.layerName;

    var size = getSizing(state.encoding.size, state.transform && state.transform.limit, lastFilteredSize, pixelRatio, layerName);

    var markType = getMarkType(state.config);

    return {
      data: [{
        name: layerName,
        sql: _utils.parser.writeSQL({
          type: "root",
          source: table,
          transform: getTransforms(table, filter, globalFilter, state, lastFilteredSize)
        })
      }],
      scales: getScales(state.encoding, layerName),
      marks: [{
        type: markType === "circle" ? "points" : "symbol",
        from: {
          data: layerName
        },
        properties: Object.assign({}, markType === "circle" ? {
          x: {
            scale: "x",
            field: "x"
          },
          y: {
            scale: "y",
            field: "y"
          },
          fillColor: getColor(state.encoding.color, layerName)
        } : {
          xc: {
            scale: "x",
            field: "x"
          },
          yc: {
            scale: "y",
            field: "y"
          },
          fillColor: getColor(state.encoding.color, layerName)
        }, markType === "circle" ? { size: size } : {
          shape: markType,
          width: size,
          height: size
        })
      }]
    };
  };

  _layer.xDim = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);
  _layer.yDim = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);

  // NOTE: builds _layer.defaultSize(), _layer.nullSize(),
  //              _layer.sizeScale(), & _layer.sizeAttr()
  (0, _utilsVega.createVegaAttrMixin)(_layer, "size", 3, 1, true);

  _layer.dynamicSize = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);

  _layer.xAttr = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);
  _layer.yAttr = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);

  var _point_wrap_class = "map-point-wrap";
  var _point_class = "map-point-new";
  var _point_gfx_class = "map-point-gfx";

  var _vega = null;
  var _scaledPopups = {};
  var _minMaxCache = {};
  var _cf = null;

  _layer.crossfilter = function (cf) {
    if (!arguments.length) {
      return _cf;
    }
    _cf = cf;
    return _layer;
  };

  _layer._requiresCap = function () {
    return false;
  };

  _layer.xRangeFilter = function (range) {
    if (!_layer.xDim()) {
      throw new Error("Must set layer's xDim before invoking xRange");
    }

    var xValue = _layer.xDim().value()[0];

    if (!arguments.length) {
      return _minMaxCache[xValue];
    }

    _minMaxCache[xValue] = range;
    return _layer;
  };

  _layer.yRangeFilter = function (range) {
    if (!_layer.yDim()) {
      throw new Error("Must set layer's yDim before invoking yRange");
    }

    var yValue = _layer.yDim().value()[0];

    if (!arguments.length) {
      return _minMaxCache[yValue];
    }

    _minMaxCache[yValue] = range;
    return _layer;
  };

  _layer._genVega = function (chart, layerName, group, query) {

    // needed to set LastFilteredSize when point map first initialized
    if (_layer.yDim()) {
      _layer.yDim().groupAll().valueAsync().then(function (value) {
        (0, _coreAsync.setLastFilteredSize)(_layer.crossfilter().getId(), value);
      });
    }

    _vega = _layer.__genVega({
      layerName: layerName,
      table: _layer.crossfilter().getTable()[0],
      filter: _layer.crossfilter().getFilterString(),
      globalFilter: _layer.crossfilter().getGlobalFilterString(),
      lastFilteredSize: (0, _coreAsync.lastFilteredSize)(_layer.crossfilter().getId()),
      pixelRatio: chart._getPixelRatio()
    });

    return _vega;
  };

  var renderAttributes = ["x", "y", "xc", "yc", "size", "width", "height", "fillColor"];

  _layer._addRenderAttrsToPopupColumnSet = function (chart, popupColumnsSet) {
    if (_vega && Array.isArray(_vega.marks) && _vega.marks.length > 0 && _vega.marks[0].properties) {
      renderAttributes.forEach(function (prop) {
        _layer._addQueryDrivenRenderPropToSet(popupColumnsSet, _vega.marks[0].properties, prop);
      });
    }
  };

  _layer._areResultsValidForPopup = function (results) {
    if (typeof results.x === "undefined" || typeof results.y === "undefined") {
      return false;
    } else {
      return true;
    }
  };

  _layer._displayPopup = function (chart, parentElem, data, width, height, margins, xscale, yscale, minPopupArea, animate) {
    var rndrProps = {};
    var queryRndrProps = new Set();
    if (_vega && Array.isArray(_vega.marks) && _vega.marks.length > 0 && _vega.marks[0].properties) {
      var propObj = _vega.marks[0].properties;
      renderAttributes.forEach(function (prop) {
        if (_typeof(propObj[prop]) === "object" && propObj[prop].field && typeof propObj[prop].field === "string") {
          rndrProps[prop] = propObj[prop].field;
          queryRndrProps.add(propObj[prop].field);
        }
      });
    }

    var xPixel = xscale(data[rndrProps.xc || rndrProps.x]) + margins.left;
    var yPixel = height - yscale(data[rndrProps.yc || rndrProps.y]) + margins.top;

    var sizeFromData = data[rndrProps.size || rndrProps.width || rndrProps.height];
    sizeFromData = Math.max(sizeFromData, 1); // size must be > 0 (#164)
    var dotSize = _layer.getSizeVal(sizeFromData);

    var scale = 1;
    var scaleRatio = minPopupArea / (dotSize * dotSize);
    var isScaled = scaleRatio > 1;
    if (isScaled) {
      scale = Math.sqrt(scaleRatio);
      dotSize = dotSize * scale;
    }

    var popupStyle = _layer.popupStyle();
    var bgColor = _layer.getFillColorVal(data[rndrProps.fillColor]);
    var strokeColor = void 0,
        strokeWidth = void 0;
    if ((typeof popupStyle === "undefined" ? "undefined" : _typeof(popupStyle)) === "object" && !isScaled) {
      bgColor = popupStyle.fillColor || bgColor;
      strokeColor = popupStyle.strokeColor;
      strokeWidth = popupStyle.strokeWidth;
    }

    var wrapDiv = parentElem.append("div").attr("class", _point_wrap_class);

    var pointDiv = wrapDiv.append("div").attr("class", _point_class).style({ left: xPixel + "px", top: yPixel + "px" });

    if (animate) {
      if (isScaled) {
        pointDiv.classed("popupPoint", true);
      } else {
        pointDiv.classed("fadeInPoint", true);
      }
    }

    _scaledPopups[chart] = isScaled;

    var gfxDiv = pointDiv.append("div").attr("class", _point_gfx_class).style("background", bgColor).style("width", dotSize + "px").style("height", dotSize + "px");

    if (strokeColor) {
      gfxDiv.style("border-color", strokeColor);
    }

    if (typeof strokeWidth === "number") {
      gfxDiv.style("border-width", strokeWidth);
    }

    return {
      rndrPropSet: queryRndrProps,
      bounds: [xPixel - dotSize / 2, xPixel + dotSize / 2, yPixel - dotSize / 2, yPixel + dotSize / 2]
    };
  };

  _layer._hidePopup = function (chart, hideCallback) {
    var mapPoint = chart.select("." + _point_class);
    if (mapPoint) {
      if (_scaledPopups[chart]) {
        mapPoint.classed("removePoint", true);
      } else {
        mapPoint.classed("fadeOutPoint", true);
      }

      if (hideCallback) {
        mapPoint.on("animationend", function () {
          hideCallback(chart);
        });
      }

      delete _scaledPopups[chart];
    }
  };

  _layer._destroyLayer = function (chart) {
    var xDim = _layer.xDim();
    if (xDim) {
      xDim.dispose();
    }

    var yDim = _layer.yDim();
    if (yDim) {
      yDim.dispose();
    }
  };

  return _layer;
}

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = rasterLayerPolyMixin;

var _utilsVega = __webpack_require__(15);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _events = __webpack_require__(9);

var _utils = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

// NOTE: Reqd until ST_Transform supported on projection columns
function conv4326To900913(x, y) {
  var transCoord = [0.0, 0.0];
  transCoord[0] = x * 111319.49077777777778;
  transCoord[1] = Math.log(Math.tan((90.0 + y) * 0.00872664625997)) * 6378136.99911215736947;
  return transCoord;
}

var vegaLineJoinOptions = ["miter", "round", "bevel"];
var polyTableGeomColumns = {
  // NOTE: the verts are interleaved x,y, so verts[0] = vert0.x, verts[1] = vert0.y, verts[2] = vert1.x, verts[3] = vert1.y, etc.
  verts: "mapd_geo_coords",
  ring_sizes: "mapd_geo_ring_sizes",
  poly_rings: "mapd_geo_poly_rings",
  // NOTE: legacy columns can be removed once pre-geo rendering is no longer used
  indices_LEGACY: "mapd_geo_indices",
  linedrawinfo_LEGACY: "mapd_geo_linedrawinfo",
  polydrawinfo_LEGACY: "mapd_geo_polydrawinfo"
};

function validateLineJoin(newLineJoin, currLineJoin) {
  if (typeof newLineJoin !== "string") {
    throw new Error("Line join must be a string and must be one of " + vegaLineJoinOptions.join(", "));
  }
  var lowCase = newLineJoin.toLowerCase();
  if (vegaLineJoinOptions.indexOf(lowCase) < 0) {
    throw new Error("Line join must be a string and must be one of " + vegaLineJoinOptions.join(", "));
  }
  return lowCase;
}

function validateMiterLimit(newMiterLimit, currMiterLimit) {
  if (typeof newMiterLimit !== "number") {
    throw new Error("Miter limit must be a number.");
  } else if (newMiterLimit < 0) {
    throw new Error("Miter limit must be >= 0");
  }
}

function rasterLayerPolyMixin(_layer) {
  _layer.crossfilter = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);
  _layer.filtersInverse = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, false);

  (0, _utilsVega.createVegaAttrMixin)(_layer, "lineJoin", vegaLineJoinOptions[0], vegaLineJoinOptions[0], false, {
    preDefault: validateLineJoin,
    preNull: validateLineJoin
  });

  (0, _utilsVega.createVegaAttrMixin)(_layer, "miterLimit", 10, 10, false, {
    preDefault: validateMiterLimit,
    preNull: validateMiterLimit
  });

  var state = null;
  var _vega = null;
  var _cf = null;

  var _scaledPopups = {};

  _layer.setState = function (setter) {
    if (typeof setter === "function") {
      state = setter(state);
    } else {
      state = setter;
    }

    if (!state.hasOwnProperty("transform")) {
      state.transform = {};
    }

    return _layer;
  };

  _layer.getState = function () {
    return state;
  };

  function getTransforms(_ref) {
    var filter = _ref.filter,
        globalFilter = _ref.globalFilter,
        _ref$layerFilter = _ref.layerFilter,
        layerFilter = _ref$layerFilter === undefined ? [] : _ref$layerFilter,
        filtersInverse = _ref.filtersInverse;

    var selfJoin = state.data[0].table === state.data[1].table;

    var groupby = {
      type: "project",
      expr: state.data[0].table + "." + state.data[0].attr,
      as: "key0"
    };

    var transforms = [{
      type: "rowid",
      table: state.data[1].table
    }, !selfJoin && {
      type: "filter",
      expr: state.data[0].table + "." + state.data[0].attr + " = " + state.data[1].table + "." + state.data[1].attr
    }, {
      type: "aggregate",
      fields: [layerFilter.length ? _utils.parser.parseExpression({
        type: "case",
        cond: [[{
          type: filtersInverse ? "not in" : "in",
          expr: state.data[0].table + "." + state.data[0].attr,
          set: layerFilter
        }, _utils.parser.parseExpression(state.encoding.color.aggregrate)]],
        else: null
      }) : _utils.parser.parseExpression(state.encoding.color.aggregrate)],
      ops: [null],
      as: ["color"],
      groupby: groupby
    }];

    if (typeof state.transform.limit === "number") {
      transforms.push({
        type: "limit",
        row: state.transform.limit
      });
    }

    if (typeof filter === "string" && filter.length) {
      transforms.push({
        type: "filter",
        expr: filter
      });
    }

    if (typeof globalFilter === "string" && globalFilter.length) {
      transforms.push({
        type: "filter",
        expr: globalFilter
      });
    }

    return transforms;
  }

  _layer.__genVega = function (_ref2) {
    var filter = _ref2.filter,
        globalFilter = _ref2.globalFilter,
        layerFilter = _ref2.layerFilter,
        filtersInverse = _ref2.filtersInverse,
        layerName = _ref2.layerName,
        useProjection = _ref2.useProjection;

    var colorRange = state.encoding.color.range.map(function (c) {
      return (0, _utilsVega.adjustOpacity)(c, state.encoding.color.opacity);
    });

    var data = [{
      name: layerName,
      format: "polys",
      sql: _utils.parser.writeSQL({
        type: "root",
        source: [].concat(_toConsumableArray(new Set(state.data.map(function (source) {
          return source.table;
        })))).join(", "),
        transform: getTransforms({
          filter: filter,
          globalFilter: globalFilter,
          layerFilter: layerFilter,
          filtersInverse: filtersInverse
        })
      })
    }];

    var scales = [{
      name: layerName + "_fillColor",
      type: "quantize",
      domain: state.encoding.color.domain,
      range: colorRange,
      nullValue: "rgba(214, 215, 214, 0.65)",
      default: "rgba(214, 215, 214, 0.65)"
    }];

    var marks = [{
      type: "polys",
      from: {
        data: layerName
      },
      properties: {
        x: {
          field: "x"
        },
        y: {
          field: "y"
        },
        fillColor: {
          scale: layerName + "_fillColor",
          field: "color"
        },
        strokeColor: _typeof(state.mark) === "object" ? state.mark.strokeColor : "white",
        strokeWidth: _typeof(state.mark) === "object" ? state.mark.strokeWidth : 0.5,
        lineJoin: _typeof(state.mark) === "object" ? state.mark.lineJoin : "miter",
        miterLimit: _typeof(state.mark) === "object" ? state.mark.miterLimit : 10
      }
    }];

    if (useProjection) {
      marks[0].transform = {
        projection: "mercator_map_projection"
      };
    } else {
      marks[0].properties.x.scale = "x";
      marks[0].properties.y.scale = "y";
    }

    return {
      data: data,
      scales: scales,
      marks: marks
    };
  };

  _layer._requiresCap = function () {
    // polys don't require a cap
    return false;
  };

  _layer._genVega = function (chart, layerName, group, query) {
    _vega = _layer.__genVega({
      layerName: layerName,
      filter: _layer.crossfilter().getFilterString(_layer.dimension().getDimensionIndex()),
      globalFilter: _layer.crossfilter().getGlobalFilterString(),
      layerFilter: _layer.filters(),
      filtersInverse: _layer.filtersInverse(),
      useProjection: chart._useGeoTypes
    });
    return _vega;
  };

  var renderAttributes = ["x", "y", "fillColor", "strokeColor", "strokeWidth", "lineJoin", "miterLimit"];

  _layer._addRenderAttrsToPopupColumnSet = function (chart, popupColsSet) {
    // add the poly geometry to the query
    popupColsSet.add(polyTableGeomColumns.verts);

    if (chart._useGeoTypes) {
      popupColsSet.add(polyTableGeomColumns.ring_sizes);
      popupColsSet.add(polyTableGeomColumns.poly_rings);
    } else {
      popupColsSet.add(polyTableGeomColumns.linedrawinfo_LEGACY);
    }

    if (_vega && Array.isArray(_vega.marks) && _vega.marks.length > 0 && _vega.marks[0].properties) {
      renderAttributes.forEach(function (rndrProp) {
        if (rndrProp !== "x" && rndrProp !== "y") {
          _layer._addQueryDrivenRenderPropToSet(popupColsSet, _vega.marks[0].properties, rndrProp);
        }
      });
    }
  };

  _layer._areResultsValidForPopup = function (results) {
    if (results[polyTableGeomColumns.verts] && results[polyTableGeomColumns.ring_sizes] || results[polyTableGeomColumns.verts] && results[polyTableGeomColumns.linedrawinfo_LEGACY]) {
      return true;
    }
    return false;
  };

  var _filtersArray = [];
  var _isInverseFilter = false;
  var polyLayerEvents = ["filtered"];
  var _listeners = _d2.default.dispatch.apply(_d2.default, polyLayerEvents);

  _layer.filter = function (key, isInverseFilter) {
    if (isInverseFilter !== _layer.filtersInverse()) {
      _layer.filterAll();
      _layer.filtersInverse(isInverseFilter);
    }
    if (_filtersArray.includes(key)) {
      _filtersArray = _filtersArray.filter(function (v) {
        return v !== key;
      });
    } else {
      _filtersArray = [].concat(_toConsumableArray(_filtersArray), [key]);
    }
    _filtersArray.length ? _layer.dimension().filterMulti(_filtersArray, undefined, isInverseFilter) : _layer.dimension().filterAll();
  };

  _layer.filters = function () {
    return _filtersArray;
  };

  _layer.filterAll = function () {
    _filtersArray = [];
  };

  _layer.on = function (event, listener) {
    _listeners.on(event, listener);
    return _layer;
  };

  _layer._displayPopup = function (chart, parentElem, data, width, height, margins, xscale, yscale, minPopupArea, animate) {
    var polys = [];

    // Only used for geotypes, but needs to be referenced when building the svg polystring
    var is_multi_ring_poly = [];

    // bounds: [minX, maxX, minY, maxY]
    var bounds = [Infinity, -Infinity, Infinity, -Infinity];
    if (chart._useGeoTypes) {
      // verts and ring_sizes should be valid as the _resultsAreValidForPopup()
      // method should've been called beforehand
      var verts = data[polyTableGeomColumns.verts];
      var ring_sizes = data[polyTableGeomColumns.ring_sizes];
      var poly_rings = data[polyTableGeomColumns.poly_rings];

      // It is possible that the poly rings column is not populated. If not populated, we have a single polygon with number of rings equal to the number of entries in the ring sizes column
      if (poly_rings === null) {
        poly_rings = [ring_sizes.length];
      }

      // TODO(croot): when the bounds is added as a column to the poly db table, we
      // can just use those bounds rather than build our own
      // But until then, we need to build our own bounds -- we use this to
      // find the reasonable center of the geom and scale from there when
      // necessary

      var processPoly = function processPoly(verts) {
        var polypts = [];
        for (var idx = 0; idx < verts.length; idx += 2) {
          var projectedCoord = conv4326To900913(verts[idx], verts[idx + 1]);

          var screenX = xscale(projectedCoord[0]) + margins.left;
          var screenY = height - yscale(projectedCoord[1]) - 1 + margins.top;

          if (screenX >= 0 && screenX <= width && screenY >= 0 && screenY <= height) {
            if (bounds[0] === Infinity) {
              bounds[0] = screenX;
              bounds[1] = screenX;
              bounds[2] = screenY;
              bounds[3] = screenY;
            } else {
              if (screenX < bounds[0]) {
                bounds[0] = screenX;
              } else if (screenX > bounds[1]) {
                bounds[1] = screenX;
              }

              if (screenY < bounds[2]) {
                bounds[2] = screenY;
              } else if (screenY > bounds[3]) {
                bounds[3] = screenY;
              }
            }
          }
          polypts.push(screenX);
          polypts.push(screenY);
        }
        return polypts;
      };

      // process each ring
      var ring_start = 0;
      var poly_count = 0;
      var poly_ring_idx = 0;
      for (var ring = 0; ring < ring_sizes.length; ring++) {
        var ring_slice = verts.slice(ring_start * 2, (ring_start + ring_sizes[ring]) * 2);

        var polypts = processPoly(ring_slice);

        if (poly_rings[poly_count] === 1) {
          polys.push(polypts);
          poly_count++;
          is_multi_ring_poly[poly_count] = false;
        } else {
          is_multi_ring_poly[poly_count] = true;
          if (poly_ring_idx === 0) {
            polys.push([polypts]);
          } else {
            polys[poly_count].push(polypts);
          }
          if (++poly_ring_idx === polys[poly_count]) {
            poly_count++;
            poly_ring_idx = 0;
          }
        }

        ring_start += ring_sizes[ring];
      }
    } else {
      // verts and drawinfo should be valid as the _resultsAreValidForPopup()
      // method should've been called beforehand
      var _verts = data[polyTableGeomColumns.verts];
      var drawinfo = data[polyTableGeomColumns.linedrawinfo_LEGACY];

      var startIdxDiff = drawinfo.length ? drawinfo[2] : 0;

      var FLT_MAX = 1e37;

      for (var i = 0; i < drawinfo.length; i = i + 4) {
        // Draw info struct:
        //     0: count,         // number of verts in loop -- might include 3 duplicate verts at end for closure
        //     1: instanceCount, // should always be 1
        //     2: firstIndex,    // the start index (includes x & y) where the verts for the loop start
        //     3: baseInstance   // irrelevant for our purposes -- should always be 0
        var _polypts = [];
        var count = (drawinfo[i] - 3) * 2; // include x&y, and drop 3 duplicated pts at the end
        var startIdx = (drawinfo[i + 2] - startIdxDiff) * 2; // include x&y
        var endIdx = startIdx + count; // remove the 3 duplicate pts at the end
        for (var idx = startIdx; idx < endIdx; idx = idx + 2) {
          if (_verts[idx] <= -FLT_MAX) {
            // -FLT_MAX is a separator for multi-polygons (like Hawaii,
            // where there would be a polygon per island), so when we hit a separator,
            // remove the 3 duplicate points that would end the polygon prior to the separator
            // and start a new polygon
            _polypts.pop();
            _polypts.pop();
            _polypts.pop();
            polys.push(_polypts);
            _polypts = [];
          } else {
            var screenX = xscale(_verts[idx]) + margins.left;
            var screenY = height - yscale(_verts[idx + 1]) - 1 + margins.top;

            if (screenX >= 0 && screenX <= width && screenY >= 0 && screenY <= height) {
              if (bounds[0] === Infinity) {
                bounds[0] = screenX;
                bounds[1] = screenX;
                bounds[2] = screenY;
                bounds[3] = screenY;
              } else {
                if (screenX < bounds[0]) {
                  bounds[0] = screenX;
                } else if (screenX > bounds[1]) {
                  bounds[1] = screenX;
                }

                if (screenY < bounds[2]) {
                  bounds[2] = screenY;
                } else if (screenY > bounds[3]) {
                  bounds[3] = screenY;
                }
              }
            }
            _polypts.push(screenX);
            _polypts.push(screenY);
          }
        }

        polys.push(_polypts);
      }
    }

    if (bounds[0] === Infinity) {
      bounds[0] = 0;
    }
    if (bounds[1] === -Infinity) {
      bounds[1] = width;
    }
    if (bounds[2] === Infinity) {
      bounds[2] = 0;
    }
    if (bounds[3] === -Infinity) {
      bounds[3] = height;
    }

    // NOTE: we could hit the case where the bounds is 0
    // if 1 point is visible in screen
    // Handle that here
    if (bounds[0] === bounds[1]) {
      bounds[0] = 0;
      bounds[1] = width;
    }
    if (bounds[2] === bounds[3]) {
      bounds[2] = 0;
      bounds[3] = height;
    }

    var rndrProps = {};
    var queryRndrProps = new Set([polyTableGeomColumns.verts, polyTableGeomColumns.ring_sizes]);
    if (_vega && Array.isArray(_vega.marks) && _vega.marks.length > 0 && _vega.marks[0].properties) {
      var propObj = _vega.marks[0].properties;
      renderAttributes.forEach(function (prop) {
        if (_typeof(propObj[prop]) === "object" && propObj[prop].field && typeof propObj[prop].field === "string") {
          rndrProps[prop] = propObj[prop].field;
          queryRndrProps.add(propObj[prop].field);
        }
      });
    }

    var boundsWidth = bounds[1] - bounds[0];
    var boundsHeight = bounds[3] - bounds[2];
    var scale = 1;
    var scaleRatio = minPopupArea / (boundsWidth * boundsHeight);
    var isScaled = scaleRatio > 1;
    if (isScaled) {
      scale = Math.sqrt(scaleRatio);
    }

    var popupStyle = _layer.popupStyle();
    var fillColor = _layer.getFillColorVal(data[rndrProps.fillColor]);
    var strokeColor = _layer.getStrokeColorVal(data[rndrProps.strokeColor]);
    var strokeWidth = void 0;
    if ((typeof popupStyle === "undefined" ? "undefined" : _typeof(popupStyle)) === "object" && !isScaled) {
      fillColor = popupStyle.fillColor || fillColor;
      strokeColor = popupStyle.strokeColor || strokeColor;
      strokeWidth = popupStyle.strokeWidth;
    }

    var svg = parentElem.append("svg").attr("width", width).attr("height", height);

    var xform = svg.append("g").attr("class", "map-poly-xform").attr("transform", "translate(" + (scale * bounds[0] - (scale - 1) * (bounds[0] + boundsWidth / 2)) + ", " + (scale * (bounds[2] + 1) - (scale - 1) * (bounds[2] + 1 + boundsHeight / 2)) + ")");

    var group = xform.append("g").attr("class", "map-poly").attr("transform-origin", boundsWidth / 2, boundsHeight / 2);

    if (typeof strokeWidth === "number") {
      group.style("stroke-width", strokeWidth);
    }

    if (animate) {
      if (isScaled) {
        group.classed("popupPoly", true);
      } else {
        group.classed("fadeInPoly", true);
      }
    }

    if (chart._useGeoTypes) {
      var ptsToSvgPath = function ptsToSvgPath(pts) {
        var pointStr = "";
        for (var _i = 0; _i < pts.length; _i = _i + 2) {
          pointStr = pointStr + (scale * (pts[_i] - bounds[0]) + " " + scale * (pts[_i + 1] - bounds[2]) + ", ");
        }
        return pointStr;
      };

      polys.forEach(function (pts, idx) {
        if (!pts) {
          return;
        }

        ptsToSvgPath(pts);

        var pointStr = "M ";
        if (is_multi_ring_poly[idx]) {
          // poly with multiple rings
          pts.forEach(function (ring) {
            pointStr += ptsToSvgPath(ring);
            pointStr += " z M ";
          });
          pointStr = pointStr.slice(0, pointStr.length - 3);
        } else {
          pointStr += ptsToSvgPath(pts);
        }
        pointStr = pointStr.slice(0, pointStr.length - 2).replace(/NaN/g, "");
        pointStr += "z";

        group.append("path").attr("d", pointStr).attr("class", "map-polygon-shape").attr("fill", fillColor).attr("fill-rule", "evenodd").attr("stroke", strokeColor).on("click", function () {
          return _layer.onClick(chart, data, _d2.default.event);
        });
      });
    } else {
      polys.forEach(function (pts) {
        if (!pts) {
          return;
        }

        var pointStr = "";
        for (var _i2 = 0; _i2 < pts.length; _i2 = _i2 + 2) {
          pointStr = pointStr + (scale * (pts[_i2] - bounds[0]) + " " + scale * (pts[_i2 + 1] - bounds[2]) + ", ");
        }
        pointStr = pointStr.slice(0, pointStr.length - 2).replace(/NaN/g, "");

        group.append("polygon").attr("points", pointStr).attr("class", "map-polygon-shape").on("click", function () {
          return _layer.onClick(chart, data, _d2.default.event);
        });
      });
    }

    _scaledPopups[chart] = isScaled;

    return {
      posX: bounds[0] + boundsWidth / 2,
      posY: bounds[2] + boundsHeight / 2,
      rndrPropSet: queryRndrProps,
      bounds: bounds
    };
  };

  _layer.onClick = function (chart, data, event) {
    if (!data) {
      return;
    }
    var isInverseFilter = Boolean(event && (event.metaKey || event.ctrlKey));

    chart.hidePopup();
    _events.events.trigger(function () {
      _layer.filter(data.key0, isInverseFilter);
      chart.filter(data.key0, isInverseFilter);
      _listeners.filtered(_layer, _filtersArray);
      chart.redrawGroup();
    });
  };

  _layer._hidePopup = function (chart, hideCallback) {
    var mapPoly = chart.select(".map-poly");
    if (mapPoly) {
      if (_scaledPopups[chart]) {
        mapPoly.classed("removePoly", true);
      } else {
        mapPoly.classed("fadeOutPoly", true);
        // mapPoly.attr('transform', 'scale(0, 0)');
      }

      if (hideCallback) {
        mapPoly.on("animationend", function () {
          hideCallback(chart);
        });
      }

      delete _scaledPopups[chart];
    }
  };

  _layer._destroyLayer = function (chart) {
    _layer.on("filtered", null);
    // deleteCanvas(chart)
  };

  return _layer;
}

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(152);

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["dc"] = __webpack_require__(154);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(153)))

/***/ }),
/* 153 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dc = undefined;

var _core = __webpack_require__(2);

var core = _interopRequireWildcard(_core);

var _coreAsync = __webpack_require__(4);

var coreAsync = _interopRequireWildcard(_coreAsync);

var _events = __webpack_require__(9);

var events = _interopRequireWildcard(_events);

var _filters = __webpack_require__(13);

var filters = _interopRequireWildcard(_filters);

var _utils = __webpack_require__(3);

var utils = _interopRequireWildcard(_utils);

var _logger = __webpack_require__(16);

var logger = _interopRequireWildcard(_logger);

var _errors = __webpack_require__(129);

var _bubbleOverlay = __webpack_require__(177);

var _bubbleOverlay2 = _interopRequireDefault(_bubbleOverlay);

var _barChart = __webpack_require__(182);

var _barChart2 = _interopRequireDefault(_barChart);

var _bubbleChart = __webpack_require__(185);

var _bubbleChart2 = _interopRequireDefault(_bubbleChart);

var _cloudChart = __webpack_require__(186);

var _cloudChart2 = _interopRequireDefault(_cloudChart);

var _compositeChart = __webpack_require__(187);

var _compositeChart2 = _interopRequireDefault(_compositeChart);

var _dataCount = __webpack_require__(188);

var _dataCount2 = _interopRequireDefault(_dataCount);

var _dataGrid = __webpack_require__(189);

var _dataGrid2 = _interopRequireDefault(_dataGrid);

var _geoChoroplethChart = __webpack_require__(190);

var _geoChoroplethChart2 = _interopRequireDefault(_geoChoroplethChart);

var _heatmap = __webpack_require__(198);

var _heatmap2 = _interopRequireDefault(_heatmap);

var _pieChart = __webpack_require__(199);

var _pieChart2 = _interopRequireDefault(_pieChart);

var _lineChart = __webpack_require__(200);

var _lineChart2 = _interopRequireDefault(_lineChart);

var _numberChart = __webpack_require__(201);

var _numberChart2 = _interopRequireDefault(_numberChart);

var _rasterChart = __webpack_require__(202);

var _rasterChart2 = _interopRequireDefault(_rasterChart);

var _rowChart = __webpack_require__(231);

var _rowChart2 = _interopRequireDefault(_rowChart);

var _scatterPlot = __webpack_require__(232);

var _scatterPlot2 = _interopRequireDefault(_scatterPlot);

var _mapdTable = __webpack_require__(233);

var _mapdTable2 = _interopRequireDefault(_mapdTable);

var _boxPlot = __webpack_require__(234);

var _boxPlot2 = _interopRequireDefault(_boxPlot);

var _countWidget = __webpack_require__(235);

var _countWidget2 = _interopRequireDefault(_countWidget);

var _asyncMixin = __webpack_require__(130);

var _asyncMixin2 = _interopRequireDefault(_asyncMixin);

var _baseMixin = __webpack_require__(5);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

var _bubbleMixin = __webpack_require__(18);

var _bubbleMixin2 = _interopRequireDefault(_bubbleMixin);

var _capMixin = __webpack_require__(10);

var _capMixin2 = _interopRequireDefault(_capMixin);

var _colorMixin = __webpack_require__(7);

var _colorMixin2 = _interopRequireDefault(_colorMixin);

var _coordinateGridMixin = __webpack_require__(11);

var _coordinateGridMixin2 = _interopRequireDefault(_coordinateGridMixin);

var _coordinateGridRasterMixin = __webpack_require__(139);

var _coordinateGridRasterMixin2 = _interopRequireDefault(_coordinateGridRasterMixin);

var _stackMixin = __webpack_require__(19);

var _stackMixin2 = _interopRequireDefault(_stackMixin);

var _marginMixin = __webpack_require__(12);

var _marginMixin2 = _interopRequireDefault(_marginMixin);

var _mapMixin = __webpack_require__(20);

var _mapMixin2 = _interopRequireDefault(_mapMixin);

var _rasterLayerHeatmapMixin = __webpack_require__(148);

var _rasterLayerHeatmapMixin2 = _interopRequireDefault(_rasterLayerHeatmapMixin);

var _rasterLayerPointMixin = __webpack_require__(149);

var _rasterLayerPointMixin2 = _interopRequireDefault(_rasterLayerPointMixin);

var _rasterLayerPolyMixin = __webpack_require__(150);

var _rasterLayerPolyMixin2 = _interopRequireDefault(_rasterLayerPolyMixin);

var _rasterLayer = __webpack_require__(236);

var _rasterLayer2 = _interopRequireDefault(_rasterLayer);

var _rasterMixin = __webpack_require__(237);

var _rasterMixin2 = _interopRequireDefault(_rasterMixin);

var _scatterMixin = __webpack_require__(140);

var _scatterMixin2 = _interopRequireDefault(_scatterMixin);

var _spinnerMixin = __webpack_require__(133);

var _spinnerMixin2 = _interopRequireDefault(_spinnerMixin);

var _legendContinuous = __webpack_require__(238);

var _legendContinuous2 = _interopRequireDefault(_legendContinuous);

var _legend = __webpack_require__(239);

var _legend2 = _interopRequireDefault(_legend);

var _dcLegendCont = __webpack_require__(241);

var _dcLegendCont2 = _interopRequireDefault(_dcLegendCont);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var errors = {
  Exception: _errors.Exception,
  InvalidStateException: _errors.InvalidStateException,
  BadArgumentException: _errors.BadArgumentException
};

var dc = exports.dc = {
  BadArgumentException: _errors.BadArgumentException,
  Exception: _errors.Exception,
  InvalidStateException: _errors.InvalidStateException,
  core: core,
  coreAsync: coreAsync,
  events: events,
  filters: filters,
  utils: utils,
  logger: logger,
  errors: errors,
  bubbleOverlay: _bubbleOverlay2.default,
  barChart: _barChart2.default,
  bubbleChart: _bubbleChart2.default,
  cloudChart: _cloudChart2.default,
  compositeChart: _compositeChart2.default,
  dataCount: _dataCount2.default,
  dataGrid: _dataGrid2.default,
  geoChoroplethChart: _geoChoroplethChart2.default,
  heatMap: _heatmap2.default,
  pieChart: _pieChart2.default,
  lineChart: _lineChart2.default,
  numberChart: _numberChart2.default,
  rasterChart: _rasterChart2.default,
  rowChart: _rowChart2.default,
  scatterPlot: _scatterPlot2.default,
  mapdTable: _mapdTable2.default,
  boxPlot: _boxPlot2.default,
  countWidget: _countWidget2.default,
  asyncMixin: _asyncMixin2.default,
  baseMixin: _baseMixin2.default,
  bubbleMixin: _bubbleMixin2.default,
  capMixin: _capMixin2.default,
  colorMixin: _colorMixin2.default,
  coordinateGridMixin: _coordinateGridMixin2.default,
  coordinateGridRasterMixin: _coordinateGridRasterMixin2.default,
  stackMixin: _stackMixin2.default,
  marginMixin: _marginMixin2.default,
  mapMixin: _mapMixin2.default,
  rasterLayerHeatmapMixin: _rasterLayerHeatmapMixin2.default,
  rasterLayerPointMixin: _rasterLayerPointMixin2.default,
  rasterLayerPolyMixin: _rasterLayerPolyMixin2.default,
  rasterLayer: _rasterLayer2.default,
  rasterMixin: _rasterMixin2.default,
  scatterMixin: _scatterMixin2.default,
  spinnerMixin: _spinnerMixin2.default,
  legendContinuous: _legendContinuous2.default,
  legend: _legend2.default,
  legendCont: _dcLegendCont2.default
};

/***/ }),
/* 155 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__parser_create_parser__ = __webpack_require__(8);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "createParser", function() { return __WEBPACK_IMPORTED_MODULE_0__parser_create_parser__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__create_data_graph__ = __webpack_require__(168);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "createDataGraph", function() { return __WEBPACK_IMPORTED_MODULE_1__create_data_graph__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__helpers_expression_builders__ = __webpack_require__(171);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "expr", function() { return __WEBPACK_IMPORTED_MODULE_2__helpers_expression_builders__; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__helpers_transform_builders__ = __webpack_require__(172);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "rel", function() { return __WEBPACK_IMPORTED_MODULE_3__helpers_transform_builders__; });
/**
 * The exported `mapd-data-layer` module. Consists of a graph constructor and
 * helper functions to build expressions and transforms and to parse them
 * @namespace API
 */









/***/ }),
/* 156 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseExpression;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__create_parser__ = __webpack_require__(8);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };



function parseExpression(expression) {
  var parser = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : __WEBPACK_IMPORTED_MODULE_0__create_parser__["b" /* default */];

  if (typeof expression === "string" || !(typeof expression === "undefined" ? "undefined" : _typeof(expression)) === "object") {
    return expression;
  }

  switch (expression.type) {
    case "=":
    case "<>":
    case "<":
    case ">":
    case "<=":
    case ">=":
      return expression.left + " " + expression.type + " " + (typeof expression.right === "string" ? "'" + expression.right + "'" : expression.right);
    case "between":
    case "not between":
      return expression.field + " " + expression.type.toUpperCase() + " " + expression.left + " AND " + expression.right;
    case "is null":
    case "is not null":
      return expression.field + " " + expression.type.toUpperCase();
    case "ilike":
    case "like":
    case "not like":
      return expression.left + " " + expression.type.toUpperCase() + " " + ("'%" + expression.right + "%'");
    case "coalesce":
      return "COALESCE(" + expression.values.map(function (field) {
        return "'" + field + "'";
      }).join(", ") + ")";
    case "in":
    case "not in":
      if (Array.isArray(expression.set)) {
        return expression.expr + " " + expression.type.toUpperCase() + " (" + expression.set.map(function (field) {
          return typeof field === "number" ? field : "'" + field + "'";
        }).join(", ") + ")";
      } else if (_typeof(expression.set) === "object" && (expression.set.type === "data" || expression.set.type === "root")) {
        return expression.expr + " " + expression.type.toUpperCase() + " (" + parser.writeSQL(expression.set) + ")";
      } else {
        return expression;
      }
    case "not":
      return "NOT(" + parseExpression(expression.expr) + ")";
    case "and":
    case "or":
      return "(" + parseExpression(expression.left) + " " + expression.type.toUpperCase() + " " + parseExpression(expression.right) + ")";
    case "case":
      return "CASE WHEN " + expression.cond.map(function (cond) {
        return parseExpression(cond[0]) + " THEN " + cond[1];
      }).join(" ") + (expression.else ? " ELSE '" + expression.else + "'" : "") + " END";
    case "date_trunc":
      return "date_trunc(" + expression.unit + ", " + expression.field + ")";
    case "extract":
      return "extract(" + expression.unit + " from " + expression.field + ")";
    case "root":
      return "(" + parser.writeSQL(expression) + ")";
    case "count":
      if (expression.distinct && expression.approx) {
        return "approx_count_distinct(" + expression.field + ")";
      } else if (expression.distinct) {
        return "count(distinct " + expression.field + " )";
      } else {
        return "count(" + expression.field + ")";
      }
    case "stddev":
    case "stddev_pop":
    case "stddev_samp":
    case "var_pop":
    case "var_samp":
      return expression.type + "(" + expression.x + ")";
    case "corr":
    case "covar_pop":
    case "covar_samp":
      return expression.type + "(" + expression.x + ", " + expression.y + ")";
    case "min":
    case "max":
    case "sum":
      return expression.type + "(" + expression.field + ")";
    case "average":
      return "avg(" + expression.field + ")";
    default:
      return expression;
  }
}

/***/ }),
/* 157 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseDataState;


function parseDataState(state, parser) {
  var initialSQL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    select: [],
    from: "",
    where: [],
    groupby: [],
    having: [],
    orderby: [],
    limit: "",
    offset: "",
    unresolved: {}
  };

  return state.transform.reduce(function (sql, t) {
    return parser.parseTransform(sql, t);
  }, {
    select: initialSQL.select,
    from: state.type === "root" ? typeof state.source === "string" ? state.source : parser.parseSource(state.source) : initialSQL.from,
    where: initialSQL.where,
    groupby: initialSQL.groupby,
    having: initialSQL.having,
    orderby: initialSQL.orderby,
    limit: initialSQL.limit,
    offset: initialSQL.offset,
    unresolved: initialSQL.unresolved
  });
}

/***/ }),
/* 158 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseTransform;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__parse_aggregate__ = __webpack_require__(159);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse_bin__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__parse_crossfilter__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__parse_sort__ = __webpack_require__(162);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__parse_limit__ = __webpack_require__(163);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__parse_filter__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__parse_project__ = __webpack_require__(164);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__parse_resolvefilter__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__parse_sample__ = __webpack_require__(166);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__parse_source__ = __webpack_require__(25);











function parseTransform(sql, t, parser) {
  switch (t.type) {
    case "aggregate":
      return Object(__WEBPACK_IMPORTED_MODULE_0__parse_aggregate__["a" /* default */])(sql, t, parser);
    case "bin":
      return Object(__WEBPACK_IMPORTED_MODULE_1__parse_bin__["a" /* default */])(sql, t);
    case "sort":
      return Object(__WEBPACK_IMPORTED_MODULE_3__parse_sort__["a" /* default */])(sql, t);
    case "limit":
      return Object(__WEBPACK_IMPORTED_MODULE_4__parse_limit__["a" /* default */])(sql, t);
    case "filter":
      return Object(__WEBPACK_IMPORTED_MODULE_5__parse_filter__["a" /* default */])(sql, t, parser);
    case "project":
      return Object(__WEBPACK_IMPORTED_MODULE_6__parse_project__["a" /* default */])(sql, t, parser);
    case "sample":
      return Object(__WEBPACK_IMPORTED_MODULE_8__parse_sample__["a" /* default */])(sql, t);
    case "resolvefilter":
      return Object(__WEBPACK_IMPORTED_MODULE_7__parse_resolvefilter__["a" /* default */])(sql, t);
    case "crossfilter":
      return Object(__WEBPACK_IMPORTED_MODULE_2__parse_crossfilter__["a" /* default */])(sql, t);
    /* istanbul ignore next */
    default:
      return sql;
  }
}

/***/ }),
/* 159 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseAggregate;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__create_parser__ = __webpack_require__(8);


var AGGREGATES = {
  average: "AVG",
  count: "COUNT",
  min: "MIN",
  max: "MAX",
  sum: "SUM"
};

function parseAggregate(sql, transform) {
  var parser = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : __WEBPACK_IMPORTED_MODULE_0__create_parser__["b" /* default */];

  if (Array.isArray(transform.groupby)) {
    transform.groupby.forEach(function (group) {
      sql = parseGroupBy(sql, group, parser);
    });
  } else {
    sql = parseGroupBy(sql, transform.groupby, parser);
  }

  transform.fields.forEach(function (field, index) {
    var as = transform.as[index];
    sql.select.push(aggregateField(transform.ops[index], field, as));
  });

  return sql;
}

function aggregateField(op, field, as) {
  var str = "";
  if (op === null) {
    str += field;
  } else if (AGGREGATES[op]) {
    str += AGGREGATES[op] + "(" + field + ")";
  } else {
    str += op + "(" + field + ")";
  }

  return str + ("" + (as ? " as " + as : ""));
}

function parseGroupBy(sql, groupby, parser) {
  if (typeof groupby === "string") {
    sql.select.push(groupby);
    sql.groupby.push(groupby);
  } else if (groupby.type === "bin") {
    sql = parser.parseTransform(sql, groupby);
    sql.groupby.push(groupby.as);
  } else if (groupby.type === "project") {
    sql.select.push(parser.parseExpression(groupby.expr) + (groupby.as ? " as " + groupby.as : ""));
    if (groupby.as) {
      sql.groupby.push(groupby.as);
    }
  }
  return sql;
}

/***/ }),
/* 160 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseBin;


function parseBin(sql, _ref) {
  var field = _ref.field,
      as = _ref.as,
      extent = _ref.extent,
      maxbins = _ref.maxbins;

  sql.select.push("cast((cast(" + field + " as float) - " + extent[0] + ") * " + maxbins / (extent[1] - extent[0]) + " as int) as " + as);
  sql.where.push("((" + field + " >= " + extent[0] + " AND " + field + " <= " + extent[1] + ") OR (" + field + " IS NULL))");
  sql.having.push("(" + as + " >= 0 AND " + as + " < " + maxbins + " OR " + as + " IS NULL)");
  return sql;
}

/***/ }),
/* 161 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseCrossfilter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__create_parser__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse_filter__ = __webpack_require__(24);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };




function parseCrossfilter(sql, transform) {
  var parser = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : __WEBPACK_IMPORTED_MODULE_0__create_parser__["b" /* default */];

  switch (transform.type) {
    case "crossfilter":
      if (_typeof(sql.unresolved) === "object") {
        if (sql.unresolved.hasOwnProperty(transform.signal)) {
          Object.keys(transform.filter).forEach(function (key) {
            var filter = transform.filter[key];
            if (sql.unresolved) {
              var ignore = sql.unresolved[transform.signal].ignore;

              if (Array.isArray(ignore) ? ignore.indexOf(key) === -1 : key !== ignore) {
                Object(__WEBPACK_IMPORTED_MODULE_1__parse_filter__["a" /* default */])(sql, filter, parser);
              }
            }
          });
        }
      }
    default:
      return sql;
  }
}

/***/ }),
/* 162 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseSort;


var ORDERINGS = {
  ascending: "ASC",
  descending: "DESC"
};


function parseSort(sql, transform) {
  transform.field.forEach(function (field, index) {
    sql.orderby.push(field + (Array.isArray(transform.order) ? " " + ORDERINGS[transform.order[index]] : ""));
  });
  return sql;
}

/***/ }),
/* 163 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseLimit;


function parseLimit(sql, transform) {
  sql.limit += transform.row;
  sql.offset += transform.offset || sql.offset;
  return sql;
}

/***/ }),
/* 164 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseProject;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__create_parser__ = __webpack_require__(8);



function parseProject(sql, transform) {
  var parser = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : __WEBPACK_IMPORTED_MODULE_0__create_parser__["b" /* default */];

  sql.select.push(parser.parseExpression(transform.expr) + (transform.as ? " as " + transform.as : ""));
  return sql;
}

/***/ }),
/* 165 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseResolvefilter;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function parseResolvefilter(sql, transform) {
  switch (transform.type) {
    case "resolvefilter":
      if (_typeof(sql.unresolved) === "object") {
        sql.unresolved[transform.filter.signal] = transform;
      } else {
        sql.unresolved = _defineProperty({}, transform.filter.signal, transform);
      }
    default:
      return sql;
  }
}

/***/ }),
/* 166 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = sample;


var GOLDEN_RATIO = 265445761;

var THIRTY_TWO_BITS = 4294967296;

function sample(sql, transform) {
  /* istanbul ignore else */
  if (transform.method === "multiplicative") {
    var size = transform.size,
        limit = transform.limit;

    var ratio = Math.min(limit / size, 1.0);
    if (ratio < 1) {
      var threshold = Math.floor(THIRTY_TWO_BITS * ratio);
      sql.where.push("MOD(" + sql.from + ".rowid * " + GOLDEN_RATIO + ", " + THIRTY_TWO_BITS + ") < " + threshold);
    }
  }

  return sql;
}

/***/ }),
/* 167 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = writeSQL;
/* harmony export (immutable) */ __webpack_exports__["b"] = write;


function writeSQL(state, parser) {
  return write(parser.parseDataState(state));
}


function write(sql) {
  return writeSelect(sql.select) + writeFrom(sql.from) + writeWhere(sql.where) + writeGroupby(sql.groupby) + writeHaving(sql.having) + writeOrderBy(sql.orderby) + writeLimit(sql.limit) + writeOffset(sql.offset);
}

function writeSelect(select) {
  return select.length ? "SELECT " + select.join(", ") : "SELECT *";
}

function writeFrom(from) {
  return " FROM " + from;
}

function writeWhere(where) {
  return where.length ? " WHERE " + where.join(" AND ") : "";
}

function writeGroupby(groupby) {
  return groupby.length ? " GROUP BY " + groupby.join(", ") : "";
}

function writeHaving(having) {
  return having.length ? " HAVING " + having.join(" AND ") : "";
}

function writeOrderBy(orderby) {
  return orderby.length ? " ORDER BY " + orderby.join(", ") : "";
}

function writeLimit(limit) {
  return limit.length ? " LIMIT " + limit : "";
}

function writeOffset(offset) {
  return offset.length ? " OFFSET " + offset : "";
}

/***/ }),
/* 168 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = createDataGraph;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__create_data_node__ = __webpack_require__(169);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parser_create_parser__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_invariant__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_invariant__);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };





/**
 * Creates a data graph instance. Must pass in a connector object that implements a query method.
 * @see {@link Graph} for further information.
 * @memberof API
 */
function createDataGraph(connector) {
  __WEBPACK_IMPORTED_MODULE_2_invariant___default()(typeof connector.query === "function", "invalid connector");

  var context = {
    connector: connector,
    parser: Object(__WEBPACK_IMPORTED_MODULE_1__parser_create_parser__["a" /* createParser */])()
  };

  var childNodes = [];

  /**
   * An instance of a data graph. A data graph is basically a tree, where each
   * node represents a
   * @namespace Graph
   */
  var graphAPI = {
    registerParser: registerParser,
    children: children,
    data: data
  };

  /**
   * Registers a custom expression or transform parser. The `typeDef` argument
   * must be a valid type definition and the `typeParser` argument must be a
   * function that matches the type of an ExpressionParser or TransformParser
   * @see {@link https://github.com/mapd/mapd-data-layer/tree/master/src/parser/createParser.js|createParser.js}
   * @memberof Graph
   * @inner
   */
  function registerParser(typeDef, typeParser) {
    context.parser.registerParser(typeDef, typeParser);
  }

  /**
   * Returns all child data node instances of the graph.
   * @memberof Graph
   * @inner
   */
  function children() {
    return childNodes;
  }

  /**
   * Creates a root data node instance. The source must be specific in the
   * initial state. An example of a source, is a string pointing to a tables
   * or an array of source transformations.
   * @memberof Graph
   * @inner
   */
  function data(state) {
    var dataNode = Object(__WEBPACK_IMPORTED_MODULE_0__create_data_node__["a" /* default */])(context, typeof state === "string" || Array.isArray(state) ? { source: state, type: "root" } : _extends({}, state, { type: "root" }));
    childNodes.push(dataNode);
    return dataNode;
  }

  return graphAPI;
}

/***/ }),
/* 169 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = createDataNode;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_invariant__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(170);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };




function createDataNode(context) {
  var initialState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var state = {
    type: initialState.type || "data",
    source: initialState.source,
    transform: initialState.transform || [],
    children: initialState.children || []
  };

  /**
   * A node in the graph that represents a set of data transformations.
   * @namespace Data
   * @see {@link https://github.com/mapd/mapd-data-layer/tree/master/src/create-data-node.js|create-data-node.js}
   */
  var dataNodeAPI = {
    getState: getState,
    transform: transform,
    toSQL: toSQL,
    values: values,
    data: data
  };

  /**
   * Returns the state of the data node.
   * @memberof Data
   * @inner
   */
  function getState() {
    return state;
  }

  /**
   * Sets the transform state of the data node. Either takes in an array of
   * transforms or a function that takes and returns an array of transforms
   * @memberof Data
   * @inner
   */
  function transform(setter) {
    state.transform = typeof setter === "function" ? setter(state.transform) : setter;
    return dataNodeAPI;
  }

  /**
   * Returns the SQL string representation of the set of transforms from
   * the node instance to its source root in the graph
   * @memberof Data
   * @inner
   */
  function toSQL() {
    return context.parser.write(Object(__WEBPACK_IMPORTED_MODULE_1__utils__["a" /* reduceToSQL */])(context, dataNodeAPI));
  }

  /**
   * Uses the `connector` in the graph context to execute data node's
   * SQL query representation and returns queried data as a promise.
   * @memberof Data
   * @inner
   */
  function values() {
    return context.connector.query(context.parser.write(Object(__WEBPACK_IMPORTED_MODULE_1__utils__["a" /* reduceToSQL */])(context, dataNodeAPI)));
  }

  /**
   * Creates a data node instance and sets it as a child of the parent.
   * @memberof Data
   * @inner
   */
  function data(childState) {
    var dataNode = createDataNode(context, _extends({}, childState, {
      source: dataNodeAPI
    }));
    state.children.push(dataNode);
    return dataNode;
  }

  return dataNodeAPI;
}

/***/ }),
/* 170 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export traverse */
/* harmony export (immutable) */ __webpack_exports__["a"] = reduceToSQL;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var identity = function identity(a) {
  return a;
};


function traverse(node, iterator, xform, accum) {
  accum = xform(accum, iterator(node));
  var source = node.getState().source;
  return (typeof source === "undefined" ? "undefined" : _typeof(source)) === "object" && !Array.isArray(source) ? traverse(source, iterator, xform, accum) : accum;
}

function reduceToSQL(context, node) {
  var initialSQL = {
    select: [],
    from: "",
    where: [],
    groupby: [],
    having: [],
    orderby: [],
    limit: "",
    offset: "",
    unresolved: {}
  };

  function toSQL(accum, rightNode) {
    return context.parser.parseDataState(rightNode.getState(), accum);
  }

  return traverse(node, identity, toSQL, initialSQL);
}

/***/ }),
/* 171 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["alias"] = alias;
/* harmony export (immutable) */ __webpack_exports__["avg"] = avg;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["sum"] = sum;
/* harmony export (immutable) */ __webpack_exports__["count"] = count;
/* harmony export (immutable) */ __webpack_exports__["approxCount"] = approxCount;
/* harmony export (immutable) */ __webpack_exports__["countStar"] = countStar;
/* harmony export (immutable) */ __webpack_exports__["extract"] = extract;
/* harmony export (immutable) */ __webpack_exports__["dateTrunc"] = dateTrunc;
/* harmony export (immutable) */ __webpack_exports__["inExpr"] = inExpr;
/* harmony export (immutable) */ __webpack_exports__["not"] = not;
/* harmony export (immutable) */ __webpack_exports__["caseExpr"] = caseExpr;
/* harmony export (immutable) */ __webpack_exports__["between"] = between;


/**
 * Creates an alias expression
 * @memberof Expression
 */
function alias(as, expr) {
  return {
    expr: expr,
    as: as
  };
}

/**
 * Creates an average expression
 * @memberof Expression
 */

/**
 * Expression builders. These are helper functions to create expression objects
 * @name expr
 * @memberof API
 * @see {@link Expression}
 */

/**
 * Expression builder module.
 * @name Expression
 * @see {@link https://github.com/mapd/mapd-data-layer/tree/master/src/types/expression-type.js|Expression Types}
 */
function avg(alias, field) {
  return {
    type: "average",
    field: field,
    as: alias
  };
}

/**
 * creates a min expression
 * @memberof Expression
 */
function min(alias, field) {
  return {
    type: "min",
    field: field,
    as: alias
  };
}

/**
 * creates a max expression
 * @memberof Expression
 */
function max(alias, field) {
  return {
    type: "max",
    field: field,
    as: alias
  };
}

/**
 * creates a sum expression
 * @memberof Expression
 */
function sum(alias, field) {
  return {
    type: "sum",
    field: field,
    as: alias
  };
}

/**
 * creates a count expression
 * @memberof Expression
 */
function count(distinct, alias, field) {
  return {
    type: "count",
    distinct: distinct,
    approx: false,
    field: field,
    as: alias
  };
}

/**
 * creates an approx count expression
 * @memberof Expression
 */
function approxCount(distinct, alias, field) {
  return {
    type: "count",
    distinct: distinct,
    approx: true,
    field: field,
    as: alias
  };
}

/**
 * creates a count star expression
 * @memberof Expression
 */
function countStar(alias) {
  return {
    type: "count",
    distinct: false,
    approx: false,
    field: "*",
    as: alias
  };
}

/**
 * creates an extract function expression
 * @memberof Expression
 */
function extract(unit, field) {
  return {
    type: "extract",
    unit: unit,
    field: field
  };
}

/**
 * creates a date_trunc function expression
 * @memberof Expression
 */
function dateTrunc(unit, field) {
  return {
    type: "date_trunc",
    unit: unit,
    field: field
  };
}

/**
 * creates an in expression
 * @memberof Expression
 */
function inExpr(expr, set) {
  return {
    type: "in",
    expr: expr,
    set: set
  };
}

/**
 * Creates a not expression
 * @memberof Expression
 */
function not(expr) {
  return {
    type: "not",
    expr: expr
  };
}

/**
 * Creates a case expression
 * @memberof Expression
 */
function caseExpr(cond, end) {
  return {
    type: "case",
    cond: cond,
    else: end
  };
}

/**
 * Creates a between expression
 * @memberof Expression
 */
function between(field, range) {
  return {
    type: "between",
    field: field,
    left: range[0],
    right: range[1]
  };
}

/***/ }),
/* 172 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["project"] = project;
/* harmony export (immutable) */ __webpack_exports__["aggregate"] = aggregate;
/* harmony export (immutable) */ __webpack_exports__["filter"] = filter;
/* harmony export (immutable) */ __webpack_exports__["filterRange"] = filterRange;
/* harmony export (immutable) */ __webpack_exports__["filterIn"] = filterIn;
/* harmony export (immutable) */ __webpack_exports__["bin"] = bin;
/* harmony export (immutable) */ __webpack_exports__["limit"] = limit;
/* harmony export (immutable) */ __webpack_exports__["sort"] = sort;
/* harmony export (immutable) */ __webpack_exports__["top"] = top;
/* harmony export (immutable) */ __webpack_exports__["bottom"] = bottom;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Creates a Project transform
 * @memberof Transform
 */
function project(expr) {
  // $FlowFixMe
  return {
    type: "project",
    expr: typeof expr === "string" ? expr : expr.expr,
    as: typeof expr === "string" ? null : expr.as
  };
}
/**
 * Transform builders. These are helpers function to create transform objects.
 * @name rel
 * @memberof API
 * @see {@link #transform-1|Transform}
 */

/**
 * Transsform builder module.
 * @name Transform
 * @see {@link https://github.com/mapd/mapd-data-layer/tree/master/src/types/transform-type.js|Transform Types}
 */


function getAggs(agg) {
  if (Array.isArray(agg)) {
    return {
      fields: agg.map(function (a) {
        return a.field;
      }),
      ops: agg.map(function (a) {
        return a.type;
      }),
      // $FlowFixMe
      as: agg.map(function (a) {
        return a.as;
      })
    };
  } else {
    return {
      fields: [agg.field],
      ops: [agg.type],
      as: [agg.as || ""]
    };
  }
}

function getGroupBy(groupby) {
  if (Array.isArray(groupby)) {
    return groupby.map(function (group) {
      if ((typeof group === "undefined" ? "undefined" : _typeof(group)) === "object") {
        return {
          type: "project",
          expr: group.expr,
          as: group.as
        };
      } else {
        return group;
      }
    });
  } else if ((typeof groupby === "undefined" ? "undefined" : _typeof(groupby)) === "object") {
    return {
      type: "project",
      expr: groupby.expr,
      as: groupby.as
    };
  } else {
    return groupby;
  }
}

/**
 * Creates an Aggregate transform
 * @memberof Transform
 */
function aggregate(groupby, agg) {
  var aggs = getAggs(agg);
  var group = getGroupBy(groupby);
  return {
    type: "aggregate",
    fields: aggs.fields,
    ops: aggs.ops,
    as: aggs.as,
    groupby: group
  };
}

/**
 * Creates an Filter transform
 * @memberof Transform
 */
function filter(expr) {
  var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

  return {
    type: "filter",
    id: id,
    expr: expr
  };
}

/**
 * Creates an Filter transform that uses a between expression
 * @memberof Transform
 */
function filterRange(field, range) {
  var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

  return {
    type: "filter",
    id: id,
    expr: {
      type: "between",
      field: field,
      left: range[0],
      right: range[1]
    }
  };
}

/**
 * Creates an Filter transform that uses an in expression
 * @memberof Transform
 */
function filterIn(field, set) {
  var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

  return {
    type: "filter",
    id: id,
    expr: {
      type: "in",
      expr: field,
      set: set
    }
  };
}

/**
 * Creates a Bin tranform
 * @memberof Transform
 */
function bin(alias, field, extent, maxbins) {
  return {
    type: "bin",
    field: field,
    extent: extent,
    maxbins: maxbins,
    as: alias
  };
}

/**
 * Creates a Limit transform
 * @memberof Transform
 */
function limit(row, offset) {
  return {
    type: "limit",
    row: row,
    offset: offset
  };
}

/**
 * Creates a Sort transform
 * @memberof Transform
 */
function sort(field, order) {
  return {
    type: "sort",
    field: typeof field === "string" ? [field] : field,
    order: typeof order === "string" ? [order] : order
  };
}

/**
 * Creates a Sort transform ordered by descending and a Limit transform
 * @memberof Transform
 */
function top(field, limit, offset) {
  return [{
    type: "sort",
    field: [field],
    order: ["descending"]
  }, {
    type: "limit",
    row: limit,
    offset: offset
  }];
}

/**
* Creates a Sort transform ordered by ascending and a Limit transform
 * @memberof Transform
 */
function bottom(field, limit, offset) {
  return [{
    type: "sort",
    field: [field],
    order: ["ascending"]
  }, {
    type: "limit",
    row: limit,
    offset: offset
  }];
}

/***/ }),
/* 173 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./af": 28,
	"./af.js": 28,
	"./ar": 29,
	"./ar-ma": 30,
	"./ar-ma.js": 30,
	"./ar-sa": 31,
	"./ar-sa.js": 31,
	"./ar-tn": 32,
	"./ar-tn.js": 32,
	"./ar.js": 29,
	"./az": 33,
	"./az.js": 33,
	"./be": 34,
	"./be.js": 34,
	"./bg": 35,
	"./bg.js": 35,
	"./bn": 36,
	"./bn.js": 36,
	"./bo": 37,
	"./bo.js": 37,
	"./br": 38,
	"./br.js": 38,
	"./bs": 39,
	"./bs.js": 39,
	"./ca": 40,
	"./ca.js": 40,
	"./cs": 41,
	"./cs.js": 41,
	"./cv": 42,
	"./cv.js": 42,
	"./cy": 43,
	"./cy.js": 43,
	"./da": 44,
	"./da.js": 44,
	"./de": 45,
	"./de-at": 46,
	"./de-at.js": 46,
	"./de.js": 45,
	"./dv": 47,
	"./dv.js": 47,
	"./el": 48,
	"./el.js": 48,
	"./en-au": 49,
	"./en-au.js": 49,
	"./en-ca": 50,
	"./en-ca.js": 50,
	"./en-gb": 51,
	"./en-gb.js": 51,
	"./en-ie": 52,
	"./en-ie.js": 52,
	"./en-nz": 53,
	"./en-nz.js": 53,
	"./eo": 54,
	"./eo.js": 54,
	"./es": 55,
	"./es.js": 55,
	"./et": 56,
	"./et.js": 56,
	"./eu": 57,
	"./eu.js": 57,
	"./fa": 58,
	"./fa.js": 58,
	"./fi": 59,
	"./fi.js": 59,
	"./fo": 60,
	"./fo.js": 60,
	"./fr": 61,
	"./fr-ca": 62,
	"./fr-ca.js": 62,
	"./fr-ch": 63,
	"./fr-ch.js": 63,
	"./fr.js": 61,
	"./fy": 64,
	"./fy.js": 64,
	"./gd": 65,
	"./gd.js": 65,
	"./gl": 66,
	"./gl.js": 66,
	"./he": 67,
	"./he.js": 67,
	"./hi": 68,
	"./hi.js": 68,
	"./hr": 69,
	"./hr.js": 69,
	"./hu": 70,
	"./hu.js": 70,
	"./hy-am": 71,
	"./hy-am.js": 71,
	"./id": 72,
	"./id.js": 72,
	"./is": 73,
	"./is.js": 73,
	"./it": 74,
	"./it.js": 74,
	"./ja": 75,
	"./ja.js": 75,
	"./jv": 76,
	"./jv.js": 76,
	"./ka": 77,
	"./ka.js": 77,
	"./kk": 78,
	"./kk.js": 78,
	"./km": 79,
	"./km.js": 79,
	"./ko": 80,
	"./ko.js": 80,
	"./ky": 81,
	"./ky.js": 81,
	"./lb": 82,
	"./lb.js": 82,
	"./lo": 83,
	"./lo.js": 83,
	"./lt": 84,
	"./lt.js": 84,
	"./lv": 85,
	"./lv.js": 85,
	"./me": 86,
	"./me.js": 86,
	"./mk": 87,
	"./mk.js": 87,
	"./ml": 88,
	"./ml.js": 88,
	"./mr": 89,
	"./mr.js": 89,
	"./ms": 90,
	"./ms-my": 91,
	"./ms-my.js": 91,
	"./ms.js": 90,
	"./my": 92,
	"./my.js": 92,
	"./nb": 93,
	"./nb.js": 93,
	"./ne": 94,
	"./ne.js": 94,
	"./nl": 95,
	"./nl.js": 95,
	"./nn": 96,
	"./nn.js": 96,
	"./pa-in": 97,
	"./pa-in.js": 97,
	"./pl": 98,
	"./pl.js": 98,
	"./pt": 99,
	"./pt-br": 100,
	"./pt-br.js": 100,
	"./pt.js": 99,
	"./ro": 101,
	"./ro.js": 101,
	"./ru": 102,
	"./ru.js": 102,
	"./se": 103,
	"./se.js": 103,
	"./si": 104,
	"./si.js": 104,
	"./sk": 105,
	"./sk.js": 105,
	"./sl": 106,
	"./sl.js": 106,
	"./sq": 107,
	"./sq.js": 107,
	"./sr": 108,
	"./sr-cyrl": 109,
	"./sr-cyrl.js": 109,
	"./sr.js": 108,
	"./ss": 110,
	"./ss.js": 110,
	"./sv": 111,
	"./sv.js": 111,
	"./sw": 112,
	"./sw.js": 112,
	"./ta": 113,
	"./ta.js": 113,
	"./te": 114,
	"./te.js": 114,
	"./th": 115,
	"./th.js": 115,
	"./tl-ph": 116,
	"./tl-ph.js": 116,
	"./tlh": 117,
	"./tlh.js": 117,
	"./tr": 118,
	"./tr.js": 118,
	"./tzl": 119,
	"./tzl.js": 119,
	"./tzm": 120,
	"./tzm-latn": 121,
	"./tzm-latn.js": 121,
	"./tzm.js": 120,
	"./uk": 122,
	"./uk.js": 122,
	"./uz": 123,
	"./uz.js": 123,
	"./vi": 124,
	"./vi.js": 124,
	"./x-pseudo": 125,
	"./x-pseudo.js": 125,
	"./zh-cn": 126,
	"./zh-cn.js": 126,
	"./zh-tw": 127,
	"./zh-tw.js": 127
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 174;

/***/ }),
/* 175 */
/***/ (function(module, exports) {

exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}


/***/ }),
/* 176 */
/***/ (function(module, exports) {

var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = bubbleOverlay;

var _core = __webpack_require__(2);

var _coreAsync = __webpack_require__(4);

var _baseMixin = __webpack_require__(5);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

var _bubbleMixin = __webpack_require__(18);

var _bubbleMixin2 = _interopRequireDefault(_bubbleMixin);

var _capMixin = __webpack_require__(10);

var _capMixin2 = _interopRequireDefault(_capMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _utils = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The bubble overlay chart is quite different from the typical bubble chart. With the bubble overlay
 * chart you can arbitrarily place bubbles on an existing svg or bitmap image, thus changing the
 * typical x and y positioning while retaining the capability to visualize data using bubble radius
 * and coloring.
 *
 * @name bubbleOverlay
 * @memberof dc
 * @mixes dc.bubbleMixin
 * @mixes dc.baseMixin
 * @example
 * // create a bubble overlay chart on top of the '#chart-container1 svg' element using the default global chart group
 * var bubbleChart1 = dc.bubbleOverlayChart('#chart-container1').svg(d3.select('#chart-container1 svg'));
 * // create a bubble overlay chart on top of the '#chart-container2 svg' element using chart group A
 * var bubbleChart2 = dc.compositeChart('#chart-container2', 'chartGroupA').svg(d3.select('#chart-container2 svg'));
 * @param {String|node|d3.selection} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector} specifying
 * a dom block element such as a div; or a dom element or d3 selection.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
 * Interaction with a chart will only trigger events and redraws within the chart's group.
 * @return {dc.bubbleOverlay}
 */
function bubbleOverlay(parent, chartGroup) {
  var BUBBLE_OVERLAY_CLASS = "bubble-overlay";

  /* OVERRIDE -----------------------------------------------------------------*/
  var BUBBLE_POPUP_CLASS = "bubble-popup";
  /* --------------------------------------------------------------------------*/

  var BUBBLE_NODE_CLASS = "node";
  var BUBBLE_CLASS = "bubble";

  /**
   * **mandatory**
   *
   * Set the underlying svg image element. Unlike other dc charts this chart will not generate a svg
   * element; therefore the bubble overlay chart will not work if this function is not invoked. If the
   * underlying image is a bitmap, then an empty svg will need to be created on top of the image.
   * @name svg
   * @memberof dc.bubbleOverlay
   * @instance
   * @example
   * // set up underlying svg element
   * chart.svg(d3.select('#chart svg'));
   * @param {SVGElement|d3.selection} [imageElement]
   * @return {dc.bubbleOverlay}
   */

  /* OVERRIDE -----------------------------------------------------------------*/
  var _chart = (0, _bubbleMixin2.default)((0, _capMixin2.default)((0, _baseMixin2.default)({})));
  /* --------------------------------------------------------------------------*/

  var _g = void 0;
  var _points = [];

  /* OVERRIDE EXTEND ----------------------------------------------------------*/
  var _colorCountUpdateCallback = null;
  var _clickCallbackFunc = null;
  var _sampling = false;

  _chart.MIN_RADIUS = 2;
  _chart.MAX_RADIUS = 10;

  _chart.scaleRadius = false;

  _chart.colorCountDictionary = {};

  _chart.clickCallback = function (_) {
    if (!arguments.length) {
      return _clickCallbackFunc;
    }
    _clickCallbackFunc = _;
    return _chart;
  };

  _chart.transitionDuration(0);
  /* --------------------------------------------------------------------------*/

  _chart.radiusValueAccessor(function (d) {
    return d.value;
  });

  /* OVERRIDE EXTEND ----------------------------------------------------------*/
  _chart.r(_d2.default.scale.sqrt());

  _chart.bounds = null;
  _chart.savedData = [];
  _chart.onColorCountUpdate = function (f) {
    if (!arguments.length) {
      return _colorCountUpdateCallback;
    }
    _colorCountUpdateCallback = f;
    return _chart;
  };

  _chart.sampling = function (setting) {
    // setting should be true or false
    if (!arguments.length) {
      return _sampling;
    }

    if (setting && !_sampling) {
      // if wasn't sampling
      (0, _core.incrementSampledCount)();
    } else if (!setting && _sampling) {
      (0, _core.decrementSampledCount)();
    }
    _sampling = setting;
    if (_sampling == false) {
      _chart.dimension().samplingRatio(null);
    } // unset sampling
    return _chart;
  };

  _chart.setSample = function () {
    if (_sampling) {
      var id = _chart.dimension().getCrossfilterId();
      var filterSize = (0, _coreAsync.lastFilteredSize)(id);
      if (filterSize === undefined) {
        _chart.dimension().samplingRatio(null);
      } else {
        _chart.dimension().samplingRatio(Math.min(_chart.cap() / filterSize, 1.0));
      }
    }
  };

  _chart.onClick = function (d) {
    if (_chart.bounds == null) {
      return;
    }
    var xPixelScale = 1.0 / (_chart.bounds[1][0] - _chart.bounds[0][0]) * _chart.width();
    var yPixelScale = 1.0 / (_chart.bounds[1][1] - _chart.bounds[0][1]) * _chart.height();
    var mapCoords = conv4326To900913([d.x, d.y]);
    var pixelPos = {
      x: (mapCoords[0] - _chart.bounds[0][0]) * xPixelScale,
      y: _chart.height() - (mapCoords[1] - _chart.bounds[0][1]) * yPixelScale
    };

    if (_clickCallbackFunc != null) {
      _clickCallbackFunc(d);
    }
  };
  /* --------------------------------------------------------------------------*/

  /**
   * **mandatory**
   *
   * Set up a data point on the overlay. The name of a data point should match a specific 'key' among
   * data groups generated using keyAccessor.  If a match is found (point name <-> data group key)
   * then a bubble will be generated at the position specified by the function. x and y
   * value specified here are relative to the underlying svg.
   * @name point
   * @memberof dc.bubbleOverlay
   * @instance
   * @param {String} name
   * @param {Number} x
   * @param {Number} y
   * @return {dc.bubbleOverlay}
   */
  _chart.point = function (name, x, y) {
    _points.push({ name: name, x: x, y: y });
    return _chart;
  };

  /* OVERRIDE EXTEND ----------------------------------------------------------*/
  function conv4326To900913(coord) {
    var transCoord = [0.0, 0.0];
    transCoord[0] = coord[0] * 111319.49077777777778;
    transCoord[1] = Math.log(Math.tan((90.0 + coord[1]) * 0.00872664625997)) * 6378136.99911215736947;
    return transCoord;
  }

  _chart.setBounds = function (bounds) {
    // need to convert to 900913 from 4326
    _chart.bounds = [[0.0, 0.0], [0.0, 0.0]];
    _chart.bounds[0] = conv4326To900913(bounds[0]);
    _chart.bounds[1] = conv4326To900913(bounds[1]);
  };
  /* --------------------------------------------------------------------------*/

  _chart._doRender = function () {
    _g = initOverlayG();

    /* OVERRIDE -----------------------------------------------------------------*/
    _g.selectAll("g").remove();
    _chart.plotData();
    /* --------------------------------------------------------------------------*/

    _chart.fadeDeselectedArea();

    return _chart;
  };

  function initOverlayG() {
    _g = _chart.select("g." + BUBBLE_OVERLAY_CLASS);
    if (_g.empty()) {
      _g = _chart.svg().append("g").attr("class", BUBBLE_OVERLAY_CLASS);
    }
    return _g;
  }

  /* OVERRIDE EXTEND ----------------------------------------------------------*/
  function mapDataToPoints(data) {
    if (_chart.bounds == null) {
      return;
    }
    var xPixelScale = 1.0 / (_chart.bounds[1][0] - _chart.bounds[0][0]) * _chart.width();
    var yPixelScale = 1.0 / (_chart.bounds[1][1] - _chart.bounds[0][1]) * _chart.height();
    var numPoints = data.length;
    for (var i = 0; i < numPoints; i++) {
      var coordTrans = conv4326To900913([data[i].x, data[i].y]);
      var xPixel = (coordTrans[0] - _chart.bounds[0][0]) * xPixelScale;
      var yPixel = _chart.height() - (coordTrans[1] - _chart.bounds[0][1]) * yPixelScale;
      data[i].xPixel = xPixel;
      data[i].yPixel = yPixel;
      data[i].xCoord = coordTrans[0];
      data[i].yCoord = coordTrans[1];
    }
  }

  _chart.remapPoints = function () {
    if (_chart.bounds == null) {
      return;
    }
    var xPixelScale = 1.0 / (_chart.bounds[1][0] - _chart.bounds[0][0]) * _chart.width();
    var yPixelScale = 1.0 / (_chart.bounds[1][1] - _chart.bounds[0][1]) * _chart.height();
    var numPoints = _chart.savedData.length;
    for (var p = 0; p < numPoints; p++) {
      _chart.savedData[p].xPixel = (_chart.savedData[p].xCoord - _chart.bounds[0][0]) * xPixelScale;
      _chart.savedData[p].yPixel = _chart.height() - (_chart.savedData[p].yCoord - _chart.bounds[0][1]) * yPixelScale;
    }
    updateBubbles();
  };

  _chart.plotData = function () {
    getData();
    var startTime = new Date();
    mapDataToPoints(_chart.savedData);
    if (_chart.scaleRadius) {
      _chart.r().domain([_chart.rMin(), _chart.rMax()]);

      _chart.r().range([_chart.MIN_RADIUS, _chart.MAX_RADIUS]);
    }
    if (!_g) {
      initOverlayG();
    }
    var bubbleG = _g.selectAll("g." + BUBBLE_NODE_CLASS).data(_chart.savedData, function (d) {
      return d.key;
    });

    bubbleG.enter().append("g").attr("class", function (d) {
      return BUBBLE_NODE_CLASS + " " + _utils.utils.nameToId(d.key);
    }).attr("transform", function (d) {
      return "translate(" + d.xPixel + "," + d.yPixel + ")";
    }).append("circle").attr("class", _chart.BUBBLE_CLASS).attr("r", function (d) {
      return _chart.scaleRadius ? _chart.bubbleR(d) : _chart.radiusValueAccessor()(d);
    }).attr("fill", _chart.getColor).on("click", _chart.onClick);

    bubbleG.attr("transform", function (d) {
      return "translate(" + d.xPixel + "," + d.yPixel + ")";
    }).attr("r", function (d) {
      return _chart.scaleRadius ? _chart.bubbleR(d) : _chart.radiusValueAccessor()(d);
    });

    bubbleG.exit().remove();
    var stopTime = new Date();
    var diff = stopTime - startTime;
  };

  function getData() {
    _chart.colorCountDictionary = {};
    _chart.savedData = _chart.data();
    _chart.savedData.forEach(function (datum) {
      if (datum.color in _chart.colorCountDictionary) {
        _chart.colorCountDictionary[datum.color]++;
      } else {
        _chart.colorCountDictionary[datum.color] = 1;
      }
      datum.key = _chart.keyAccessor()(datum);
    });
    if (_colorCountUpdateCallback != null) {
      _colorCountUpdateCallback(_chart.colorCountDictionary);
    }

    return _chart.savedData;
  }
  /* --------------------------------------------------------------------------*/

  function initializeBubbles() {
    var data = mapData();

    _points.forEach(function (point) {
      var nodeG = getNodeG(point, data);

      var circle = nodeG.select("circle." + BUBBLE_CLASS);

      if (circle.empty()) {
        circle = nodeG.append("circle").attr("class", BUBBLE_CLASS).attr("r", 0).attr("fill", _chart.getColor).on("click", _chart.onClick);
      }

      (0, _core.transition)(circle, _chart.transitionDuration()).attr("r", function (d) {
        return _chart.bubbleR(d);
      });

      _chart._doRenderLabel(nodeG);

      _chart._doRenderTitles(nodeG);
    });
  }

  function mapData() {
    var data = {};
    _chart.data().forEach(function (datum) {
      data[_chart.keyAccessor()(datum)] = datum;
    });
    return data;
  }

  function getNodeG(point, data) {
    var bubbleNodeClass = BUBBLE_NODE_CLASS + " " + _utils.utils.nameToId(point.name);

    var nodeG = _g.select("g." + _utils.utils.nameToId(point.name));

    if (nodeG.empty()) {
      nodeG = _g.append("g").attr("class", bubbleNodeClass).attr("transform", "translate(" + point.x + "," + point.y + ")");
    }

    nodeG.datum(data[point.name]);

    return nodeG;
  }

  _chart._doRedraw = function () {
    /* OVERRIDE -----------------------------------------------------------------*/
    _chart.plotData();
    /* --------------------------------------------------------------------------*/

    _chart.fadeDeselectedArea();
    return _chart;
  };

  function updateBubbles() {
    /* OVERRIDE -----------------------------------------------------------------*/
    if (!_g) {
      return;
    }

    var bubbleG = _g.selectAll("g." + BUBBLE_NODE_CLASS).data(_chart.savedData, function (d) {
      return d.key0;
    });

    bubbleG.attr("transform", function (d) {
      return "translate(" + d.xPixel + "," + d.yPixel + ")";
    });
    /* --------------------------------------------------------------------------*/
  }

  _chart.debug = function (flag) {
    if (flag) {
      var debugG = _chart.select("g." + _core.constants.DEBUG_GROUP_CLASS);

      if (debugG.empty()) {
        debugG = _chart.svg().append("g").attr("class", _core.constants.DEBUG_GROUP_CLASS);
      }

      var debugText = debugG.append("text").attr("x", 10).attr("y", 20);

      debugG.append("rect").attr("width", _chart.width()).attr("height", _chart.height()).on("mousemove", function () {
        var position = _d2.default.mouse(debugG.node());
        var msg = position[0] + ", " + position[1];
        debugText.text(msg);
      });
    } else {
      _chart.selectAll(".debug").remove();
    }

    return _chart;
  };

  _chart.anchor(parent, chartGroup);

  return _chart;
}
/** ***************************************************************************
 * END OVERRIDE: dc.bubbleOverlay                                             *
 * ***************************************************************************/

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = legendMixin;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _core = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PERCENTAGE = 100.0;
var LOWER_THAN_START_RANGE = 1000;

function legendMixin(chart) {
  chart.legendablesContinuous = function () {
    var legends = [];
    var colorDomain = chart.colors().domain();

    var colorDomainSize = colorDomain[1] - colorDomain[0];
    var colorRange = chart.colors().range();
    var numColors = colorRange.length;
    var commafy = _d2.default.format(",");

    for (var c = 0; c < numColors; c++) {
      var startRange = c / numColors * colorDomainSize + colorDomain[0];

      if (chart.isTargeting()) {
        startRange = "%" + (parseFloat(startRange) * PERCENTAGE).toFixed(2);
      } else if (chart.colorByExpr() === "count(*)") {
        startRange = parseInt(startRange); // eslint-disable-line radix
      } else {
        startRange = parseFloat(startRange).toFixed(2);
        startRange = startRange >= LOWER_THAN_START_RANGE ? Math.round(startRange) : startRange;
      }

      var color = null;

      if (colorDomainSize === 0) {
        color = colorRange[Math.floor(numColors / 2)];
      } else {
        color = colorRange[c];
      }

      legends.push({
        color: color,
        value: isNaN(startRange) ? startRange : commafy(startRange)
      });
    }

    return legends;
  };

  var legend_events = ["clearCustomContLegend", "setCustomContLegend"];

  var legend_listeners = _d2.default.dispatch.apply(_d2.default, legend_events);

  (0, _core.override)(chart, "on", function (event, listener) {
    var NON_INDEX = -1;
    if (legend_events.indexOf(event) === NON_INDEX) {
      chart._on(event, listener);
    } else {
      legend_listeners.on(event, listener);
    }

    return chart;
  });

  chart._invokeClearCustomContLegendListener = function () {
    legend_listeners.clearCustomContLegend(chart);
  };

  chart._invokeSetCustomContLegendListener = function (f) {
    legend_listeners.setCustomContLegend(chart, f);
  };

  return chart;
}

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addFilterHandler = addFilterHandler;
exports.hasFilterHandler = hasFilterHandler;
exports.filterHandlerWithChartContext = filterHandlerWithChartContext;
exports.default = filterMixin;

var _formattingHelpers = __webpack_require__(6);

var _events = __webpack_require__(9);

var noop = function noop() {}; // eslint-disable-line no-empty-function

function addFilterHandler(filters, filter) {
  if ((0, _formattingHelpers.isArrayOfObjects)(filter)) {
    filters.push(filter.map(function (f) {
      return f === null ? null : f.value;
    }));
  } else {
    filters.push(filter);
  }
  return filters;
}

function hasFilterHandler(filters, filter) {
  if (typeof filter === "undefined") {
    return filters.length > 0;
  } else if (Array.isArray(filter)) {
    filter = filter.map(_formattingHelpers.normalizeArrayByValue);
    return filters.some(function (f) {
      return filter <= f && filter >= f;
    });
  } else {
    return filters.some(function (f) {
      return filter <= f && filter >= f;
    });
  }
}

function filterHandlerWithChartContext(_chart) {
  return function filterHandler(dimension, filters) {
    if (dimension.type === "crossfilter") {
      return filters;
    }

    if (filters.length === 0) {
      dimension.filterAll(_chart.softFilterClear());
    } else if (_chart.hasOwnProperty("rangeFocused")) {
      dimension.filterMulti(filters, _chart.rangeFocused(), _chart.filtersInverse(), _chart.group().binParams());
    } else {
      dimension.filterMulti(filters, undefined, _chart.filtersInverse(), _chart.group().binParams()); // eslint-disable-line no-undefined
    }
    return filters;
  };
}

function filterMixin(_chart) {
  var _filters = [];
  var softFilterClear = false;
  var areFiltersInverse = false;
  var _hasFilterHandler = noop;

  _chart.filters = function () {
    return _filters;
  };

  _chart.replaceFilter = function (_) {
    _filters = [];
    _chart.filter(_);
  };

  _chart.softFilterClear = function (val) {
    if (!arguments.length) {
      return softFilterClear;
    }
    softFilterClear = val;
    return _chart;
  };

  _chart.filtersInverse = function (isInverse) {
    if (!arguments.length) {
      return areFiltersInverse;
    }
    areFiltersInverse = isInverse;
    return _chart;
  };

  /**
   * Clear all filters associated with this chart
   *
   * The same can be achieved by calling {@link #dc.baseMixin+filter chart.filter(Symbol.for("clear"))}.
   * @name filterAll
   * @memberof dc.baseMixin
   * @instance
   * @return {dc.baseMixin}
   */
  _chart.filterAll = function (_softFilterClear) {
    if (_softFilterClear) {
      _chart.softFilterClear(true);
    } else {
      _chart.softFilterClear(false);
    }
    return _chart.filter(Symbol.for("clear"));
  };

  _chart.filterHandler(filterHandlerWithChartContext(_chart));

  _chart.addFilterHandler(addFilterHandler);

  _chart.hasFilter = function (filter) {
    return _hasFilterHandler(_filters, filter);
  };

  _chart.hasFilterHandler = function (handler) {
    if (!arguments.length) {
      return _hasFilterHandler;
    }
    _hasFilterHandler = handler;
    return _chart;
  };

  _chart.hasFilterHandler(hasFilterHandler);

  function applyFilters() {
    if (_chart.dimension() && _chart.dimension().filter) {
      var fs = _chart.filterHandler()(_chart.dimension(), _filters);
      _filters = fs ? fs : _filters;
    }
  }

  _chart.filter = function (filter) {
    var isFilterInverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (!arguments.length) {
      return _filters.length > 0 ? _filters[0] : null;
    }

    if (Array.isArray(filter) && filter.length === 1) {
      filter = filter[0];
    } else if (Array.isArray(filter)) {
      filter = filter.map(function (filter) {
        return (
          // eslint-disable-line no-shadow, arrow-body-style
          Array.isArray(filter) && filter.length === 1 ? filter[0] : filter
        );
      });
    }

    if (isFilterInverse !== _chart.filtersInverse()) {
      _filters = _chart.resetFilterHandler()(_filters);
      _chart.filtersInverse(isFilterInverse);
    }

    if (filter === Symbol.for("clear") || Array.isArray(filter) && filter.length === 0) {
      _filters = _chart.resetFilterHandler()(_filters);
    } else if (_chart.hasFilter(filter)) {
      _chart.removeFilterHandler()(_filters, filter);
    } else {
      _chart.addFilterHandler()(_filters, filter);
    }

    applyFilters();
    _chart._invokeFilteredListener(filter, isFilterInverse);

    if (_chart.root() !== null && _chart.hasFilter()) {
      _chart.turnOnControls();
    } else {
      _chart.turnOffControls();
    }

    return _chart;
  };

  /**
   * Filters chart on click. Determines if filter is inverse and passes
   * that information to _chart.filter. Calls _chart.redrawGroup at the end.
   * @name handleFilterClick
   * @memberof dc.baseMixin
   * @instance
   * @example
   * chart.handleFilterClick(d3.event, filter);
   * @param {d3.event} event
   * @param {dc filter} filter
   * @return {dc.baseMixin}
   */
  _chart.handleFilterClick = function (event, filter) {
    if (event.defaultPrevented) {
      return;
    }
    var isInverseFilter = event.metaKey || event.ctrlKey;
    _events.events.trigger(function () {
      _chart.filter(filter, isInverseFilter);
      _chart.redrawGroup();
    });
  };

  return _chart;
}

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = labelMixin;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NON_INDEX = -1;
var LEGEND_WIDTH = 180;
var LABEL_WIDTH_MULTIPLIER = 0.9;

function labelMixin(chart) {
  var events = ["xLabel", "yLabel"];
  var _listeners = _d2.default.dispatch.apply(_d2.default, events);
  var _on = chart.on.bind(chart);
  var _measureLabelsOn = false;

  chart.measureLabelsOn = function (val) {
    if (!arguments.length) {
      return _measureLabelsOn;
    }
    _measureLabelsOn = val;
    return chart;
  };

  chart.on = function (event, listener) {
    var baseEvent = event.includes(".") ? event.slice(0, event.indexOf(".")) : event;
    if (events.indexOf(baseEvent) === NON_INDEX) {
      _on(event, listener);
    } else {
      _listeners.on(event, listener);
    }
    return chart;
  };

  chart._invokeLabelYListener = function (val) {
    _listeners.yLabel(chart, val);
  };

  chart._invokeLabelXListener = function (val) {
    _listeners.xLabel(chart, val);
  };

  function rangeChart() {
    return typeof chart.rangeChart === "function" && chart.rangeChart();
  }

  function focusChart() {
    return typeof chart.focusChart === "function" && chart.focusChart();
  }

  function isIE11() {
    return Boolean(window.MSInputMethodContext) && Boolean(document.documentMode);
  }

  function getMaxLabelWidth(type, hasLegend) {
    if (type === "y") {
      var height = chart.height() + (rangeChart() ? chart.rangeChart().height() : 0);
      return (height - Math.max(chart.margins().top + chart.margins().bottom, 64)) * LABEL_WIDTH_MULTIPLIER;
    }

    return (hasLegend ? chart.width() - LEGEND_WIDTH : chart.effectiveWidth()) * LABEL_WIDTH_MULTIPLIER;
  }

  function getXaxisLeftPosition(hasLegend) {
    return hasLegend ? chart.getAxisLabelContainerWidth("x", hasLegend) / 2 + 32 : chart.effectiveWidth() / 2 + chart.margins().left;
  }

  function getYaxisTopPosition() {
    var yOffset = rangeChart() ? chart.rangeChart().height() - chart.rangeChart().margins().bottom + chart.margins().bottom : 0;
    return (chart.height() - Math.max(chart.margins().top + chart.margins().bottom, 64) + yOffset) / 2 + chart.margins().top;
  }

  chart.getAxisLabelContainerWidth = function (type, hasLegend) {
    var width = type === "x" ? chart.effectiveWidth() : chart.effectiveHeight();
    var adjustForLegend = type === "x" && hasLegend ? 32 : 0;
    return width - adjustForLegend;
  };

  function setLabel(type, val) {
    chart[type + "AxisLabel"](val);
    if (focusChart()) {
      chart.focusChart()["_invokeLabel" + type.toUpperCase() + "Listener"](val);
      if (type === "x") {
        chart.xAxisLabel(val);
        chart.redrawAsync();
      }
      return;
    }
    chart["_invokeLabel" + type.toUpperCase() + "Listener"](val);
    chart.redrawAsync();
  }

  chart.prepareLabelEdit = function () {
    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "y";

    if (rangeChart() && type === "x" || focusChart() && type === "y") {
      return;
    }
    var hasLegend = type === "x" && chart.legend() && chart.legend().legendType && chart.legend().legendType() === "quantitative";

    var iconPosition = {
      left: type === "y" ? "" : getXaxisLeftPosition(hasLegend) + "px",
      top: type === "y" ? getYaxisTopPosition() + "px" : ""
    };

    chart.root().selectAll(".axis-label-edit.type-" + type).remove();

    chart.root().selectAll(".y-axis-label, .x-axis-label").style("display", "none");

    var editorWrapper = chart.root().append("div").attr("class", "axis-label-edit type-" + type).style("width", chart.getAxisLabelContainerWidth(type, hasLegend) + "px").classed("has-legend", hasLegend).style("top", iconPosition.top).style("left", iconPosition.left).append("div").attr("class", "input-wrapper").style("max-width", getMaxLabelWidth(type, hasLegend) + "px").style("width", isIE11() ? getMaxLabelWidth(type, hasLegend) + "px" : "auto");

    editorWrapper.append("span").text(chart[type + "AxisLabel"]());

    editorWrapper.append("input").attr("value", chart[type + "AxisLabel"]()).attr("title", chart[type + "AxisLabel"]()).on("focus", function () {
      this.select();
    }).on("keyup", function () {
      _d2.default.select(this.parentNode).select("span").text(this.value);
      if (_d2.default.event.keyCode === 13) {
        this.blur();
      }
    }).on("mouseup", function () {
      _d2.default.event.preventDefault();
    }).on("change", function () {
      this.blur();
    }).on("blur", function () {
      setLabel(type, this.value);
    });
  };

  return chart;
}

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var SPINNER_DELAY = exports.SPINNER_DELAY = 1000;

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = barChart;

var _core = __webpack_require__(2);

var _utils = __webpack_require__(3);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _stackMixin = __webpack_require__(19);

var _stackMixin2 = _interopRequireDefault(_stackMixin);

var _elasticDimensionMixin = __webpack_require__(134);

var _elasticDimensionMixin2 = _interopRequireDefault(_elasticDimensionMixin);

var _coordinateGridMixin = __webpack_require__(11);

var _coordinateGridMixin2 = _interopRequireDefault(_coordinateGridMixin);

var _multiSeriesMixin = __webpack_require__(136);

var _multiSeriesMixin2 = _interopRequireDefault(_multiSeriesMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TIME_UNIT_PER_SECONDS = {
  century: 3153600000,
  decade: 315360000,
  year: 31536000,
  quarter: 10368000,
  month: 2592000,
  week: 604800,
  day: 86400,
  hour: 3600,
  minute: 60,
  second: 1
};

var MILLISECONDS_IN_SECOND = 1000;

var EXTRACT_UNIT_NUM_BUCKETS = {
  day: 31,
  isodom: 31,
  isodow: 7,
  month: 12,
  quarter: 4,
  hour: 24,
  minute: 60

  /**
   * Concrete bar chart/histogram implementation.
   *
   * @class barChart
   * @memberof dc
   * @mixes dc.stackMixin
   * @mixes dc.coordinateGridMixin
   * @example
   * // create a bar chart under #chart-container1 element using the default global chart group
   * var chart1 = dc.barChart('#chart-container1');
   * // create a bar chart under #chart-container2 element using chart group A
   * var chart2 = dc.barChart('#chart-container2', 'chartGroupA');
   * // create a sub-chart under a composite parent chart
   * var chart3 = dc.barChart(compositeChart);
   * @param {String|node|d3.selection|dc.compositeChart} parent - Any valid
   * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector}
   * specifying a dom block element such as a div; or a dom element or d3 selection.  If the bar
   * chart is a sub-chart in a {@link dc.compositeChart Composite Chart} then pass in the parent
   * composite chart instance instead.
   * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
   * Interaction with a chart will only trigger events and redraws within the chart's group.
   * @returns {dc.barChart}
   */
};function barChart(parent, chartGroup) {
  var MIN_BAR_WIDTH = 1;
  var DEFAULT_GAP_BETWEEN_BARS = 4;
  var LABEL_PADDING = 3;

  var _chart = (0, _elasticDimensionMixin2.default)((0, _stackMixin2.default)((0, _coordinateGridMixin2.default)({})));

  var _gap = DEFAULT_GAP_BETWEEN_BARS;
  var _centerBar = false;
  var _alwaysUseRounding = false;

  var _numBars = void 0;
  var _parent = parent;

  _chart._numberOfBars = null;
  var _barWidth = void 0;

  (0, _core.override)(_chart, "rescale", function () {
    _chart._rescale();
    _barWidth = undefined;

    return _chart;
  });

  _chart.label(function (d) {
    return _utils.utils.printSingleValue(d.y0 + d.y);
  }, false);

  _chart.measureValue = function (value) {
    var customFormatter = _chart.valueFormatter();
    return customFormatter && customFormatter(value) || _utils.utils.formatValue(value);
  };

  _chart.plotData = function () {
    var layers = _chart.chartBodyG().selectAll("g.stack").data(_chart.data());

    calculateBarWidth();

    layers.enter().append("g").attr("class", function (d, i) {
      return "stack " + "_" + i;
    });

    var last = layers.size() - 1;
    layers.each(function (d, i) {
      var layer = _d2.default.select(this);

      renderBars(layer, i, d);
      if (_chart.renderLabel() && last === i) {
        renderLabels(layer, i, d);
      }
    });

    if (_chart.brushOn()) {
      hoverOverBrush();
    }
  };

  function hoverOverBrush() {
    var g = _chart.g().on("mouseout", function () {
      dehighlightBars();
    }).on("mousemove", function () {
      if (_chart.isBrushing()) {
        hidePopup();
      } else {
        highlightBars(g, this);
      }
    });
  }

  function highlightBars(g, e) {
    var coordinates = [0, 0];
    coordinates = _chart.popupCoordinates(_d2.default.mouse(e));
    var x = coordinates[0];
    var y = coordinates[1];
    var xAdjusted = x - _chart.margins().left;
    var yAdjusted = y - _chart.margins().top;

    var popupRows = [];

    var toolTips = g.selectAll(".stack").each(function () {
      var hoverBar = null;

      var bars = _d2.default.select(this).selectAll(".bar").style("fill-opacity", 1);

      bars[0].sort(function (a, b) {
        return _d2.default.select(a).attr("x") - _d2.default.select(b).attr("x");
      });

      bars[0].some(function (obj, i) {
        var elm = _d2.default.select(obj);

        if (xAdjusted < elm.attr("x")) {
          return true;
        }

        hoverBar = { elm: elm, datum: elm.datum(), i: i };
      });

      if (hoverBar && Math.abs(hoverBar.elm.attr("x") - xAdjusted) < _barWidth) {
        hoverBar.elm.style("fill-opacity", 0.8);
        popupRows.push(hoverBar);
      }
    });

    if (popupRows.length > 0) {
      showPopup(popupRows.reverse(), x, y);
    } else {
      hidePopup();
    }
  }

  function dehighlightBars() {
    _chart.g().selectAll(".bar").style("fill-opacity", 1);
    hidePopup();
  }

  function showPopup(arr, x, y) {
    if (!_chart.popupIsEnabled()) {
      hidePopup();
      return false;
    }
    var popup = _chart.popup().classed("hide-delay", true);

    var popupBox = popup.select(".chart-popup-content").html("").classed("popup-list", true);

    popupBox.append("div").attr("class", "popup-header").text(_chart.popupTextAccessor(arr));

    var popupItems = popupBox.selectAll(".popup-item").data(arr).enter().append("div").attr("class", "popup-item");

    popupItems.append("div").attr("class", "popup-legend").style("background-color", function (d) {
      return _chart.getColor(d.datum, d.i);
    });

    if (_chart.series().keys()) {
      popupItems.append("div").attr("class", "popup-item-key").text(function (d) {
        return _chart.colorDomain()[d.datum.idx];
      });
    }

    popupItems.append("div").attr("class", "popup-item-value").text(function (d) {
      return _chart.measureValue(d.datum.y);
    });

    positionPopup(x, y);
    popup.classed("js-showPopup", true);
  }

  function hidePopup() {
    _chart.popup().classed("js-showPopup", false);
  }

  function positionPopup(x, y) {
    var popup = _chart.popup().attr("style", function () {
      return "transform:translate(" + x + "px," + y + "px)";
    });

    popup.select(".chart-popup-box").classed("align-left-center", true).classed("align-right-center", function () {
      return x + (_d2.default.select(this).node().getBoundingClientRect().width + 32) > _chart.width();
    });
  }

  function barHeight(d) {
    return _utils.utils.safeNumber(Math.abs(_chart.y()(d.y + d.y0) - _chart.y()(d.y0)));
  }

  function renderLabels(layer, layerIndex, d) {
    var labels = layer.selectAll("text.barLabel").data(d.values, (0, _utils.pluck)("x"));

    labels.enter().append("text").attr("class", "barLabel").attr("text-anchor", "middle");

    if (_chart.isOrdinal()) {
      labels.on("click", _chart.onClick);
      labels.attr("cursor", "pointer");
    }

    (0, _core.transition)(labels, _chart.transitionDuration()).attr("x", function (d) {
      var x = _chart.x()(d.x);
      if (!_centerBar) {
        x = x + _barWidth / 2;
      }
      return _utils.utils.safeNumber(x);
    }).attr("y", function (d) {
      var y = _chart.y()(d.y + d.y0);

      if (d.y < 0) {
        y = y - barHeight(d);
      }

      return _utils.utils.safeNumber(y - LABEL_PADDING);
    }).text(function (d) {
      return _chart.label()(d);
    });

    (0, _core.transition)(labels.exit(), _chart.transitionDuration()).attr("height", 0).remove();
  }

  function renderBars(layer, layerIndex, d) {
    /* OVERRIDE ---------------------------------------------------------------- */
    _numBars = d.values.length;
    /* ------------------------------------------------------------------------- */
    function colors(d, i) {
      if (d.name) {
        d.layer = d.name;
        return _chart.getColor(d, i);
      } else {
        return _chart.getColor(d, i);
      }
    }

    var bars = layer.selectAll("rect.bar").data(d.values, (0, _utils.pluck)("x"));

    var enter = bars.enter().append("rect").attr("class", "bar").attr("fill", colors).attr("y", _chart.yAxisHeight()).attr("height", 0);

    if (_chart.renderTitle()) {
      enter.append("title").text((0, _utils.pluck)("data", _chart.title(d.name)));
    }

    if (_chart.isOrdinal()) {
      bars.on("click", _chart.onClick);
    }

    (0, _core.transition)(bars, _chart.transitionDuration()).attr("x", function (d) {
      var x = _chart.x()(d.x);
      if (_centerBar) {
        x = x - _barWidth / 2;
      }
      if (_chart.isOrdinal() && _gap !== undefined) {
        x = x + _gap / 2;
      }
      return _utils.utils.safeNumber(x);
    }).attr("y", function (d) {
      var y = _chart.y()(d.y + d.y0);

      if (d.y < 0) {
        y = y - barHeight(d);
      }

      return _utils.utils.safeNumber(y);
    }).attr("width", _barWidth).attr("height", function (d) {
      return barHeight(d);
    }).attr("fill", colors).select("title").text((0, _utils.pluck)("data", _chart.title(d.name)));

    (0, _core.transition)(bars.exit(), _chart.transitionDuration()).attr("height", 0).remove();
  }

  function calculateBarWidth() {
    var numberOfBars = void 0;
    var binParams = _chart.group().binParams()[0];

    if (binParams) {
      numberOfBars = binParams.timeBin ? _chart.getTimeBinSize(binParams) : binParams.numBins;
    } else {
      var allValues = _chart.data()[0].values.map(function (val) {
        return val.x;
      });
      var maxVal = Math.max.apply(null, allValues);
      var minVal = Math.min.apply(null, allValues);

      numberOfBars = maxVal - minVal;
    }

    if (_chart.isOrdinal() && _gap === undefined) {
      _barWidth = Math.floor(_chart.x().rangeBand());
    } else if (_gap) {
      _barWidth = Math.floor((_chart.xAxisLength() - (numberOfBars - 1) * _gap) / numberOfBars);
    } else {
      _barWidth = Math.floor(_chart.xAxisLength() / (1 + _chart.barPadding()) / numberOfBars);
    }

    if (_barWidth === Infinity || isNaN(_barWidth) || _barWidth < MIN_BAR_WIDTH) {
      _barWidth = MIN_BAR_WIDTH;
    }
  }

  _chart.fadeDeselectedArea = function () {
    var bars = _chart.chartBodyG().selectAll("rect.bar");
    var extent = _chart.brush().extent();

    if (_chart.isOrdinal()) {
      if (_chart.hasFilter()) {
        bars.classed(_core.constants.SELECTED_CLASS, function (d) {
          return _chart.hasFilter(d.x);
        });
        bars.classed(_core.constants.DESELECTED_CLASS, function (d) {
          return !_chart.hasFilter(d.x);
        });
      } else {
        bars.classed(_core.constants.SELECTED_CLASS, false);
        bars.classed(_core.constants.DESELECTED_CLASS, false);
      }
    } else if (!_chart.brushIsEmpty(extent)) {
      var start = extent[0];
      var end = extent[1];

      bars.classed(_core.constants.DESELECTED_CLASS, function (d) {
        return d.x < start || d.x >= end;
      });
    } else {
      bars.classed(_core.constants.DESELECTED_CLASS, false);
    }
  };

  /**
   * Whether the bar chart will render each bar centered around the data position on the x-axis.
   * @name centerBar
   * @memberof dc.barChart
   * @instance
   * @param {Boolean} [centerBar=false]
   * @return {Boolean}
   * @return {dc.barChart}
   */
  _chart.centerBar = function (centerBar) {
    if (!arguments.length) {
      return _centerBar;
    }
    _centerBar = centerBar;
    return _chart;
  };

  (0, _core.override)(_chart, "onClick", function (d) {
    _chart._onClick(d.data);
  });

  /**
   * Get or set the spacing between bars as a fraction of bar size. Valid values are between 0-1.
   * Setting this value will also remove any previously set {@link #dc.barChart+gap gap}. See the
   * {@link https://github.com/mbostock/d3/wiki/Ordinal-Scales#wiki-ordinal_rangeBands d3 docs}
   * for a visual description of how the padding is applied.
   * @name barPadding
   * @memberof dc.barChart
   * @instance
   * @param {Number} [barPadding=0]
   * @return {Number}
   * @return {dc.barChart}
   */
  _chart.barPadding = function (barPadding) {
    if (!arguments.length) {
      return _chart._rangeBandPadding();
    }
    _chart._rangeBandPadding(barPadding);
    _gap = undefined;
    return _chart;
  };

  _chart._useOuterPadding = function () {
    return _gap === undefined;
  };

  /**
   * Get or set the outer padding on an ordinal bar chart. This setting has no effect on non-ordinal charts.
   * Will pad the width by `padding * barWidth` on each side of the chart.
   * @name outerPadding
   * @memberof dc.barChart
   * @instance
   * @param {Number} [padding=0.5]
   * @return {Number}
   * @return {dc.barChart}
   */
  _chart.outerPadding = _chart._outerRangeBandPadding;

  /**
   * Manually set fixed gap (in px) between bars instead of relying on the default auto-generated
   * gap.  By default the bar chart implementation will calculate and set the gap automatically
   * based on the number of data points and the length of the x axis.
   * @name gap
   * @memberof dc.barChart
   * @instance
   * @param {Number} [gap=2]
   * @return {Number}
   * @return {dc.barChart}
   */
  _chart.gap = function (gap) {
    if (!arguments.length) {
      return _gap;
    }
    _gap = gap;
    return _chart;
  };

  _chart.extendBrush = function () {
    var extent = _chart.brush().extent();
    if (_chart.round() && (!_centerBar || _alwaysUseRounding)) {
      extent[0] = extent.map(_chart.round())[0];
      extent[1] = extent.map(_chart.round())[1];

      _chart.chartBodyG().select(".brush").call(_chart.brush().extent(extent));
    }

    return extent;
  };

  /**
   * Set or get whether rounding is enabled when bars are centered. If false, using
   * rounding with centered bars will result in a warning and rounding will be ignored.  This flag
   * has no effect if bars are not {@link #dc.barChart+centerBar centered}.
   * When using standard d3.js rounding methods, the brush often doesn't align correctly with
   * centered bars since the bars are offset.  The rounding function must add an offset to
   * compensate, such as in the following example.
   * @name alwaysUseRounding
   * @memberof dc.barChart
   * @instance
   * @example
   * chart.round(function(n) { return Math.floor(n) + 0.5; });
   * @param {Boolean} [alwaysUseRounding=false]
   * @return {Boolean}
   * @return {dc.barChart}
   */
  _chart.alwaysUseRounding = function (alwaysUseRounding) {
    if (!arguments.length) {
      return _alwaysUseRounding;
    }
    _alwaysUseRounding = alwaysUseRounding;
    return _chart;
  };

  function colorFilter(color, inv) {
    return function () {
      var item = _d2.default.select(this);
      var match = item.attr("fill") === color;
      return inv ? !match : match;
    };
  }

  _chart.legendHighlight = function (d) {
    if (!_chart.isLegendableHidden(d)) {
      _chart.g().selectAll("rect.bar").classed("highlight", colorFilter(d.color)).classed("fadeout", colorFilter(d.color, true));
    }
  };

  _chart.legendReset = function () {
    _chart.g().selectAll("rect.bar").classed("highlight", false).classed("fadeout", false);
  };

  (0, _core.override)(_chart, "xAxisMax", function () {
    var max = this._xAxisMax();
    if ("resolution" in _chart.xUnits()) {
      var res = _chart.xUnits().resolution;
      max = max + res;
    }
    return max;
  });

  var getConservativeDateTruncBucket = function getConservativeDateTruncBucket(binUnit) {
    return TIME_UNIT_PER_SECONDS[binUnit] * MILLISECONDS_IN_SECOND;
  };

  var getDateExtractBucket = function getDateExtractBucket(binUnit) {
    return EXTRACT_UNIT_NUM_BUCKETS[binUnit];
  };

  _chart.getTimeBinSize = function (binParams) {
    if (binParams.extract && binParams.timeBin !== "year") {
      return getDateExtractBucket(binParams.timeBin);
    }
    return Math.ceil((_chart.xAxisMax() - _chart.xAxisMin()) / getConservativeDateTruncBucket(binParams.timeBin));
  };

  _chart.renderLabel(false);

  _chart = (0, _multiSeriesMixin2.default)(_chart);

  _chart.destroyChart = function () {
    (0, _core.deregisterChart)(_chart, _chart.chartGroup());
    _chart.on("filtered", null);
    _chart.filterAll();
    _chart.resetSvg();
    _chart.root().attr("style", "").attr("class", "").html("");
    _chart._doRender = function () {
      return _chart;
    };
  };

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

//  Ramda v0.21.0
//  https://github.com/ramda/ramda
//  (c) 2013-2016 Scott Sauyet, Michael Hurley, and David Chambers
//  Ramda may be freely distributed under the MIT license.

;(function() {

  'use strict';

  /**
     * A special placeholder value used to specify "gaps" within curried functions,
     * allowing partial application of any combination of arguments, regardless of
     * their positions.
     *
     * If `g` is a curried ternary function and `_` is `R.__`, the following are
     * equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2, _)(1, 3)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @constant
     * @memberOf R
     * @since v0.6.0
     * @category Function
     * @example
     *
     *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');
     *      greet('Alice'); //=> 'Hello, Alice!'
     */
    var __ = { '@@functional/placeholder': true };

    /* eslint-disable no-unused-vars */
    var _arity = function _arity(n, fn) {
        /* eslint-disable no-unused-vars */
        switch (n) {
        case 0:
            return function () {
                return fn.apply(this, arguments);
            };
        case 1:
            return function (a0) {
                return fn.apply(this, arguments);
            };
        case 2:
            return function (a0, a1) {
                return fn.apply(this, arguments);
            };
        case 3:
            return function (a0, a1, a2) {
                return fn.apply(this, arguments);
            };
        case 4:
            return function (a0, a1, a2, a3) {
                return fn.apply(this, arguments);
            };
        case 5:
            return function (a0, a1, a2, a3, a4) {
                return fn.apply(this, arguments);
            };
        case 6:
            return function (a0, a1, a2, a3, a4, a5) {
                return fn.apply(this, arguments);
            };
        case 7:
            return function (a0, a1, a2, a3, a4, a5, a6) {
                return fn.apply(this, arguments);
            };
        case 8:
            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
                return fn.apply(this, arguments);
            };
        case 9:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
                return fn.apply(this, arguments);
            };
        case 10:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                return fn.apply(this, arguments);
            };
        default:
            throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
        }
    };

    var _arrayFromIterator = function _arrayFromIterator(iter) {
        var list = [];
        var next;
        while (!(next = iter.next()).done) {
            list.push(next.value);
        }
        return list;
    };

    var _arrayOf = function _arrayOf() {
        return Array.prototype.slice.call(arguments);
    };

    var _cloneRegExp = function _cloneRegExp(pattern) {
        return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
    };

    var _complement = function _complement(f) {
        return function () {
            return !f.apply(this, arguments);
        };
    };

    /**
     * Private `concat` function to merge two array-like objects.
     *
     * @private
     * @param {Array|Arguments} [set1=[]] An array-like object.
     * @param {Array|Arguments} [set2=[]] An array-like object.
     * @return {Array} A new, merged array.
     * @example
     *
     *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
     */
    var _concat = function _concat(set1, set2) {
        set1 = set1 || [];
        set2 = set2 || [];
        var idx;
        var len1 = set1.length;
        var len2 = set2.length;
        var result = [];
        idx = 0;
        while (idx < len1) {
            result[result.length] = set1[idx];
            idx += 1;
        }
        idx = 0;
        while (idx < len2) {
            result[result.length] = set2[idx];
            idx += 1;
        }
        return result;
    };

    var _containsWith = function _containsWith(pred, x, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            if (pred(x, list[idx])) {
                return true;
            }
            idx += 1;
        }
        return false;
    };

    var _filter = function _filter(fn, list) {
        var idx = 0;
        var len = list.length;
        var result = [];
        while (idx < len) {
            if (fn(list[idx])) {
                result[result.length] = list[idx];
            }
            idx += 1;
        }
        return result;
    };

    var _forceReduced = function _forceReduced(x) {
        return {
            '@@transducer/value': x,
            '@@transducer/reduced': true
        };
    };

    // String(x => x) evaluates to "x => x", so the pattern may not match.
    var _functionName = function _functionName(f) {
        // String(x => x) evaluates to "x => x", so the pattern may not match.
        var match = String(f).match(/^function (\w*)/);
        return match == null ? '' : match[1];
    };

    var _has = function _has(prop, obj) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
    };

    var _identity = function _identity(x) {
        return x;
    };

    var _isArguments = function () {
        var toString = Object.prototype.toString;
        return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
            return toString.call(x) === '[object Arguments]';
        } : function _isArguments(x) {
            return _has('callee', x);
        };
    }();

    /**
     * Tests whether or not an object is an array.
     *
     * @private
     * @param {*} val The object to test.
     * @return {Boolean} `true` if `val` is an array, `false` otherwise.
     * @example
     *
     *      _isArray([]); //=> true
     *      _isArray(null); //=> false
     *      _isArray({}); //=> false
     */
    var _isArray = Array.isArray || function _isArray(val) {
        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
    };

    var _isFunction = function _isNumber(x) {
        return Object.prototype.toString.call(x) === '[object Function]';
    };

    /**
     * Determine if the passed argument is an integer.
     *
     * @private
     * @param {*} n
     * @category Type
     * @return {Boolean}
     */
    var _isInteger = Number.isInteger || function _isInteger(n) {
        return n << 0 === n;
    };

    var _isNumber = function _isNumber(x) {
        return Object.prototype.toString.call(x) === '[object Number]';
    };

    var _isObject = function _isObject(x) {
        return Object.prototype.toString.call(x) === '[object Object]';
    };

    var _isPlaceholder = function _isPlaceholder(a) {
        return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
    };

    var _isRegExp = function _isRegExp(x) {
        return Object.prototype.toString.call(x) === '[object RegExp]';
    };

    var _isString = function _isString(x) {
        return Object.prototype.toString.call(x) === '[object String]';
    };

    var _isTransformer = function _isTransformer(obj) {
        return typeof obj['@@transducer/step'] === 'function';
    };

    var _map = function _map(fn, functor) {
        var idx = 0;
        var len = functor.length;
        var result = Array(len);
        while (idx < len) {
            result[idx] = fn(functor[idx]);
            idx += 1;
        }
        return result;
    };

    // Based on https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
    var _objectAssign = function _objectAssign(target) {
        if (target == null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }
        var output = Object(target);
        var idx = 1;
        var length = arguments.length;
        while (idx < length) {
            var source = arguments[idx];
            if (source != null) {
                for (var nextKey in source) {
                    if (_has(nextKey, source)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
            idx += 1;
        }
        return output;
    };

    var _of = function _of(x) {
        return [x];
    };

    var _pipe = function _pipe(f, g) {
        return function () {
            return g.call(this, f.apply(this, arguments));
        };
    };

    var _pipeP = function _pipeP(f, g) {
        return function () {
            var ctx = this;
            return f.apply(ctx, arguments).then(function (x) {
                return g.call(ctx, x);
            });
        };
    };

    // \b matches word boundary; [\b] matches backspace
    var _quote = function _quote(s) {
        var escaped = s.replace(/\\/g, '\\\\').replace(/[\b]/g, '\\b')    // \b matches word boundary; [\b] matches backspace
    .replace(/\f/g, '\\f').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t').replace(/\v/g, '\\v').replace(/\0/g, '\\0');
        return '"' + escaped.replace(/"/g, '\\"') + '"';
    };

    var _reduced = function _reduced(x) {
        return x && x['@@transducer/reduced'] ? x : {
            '@@transducer/value': x,
            '@@transducer/reduced': true
        };
    };

    /**
     * An optimized, private array `slice` implementation.
     *
     * @private
     * @param {Arguments|Array} args The array or arguments object to consider.
     * @param {Number} [from=0] The array index to slice from, inclusive.
     * @param {Number} [to=args.length] The array index to slice to, exclusive.
     * @return {Array} A new, sliced array.
     * @example
     *
     *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]
     *
     *      var firstThreeArgs = function(a, b, c, d) {
     *        return _slice(arguments, 0, 3);
     *      };
     *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]
     */
    var _slice = function _slice(args, from, to) {
        switch (arguments.length) {
        case 1:
            return _slice(args, 0, args.length);
        case 2:
            return _slice(args, from, args.length);
        default:
            var list = [];
            var idx = 0;
            var len = Math.max(0, Math.min(args.length, to) - from);
            while (idx < len) {
                list[idx] = args[from + idx];
                idx += 1;
            }
            return list;
        }
    };

    /**
     * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
     */
    var _toISOString = function () {
        var pad = function pad(n) {
            return (n < 10 ? '0' : '') + n;
        };
        return typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
            return d.toISOString();
        } : function _toISOString(d) {
            return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
        };
    }();

    var _xfBase = {
        init: function () {
            return this.xf['@@transducer/init']();
        },
        result: function (result) {
            return this.xf['@@transducer/result'](result);
        }
    };

    var _xwrap = function () {
        function XWrap(fn) {
            this.f = fn;
        }
        XWrap.prototype['@@transducer/init'] = function () {
            throw new Error('init not implemented on XWrap');
        };
        XWrap.prototype['@@transducer/result'] = function (acc) {
            return acc;
        };
        XWrap.prototype['@@transducer/step'] = function (acc, x) {
            return this.f(acc, x);
        };
        return function _xwrap(fn) {
            return new XWrap(fn);
        };
    }();

    var _aperture = function _aperture(n, list) {
        var idx = 0;
        var limit = list.length - (n - 1);
        var acc = new Array(limit >= 0 ? limit : 0);
        while (idx < limit) {
            acc[idx] = _slice(list, idx, idx + n);
            idx += 1;
        }
        return acc;
    };

    var _assign = typeof Object.assign === 'function' ? Object.assign : _objectAssign;

    /**
     * Similar to hasMethod, this checks whether a function has a [methodname]
     * function. If it isn't an array it will execute that function otherwise it
     * will default to the ramda implementation.
     *
     * @private
     * @param {Function} fn ramda implemtation
     * @param {String} methodname property to check for a custom implementation
     * @return {Object} Whatever the return value of the method is.
     */
    var _checkForMethod = function _checkForMethod(methodname, fn) {
        return function () {
            var length = arguments.length;
            if (length === 0) {
                return fn();
            }
            var obj = arguments[length - 1];
            return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, _slice(arguments, 0, length - 1));
        };
    };

    /**
     * Optimized internal one-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curry1 = function _curry1(fn) {
        return function f1(a) {
            if (arguments.length === 0 || _isPlaceholder(a)) {
                return f1;
            } else {
                return fn.apply(this, arguments);
            }
        };
    };

    /**
     * Optimized internal two-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curry2 = function _curry2(fn) {
        return function f2(a, b) {
            switch (arguments.length) {
            case 0:
                return f2;
            case 1:
                return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
                    return fn(a, _b);
                });
            default:
                return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
                    return fn(_a, b);
                }) : _isPlaceholder(b) ? _curry1(function (_b) {
                    return fn(a, _b);
                }) : fn(a, b);
            }
        };
    };

    /**
     * Optimized internal three-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curry3 = function _curry3(fn) {
        return function f3(a, b, c) {
            switch (arguments.length) {
            case 0:
                return f3;
            case 1:
                return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
                    return fn(a, _b, _c);
                });
            case 2:
                return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
                    return fn(_a, b, _c);
                }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
                    return fn(a, _b, _c);
                }) : _curry1(function (_c) {
                    return fn(a, b, _c);
                });
            default:
                return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
                    return fn(_a, _b, c);
                }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
                    return fn(_a, b, _c);
                }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
                    return fn(a, _b, _c);
                }) : _isPlaceholder(a) ? _curry1(function (_a) {
                    return fn(_a, b, c);
                }) : _isPlaceholder(b) ? _curry1(function (_b) {
                    return fn(a, _b, c);
                }) : _isPlaceholder(c) ? _curry1(function (_c) {
                    return fn(a, b, _c);
                }) : fn(a, b, c);
            }
        };
    };

    /**
     * Internal curryN function.
     *
     * @private
     * @category Function
     * @param {Number} length The arity of the curried function.
     * @param {Array} received An array of arguments received thus far.
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curryN = function _curryN(length, received, fn) {
        return function () {
            var combined = [];
            var argsIdx = 0;
            var left = length;
            var combinedIdx = 0;
            while (combinedIdx < received.length || argsIdx < arguments.length) {
                var result;
                if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
                    result = received[combinedIdx];
                } else {
                    result = arguments[argsIdx];
                    argsIdx += 1;
                }
                combined[combinedIdx] = result;
                if (!_isPlaceholder(result)) {
                    left -= 1;
                }
                combinedIdx += 1;
            }
            return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
        };
    };

    /**
     * Returns a function that dispatches with different strategies based on the
     * object in list position (last argument). If it is an array, executes [fn].
     * Otherwise, if it has a function with [methodname], it will execute that
     * function (functor case). Otherwise, if it is a transformer, uses transducer
     * [xf] to return a new transformer (transducer case). Otherwise, it will
     * default to executing [fn].
     *
     * @private
     * @param {String} methodname property to check for a custom implementation
     * @param {Function} xf transducer to initialize if object is transformer
     * @param {Function} fn default ramda implementation
     * @return {Function} A function that dispatches on object in list position
     */
    var _dispatchable = function _dispatchable(methodname, xf, fn) {
        return function () {
            var length = arguments.length;
            if (length === 0) {
                return fn();
            }
            var obj = arguments[length - 1];
            if (!_isArray(obj)) {
                var args = _slice(arguments, 0, length - 1);
                if (typeof obj[methodname] === 'function') {
                    return obj[methodname].apply(obj, args);
                }
                if (_isTransformer(obj)) {
                    var transducer = xf.apply(null, args);
                    return transducer(obj);
                }
            }
            return fn.apply(this, arguments);
        };
    };

    var _dropLastWhile = function dropLastWhile(pred, list) {
        var idx = list.length - 1;
        while (idx >= 0 && pred(list[idx])) {
            idx -= 1;
        }
        return _slice(list, 0, idx + 1);
    };

    var _xall = function () {
        function XAll(f, xf) {
            this.xf = xf;
            this.f = f;
            this.all = true;
        }
        XAll.prototype['@@transducer/init'] = _xfBase.init;
        XAll.prototype['@@transducer/result'] = function (result) {
            if (this.all) {
                result = this.xf['@@transducer/step'](result, true);
            }
            return this.xf['@@transducer/result'](result);
        };
        XAll.prototype['@@transducer/step'] = function (result, input) {
            if (!this.f(input)) {
                this.all = false;
                result = _reduced(this.xf['@@transducer/step'](result, false));
            }
            return result;
        };
        return _curry2(function _xall(f, xf) {
            return new XAll(f, xf);
        });
    }();

    var _xany = function () {
        function XAny(f, xf) {
            this.xf = xf;
            this.f = f;
            this.any = false;
        }
        XAny.prototype['@@transducer/init'] = _xfBase.init;
        XAny.prototype['@@transducer/result'] = function (result) {
            if (!this.any) {
                result = this.xf['@@transducer/step'](result, false);
            }
            return this.xf['@@transducer/result'](result);
        };
        XAny.prototype['@@transducer/step'] = function (result, input) {
            if (this.f(input)) {
                this.any = true;
                result = _reduced(this.xf['@@transducer/step'](result, true));
            }
            return result;
        };
        return _curry2(function _xany(f, xf) {
            return new XAny(f, xf);
        });
    }();

    var _xaperture = function () {
        function XAperture(n, xf) {
            this.xf = xf;
            this.pos = 0;
            this.full = false;
            this.acc = new Array(n);
        }
        XAperture.prototype['@@transducer/init'] = _xfBase.init;
        XAperture.prototype['@@transducer/result'] = function (result) {
            this.acc = null;
            return this.xf['@@transducer/result'](result);
        };
        XAperture.prototype['@@transducer/step'] = function (result, input) {
            this.store(input);
            return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;
        };
        XAperture.prototype.store = function (input) {
            this.acc[this.pos] = input;
            this.pos += 1;
            if (this.pos === this.acc.length) {
                this.pos = 0;
                this.full = true;
            }
        };
        XAperture.prototype.getCopy = function () {
            return _concat(_slice(this.acc, this.pos), _slice(this.acc, 0, this.pos));
        };
        return _curry2(function _xaperture(n, xf) {
            return new XAperture(n, xf);
        });
    }();

    var _xdrop = function () {
        function XDrop(n, xf) {
            this.xf = xf;
            this.n = n;
        }
        XDrop.prototype['@@transducer/init'] = _xfBase.init;
        XDrop.prototype['@@transducer/result'] = _xfBase.result;
        XDrop.prototype['@@transducer/step'] = function (result, input) {
            if (this.n > 0) {
                this.n -= 1;
                return result;
            }
            return this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdrop(n, xf) {
            return new XDrop(n, xf);
        });
    }();

    var _xdropLast = function () {
        function XDropLast(n, xf) {
            this.xf = xf;
            this.pos = 0;
            this.full = false;
            this.acc = new Array(n);
        }
        XDropLast.prototype['@@transducer/init'] = _xfBase.init;
        XDropLast.prototype['@@transducer/result'] = function (result) {
            this.acc = null;
            return this.xf['@@transducer/result'](result);
        };
        XDropLast.prototype['@@transducer/step'] = function (result, input) {
            if (this.full) {
                result = this.xf['@@transducer/step'](result, this.acc[this.pos]);
            }
            this.store(input);
            return result;
        };
        XDropLast.prototype.store = function (input) {
            this.acc[this.pos] = input;
            this.pos += 1;
            if (this.pos === this.acc.length) {
                this.pos = 0;
                this.full = true;
            }
        };
        return _curry2(function _xdropLast(n, xf) {
            return new XDropLast(n, xf);
        });
    }();

    var _xdropRepeatsWith = function () {
        function XDropRepeatsWith(pred, xf) {
            this.xf = xf;
            this.pred = pred;
            this.lastValue = undefined;
            this.seenFirstValue = false;
        }
        XDropRepeatsWith.prototype['@@transducer/init'] = function () {
            return this.xf['@@transducer/init']();
        };
        XDropRepeatsWith.prototype['@@transducer/result'] = function (result) {
            return this.xf['@@transducer/result'](result);
        };
        XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
            var sameAsLast = false;
            if (!this.seenFirstValue) {
                this.seenFirstValue = true;
            } else if (this.pred(this.lastValue, input)) {
                sameAsLast = true;
            }
            this.lastValue = input;
            return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdropRepeatsWith(pred, xf) {
            return new XDropRepeatsWith(pred, xf);
        });
    }();

    var _xdropWhile = function () {
        function XDropWhile(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
        XDropWhile.prototype['@@transducer/result'] = _xfBase.result;
        XDropWhile.prototype['@@transducer/step'] = function (result, input) {
            if (this.f) {
                if (this.f(input)) {
                    return result;
                }
                this.f = null;
            }
            return this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdropWhile(f, xf) {
            return new XDropWhile(f, xf);
        });
    }();

    var _xfilter = function () {
        function XFilter(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XFilter.prototype['@@transducer/init'] = _xfBase.init;
        XFilter.prototype['@@transducer/result'] = _xfBase.result;
        XFilter.prototype['@@transducer/step'] = function (result, input) {
            return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
        };
        return _curry2(function _xfilter(f, xf) {
            return new XFilter(f, xf);
        });
    }();

    var _xfind = function () {
        function XFind(f, xf) {
            this.xf = xf;
            this.f = f;
            this.found = false;
        }
        XFind.prototype['@@transducer/init'] = _xfBase.init;
        XFind.prototype['@@transducer/result'] = function (result) {
            if (!this.found) {
                result = this.xf['@@transducer/step'](result, void 0);
            }
            return this.xf['@@transducer/result'](result);
        };
        XFind.prototype['@@transducer/step'] = function (result, input) {
            if (this.f(input)) {
                this.found = true;
                result = _reduced(this.xf['@@transducer/step'](result, input));
            }
            return result;
        };
        return _curry2(function _xfind(f, xf) {
            return new XFind(f, xf);
        });
    }();

    var _xfindIndex = function () {
        function XFindIndex(f, xf) {
            this.xf = xf;
            this.f = f;
            this.idx = -1;
            this.found = false;
        }
        XFindIndex.prototype['@@transducer/init'] = _xfBase.init;
        XFindIndex.prototype['@@transducer/result'] = function (result) {
            if (!this.found) {
                result = this.xf['@@transducer/step'](result, -1);
            }
            return this.xf['@@transducer/result'](result);
        };
        XFindIndex.prototype['@@transducer/step'] = function (result, input) {
            this.idx += 1;
            if (this.f(input)) {
                this.found = true;
                result = _reduced(this.xf['@@transducer/step'](result, this.idx));
            }
            return result;
        };
        return _curry2(function _xfindIndex(f, xf) {
            return new XFindIndex(f, xf);
        });
    }();

    var _xfindLast = function () {
        function XFindLast(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XFindLast.prototype['@@transducer/init'] = _xfBase.init;
        XFindLast.prototype['@@transducer/result'] = function (result) {
            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
        };
        XFindLast.prototype['@@transducer/step'] = function (result, input) {
            if (this.f(input)) {
                this.last = input;
            }
            return result;
        };
        return _curry2(function _xfindLast(f, xf) {
            return new XFindLast(f, xf);
        });
    }();

    var _xfindLastIndex = function () {
        function XFindLastIndex(f, xf) {
            this.xf = xf;
            this.f = f;
            this.idx = -1;
            this.lastIdx = -1;
        }
        XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;
        XFindLastIndex.prototype['@@transducer/result'] = function (result) {
            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
        };
        XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
            this.idx += 1;
            if (this.f(input)) {
                this.lastIdx = this.idx;
            }
            return result;
        };
        return _curry2(function _xfindLastIndex(f, xf) {
            return new XFindLastIndex(f, xf);
        });
    }();

    var _xmap = function () {
        function XMap(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XMap.prototype['@@transducer/init'] = _xfBase.init;
        XMap.prototype['@@transducer/result'] = _xfBase.result;
        XMap.prototype['@@transducer/step'] = function (result, input) {
            return this.xf['@@transducer/step'](result, this.f(input));
        };
        return _curry2(function _xmap(f, xf) {
            return new XMap(f, xf);
        });
    }();

    var _xtake = function () {
        function XTake(n, xf) {
            this.xf = xf;
            this.n = n;
        }
        XTake.prototype['@@transducer/init'] = _xfBase.init;
        XTake.prototype['@@transducer/result'] = _xfBase.result;
        XTake.prototype['@@transducer/step'] = function (result, input) {
            if (this.n === 0) {
                return _reduced(result);
            } else {
                this.n -= 1;
                return this.xf['@@transducer/step'](result, input);
            }
        };
        return _curry2(function _xtake(n, xf) {
            return new XTake(n, xf);
        });
    }();

    var _xtakeWhile = function () {
        function XTakeWhile(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
        XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;
        XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
            return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
        };
        return _curry2(function _xtakeWhile(f, xf) {
            return new XTakeWhile(f, xf);
        });
    }();

    /**
     * Adds two values.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a
     * @param {Number} b
     * @return {Number}
     * @see R.subtract
     * @example
     *
     *      R.add(2, 3);       //=>  5
     *      R.add(7)(10);      //=> 17
     */
    var add = _curry2(function add(a, b) {
        return Number(a) + Number(b);
    });

    /**
     * Applies a function to the value at the given index of an array, returning a
     * new copy of the array with the element at the given index replaced with the
     * result of the function application.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig (a -> a) -> Number -> [a] -> [a]
     * @param {Function} fn The function to apply.
     * @param {Number} idx The index.
     * @param {Array|Arguments} list An array-like object whose value
     *        at the supplied index will be replaced.
     * @return {Array} A copy of the supplied array-like object with
     *         the element at index `idx` replaced with the value
     *         returned by applying `fn` to the existing element.
     * @see R.update
     * @example
     *
     *      R.adjust(R.add(10), 1, [0, 1, 2]);     //=> [0, 11, 2]
     *      R.adjust(R.add(10))(1)([0, 1, 2]);     //=> [0, 11, 2]
     */
    var adjust = _curry3(function adjust(fn, idx, list) {
        if (idx >= list.length || idx < -list.length) {
            return list;
        }
        var start = idx < 0 ? list.length : 0;
        var _idx = start + idx;
        var _list = _concat(list);
        _list[_idx] = fn(list[_idx]);
        return _list;
    });

    /**
     * Returns `true` if all elements of the list match the predicate, `false` if
     * there are any that don't.
     *
     * Dispatches to the `all` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> Boolean
     * @param {Function} fn The predicate function.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
     *         otherwise.
     * @see R.any, R.none, R.transduce
     * @example
     *
     *      var lessThan2 = R.flip(R.lt)(2);
     *      var lessThan3 = R.flip(R.lt)(3);
     *      R.all(lessThan2)([1, 2]); //=> false
     *      R.all(lessThan3)([1, 2]); //=> true
     */
    var all = _curry2(_dispatchable('all', _xall, function all(fn, list) {
        var idx = 0;
        while (idx < list.length) {
            if (!fn(list[idx])) {
                return false;
            }
            idx += 1;
        }
        return true;
    }));

    /**
     * Returns a function that always returns the given value. Note that for
     * non-primitives the value returned is a reference to the original value.
     *
     * This function is known as `const`, `constant`, or `K` (for K combinator) in
     * other languages and libraries.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig a -> (* -> a)
     * @param {*} val The value to wrap in a function
     * @return {Function} A Function :: * -> val.
     * @example
     *
     *      var t = R.always('Tee');
     *      t(); //=> 'Tee'
     */
    var always = _curry1(function always(val) {
        return function () {
            return val;
        };
    });

    /**
     * Returns `true` if both arguments are `true`; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Logic
     * @sig * -> * -> *
     * @param {Boolean} a A boolean value
     * @param {Boolean} b A boolean value
     * @return {Boolean} `true` if both arguments are `true`, `false` otherwise
     * @see R.both
     * @example
     *
     *      R.and(true, true); //=> true
     *      R.and(true, false); //=> false
     *      R.and(false, true); //=> false
     *      R.and(false, false); //=> false
     */
    var and = _curry2(function and(a, b) {
        return a && b;
    });

    /**
     * Returns `true` if at least one of elements of the list match the predicate,
     * `false` otherwise.
     *
     * Dispatches to the `any` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> Boolean
     * @param {Function} fn The predicate function.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
     *         otherwise.
     * @see R.all, R.none, R.transduce
     * @example
     *
     *      var lessThan0 = R.flip(R.lt)(0);
     *      var lessThan2 = R.flip(R.lt)(2);
     *      R.any(lessThan0)([1, 2]); //=> false
     *      R.any(lessThan2)([1, 2]); //=> true
     */
    var any = _curry2(_dispatchable('any', _xany, function any(fn, list) {
        var idx = 0;
        while (idx < list.length) {
            if (fn(list[idx])) {
                return true;
            }
            idx += 1;
        }
        return false;
    }));

    /**
     * Returns a new list, composed of n-tuples of consecutive elements If `n` is
     * greater than the length of the list, an empty list is returned.
     *
     * Dispatches to the `aperture` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category List
     * @sig Number -> [a] -> [[a]]
     * @param {Number} n The size of the tuples to create
     * @param {Array} list The list to split into `n`-tuples
     * @return {Array} The new list.
     * @see R.transduce
     * @example
     *
     *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
     *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
     *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
     */
    var aperture = _curry2(_dispatchable('aperture', _xaperture, _aperture));

    /**
     * Returns a new list containing the contents of the given list, followed by
     * the given element.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> [a]
     * @param {*} el The element to add to the end of the new list.
     * @param {Array} list The list whose contents will be added to the beginning of the output
     *        list.
     * @return {Array} A new list containing the contents of the old list followed by `el`.
     * @see R.prepend
     * @example
     *
     *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
     *      R.append('tests', []); //=> ['tests']
     *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
     */
    var append = _curry2(function append(el, list) {
        return _concat(list, [el]);
    });

    /**
     * Applies function `fn` to the argument list `args`. This is useful for
     * creating a fixed-arity function from a variadic function. `fn` should be a
     * bound function if context is significant.
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Function
     * @sig (*... -> a) -> [*] -> a
     * @param {Function} fn
     * @param {Array} args
     * @return {*}
     * @see R.call, R.unapply
     * @example
     *
     *      var nums = [1, 2, 3, -99, 42, 6, 7];
     *      R.apply(Math.max, nums); //=> 42
     */
    var apply = _curry2(function apply(fn, args) {
        return fn.apply(this, args);
    });

    /**
     * Makes a shallow clone of an object, setting or overriding the specified
     * property with the given value. Note that this copies and flattens prototype
     * properties onto the new object as well. All non-primitive properties are
     * copied by reference.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @sig String -> a -> {k: v} -> {k: v}
     * @param {String} prop the property name to set
     * @param {*} val the new value
     * @param {Object} obj the object to clone
     * @return {Object} a new object similar to the original except for the specified property.
     * @see R.dissoc
     * @example
     *
     *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
     */
    var assoc = _curry3(function assoc(prop, val, obj) {
        var result = {};
        for (var p in obj) {
            result[p] = obj[p];
        }
        result[prop] = val;
        return result;
    });

    /**
     * Makes a shallow clone of an object, setting or overriding the nodes required
     * to create the given path, and placing the specific value at the tail end of
     * that path. Note that this copies and flattens prototype properties onto the
     * new object as well. All non-primitive properties are copied by reference.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @sig [String] -> a -> {k: v} -> {k: v}
     * @param {Array} path the path to set
     * @param {*} val the new value
     * @param {Object} obj the object to clone
     * @return {Object} a new object similar to the original except along the specified path.
     * @see R.dissocPath
     * @example
     *
     *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
     */
    var assocPath = _curry3(function assocPath(path, val, obj) {
        switch (path.length) {
        case 0:
            return val;
        case 1:
            return assoc(path[0], val, obj);
        default:
            return assoc(path[0], assocPath(_slice(path, 1), val, Object(obj[path[0]])), obj);
        }
    });

    /**
     * Creates a function that is bound to a context.
     * Note: `R.bind` does not provide the additional argument-binding capabilities of
     * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category Function
     * @category Object
     * @sig (* -> *) -> {*} -> (* -> *)
     * @param {Function} fn The function to bind to context
     * @param {Object} thisObj The context to bind `fn` to
     * @return {Function} A function that will execute in the context of `thisObj`.
     * @see R.partial
     */
    var bind = _curry2(function bind(fn, thisObj) {
        return _arity(fn.length, function () {
            return fn.apply(thisObj, arguments);
        });
    });

    /**
     * Restricts a number to be within a range.
     *
     * Also works for other ordered types such as Strings and Dates.
     *
     * @func
     * @memberOf R
     * @since v0.20.0
     * @category Relation
     * @sig Ord a => a -> a -> a -> a
     * @param {Number} minimum number
     * @param {Number} maximum number
     * @param {Number} value to be clamped
     * @return {Number} Returns the clamped value
     * @example
     *
     *      R.clamp(1, 10, -1) // => 1
     *      R.clamp(1, 10, 11) // => 10
     *      R.clamp(1, 10, 4)  // => 4
     */
    var clamp = _curry3(function clamp(min, max, value) {
        if (min > max) {
            throw new Error('min must not be greater than max in clamp(min, max, value)');
        }
        return value < min ? min : value > max ? max : value;
    });

    /**
     * Makes a comparator function out of a function that reports whether the first
     * element is less than the second.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a, b -> Boolean) -> (a, b -> Number)
     * @param {Function} pred A predicate function of arity two.
     * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`.
     * @example
     *
     *      var cmp = R.comparator((a, b) => a.age < b.age);
     *      var people = [
     *        // ...
     *      ];
     *      R.sort(cmp, people);
     */
    var comparator = _curry1(function comparator(pred) {
        return function (a, b) {
            return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
        };
    });

    /**
     * Returns a curried equivalent of the provided function, with the specified
     * arity. The curried function has two unusual capabilities. First, its
     * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
     * following are equivalent:
     *
     *   - `g(1)(2)(3)`
     *   - `g(1)(2, 3)`
     *   - `g(1, 2)(3)`
     *   - `g(1, 2, 3)`
     *
     * Secondly, the special placeholder value `R.__` may be used to specify
     * "gaps", allowing partial application of any combination of arguments,
     * regardless of their positions. If `g` is as above and `_` is `R.__`, the
     * following are equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @func
     * @memberOf R
     * @since v0.5.0
     * @category Function
     * @sig Number -> (* -> a) -> (* -> a)
     * @param {Number} length The arity for the returned function.
     * @param {Function} fn The function to curry.
     * @return {Function} A new, curried function.
     * @see R.curry
     * @example
     *
     *      var sumArgs = (...args) => R.sum(args);
     *
     *      var curriedAddFourNumbers = R.curryN(4, sumArgs);
     *      var f = curriedAddFourNumbers(1, 2);
     *      var g = f(3);
     *      g(4); //=> 10
     */
    var curryN = _curry2(function curryN(length, fn) {
        if (length === 1) {
            return _curry1(fn);
        }
        return _arity(length, _curryN(length, [], fn));
    });

    /**
     * Decrements its argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Math
     * @sig Number -> Number
     * @param {Number} n
     * @return {Number}
     * @see R.inc
     * @example
     *
     *      R.dec(42); //=> 41
     */
    var dec = add(-1);

    /**
     * Returns the second argument if it is not `null`, `undefined` or `NaN`
     * otherwise the first argument is returned.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Logic
     * @sig a -> b -> a | b
     * @param {a} val The default value.
     * @param {b} val The value to return if it is not null or undefined
     * @return {*} The the second value or the default value
     * @example
     *
     *      var defaultTo42 = R.defaultTo(42);
     *
     *      defaultTo42(null);  //=> 42
     *      defaultTo42(undefined);  //=> 42
     *      defaultTo42('Ramda');  //=> 'Ramda'
     *      defaultTo42(parseInt('string')); //=> 42
     */
    var defaultTo = _curry2(function defaultTo(d, v) {
        return v == null || v !== v ? d : v;
    });

    /**
     * Finds the set (i.e. no duplicates) of all elements in the first list not
     * contained in the second list. Duplication is determined according to the
     * value returned by applying the supplied predicate to two list elements.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The elements in `list1` that are not in `list2`.
     * @see R.difference
     * @example
     *
     *      var cmp = (x, y) => x.a === y.a;
     *      var l1 = [{a: 1}, {a: 2}, {a: 3}];
     *      var l2 = [{a: 3}, {a: 4}];
     *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
     */
    var differenceWith = _curry3(function differenceWith(pred, first, second) {
        var out = [];
        var idx = 0;
        var firstLen = first.length;
        while (idx < firstLen) {
            if (!_containsWith(pred, first[idx], second) && !_containsWith(pred, first[idx], out)) {
                out.push(first[idx]);
            }
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a new object that does not contain a `prop` property.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Object
     * @sig String -> {k: v} -> {k: v}
     * @param {String} prop the name of the property to dissociate
     * @param {Object} obj the object to clone
     * @return {Object} a new object similar to the original but without the specified property
     * @see R.assoc
     * @example
     *
     *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
     */
    var dissoc = _curry2(function dissoc(prop, obj) {
        var result = {};
        for (var p in obj) {
            if (p !== prop) {
                result[p] = obj[p];
            }
        }
        return result;
    });

    /**
     * Makes a shallow clone of an object, omitting the property at the given path.
     * Note that this copies and flattens prototype properties onto the new object
     * as well. All non-primitive properties are copied by reference.
     *
     * @func
     * @memberOf R
     * @since v0.11.0
     * @category Object
     * @sig [String] -> {k: v} -> {k: v}
     * @param {Array} path the path to set
     * @param {Object} obj the object to clone
     * @return {Object} a new object without the property at path
     * @see R.assocPath
     * @example
     *
     *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
     */
    var dissocPath = _curry2(function dissocPath(path, obj) {
        switch (path.length) {
        case 0:
            return obj;
        case 1:
            return dissoc(path[0], obj);
        default:
            var head = path[0];
            var tail = _slice(path, 1);
            return obj[head] == null ? obj : assoc(head, dissocPath(tail, obj[head]), obj);
        }
    });

    /**
     * Divides two numbers. Equivalent to `a / b`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The first value.
     * @param {Number} b The second value.
     * @return {Number} The result of `a / b`.
     * @see R.multiply
     * @example
     *
     *      R.divide(71, 100); //=> 0.71
     *
     *      var half = R.divide(R.__, 2);
     *      half(42); //=> 21
     *
     *      var reciprocal = R.divide(1);
     *      reciprocal(4);   //=> 0.25
     */
    var divide = _curry2(function divide(a, b) {
        return a / b;
    });

    /**
     * Returns a new list containing the last `n` elements of a given list, passing
     * each value to the supplied predicate function, skipping elements while the
     * predicate function returns `true`. The predicate function is passed one
     * argument: *(value)*.
     *
     * Dispatches to the `dropWhile` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.takeWhile, R.transduce, R.addIndex
     * @example
     *
     *      var lteTwo = x => x <= 2;
     *
     *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
     */
    var dropWhile = _curry2(_dispatchable('dropWhile', _xdropWhile, function dropWhile(pred, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len && pred(list[idx])) {
            idx += 1;
        }
        return _slice(list, idx);
    }));

    /**
     * Returns the empty value of its argument's type. Ramda defines the empty
     * value of Array (`[]`), Object (`{}`), String (`''`), and Arguments. Other
     * types are supported if they define `<Type>.empty` and/or
     * `<Type>.prototype.empty`.
     *
     * Dispatches to the `empty` method of the first argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Function
     * @sig a -> a
     * @param {*} x
     * @return {*}
     * @example
     *
     *      R.empty(Just(42));      //=> Nothing()
     *      R.empty([1, 2, 3]);     //=> []
     *      R.empty('unicorns');    //=> ''
     *      R.empty({x: 1, y: 2});  //=> {}
     */
    // else
    var empty = _curry1(function empty(x) {
        return x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? '' : _isObject(x) ? {} : _isArguments(x) ? function () {
            return arguments;
        }() : // else
        void 0;
    });

    /**
     * Creates a new object by recursively evolving a shallow copy of `object`,
     * according to the `transformation` functions. All non-primitive properties
     * are copied by reference.
     *
     * A `transformation` function will not be invoked if its corresponding key
     * does not exist in the evolved object.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Object
     * @sig {k: (v -> v)} -> {k: v} -> {k: v}
     * @param {Object} transformations The object specifying transformation functions to apply
     *        to the object.
     * @param {Object} object The object to be transformed.
     * @return {Object} The transformed object.
     * @example
     *
     *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
     *      var transformations = {
     *        firstName: R.trim,
     *        lastName: R.trim, // Will not get invoked.
     *        data: {elapsed: R.add(1), remaining: R.add(-1)}
     *      };
     *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
     */
    var evolve = _curry2(function evolve(transformations, object) {
        var result = {};
        var transformation, key, type;
        for (key in object) {
            transformation = transformations[key];
            type = typeof transformation;
            result[key] = type === 'function' ? transformation(object[key]) : type === 'object' ? evolve(transformations[key], object[key]) : object[key];
        }
        return result;
    });

    /**
     * Returns the first element of the list which matches the predicate, or
     * `undefined` if no element matches.
     *
     * Dispatches to the `find` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> a | undefined
     * @param {Function} fn The predicate function used to determine if the element is the
     *        desired one.
     * @param {Array} list The array to consider.
     * @return {Object} The element found, or `undefined`.
     * @see R.transduce
     * @example
     *
     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
     *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
     *      R.find(R.propEq('a', 4))(xs); //=> undefined
     */
    var find = _curry2(_dispatchable('find', _xfind, function find(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            if (fn(list[idx])) {
                return list[idx];
            }
            idx += 1;
        }
    }));

    /**
     * Returns the index of the first element of the list which matches the
     * predicate, or `-1` if no element matches.
     *
     * Dispatches to the `findIndex` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> Boolean) -> [a] -> Number
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Number} The index of the element found, or `-1`.
     * @see R.transduce
     * @example
     *
     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
     *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
     *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
     */
    var findIndex = _curry2(_dispatchable('findIndex', _xfindIndex, function findIndex(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            if (fn(list[idx])) {
                return idx;
            }
            idx += 1;
        }
        return -1;
    }));

    /**
     * Returns the last element of the list which matches the predicate, or
     * `undefined` if no element matches.
     *
     * Dispatches to the `findLast` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> Boolean) -> [a] -> a | undefined
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Object} The element found, or `undefined`.
     * @see R.transduce
     * @example
     *
     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
     *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
     *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
     */
    var findLast = _curry2(_dispatchable('findLast', _xfindLast, function findLast(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
            if (fn(list[idx])) {
                return list[idx];
            }
            idx -= 1;
        }
    }));

    /**
     * Returns the index of the last element of the list which matches the
     * predicate, or `-1` if no element matches.
     *
     * Dispatches to the `findLastIndex` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> Boolean) -> [a] -> Number
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Number} The index of the element found, or `-1`.
     * @see R.transduce
     * @example
     *
     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
     *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
     *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
     */
    var findLastIndex = _curry2(_dispatchable('findLastIndex', _xfindLastIndex, function findLastIndex(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
            if (fn(list[idx])) {
                return idx;
            }
            idx -= 1;
        }
        return -1;
    }));

    /**
     * Iterate over an input `list`, calling a provided function `fn` for each
     * element in the list.
     *
     * `fn` receives one argument: *(value)*.
     *
     * Note: `R.forEach` does not skip deleted or unassigned indices (sparse
     * arrays), unlike the native `Array.prototype.forEach` method. For more
     * details on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
     *
     * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns
     * the original array. In some libraries this function is named `each`.
     *
     * Dispatches to the `forEach` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> *) -> [a] -> [a]
     * @param {Function} fn The function to invoke. Receives one argument, `value`.
     * @param {Array} list The list to iterate over.
     * @return {Array} The original list.
     * @see R.addIndex
     * @example
     *
     *      var printXPlusFive = x => console.log(x + 5);
     *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
     *      //-> 6
     *      //-> 7
     *      //-> 8
     */
    var forEach = _curry2(_checkForMethod('forEach', function forEach(fn, list) {
        var len = list.length;
        var idx = 0;
        while (idx < len) {
            fn(list[idx]);
            idx += 1;
        }
        return list;
    }));

    /**
     * Creates a new object out of a list key-value pairs.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig [[k,v]] -> {k: v}
     * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
     * @return {Object} The object made by pairing up `keys` and `values`.
     * @see R.toPairs, R.pair
     * @example
     *
     *      R.fromPairs([['a', 1], ['b', 2],  ['c', 3]]); //=> {a: 1, b: 2, c: 3}
     */
    var fromPairs = _curry1(function fromPairs(pairs) {
        var idx = 0;
        var len = pairs.length;
        var out = {};
        while (idx < len) {
            if (_isArray(pairs[idx]) && pairs[idx].length) {
                out[pairs[idx][0]] = pairs[idx][1];
            }
            idx += 1;
        }
        return out;
    });

    /**
     * Takes a list and returns a list of lists where each sublist's elements are
     * all "equal" according to the provided equality function.
     *
     * @func
     * @memberOf R
     * @since v0.21.0
     * @category List
     * @sig (a, a -> Boolean) -> [a] -> [[a]]
     * @param {Function} fn Function for determining whether two given (adjacent)
     *        elements should be in the same group
     * @param {Array} list The array to group. Also accepts a string, which will be
     *        treated as a list of characters.
     * @return {List} A list that contains sublists of equal elements,
     *         whose concatenations is equal to the original list.
     * @example
     *
     *    groupWith(R.equals, [0, 1, 1, 2, 3, 5, 8, 13, 21])
     *    // [[0], [1, 1], [2, 3, 5, 8, 13, 21]]
     *
     *    groupWith((a, b) => a % 2 === b % 2, [0, 1, 1, 2, 3, 5, 8, 13, 21])
     *    // [[0], [1, 1], [2], [3, 5], [8], [13, 21]]
     *
     *    R.groupWith(R.eqBy(isVowel), 'aestiou')
     *    // ['ae', 'st', 'iou']
     */
    var groupWith = _curry2(function (fn, list) {
        var res = [];
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            var nextidx = idx + 1;
            while (nextidx < len && fn(list[idx], list[nextidx])) {
                nextidx += 1;
            }
            res.push(list.slice(idx, nextidx));
            idx = nextidx;
        }
        return res;
    });

    /**
     * Returns `true` if the first argument is greater than the second; `false`
     * otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @see R.lt
     * @example
     *
     *      R.gt(2, 1); //=> true
     *      R.gt(2, 2); //=> false
     *      R.gt(2, 3); //=> false
     *      R.gt('a', 'z'); //=> false
     *      R.gt('z', 'a'); //=> true
     */
    var gt = _curry2(function gt(a, b) {
        return a > b;
    });

    /**
     * Returns `true` if the first argument is greater than or equal to the second;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {Number} a
     * @param {Number} b
     * @return {Boolean}
     * @see R.lte
     * @example
     *
     *      R.gte(2, 1); //=> true
     *      R.gte(2, 2); //=> true
     *      R.gte(2, 3); //=> false
     *      R.gte('a', 'z'); //=> false
     *      R.gte('z', 'a'); //=> true
     */
    var gte = _curry2(function gte(a, b) {
        return a >= b;
    });

    /**
     * Returns whether or not an object has an own property with the specified name
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Object
     * @sig s -> {s: x} -> Boolean
     * @param {String} prop The name of the property to check for.
     * @param {Object} obj The object to query.
     * @return {Boolean} Whether the property exists.
     * @example
     *
     *      var hasName = R.has('name');
     *      hasName({name: 'alice'});   //=> true
     *      hasName({name: 'bob'});     //=> true
     *      hasName({});                //=> false
     *
     *      var point = {x: 0, y: 0};
     *      var pointHas = R.has(R.__, point);
     *      pointHas('x');  //=> true
     *      pointHas('y');  //=> true
     *      pointHas('z');  //=> false
     */
    var has = _curry2(_has);

    /**
     * Returns whether or not an object or its prototype chain has a property with
     * the specified name
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Object
     * @sig s -> {s: x} -> Boolean
     * @param {String} prop The name of the property to check for.
     * @param {Object} obj The object to query.
     * @return {Boolean} Whether the property exists.
     * @example
     *
     *      function Rectangle(width, height) {
     *        this.width = width;
     *        this.height = height;
     *      }
     *      Rectangle.prototype.area = function() {
     *        return this.width * this.height;
     *      };
     *
     *      var square = new Rectangle(2, 2);
     *      R.hasIn('width', square);  //=> true
     *      R.hasIn('area', square);  //=> true
     */
    var hasIn = _curry2(function hasIn(prop, obj) {
        return prop in obj;
    });

    /**
     * Returns true if its arguments are identical, false otherwise. Values are
     * identical if they reference the same memory. `NaN` is identical to `NaN`;
     * `0` and `-0` are not identical.
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category Relation
     * @sig a -> a -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @example
     *
     *      var o = {};
     *      R.identical(o, o); //=> true
     *      R.identical(1, 1); //=> true
     *      R.identical(1, '1'); //=> false
     *      R.identical([], []); //=> false
     *      R.identical(0, -0); //=> false
     *      R.identical(NaN, NaN); //=> true
     */
    // SameValue algorithm
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Step 6.a: NaN == NaN
    var identical = _curry2(function identical(a, b) {
        // SameValue algorithm
        if (a === b) {
            // Steps 1-5, 7-10
            // Steps 6.b-6.e: +0 != -0
            return a !== 0 || 1 / a === 1 / b;
        } else {
            // Step 6.a: NaN == NaN
            return a !== a && b !== b;
        }
    });

    /**
     * A function that does nothing but return the parameter supplied to it. Good
     * as a default or placeholder function.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig a -> a
     * @param {*} x The value to return.
     * @return {*} The input value, `x`.
     * @example
     *
     *      R.identity(1); //=> 1
     *
     *      var obj = {};
     *      R.identity(obj) === obj; //=> true
     */
    var identity = _curry1(_identity);

    /**
     * Creates a function that will process either the `onTrue` or the `onFalse`
     * function depending upon the result of the `condition` predicate.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Logic
     * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
     * @param {Function} condition A predicate function
     * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
     * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
     * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`
     *                    function depending upon the result of the `condition` predicate.
     * @see R.unless, R.when
     * @example
     *
     *      var incCount = R.ifElse(
     *        R.has('count'),
     *        R.over(R.lensProp('count'), R.inc),
     *        R.assoc('count', 1)
     *      );
     *      incCount({});           //=> { count: 1 }
     *      incCount({ count: 1 }); //=> { count: 2 }
     */
    var ifElse = _curry3(function ifElse(condition, onTrue, onFalse) {
        return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
            return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
        });
    });

    /**
     * Increments its argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Math
     * @sig Number -> Number
     * @param {Number} n
     * @return {Number}
     * @see R.dec
     * @example
     *
     *      R.inc(42); //=> 43
     */
    var inc = add(1);

    /**
     * Inserts the supplied element into the list, at index `index`. _Note that
     * this is not destructive_: it returns a copy of the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @since v0.2.2
     * @category List
     * @sig Number -> a -> [a] -> [a]
     * @param {Number} index The position to insert the element
     * @param {*} elt The element to insert into the Array
     * @param {Array} list The list to insert into
     * @return {Array} A new Array with `elt` inserted at `index`.
     * @example
     *
     *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
     */
    var insert = _curry3(function insert(idx, elt, list) {
        idx = idx < list.length && idx >= 0 ? idx : list.length;
        var result = _slice(list);
        result.splice(idx, 0, elt);
        return result;
    });

    /**
     * Inserts the sub-list into the list, at index `index`. _Note that this is not
     * destructive_: it returns a copy of the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category List
     * @sig Number -> [a] -> [a] -> [a]
     * @param {Number} index The position to insert the sub-list
     * @param {Array} elts The sub-list to insert into the Array
     * @param {Array} list The list to insert the sub-list into
     * @return {Array} A new Array with `elts` inserted starting at `index`.
     * @example
     *
     *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
     */
    var insertAll = _curry3(function insertAll(idx, elts, list) {
        idx = idx < list.length && idx >= 0 ? idx : list.length;
        return _concat(_concat(_slice(list, 0, idx), elts), _slice(list, idx));
    });

    /**
     * Creates a new list with the separator interposed between elements.
     *
     * Dispatches to the `intersperse` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig a -> [a] -> [a]
     * @param {*} separator The element to add to the list.
     * @param {Array} list The list to be interposed.
     * @return {Array} The new list.
     * @example
     *
     *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']
     */
    var intersperse = _curry2(_checkForMethod('intersperse', function intersperse(separator, list) {
        var out = [];
        var idx = 0;
        var length = list.length;
        while (idx < length) {
            if (idx === length - 1) {
                out.push(list[idx]);
            } else {
                out.push(list[idx], separator);
            }
            idx += 1;
        }
        return out;
    }));

    /**
     * See if an object (`val`) is an instance of the supplied constructor. This
     * function will check up the inheritance chain, if any.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Type
     * @sig (* -> {*}) -> a -> Boolean
     * @param {Object} ctor A constructor
     * @param {*} val The value to test
     * @return {Boolean}
     * @example
     *
     *      R.is(Object, {}); //=> true
     *      R.is(Number, 1); //=> true
     *      R.is(Object, 1); //=> false
     *      R.is(String, 's'); //=> true
     *      R.is(String, new String('')); //=> true
     *      R.is(Object, new String('')); //=> true
     *      R.is(Object, 's'); //=> false
     *      R.is(Number, {}); //=> false
     */
    var is = _curry2(function is(Ctor, val) {
        return val != null && val.constructor === Ctor || val instanceof Ctor;
    });

    /**
     * Tests whether or not an object is similar to an array.
     *
     * @func
     * @memberOf R
     * @since v0.5.0
     * @category Type
     * @category List
     * @sig * -> Boolean
     * @param {*} x The object to test.
     * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
     * @example
     *
     *      R.isArrayLike([]); //=> true
     *      R.isArrayLike(true); //=> false
     *      R.isArrayLike({}); //=> false
     *      R.isArrayLike({length: 10}); //=> false
     *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
     */
    var isArrayLike = _curry1(function isArrayLike(x) {
        if (_isArray(x)) {
            return true;
        }
        if (!x) {
            return false;
        }
        if (typeof x !== 'object') {
            return false;
        }
        if (x instanceof String) {
            return false;
        }
        if (x.nodeType === 1) {
            return !!x.length;
        }
        if (x.length === 0) {
            return true;
        }
        if (x.length > 0) {
            return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
        }
        return false;
    });

    /**
     * Checks if the input value is `null` or `undefined`.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Type
     * @sig * -> Boolean
     * @param {*} x The value to test.
     * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
     * @example
     *
     *      R.isNil(null); //=> true
     *      R.isNil(undefined); //=> true
     *      R.isNil(0); //=> false
     *      R.isNil([]); //=> false
     */
    var isNil = _curry1(function isNil(x) {
        return x == null;
    });

    /**
     * Returns a list containing the names of all the enumerable own properties of
     * the supplied object.
     * Note that the order of the output array is not guaranteed to be consistent
     * across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {k: v} -> [k]
     * @param {Object} obj The object to extract properties from
     * @return {Array} An array of the object's own properties.
     * @example
     *
     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
     */
    // cover IE < 9 keys issues
    // Safari bug
    var keys = function () {
        // cover IE < 9 keys issues
        var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
        var nonEnumerableProps = [
            'constructor',
            'valueOf',
            'isPrototypeOf',
            'toString',
            'propertyIsEnumerable',
            'hasOwnProperty',
            'toLocaleString'
        ];
        // Safari bug
        var hasArgsEnumBug = function () {
            'use strict';
            return arguments.propertyIsEnumerable('length');
        }();
        var contains = function contains(list, item) {
            var idx = 0;
            while (idx < list.length) {
                if (list[idx] === item) {
                    return true;
                }
                idx += 1;
            }
            return false;
        };
        return typeof Object.keys === 'function' && !hasArgsEnumBug ? _curry1(function keys(obj) {
            return Object(obj) !== obj ? [] : Object.keys(obj);
        }) : _curry1(function keys(obj) {
            if (Object(obj) !== obj) {
                return [];
            }
            var prop, nIdx;
            var ks = [];
            var checkArgsLength = hasArgsEnumBug && _isArguments(obj);
            for (prop in obj) {
                if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
                    ks[ks.length] = prop;
                }
            }
            if (hasEnumBug) {
                nIdx = nonEnumerableProps.length - 1;
                while (nIdx >= 0) {
                    prop = nonEnumerableProps[nIdx];
                    if (_has(prop, obj) && !contains(ks, prop)) {
                        ks[ks.length] = prop;
                    }
                    nIdx -= 1;
                }
            }
            return ks;
        });
    }();

    /**
     * Returns a list containing the names of all the properties of the supplied
     * object, including prototype properties.
     * Note that the order of the output array is not guaranteed to be consistent
     * across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Object
     * @sig {k: v} -> [k]
     * @param {Object} obj The object to extract properties from
     * @return {Array} An array of the object's own and prototype properties.
     * @example
     *
     *      var F = function() { this.x = 'X'; };
     *      F.prototype.y = 'Y';
     *      var f = new F();
     *      R.keysIn(f); //=> ['x', 'y']
     */
    var keysIn = _curry1(function keysIn(obj) {
        var prop;
        var ks = [];
        for (prop in obj) {
            ks[ks.length] = prop;
        }
        return ks;
    });

    /**
     * Returns the number of elements in the array by returning `list.length`.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig [a] -> Number
     * @param {Array} list The array to inspect.
     * @return {Number} The length of the array.
     * @example
     *
     *      R.length([]); //=> 0
     *      R.length([1, 2, 3]); //=> 3
     */
    var length = _curry1(function length(list) {
        return list != null && is(Number, list.length) ? list.length : NaN;
    });

    /**
     * Returns `true` if the first argument is less than the second; `false`
     * otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @see R.gt
     * @example
     *
     *      R.lt(2, 1); //=> false
     *      R.lt(2, 2); //=> false
     *      R.lt(2, 3); //=> true
     *      R.lt('a', 'z'); //=> true
     *      R.lt('z', 'a'); //=> false
     */
    var lt = _curry2(function lt(a, b) {
        return a < b;
    });

    /**
     * Returns `true` if the first argument is less than or equal to the second;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {Number} a
     * @param {Number} b
     * @return {Boolean}
     * @see R.gte
     * @example
     *
     *      R.lte(2, 1); //=> false
     *      R.lte(2, 2); //=> true
     *      R.lte(2, 3); //=> true
     *      R.lte('a', 'z'); //=> true
     *      R.lte('z', 'a'); //=> false
     */
    var lte = _curry2(function lte(a, b) {
        return a <= b;
    });

    /**
     * The mapAccum function behaves like a combination of map and reduce; it
     * applies a function to each element of a list, passing an accumulating
     * parameter from left to right, and returning a final value of this
     * accumulator together with the new list.
     *
     * The iterator function receives two arguments, *acc* and *value*, and should
     * return a tuple *[acc, value]*.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
     * @param {Function} fn The function to be called on every element of the input `list`.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.addIndex
     * @example
     *
     *      var digits = ['1', '2', '3', '4'];
     *      var appender = (a, b) => [a + b, a + b];
     *
     *      R.mapAccum(appender, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
     */
    var mapAccum = _curry3(function mapAccum(fn, acc, list) {
        var idx = 0;
        var len = list.length;
        var result = [];
        var tuple = [acc];
        while (idx < len) {
            tuple = fn(tuple[0], list[idx]);
            result[idx] = tuple[1];
            idx += 1;
        }
        return [
            tuple[0],
            result
        ];
    });

    /**
     * The mapAccumRight function behaves like a combination of map and reduce; it
     * applies a function to each element of a list, passing an accumulating
     * parameter from right to left, and returning a final value of this
     * accumulator together with the new list.
     *
     * Similar to `mapAccum`, except moves through the input list from the right to
     * the left.
     *
     * The iterator function receives two arguments, *acc* and *value*, and should
     * return a tuple *[acc, value]*.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
     * @param {Function} fn The function to be called on every element of the input `list`.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.addIndex
     * @example
     *
     *      var digits = ['1', '2', '3', '4'];
     *      var append = (a, b) => [a + b, a + b];
     *
     *      R.mapAccumRight(append, 0, digits); //=> ['04321', ['04321', '0432', '043', '04']]
     */
    var mapAccumRight = _curry3(function mapAccumRight(fn, acc, list) {
        var idx = list.length - 1;
        var result = [];
        var tuple = [acc];
        while (idx >= 0) {
            tuple = fn(tuple[0], list[idx]);
            result[idx] = tuple[1];
            idx -= 1;
        }
        return [
            tuple[0],
            result
        ];
    });

    /**
     * Tests a regular expression against a String. Note that this function will
     * return an empty array when there are no matches. This differs from
     * [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
     * which returns `null` when there are no matches.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category String
     * @sig RegExp -> String -> [String | Undefined]
     * @param {RegExp} rx A regular expression.
     * @param {String} str The string to match against
     * @return {Array} The list of matches or empty array.
     * @see R.test
     * @example
     *
     *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
     *      R.match(/a/, 'b'); //=> []
     *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
     */
    var match = _curry2(function match(rx, str) {
        return str.match(rx) || [];
    });

    /**
     * mathMod behaves like the modulo operator should mathematically, unlike the
     * `%` operator (and by extension, R.modulo). So while "-17 % 5" is -2,
     * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN
     * when the modulus is zero or negative.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} m The dividend.
     * @param {Number} p the modulus.
     * @return {Number} The result of `b mod a`.
     * @example
     *
     *      R.mathMod(-17, 5);  //=> 3
     *      R.mathMod(17, 5);   //=> 2
     *      R.mathMod(17, -5);  //=> NaN
     *      R.mathMod(17, 0);   //=> NaN
     *      R.mathMod(17.2, 5); //=> NaN
     *      R.mathMod(17, 5.3); //=> NaN
     *
     *      var clock = R.mathMod(R.__, 12);
     *      clock(15); //=> 3
     *      clock(24); //=> 0
     *
     *      var seventeenMod = R.mathMod(17);
     *      seventeenMod(3);  //=> 2
     *      seventeenMod(4);  //=> 1
     *      seventeenMod(10); //=> 7
     */
    var mathMod = _curry2(function mathMod(m, p) {
        if (!_isInteger(m)) {
            return NaN;
        }
        if (!_isInteger(p) || p < 1) {
            return NaN;
        }
        return (m % p + p) % p;
    });

    /**
     * Returns the larger of its two arguments.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> a
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.maxBy, R.min
     * @example
     *
     *      R.max(789, 123); //=> 789
     *      R.max('a', 'b'); //=> 'b'
     */
    var max = _curry2(function max(a, b) {
        return b > a ? b : a;
    });

    /**
     * Takes a function and two values, and returns whichever value produces the
     * larger result when passed to the provided function.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Relation
     * @sig Ord b => (a -> b) -> a -> a -> a
     * @param {Function} f
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.max, R.minBy
     * @example
     *
     *      //  square :: Number -> Number
     *      var square = n => n * n;
     *
     *      R.maxBy(square, -3, 2); //=> -3
     *
     *      R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); //=> -5
     *      R.reduce(R.maxBy(square), 0, []); //=> 0
     */
    var maxBy = _curry3(function maxBy(f, a, b) {
        return f(b) > f(a) ? b : a;
    });

    /**
     * Create a new object with the own properties of the first object merged with
     * the own properties of the second object. If a key exists in both objects,
     * the value from the second object will be used.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {k: v} -> {k: v} -> {k: v}
     * @param {Object} l
     * @param {Object} r
     * @return {Object}
     * @see R.mergeWith, R.mergeWithKey
     * @example
     *
     *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
     *      //=> { 'name': 'fred', 'age': 40 }
     *
     *      var resetToDefault = R.merge(R.__, {x: 0});
     *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
     */
    var merge = _curry2(function merge(l, r) {
        return _assign({}, l, r);
    });

    /**
     * Merges a list of objects together into one object.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig [{k: v}] -> {k: v}
     * @param {Array} list An array of objects
     * @return {Object} A merged object.
     * @see R.reduce
     * @example
     *
     *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
     *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
     */
    var mergeAll = _curry1(function mergeAll(list) {
        return _assign.apply(null, [{}].concat(list));
    });

    /**
     * Creates a new object with the own properties of the two provided objects. If
     * a key exists in both objects, the provided function is applied to the key
     * and the values associated with the key in each object, with the result being
     * used as the value associated with the key in the returned object. The key
     * will be excluded from the returned object if the resulting value is
     * `undefined`.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Object
     * @sig (String -> a -> a -> a) -> {a} -> {a} -> {a}
     * @param {Function} fn
     * @param {Object} l
     * @param {Object} r
     * @return {Object}
     * @see R.merge, R.mergeWith
     * @example
     *
     *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
     *      R.mergeWithKey(concatValues,
     *                     { a: true, thing: 'foo', values: [10, 20] },
     *                     { b: true, thing: 'bar', values: [15, 35] });
     *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }
     */
    var mergeWithKey = _curry3(function mergeWithKey(fn, l, r) {
        var result = {};
        var k;
        for (k in l) {
            if (_has(k, l)) {
                result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
            }
        }
        for (k in r) {
            if (_has(k, r) && !_has(k, result)) {
                result[k] = r[k];
            }
        }
        return result;
    });

    /**
     * Returns the smaller of its two arguments.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> a
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.minBy, R.max
     * @example
     *
     *      R.min(789, 123); //=> 123
     *      R.min('a', 'b'); //=> 'a'
     */
    var min = _curry2(function min(a, b) {
        return b < a ? b : a;
    });

    /**
     * Takes a function and two values, and returns whichever value produces the
     * smaller result when passed to the provided function.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Relation
     * @sig Ord b => (a -> b) -> a -> a -> a
     * @param {Function} f
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.min, R.maxBy
     * @example
     *
     *      //  square :: Number -> Number
     *      var square = n => n * n;
     *
     *      R.minBy(square, -3, 2); //=> 2
     *
     *      R.reduce(R.minBy(square), Infinity, [3, -5, 4, 1, -2]); //=> 1
     *      R.reduce(R.minBy(square), Infinity, []); //=> Infinity
     */
    var minBy = _curry3(function minBy(f, a, b) {
        return f(b) < f(a) ? b : a;
    });

    /**
     * Divides the second parameter by the first and returns the remainder. Note
     * that this function preserves the JavaScript-style behavior for modulo. For
     * mathematical modulo see `mathMod`.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The value to the divide.
     * @param {Number} b The pseudo-modulus
     * @return {Number} The result of `b % a`.
     * @see R.mathMod
     * @example
     *
     *      R.modulo(17, 3); //=> 2
     *      // JS behavior:
     *      R.modulo(-17, 3); //=> -2
     *      R.modulo(17, -3); //=> 2
     *
     *      var isOdd = R.modulo(R.__, 2);
     *      isOdd(42); //=> 0
     *      isOdd(21); //=> 1
     */
    var modulo = _curry2(function modulo(a, b) {
        return a % b;
    });

    /**
     * Multiplies two numbers. Equivalent to `a * b` but curried.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The first value.
     * @param {Number} b The second value.
     * @return {Number} The result of `a * b`.
     * @see R.divide
     * @example
     *
     *      var double = R.multiply(2);
     *      var triple = R.multiply(3);
     *      double(3);       //=>  6
     *      triple(4);       //=> 12
     *      R.multiply(2, 5);  //=> 10
     */
    var multiply = _curry2(function multiply(a, b) {
        return a * b;
    });

    /**
     * Wraps a function of any arity (including nullary) in a function that accepts
     * exactly `n` parameters. Any extraneous parameters will not be passed to the
     * supplied function.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig Number -> (* -> a) -> (* -> a)
     * @param {Number} n The desired arity of the new function.
     * @param {Function} fn The function to wrap.
     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
     *         arity `n`.
     * @example
     *
     *      var takesTwoArgs = (a, b) => [a, b];
     *
     *      takesTwoArgs.length; //=> 2
     *      takesTwoArgs(1, 2); //=> [1, 2]
     *
     *      var takesOneArg = R.nAry(1, takesTwoArgs);
     *      takesOneArg.length; //=> 1
     *      // Only `n` arguments are passed to the wrapped function
     *      takesOneArg(1, 2); //=> [1, undefined]
     */
    var nAry = _curry2(function nAry(n, fn) {
        switch (n) {
        case 0:
            return function () {
                return fn.call(this);
            };
        case 1:
            return function (a0) {
                return fn.call(this, a0);
            };
        case 2:
            return function (a0, a1) {
                return fn.call(this, a0, a1);
            };
        case 3:
            return function (a0, a1, a2) {
                return fn.call(this, a0, a1, a2);
            };
        case 4:
            return function (a0, a1, a2, a3) {
                return fn.call(this, a0, a1, a2, a3);
            };
        case 5:
            return function (a0, a1, a2, a3, a4) {
                return fn.call(this, a0, a1, a2, a3, a4);
            };
        case 6:
            return function (a0, a1, a2, a3, a4, a5) {
                return fn.call(this, a0, a1, a2, a3, a4, a5);
            };
        case 7:
            return function (a0, a1, a2, a3, a4, a5, a6) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
            };
        case 8:
            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
            };
        case 9:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
            };
        case 10:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            };
        default:
            throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
        }
    });

    /**
     * Negates its argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Math
     * @sig Number -> Number
     * @param {Number} n
     * @return {Number}
     * @example
     *
     *      R.negate(42); //=> -42
     */
    var negate = _curry1(function negate(n) {
        return -n;
    });

    /**
     * Returns `true` if no elements of the list match the predicate, `false`
     * otherwise.
     *
     * Dispatches to the `any` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> Boolean
     * @param {Function} fn The predicate function.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
     * @see R.all, R.any
     * @example
     *
     *      var isEven = n => n % 2 === 0;
     *
     *      R.none(isEven, [1, 3, 5, 7, 9, 11]); //=> true
     *      R.none(isEven, [1, 3, 5, 7, 8, 11]); //=> false
     */
    var none = _curry2(_complement(_dispatchable('any', _xany, any)));

    /**
     * A function that returns the `!` of its argument. It will return `true` when
     * passed false-y value, and `false` when passed a truth-y one.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Logic
     * @sig * -> Boolean
     * @param {*} a any value
     * @return {Boolean} the logical inverse of passed argument.
     * @see R.complement
     * @example
     *
     *      R.not(true); //=> false
     *      R.not(false); //=> true
     *      R.not(0); => true
     *      R.not(1); => false
     */
    var not = _curry1(function not(a) {
        return !a;
    });

    /**
     * Returns the nth element of the given list or string. If n is negative the
     * element at index length + n is returned.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Number -> [a] -> a | Undefined
     * @sig Number -> String -> String
     * @param {Number} offset
     * @param {*} list
     * @return {*}
     * @example
     *
     *      var list = ['foo', 'bar', 'baz', 'quux'];
     *      R.nth(1, list); //=> 'bar'
     *      R.nth(-1, list); //=> 'quux'
     *      R.nth(-99, list); //=> undefined
     *
     *      R.nth(2, 'abc'); //=> 'c'
     *      R.nth(3, 'abc'); //=> ''
     */
    var nth = _curry2(function nth(offset, list) {
        var idx = offset < 0 ? list.length + offset : offset;
        return _isString(list) ? list.charAt(idx) : list[idx];
    });

    /**
     * Returns a function which returns its nth argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Function
     * @sig Number -> *... -> *
     * @param {Number} n
     * @return {Function}
     * @example
     *
     *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
     *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
     */
    var nthArg = _curry1(function nthArg(n) {
        return function () {
            return nth(n, arguments);
        };
    });

    /**
     * Creates an object containing a single key:value pair.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Object
     * @sig String -> a -> {String:a}
     * @param {String} key
     * @param {*} val
     * @return {Object}
     * @see R.pair
     * @example
     *
     *      var matchPhrases = R.compose(
     *        R.objOf('must'),
     *        R.map(R.objOf('match_phrase'))
     *      );
     *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
     */
    var objOf = _curry2(function objOf(key, val) {
        var obj = {};
        obj[key] = val;
        return obj;
    });

    /**
     * Returns a singleton array containing the value provided.
     *
     * Note this `of` is different from the ES6 `of`; See
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Function
     * @sig a -> [a]
     * @param {*} x any value
     * @return {Array} An array wrapping `x`.
     * @example
     *
     *      R.of(null); //=> [null]
     *      R.of([42]); //=> [[42]]
     */
    var of = _curry1(_of);

    /**
     * Accepts a function `fn` and returns a function that guards invocation of
     * `fn` such that `fn` can only ever be called once, no matter how many times
     * the returned function is invoked. The first value calculated is returned in
     * subsequent invocations.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a... -> b) -> (a... -> b)
     * @param {Function} fn The function to wrap in a call-only-once wrapper.
     * @return {Function} The wrapped function.
     * @example
     *
     *      var addOneOnce = R.once(x => x + 1);
     *      addOneOnce(10); //=> 11
     *      addOneOnce(addOneOnce(50)); //=> 11
     */
    var once = _curry1(function once(fn) {
        var called = false;
        var result;
        return _arity(fn.length, function () {
            if (called) {
                return result;
            }
            called = true;
            result = fn.apply(this, arguments);
            return result;
        });
    });

    /**
     * Returns `true` if one or both of its arguments are `true`. Returns `false`
     * if both arguments are `false`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Logic
     * @sig * -> * -> *
     * @param {Boolean} a A boolean value
     * @param {Boolean} b A boolean value
     * @return {Boolean} `true` if one or both arguments are `true`, `false` otherwise
     * @see R.either
     * @example
     *
     *      R.or(true, true); //=> true
     *      R.or(true, false); //=> true
     *      R.or(false, true); //=> true
     *      R.or(false, false); //=> false
     */
    var or = _curry2(function or(a, b) {
        return a || b;
    });

    /**
     * Returns the result of "setting" the portion of the given data structure
     * focused by the given lens to the result of applying the given function to
     * the focused value.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Lens s a -> (a -> a) -> s -> s
     * @param {Lens} lens
     * @param {*} v
     * @param {*} x
     * @return {*}
     * @see R.prop, R.lensIndex, R.lensProp
     * @example
     *
     *      var headLens = R.lensIndex(0);
     *
     *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
     */
    // `Identity` is a functor that holds a single value, where `map` simply
    // transforms the held value with the provided function.
    // The value returned by the getter function is first transformed with `f`,
    // then set as the value of an `Identity`. This is then mapped over with the
    // setter function of the lens.
    var over = function () {
        // `Identity` is a functor that holds a single value, where `map` simply
        // transforms the held value with the provided function.
        var Identity = function (x) {
            return {
                value: x,
                map: function (f) {
                    return Identity(f(x));
                }
            };
        };
        return _curry3(function over(lens, f, x) {
            // The value returned by the getter function is first transformed with `f`,
            // then set as the value of an `Identity`. This is then mapped over with the
            // setter function of the lens.
            return lens(function (y) {
                return Identity(f(y));
            })(x).value;
        });
    }();

    /**
     * Takes two arguments, `fst` and `snd`, and returns `[fst, snd]`.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category List
     * @sig a -> b -> (a,b)
     * @param {*} fst
     * @param {*} snd
     * @return {Array}
     * @see R.objOf, R.of
     * @example
     *
     *      R.pair('foo', 'bar'); //=> ['foo', 'bar']
     */
    var pair = _curry2(function pair(fst, snd) {
        return [
            fst,
            snd
        ];
    });

    /**
     * Retrieve the value at a given path.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Object
     * @sig [String] -> {k: v} -> v | Undefined
     * @param {Array} path The path to use.
     * @param {Object} obj The object to retrieve the nested property from.
     * @return {*} The data at `path`.
     * @example
     *
     *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
     *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
     */
    var path = _curry2(function path(paths, obj) {
        var val = obj;
        var idx = 0;
        while (idx < paths.length) {
            if (val == null) {
                return;
            }
            val = val[paths[idx]];
            idx += 1;
        }
        return val;
    });

    /**
     * If the given, non-null object has a value at the given path, returns the
     * value at that path. Otherwise returns the provided default value.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Object
     * @sig a -> [String] -> Object -> a
     * @param {*} d The default value.
     * @param {Array} p The path to use.
     * @param {Object} obj The object to retrieve the nested property from.
     * @return {*} The data at `path` of the supplied object or the default value.
     * @example
     *
     *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2
     *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> "N/A"
     */
    var pathOr = _curry3(function pathOr(d, p, obj) {
        return defaultTo(d, path(p, obj));
    });

    /**
     * Returns `true` if the specified object property at given path satisfies the
     * given predicate; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Logic
     * @sig (a -> Boolean) -> [String] -> Object -> Boolean
     * @param {Function} pred
     * @param {Array} propPath
     * @param {*} obj
     * @return {Boolean}
     * @see R.propSatisfies, R.path
     * @example
     *
     *      R.pathSatisfies(y => y > 0, ['x', 'y'], {x: {y: 2}}); //=> true
     */
    var pathSatisfies = _curry3(function pathSatisfies(pred, propPath, obj) {
        return propPath.length > 0 && pred(path(propPath, obj));
    });

    /**
     * Returns a partial copy of an object containing only the keys specified. If
     * the key does not exist, the property is ignored.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [k] -> {k: v} -> {k: v}
     * @param {Array} names an array of String property names to copy onto a new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with only properties from `names` on it.
     * @see R.omit, R.props
     * @example
     *
     *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
     *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
     */
    var pick = _curry2(function pick(names, obj) {
        var result = {};
        var idx = 0;
        while (idx < names.length) {
            if (names[idx] in obj) {
                result[names[idx]] = obj[names[idx]];
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Similar to `pick` except that this one includes a `key: undefined` pair for
     * properties that don't exist.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [k] -> {k: v} -> {k: v}
     * @param {Array} names an array of String property names to copy onto a new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with only properties from `names` on it.
     * @see R.pick
     * @example
     *
     *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
     *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
     */
    var pickAll = _curry2(function pickAll(names, obj) {
        var result = {};
        var idx = 0;
        var len = names.length;
        while (idx < len) {
            var name = names[idx];
            result[name] = obj[name];
            idx += 1;
        }
        return result;
    });

    /**
     * Returns a partial copy of an object containing only the keys that satisfy
     * the supplied predicate.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @sig (v, k -> Boolean) -> {k: v} -> {k: v}
     * @param {Function} pred A predicate to determine whether or not a key
     *        should be included on the output object.
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with only properties that satisfy `pred`
     *         on it.
     * @see R.pick, R.filter
     * @example
     *
     *      var isUpperCase = (val, key) => key.toUpperCase() === key;
     *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
     */
    var pickBy = _curry2(function pickBy(test, obj) {
        var result = {};
        for (var prop in obj) {
            if (test(obj[prop], prop, obj)) {
                result[prop] = obj[prop];
            }
        }
        return result;
    });

    /**
     * Returns a new list with the given element at the front, followed by the
     * contents of the list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> [a]
     * @param {*} el The item to add to the head of the output list.
     * @param {Array} list The array to add to the tail of the output list.
     * @return {Array} A new array.
     * @see R.append
     * @example
     *
     *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
     */
    var prepend = _curry2(function prepend(el, list) {
        return _concat([el], list);
    });

    /**
     * Returns a function that when supplied an object returns the indicated
     * property of that object, if it exists.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig s -> {s: a} -> a | Undefined
     * @param {String} p The property name
     * @param {Object} obj The object to query
     * @return {*} The value at `obj.p`.
     * @example
     *
     *      R.prop('x', {x: 100}); //=> 100
     *      R.prop('x', {}); //=> undefined
     */
    var prop = _curry2(function prop(p, obj) {
        return obj[p];
    });

    /**
     * If the given, non-null object has an own property with the specified name,
     * returns the value of that property. Otherwise returns the provided default
     * value.
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category Object
     * @sig a -> String -> Object -> a
     * @param {*} val The default value.
     * @param {String} p The name of the property to return.
     * @param {Object} obj The object to query.
     * @return {*} The value of given property of the supplied object or the default value.
     * @example
     *
     *      var alice = {
     *        name: 'ALICE',
     *        age: 101
     *      };
     *      var favorite = R.prop('favoriteLibrary');
     *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
     *
     *      favorite(alice);  //=> undefined
     *      favoriteWithDefault(alice);  //=> 'Ramda'
     */
    var propOr = _curry3(function propOr(val, p, obj) {
        return obj != null && _has(p, obj) ? obj[p] : val;
    });

    /**
     * Returns `true` if the specified object property satisfies the given
     * predicate; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Logic
     * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
     * @param {Function} pred
     * @param {String} name
     * @param {*} obj
     * @return {Boolean}
     * @see R.propEq, R.propIs
     * @example
     *
     *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
     */
    var propSatisfies = _curry3(function propSatisfies(pred, name, obj) {
        return pred(obj[name]);
    });

    /**
     * Acts as multiple `prop`: array of keys in, array of values out. Preserves
     * order.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [k] -> {k: v} -> [v]
     * @param {Array} ps The property names to fetch
     * @param {Object} obj The object to query
     * @return {Array} The corresponding values or partially applied function.
     * @example
     *
     *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
     *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
     *
     *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));
     *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
     */
    var props = _curry2(function props(ps, obj) {
        var len = ps.length;
        var out = [];
        var idx = 0;
        while (idx < len) {
            out[idx] = obj[ps[idx]];
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Number -> Number -> [Number]
     * @param {Number} from The first number in the list.
     * @param {Number} to One more than the last number in the list.
     * @return {Array} The list of numbers in tthe set `[a, b)`.
     * @example
     *
     *      R.range(1, 5);    //=> [1, 2, 3, 4]
     *      R.range(50, 53);  //=> [50, 51, 52]
     */
    var range = _curry2(function range(from, to) {
        if (!(_isNumber(from) && _isNumber(to))) {
            throw new TypeError('Both arguments to range must be numbers');
        }
        var result = [];
        var n = from;
        while (n < to) {
            result.push(n);
            n += 1;
        }
        return result;
    });

    /**
     * Returns a single item by iterating through the list, successively calling
     * the iterator function and passing it an accumulator value and the current
     * value from the array, and then passing the result to the next call.
     *
     * Similar to `reduce`, except moves through the input list from the right to
     * the left.
     *
     * The iterator function receives two values: *(acc, value)*
     *
     * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse
     * arrays), unlike the native `Array.prototype.reduce` method. For more details
     * on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a,b -> a) -> a -> [b] -> a
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.addIndex
     * @example
     *
     *      var pairs = [ ['a', 1], ['b', 2], ['c', 3] ];
     *      var flattenPairs = (acc, pair) => acc.concat(pair);
     *
     *      R.reduceRight(flattenPairs, [], pairs); //=> [ 'c', 3, 'b', 2, 'a', 1 ]
     */
    var reduceRight = _curry3(function reduceRight(fn, acc, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
            acc = fn(acc, list[idx]);
            idx -= 1;
        }
        return acc;
    });

    /**
     * Returns a value wrapped to indicate that it is the final value of the reduce
     * and transduce functions. The returned value should be considered a black
     * box: the internal structure is not guaranteed to be stable.
     *
     * Note: this optimization is unavailable to functions not explicitly listed
     * above. For instance, it is not currently supported by reduceRight.
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category List
     * @sig a -> *
     * @param {*} x The final value of the reduce.
     * @return {*} The wrapped value.
     * @see R.reduce, R.transduce
     * @example
     *
     *      R.reduce(
     *        R.pipe(R.add, R.when(R.gte(R.__, 10), R.reduced)),
     *        0,
     *        [1, 2, 3, 4, 5]) // 10
     */
    var reduced = _curry1(_reduced);

    /**
     * Removes the sub-list of `list` starting at index `start` and containing
     * `count` elements. _Note that this is not destructive_: it returns a copy of
     * the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @since v0.2.2
     * @category List
     * @sig Number -> Number -> [a] -> [a]
     * @param {Number} start The position to start removing elements
     * @param {Number} count The number of elements to remove
     * @param {Array} list The list to remove from
     * @return {Array} A new Array with `count` elements from `start` removed.
     * @example
     *
     *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
     */
    var remove = _curry3(function remove(start, count, list) {
        return _concat(_slice(list, 0, Math.min(start, list.length)), _slice(list, Math.min(list.length, start + count)));
    });

    /**
     * Replace a substring or regex match in a string with a replacement.
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category String
     * @sig RegExp|String -> String -> String -> String
     * @param {RegExp|String} pattern A regular expression or a substring to match.
     * @param {String} replacement The string to replace the matches with.
     * @param {String} str The String to do the search and replacement in.
     * @return {String} The result.
     * @example
     *
     *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
     *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
     *
     *      // Use the "g" (global) flag to replace all occurrences:
     *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
     */
    var replace = _curry3(function replace(regex, replacement, str) {
        return str.replace(regex, replacement);
    });

    /**
     * Returns a new list or string with the elements or characters in reverse
     * order.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a]
     * @sig String -> String
     * @param {Array|String} list
     * @return {Array|String}
     * @example
     *
     *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
     *      R.reverse([1, 2]);     //=> [2, 1]
     *      R.reverse([1]);        //=> [1]
     *      R.reverse([]);         //=> []
     *
     *      R.reverse('abc');      //=> 'cba'
     *      R.reverse('ab');       //=> 'ba'
     *      R.reverse('a');        //=> 'a'
     *      R.reverse('');         //=> ''
     */
    var reverse = _curry1(function reverse(list) {
        return _isString(list) ? list.split('').reverse().join('') : _slice(list).reverse();
    });

    /**
     * Scan is similar to reduce, but returns a list of successively reduced values
     * from the left
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig (a,b -> a) -> a -> [b] -> [a]
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {Array} A list of all intermediately reduced values.
     * @example
     *
     *      var numbers = [1, 2, 3, 4];
     *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
     */
    var scan = _curry3(function scan(fn, acc, list) {
        var idx = 0;
        var len = list.length;
        var result = [acc];
        while (idx < len) {
            acc = fn(acc, list[idx]);
            result[idx + 1] = acc;
            idx += 1;
        }
        return result;
    });

    /**
     * Returns the result of "setting" the portion of the given data structure
     * focused by the given lens to the given value.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Lens s a -> a -> s -> s
     * @param {Lens} lens
     * @param {*} v
     * @param {*} x
     * @return {*}
     * @see R.prop, R.lensIndex, R.lensProp
     * @example
     *
     *      var xLens = R.lensProp('x');
     *
     *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
     *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
     */
    var set = _curry3(function set(lens, v, x) {
        return over(lens, always(v), x);
    });

    /**
     * Returns the elements of the given list or string (or object with a `slice`
     * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
     *
     * Dispatches to the `slice` method of the third argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.4
     * @category List
     * @sig Number -> Number -> [a] -> [a]
     * @sig Number -> Number -> String -> String
     * @param {Number} fromIndex The start index (inclusive).
     * @param {Number} toIndex The end index (exclusive).
     * @param {*} list
     * @return {*}
     * @example
     *
     *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
     *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
     *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
     *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
     *      R.slice(0, 3, 'ramda');                     //=> 'ram'
     */
    var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
        return Array.prototype.slice.call(list, fromIndex, toIndex);
    }));

    /**
     * Returns a copy of the list, sorted according to the comparator function,
     * which should accept two values at a time and return a negative number if the
     * first value is smaller, a positive number if it's larger, and zero if they
     * are equal. Please note that this is a **copy** of the list. It does not
     * modify the original.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a,a -> Number) -> [a] -> [a]
     * @param {Function} comparator A sorting function :: a -> b -> Int
     * @param {Array} list The list to sort
     * @return {Array} a new array with its elements sorted by the comparator function.
     * @example
     *
     *      var diff = function(a, b) { return a - b; };
     *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
     */
    var sort = _curry2(function sort(comparator, list) {
        return _slice(list).sort(comparator);
    });

    /**
     * Sorts the list according to the supplied function.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord b => (a -> b) -> [a] -> [a]
     * @param {Function} fn
     * @param {Array} list The list to sort.
     * @return {Array} A new list sorted by the keys generated by `fn`.
     * @example
     *
     *      var sortByFirstItem = R.sortBy(R.prop(0));
     *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
     *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];
     *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
     *      var alice = {
     *        name: 'ALICE',
     *        age: 101
     *      };
     *      var bob = {
     *        name: 'Bob',
     *        age: -10
     *      };
     *      var clara = {
     *        name: 'clara',
     *        age: 314.159
     *      };
     *      var people = [clara, bob, alice];
     *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
     */
    var sortBy = _curry2(function sortBy(fn, list) {
        return _slice(list).sort(function (a, b) {
            var aa = fn(a);
            var bb = fn(b);
            return aa < bb ? -1 : aa > bb ? 1 : 0;
        });
    });

    /**
     * Splits a given list or string at a given index.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig Number -> [a] -> [[a], [a]]
     * @sig Number -> String -> [String, String]
     * @param {Number} index The index where the array/string is split.
     * @param {Array|String} array The array/string to be split.
     * @return {Array}
     * @example
     *
     *      R.splitAt(1, [1, 2, 3]);          //=> [[1], [2, 3]]
     *      R.splitAt(5, 'hello world');      //=> ['hello', ' world']
     *      R.splitAt(-1, 'foobar');          //=> ['fooba', 'r']
     */
    var splitAt = _curry2(function splitAt(index, array) {
        return [
            slice(0, index, array),
            slice(index, length(array), array)
        ];
    });

    /**
     * Splits a collection into slices of the specified length.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig Number -> [a] -> [[a]]
     * @sig Number -> String -> [String]
     * @param {Number} n
     * @param {Array} list
     * @return {Array}
     * @example
     *
     *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
     *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
     */
    var splitEvery = _curry2(function splitEvery(n, list) {
        if (n <= 0) {
            throw new Error('First argument to splitEvery must be a positive integer');
        }
        var result = [];
        var idx = 0;
        while (idx < list.length) {
            result.push(slice(idx, idx += n, list));
        }
        return result;
    });

    /**
     * Takes a list and a predicate and returns a pair of lists with the following properties:
     *
     *  - the result of concatenating the two output lists is equivalent to the input list;
     *  - none of the elements of the first output list satisfies the predicate; and
     *  - if the second output list is non-empty, its first element satisfies the predicate.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [[a], [a]]
     * @param {Function} pred The predicate that determines where the array is split.
     * @param {Array} list The array to be split.
     * @return {Array}
     * @example
     *
     *      R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=> [[1], [2, 3, 1, 2, 3]]
     */
    var splitWhen = _curry2(function splitWhen(pred, list) {
        var idx = 0;
        var len = list.length;
        var prefix = [];
        while (idx < len && !pred(list[idx])) {
            prefix.push(list[idx]);
            idx += 1;
        }
        return [
            prefix,
            _slice(list, idx)
        ];
    });

    /**
     * Subtracts its second argument from its first argument.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The first value.
     * @param {Number} b The second value.
     * @return {Number} The result of `a - b`.
     * @see R.add
     * @example
     *
     *      R.subtract(10, 8); //=> 2
     *
     *      var minus5 = R.subtract(R.__, 5);
     *      minus5(17); //=> 12
     *
     *      var complementaryAngle = R.subtract(90);
     *      complementaryAngle(30); //=> 60
     *      complementaryAngle(72); //=> 18
     */
    var subtract = _curry2(function subtract(a, b) {
        return Number(a) - Number(b);
    });

    /**
     * Returns all but the first element of the given list or string (or object
     * with a `tail` method).
     *
     * Dispatches to the `slice` method of the first argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a]
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @see R.head, R.init, R.last
     * @example
     *
     *      R.tail([1, 2, 3]);  //=> [2, 3]
     *      R.tail([1, 2]);     //=> [2]
     *      R.tail([1]);        //=> []
     *      R.tail([]);         //=> []
     *
     *      R.tail('abc');  //=> 'bc'
     *      R.tail('ab');   //=> 'b'
     *      R.tail('a');    //=> ''
     *      R.tail('');     //=> ''
     */
    var tail = _checkForMethod('tail', slice(1, Infinity));

    /**
     * Returns the first `n` elements of the given list, string, or
     * transducer/transformer (or object with a `take` method).
     *
     * Dispatches to the `take` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n
     * @param {*} list
     * @return {*}
     * @see R.drop
     * @example
     *
     *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
     *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
     *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.take(3, 'ramda');               //=> 'ram'
     *
     *      var personnel = [
     *        'Dave Brubeck',
     *        'Paul Desmond',
     *        'Eugene Wright',
     *        'Joe Morello',
     *        'Gerry Mulligan',
     *        'Bob Bates',
     *        'Joe Dodge',
     *        'Ron Crotty'
     *      ];
     *
     *      var takeFive = R.take(5);
     *      takeFive(personnel);
     *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
     */
    var take = _curry2(_dispatchable('take', _xtake, function take(n, xs) {
        return slice(0, n < 0 ? Infinity : n, xs);
    }));

    /**
     * Returns a new list containing the last `n` elements of a given list, passing
     * each value to the supplied predicate function, and terminating when the
     * predicate function returns `false`. Excludes the element that caused the
     * predicate function to fail. The predicate function is passed one argument:
     * *(value)*.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.dropLastWhile, R.addIndex
     * @example
     *
     *      var isNotOne = x => x !== 1;
     *
     *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
     */
    var takeLastWhile = _curry2(function takeLastWhile(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0 && fn(list[idx])) {
            idx -= 1;
        }
        return _slice(list, idx + 1, Infinity);
    });

    /**
     * Returns a new list containing the first `n` elements of a given list,
     * passing each value to the supplied predicate function, and terminating when
     * the predicate function returns `false`. Excludes the element that caused the
     * predicate function to fail. The predicate function is passed one argument:
     * *(value)*.
     *
     * Dispatches to the `takeWhile` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.dropWhile, R.transduce, R.addIndex
     * @example
     *
     *      var isNotFour = x => x !== 4;
     *
     *      R.takeWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3]
     */
    var takeWhile = _curry2(_dispatchable('takeWhile', _xtakeWhile, function takeWhile(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len && fn(list[idx])) {
            idx += 1;
        }
        return _slice(list, 0, idx);
    }));

    /**
     * Runs the given function with the supplied object, then returns the object.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a -> *) -> a -> a
     * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
     * @param {*} x
     * @return {*} `x`.
     * @example
     *
     *      var sayX = x => console.log('x is ' + x);
     *      R.tap(sayX, 100); //=> 100
     *      //-> 'x is 100'
     */
    var tap = _curry2(function tap(fn, x) {
        fn(x);
        return x;
    });

    /**
     * Calls an input function `n` times, returning an array containing the results
     * of those function calls.
     *
     * `fn` is passed one argument: The current value of `n`, which begins at `0`
     * and is gradually incremented to `n - 1`.
     *
     * @func
     * @memberOf R
     * @since v0.2.3
     * @category List
     * @sig (Number -> a) -> Number -> [a]
     * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
     * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
     * @return {Array} An array containing the return values of all calls to `fn`.
     * @example
     *
     *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
     */
    var times = _curry2(function times(fn, n) {
        var len = Number(n);
        var idx = 0;
        var list;
        if (len < 0 || isNaN(len)) {
            throw new RangeError('n must be a non-negative number');
        }
        list = new Array(len);
        while (idx < len) {
            list[idx] = fn(idx);
            idx += 1;
        }
        return list;
    });

    /**
     * Converts an object into an array of key, value arrays. Only the object's
     * own properties are used.
     * Note that the order of the output array is not guaranteed to be consistent
     * across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.4.0
     * @category Object
     * @sig {String: *} -> [[String,*]]
     * @param {Object} obj The object to extract from
     * @return {Array} An array of key, value arrays from the object's own properties.
     * @see R.fromPairs
     * @example
     *
     *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
     */
    var toPairs = _curry1(function toPairs(obj) {
        var pairs = [];
        for (var prop in obj) {
            if (_has(prop, obj)) {
                pairs[pairs.length] = [
                    prop,
                    obj[prop]
                ];
            }
        }
        return pairs;
    });

    /**
     * Converts an object into an array of key, value arrays. The object's own
     * properties and prototype properties are used. Note that the order of the
     * output array is not guaranteed to be consistent across different JS
     * platforms.
     *
     * @func
     * @memberOf R
     * @since v0.4.0
     * @category Object
     * @sig {String: *} -> [[String,*]]
     * @param {Object} obj The object to extract from
     * @return {Array} An array of key, value arrays from the object's own
     *         and prototype properties.
     * @example
     *
     *      var F = function() { this.x = 'X'; };
     *      F.prototype.y = 'Y';
     *      var f = new F();
     *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
     */
    var toPairsIn = _curry1(function toPairsIn(obj) {
        var pairs = [];
        for (var prop in obj) {
            pairs[pairs.length] = [
                prop,
                obj[prop]
            ];
        }
        return pairs;
    });

    /**
     * Transposes the rows and columns of a 2D list.
     * When passed a list of `n` lists of length `x`,
     * returns a list of `x` lists of length `n`.
     *
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig [[a]] -> [[a]]
     * @param {Array} list A 2D list
     * @return {Array} A 2D list
     * @example
     *
     *      R.transpose([[1, 'a'], [2, 'b'], [3, 'c']]) //=> [[1, 2, 3], ['a', 'b', 'c']]
     *      R.transpose([[1, 2, 3], ['a', 'b', 'c']]) //=> [[1, 'a'], [2, 'b'], [3, 'c']]
     *
     * If some of the rows are shorter than the following rows, their elements are skipped:
     *
     *      R.transpose([[10, 11], [20], [], [30, 31, 32]]) //=> [[10, 20, 30], [11, 31], [32]]
     */
    var transpose = _curry1(function transpose(outerlist) {
        var i = 0;
        var result = [];
        while (i < outerlist.length) {
            var innerlist = outerlist[i];
            var j = 0;
            while (j < innerlist.length) {
                if (typeof result[j] === 'undefined') {
                    result[j] = [];
                }
                result[j].push(innerlist[j]);
                j += 1;
            }
            i += 1;
        }
        return result;
    });

    /**
     * Removes (strips) whitespace from both ends of the string.
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category String
     * @sig String -> String
     * @param {String} str The string to trim.
     * @return {String} Trimmed version of `str`.
     * @example
     *
     *      R.trim('   xyz  '); //=> 'xyz'
     *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
     */
    var trim = function () {
        var ws = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
        var zeroWidth = '\u200B';
        var hasProtoTrim = typeof String.prototype.trim === 'function';
        if (!hasProtoTrim || (ws.trim() || !zeroWidth.trim())) {
            return _curry1(function trim(str) {
                var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
                var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
                return str.replace(beginRx, '').replace(endRx, '');
            });
        } else {
            return _curry1(function trim(str) {
                return str.trim();
            });
        }
    }();

    /**
     * `tryCatch` takes two functions, a `tryer` and a `catcher`. The returned
     * function evaluates the `tryer`; if it does not throw, it simply returns the
     * result. If the `tryer` *does* throw, the returned function evaluates the
     * `catcher` function and returns its result. Note that for effective
     * composition with this function, both the `tryer` and `catcher` functions
     * must return the same type of results.
     *
     * @func
     * @memberOf R
     * @since v0.20.0
     * @category Function
     * @sig (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
     * @param {Function} tryer The function that may throw.
     * @param {Function} catcher The function that will be evaluated if `tryer` throws.
     * @return {Function} A new function that will catch exceptions and send then to the catcher.
     * @example
     *
     *      R.tryCatch(R.prop('x'), R.F, {x: true}); //=> true
     *      R.tryCatch(R.prop('x'), R.F, null);      //=> false
     */
    var tryCatch = _curry2(function _tryCatch(tryer, catcher) {
        return _arity(tryer.length, function () {
            try {
                return tryer.apply(this, arguments);
            } catch (e) {
                return catcher.apply(this, _concat([e], arguments));
            }
        });
    });

    /**
     * Gives a single-word string description of the (native) type of a value,
     * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
     * attempt to distinguish user Object types any further, reporting them all as
     * 'Object'.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Type
     * @sig (* -> {*}) -> String
     * @param {*} val The value to test
     * @return {String}
     * @example
     *
     *      R.type({}); //=> "Object"
     *      R.type(1); //=> "Number"
     *      R.type(false); //=> "Boolean"
     *      R.type('s'); //=> "String"
     *      R.type(null); //=> "Null"
     *      R.type([]); //=> "Array"
     *      R.type(/[A-z]/); //=> "RegExp"
     */
    var type = _curry1(function type(val) {
        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
    });

    /**
     * Takes a function `fn`, which takes a single array argument, and returns a
     * function which:
     *
     *   - takes any number of positional arguments;
     *   - passes these arguments to `fn` as an array; and
     *   - returns the result.
     *
     * In other words, R.unapply derives a variadic function from a function which
     * takes an array. R.unapply is the inverse of R.apply.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Function
     * @sig ([*...] -> a) -> (*... -> a)
     * @param {Function} fn
     * @return {Function}
     * @see R.apply
     * @example
     *
     *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
     */
    var unapply = _curry1(function unapply(fn) {
        return function () {
            return fn(_slice(arguments));
        };
    });

    /**
     * Wraps a function of any arity (including nullary) in a function that accepts
     * exactly 1 parameter. Any extraneous parameters will not be passed to the
     * supplied function.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Function
     * @sig (* -> b) -> (a -> b)
     * @param {Function} fn The function to wrap.
     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
     *         arity 1.
     * @example
     *
     *      var takesTwoArgs = function(a, b) {
     *        return [a, b];
     *      };
     *      takesTwoArgs.length; //=> 2
     *      takesTwoArgs(1, 2); //=> [1, 2]
     *
     *      var takesOneArg = R.unary(takesTwoArgs);
     *      takesOneArg.length; //=> 1
     *      // Only 1 argument is passed to the wrapped function
     *      takesOneArg(1, 2); //=> [1, undefined]
     */
    var unary = _curry1(function unary(fn) {
        return nAry(1, fn);
    });

    /**
     * Returns a function of arity `n` from a (manually) curried function.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Function
     * @sig Number -> (a -> b) -> (a -> c)
     * @param {Number} length The arity for the returned function.
     * @param {Function} fn The function to uncurry.
     * @return {Function} A new function.
     * @see R.curry
     * @example
     *
     *      var addFour = a => b => c => d => a + b + c + d;
     *
     *      var uncurriedAddFour = R.uncurryN(4, addFour);
     *      uncurriedAddFour(1, 2, 3, 4); //=> 10
     */
    var uncurryN = _curry2(function uncurryN(depth, fn) {
        return curryN(depth, function () {
            var currentDepth = 1;
            var value = fn;
            var idx = 0;
            var endIdx;
            while (currentDepth <= depth && typeof value === 'function') {
                endIdx = currentDepth === depth ? arguments.length : idx + value.length;
                value = value.apply(this, _slice(arguments, idx, endIdx));
                currentDepth += 1;
                idx = endIdx;
            }
            return value;
        });
    });

    /**
     * Builds a list from a seed value. Accepts an iterator function, which returns
     * either false to stop iteration or an array of length 2 containing the value
     * to add to the resulting list and the seed to be used in the next call to the
     * iterator function.
     *
     * The iterator function receives one argument: *(seed)*.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig (a -> [b]) -> * -> [b]
     * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
     *        either false to quit iteration or an array of length two to proceed. The element
     *        at index 0 of this array will be added to the resulting array, and the element
     *        at index 1 will be passed to the next call to `fn`.
     * @param {*} seed The seed value.
     * @return {Array} The final list.
     * @example
     *
     *      var f = n => n > 50 ? false : [-n, n + 10];
     *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
     */
    var unfold = _curry2(function unfold(fn, seed) {
        var pair = fn(seed);
        var result = [];
        while (pair && pair.length) {
            result[result.length] = pair[0];
            pair = fn(pair[1]);
        }
        return result;
    });

    /**
     * Returns a new list containing only one copy of each element in the original
     * list, based upon the value returned by applying the supplied predicate to
     * two list elements. Prefers the first item if two items compare equal based
     * on the predicate.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category List
     * @sig (a, a -> Boolean) -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      var strEq = R.eqBy(String);
     *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
     *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
     *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
     *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
     */
    var uniqWith = _curry2(function uniqWith(pred, list) {
        var idx = 0;
        var len = list.length;
        var result = [];
        var item;
        while (idx < len) {
            item = list[idx];
            if (!_containsWith(pred, item, result)) {
                result[result.length] = item;
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Tests the final argument by passing it to the given predicate function. If
     * the predicate is not satisfied, the function will return the result of
     * calling the `whenFalseFn` function with the same argument. If the predicate
     * is satisfied, the argument is returned as is.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Logic
     * @sig (a -> Boolean) -> (a -> a) -> a -> a
     * @param {Function} pred        A predicate function
     * @param {Function} whenFalseFn A function to invoke when the `pred` evaluates
     *                               to a falsy value.
     * @param {*}        x           An object to test with the `pred` function and
     *                               pass to `whenFalseFn` if necessary.
     * @return {*} Either `x` or the result of applying `x` to `whenFalseFn`.
     * @see R.ifElse, R.when
     * @example
     *
     *      // coerceArray :: (a|[a]) -> [a]
     *      var coerceArray = R.unless(R.isArrayLike, R.of);
     *      coerceArray([1, 2, 3]); //=> [1, 2, 3]
     *      coerceArray(1);         //=> [1]
     */
    var unless = _curry3(function unless(pred, whenFalseFn, x) {
        return pred(x) ? x : whenFalseFn(x);
    });

    /**
     * Takes a predicate, a transformation function, and an initial value,
     * and returns a value of the same type as the initial value.
     * It does so by applying the transformation until the predicate is satisfied,
     * at which point it returns the satisfactory value.
     *
     * @func
     * @memberOf R
     * @since v0.20.0
     * @category Logic
     * @sig (a -> Boolean) -> (a -> a) -> a -> a
     * @param {Function} pred A predicate function
     * @param {Function} fn The iterator function
     * @param {*} init Initial value
     * @return {*} Final value that satisfies predicate
     * @example
     *
     *      R.until(R.gt(R.__, 100), R.multiply(2))(1) // => 128
     */
    var until = _curry3(function until(pred, fn, init) {
        var val = init;
        while (!pred(val)) {
            val = fn(val);
        }
        return val;
    });

    /**
     * Returns a new copy of the array with the element at the provided index
     * replaced with the given value.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig Number -> a -> [a] -> [a]
     * @param {Number} idx The index to update.
     * @param {*} x The value to exist at the given index of the returned array.
     * @param {Array|Arguments} list The source array-like object to be updated.
     * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
     * @see R.adjust
     * @example
     *
     *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]
     *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]
     */
    var update = _curry3(function update(idx, x, list) {
        return adjust(always(x), idx, list);
    });

    /**
     * Accepts a function `fn` and a list of transformer functions and returns a
     * new curried function. When the new function is invoked, it calls the
     * function `fn` with parameters consisting of the result of calling each
     * supplied handler on successive arguments to the new function.
     *
     * If more arguments are passed to the returned function than transformer
     * functions, those arguments are passed directly to `fn` as additional
     * parameters. If you expect additional arguments that don't need to be
     * transformed, although you can ignore them, it's best to pass an identity
     * function so that the new function reports the correct arity.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (x1 -> x2 -> ... -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)
     * @param {Function} fn The function to wrap.
     * @param {Array} transformers A list of transformer functions
     * @return {Function} The wrapped function.
     * @example
     *
     *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81
     *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81
     *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32
     *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32
     */
    var useWith = _curry2(function useWith(fn, transformers) {
        return curryN(transformers.length, function () {
            var args = [];
            var idx = 0;
            while (idx < transformers.length) {
                args.push(transformers[idx].call(this, arguments[idx]));
                idx += 1;
            }
            return fn.apply(this, args.concat(_slice(arguments, transformers.length)));
        });
    });

    /**
     * Returns a list of all the enumerable own properties of the supplied object.
     * Note that the order of the output array is not guaranteed across different
     * JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {k: v} -> [v]
     * @param {Object} obj The object to extract values from
     * @return {Array} An array of the values of the object's own properties.
     * @example
     *
     *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
     */
    var values = _curry1(function values(obj) {
        var props = keys(obj);
        var len = props.length;
        var vals = [];
        var idx = 0;
        while (idx < len) {
            vals[idx] = obj[props[idx]];
            idx += 1;
        }
        return vals;
    });

    /**
     * Returns a list of all the properties, including prototype properties, of the
     * supplied object.
     * Note that the order of the output array is not guaranteed to be consistent
     * across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Object
     * @sig {k: v} -> [v]
     * @param {Object} obj The object to extract values from
     * @return {Array} An array of the values of the object's own and prototype properties.
     * @example
     *
     *      var F = function() { this.x = 'X'; };
     *      F.prototype.y = 'Y';
     *      var f = new F();
     *      R.valuesIn(f); //=> ['X', 'Y']
     */
    var valuesIn = _curry1(function valuesIn(obj) {
        var prop;
        var vs = [];
        for (prop in obj) {
            vs[vs.length] = obj[prop];
        }
        return vs;
    });

    /**
     * Returns a "view" of the given data structure, determined by the given lens.
     * The lens's focus determines which portion of the data structure is visible.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Lens s a -> s -> a
     * @param {Lens} lens
     * @param {*} x
     * @return {*}
     * @see R.prop, R.lensIndex, R.lensProp
     * @example
     *
     *      var xLens = R.lensProp('x');
     *
     *      R.view(xLens, {x: 1, y: 2});  //=> 1
     *      R.view(xLens, {x: 4, y: 2});  //=> 4
     */
    // `Const` is a functor that effectively ignores the function given to `map`.
    // Using `Const` effectively ignores the setter function of the `lens`,
    // leaving the value returned by the getter function unmodified.
    var view = function () {
        // `Const` is a functor that effectively ignores the function given to `map`.
        var Const = function (x) {
            return {
                value: x,
                map: function () {
                    return this;
                }
            };
        };
        return _curry2(function view(lens, x) {
            // Using `Const` effectively ignores the setter function of the `lens`,
            // leaving the value returned by the getter function unmodified.
            return lens(Const)(x).value;
        });
    }();

    /**
     * Tests the final argument by passing it to the given predicate function. If
     * the predicate is satisfied, the function will return the result of calling
     * the `whenTrueFn` function with the same argument. If the predicate is not
     * satisfied, the argument is returned as is.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Logic
     * @sig (a -> Boolean) -> (a -> a) -> a -> a
     * @param {Function} pred       A predicate function
     * @param {Function} whenTrueFn A function to invoke when the `condition`
     *                              evaluates to a truthy value.
     * @param {*}        x          An object to test with the `pred` function and
     *                              pass to `whenTrueFn` if necessary.
     * @return {*} Either `x` or the result of applying `x` to `whenTrueFn`.
     * @see R.ifElse, R.unless
     * @example
     *
     *      // truncate :: String -> String
     *      var truncate = R.when(
     *        R.propSatisfies(R.gt(R.__, 10), 'length'),
     *        R.pipe(R.take(10), R.append(''), R.join(''))
     *      );
     *      truncate('12345');         //=> '12345'
     *      truncate('0123456789ABC'); //=> '0123456789'
     */
    var when = _curry3(function when(pred, whenTrueFn, x) {
        return pred(x) ? whenTrueFn(x) : x;
    });

    /**
     * Takes a spec object and a test object; returns true if the test satisfies
     * the spec. Each of the spec's own properties must be a predicate function.
     * Each predicate is applied to the value of the corresponding property of the
     * test object. `where` returns true if all the predicates return true, false
     * otherwise.
     *
     * `where` is well suited to declaratively expressing constraints for other
     * functions such as `filter` and `find`.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category Object
     * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
     * @param {Object} spec
     * @param {Object} testObj
     * @return {Boolean}
     * @example
     *
     *      // pred :: Object -> Boolean
     *      var pred = R.where({
     *        a: R.equals('foo'),
     *        b: R.complement(R.equals('bar')),
     *        x: R.gt(_, 10),
     *        y: R.lt(_, 20)
     *      });
     *
     *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
     *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
     *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
     *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
     *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
     */
    var where = _curry2(function where(spec, testObj) {
        for (var prop in spec) {
            if (_has(prop, spec) && !spec[prop](testObj[prop])) {
                return false;
            }
        }
        return true;
    });

    /**
     * Wrap a function inside another to allow you to make adjustments to the
     * parameters, or do other processing either before the internal function is
     * called or with its results.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a... -> b) -> ((a... -> b) -> a... -> c) -> (a... -> c)
     * @param {Function} fn The function to wrap.
     * @param {Function} wrapper The wrapper function.
     * @return {Function} The wrapped function.
     * @example
     *
     *      var greet = name => 'Hello ' + name;
     *
     *      var shoutedGreet = R.wrap(greet, (gr, name) => gr(name).toUpperCase());
     *
     *      shoutedGreet("Kathy"); //=> "HELLO KATHY"
     *
     *      var shortenedGreet = R.wrap(greet, function(gr, name) {
     *        return gr(name.substring(0, 3));
     *      });
     *      shortenedGreet("Robert"); //=> "Hello Rob"
     */
    var wrap = _curry2(function wrap(fn, wrapper) {
        return curryN(fn.length, function () {
            return wrapper.apply(this, _concat([fn], arguments));
        });
    });

    /**
     * Creates a new list out of the two supplied by creating each possible pair
     * from the lists.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [b] -> [[a,b]]
     * @param {Array} as The first list.
     * @param {Array} bs The second list.
     * @return {Array} The list made by combining each possible pair from
     *         `as` and `bs` into pairs (`[a, b]`).
     * @example
     *
     *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
     */
    // = xprodWith(prepend); (takes about 3 times as long...)
    var xprod = _curry2(function xprod(a, b) {
        // = xprodWith(prepend); (takes about 3 times as long...)
        var idx = 0;
        var ilen = a.length;
        var j;
        var jlen = b.length;
        var result = [];
        while (idx < ilen) {
            j = 0;
            while (j < jlen) {
                result[result.length] = [
                    a[idx],
                    b[j]
                ];
                j += 1;
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Creates a new list out of the two supplied by pairing up equally-positioned
     * items from both lists. The returned list is truncated to the length of the
     * shorter of the two input lists.
     * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [b] -> [[a,b]]
     * @param {Array} list1 The first array to consider.
     * @param {Array} list2 The second array to consider.
     * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
     * @example
     *
     *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
     */
    var zip = _curry2(function zip(a, b) {
        var rv = [];
        var idx = 0;
        var len = Math.min(a.length, b.length);
        while (idx < len) {
            rv[idx] = [
                a[idx],
                b[idx]
            ];
            idx += 1;
        }
        return rv;
    });

    /**
     * Creates a new object out of a list of keys and a list of values.
     * Key/value pairing is truncated to the length of the shorter of the two lists.
     * Note: `zipObj` is equivalent to `pipe(zipWith(pair), fromPairs)`.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig [String] -> [*] -> {String: *}
     * @param {Array} keys The array that will be properties on the output object.
     * @param {Array} values The list of values on the output object.
     * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
     * @example
     *
     *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
     */
    var zipObj = _curry2(function zipObj(keys, values) {
        var idx = 0;
        var len = Math.min(keys.length, values.length);
        var out = {};
        while (idx < len) {
            out[keys[idx]] = values[idx];
            idx += 1;
        }
        return out;
    });

    /**
     * Creates a new list out of the two supplied by applying the function to each
     * equally-positioned pair in the lists. The returned list is truncated to the
     * length of the shorter of the two input lists.
     *
     * @function
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a,b -> c) -> [a] -> [b] -> [c]
     * @param {Function} fn The function used to combine the two elements into one value.
     * @param {Array} list1 The first array to consider.
     * @param {Array} list2 The second array to consider.
     * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
     *         using `fn`.
     * @example
     *
     *      var f = (x, y) => {
     *        // ...
     *      };
     *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
     *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
     */
    var zipWith = _curry3(function zipWith(fn, a, b) {
        var rv = [];
        var idx = 0;
        var len = Math.min(a.length, b.length);
        while (idx < len) {
            rv[idx] = fn(a[idx], b[idx]);
            idx += 1;
        }
        return rv;
    });

    /**
     * A function that always returns `false`. Any passed in parameters are ignored.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Function
     * @sig * -> Boolean
     * @param {*}
     * @return {Boolean}
     * @see R.always, R.T
     * @example
     *
     *      R.F(); //=> false
     */
    var F = always(false);

    /**
     * A function that always returns `true`. Any passed in parameters are ignored.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Function
     * @sig * -> Boolean
     * @param {*}
     * @return {Boolean}
     * @see R.always, R.F
     * @example
     *
     *      R.T(); //=> true
     */
    var T = always(true);

    /**
     * Copies an object.
     *
     * @private
     * @param {*} value The value to be copied
     * @param {Array} refFrom Array containing the source references
     * @param {Array} refTo Array containing the copied source references
     * @param {Boolean} deep Whether or not to perform deep cloning.
     * @return {*} The copied value.
     */
    var _clone = function _clone(value, refFrom, refTo, deep) {
        var copy = function copy(copiedValue) {
            var len = refFrom.length;
            var idx = 0;
            while (idx < len) {
                if (value === refFrom[idx]) {
                    return refTo[idx];
                }
                idx += 1;
            }
            refFrom[idx + 1] = value;
            refTo[idx + 1] = copiedValue;
            for (var key in value) {
                copiedValue[key] = deep ? _clone(value[key], refFrom, refTo, true) : value[key];
            }
            return copiedValue;
        };
        switch (type(value)) {
        case 'Object':
            return copy({});
        case 'Array':
            return copy([]);
        case 'Date':
            return new Date(value.valueOf());
        case 'RegExp':
            return _cloneRegExp(value);
        default:
            return value;
        }
    };

    var _createPartialApplicator = function _createPartialApplicator(concat) {
        return _curry2(function (fn, args) {
            return _arity(Math.max(0, fn.length - args.length), function () {
                return fn.apply(this, concat(args, arguments));
            });
        });
    };

    var _dropLast = function dropLast(n, xs) {
        return take(n < xs.length ? xs.length - n : 0, xs);
    };

    // Values of other types are only equal if identical.
    var _equals = function _equals(a, b, stackA, stackB) {
        if (identical(a, b)) {
            return true;
        }
        if (type(a) !== type(b)) {
            return false;
        }
        if (a == null || b == null) {
            return false;
        }
        if (typeof a.equals === 'function' || typeof b.equals === 'function') {
            return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
        }
        switch (type(a)) {
        case 'Arguments':
        case 'Array':
        case 'Object':
            if (typeof a.constructor === 'function' && _functionName(a.constructor) === 'Promise') {
                return a === b;
            }
            break;
        case 'Boolean':
        case 'Number':
        case 'String':
            if (!(typeof a === typeof b && identical(a.valueOf(), b.valueOf()))) {
                return false;
            }
            break;
        case 'Date':
            if (!identical(a.valueOf(), b.valueOf())) {
                return false;
            }
            break;
        case 'Error':
            return a.name === b.name && a.message === b.message;
        case 'RegExp':
            if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
                return false;
            }
            break;
        case 'Map':
        case 'Set':
            if (!_equals(_arrayFromIterator(a.entries()), _arrayFromIterator(b.entries()), stackA, stackB)) {
                return false;
            }
            break;
        case 'Int8Array':
        case 'Uint8Array':
        case 'Uint8ClampedArray':
        case 'Int16Array':
        case 'Uint16Array':
        case 'Int32Array':
        case 'Uint32Array':
        case 'Float32Array':
        case 'Float64Array':
            break;
        case 'ArrayBuffer':
            break;
        default:
            // Values of other types are only equal if identical.
            return false;
        }
        var keysA = keys(a);
        if (keysA.length !== keys(b).length) {
            return false;
        }
        var idx = stackA.length - 1;
        while (idx >= 0) {
            if (stackA[idx] === a) {
                return stackB[idx] === b;
            }
            idx -= 1;
        }
        stackA.push(a);
        stackB.push(b);
        idx = keysA.length - 1;
        while (idx >= 0) {
            var key = keysA[idx];
            if (!(_has(key, b) && _equals(b[key], a[key], stackA, stackB))) {
                return false;
            }
            idx -= 1;
        }
        stackA.pop();
        stackB.pop();
        return true;
    };

    /**
     * `_makeFlat` is a helper function that returns a one-level or fully recursive
     * function based on the flag passed in.
     *
     * @private
     */
    var _makeFlat = function _makeFlat(recursive) {
        return function flatt(list) {
            var value, jlen, j;
            var result = [];
            var idx = 0;
            var ilen = list.length;
            while (idx < ilen) {
                if (isArrayLike(list[idx])) {
                    value = recursive ? flatt(list[idx]) : list[idx];
                    j = 0;
                    jlen = value.length;
                    while (j < jlen) {
                        result[result.length] = value[j];
                        j += 1;
                    }
                } else {
                    result[result.length] = list[idx];
                }
                idx += 1;
            }
            return result;
        };
    };

    var _reduce = function () {
        function _arrayReduce(xf, acc, list) {
            var idx = 0;
            var len = list.length;
            while (idx < len) {
                acc = xf['@@transducer/step'](acc, list[idx]);
                if (acc && acc['@@transducer/reduced']) {
                    acc = acc['@@transducer/value'];
                    break;
                }
                idx += 1;
            }
            return xf['@@transducer/result'](acc);
        }
        function _iterableReduce(xf, acc, iter) {
            var step = iter.next();
            while (!step.done) {
                acc = xf['@@transducer/step'](acc, step.value);
                if (acc && acc['@@transducer/reduced']) {
                    acc = acc['@@transducer/value'];
                    break;
                }
                step = iter.next();
            }
            return xf['@@transducer/result'](acc);
        }
        function _methodReduce(xf, acc, obj) {
            return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));
        }
        var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
        return function _reduce(fn, acc, list) {
            if (typeof fn === 'function') {
                fn = _xwrap(fn);
            }
            if (isArrayLike(list)) {
                return _arrayReduce(fn, acc, list);
            }
            if (typeof list.reduce === 'function') {
                return _methodReduce(fn, acc, list);
            }
            if (list[symIterator] != null) {
                return _iterableReduce(fn, acc, list[symIterator]());
            }
            if (typeof list.next === 'function') {
                return _iterableReduce(fn, acc, list);
            }
            throw new TypeError('reduce: list must be array or iterable');
        };
    }();

    var _stepCat = function () {
        var _stepCatArray = {
            '@@transducer/init': Array,
            '@@transducer/step': function (xs, x) {
                xs.push(x);
                return xs;
            },
            '@@transducer/result': _identity
        };
        var _stepCatString = {
            '@@transducer/init': String,
            '@@transducer/step': function (a, b) {
                return a + b;
            },
            '@@transducer/result': _identity
        };
        var _stepCatObject = {
            '@@transducer/init': Object,
            '@@transducer/step': function (result, input) {
                return _assign(result, isArrayLike(input) ? objOf(input[0], input[1]) : input);
            },
            '@@transducer/result': _identity
        };
        return function _stepCat(obj) {
            if (_isTransformer(obj)) {
                return obj;
            }
            if (isArrayLike(obj)) {
                return _stepCatArray;
            }
            if (typeof obj === 'string') {
                return _stepCatString;
            }
            if (typeof obj === 'object') {
                return _stepCatObject;
            }
            throw new Error('Cannot create transformer for ' + obj);
        };
    }();

    var _xdropLastWhile = function () {
        function XDropLastWhile(fn, xf) {
            this.f = fn;
            this.retained = [];
            this.xf = xf;
        }
        XDropLastWhile.prototype['@@transducer/init'] = _xfBase.init;
        XDropLastWhile.prototype['@@transducer/result'] = function (result) {
            this.retained = null;
            return this.xf['@@transducer/result'](result);
        };
        XDropLastWhile.prototype['@@transducer/step'] = function (result, input) {
            return this.f(input) ? this.retain(result, input) : this.flush(result, input);
        };
        XDropLastWhile.prototype.flush = function (result, input) {
            result = _reduce(this.xf['@@transducer/step'], result, this.retained);
            this.retained = [];
            return this.xf['@@transducer/step'](result, input);
        };
        XDropLastWhile.prototype.retain = function (result, input) {
            this.retained.push(input);
            return result;
        };
        return _curry2(function _xdropLastWhile(fn, xf) {
            return new XDropLastWhile(fn, xf);
        });
    }();

    var _xgroupBy = function () {
        function XGroupBy(f, xf) {
            this.xf = xf;
            this.f = f;
            this.inputs = {};
        }
        XGroupBy.prototype['@@transducer/init'] = _xfBase.init;
        XGroupBy.prototype['@@transducer/result'] = function (result) {
            var key;
            for (key in this.inputs) {
                if (_has(key, this.inputs)) {
                    result = this.xf['@@transducer/step'](result, this.inputs[key]);
                    if (result['@@transducer/reduced']) {
                        result = result['@@transducer/value'];
                        break;
                    }
                }
            }
            this.inputs = null;
            return this.xf['@@transducer/result'](result);
        };
        XGroupBy.prototype['@@transducer/step'] = function (result, input) {
            var key = this.f(input);
            this.inputs[key] = this.inputs[key] || [
                key,
                []
            ];
            this.inputs[key][1] = append(input, this.inputs[key][1]);
            return result;
        };
        return _curry2(function _xgroupBy(f, xf) {
            return new XGroupBy(f, xf);
        });
    }();

    /**
     * Creates a new list iteration function from an existing one by adding two new
     * parameters to its callback function: the current index, and the entire list.
     *
     * This would turn, for instance, Ramda's simple `map` function into one that
     * more closely resembles `Array.prototype.map`. Note that this will only work
     * for functions in which the iteration callback function is the first
     * parameter, and where the list is the last parameter. (This latter might be
     * unimportant if the list parameter is not used.)
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category Function
     * @category List
     * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
     * @param {Function} fn A list iteration function that does not pass index or list to its callback
     * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
     * @example
     *
     *      var mapIndexed = R.addIndex(R.map);
     *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
     *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
     */
    var addIndex = _curry1(function addIndex(fn) {
        return curryN(fn.length, function () {
            var idx = 0;
            var origFn = arguments[0];
            var list = arguments[arguments.length - 1];
            var args = _slice(arguments);
            args[0] = function () {
                var result = origFn.apply(this, _concat(arguments, [
                    idx,
                    list
                ]));
                idx += 1;
                return result;
            };
            return fn.apply(this, args);
        });
    });

    /**
     * Wraps a function of any arity (including nullary) in a function that accepts
     * exactly 2 parameters. Any extraneous parameters will not be passed to the
     * supplied function.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Function
     * @sig (* -> c) -> (a, b -> c)
     * @param {Function} fn The function to wrap.
     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
     *         arity 2.
     * @example
     *
     *      var takesThreeArgs = function(a, b, c) {
     *        return [a, b, c];
     *      };
     *      takesThreeArgs.length; //=> 3
     *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
     *
     *      var takesTwoArgs = R.binary(takesThreeArgs);
     *      takesTwoArgs.length; //=> 2
     *      // Only 2 arguments are passed to the wrapped function
     *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
     */
    var binary = _curry1(function binary(fn) {
        return nAry(2, fn);
    });

    /**
     * Creates a deep copy of the value which may contain (nested) `Array`s and
     * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are not
     * copied, but assigned by their reference.
     *
     * Dispatches to a `clone` method if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {*} -> {*}
     * @param {*} value The object or array to clone
     * @return {*} A new object or array.
     * @example
     *
     *      var objects = [{}, {}, {}];
     *      var objectsClone = R.clone(objects);
     *      objects[0] === objectsClone[0]; //=> false
     */
    var clone = _curry1(function clone(value) {
        return value != null && typeof value.clone === 'function' ? value.clone() : _clone(value, [], [], true);
    });

    /**
     * Returns a curried equivalent of the provided function. The curried function
     * has two unusual capabilities. First, its arguments needn't be provided one
     * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
     * following are equivalent:
     *
     *   - `g(1)(2)(3)`
     *   - `g(1)(2, 3)`
     *   - `g(1, 2)(3)`
     *   - `g(1, 2, 3)`
     *
     * Secondly, the special placeholder value `R.__` may be used to specify
     * "gaps", allowing partial application of any combination of arguments,
     * regardless of their positions. If `g` is as above and `_` is `R.__`, the
     * following are equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (* -> a) -> (* -> a)
     * @param {Function} fn The function to curry.
     * @return {Function} A new, curried function.
     * @see R.curryN
     * @example
     *
     *      var addFourNumbers = (a, b, c, d) => a + b + c + d;
     *
     *      var curriedAddFourNumbers = R.curry(addFourNumbers);
     *      var f = curriedAddFourNumbers(1, 2);
     *      var g = f(3);
     *      g(4); //=> 10
     */
    var curry = _curry1(function curry(fn) {
        return curryN(fn.length, fn);
    });

    /**
     * Returns all but the first `n` elements of the given list, string, or
     * transducer/transformer (or object with a `drop` method).
     *
     * Dispatches to the `drop` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n
     * @param {*} list
     * @return {*}
     * @see R.take, R.transduce
     * @example
     *
     *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
     *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
     *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
     *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
     *      R.drop(3, 'ramda');               //=> 'da'
     */
    var drop = _curry2(_dispatchable('drop', _xdrop, function drop(n, xs) {
        return slice(Math.max(0, n), Infinity, xs);
    }));

    /**
     * Returns a list containing all but the last `n` elements of the given `list`.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n The number of elements of `xs` to skip.
     * @param {Array} xs The collection to consider.
     * @return {Array}
     * @see R.takeLast
     * @example
     *
     *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
     *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
     *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
     *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
     *      R.dropLast(3, 'ramda');               //=> 'ra'
     */
    var dropLast = _curry2(_dispatchable('dropLast', _xdropLast, _dropLast));

    /**
     * Returns a new list containing all but last the`n` elements of a given list,
     * passing each value from the right to the supplied predicate function,
     * skipping elements while the predicate function returns `true`. The predicate
     * function is passed one argument: (value)*.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.takeLastWhile, R.addIndex
     * @example
     *
     *      var lteThree = x => x <= 3;
     *
     *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]
     */
    var dropLastWhile = _curry2(_dispatchable('dropLastWhile', _xdropLastWhile, _dropLastWhile));

    /**
     * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
     * cyclical data structures.
     *
     * Dispatches symmetrically to the `equals` methods of both arguments, if
     * present.
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category Relation
     * @sig a -> b -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @example
     *
     *      R.equals(1, 1); //=> true
     *      R.equals(1, '1'); //=> false
     *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
     *
     *      var a = {}; a.v = a;
     *      var b = {}; b.v = b;
     *      R.equals(a, b); //=> true
     */
    var equals = _curry2(function equals(a, b) {
        return _equals(a, b, [], []);
    });

    /**
     * Takes a predicate and a "filterable", and returns a new filterable of the
     * same type containing the members of the given filterable which satisfy the
     * given predicate.
     *
     * Dispatches to the `filter` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Filterable f => (a -> Boolean) -> f a -> f a
     * @param {Function} pred
     * @param {Array} filterable
     * @return {Array}
     * @see R.reject, R.transduce, R.addIndex
     * @example
     *
     *      var isEven = n => n % 2 === 0;
     *
     *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
     *
     *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
     */
    // else
    var filter = _curry2(_dispatchable('filter', _xfilter, function (pred, filterable) {
        return _isObject(filterable) ? _reduce(function (acc, key) {
            if (pred(filterable[key])) {
                acc[key] = filterable[key];
            }
            return acc;
        }, {}, keys(filterable)) : // else
        _filter(pred, filterable);
    }));

    /**
     * Returns a new list by pulling every item out of it (and all its sub-arrays)
     * and putting them in a new array, depth-first.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [b]
     * @param {Array} list The array to consider.
     * @return {Array} The flattened list.
     * @see R.unnest
     * @example
     *
     *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
     *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
     */
    var flatten = _curry1(_makeFlat(true));

    /**
     * Returns a new function much like the supplied one, except that the first two
     * arguments' order is reversed.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z)
     * @param {Function} fn The function to invoke with its first two parameters reversed.
     * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
     * @example
     *
     *      var mergeThree = (a, b, c) => [].concat(a, b, c);
     *
     *      mergeThree(1, 2, 3); //=> [1, 2, 3]
     *
     *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
     */
    var flip = _curry1(function flip(fn) {
        return curry(function (a, b) {
            var args = _slice(arguments);
            args[0] = b;
            args[1] = a;
            return fn.apply(this, args);
        });
    });

    /**
     * Returns the first element of the given list or string. In some libraries
     * this function is named `first`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> a | Undefined
     * @sig String -> String
     * @param {Array|String} list
     * @return {*}
     * @see R.tail, R.init, R.last
     * @example
     *
     *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
     *      R.head([]); //=> undefined
     *
     *      R.head('abc'); //=> 'a'
     *      R.head(''); //=> ''
     */
    var head = nth(0);

    /**
     * Returns all but the last element of the given list or string.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category List
     * @sig [a] -> [a]
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @see R.last, R.head, R.tail
     * @example
     *
     *      R.init([1, 2, 3]);  //=> [1, 2]
     *      R.init([1, 2]);     //=> [1]
     *      R.init([1]);        //=> []
     *      R.init([]);         //=> []
     *
     *      R.init('abc');  //=> 'ab'
     *      R.init('ab');   //=> 'a'
     *      R.init('a');    //=> ''
     *      R.init('');     //=> ''
     */
    var init = slice(0, -1);

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of those
     * elements common to both lists. Duplication is determined according to the
     * value returned by applying the supplied predicate to two list elements.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
     * @param {Function} pred A predicate function that determines whether
     *        the two supplied elements are equal.
     * @param {Array} list1 One list of items to compare
     * @param {Array} list2 A second list of items to compare
     * @return {Array} A new list containing those elements common to both lists.
     * @see R.intersection
     * @example
     *
     *      var buffaloSpringfield = [
     *        {id: 824, name: 'Richie Furay'},
     *        {id: 956, name: 'Dewey Martin'},
     *        {id: 313, name: 'Bruce Palmer'},
     *        {id: 456, name: 'Stephen Stills'},
     *        {id: 177, name: 'Neil Young'}
     *      ];
     *      var csny = [
     *        {id: 204, name: 'David Crosby'},
     *        {id: 456, name: 'Stephen Stills'},
     *        {id: 539, name: 'Graham Nash'},
     *        {id: 177, name: 'Neil Young'}
     *      ];
     *
     *      R.intersectionWith(R.eqBy(R.prop('id')), buffaloSpringfield, csny);
     *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
     */
    var intersectionWith = _curry3(function intersectionWith(pred, list1, list2) {
        var lookupList, filteredList;
        if (list1.length > list2.length) {
            lookupList = list1;
            filteredList = list2;
        } else {
            lookupList = list2;
            filteredList = list1;
        }
        var results = [];
        var idx = 0;
        while (idx < filteredList.length) {
            if (_containsWith(pred, filteredList[idx], lookupList)) {
                results[results.length] = filteredList[idx];
            }
            idx += 1;
        }
        return uniqWith(pred, results);
    });

    /**
     * Transforms the items of the list with the transducer and appends the
     * transformed items to the accumulator using an appropriate iterator function
     * based on the accumulator type.
     *
     * The accumulator can be an array, string, object or a transformer. Iterated
     * items will be appended to arrays and concatenated to strings. Objects will
     * be merged directly or 2-item arrays will be merged as key, value pairs.
     *
     * The accumulator can also be a transformer object that provides a 2-arity
     * reducing iterator function, step, 0-arity initial value function, init, and
     * 1-arity result extraction function result. The step function is used as the
     * iterator function in reduce. The result function is used to convert the
     * final accumulator into the return type and in most cases is R.identity. The
     * init function is used to provide the initial accumulator.
     *
     * The iteration is performed with R.reduce after initializing the transducer.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category List
     * @sig a -> (b -> b) -> [c] -> a
     * @param {*} acc The initial accumulator value.
     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @example
     *
     *      var numbers = [1, 2, 3, 4];
     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
     *
     *      R.into([], transducer, numbers); //=> [2, 3]
     *
     *      var intoArray = R.into([]);
     *      intoArray(transducer, numbers); //=> [2, 3]
     */
    var into = _curry3(function into(acc, xf, list) {
        return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), _clone(acc, [], [], false), list);
    });

    /**
     * Same as R.invertObj, however this accounts for objects with duplicate values
     * by putting the values into an array.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Object
     * @sig {s: x} -> {x: [ s, ... ]}
     * @param {Object} obj The object or array to invert
     * @return {Object} out A new object with keys
     * in an array.
     * @example
     *
     *      var raceResultsByFirstName = {
     *        first: 'alice',
     *        second: 'jake',
     *        third: 'alice',
     *      };
     *      R.invert(raceResultsByFirstName);
     *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
     */
    var invert = _curry1(function invert(obj) {
        var props = keys(obj);
        var len = props.length;
        var idx = 0;
        var out = {};
        while (idx < len) {
            var key = props[idx];
            var val = obj[key];
            var list = _has(val, out) ? out[val] : out[val] = [];
            list[list.length] = key;
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a new object with the keys of the given object as values, and the
     * values of the given object, which are coerced to strings, as keys. Note
     * that the last key found is preferred when handling the same value.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Object
     * @sig {s: x} -> {x: s}
     * @param {Object} obj The object or array to invert
     * @return {Object} out A new object
     * @example
     *
     *      var raceResults = {
     *        first: 'alice',
     *        second: 'jake'
     *      };
     *      R.invertObj(raceResults);
     *      //=> { 'alice': 'first', 'jake':'second' }
     *
     *      // Alternatively:
     *      var raceResults = ['alice', 'jake'];
     *      R.invertObj(raceResults);
     *      //=> { 'alice': '0', 'jake':'1' }
     */
    var invertObj = _curry1(function invertObj(obj) {
        var props = keys(obj);
        var len = props.length;
        var idx = 0;
        var out = {};
        while (idx < len) {
            var key = props[idx];
            out[obj[key]] = key;
            idx += 1;
        }
        return out;
    });

    /**
     * Returns `true` if the given value is its type's empty value; `false`
     * otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Logic
     * @sig a -> Boolean
     * @param {*} x
     * @return {Boolean}
     * @see R.empty
     * @example
     *
     *      R.isEmpty([1, 2, 3]);   //=> false
     *      R.isEmpty([]);          //=> true
     *      R.isEmpty('');          //=> true
     *      R.isEmpty(null);        //=> false
     *      R.isEmpty({});          //=> true
     *      R.isEmpty({length: 0}); //=> false
     */
    var isEmpty = _curry1(function isEmpty(x) {
        return x != null && equals(x, empty(x));
    });

    /**
     * Returns the last element of the given list or string.
     *
     * @func
     * @memberOf R
     * @since v0.1.4
     * @category List
     * @sig [a] -> a | Undefined
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @see R.init, R.head, R.tail
     * @example
     *
     *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
     *      R.last([]); //=> undefined
     *
     *      R.last('abc'); //=> 'c'
     *      R.last(''); //=> ''
     */
    var last = nth(-1);

    /**
     * Returns the position of the last occurrence of an item in an array, or -1 if
     * the item is not included in the array. `R.equals` is used to determine
     * equality.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> Number
     * @param {*} target The item to find.
     * @param {Array} xs The array to search in.
     * @return {Number} the index of the target, or -1 if the target is not found.
     * @see R.indexOf
     * @example
     *
     *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
     *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
     */
    var lastIndexOf = _curry2(function lastIndexOf(target, xs) {
        if (typeof xs.lastIndexOf === 'function' && !_isArray(xs)) {
            return xs.lastIndexOf(target);
        } else {
            var idx = xs.length - 1;
            while (idx >= 0) {
                if (equals(xs[idx], target)) {
                    return idx;
                }
                idx -= 1;
            }
            return -1;
        }
    });

    /**
     * Takes a function and
     * a [functor](https://github.com/fantasyland/fantasy-land#functor),
     * applies the function to each of the functor's values, and returns
     * a functor of the same shape.
     *
     * Ramda provides suitable `map` implementations for `Array` and `Object`,
     * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
     *
     * Dispatches to the `map` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * Also treats functions as functors and will compose them together.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Functor f => (a -> b) -> f a -> f b
     * @param {Function} fn The function to be called on every element of the input `list`.
     * @param {Array} list The list to be iterated over.
     * @return {Array} The new list.
     * @see R.transduce, R.addIndex
     * @example
     *
     *      var double = x => x * 2;
     *
     *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
     *
     *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
     */
    var map = _curry2(_dispatchable('map', _xmap, function map(fn, functor) {
        switch (Object.prototype.toString.call(functor)) {
        case '[object Function]':
            return curryN(functor.length, function () {
                return fn.call(this, functor.apply(this, arguments));
            });
        case '[object Object]':
            return _reduce(function (acc, key) {
                acc[key] = fn(functor[key]);
                return acc;
            }, {}, keys(functor));
        default:
            return _map(fn, functor);
        }
    }));

    /**
     * An Object-specific version of `map`. The function is applied to three
     * arguments: *(value, key, obj)*. If only the value is significant, use
     * `map` instead.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Object
     * @sig ((*, String, Object) -> *) -> Object -> Object
     * @param {Function} fn
     * @param {Object} obj
     * @return {Object}
     * @see R.map
     * @example
     *
     *      var values = { x: 1, y: 2, z: 3 };
     *      var prependKeyAndDouble = (num, key, obj) => key + (num * 2);
     *
     *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }
     */
    var mapObjIndexed = _curry2(function mapObjIndexed(fn, obj) {
        return _reduce(function (acc, key) {
            acc[key] = fn(obj[key], key, obj);
            return acc;
        }, {}, keys(obj));
    });

    /**
     * Creates a new object with the own properties of the two provided objects. If
     * a key exists in both objects, the provided function is applied to the values
     * associated with the key in each object, with the result being used as the
     * value associated with the key in the returned object. The key will be
     * excluded from the returned object if the resulting value is `undefined`.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Object
     * @sig (a -> a -> a) -> {a} -> {a} -> {a}
     * @param {Function} fn
     * @param {Object} l
     * @param {Object} r
     * @return {Object}
     * @see R.merge, R.mergeWithKey
     * @example
     *
     *      R.mergeWith(R.concat,
     *                  { a: true, values: [10, 20] },
     *                  { b: true, values: [15, 35] });
     *      //=> { a: true, b: true, values: [10, 20, 15, 35] }
     */
    var mergeWith = _curry3(function mergeWith(fn, l, r) {
        return mergeWithKey(function (_, _l, _r) {
            return fn(_l, _r);
        }, l, r);
    });

    /**
     * Takes a function `f` and a list of arguments, and returns a function `g`.
     * When applied, `g` returns the result of applying `f` to the arguments
     * provided initially followed by the arguments provided to `g`.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Function
     * @sig ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x)
     * @param {Function} f
     * @param {Array} args
     * @return {Function}
     * @see R.partialRight
     * @example
     *
     *      var multiply = (a, b) => a * b;
     *      var double = R.partial(multiply, [2]);
     *      double(2); //=> 4
     *
     *      var greet = (salutation, title, firstName, lastName) =>
     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
     *
     *      var sayHello = R.partial(greet, ['Hello']);
     *      var sayHelloToMs = R.partial(sayHello, ['Ms.']);
     *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
     */
    var partial = _createPartialApplicator(_concat);

    /**
     * Takes a function `f` and a list of arguments, and returns a function `g`.
     * When applied, `g` returns the result of applying `f` to the arguments
     * provided to `g` followed by the arguments provided initially.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Function
     * @sig ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)
     * @param {Function} f
     * @param {Array} args
     * @return {Function}
     * @see R.partial
     * @example
     *
     *      var greet = (salutation, title, firstName, lastName) =>
     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
     *
     *      var greetMsJaneJones = R.partialRight(greet, ['Ms.', 'Jane', 'Jones']);
     *
     *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
     */
    var partialRight = _createPartialApplicator(flip(_concat));

    /**
     * Determines whether a nested path on an object has a specific value, in
     * `R.equals` terms. Most likely used to filter a list.
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Relation
     * @sig [String] -> * -> {String: *} -> Boolean
     * @param {Array} path The path of the nested property to use
     * @param {*} val The value to compare the nested property with
     * @param {Object} obj The object to check the nested property in
     * @return {Boolean} `true` if the value equals the nested object property,
     *         `false` otherwise.
     * @example
     *
     *      var user1 = { address: { zipCode: 90210 } };
     *      var user2 = { address: { zipCode: 55555 } };
     *      var user3 = { name: 'Bob' };
     *      var users = [ user1, user2, user3 ];
     *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);
     *      R.filter(isFamous, users); //=> [ user1 ]
     */
    var pathEq = _curry3(function pathEq(_path, val, obj) {
        return equals(path(_path, obj), val);
    });

    /**
     * Returns a new list by plucking the same named property off all objects in
     * the list supplied.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig k -> [{k: v}] -> [v]
     * @param {Number|String} key The key name to pluck off of each object.
     * @param {Array} list The array to consider.
     * @return {Array} The list of values for the given key.
     * @see R.props
     * @example
     *
     *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
     *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
     */
    var pluck = _curry2(function pluck(p, list) {
        return map(prop(p), list);
    });

    /**
     * Reasonable analog to SQL `select` statement.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @category Relation
     * @sig [k] -> [{k: v}] -> [{k: v}]
     * @param {Array} props The property names to project
     * @param {Array} objs The objects to query
     * @return {Array} An array of objects with just the `props` properties.
     * @example
     *
     *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
     *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
     *      var kids = [abby, fred];
     *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
     */
    // passing `identity` gives correct arity
    var project = useWith(_map, [
        pickAll,
        identity
    ]);

    /**
     * Returns `true` if the specified object property is equal, in `R.equals`
     * terms, to the given value; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig String -> a -> Object -> Boolean
     * @param {String} name
     * @param {*} val
     * @param {*} obj
     * @return {Boolean}
     * @see R.equals, R.propSatisfies
     * @example
     *
     *      var abby = {name: 'Abby', age: 7, hair: 'blond'};
     *      var fred = {name: 'Fred', age: 12, hair: 'brown'};
     *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};
     *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};
     *      var kids = [abby, fred, rusty, alois];
     *      var hasBrownHair = R.propEq('hair', 'brown');
     *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
     */
    var propEq = _curry3(function propEq(name, val, obj) {
        return propSatisfies(equals(val), name, obj);
    });

    /**
     * Returns `true` if the specified object property is of the given type;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Type
     * @sig Type -> String -> Object -> Boolean
     * @param {Function} type
     * @param {String} name
     * @param {*} obj
     * @return {Boolean}
     * @see R.is, R.propSatisfies
     * @example
     *
     *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
     *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
     *      R.propIs(Number, 'x', {});            //=> false
     */
    var propIs = _curry3(function propIs(type, name, obj) {
        return propSatisfies(is(type), name, obj);
    });

    /**
     * Returns a single item by iterating through the list, successively calling
     * the iterator function and passing it an accumulator value and the current
     * value from the array, and then passing the result to the next call.
     *
     * The iterator function receives two values: *(acc, value)*. It may use
     * `R.reduced` to shortcut the iteration.
     *
     * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
     * arrays), unlike the native `Array.prototype.reduce` method. For more details
     * on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
     *
     * Dispatches to the `reduce` method of the third argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig ((a, b) -> a) -> a -> [b] -> a
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.reduced, R.addIndex
     * @example
     *
     *      var numbers = [1, 2, 3];
     *      var add = (a, b) => a + b;
     *
     *      R.reduce(add, 10, numbers); //=> 16
     */
    var reduce = _curry3(_reduce);

    /**
     * Groups the elements of the list according to the result of calling
     * the String-returning function `keyFn` on each element and reduces the elements
     * of each group to a single value via the reducer function `valueFn`.
     *
     * This function is basically a more general `groupBy` function.
     *
     * @func
     * @memberOf R
     * @since v0.20.0
     * @category List
     * @sig ((a, b) -> a) -> a -> (b -> String) -> [b] -> {String: a}
     * @param {Function} valueFn The function that reduces the elements of each group to a single
     *        value. Receives two values, accumulator for a particular group and the current element.
     * @param {*} acc The (initial) accumulator value for each group.
     * @param {Function} keyFn The function that maps the list's element into a key.
     * @param {Array} list The array to group.
     * @return {Object} An object with the output of `keyFn` for keys, mapped to the output of
     *         `valueFn` for elements which produced that key when passed to `keyFn`.
     * @see R.groupBy, R.reduce
     * @example
     *
     *      var reduceToNamesBy = R.reduceBy((acc, student) => acc.concat(student.name), []);
     *      var namesByGrade = reduceToNamesBy(function(student) {
     *        var score = student.score;
     *        return score < 65 ? 'F' :
     *               score < 70 ? 'D' :
     *               score < 80 ? 'C' :
     *               score < 90 ? 'B' : 'A';
     *      });
     *      var students = [{name: 'Lucy', score: 92},
     *                      {name: 'Drew', score: 85},
     *                      // ...
     *                      {name: 'Bart', score: 62}];
     *      namesByGrade(students);
     *      // {
     *      //   'A': ['Lucy'],
     *      //   'B': ['Drew']
     *      //   // ...,
     *      //   'F': ['Bart']
     *      // }
     */
    var reduceBy = _curryN(4, [], function reduceBy(valueFn, valueAcc, keyFn, list) {
        return _reduce(function (acc, elt) {
            var key = keyFn(elt);
            acc[key] = valueFn(_has(key, acc) ? acc[key] : valueAcc, elt);
            return acc;
        }, {}, list);
    });

    /**
     * The complement of `filter`.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Filterable f => (a -> Boolean) -> f a -> f a
     * @param {Function} pred
     * @param {Array} filterable
     * @return {Array}
     * @see R.filter, R.transduce, R.addIndex
     * @example
     *
     *      var isOdd = (n) => n % 2 === 1;
     *
     *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
     *
     *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
     */
    var reject = _curry2(function reject(pred, filterable) {
        return filter(_complement(pred), filterable);
    });

    /**
     * Returns a fixed list of size `n` containing a specified identical value.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig a -> n -> [a]
     * @param {*} value The value to repeat.
     * @param {Number} n The desired size of the output list.
     * @return {Array} A new array containing `n` `value`s.
     * @example
     *
     *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
     *
     *      var obj = {};
     *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
     *      repeatedObjs[0] === repeatedObjs[1]; //=> true
     */
    var repeat = _curry2(function repeat(value, n) {
        return times(always(value), n);
    });

    /**
     * Adds together all the elements of a list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list An array of numbers
     * @return {Number} The sum of all the numbers in the list.
     * @see R.reduce
     * @example
     *
     *      R.sum([2,4,6,8,100,1]); //=> 121
     */
    var sum = reduce(add, 0);

    /**
     * Returns a new list containing the last `n` elements of the given list.
     * If `n > list.length`, returns a list of `list.length` elements.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n The number of elements to return.
     * @param {Array} xs The collection to consider.
     * @return {Array}
     * @see R.dropLast
     * @example
     *
     *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
     *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
     *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.takeLast(3, 'ramda');               //=> 'mda'
     */
    var takeLast = _curry2(function takeLast(n, xs) {
        return drop(n >= 0 ? xs.length - n : 0, xs);
    });

    /**
     * Initializes a transducer using supplied iterator function. Returns a single
     * item by iterating through the list, successively calling the transformed
     * iterator function and passing it an accumulator value and the current value
     * from the array, and then passing the result to the next call.
     *
     * The iterator function receives two values: *(acc, value)*. It will be
     * wrapped as a transformer to initialize the transducer. A transformer can be
     * passed directly in place of an iterator function. In both cases, iteration
     * may be stopped early with the `R.reduced` function.
     *
     * A transducer is a function that accepts a transformer and returns a
     * transformer and can be composed directly.
     *
     * A transformer is an an object that provides a 2-arity reducing iterator
     * function, step, 0-arity initial value function, init, and 1-arity result
     * extraction function, result. The step function is used as the iterator
     * function in reduce. The result function is used to convert the final
     * accumulator into the return type and in most cases is R.identity. The init
     * function can be used to provide an initial accumulator, but is ignored by
     * transduce.
     *
     * The iteration is performed with R.reduce after initializing the transducer.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category List
     * @sig (c -> c) -> (a,b -> a) -> a -> [b] -> a
     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array. Wrapped as transformer, if necessary, and used to
     *        initialize the transducer
     * @param {*} acc The initial accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.reduce, R.reduced, R.into
     * @example
     *
     *      var numbers = [1, 2, 3, 4];
     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
     *
     *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
     */
    var transduce = curryN(4, function transduce(xf, fn, acc, list) {
        return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
    });

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of the elements
     * of each list. Duplication is determined according to the value returned by
     * applying the supplied predicate to two list elements.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The first and second lists concatenated, with
     *         duplicates removed.
     * @see R.union
     * @example
     *
     *      var l1 = [{a: 1}, {a: 2}];
     *      var l2 = [{a: 1}, {a: 4}];
     *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
     */
    var unionWith = _curry3(function unionWith(pred, list1, list2) {
        return uniqWith(pred, _concat(list1, list2));
    });

    /**
     * Takes a spec object and a test object; returns true if the test satisfies
     * the spec, false otherwise. An object satisfies the spec if, for each of the
     * spec's own properties, accessing that property of the object gives the same
     * value (in `R.equals` terms) as accessing that property of the spec.
     *
     * `whereEq` is a specialization of [`where`](#where).
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Object
     * @sig {String: *} -> {String: *} -> Boolean
     * @param {Object} spec
     * @param {Object} testObj
     * @return {Boolean}
     * @see R.where
     * @example
     *
     *      // pred :: Object -> Boolean
     *      var pred = R.whereEq({a: 1, b: 2});
     *
     *      pred({a: 1});              //=> false
     *      pred({a: 1, b: 2});        //=> true
     *      pred({a: 1, b: 2, c: 3});  //=> true
     *      pred({a: 1, b: 1});        //=> false
     */
    var whereEq = _curry2(function whereEq(spec, testObj) {
        return where(map(equals, spec), testObj);
    });

    var _flatCat = function () {
        var preservingReduced = function (xf) {
            return {
                '@@transducer/init': _xfBase.init,
                '@@transducer/result': function (result) {
                    return xf['@@transducer/result'](result);
                },
                '@@transducer/step': function (result, input) {
                    var ret = xf['@@transducer/step'](result, input);
                    return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
                }
            };
        };
        return function _xcat(xf) {
            var rxf = preservingReduced(xf);
            return {
                '@@transducer/init': _xfBase.init,
                '@@transducer/result': function (result) {
                    return rxf['@@transducer/result'](result);
                },
                '@@transducer/step': function (result, input) {
                    return !isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
                }
            };
        };
    }();

    // Array.prototype.indexOf doesn't exist below IE9
    // manually crawl the list to distinguish between +0 and -0
    // NaN
    // non-zero numbers can utilise Set
    // all these types can utilise Set
    // null can utilise Set
    // anything else not covered above, defer to R.equals
    var _indexOf = function _indexOf(list, a, idx) {
        var inf, item;
        // Array.prototype.indexOf doesn't exist below IE9
        if (typeof list.indexOf === 'function') {
            switch (typeof a) {
            case 'number':
                if (a === 0) {
                    // manually crawl the list to distinguish between +0 and -0
                    inf = 1 / a;
                    while (idx < list.length) {
                        item = list[idx];
                        if (item === 0 && 1 / item === inf) {
                            return idx;
                        }
                        idx += 1;
                    }
                    return -1;
                } else if (a !== a) {
                    // NaN
                    while (idx < list.length) {
                        item = list[idx];
                        if (typeof item === 'number' && item !== item) {
                            return idx;
                        }
                        idx += 1;
                    }
                    return -1;
                }
                // non-zero numbers can utilise Set
                return list.indexOf(a, idx);
            // all these types can utilise Set
            case 'string':
            case 'boolean':
            case 'function':
            case 'undefined':
                return list.indexOf(a, idx);
            case 'object':
                if (a === null) {
                    // null can utilise Set
                    return list.indexOf(a, idx);
                }
            }
        }
        // anything else not covered above, defer to R.equals
        while (idx < list.length) {
            if (equals(list[idx], a)) {
                return idx;
            }
            idx += 1;
        }
        return -1;
    };

    var _xchain = _curry2(function _xchain(f, xf) {
        return map(f, _flatCat(xf));
    });

    /**
     * Takes a list of predicates and returns a predicate that returns true for a
     * given list of arguments if every one of the provided predicates is satisfied
     * by those arguments.
     *
     * The function returned is a curried function whose arity matches that of the
     * highest-arity predicate.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Logic
     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
     * @param {Array} preds
     * @return {Function}
     * @see R.anyPass
     * @example
     *
     *      var isQueen = R.propEq('rank', 'Q');
     *      var isSpade = R.propEq('suit', '');
     *      var isQueenOfSpades = R.allPass([isQueen, isSpade]);
     *
     *      isQueenOfSpades({rank: 'Q', suit: ''}); //=> false
     *      isQueenOfSpades({rank: 'Q', suit: ''}); //=> true
     */
    var allPass = _curry1(function allPass(preds) {
        return curryN(reduce(max, 0, pluck('length', preds)), function () {
            var idx = 0;
            var len = preds.length;
            while (idx < len) {
                if (!preds[idx].apply(this, arguments)) {
                    return false;
                }
                idx += 1;
            }
            return true;
        });
    });

    /**
     * Returns `true` if all elements are unique, in `R.equals` terms, otherwise
     * `false`.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category List
     * @sig [a] -> Boolean
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if all elements are unique, else `false`.
     * @deprecated since v0.20.0
     * @example
     *
     *      R.allUniq(['1', 1]); //=> true
     *      R.allUniq([1, 1]);   //=> false
     *      R.allUniq([[42], [42]]); //=> false
     */
    var allUniq = _curry1(function allUniq(list) {
        var len = list.length;
        var idx = 0;
        while (idx < len) {
            if (_indexOf(list, list[idx], idx + 1) >= 0) {
                return false;
            }
            idx += 1;
        }
        return true;
    });

    /**
     * Takes a list of predicates and returns a predicate that returns true for a
     * given list of arguments if at least one of the provided predicates is
     * satisfied by those arguments.
     *
     * The function returned is a curried function whose arity matches that of the
     * highest-arity predicate.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Logic
     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
     * @param {Array} preds
     * @return {Function}
     * @see R.allPass
     * @example
     *
     *      var gte = R.anyPass([R.gt, R.equals]);
     *
     *      gte(3, 2); //=> true
     *      gte(2, 2); //=> true
     *      gte(2, 3); //=> false
     */
    var anyPass = _curry1(function anyPass(preds) {
        return curryN(reduce(max, 0, pluck('length', preds)), function () {
            var idx = 0;
            var len = preds.length;
            while (idx < len) {
                if (preds[idx].apply(this, arguments)) {
                    return true;
                }
                idx += 1;
            }
            return false;
        });
    });

    /**
     * ap applies a list of functions to a list of values.
     *
     * Dispatches to the `ap` method of the second argument, if present. Also
     * treats functions as applicatives.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Function
     * @sig [f] -> [a] -> [f a]
     * @param {Array} fns An array of functions
     * @param {Array} vs An array of values
     * @return {Array} An array of results of applying each of `fns` to all of `vs` in turn.
     * @example
     *
     *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
     */
    // else
    var ap = _curry2(function ap(applicative, fn) {
        return typeof applicative.ap === 'function' ? applicative.ap(fn) : typeof applicative === 'function' ? curryN(Math.max(applicative.length, fn.length), function () {
            return applicative.apply(this, arguments)(fn.apply(this, arguments));
        }) : // else
        _reduce(function (acc, f) {
            return _concat(acc, map(f, fn));
        }, [], applicative);
    });

    /**
     * Given a spec object recursively mapping properties to functions, creates a
     * function producing an object of the same structure, by mapping each property
     * to the result of calling its associated function with the supplied arguments.
     *
     * @func
     * @memberOf R
     * @since v0.20.0
     * @category Function
     * @sig {k: ((a, b, ..., m) -> v)} -> ((a, b, ..., m) -> {k: v})
     * @param {Object} spec an object recursively mapping properties to functions for
     *        producing the values for these properties.
     * @return {Function} A function that returns an object of the same structure
     * as `spec', with each property set to the value returned by calling its
     * associated function with the supplied arguments.
     * @see R.juxt
     * @example
     *
     *      var getMetrics = R.applySpec({
     *                                      sum: R.add,
     *                                      nested: { mul: R.multiply }
     *                                   });
     *      getMetrics(2, 4); // => { sum: 6, nested: { mul: 8 } }
     */
    var applySpec = _curry1(function applySpec(spec) {
        spec = map(function (v) {
            return typeof v == 'function' ? v : applySpec(v);
        }, spec);
        return curryN(reduce(max, 0, pluck('length', values(spec))), function () {
            var args = arguments;
            return map(function (f) {
                return apply(f, args);
            }, spec);
        });
    });

    /**
     * Returns the result of calling its first argument with the remaining
     * arguments. This is occasionally useful as a converging function for
     * `R.converge`: the left branch can produce a function while the right branch
     * produces a value to be passed to that function as an argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Function
     * @sig (*... -> a),*... -> a
     * @param {Function} fn The function to apply to the remaining arguments.
     * @param {...*} args Any number of positional arguments.
     * @return {*}
     * @see R.apply
     * @example
     *
     *      var indentN = R.pipe(R.times(R.always(' ')),
     *                           R.join(''),
     *                           R.replace(/^(?!$)/gm));
     *
     *      var format = R.converge(R.call, [
     *                                  R.pipe(R.prop('indent'), indentN),
     *                                  R.prop('value')
     *                              ]);
     *
     *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
     */
    var call = curry(function call(fn) {
        return fn.apply(this, _slice(arguments, 1));
    });

    /**
     * `chain` maps a function over a list and concatenates the results. `chain`
     * is also known as `flatMap` in some libraries
     *
     * Dispatches to the `chain` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig (a -> [b]) -> [a] -> [b]
     * @param {Function} fn
     * @param {Array} list
     * @return {Array}
     * @example
     *
     *      var duplicate = n => [n, n];
     *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
     */
    var chain = _curry2(_dispatchable('chain', _xchain, function chain(fn, monad) {
        if (typeof monad === 'function') {
            return function () {
                return monad.call(this, fn.apply(this, arguments)).apply(this, arguments);
            };
        }
        return _makeFlat(false)(map(fn, monad));
    }));

    /**
     * Returns a function, `fn`, which encapsulates if/else-if/else logic.
     * `R.cond` takes a list of [predicate, transform] pairs. All of the arguments
     * to `fn` are applied to each of the predicates in turn until one returns a
     * "truthy" value, at which point `fn` returns the result of applying its
     * arguments to the corresponding transformer. If none of the predicates
     * matches, `fn` returns undefined.
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category Logic
     * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
     * @param {Array} pairs
     * @return {Function}
     * @example
     *
     *      var fn = R.cond([
     *        [R.equals(0),   R.always('water freezes at 0C')],
     *        [R.equals(100), R.always('water boils at 100C')],
     *        [R.T,           temp => 'nothing special happens at ' + temp + 'C']
     *      ]);
     *      fn(0); //=> 'water freezes at 0C'
     *      fn(50); //=> 'nothing special happens at 50C'
     *      fn(100); //=> 'water boils at 100C'
     */
    var cond = _curry1(function cond(pairs) {
        var arity = reduce(max, 0, map(function (pair) {
            return pair[0].length;
        }, pairs));
        return _arity(arity, function () {
            var idx = 0;
            while (idx < pairs.length) {
                if (pairs[idx][0].apply(this, arguments)) {
                    return pairs[idx][1].apply(this, arguments);
                }
                idx += 1;
            }
        });
    });

    /**
     * Wraps a constructor function inside a curried function that can be called
     * with the same arguments and returns the same type. The arity of the function
     * returned is specified to allow using variadic constructor functions.
     *
     * @func
     * @memberOf R
     * @since v0.4.0
     * @category Function
     * @sig Number -> (* -> {*}) -> (* -> {*})
     * @param {Number} n The arity of the constructor function.
     * @param {Function} Fn The constructor function to wrap.
     * @return {Function} A wrapped, curried constructor function.
     * @example
     *
     *      // Variadic constructor function
     *      var Widget = () => {
     *        this.children = Array.prototype.slice.call(arguments);
     *        // ...
     *      };
     *      Widget.prototype = {
     *        // ...
     *      };
     *      var allConfigs = [
     *        // ...
     *      ];
     *      R.map(R.constructN(1, Widget), allConfigs); // a list of Widgets
     */
    var constructN = _curry2(function constructN(n, Fn) {
        if (n > 10) {
            throw new Error('Constructor with greater than ten arguments');
        }
        if (n === 0) {
            return function () {
                return new Fn();
            };
        }
        return curry(nAry(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
            switch (arguments.length) {
            case 1:
                return new Fn($0);
            case 2:
                return new Fn($0, $1);
            case 3:
                return new Fn($0, $1, $2);
            case 4:
                return new Fn($0, $1, $2, $3);
            case 5:
                return new Fn($0, $1, $2, $3, $4);
            case 6:
                return new Fn($0, $1, $2, $3, $4, $5);
            case 7:
                return new Fn($0, $1, $2, $3, $4, $5, $6);
            case 8:
                return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
            case 9:
                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
            case 10:
                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
            }
        }));
    });

    /**
     * Accepts a converging function and a list of branching functions and returns
     * a new function. When invoked, this new function is applied to some
     * arguments, each branching function is applied to those same arguments. The
     * results of each branching function are passed as arguments to the converging
     * function to produce the return value.
     *
     * @func
     * @memberOf R
     * @since v0.4.2
     * @category Function
     * @sig (x1 -> x2 -> ... -> z) -> [(a -> b -> ... -> x1), (a -> b -> ... -> x2), ...] -> (a -> b -> ... -> z)
     * @param {Function} after A function. `after` will be invoked with the return values of
     *        `fn1` and `fn2` as its arguments.
     * @param {Array} functions A list of functions.
     * @return {Function} A new function.
     * @example
     *
     *      var add = (a, b) => a + b;
     *      var multiply = (a, b) => a * b;
     *      var subtract = (a, b) => a - b;
     *
     *      // multiply( add(1, 2), subtract(1, 2) );
     *      R.converge(multiply, [add, subtract])(1, 2); //=> -3
     *
     *      var add3 = (a, b, c) => a + b + c;
     *      R.converge(add3, [multiply, add, subtract])(1, 2); //=> 4
     */
    var converge = _curry2(function converge(after, fns) {
        return curryN(reduce(max, 0, pluck('length', fns)), function () {
            var args = arguments;
            var context = this;
            return after.apply(context, _map(function (fn) {
                return fn.apply(context, args);
            }, fns));
        });
    });

    /**
     * Counts the elements of a list according to how many match each value of a
     * key generated by the supplied function. Returns an object mapping the keys
     * produced by `fn` to the number of occurrences in the list. Note that all
     * keys are coerced to strings because of how JavaScript objects work.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig (a -> String) -> [a] -> {*}
     * @param {Function} fn The function used to map values to keys.
     * @param {Array} list The list to count elements from.
     * @return {Object} An object mapping keys to number of occurrences in the list.
     * @example
     *
     *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
     *      var letters = R.split('', 'abcABCaaaBBc');
     *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
     *      R.countBy(R.toLower)(letters);   //=> {'a': 5, 'b': 4, 'c': 3}
     */
    var countBy = reduceBy(function (acc, elem) {
        return acc + 1;
    }, 0);

    /**
     * Returns a new list without any consecutively repeating elements. Equality is
     * determined by applying the supplied predicate two consecutive elements. The
     * first element in a series of equal element is the one being preserved.
     *
     * Dispatches to the `dropRepeatsWith` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig (a, a -> Boolean) -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list The array to consider.
     * @return {Array} `list` without repeating elements.
     * @see R.transduce
     * @example
     *
     *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
     *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]
     */
    var dropRepeatsWith = _curry2(_dispatchable('dropRepeatsWith', _xdropRepeatsWith, function dropRepeatsWith(pred, list) {
        var result = [];
        var idx = 1;
        var len = list.length;
        if (len !== 0) {
            result[0] = list[0];
            while (idx < len) {
                if (!pred(last(result), list[idx])) {
                    result[result.length] = list[idx];
                }
                idx += 1;
            }
        }
        return result;
    }));

    /**
     * Takes a function and two values in its domain and returns `true` if the
     * values map to the same value in the codomain; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Relation
     * @sig (a -> b) -> a -> a -> Boolean
     * @param {Function} f
     * @param {*} x
     * @param {*} y
     * @return {Boolean}
     * @example
     *
     *      R.eqBy(Math.abs, 5, -5); //=> true
     */
    var eqBy = _curry3(function eqBy(f, x, y) {
        return equals(f(x), f(y));
    });

    /**
     * Reports whether two objects have the same value, in `R.equals` terms, for
     * the specified property. Useful as a curried predicate.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig k -> {k: v} -> {k: v} -> Boolean
     * @param {String} prop The name of the property to compare
     * @param {Object} obj1
     * @param {Object} obj2
     * @return {Boolean}
     *
     * @example
     *
     *      var o1 = { a: 1, b: 2, c: 3, d: 4 };
     *      var o2 = { a: 10, b: 20, c: 3, d: 40 };
     *      R.eqProps('a', o1, o2); //=> false
     *      R.eqProps('c', o1, o2); //=> true
     */
    var eqProps = _curry3(function eqProps(prop, obj1, obj2) {
        return equals(obj1[prop], obj2[prop]);
    });

    /**
     * Splits a list into sub-lists stored in an object, based on the result of
     * calling a String-returning function on each element, and grouping the
     * results according to values returned.
     *
     * Dispatches to the `groupBy` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> String) -> [a] -> {String: [a]}
     * @param {Function} fn Function :: a -> String
     * @param {Array} list The array to group
     * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
     *         that produced that key when passed to `fn`.
     * @see R.transduce
     * @example
     *
     *      var byGrade = R.groupBy(function(student) {
     *        var score = student.score;
     *        return score < 65 ? 'F' :
     *               score < 70 ? 'D' :
     *               score < 80 ? 'C' :
     *               score < 90 ? 'B' : 'A';
     *      });
     *      var students = [{name: 'Abby', score: 84},
     *                      {name: 'Eddy', score: 58},
     *                      // ...
     *                      {name: 'Jack', score: 69}];
     *      byGrade(students);
     *      // {
     *      //   'A': [{name: 'Dianne', score: 99}],
     *      //   'B': [{name: 'Abby', score: 84}]
     *      //   // ...,
     *      //   'F': [{name: 'Eddy', score: 58}]
     *      // }
     */
    var groupBy = _curry2(_dispatchable('groupBy', _xgroupBy, reduceBy(function (acc, item) {
        if (acc == null) {
            acc = [];
        }
        acc.push(item);
        return acc;
    }, null)));

    /**
     * Given a function that generates a key, turns a list of objects into an
     * object indexing the objects by the given key. Note that if multiple
     * objects generate the same value for the indexing key only the last value
     * will be included in the generated object.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig (a -> String) -> [{k: v}] -> {k: {k: v}}
     * @param {Function} fn Function :: a -> String
     * @param {Array} array The array of objects to index
     * @return {Object} An object indexing each array element by the given property.
     * @example
     *
     *      var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];
     *      R.indexBy(R.prop('id'), list);
     *      //=> {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}}
     */
    var indexBy = reduceBy(function (acc, elem) {
        return elem;
    }, null);

    /**
     * Returns the position of the first occurrence of an item in an array, or -1
     * if the item is not included in the array. `R.equals` is used to determine
     * equality.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> Number
     * @param {*} target The item to find.
     * @param {Array} xs The array to search in.
     * @return {Number} the index of the target, or -1 if the target is not found.
     * @see R.lastIndexOf
     * @example
     *
     *      R.indexOf(3, [1,2,3,4]); //=> 2
     *      R.indexOf(10, [1,2,3,4]); //=> -1
     */
    var indexOf = _curry2(function indexOf(target, xs) {
        return typeof xs.indexOf === 'function' && !_isArray(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
    });

    /**
     * juxt applies a list of functions to a list of values.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Function
     * @sig [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])
     * @param {Array} fns An array of functions
     * @return {Function} A function that returns a list of values after applying each of the original `fns` to its parameters.
     * @see R.applySpec
     * @example
     *
     *      var range = R.juxt([Math.min, Math.max]);
     *      range(3, 4, 9, -3); //=> [-3, 9]
     */
    var juxt = _curry1(function juxt(fns) {
        return converge(_arrayOf, fns);
    });

    /**
     * Returns a lens for the given getter and setter functions. The getter "gets"
     * the value of the focus; the setter "sets" the value of the focus. The setter
     * should not mutate the data structure.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
     * @param {Function} getter
     * @param {Function} setter
     * @return {Lens}
     * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
     * @example
     *
     *      var xLens = R.lens(R.prop('x'), R.assoc('x'));
     *
     *      R.view(xLens, {x: 1, y: 2});            //=> 1
     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
     */
    var lens = _curry2(function lens(getter, setter) {
        return function (toFunctorFn) {
            return function (target) {
                return map(function (focus) {
                    return setter(focus, target);
                }, toFunctorFn(getter(target)));
            };
        };
    });

    /**
     * Returns a lens whose focus is the specified index.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Number -> Lens s a
     * @param {Number} n
     * @return {Lens}
     * @see R.view, R.set, R.over
     * @example
     *
     *      var headLens = R.lensIndex(0);
     *
     *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
     *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
     *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
     */
    var lensIndex = _curry1(function lensIndex(n) {
        return lens(nth(n), update(n));
    });

    /**
     * Returns a lens whose focus is the specified path.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig [String] -> Lens s a
     * @param {Array} path The path to use.
     * @return {Lens}
     * @see R.view, R.set, R.over
     * @example
     *
     *      var xyLens = R.lensPath(['x', 'y']);
     *
     *      R.view(xyLens, {x: {y: 2, z: 3}});            //=> 2
     *      R.set(xyLens, 4, {x: {y: 2, z: 3}});          //=> {x: {y: 4, z: 3}}
     *      R.over(xyLens, R.negate, {x: {y: 2, z: 3}});  //=> {x: {y: -2, z: 3}}
     */
    var lensPath = _curry1(function lensPath(p) {
        return lens(path(p), assocPath(p));
    });

    /**
     * Returns a lens whose focus is the specified property.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig String -> Lens s a
     * @param {String} k
     * @return {Lens}
     * @see R.view, R.set, R.over
     * @example
     *
     *      var xLens = R.lensProp('x');
     *
     *      R.view(xLens, {x: 1, y: 2});            //=> 1
     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
     */
    var lensProp = _curry1(function lensProp(k) {
        return lens(prop(k), assoc(k));
    });

    /**
     * "lifts" a function to be the specified arity, so that it may "map over" that
     * many lists, Functions or other objects that satisfy the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Function
     * @sig Number -> (*... -> *) -> ([*]... -> [*])
     * @param {Function} fn The function to lift into higher context
     * @return {Function} The lifted function.
     * @see R.lift, R.ap
     * @example
     *
     *      var madd3 = R.liftN(3, R.curryN(3, (...args) => R.sum(args)));
     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
     */
    var liftN = _curry2(function liftN(arity, fn) {
        var lifted = curryN(arity, fn);
        return curryN(arity, function () {
            return _reduce(ap, map(lifted, arguments[0]), _slice(arguments, 1));
        });
    });

    /**
     * Returns the mean of the given list of numbers.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list
     * @return {Number}
     * @example
     *
     *      R.mean([2, 7, 9]); //=> 6
     *      R.mean([]); //=> NaN
     */
    var mean = _curry1(function mean(list) {
        return sum(list) / list.length;
    });

    /**
     * Returns the median of the given list of numbers.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list
     * @return {Number}
     * @example
     *
     *      R.median([2, 9, 7]); //=> 7
     *      R.median([7, 2, 10, 9]); //=> 8
     *      R.median([]); //=> NaN
     */
    var median = _curry1(function median(list) {
        var len = list.length;
        if (len === 0) {
            return NaN;
        }
        var width = 2 - len % 2;
        var idx = (len - width) / 2;
        return mean(_slice(list).sort(function (a, b) {
            return a < b ? -1 : a > b ? 1 : 0;
        }).slice(idx, idx + width));
    });

    /**
     * Takes a predicate and a list or other "filterable" object and returns the
     * pair of filterable objects of the same type of elements which do and do not
     * satisfy, the predicate, respectively.
     *
     * @func
     * @memberOf R
     * @since v0.1.4
     * @category List
     * @sig Filterable f => (a -> Boolean) -> f a -> [f a, f a]
     * @param {Function} pred A predicate to determine which side the element belongs to.
     * @param {Array} filterable the list (or other filterable) to partition.
     * @return {Array} An array, containing first the subset of elements that satisfy the
     *         predicate, and second the subset of elements that do not satisfy.
     * @see R.filter, R.reject
     * @example
     *
     *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);
     *      // => [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
     *
     *      R.partition(R.contains('s'), { a: 'sss', b: 'ttt', foo: 'bars' });
     *      // => [ { a: 'sss', foo: 'bars' }, { b: 'ttt' }  ]
     */
    var partition = juxt([
        filter,
        reject
    ]);

    /**
     * Performs left-to-right function composition. The leftmost function may have
     * any arity; the remaining functions must be unary.
     *
     * In some libraries this function is named `sequence`.
     *
     * **Note:** The result of pipe is not automatically curried.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.compose
     * @example
     *
     *      var f = R.pipe(Math.pow, R.negate, R.inc);
     *
     *      f(3, 4); // -(3^4) + 1
     */
    var pipe = function pipe() {
        if (arguments.length === 0) {
            throw new Error('pipe requires at least one argument');
        }
        return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
    };

    /**
     * Performs left-to-right composition of one or more Promise-returning
     * functions. The leftmost function may have any arity; the remaining functions
     * must be unary.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Function
     * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.composeP
     * @example
     *
     *      //  followersForUser :: String -> Promise [User]
     *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
     */
    var pipeP = function pipeP() {
        if (arguments.length === 0) {
            throw new Error('pipeP requires at least one argument');
        }
        return _arity(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));
    };

    /**
     * Multiplies together all the elements of a list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list An array of numbers
     * @return {Number} The product of all the numbers in the list.
     * @see R.reduce
     * @example
     *
     *      R.product([2,4,6,8,100,1]); //=> 38400
     */
    var product = reduce(multiply, 1);

    /**
     * Transforms a [Traversable](https://github.com/fantasyland/fantasy-land#traversable)
     * of [Applicative](https://github.com/fantasyland/fantasy-land#applicative) into an
     * Applicative of Traversable.
     *
     * Dispatches to the `sequence` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig (Applicative f, Traversable t) => (a -> f a) -> t (f a) -> f (t a)
     * @param {Function} of
     * @param {*} traversable
     * @return {*}
     * @see R.traverse
     * @example
     *
     *      R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
     *      R.sequence(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
     *
     *      R.sequence(R.of, Just([1, 2, 3])); //=> [Just(1), Just(2), Just(3)]
     *      R.sequence(R.of, Nothing());       //=> [Nothing()]
     */
    var sequence = _curry2(function sequence(of, traversable) {
        return typeof traversable.sequence === 'function' ? traversable.sequence(of) : reduceRight(function (acc, x) {
            return ap(map(prepend, x), acc);
        }, of([]), traversable);
    });

    /**
     * Maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning
     * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),
     * then uses [`sequence`](#sequence) to transform the resulting Traversable of Applicative
     * into an Applicative of Traversable.
     *
     * Dispatches to the `sequence` method of the third argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig (Applicative f, Traversable t) => (a -> f a) -> (a -> f b) -> t a -> f (t b)
     * @param {Function} of
     * @param {Function} f
     * @param {*} traversable
     * @return {*}
     * @see R.sequence
     * @example
     *
     *      // Returns `Nothing` if the given divisor is `0`
     *      safeDiv = n => d => d === 0 ? Nothing() : Just(n / d)
     *
     *      R.traverse(Maybe.of, safeDiv(10), [2, 4, 5]); //=> Just([5, 2.5, 2])
     *      R.traverse(Maybe.of, safeDiv(10), [2, 0, 5]); //=> Nothing
     */
    var traverse = _curry3(function traverse(of, f, traversable) {
        return sequence(of, map(f, traversable));
    });

    /**
     * Shorthand for `R.chain(R.identity)`, which removes one level of nesting from
     * any [Chain](https://github.com/fantasyland/fantasy-land#chain).
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig Chain c => c (c a) -> c a
     * @param {*} list
     * @return {*}
     * @see R.flatten, R.chain
     * @example
     *
     *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
     *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
     */
    var unnest = chain(_identity);

    var _contains = function _contains(a, list) {
        return _indexOf(list, a, 0) >= 0;
    };

    //  mapPairs :: (Object, [String]) -> [String]
    var _toString = function _toString(x, seen) {
        var recur = function recur(y) {
            var xs = seen.concat([x]);
            return _contains(y, xs) ? '<Circular>' : _toString(y, xs);
        };
        //  mapPairs :: (Object, [String]) -> [String]
        var mapPairs = function (obj, keys) {
            return _map(function (k) {
                return _quote(k) + ': ' + recur(obj[k]);
            }, keys.slice().sort());
        };
        switch (Object.prototype.toString.call(x)) {
        case '[object Arguments]':
            return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';
        case '[object Array]':
            return '[' + _map(recur, x).concat(mapPairs(x, reject(function (k) {
                return /^\d+$/.test(k);
            }, keys(x)))).join(', ') + ']';
        case '[object Boolean]':
            return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
        case '[object Date]':
            return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString(x))) + ')';
        case '[object Null]':
            return 'null';
        case '[object Number]':
            return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
        case '[object String]':
            return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);
        case '[object Undefined]':
            return 'undefined';
        default:
            if (typeof x.toString === 'function') {
                var repr = x.toString();
                if (repr !== '[object Object]') {
                    return repr;
                }
            }
            return '{' + mapPairs(x, keys(x)).join(', ') + '}';
        }
    };

    /**
     * Performs right-to-left function composition. The rightmost function may have
     * any arity; the remaining functions must be unary.
     *
     * **Note:** The result of compose is not automatically curried.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.pipe
     * @example
     *
     *      var f = R.compose(R.inc, R.negate, Math.pow);
     *
     *      f(3, 4); // -(3^4) + 1
     */
    var compose = function compose() {
        if (arguments.length === 0) {
            throw new Error('compose requires at least one argument');
        }
        return pipe.apply(this, reverse(arguments));
    };

    /**
     * Returns the right-to-left Kleisli composition of the provided functions,
     * each of which must return a value of a type supported by [`chain`](#chain).
     *
     * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), R.chain(f))`.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Function
     * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (m a -> m z)
     * @param {...Function}
     * @return {Function}
     * @see R.pipeK
     * @example
     *
     *      //  parseJson :: String -> Maybe *
     *      //  get :: String -> Object -> Maybe *
     *
     *      //  getStateCode :: Maybe String -> Maybe String
     *      var getStateCode = R.composeK(
     *        R.compose(Maybe.of, R.toUpper),
     *        get('state'),
     *        get('address'),
     *        get('user'),
     *        parseJson
     *      );
     *
     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
     *      //=> Just('NY')
     *      getStateCode(Maybe.of('[Invalid JSON]'));
     *      //=> Nothing()
     */
    var composeK = function composeK() {
        return compose.apply(this, prepend(identity, map(chain, arguments)));
    };

    /**
     * Performs right-to-left composition of one or more Promise-returning
     * functions. The rightmost function may have any arity; the remaining
     * functions must be unary.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Function
     * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.pipeP
     * @example
     *
     *      //  followersForUser :: String -> Promise [User]
     *      var followersForUser = R.composeP(db.getFollowers, db.getUserById);
     */
    var composeP = function composeP() {
        if (arguments.length === 0) {
            throw new Error('composeP requires at least one argument');
        }
        return pipeP.apply(this, reverse(arguments));
    };

    /**
     * Wraps a constructor function inside a curried function that can be called
     * with the same arguments and returns the same type.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (* -> {*}) -> (* -> {*})
     * @param {Function} Fn The constructor function to wrap.
     * @return {Function} A wrapped, curried constructor function.
     * @example
     *
     *      // Constructor function
     *      var Widget = config => {
     *        // ...
     *      };
     *      Widget.prototype = {
     *        // ...
     *      };
     *      var allConfigs = [
     *        // ...
     *      ];
     *      R.map(R.construct(Widget), allConfigs); // a list of Widgets
     */
    var construct = _curry1(function construct(Fn) {
        return constructN(Fn.length, Fn);
    });

    /**
     * Returns `true` if the specified value is equal, in `R.equals` terms, to at
     * least one element of the given list; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> Boolean
     * @param {Object} a The item to compare against.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the item is in the list, `false` otherwise.
     * @see R.any
     * @example
     *
     *      R.contains(3, [1, 2, 3]); //=> true
     *      R.contains(4, [1, 2, 3]); //=> false
     *      R.contains([42], [[42]]); //=> true
     */
    var contains = _curry2(_contains);

    /**
     * Finds the set (i.e. no duplicates) of all elements in the first list not
     * contained in the second list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig [*] -> [*] -> [*]
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The elements in `list1` that are not in `list2`.
     * @see R.differenceWith
     * @example
     *
     *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
     *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
     */
    var difference = _curry2(function difference(first, second) {
        var out = [];
        var idx = 0;
        var firstLen = first.length;
        while (idx < firstLen) {
            if (!_contains(first[idx], second) && !_contains(first[idx], out)) {
                out[out.length] = first[idx];
            }
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a new list without any consecutively repeating elements. `R.equals`
     * is used to determine equality.
     *
     * Dispatches to the `dropRepeats` method of the first argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig [a] -> [a]
     * @param {Array} list The array to consider.
     * @return {Array} `list` without repeating elements.
     * @see R.transduce
     * @example
     *
     *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
     */
    var dropRepeats = _curry1(_dispatchable('dropRepeats', _xdropRepeatsWith(equals), dropRepeatsWith(equals)));

    /**
     * "lifts" a function of arity > 1 so that it may "map over" a list, Function or other
     * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Function
     * @sig (*... -> *) -> ([*]... -> [*])
     * @param {Function} fn The function to lift into higher context
     * @return {Function} The lifted function.
     * @see R.liftN
     * @example
     *
     *      var madd3 = R.lift(R.curry((a, b, c) => a + b + c));
     *
     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
     *
     *      var madd5 = R.lift(R.curry((a, b, c, d, e) => a + b + c + d + e));
     *
     *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]
     */
    var lift = _curry1(function lift(fn) {
        return liftN(fn.length, fn);
    });

    /**
     * Returns a partial copy of an object omitting the keys specified.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [String] -> {String: *} -> {String: *}
     * @param {Array} names an array of String property names to omit from the new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with properties from `names` not on it.
     * @see R.pick
     * @example
     *
     *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
     */
    var omit = _curry2(function omit(names, obj) {
        var result = {};
        for (var prop in obj) {
            if (!_contains(prop, names)) {
                result[prop] = obj[prop];
            }
        }
        return result;
    });

    /**
     * Returns the left-to-right Kleisli composition of the provided functions,
     * each of which must return a value of a type supported by [`chain`](#chain).
     *
     * `R.pipeK(f, g, h)` is equivalent to `R.pipe(R.chain(f), R.chain(g), R.chain(h))`.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Function
     * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (m a -> m z)
     * @param {...Function}
     * @return {Function}
     * @see R.composeK
     * @example
     *
     *      //  parseJson :: String -> Maybe *
     *      //  get :: String -> Object -> Maybe *
     *
     *      //  getStateCode :: Maybe String -> Maybe String
     *      var getStateCode = R.pipeK(
     *        parseJson,
     *        get('user'),
     *        get('address'),
     *        get('state'),
     *        R.compose(Maybe.of, R.toUpper)
     *      );
     *
     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
     *      //=> Just('NY')
     *      getStateCode(Maybe.of('[Invalid JSON]'));
     *      //=> Nothing()
     */
    var pipeK = function pipeK() {
        return composeK.apply(this, reverse(arguments));
    };

    /**
     * Returns the string representation of the given value. `eval`'ing the output
     * should result in a value equivalent to the input value. Many of the built-in
     * `toString` methods do not satisfy this requirement.
     *
     * If the given value is an `[object Object]` with a `toString` method other
     * than `Object.prototype.toString`, this method is invoked with no arguments
     * to produce the return value. This means user-defined constructor functions
     * can provide a suitable `toString` method. For example:
     *
     *     function Point(x, y) {
     *       this.x = x;
     *       this.y = y;
     *     }
     *
     *     Point.prototype.toString = function() {
     *       return 'new Point(' + this.x + ', ' + this.y + ')';
     *     };
     *
     *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category String
     * @sig * -> String
     * @param {*} val
     * @return {String}
     * @example
     *
     *      R.toString(42); //=> '42'
     *      R.toString('abc'); //=> '"abc"'
     *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
     *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
     *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
     */
    var toString = _curry1(function toString(val) {
        return _toString(val, []);
    });

    /**
     * Returns a new list without values in the first argument.
     * `R.equals` is used to determine equality.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig [a] -> [a] -> [a]
     * @param {Array} list1 The values to be removed from `list2`.
     * @param {Array} list2 The array to remove values from.
     * @return {Array} The new array without values in `list1`.
     * @see R.transduce
     * @example
     *
     *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]
     */
    var without = _curry2(function (xs, list) {
        return reject(flip(_contains)(xs), list);
    });

    // A simple Set type that honours R.equals semantics
    /* globals Set */
    /**
       * Combines the logic for checking whether an item is a member of the set and
       * for adding a new item to the set.
       *
       * @param item       The item to check or add to the Set instance.
       * @param shouldAdd  If true, the item will be added to the set if it doesn't
       *                   already exist.
       * @param set        The set instance to check or add to.
       * @return {boolean} When shouldAdd is true, this will return true when a new
       *                   item was added otherwise false. When shouldAdd is false,
       *                   this will return true if the item already exists, otherwise
       *                   false.
       */
    // distinguish between +0 and -0
    // these types can all utilise Set
    // set._items['boolean'] holds a two element array
    // representing [ falseExists, trueExists ]
    // compare functions for reference equality
    /* falls through */
    // reduce the search size of heterogeneous sets by creating buckets
    // for each type.
    // scan through all previously applied items
    var _Set = function () {
        function _Set() {
            /* globals Set */
            this._nativeSet = typeof Set === 'function' ? new Set() : null;
            this._items = {};
        }
        _Set.prototype.add = function (item) {
            return hasOrAdd(item, true, this);
        };
        _Set.prototype.has = function (item) {
            return hasOrAdd(item, false, this);
        };
        /**
       * Combines the logic for checking whether an item is a member of the set and
       * for adding a new item to the set.
       *
       * @param item       The item to check or add to the Set instance.
       * @param shouldAdd  If true, the item will be added to the set if it doesn't
       *                   already exist.
       * @param set        The set instance to check or add to.
       * @return {boolean} When shouldAdd is true, this will return true when a new
       *                   item was added otherwise false. When shouldAdd is false,
       *                   this will return true if the item already exists, otherwise
       *                   false.
       */
        function hasOrAdd(item, shouldAdd, set) {
            var type = typeof item;
            var prevSize, newSize;
            switch (type) {
            case 'string':
            case 'number':
                // distinguish between +0 and -0
                if (item === 0 && !set._items['-0'] && 1 / item === -Infinity) {
                    if (shouldAdd) {
                        set._items['-0'] = true;
                    }
                    return shouldAdd;
                }
                // these types can all utilise Set
                if (set._nativeSet !== null) {
                    if (shouldAdd) {
                        prevSize = set._nativeSet.size;
                        set._nativeSet.add(item);
                        newSize = set._nativeSet.size;
                        return newSize > prevSize;
                    } else {
                        return set._nativeSet.has(item);
                    }
                } else {
                    if (!(type in set._items)) {
                        if (shouldAdd) {
                            set._items[type] = {};
                            set._items[type][item] = true;
                        }
                        return shouldAdd;
                    } else if (item in set._items[type]) {
                        return !shouldAdd;
                    } else {
                        if (shouldAdd) {
                            set._items[type][item] = true;
                        }
                        return shouldAdd;
                    }
                }
            case 'boolean':
                // set._items['boolean'] holds a two element array
                // representing [ falseExists, trueExists ]
                if (type in set._items) {
                    var bIdx = item ? 1 : 0;
                    if (set._items[type][bIdx]) {
                        return !shouldAdd;
                    } else {
                        if (shouldAdd) {
                            set._items[type][bIdx] = true;
                        }
                        return shouldAdd;
                    }
                } else {
                    if (shouldAdd) {
                        set._items[type] = item ? [
                            false,
                            true
                        ] : [
                            true,
                            false
                        ];
                    }
                    return shouldAdd;
                }
            case 'function':
                // compare functions for reference equality
                if (set._nativeSet !== null) {
                    if (shouldAdd) {
                        prevSize = set._nativeSet.size;
                        set._nativeSet.add(item);
                        newSize = set._nativeSet.size;
                        return newSize > prevSize;
                    } else {
                        return set._nativeSet.has(item);
                    }
                } else {
                    if (!(type in set._items)) {
                        if (shouldAdd) {
                            set._items[type] = [item];
                        }
                        return shouldAdd;
                    }
                    if (!_contains(item, set._items[type])) {
                        if (shouldAdd) {
                            set._items[type].push(item);
                        }
                        return shouldAdd;
                    }
                }
                return !shouldAdd;
            case 'undefined':
                if (set._items[type]) {
                    return !shouldAdd;
                } else {
                    if (shouldAdd) {
                        set._items[type] = true;
                    }
                    return shouldAdd;
                }
            case 'object':
                if (item === null) {
                    if (!set._items['null']) {
                        if (shouldAdd) {
                            set._items['null'] = true;
                        }
                        return shouldAdd;
                    }
                    return !shouldAdd;
                }
            /* falls through */
            default:
                // reduce the search size of heterogeneous sets by creating buckets
                // for each type.
                type = Object.prototype.toString.call(item);
                if (!(type in set._items)) {
                    if (shouldAdd) {
                        set._items[type] = [item];
                    }
                    return shouldAdd;
                }
                // scan through all previously applied items
                if (!_contains(item, set._items[type])) {
                    if (shouldAdd) {
                        set._items[type].push(item);
                    }
                    return shouldAdd;
                }
                return !shouldAdd;
            }
        }
        return _Set;
    }();

    /**
     * A function wrapping calls to the two functions in an `&&` operation,
     * returning the result of the first function if it is false-y and the result
     * of the second function otherwise. Note that this is short-circuited,
     * meaning that the second function will not be invoked if the first returns a
     * false-y value.
     *
     * In addition to functions, `R.both` also accepts any fantasy-land compatible
     * applicative functor.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category Logic
     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
     * @param {Function} f a predicate
     * @param {Function} g another predicate
     * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
     * @see R.and
     * @example
     *
     *      var gt10 = x => x > 10;
     *      var even = x => x % 2 === 0;
     *      var f = R.both(gt10, even);
     *      f(100); //=> true
     *      f(101); //=> false
     */
    var both = _curry2(function both(f, g) {
        return _isFunction(f) ? function _both() {
            return f.apply(this, arguments) && g.apply(this, arguments);
        } : lift(and)(f, g);
    });

    /**
     * Takes a function `f` and returns a function `g` such that:
     *
     *   - applying `g` to zero or more arguments will give __true__ if applying
     *     the same arguments to `f` gives a logical __false__ value; and
     *
     *   - applying `g` to zero or more arguments will give __false__ if applying
     *     the same arguments to `f` gives a logical __true__ value.
     *
     * `R.complement` will work on all other functors as well.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category Logic
     * @sig (*... -> *) -> (*... -> Boolean)
     * @param {Function} f
     * @return {Function}
     * @see R.not
     * @example
     *
     *      var isEven = n => n % 2 === 0;
     *      var isOdd = R.complement(isEven);
     *      isOdd(21); //=> true
     *      isOdd(42); //=> false
     */
    var complement = lift(not);

    /**
     * A function wrapping calls to the two functions in an `||` operation,
     * returning the result of the first function if it is truth-y and the result
     * of the second function otherwise. Note that this is short-circuited,
     * meaning that the second function will not be invoked if the first returns a
     * truth-y value.
     *
     * In addition to functions, `R.either` also accepts any fantasy-land compatible
     * applicative functor.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category Logic
     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
     * @param {Function} f a predicate
     * @param {Function} g another predicate
     * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
     * @see R.or
     * @example
     *
     *      var gt10 = x => x > 10;
     *      var even = x => x % 2 === 0;
     *      var f = R.either(gt10, even);
     *      f(101); //=> true
     *      f(8); //=> true
     */
    var either = _curry2(function either(f, g) {
        return _isFunction(f) ? function _either() {
            return f.apply(this, arguments) || g.apply(this, arguments);
        } : lift(or)(f, g);
    });

    /**
     * Turns a named method with a specified arity into a function that can be
     * called directly supplied with arguments and a target object.
     *
     * The returned function is curried and accepts `arity + 1` parameters where
     * the final parameter is the target object.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
     * @param {Number} arity Number of arguments the returned function should take
     *        before the target object.
     * @param {String} method Name of the method to call.
     * @return {Function} A new curried function.
     * @example
     *
     *      var sliceFrom = R.invoker(1, 'slice');
     *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
     *      var sliceFrom6 = R.invoker(2, 'slice')(6);
     *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
     */
    var invoker = _curry2(function invoker(arity, method) {
        return curryN(arity + 1, function () {
            var target = arguments[arity];
            if (target != null && is(Function, target[method])) {
                return target[method].apply(target, _slice(arguments, 0, arity));
            }
            throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
        });
    });

    /**
     * Returns a string made by inserting the `separator` between each element and
     * concatenating all the elements into a single string.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig String -> [a] -> String
     * @param {Number|String} separator The string used to separate the elements.
     * @param {Array} xs The elements to join into a string.
     * @return {String} str The string made by concatenating `xs` with `separator`.
     * @see R.split
     * @example
     *
     *      var spacer = R.join(' ');
     *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
     *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
     */
    var join = invoker(1, 'join');

    /**
     * Creates a new function that, when invoked, caches the result of calling `fn`
     * for a given argument set and returns the result. Subsequent calls to the
     * memoized `fn` with the same argument set will not result in an additional
     * call to `fn`; instead, the cached result for that set of arguments will be
     * returned.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (*... -> a) -> (*... -> a)
     * @param {Function} fn The function to memoize.
     * @return {Function} Memoized version of `fn`.
     * @example
     *
     *      var count = 0;
     *      var factorial = R.memoize(n => {
     *        count += 1;
     *        return R.product(R.range(1, n + 1));
     *      });
     *      factorial(5); //=> 120
     *      factorial(5); //=> 120
     *      factorial(5); //=> 120
     *      count; //=> 1
     */
    var memoize = _curry1(function memoize(fn) {
        var cache = {};
        return _arity(fn.length, function () {
            var key = toString(arguments);
            if (!_has(key, cache)) {
                cache[key] = fn.apply(this, arguments);
            }
            return cache[key];
        });
    });

    /**
     * Splits a string into an array of strings based on the given
     * separator.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category String
     * @sig (String | RegExp) -> String -> [String]
     * @param {String|RegExp} sep The pattern.
     * @param {String} str The string to separate into an array.
     * @return {Array} The array of strings from `str` separated by `str`.
     * @see R.join
     * @example
     *
     *      var pathComponents = R.split('/');
     *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
     *
     *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
     */
    var split = invoker(1, 'split');

    /**
     * Determines whether a given string matches a given regular expression.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category String
     * @sig RegExp -> String -> Boolean
     * @param {RegExp} pattern
     * @param {String} str
     * @return {Boolean}
     * @see R.match
     * @example
     *
     *      R.test(/^x/, 'xyz'); //=> true
     *      R.test(/^y/, 'xyz'); //=> false
     */
    var test = _curry2(function test(pattern, str) {
        if (!_isRegExp(pattern)) {
            throw new TypeError('\u2018test\u2019 requires a value of type RegExp as its first argument; received ' + toString(pattern));
        }
        return _cloneRegExp(pattern).test(str);
    });

    /**
     * The lower case version of a string.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category String
     * @sig String -> String
     * @param {String} str The string to lower case.
     * @return {String} The lower case version of `str`.
     * @see R.toUpper
     * @example
     *
     *      R.toLower('XYZ'); //=> 'xyz'
     */
    var toLower = invoker(0, 'toLowerCase');

    /**
     * The upper case version of a string.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category String
     * @sig String -> String
     * @param {String} str The string to upper case.
     * @return {String} The upper case version of `str`.
     * @see R.toLower
     * @example
     *
     *      R.toUpper('abc'); //=> 'ABC'
     */
    var toUpper = invoker(0, 'toUpperCase');

    /**
     * Returns a new list containing only one copy of each element in the original
     * list, based upon the value returned by applying the supplied function to
     * each list element. Prefers the first item if the supplied function produces
     * the same value on two items. `R.equals` is used for comparison.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig (a -> b) -> [a] -> [a]
     * @param {Function} fn A function used to produce a value to use during comparisons.
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
     */
    var uniqBy = _curry2(function uniqBy(fn, list) {
        var set = new _Set();
        var result = [];
        var idx = 0;
        var appliedItem, item;
        while (idx < list.length) {
            item = list[idx];
            appliedItem = fn(item);
            if (set.add(appliedItem)) {
                result.push(item);
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Returns the result of concatenating the given lists or strings.
     *
     * Dispatches to the `concat` method of the first argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a] -> [a]
     * @sig String -> String -> String
     * @param {Array|String} a
     * @param {Array|String} b
     * @return {Array|String}
     *
     * @example
     *
     *      R.concat([], []); //=> []
     *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
     *      R.concat('ABC', 'DEF'); // 'ABCDEF'
     */
    var concat = flip(invoker(1, 'concat'));

    /**
     * Finds the set (i.e. no duplicates) of all elements contained in the first or
     * second list, but not both.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Relation
     * @sig [*] -> [*] -> [*]
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The elements in `list1` or `list2`, but not both.
     * @see R.symmetricDifferenceWith
     * @example
     *
     *      R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=> [1,2,7,6,5]
     *      R.symmetricDifference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5,1,2]
     */
    var symmetricDifference = _curry2(function symmetricDifference(list1, list2) {
        return concat(difference(list1, list2), difference(list2, list1));
    });

    /**
     * Finds the set (i.e. no duplicates) of all elements contained in the first or
     * second list, but not both. Duplication is determined according to the value
     * returned by applying the supplied predicate to two list elements.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Relation
     * @sig (a -> a -> Boolean) -> [a] -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The elements in `list1` or `list2`, but not both.
     * @see R.symmetricDifference
     * @example
     *
     *      var eqA = R.eqBy(R.prop('a'));
     *      var l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];
     *      var l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];
     *      R.symmetricDifferenceWith(eqA, l1, l2); //=> [{a: 1}, {a: 2}, {a: 5}, {a: 6}]
     */
    var symmetricDifferenceWith = _curry3(function symmetricDifferenceWith(pred, list1, list2) {
        return concat(differenceWith(pred, list1, list2), differenceWith(pred, list2, list1));
    });

    /**
     * Returns a new list containing only one copy of each element in the original
     * list. `R.equals` is used to determine equality.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a]
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
     *      R.uniq([1, '1']);     //=> [1, '1']
     *      R.uniq([[42], [42]]); //=> [[42]]
     */
    var uniq = uniqBy(identity);

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of those
     * elements common to both lists.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig [*] -> [*] -> [*]
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The list of elements found in both `list1` and `list2`.
     * @see R.intersectionWith
     * @example
     *
     *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
     */
    var intersection = _curry2(function intersection(list1, list2) {
        var lookupList, filteredList;
        if (list1.length > list2.length) {
            lookupList = list1;
            filteredList = list2;
        } else {
            lookupList = list2;
            filteredList = list1;
        }
        return uniq(_filter(flip(_contains)(lookupList), filteredList));
    });

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of the elements
     * of each list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig [*] -> [*] -> [*]
     * @param {Array} as The first list.
     * @param {Array} bs The second list.
     * @return {Array} The first and second lists concatenated, with
     *         duplicates removed.
     * @example
     *
     *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
     */
    var union = _curry2(compose(uniq, _concat));

    var R = {
        F: F,
        T: T,
        __: __,
        add: add,
        addIndex: addIndex,
        adjust: adjust,
        all: all,
        allPass: allPass,
        allUniq: allUniq,
        always: always,
        and: and,
        any: any,
        anyPass: anyPass,
        ap: ap,
        aperture: aperture,
        append: append,
        apply: apply,
        applySpec: applySpec,
        assoc: assoc,
        assocPath: assocPath,
        binary: binary,
        bind: bind,
        both: both,
        call: call,
        chain: chain,
        clamp: clamp,
        clone: clone,
        comparator: comparator,
        complement: complement,
        compose: compose,
        composeK: composeK,
        composeP: composeP,
        concat: concat,
        cond: cond,
        construct: construct,
        constructN: constructN,
        contains: contains,
        converge: converge,
        countBy: countBy,
        curry: curry,
        curryN: curryN,
        dec: dec,
        defaultTo: defaultTo,
        difference: difference,
        differenceWith: differenceWith,
        dissoc: dissoc,
        dissocPath: dissocPath,
        divide: divide,
        drop: drop,
        dropLast: dropLast,
        dropLastWhile: dropLastWhile,
        dropRepeats: dropRepeats,
        dropRepeatsWith: dropRepeatsWith,
        dropWhile: dropWhile,
        either: either,
        empty: empty,
        eqBy: eqBy,
        eqProps: eqProps,
        equals: equals,
        evolve: evolve,
        filter: filter,
        find: find,
        findIndex: findIndex,
        findLast: findLast,
        findLastIndex: findLastIndex,
        flatten: flatten,
        flip: flip,
        forEach: forEach,
        fromPairs: fromPairs,
        groupBy: groupBy,
        groupWith: groupWith,
        gt: gt,
        gte: gte,
        has: has,
        hasIn: hasIn,
        head: head,
        identical: identical,
        identity: identity,
        ifElse: ifElse,
        inc: inc,
        indexBy: indexBy,
        indexOf: indexOf,
        init: init,
        insert: insert,
        insertAll: insertAll,
        intersection: intersection,
        intersectionWith: intersectionWith,
        intersperse: intersperse,
        into: into,
        invert: invert,
        invertObj: invertObj,
        invoker: invoker,
        is: is,
        isArrayLike: isArrayLike,
        isEmpty: isEmpty,
        isNil: isNil,
        join: join,
        juxt: juxt,
        keys: keys,
        keysIn: keysIn,
        last: last,
        lastIndexOf: lastIndexOf,
        length: length,
        lens: lens,
        lensIndex: lensIndex,
        lensPath: lensPath,
        lensProp: lensProp,
        lift: lift,
        liftN: liftN,
        lt: lt,
        lte: lte,
        map: map,
        mapAccum: mapAccum,
        mapAccumRight: mapAccumRight,
        mapObjIndexed: mapObjIndexed,
        match: match,
        mathMod: mathMod,
        max: max,
        maxBy: maxBy,
        mean: mean,
        median: median,
        memoize: memoize,
        merge: merge,
        mergeAll: mergeAll,
        mergeWith: mergeWith,
        mergeWithKey: mergeWithKey,
        min: min,
        minBy: minBy,
        modulo: modulo,
        multiply: multiply,
        nAry: nAry,
        negate: negate,
        none: none,
        not: not,
        nth: nth,
        nthArg: nthArg,
        objOf: objOf,
        of: of,
        omit: omit,
        once: once,
        or: or,
        over: over,
        pair: pair,
        partial: partial,
        partialRight: partialRight,
        partition: partition,
        path: path,
        pathEq: pathEq,
        pathOr: pathOr,
        pathSatisfies: pathSatisfies,
        pick: pick,
        pickAll: pickAll,
        pickBy: pickBy,
        pipe: pipe,
        pipeK: pipeK,
        pipeP: pipeP,
        pluck: pluck,
        prepend: prepend,
        product: product,
        project: project,
        prop: prop,
        propEq: propEq,
        propIs: propIs,
        propOr: propOr,
        propSatisfies: propSatisfies,
        props: props,
        range: range,
        reduce: reduce,
        reduceBy: reduceBy,
        reduceRight: reduceRight,
        reduced: reduced,
        reject: reject,
        remove: remove,
        repeat: repeat,
        replace: replace,
        reverse: reverse,
        scan: scan,
        sequence: sequence,
        set: set,
        slice: slice,
        sort: sort,
        sortBy: sortBy,
        split: split,
        splitAt: splitAt,
        splitEvery: splitEvery,
        splitWhen: splitWhen,
        subtract: subtract,
        sum: sum,
        symmetricDifference: symmetricDifference,
        symmetricDifferenceWith: symmetricDifferenceWith,
        tail: tail,
        take: take,
        takeLast: takeLast,
        takeLastWhile: takeLastWhile,
        takeWhile: takeWhile,
        tap: tap,
        test: test,
        times: times,
        toLower: toLower,
        toPairs: toPairs,
        toPairsIn: toPairsIn,
        toString: toString,
        toUpper: toUpper,
        transduce: transduce,
        transpose: transpose,
        traverse: traverse,
        trim: trim,
        tryCatch: tryCatch,
        type: type,
        unapply: unapply,
        unary: unary,
        uncurryN: uncurryN,
        unfold: unfold,
        union: union,
        unionWith: unionWith,
        uniq: uniq,
        uniqBy: uniqBy,
        uniqWith: uniqWith,
        unless: unless,
        unnest: unnest,
        until: until,
        update: update,
        useWith: useWith,
        values: values,
        valuesIn: valuesIn,
        view: view,
        when: when,
        where: where,
        whereEq: whereEq,
        without: without,
        wrap: wrap,
        xprod: xprod,
        zip: zip,
        zipObj: zipObj,
        zipWith: zipWith
    };
  /* eslint-env amd */

  /* TEST_ENTRY_POINT */

  if (true) {
    module.exports = R;
  } else if (typeof define === 'function' && define.amd) {
    define(function() { return R; });
  } else {
    this.R = R;
  }

}.call(this));


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.roundTimeBin = roundTimeBin;
exports.default = binningMixin;

var _binningHelpers = __webpack_require__(17);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _events = __webpack_require__(9);

var _filters = __webpack_require__(13);

var _core = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function roundTimeBin(date, timeInterval, operation) {
  if (!timeInterval) {
    return date;
  }

  if (_d2.default.time[timeInterval]) {
    return _d2.default.time[timeInterval].utc[operation](date);
  }

  var unit = timeInterval === "quarter" ? "month" : "year";
  var ranges = [];
  switch (timeInterval) {
    case "quarter":
      ranges = [-2, 2, 3];
      break;
    case "decade":
      ranges = [-5, 5, 10];
      break;
    case "century":
      ranges = [-50, 50, 100];
      break;
  }

  var startRange = operation === "round" ? ranges[0] : operation === "ceil" ? 0 : -ranges[2];
  var endRange = operation === "round" ? ranges[1] : operation === "ceil" ? ranges[2] : 0;

  var subHalf = _d2.default.time[unit].offset(date, startRange);
  var addHalf = _d2.default.time[unit].offset(date, endRange);

  return _d2.default.time[unit].utc.round(_d2.default.time[unit + "s"](subHalf, addHalf, ranges[2])[0]);
}

function binningMixin(chart) {
  var _timeBinInputVal = "auto";

  var _line_events = ["bin"];
  var _listeners = _d2.default.dispatch.apply(_d2.default, _line_events);
  var _on = chart.on.bind(chart);

  chart.on = function (event, listener) {
    if (_line_events.indexOf(event) === -1) {
      _on(event, listener);
    } else {
      _listeners.on(event, listener);
    }
    return chart;
  };

  chart._invokeBinListener = function (f) {
    if (f !== "undefined") {
      _listeners.bin(chart, f);
    }
  };

  chart.binInputOptions = function () {
    return _binningHelpers.BIN_INPUT_OPTIONS;
  };

  chart.timeBinInputVal = function (val) {
    if (typeof val === "undefined") {
      return _timeBinInputVal;
    }
    _timeBinInputVal = val;
    return chart;
  };

  chart.binBrush = function (isRangeChart) {
    var rangeChartBrush = isRangeChart ? chart.rangeChart().extendBrush() : null;
    var extent0 = isRangeChart ? rangeChartBrush : chart.extendBrush();

    var bin_bounds = chart.group().binParams()[0] ? chart.group().binParams()[0].binBounds : null;

    var chartBounds = isRangeChart ? rangeChartBrush : bin_bounds;

    if (!extent0[0].getTime || extent0[0].getTime() === extent0[1].getTime()) {
      return;
    }

    var timeInterval = chart.group().binParams()[0].timeBin;

    var extent1 = extent0.map(function (date) {
      return roundTimeBin(date, timeInterval, "round");
    });

    if (extent1[0] < chartBounds[0]) {
      extent1[0] = roundTimeBin(extent0[0], timeInterval, "ceil");
    }

    if (extent1[1] > chartBounds[1]) {
      extent1[1] = roundTimeBin(extent0[1], timeInterval, "floor");
    }

    /* istanbul ignore next */
    // if empty when rounded, use floor & ceil instead
    if (extent1[0] >= extent1[1]) {
      extent1[0] = roundTimeBin(extent0[0], timeInterval, "floor");
      extent1[1] = roundTimeBin(extent0[1], timeInterval, "ceil");
    }

    /* istanbul ignore next */
    if (!isNaN(chart.xAxisMax()) && extent1[0].getTime() === chart.xAxisMax().getTime()) {
      var binNumSecs = chart.binInputOptions().filter(function (d) {
        return chart.group().binParams()[0].timeBin === d.val;
      })[0].numSeconds;
      extent1[0] = new Date(extent1[0].getTime() - binNumSecs * 1000);
      extent1[0] = roundTimeBin(extent1[0], timeInterval, "round");
    }

    /* istanbul ignore next */
    if (!isNaN(chart.xAxisMin()) && extent1[1].getTime() === chart.xAxisMin().getTime()) {
      var _binNumSecs = chart.binInputOptions().filter(function (d) {
        return chart.group().binParams()[0].timeBin === d.val;
      })[0].numSeconds;
      extent1[1] = new Date(extent1[1].getTime() + _binNumSecs * 1000);
      extent1[1] = roundTimeBin(extent1[1], timeInterval, "round");
    }

    var rangedFilter = _filters.filters.RangedFilter(extent1[0], extent1[1]);

    _events.events.trigger(function () {
      chart.replaceFilter(rangedFilter);
    }, _core.constants.EVENT_DELAY);
  };

  chart.changeBinVal = function (val) {
    chart.timeBinInputVal(val);

    var currentStack = chart.stack().slice();
    /* istanbul ignore next */

    var _loop = function _loop(i) {
      var binParams = currentStack[i].group.binParams().map(function (binParam, idx) {
        if (idx === i && binParam) {
          var binBounds = binParam.binBounds,
              numBins = binParam.numBins;

          var isAuto = val === "auto";
          var bounds = binBounds.map(function (date) {
            return date.getTime();
          });
          binParam.timeBin = isAuto ? (0, _binningHelpers.autoBinParams)(bounds, numBins) : val;
          binParam.auto = isAuto; // hightlights the "auto" UI button
        }
        return binParam;
      });

      /* istanbul ignore next */
      if (i === 0) {
        chart.group(currentStack[i].group.binParams(binParams), currentStack[i].name);
      } else {
        chart.stack(currentStack[i].group.binParams(binParams), currentStack[i].name, currentStack[i].accessor);
      }
    };

    for (var i = 0; i < currentStack.length; i++) {
      _loop(i);
    }

    chart._invokeBinListener(val);
    return chart.renderAsync().then(function () {
      chart.binBrush();
    });
  };

  return chart;
}

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = bubbleChart;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _bubbleMixin = __webpack_require__(18);

var _bubbleMixin2 = _interopRequireDefault(_bubbleMixin);

var _capMixin = __webpack_require__(10);

var _capMixin2 = _interopRequireDefault(_capMixin);

var _coordinateGridMixin = __webpack_require__(11);

var _coordinateGridMixin2 = _interopRequireDefault(_coordinateGridMixin);

var _utils = __webpack_require__(3);

var _core = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A concrete implementation of a general purpose bubble chart that allows data visualization using the
 * following dimensions:
 * - x axis position
 * - y axis position
 * - bubble radius
 * - color
 * Examples:
 * - {@link https://mapd.github.io/mapd-charting/example/example1.html Carrier Departure Delay by Arrival Delay (Minutes)
}
 * @name bubbleChart
 * @memberof dc
 * @mixes dc.bubbleMixin
 * @mixes dc.coordinateGridMixin
 * @example
 * // create a bubble chart under #chart-container1 element using the default global chart group
 * var bubbleChart1 = dc.bubbleChart('#chart-container1');
 * // create a bubble chart under #chart-container2 element using chart group A
 * var bubbleChart2 = dc.bubbleChart('#chart-container2', 'chartGroupA');
 * @param {String|node|d3.selection} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector} specifying
 * a dom block element such as a div; or a dom element or d3 selection.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
 * Interaction with a chart will only trigger events and redraws within the chart's group.
 * @return {dc.bubbleChart}
 */
function bubbleChart(parent, chartGroup) {
  /* OVERRIDE -----------------------------------------------------------------*/
  var _chart = (0, _bubbleMixin2.default)((0, _capMixin2.default)((0, _coordinateGridMixin2.default)({})));
  var _popupHeader = [];
  var _isHoverNode = null;
  /* --------------------------------------------------------------------------*/

  var _elasticRadius = false;
  var _sortBubbleSize = false;

  _chart.transitionDuration(750);

  var bubbleLocator = function bubbleLocator(d) {
    return "translate(" + bubbleX(d) + "," + bubbleY(d) + ")";
  };

  /* OVERRIDE -----------------------------------------------------------------*/
  _chart.setPopupHeader = function (_) {
    if (!arguments.length) {
      return _popupHeader;
    }
    _popupHeader = _;
    return _chart;
  };

  _chart.measureValue = function (value, key, type) {
    if (type === "measure") {
      var customFormatter = _chart.valueFormatter();
      return customFormatter && customFormatter(value, key) || _utils.utils.formatValue(value);
    } else {
      _utils.utils.formatValue(value);
    }
  };

  _chart.hideOverlappedLabels = function () {
    var nodes = _chart.svg().selectAll(".node");

    var labelHeight = 10;
    var letterWidth = 5;

    nodes[0].reverse();

    nodes.classed("hide-label", function (d) {
      return _chart.bubbleR(d) < _chart.minRadiusWithLabel();
    }).each(function (d, i) {
      var a = this;
      var aR = i > 0 ? d.radius : _chart.bubbleR(d);
      var aX = i > 0 ? d.xPixel : bubbleX(d);
      var aY = i > 0 ? d.yPixel : bubbleY(d);
      var aKey = d.key0;

      if (_d2.default.select(a).classed("hide-label")) {
        return;
      }

      for (var j = i + 1; j < nodes[0].length; j++) {
        var b = _d2.default.select(nodes[0][j]);
        var d = b.datum();

        var bX = d.xPixel = bubbleX(d);
        var bY = d.yPixel = bubbleY(d);
        var bR = d.radius = _chart.bubbleR(d);
        var bKey = d.key0;

        if (Math.abs(aY - bY) > labelHeight || bR < _chart.minRadiusWithLabel() || b.classed("hide-label")) {
          continue;
        }

        var aXmin = aX - String(aKey).length * letterWidth / 2;
        var aXmax = aX + String(aKey).length * letterWidth / 2;

        var bXmin = bX - String(bKey).length * letterWidth / 2;
        var bXmax = bX + String(bKey).length * letterWidth / 2;

        var isLabelOverlapped = aXmin >= bXmin && aXmin <= bXmax || aXmax >= bXmin && aXmax <= bXmax || aXmin <= bXmin && aXmax >= bXmax;

        if (isLabelOverlapped) {
          b.classed("hide-label", true);
        }
      }
    });
  };

  function isNodeOverlapped(d1, d2) {
    var dist = Math.sqrt((d1.xPixel - d2.xPixel) * (d1.xPixel - d2.xPixel) + (d1.yPixel - d2.yPixel) * (d1.yPixel - d2.yPixel));
    return d1.radius + 8 >= dist;
  }

  _chart.showPopup = function (d, i) {
    if (_chart.svg().select(".mouse-out-detect").empty()) {
      _chart.svg().insert("rect", ":first-child").attr("class", "mouse-out-detect").attr({ width: _chart.width(), height: _chart.height() }).on("mousemove", _chart.hidePopup);
    }

    _isHoverNode = d;

    var popup = _chart.popup();

    var popupBox = popup.select(".chart-popup-content").html("");

    popupBox.append("div").attr("class", "popup-bridge").style("width", _chart.bubbleR(d) * 2 + "px").style("height", _chart.bubbleR(d) + 24 + "px").style("border-radius", "0 0 " + _chart.bubbleR(d) + "px " + _chart.bubbleR(d) + "px").on("click", function () {
      _chart.onClick(d);
    }).append("div").attr("class", "bridge-hitbox");

    var popupTableWrap = popupBox.append("div").attr("class", "popup-table-wrap").on("mouseleave", _chart.hidePopup);

    var popupTable = popupTableWrap.append("table").attr("class", "popup-table");

    var popupTableHeader = popupTable.append("tr");

    var headerItems = popupTableHeader.selectAll("th").data(_popupHeader).enter().append("th");

    headerItems.append("div").attr("class", "ellipse-text").text(function (d) {
      return d.label;
    }).append("div").attr("class", "full-text").text(function (d) {
      return d.label;
    }).on("mouseenter", function () {
      _d2.default.select(this).style("transform", function () {
        var elm = _d2.default.select(this);
        var textWidth = elm.node().getBoundingClientRect().width;
        var boxWidth = elm.node().parentNode.getBoundingClientRect().width;

        if (textWidth < boxWidth) {
          elm.classed("scroll-text", false);
          return "none";
        }
        var dist = textWidth - boxWidth;

        elm.style("transition-duration", dist * 0.05 + "s").classed("scroll-text", true).on("webkitTransitionEnd", function () {
          setTimeout(function () {
            elm.classed("scroll-text", false).style("transform", "translateX(0)");
          }, 500);

          setTimeout(function () {
            elm.style("transform", "translateX(" + -dist + "px)").classed("scroll-text", true);
          }, 1000);
        });

        return "translateX(" + -dist + "px)";
      });
    }).on("mouseleave", function () {
      _d2.default.select(this).classed("scroll-text", false).style("transform", "translateX(0)");
    });

    var dataRows = [d];
    var nodes = _chart.svg().selectAll(".node");
    var foundCurrentNode = false;

    nodes[0].reverse();

    nodes.each(function (node, i) {
      if (d === node) {
        foundCurrentNode = true;
        return;
      }

      if (foundCurrentNode && isNodeOverlapped(d, node)) {
        dataRows.push(node);
      }
    });

    var rowItems = popupTable.selectAll(".popup-row-item").data(dataRows).enter().append("tr").html(function (d) {
      return renderPopupRow(d);
    }).on("click", function (d) {
      _chart.onClick(d);
    }).attr("class", "popup-row-item");

    _chart.updatePopup();

    popup.classed("js-showPopup popup-scrollable delay-pointer scatter-plot-popup", true);

    _chart.root().node().parentNode.parentNode.style.zIndex = 1;

    setTimeout(function () {
      popup.classed("delay-pointer", false);
    }, 250);

    positionPopup(d, this);
  };

  _chart.updatePopup = function () {
    if (_chart.hasFilter()) {
      _chart.popup().selectAll(".popup-row-item").each(function (d) {
        _d2.default.select(this).classed("deselected", !_chart.isSelectedNode(d)).classed("selected", _chart.isSelectedNode(d));
      });
    } else {
      _chart.popup().selectAll(".popup-row-item").classed("deselected", false).classed("selected", false);
    }
  };

  function renderPopupRow(d) {
    var str = "\n            <td>\n                <div class=\"table-dim\">\n                    <div class=\"table-legend\" style=\"background:" + _chart.getColor(d) + "\"></div>\n                    <div class=\"table-dim-val\">" + _chart.label()(d) + "</div>\n                </div>\n            </td>\n        ";

    for (var i = 1; i < _popupHeader.length; i++) {
      if (_popupHeader[i].alias) {
        var value = _popupHeader[i];
        str = str + ("<td>" + _chart.measureValue(d[value.alias], value.label, value.type) + "</td>");
      }
    }
    return str;
  }

  _chart.hidePopup = function () {
    _chart.popup().classed("js-showPopup", false);

    _chart.root().node().parentNode.parentNode.style.zIndex = "auto";

    _d2.default.selectAll(".node-hover").classed("node-hover", false);

    _isHoverNode = null;
  };

  function positionPopup(d, e) {
    var x = bubbleX(d) + _chart.margins().left;
    var y = bubbleY(d) + _chart.margins().top;

    var popup = _chart.popup().style("transform", function () {
      var popupWidth = _d2.default.select(this).select(".chart-popup-box").node().getBoundingClientRect().width / 2;
      var offsetX = x - popupWidth < 0 ? popupWidth - x - 16 : x + popupWidth > _chart.width() ? _chart.width() - (x + popupWidth) + 16 : 0;

      _d2.default.select(this).select(".popup-bridge").style("left", function () {
        return offsetX !== 0 ? popupWidth - offsetX + "px" : "50%";
      });
      return "translate(" + (x + offsetX) + "px," + y + "px)";
    });

    popup.select(".chart-popup-box").classed("align-center", true).classed("popdown", function () {
      return popup.node().getBoundingClientRect().top - 76 < _d2.default.select(this).node().getBoundingClientRect().height;
    }).select(".popup-table-wrap").style("overflow-y", function () {
      return popup.select(".popup-table").node().getBoundingClientRect().height > 160 ? "scroll" : "hidden";
    });
  }

  /* --------------------------------------------------------------------------*/

  /**
   * Turn on or off the elastic bubble radius feature, or return the value of the flag. If this
   * feature is turned on, then bubble radii will be automatically rescaled to fit the chart better.
   * @name elasticRadius
   * @memberof dc.bubbleChart
   * @instance
   * @param {Boolean} [elasticRadius=false]
   * @return {Boolean}
   * @return {dc.bubbleChart}
   */
  _chart.elasticRadius = function (elasticRadius) {
    if (!arguments.length) {
      return _elasticRadius;
    }
    _elasticRadius = elasticRadius;
    return _chart;
  };

  /**
   * Turn on or off the bubble sorting feature, or return the value of the flag. If enabled,
   * bubbles will be sorted by their radius, with smaller bubbles in front.
   * @name sortBubbleSize
   * @memberof dc.bubbleChart
   * @instance
   * @param {Boolean} [sortBubbleSize=false]
   * @return {Boolean}
   * @return {dc.bubbleChart}
   */
  _chart.sortBubbleSize = function (sortBubbleSize) {
    if (!arguments.length) {
      return _sortBubbleSize;
    }
    _sortBubbleSize = sortBubbleSize;
    return _chart;
  };

  _chart.plotData = function () {
    if (_elasticRadius) {
      _chart.r().domain([_chart.rMin(), _chart.rMax()]);
    }

    _chart.r().range([_chart.MIN_RADIUS, _chart.xAxisLength() * _chart.maxBubbleRelativeSize()]);

    var data = _chart.data();
    if (_sortBubbleSize) {
      // sort descending so smaller bubbles are on top
      var radiusAccessor = _chart.radiusValueAccessor();
      data.sort(function (a, b) {
        return _d2.default.descending(radiusAccessor(a), radiusAccessor(b));
      });
    }
    var bubbleG = _chart.chartBodyG().selectAll("g." + _chart.BUBBLE_NODE_CLASS)

    /* OVERRIDE -----------------------------------------------------------------*/
    .data(data);
    /* --------------------------------------------------------------------------*/

    if (_sortBubbleSize) {
      // Call order here to update dom order based on sort
      bubbleG.order();
    }

    renderNodes(bubbleG);

    updateNodes(bubbleG);

    removeNodes(bubbleG);

    _chart.fadeDeselectedArea();
  };

  function renderNodes(bubbleG) {
    var bubbleGEnter = void 0;
    bubbleGEnter = bubbleG.enter().append("g");
    bubbleGEnter.append("circle").attr("class", function (d, i) {
      return _chart.BUBBLE_CLASS + " _" + i;
    }).on("click", _chart.onClick).attr("fill", _chart.getColor).attr("r", 0);

    var debouncePopUp = _chart.debounce(function (d, i, elm) {
      _d2.default.select(elm).classed("node-hover", true);
      _chart.showPopup(d, i);
    }, 250);

    bubbleGEnter.attr("class", _chart.BUBBLE_NODE_CLASS).attr("transform", bubbleLocator)
    /* OVERRIDE -----------------------------------------------------------------*/
    .on("mouseover", function (d, i) {
      if (JSON.stringify(_isHoverNode) !== JSON.stringify(d)) {
        debouncePopUp(d, i, this);
        _chart.hidePopup();
      }
    });
    /* --------------------------------------------------------------------------*/

    (0, _core.transition)(bubbleG, _chart.transitionDuration()).selectAll("circle." + _chart.BUBBLE_CLASS).attr("r", function (d) {
      return _chart.bubbleR(d);
    }).attr("opacity", function (d) {
      return _chart.bubbleR(d) > 0 ? 1 : 0;
    });

    _chart._doRenderLabel(bubbleGEnter);

    _chart.prepareLockAxis("x");
  }

  function updateNodes(bubbleG) {
    (0, _core.transition)(bubbleG, _chart.transitionDuration()).attr("transform", bubbleLocator)

    /* OVERRIDE -----------------------------------------------------------------*/
    .select("circle." + _chart.BUBBLE_CLASS)
    /* --------------------------------------------------------------------------*/

    .attr("fill", _chart.getColor).attr("r", function (d) {
      return _chart.bubbleR(d);
    }).attr("opacity", function (d) {
      return _chart.bubbleR(d) > 0 ? 1 : 0;
    });

    _chart.doUpdateLabels(bubbleG);
    _chart.doUpdateTitles(bubbleG);
  }

  function removeNodes(bubbleG) {
    bubbleG.exit().remove();
  }

  function bubbleX(d) {
    var x = _chart.x()(_chart.keyAccessor()(d));
    if (isNaN(x)) {
      x = 0;
    }
    return x;
  }

  function bubbleY(d) {
    var y = _chart.y()(_chart.valueAccessor()(d));
    if (isNaN(y)) {
      y = 0;
    }
    return y;
  }

  _chart.renderBrush = function () {
    // override default x axis brush from parent chart
  };

  _chart.redrawBrush = function () {
    // override default x axis brush from parent chart
    _chart.fadeDeselectedArea();
  };

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cloudChart;

var _baseMixin = __webpack_require__(5);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

var _capMixin = __webpack_require__(10);

var _capMixin2 = _interopRequireDefault(_capMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _colorMixin = __webpack_require__(7);

var _colorMixin2 = _interopRequireDefault(_colorMixin);

var _marginMixin = __webpack_require__(12);

var _marginMixin2 = _interopRequireDefault(_marginMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function cloudChart(parent, chartGroup) {
  var _g = void 0;
  var _chart = (0, _capMixin2.default)((0, _marginMixin2.default)((0, _colorMixin2.default)((0, _baseMixin2.default)({}))));
  var _cloudData = void 0;
  var _cloudLayout = void 0;
  var _r = void 0;
  var _tags = void 0; // store output of _cloudLayout
  var _noRelayout = false; // flag to set on click so rerender doesn't relayout elements
  var _hasBeenRendered = false;

  _chart.setNoRelayout = function (val) {
    _noRelayout = val;
  };

  function drawChart() {
    _cloudData = _chart.data();
    calculateSizeScale();
    _cloudLayout = _d2.default.layout.cloud().size([_chart.width(), _chart.height()]).words(_cloudData.map(function (d) {
      return {
        key0: d.key0,
        value: d.value,
        color: d.color,
        text: d.key0,
        size: _r(_chart.valueAccessor()(d))
      };
    }

    // return {key: d.key0, value: d.value, text: d.key0, size: _r(_chart.valueAccessor()(d))};
    )).rotate(function () {
      return 0;
    }).font("Impact").fontSize(function (d) {
      return d.size;
    }).on("end", cloudDraw);
    _cloudLayout.start();
  }

  function calculateSizeScale() {
    var extent = _d2.default.extent(_cloudData, _chart.cappedValueAccessor);

    _r = _d2.default.scale.log().domain(extent).range([10, Math.max(14, Math.min(_chart.effectiveWidth(), _chart.effectiveHeight()) / 10)]);
  }

  function cloudDraw(newTags) {
    _tags = newTags;
    var tagElems = _g.attr("transform", "translate(" + _cloudLayout.size()[0] / 2 + "," + _cloudLayout.size()[1] / 2 + ")").selectAll("text").data(_tags);
    tagElems.enter().append("text");
    tagElems.exit().remove();
    tagElems.style("font-size", function (d) {
      return d.size + "px";
    }).style("font-family", "Impact").style("fill", _chart.getColor) // function(d, i) { return fill(i); })
    .style("cursor", "pointer").attr("text-anchor", "middle").attr("transform", function (d) {
      return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
    }).text(function (d) {
      return d.key0;
    }).on("click", onClick).classed("deselected", function (d) {
      return _chart.hasFilter() ? !isSelectedTag(d) : false;
    }).classed("selected", function (d) {
      return _chart.hasFilter() ? isSelectedTag(d) : false;
    });

    createTitles(tagElems);
  }

  function onClick(d) {
    _noRelayout = true;
    _chart.onClick(d);
  }

  function createTitles(tags) {
    if (_chart.renderTitle()) {
      tags.selectAll("title").remove();
      tags.append("title").text(_chart.title());
    }
  }

  function isSelectedTag(d) {
    return _chart.hasFilter(_chart.cappedKeyAccessor(d));
  }

  _chart.title(function (d) {
    return _chart.cappedKeyAccessor(d) + ": " + _chart.cappedValueAccessor(d);
  });

  _chart.label(_chart.cappedKeyAccessor);

  _chart._doRender = function () {
    _chart.resetSvg();
    _g = _chart.svg().append("g").attr("transform", "translate(" + _chart.margins().left + "," + _chart.margins().top + ")");

    if (_noRelayout) {
      cloudDraw(_tags); // skip layout so tags remain in place
      _noRelayout = false;
    } else {
      drawChart();
    }
    var _hasBeenRendered = true;

    return _chart;
  };

  _chart._doRedraw = function () {
    if (!_hasBeenRendered) {
      return _chart._doRender();
    }
    if (_noRelayout) {
      cloudDraw(_tags);
      _noRelayout = false;
    } else {
      drawChart();
    }
    return _chart;
  };

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = compositeChart;

var _coordinateGridMixin = __webpack_require__(11);

var _coordinateGridMixin2 = _interopRequireDefault(_coordinateGridMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _core = __webpack_require__(2);

var _utils = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Composite charts are a special kind of chart that render multiple charts on the same Coordinate
 * Grid. You can overlay (compose) different bar/line/area charts in a single composite chart to
 * achieve some quite flexible charting effects.
 * @name compositeChart
 * @memberof dc
 * @mixes dc.coordinateGridMixin
 * @example
 * // create a composite chart under #chart-container1 element using the default global chart group
 * var compositeChart1 = dc.compositeChart('#chart-container1');
 * // create a composite chart under #chart-container2 element using chart group A
 * var compositeChart2 = dc.compositeChart('#chart-container2', 'chartGroupA');
 * @param {String|node|d3.selection} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector} specifying
 * a dom block element such as a div; or a dom element or d3 selection.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
 * Interaction with a chart will only trigger events and redraws within the chart's group.
 * @return {dc.compositeChart}
 */
function compositeChart(parent, chartGroup) {
  var SUB_CHART_CLASS = "sub";
  var DEFAULT_RIGHT_Y_AXIS_LABEL_PADDING = 12;

  var _chart = (0, _coordinateGridMixin2.default)({});
  var _children = [];

  var _childOptions = {};

  var _shareColors = false,
      _shareTitle = true,
      _alignYAxes = false;

  var _rightYAxis = _d2.default.svg.axis(),
      _rightYAxisLabel = 0,
      _rightYAxisLabelPadding = DEFAULT_RIGHT_Y_AXIS_LABEL_PADDING,
      _rightY = void 0,
      _rightAxisGridLines = false;

  _chart._mandatoryAttributes([]);
  _chart.transitionDuration(500);

  (0, _core.override)(_chart, "_generateG", function () {
    var g = this.__generateG();

    for (var i = 0; i < _children.length; ++i) {
      var child = _children[i];

      generateChildG(child, i);

      if (!child.dimension()) {
        child.dimension(_chart.dimension());
      }
      if (!child.group()) {
        child.group(_chart.group());
      }

      child.chartGroup(_chart.chartGroup());
      child.svg(_chart.svg());
      child.xUnits(_chart.xUnits());
      child.transitionDuration(_chart.transitionDuration());
      child.brushOn(_chart.brushOn());
      child.renderTitle(_chart.renderTitle());
      child.elasticX(_chart.elasticX());
    }

    return g;
  });

  _chart._brushing = function () {
    var extent = _chart.extendBrush();
    var brushIsEmpty = _chart.brushIsEmpty(extent);

    for (var i = 0; i < _children.length; ++i) {
      _children[i].filterAll();
      if (!brushIsEmpty) {
        _children[i].filter(extent);
      }
    }
  };

  _chart._prepareYAxis = function () {
    var left = leftYAxisChildren().length !== 0;
    var right = rightYAxisChildren().length !== 0;
    var ranges = calculateYAxisRanges(left, right);

    if (left) {
      prepareLeftYAxis(ranges);
    }
    if (right) {
      prepareRightYAxis(ranges);
    }

    if (leftYAxisChildren().length > 0 && !_rightAxisGridLines) {
      _chart._renderHorizontalGridLinesForAxis(_chart.g(), _chart.y(), _chart.yAxis());
    } else if (rightYAxisChildren().length > 0) {
      _chart._renderHorizontalGridLinesForAxis(_chart.g(), _rightY, _rightYAxis);
    }
  };

  _chart.renderYAxis = function () {
    if (leftYAxisChildren().length !== 0) {
      _chart.renderYAxisAt("y", _chart.yAxis(), _chart.margins().left);
      _chart.renderYAxisLabel("y", _chart.yAxisLabel(), -90);
    }

    if (rightYAxisChildren().length !== 0) {
      _chart.renderYAxisAt("yr", _chart.rightYAxis(), _chart.width() - _chart.margins().right);
      _chart.renderYAxisLabel("yr", _chart.rightYAxisLabel(), 90, _chart.width() - _rightYAxisLabelPadding);
    }
  };

  function calculateYAxisRanges(left, right) {
    var lyAxisMin = void 0,
        lyAxisMax = void 0,
        ryAxisMin = void 0,
        ryAxisMax = void 0;

    if (left) {
      lyAxisMin = yAxisMin();
      lyAxisMax = yAxisMax();
    }

    if (right) {
      ryAxisMin = rightYAxisMin();
      ryAxisMax = rightYAxisMax();
    }

    if (_chart.alignYAxes() && left && right && (lyAxisMin < 0 || ryAxisMin < 0)) {
      // both y axis are linear and at least one doesn't start at zero
      var leftYRatio = void 0,
          rightYRatio = void 0;

      if (lyAxisMin < 0) {
        leftYRatio = lyAxisMax / lyAxisMin;
      }

      if (ryAxisMin < 0) {
        rightYRatio = ryAxisMax / ryAxisMin;
      }

      if (lyAxisMin < 0 && ryAxisMin < 0) {
        if (leftYRatio < rightYRatio) {
          ryAxisMax = ryAxisMin * leftYRatio;
        } else {
          lyAxisMax = lyAxisMin * rightYRatio;
        }
      } else if (lyAxisMin < 0) {
        ryAxisMin = ryAxisMax / leftYRatio;
      } else {
        lyAxisMin = lyAxisMax / (ryAxisMax / ryAxisMin);
      }
    }
    return {
      lyAxisMin: lyAxisMin,
      lyAxisMax: lyAxisMax,
      ryAxisMin: ryAxisMin,
      ryAxisMax: ryAxisMax
    };
  }

  function prepareRightYAxis(ranges) {
    if (_chart.rightY() === undefined || _chart.elasticY() || _chart.resizing()) {
      if (_chart.rightY() === undefined) {
        _chart.rightY(_d2.default.scale.linear());
      }
      _chart.rightY().domain([ranges.ryAxisMin, ranges.ryAxisMax]).rangeRound([_chart.yAxisHeight(), 0]);
    }

    _chart.rightY().range([_chart.yAxisHeight(), 0]);
    _chart.rightYAxis(_chart.rightYAxis().scale(_chart.rightY()));

    _chart.rightYAxis().orient("right");
  }

  function prepareLeftYAxis(ranges) {
    if (_chart.y() === undefined || _chart.elasticY() || _chart.resizing()) {
      if (_chart.y() === undefined) {
        _chart.y(_d2.default.scale.linear());
      }
      _chart.y().domain([ranges.lyAxisMin, ranges.lyAxisMax]).rangeRound([_chart.yAxisHeight(), 0]);
    }

    _chart.y().range([_chart.yAxisHeight(), 0]);
    _chart.yAxis(_chart.yAxis().scale(_chart.y()));

    _chart.yAxis().orient("left");
  }

  function generateChildG(child, i) {
    child._generateG(_chart.g());
    child.g().attr("class", SUB_CHART_CLASS + " _" + i);
  }

  _chart.plotData = function () {
    for (var i = 0; i < _children.length; ++i) {
      var child = _children[i];

      if (!child.g()) {
        generateChildG(child, i);
      }

      if (_shareColors) {
        child.colors(_chart.colors());
      }

      child.x(_chart.x());

      child.xAxis(_chart.xAxis());

      if (child.useRightYAxis()) {
        child.y(_chart.rightY());
        child.yAxis(_chart.rightYAxis());
      } else {
        child.y(_chart.y());
        child.yAxis(_chart.yAxis());
      }

      child.plotData();

      child._activateRenderlets();
    }
  };

  /**
   * Get or set whether to draw gridlines from the right y axis.  Drawing from the left y axis is the
   * default behavior. This option is only respected when subcharts with both left and right y-axes
   * are present.
   * @name useRightAxisGridLines
   * @memberof dc.compositeChart
   * @instance
   * @param {Boolean} [useRightAxisGridLines=false]
   * @return {Boolean}
   * @return {dc.compositeChart}
   */
  _chart.useRightAxisGridLines = function (useRightAxisGridLines) {
    if (!arguments) {
      return _rightAxisGridLines;
    }

    _rightAxisGridLines = useRightAxisGridLines;
    return _chart;
  };

  /**
   * Get or set chart-specific options for all child charts. This is equivalent to calling
   * {@link #dc.baseMixin+options .options} on each child chart.
   * @name childOptions
   * @memberof dc.compositeChart
   * @instance
   * @param {Object} [childOptions]
   * @return {Object}
   * @return {dc.compositeChart}
   */
  _chart.childOptions = function (childOptions) {
    if (!arguments.length) {
      return _childOptions;
    }
    _childOptions = childOptions;
    _children.forEach(function (child) {
      child.options(_childOptions);
    });
    return _chart;
  };

  _chart.fadeDeselectedArea = function () {
    for (var i = 0; i < _children.length; ++i) {
      var child = _children[i];
      child.brush(_chart.brush());
      child.fadeDeselectedArea();
    }
  };

  /**
   * Set or get the right y axis label.
   * @name rightYAxisLabel
   * @memberof dc.compositeChart
   * @instance
   * @param {String} [rightYAxisLabel]
   * @param {Number} [padding]
   * @return {String}
   * @return {dc.compositeChart}
   */
  _chart.rightYAxisLabel = function (rightYAxisLabel, padding) {
    if (!arguments.length) {
      return _rightYAxisLabel;
    }
    _rightYAxisLabel = rightYAxisLabel;
    _chart.margins().right -= _rightYAxisLabelPadding;
    _rightYAxisLabelPadding = padding === undefined ? DEFAULT_RIGHT_Y_AXIS_LABEL_PADDING : padding;
    _chart.margins().right += _rightYAxisLabelPadding;
    return _chart;
  };

  /**
   * Combine the given charts into one single composite coordinate grid chart.
   * @name compose
   * @memberof dc.compositeChart
   * @instance
   * @example
   * moveChart.compose([
   *     // when creating sub-chart you need to pass in the parent chart
   *     dc.lineChart(moveChart)
   *         .group(indexAvgByMonthGroup) // if group is missing then parent's group will be used
   *         .valueAccessor(function (d){return d.value.avg;})
   *         // most of the normal functions will continue to work in a composed chart
   *         .renderArea(true)
   *         .stack(monthlyMoveGroup, function (d){return d.value;})
   *         .title(function (d){
   *             var value = d.value.avg?d.value.avg:d.value;
   *             if(isNaN(value)) value = 0;
   *             return dateFormat(d.key) + '\n' + numberFormat(value);
   *         }),
   *     dc.barChart(moveChart)
   *         .group(volumeByMonthGroup)
   *         .centerBar(true)
   * ]);
   * @param {Array<Chart>} [subChartArray]
   * @return {dc.compositeChart}
   */
  _chart.compose = function (subChartArray) {
    _children = subChartArray;
    _children.forEach(function (child) {
      child.height(_chart.height());
      child.width(_chart.width());
      child.margins(_chart.margins());

      if (_shareTitle) {
        child.title(_chart.title());
      }

      child.options(_childOptions);
    });
    return _chart;
  };

  /**
   * Returns the child charts which are composed into the composite chart.
   * @name children
   * @memberof dc.compositeChart
   * @instance
   * @return {Array<dc.baseMixin>}
   */
  _chart.children = function () {
    return _children;
  };

  /**
   * Get or set color sharing for the chart. If set, the {@link #dc.colorMixin+colors .colors()} value from this chart
   * will be shared with composed children. Additionally if the child chart implements
   * Stackable and has not set a custom .colorAccessor, then it will generate a color
   * specific to its order in the composition.
   * @name shareColors
   * @memberof dc.compositeChart
   * @instance
   * @param {Boolean} [shareColors=false]
   * @return {Boolean}
   * @return {dc.compositeChart}
   */
  _chart.shareColors = function (shareColors) {
    if (!arguments.length) {
      return _shareColors;
    }
    _shareColors = shareColors;
    return _chart;
  };

  /**
   * Get or set title sharing for the chart. If set, the {@link #dc.baseMixin+title .title()} value from
   * this chart will be shared with composed children.
   * @name shareTitle
   * @memberof dc.compositeChart
   * @instance
   * @param {Boolean} [shareTitle=true]
   * @return {Boolean}
   * @return {dc.compositeChart}
   */
  _chart.shareTitle = function (shareTitle) {
    if (!arguments.length) {
      return _shareTitle;
    }
    _shareTitle = shareTitle;
    return _chart;
  };

  /**
   * Get or set the y scale for the right axis. The right y scale is typically automatically
   * generated by the chart implementation.
   * @name rightY
   * @memberof dc.compositeChart
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/Scales d3.scale}
   * @param {d3.scale} [yScale]
   * @return {d3.scale}
   * @return {dc.compositeChart}
   */
  _chart.rightY = function (yScale) {
    if (!arguments.length) {
      return _rightY;
    }
    _rightY = yScale;
    _chart.rescale();
    return _chart;
  };

  /**
   * Get or set alignment between left and right y axes. A line connecting '0' on both y axis
   * will be parallel to x axis.
   * @name alignYAxes
   * @memberof dc.compositeChart
   * @instance
   * @param {Boolean} [alignYAxes=false]
   * @return {Chart}
   */
  _chart.alignYAxes = function (alignYAxes) {
    if (!arguments.length) {
      return _alignYAxes;
    }
    _alignYAxes = alignYAxes;
    _chart.rescale();
    return _chart;
  };

  function leftYAxisChildren() {
    return _children.filter(function (child) {
      return !child.useRightYAxis();
    });
  }

  function rightYAxisChildren() {
    return _children.filter(function (child) {
      return child.useRightYAxis();
    });
  }

  function getYAxisMin(charts) {
    return charts.map(function (c) {
      return c.yAxisMin();
    });
  }

  delete _chart.yAxisMin;
  function yAxisMin() {
    return _d2.default.min(getYAxisMin(leftYAxisChildren()));
  }

  function rightYAxisMin() {
    return _d2.default.min(getYAxisMin(rightYAxisChildren()));
  }

  function getYAxisMax(charts) {
    return charts.map(function (c) {
      return c.yAxisMax();
    });
  }

  delete _chart.yAxisMax;
  function yAxisMax() {
    return _utils.utils.add(_d2.default.max(getYAxisMax(leftYAxisChildren())), _chart.yAxisPadding());
  }

  function rightYAxisMax() {
    return _utils.utils.add(_d2.default.max(getYAxisMax(rightYAxisChildren())), _chart.yAxisPadding());
  }

  function getAllXAxisMinFromChildCharts() {
    return _children.map(function (c) {
      return c.xAxisMin();
    });
  }

  (0, _core.override)(_chart, "xAxisMin", function () {
    return _utils.utils.subtract(_d2.default.min(getAllXAxisMinFromChildCharts()), _chart.xAxisPadding());
  });

  function getAllXAxisMaxFromChildCharts() {
    return _children.map(function (c) {
      return c.xAxisMax();
    });
  }

  (0, _core.override)(_chart, "xAxisMax", function () {
    return _utils.utils.add(_d2.default.max(getAllXAxisMaxFromChildCharts()), _chart.xAxisPadding());
  });

  _chart.legendables = function () {
    return _children.reduce(function (items, child) {
      if (_shareColors) {
        child.colors(_chart.colors());
      }
      items.push.apply(items, child.legendables());
      return items;
    }, []);
  };

  _chart.legendHighlight = function (d) {
    for (var j = 0; j < _children.length; ++j) {
      var child = _children[j];
      child.legendHighlight(d);
    }
  };

  _chart.legendReset = function (d) {
    for (var j = 0; j < _children.length; ++j) {
      var child = _children[j];
      child.legendReset(d);
    }
  };

  _chart.legendToggle = function () {
    console.log("composite should not be getting legendToggle itself");
  };

  /**
   * Set or get the right y axis used by the composite chart. This function is most useful when y
   * axis customization is required. The y axis in dc.js is an instance of a [d3 axis
   * object](https://github.com/mbostock/d3/wiki/SVG-Axes#wiki-_axis) therefore it supports any valid
   * d3 axis manipulation. **Caution**: The y axis is usually generated internally by dc;
   * resetting it may cause unexpected results.
   * @name rightYAxis
   * @memberof dc.compositeChart
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/SVG-Axes d3.svg.axis}
   * @example
   * // customize y axis tick format
   * chart.rightYAxis().tickFormat(function (v) {return v + '%';});
   * // customize y axis tick values
   * chart.rightYAxis().tickValues([0, 100, 200, 300]);
   * @param {d3.svg.axis} [rightYAxis]
   * @return {d3.svg.axis}
   * @return {dc.compositeChart}
   */
  _chart.rightYAxis = function (rightYAxis) {
    if (!arguments.length) {
      return _rightYAxis;
    }
    _rightYAxis = rightYAxis;
    return _chart;
  };

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = dataCount;

var _baseMixin = __webpack_require__(5);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _coreAsync = __webpack_require__(4);

var _core = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The data count widget is a simple widget designed to display the number of records selected by the
 * current filters out of the total number of records in the data set. Once created the data count widget
 * will automatically update the text content of the following elements under the parent element.
 *
 * '.total-count' - total number of records
 * '.filter-count' - number of records matched by the current filters
 *
 * @name dataCount
 * @memberof dc
 * @mixes dc.baseMixin
 * @example
 * var ndx = crossfilter(data);
 * var all = ndx.groupAll();
 *
 * dc.dataCount('.dc-data-count')
 *     .dimension(ndx)
 *     .group(all);
 * @param {String|node|d3.selection} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector} specifying
 * a dom block element such as a div; or a dom element or d3 selection.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
 * Interaction with a chart will only trigger events and redraws within the chart's group.
 * @return {dc.dataCount}
 */
function dataCount(parent, chartGroup) {
  var _formatNumber = _d2.default.format(",d");
  var _chart = (0, _baseMixin2.default)({});
  var _html = { some: "", all: ""

    /* OVERRIDE ---------------------------------------------------------------- */
  };_chart.isCountChart = function () {
    return true;
  }; // override for count chart
  /* ------------------------------------------------------------------------- */

  (0, _core.override)(_chart, "group", function (group, name) {
    if (!arguments.length) {
      return _chart._group();
    }

    (0, _coreAsync.groupAll)(group);
    return _chart._group(group, name);
  });
  /**
   * Gets or sets an optional object specifying HTML templates to use depending how many items are
   * selected. The text `%total-count` will replaced with the total number of records, and the text
   * `%filter-count` will be replaced with the number of selected records.
   * - all: HTML template to use if all items are selected
   * - some: HTML template to use if not all items are selected
   * @name html
   * @memberof dc.dataCount
   * @instance
   * @example
   * counter.html({
   *      some: '%filter-count out of %total-count records selected',
   *      all: 'All records selected. Click on charts to apply filters'
   * })
   * @param {{some:String, all: String}} [options]
   * @return {{some:String, all: String}}
   * @return {dc.dataCount}
   */
  _chart.html = function (options) {
    if (!arguments.length) {
      return _html;
    }
    if (options.all) {
      _html.all = options.all;
    }
    if (options.some) {
      _html.some = options.some;
    }
    return _chart;
  };

  /**
   * Gets or sets an optional function to format the filter count and total count.
   * @name formatNumber
   * @memberof dc.dataCount
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/Formatting d3.format}
   * @example
   * counter.formatNumber(d3.format('.2g'))
   * @param {Function} [formatter=d3.format('.2g')]
   * @return {Function}
   * @return {dc.dataCount}
   */
  _chart.formatNumber = function (formatter) {
    if (!arguments.length) {
      return _formatNumber;
    }
    _formatNumber = formatter;
    return _chart;
  };

  /* OVERRIDE ---------------------------------------------------------------- */
  _chart.setDataAsync(function (group, callbacks) {
    return group.valueAsync().then(function (data) {
      callbacks(null, data);
    }).catch(function (error) {
      callbacks(error);
    });
  });
  /* ------------------------------------------------------------------------- */

  _chart._doRender = function () {
    // ok to call size b/c will hit cache every time
    var tot = _chart.dimension().size();
    _chart.root().style("width", "auto").style("height", "auto");

    /* OVERRIDE ---------------------------------------------------------------- */
    var val = null;
    if (_chart.dataCache != null) {
      val = _chart.dataCache;
    } else {
      val = _chart.group().value();
    }
    /* ------------------------------------------------------------------------- */

    var all = _formatNumber(tot);
    var selected = _formatNumber(val);

    if (tot === val && _html.all !== "") {
      _chart.root().html(_html.all.replace("%total-count", all).replace("%filter-count", selected));
    } else if (_html.some !== "") {
      _chart.root().html(_html.some.replace("%total-count", all).replace("%filter-count", selected));
    } else {
      _chart.selectAll(".total-count").text(all);

      /* OVERRIDE ---------------------------------------------------------------- */
      _chart.selectAll(".filter-count").classed("dark-text", all !== selected).text(selected);
      /* ------------------------------------------------------------------------- */
    }
    return _chart;
  };

  _chart._doRedraw = function () {
    return _chart._doRender();
  };

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = dataGrid;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _baseMixin = __webpack_require__(5);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Data grid is a simple widget designed to list the filtered records, providing
 * a simple way to define how the items are displayed.
 *
 * Note: Unlike other charts, the data grid chart (and data table) use the group attribute as a keying function
 * for {@link https://github.com/mbostock/d3/wiki/Arrays#-nest nesting} the data together in groups.
 * Do not pass in a crossfilter group as this will not work.
 *
 * Examples:
 * - {@link http://europarl.me/dc.js/web/ep/index.html List of members of the european parliament}
 * @name dataGrid
 * @memberof dc
 * @mixes dc.baseMixin
 * @param {String|node|d3.selection} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector} specifying
 * a dom block element such as a div; or a dom element or d3 selection.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
 * Interaction with a chart will only trigger events and redraws within the chart's group.
 * @return {dc.dataGrid}
 */
function dataGrid(parent, chartGroup) {
  var LABEL_CSS_CLASS = "dc-grid-label";
  var ITEM_CSS_CLASS = "dc-grid-item";
  var GROUP_CSS_CLASS = "dc-grid-group";
  var GRID_CSS_CLASS = "dc-grid-top";

  var _chart = (0, _baseMixin2.default)({});

  var _size = 999; // shouldn't be needed, but you might
  var _html = function _html(d) {
    return "you need to provide an html() handling param:  " + JSON.stringify(d);
  };
  var _sortBy = function _sortBy(d) {
    return d;
  };
  var _order = _d2.default.ascending;
  var _beginSlice = 0,
      _endSlice = void 0;

  var _htmlGroup = function _htmlGroup(d) {
    return "<div class='" + GROUP_CSS_CLASS + "'><h1 class='" + LABEL_CSS_CLASS + "'>" + _chart.keyAccessor()(d) + "</h1></div>";
  };

  _chart._doRender = function () {
    _chart.selectAll("div." + GRID_CSS_CLASS).remove();

    renderItems(renderGroups());

    return _chart;
  };

  function renderGroups() {
    var groups = _chart.root().selectAll("div." + GRID_CSS_CLASS).data(nestEntries(), function (d) {
      return _chart.keyAccessor()(d);
    });

    var itemGroup = groups.enter().append("div").attr("class", GRID_CSS_CLASS);

    if (_htmlGroup) {
      itemGroup.html(function (d) {
        return _htmlGroup(d);
      });
    }

    groups.exit().remove();
    return itemGroup;
  }

  function nestEntries() {
    var entries = _chart.dimension().top(_size);

    return _d2.default.nest().key(_chart.group()).sortKeys(_order).entries(entries.sort(function (a, b) {
      return _order(_sortBy(a), _sortBy(b));
    }).slice(_beginSlice, _endSlice));
  }

  function renderItems(groups) {
    var items = groups.order().selectAll("div." + ITEM_CSS_CLASS).data(function (d) {
      return d.values;
    });

    items.enter().append("div").attr("class", ITEM_CSS_CLASS).html(function (d) {
      return _html(d);
    });

    items.exit().remove();

    return items;
  }

  _chart._doRedraw = function () {
    return _chart._doRender();
  };

  /**
   * Get or set the index of the beginning slice which determines which entries get displayed by the widget.
   * Useful when implementing pagination.
   * @name beginSlice
   * @memberof dc.dataGrid
   * @instance
   * @param {Number} [beginSlice=0]
   * @return {Number}
   * @return {dc.dataGrid}
   */
  _chart.beginSlice = function (beginSlice) {
    if (!arguments.length) {
      return _beginSlice;
    }
    _beginSlice = beginSlice;
    return _chart;
  };

  /**
   * Get or set the index of the end slice which determines which entries get displayed by the widget
   * Useful when implementing pagination.
   * @name endSlice
   * @memberof dc.dataGrid
   * @instance
   * @param {Number} [endSlice]
   * @return {Number}
   * @return {dc.dataGrid}
   */
  _chart.endSlice = function (endSlice) {
    if (!arguments.length) {
      return _endSlice;
    }
    _endSlice = endSlice;
    return _chart;
  };

  /**
   * Get or set the grid size which determines the number of items displayed by the widget.
   * @name size
   * @memberof dc.dataGrid
   * @instance
   * @param {Number} [size=999]
   * @return {Number}
   * @return {dc.dataGrid}
   */
  _chart.size = function (size) {
    if (!arguments.length) {
      return _size;
    }
    _size = size;
    return _chart;
  };

  /**
   * Get or set the function that formats an item. The data grid widget uses a
   * function to generate dynamic html. Use your favourite templating engine or
   * generate the string directly.
   * @name html
   * @memberof dc.dataGrid
   * @instance
   * @example
   * chart.html(function (d) { return '<div class='item '+data.exampleCategory+''>'+data.exampleString+'</div>';});
   * @param {Function} [html]
   * @return {Function}
   * @return {dc.dataGrid}
   */
  _chart.html = function (html) {
    if (!arguments.length) {
      return _html;
    }
    _html = html;
    return _chart;
  };

  /**
   * Get or set the function that formats a group label.
   * @name htmlGroup
   * @memberof dc.dataGrid
   * @instance
   * @example
   * chart.htmlGroup (function (d) { return '<h2>'.d.key . 'with ' . d.values.length .' items</h2>'});
   * @param {Function} [htmlGroup]
   * @return {Function}
   * @return {dc.dataGrid}
   */
  _chart.htmlGroup = function (htmlGroup) {
    if (!arguments.length) {
      return _htmlGroup;
    }
    _htmlGroup = htmlGroup;
    return _chart;
  };

  /**
   * Get or set sort-by function. This function works as a value accessor at the item
   * level and returns a particular field to be sorted.
   * @name sortBy
   * @memberof dc.dataGrid
   * @instance
   * @example
   * chart.sortBy(function(d) {
   *     return d.date;
   * });
   * @param {Function} [sortByFunction]
   * @return {Function}
   * @return {dc.dataGrid}
   */
  _chart.sortBy = function (sortByFunction) {
    if (!arguments.length) {
      return _sortBy;
    }
    _sortBy = sortByFunction;
    return _chart;
  };

  /**
   * Get or set sort order function.
   * @name order
   * @memberof dc.dataGrid
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/Arrays#d3_ascending d3.ascending}
   * @see {@link https://github.com/mbostock/d3/wiki/Arrays#d3_descending d3.descending}
   * @example
   * chart.order(d3.descending);
   * @param {Function} [order=d3.ascending]
   * @return {Function}
   * @return {dc.dataGrid}
   */
  _chart.order = function (order) {
    if (!arguments.length) {
      return _order;
    }
    _order = order;
    return _chart;
  };

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = geoChoroplethChart;

var _baseMixin = __webpack_require__(5);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

var _colorMixin = __webpack_require__(7);

var _colorMixin2 = _interopRequireDefault(_colorMixin);

var _d2 = __webpack_require__(1);

var _d3 = _interopRequireDefault(_d2);

var _mapMixin = __webpack_require__(20);

var _mapMixin2 = _interopRequireDefault(_mapMixin);

var _core = __webpack_require__(2);

var _utils = __webpack_require__(3);

var _bbox = __webpack_require__(195);

var _bbox2 = _interopRequireDefault(_bbox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The geo choropleth chart is designed as an easy way to create a crossfilter driven choropleth map
 * from GeoJson data. This chart implementation was inspired by
 * {@link http://bl.ocks.org/4060606 the great d3 choropleth example}.
 *
 * @name geoChoroplethChart
 * @memberof dc
 * @mixes dc.colorMixin
 * @mixes dc.baseMixin
 * @example
 * // create a choropleth chart under '#us-chart' element using the default global chart group
 * var chart1 = dc.geoChoroplethChart('#us-chart');
 * // create a choropleth chart under '#us-chart2' element using chart group A
 * var chart2 = dc.compositeChart('#us-chart2', 'chartGroupA');
 * @param {String|node|d3.selection} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector} specifying
 * a dom block element such as a div; or a dom element or d3 selection.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
 * Interaction with a chart will only trigger events and redraws within the chart's group.
 * @return {dc.geoChoroplethChart}
 */
function geoChoroplethChart(parent, useMap, chartGroup, mapbox) {
  var _useMap = useMap !== undefined ? useMap : false;
  var parentDivId = parent.attributes.id.value;
  var _chart = null;
  if (_useMap) {
    _chart = (0, _mapMixin2.default)((0, _colorMixin2.default)((0, _baseMixin2.default)({})), parentDivId, mapbox);
  } else {
    _chart = (0, _colorMixin2.default)((0, _baseMixin2.default)({}));
  }

  _chart.colorAccessor(function (d) {
    return d || 0;
  });

  /* OVERRIDE -----------------------------------------------------------------*/
  _chart.accent = accentPoly;
  _chart.unAccent = unAccentPoly;

  _chart.measureValue = function (d) {
    var customFormatter = _chart.valueFormatter();
    return customFormatter && customFormatter(d) || _utils.utils.formatValue(d);
  };

  var _hasBeenRendered = false;
  /* --------------------------------------------------------------------------*/

  var _geoPath = _d3.default.geo.path();
  if (_useMap) {
    _geoPath.projection(_chart.mapProject.bind(_chart));
  }

  _chart._projectionFlag;

  var _geoJsons = [];
  _chart.transitionDuration(0);

  function findGeomMinMax(layerIndex) {
    var _geoJson = geoJson(layerIndex);
    var data = _geoJson.data;

    var realGeoJson = {
      type: "FeatureCollection",
      features: data
    };

    var _turfBbox = (0, _bbox2.default)(realGeoJson),
        _turfBbox2 = _slicedToArray(_turfBbox, 4),
        xMin = _turfBbox2[0],
        yMin = _turfBbox2[1],
        xMax = _turfBbox2[2],
        yMax = _turfBbox2[3];

    return [[xMin, yMin], [xMax, yMax]];
  }

  _chart.fitBounds = function () {
    if (geoJson(0)) {
      var bounds = geoJson(0).bounds;
      _chart.map().fitBounds(bounds, { animate: false }, { skipRedraw: true });
    }
  };

  _chart.destroyChart = function () {
    this.map().remove();
    if (this.legend()) {
      this.legend().removeLegend();
    }
  };

  _chart._doRender = function (d) {
    _chart.resetSvg(); // will use map mixin reset svg if we inherit map mixin
    for (var layerIndex = 0; layerIndex < _geoJsons.length; ++layerIndex) {
      var states = _chart.svg().append("g").attr("class", "layer" + layerIndex);
      // .attr('transform', 'translate(0, -16)');

      var regionG = states.selectAll("g." + geoJson(layerIndex).name).data(geoJson(layerIndex).data).enter().append("g").attr("class", geoJson(layerIndex).name);

      regionG.append("path").attr("fill", "white").attr("d", _geoPath);

      regionG.append("title");

      plotData(layerIndex, d);
    }
    _chart._projectionFlag = false;

    /* OVERRIDE -----------------------------------------------------------------*/
    _hasBeenRendered = true;
    /* --------------------------------------------------------------------------*/
  };

  function plotData(layerIndex, d) {
    var data = generateLayeredData(d);

    if (isDataLayer(layerIndex)) {
      var regionG = renderRegionG(layerIndex);

      renderPaths(regionG, layerIndex, data);

      // renderTitle(regionG, layerIndex, data);
    }
  }

  function generateLayeredData(d) {
    var data = {};
    var groupAll = d;
    for (var i = 0; i < groupAll.length; ++i) {
      data[_chart.keyAccessor()(groupAll[i])] = _chart.valueAccessor()(groupAll[i]);
    }
    return data;
  }

  function isDataLayer(layerIndex) {
    return geoJson(layerIndex).keyAccessor;
  }

  function renderRegionG(layerIndex) {
    var regionG = _chart.svg().selectAll(layerSelector(layerIndex)).classed("selected", function (d) {
      return isSelected(layerIndex, d);
    }).classed("deselected", function (d) {
      return isDeselected(layerIndex, d);
    }).attr("class", function (d) {
      var layerNameClass = geoJson(layerIndex).name;
      var regionClass = _utils.utils.nameToId(geoJson(layerIndex).keyAccessor(d));
      var baseClasses = layerNameClass + " " + regionClass;
      if (isSelected(layerIndex, d)) {
        baseClasses = baseClasses + " selected";
      }
      if (isDeselected(layerIndex, d)) {
        baseClasses = baseClasses + " deselected";
      }
      return baseClasses;
    });
    return regionG;
  }

  function layerSelector(layerIndex) {
    return "g.layer" + layerIndex + " g." + geoJson(layerIndex).name;
  }

  /* OVERRIDE EXTEND ----------------------------------------------------------*/
  function accentPoly(label) {
    var layerNameClass = geoJson(0).name; // hack for now as we only allow one layer currently
    _chart.selectAll("g." + layerNameClass).each(function (d) {
      if (getKey(0, d) == label) {
        _chart.accentSelected(this);
      }
    });
  }

  function unAccentPoly(label) {
    var layerNameClass = geoJson(0).name; // hack for now as we only allow one layer currently
    _chart.selectAll("g." + layerNameClass).each(function (d) {
      if (getKey(0, d) == label) {
        _chart.unAccentSelected(this);
      }
    });
  }
  /* --------------------------------------------------------------------------*/

  function isSelected(layerIndex, d) {
    return _chart.hasFilter() && _chart.hasFilter(getKey(layerIndex, d)) ^ _chart.filtersInverse();
  }

  function isDeselected(layerIndex, d) {
    return _chart.hasFilter() && !isSelected(layerIndex, d);
  }

  function getKey(layerIndex, d) {
    return geoJson(layerIndex).keyAccessor(d);
  }

  function geoJson(index) {
    return _geoJsons[index];
  }

  function renderPaths(regionG, layerIndex, data) {
    /* OVERRIDE ---------------------------------------------------------------- */
    var dragRegion = _d3.default.behavior.drag().on("dragstart", function () {
      _d3.default.event.sourceEvent.preventDefault();
    });
    /* ------------------------------------------------------------------------- */

    var paths = regionG.select("path").attr("fill", function () {
      var currentFill = _d3.default.select(this).attr("fill");
      if (currentFill) {
        return currentFill;
      }
      return "#e2e2e2";
    })
    /* OVERRIDE ---------------------------------------------------------------- */
    .on("mouseenter", function (d, i) {
      showPopup(d, i, data);
    }).on("mousemove", positionPopup).on("mouseleave", hidePopup).call(dragRegion)
    /* ------------------------------------------------------------------------- */
    .on("click", function (d) {
      return _chart.onClick(d, layerIndex);
    });

    (0, _core.transition)(paths, _chart.transitionDuration()).attr("fill", function (d, i) {
      var dataColor = data[geoJson(layerIndex).keyAccessor(d)];
      return _chart.getColor(dataColor, i);
    });
  }

  _chart.onClick = function (d, layerIndex) {
    var selectedRegion = geoJson(layerIndex).keyAccessor(d);
    _chart.handleFilterClick(_d3.default.event, selectedRegion);
  };

  function renderTitle(regionG, layerIndex, data) {
    if (_chart.renderTitle()) {
      regionG.selectAll("title").text(function (d) {
        var key = getKey(layerIndex, d);

        /* OVERRIDE -----------------------------------------------------------------*/
        var value = Number(data[key]).toFixed(2);
        return _chart.title()({ key0: key, value: value });
        /* --------------------------------------------------------------------------*/
      });
    }
  }

  _chart._doRedraw = function (data) {
    /* OVERRIDE -----------------------------------------------------------------*/
    if (!_hasBeenRendered) {
      return _chart._doRender();
    }
    /* --------------------------------------------------------------------------*/

    for (var layerIndex = 0; layerIndex < _geoJsons.length; ++layerIndex) {
      plotData(layerIndex, data);
      if (_chart._projectionFlag) {
        _chart.svg().selectAll("g." + geoJson(layerIndex).name + " path").attr("d", _geoPath);
      }
    }
    _chart._projectionFlag = false;
  };

  /**
   * **mandatory**
   *
   * Use this function to insert a new GeoJson map layer. This function can be invoked multiple times
   * if you have multiple GeoJson data layers to render on top of each other. If you overlay multiple
   * layers with the same name the new overlay will override the existing one.
   * @name overlayGeoJson
   * @memberof dc.geoChoroplethChart
   * @instance
   * @see {@link http://geojson.org/ GeoJSON}
   * @see {@link https://github.com/mbostock/topojson/wiki TopoJSON}
   * @see {@link https://github.com/mbostock/topojson/wiki/API-Reference#feature topojson.feature}
   * @example
   * // insert a layer for rendering US states
   * chart.overlayGeoJson(statesJson.features, 'state', function(d) {
   *      return d.properties.name;
   * })
   * @param {geoJson} json - a geojson feed
   * @param {String} name - name of the layer
   * @param {Function} keyAccessor - accessor function used to extract 'key' from the GeoJson data. The key extracted by
   * this function should match the keys returned by the crossfilter groups.
   * @return {dc.geoChoroplethChart}
   */
  _chart.overlayGeoJson = function (json, name, keyAccessor) {
    for (var i = 0; i < _geoJsons.length; ++i) {
      if (_geoJsons[i].name === name) {
        _geoJsons[i].data = json;
        _geoJsons[i].keyAccessor = keyAccessor;
        return _chart;
      }
    }
    _geoJsons.push({ name: name, data: json, keyAccessor: keyAccessor });
    _geoJsons[_geoJsons.length - 1].bounds = findGeomMinMax(_geoJsons.length - 1);

    return _chart;
  };

  /**
   * Set custom geo projection function. See the available [d3 geo projection
   * functions](https://github.com/mbostock/d3/wiki/Geo-Projections).
   * @name projection
   * @memberof dc.geoChoroplethChart
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/Geo-Projections d3.geo.projection}
   * @see {@link https://github.com/d3/d3-geo-projection Extended d3.geo.projection}
   * @param {d3.projection} [projection=d3.geo.albersUsa()]
   * @return {dc.geoChoroplethChart}
   */
  _chart.projection = function (projection) {
    if (!_useMap) {
      _geoPath.projection(projection);
      _chart._projectionFlag = true;
    }
    return _chart;
  };

  /**
   * Returns all GeoJson layers currently registered with this chart. The returned array is a
   * reference to this chart's internal data structure, so any modification to this array will also
   * modify this chart's internal registration.
   * @name geoJsons
   * @memberof dc.geoChoroplethChart
   * @instance
   * @return {Array<{name:String, data: Object, accessor: Function}>}
   */
  _chart.geoJsons = function () {
    return _geoJsons;
  };

  /**
   * Returns the {@link https://github.com/mbostock/d3/wiki/Geo-Paths#path d3.geo.path} object used to
   * render the projection and features.  Can be useful for figuring out the bounding box of the
   * feature set and thus a way to calculate scale and translation for the projection.
   * @name geoPath
   * @memberof dc.geoChoroplethChart
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/Geo-Paths#path d3.geo.path}
   * @return {d3.geo.path}
   */
  _chart.geoPath = function () {
    return _geoPath;
  };

  /**
   * Remove a GeoJson layer from this chart by name
   * @name removeGeoJson
   * @memberof dc.geoChoroplethChart
   * @instance
   * @param {String} name
   * @return {dc.geoChoroplethChart}
   */
  _chart.removeGeoJson = function (name) {
    var geoJsons = [];

    for (var i = 0; i < _geoJsons.length; ++i) {
      var layer = _geoJsons[i];
      if (layer.name !== name) {
        geoJsons.push(layer);
      }
    }

    _geoJsons = geoJsons;

    return _chart;
  };
  /* OVERRIDE ---------------------------------------------------------------- */
  function showPopup(d, i, data) {
    var popup = _chart.popup();

    var popupBox = popup.select(".chart-popup-content").html("");

    popupBox.append("div").attr("class", "popup-legend").style("background-color", _chart.getColor(data[geoJson(0).keyAccessor(d)], i));

    popupBox.append("div").attr("class", "popup-value").html(function () {
      var key = getKey(0, d);
      var value = isNaN(data[key]) ? "N/A" : _chart.measureValue(data[key]);
      return '<div class="popup-value-dim">' + key + '</div><div class="popup-value-measure">' + value + "</div>";
    });

    popup.classed("js-showPopup", true);
  }

  function hidePopup() {
    _chart.popup().classed("js-showPopup", false);
  }

  function positionPopup() {
    var coordinates = [0, 0];
    coordinates = _chart.popupCoordinates(_d3.default.mouse(this));
    var x = coordinates[0];
    var y = coordinates[1] - 16;

    var popup = _chart.popup().attr("style", function () {
      return "transform:translate(" + x + "px," + y + "px)";
    });

    popup.select(".chart-popup-box").classed("align-right", function () {
      return x + _d3.default.select(this).node().getBoundingClientRect().width > _chart.width();
    });
  }
  /* ------------------------------------------------------------------------- */

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapDrawMixin = mapDrawMixin;

var _utilsLasso = __webpack_require__(192);

var utils = _interopRequireWildcard(_utilsLasso);

var _coreAsync = __webpack_require__(4);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var DRAW_OPTIONS = {
  drawing: true,
  boxSelect: true,
  keybindings: false,
  controls: {
    point: false,
    line_string: false,
    polygon: true,
    trash: true,
    circle: true,
    combine_features: false,
    uncombine_features: false
  },
  styles: [
  // ACTIVE (being drawn)
  // line stroke
  {
    id: "gl-draw-line",
    type: "line",
    filter: ["all", ["==", "$type", "LineString"], ["==", "active", "true"]],
    layout: {
      "line-cap": "round",
      "line-join": "round"
    },
    paint: {
      "line-color": "#ef9b20",
      "line-dasharray": [0.5, 2],
      "line-width": 3
    }
  },
  // polygon fill
  {
    id: "gl-draw-polygon-fill",
    type: "fill",
    filter: ["all", ["==", "$type", "Polygon"], ["==", "active", "true"]],
    paint: {
      "fill-color": "#ef9b20",
      "fill-opacity": 0.1
    }
  },
  // polygon outline stroke
  // This doesn't style the first edge of the polygon, which uses the line stroke styling instead
  {
    id: "gl-draw-polygon-stroke-active",
    type: "line",
    filter: ["all", ["==", "$type", "Polygon"], ["==", "active", "true"]],
    layout: {
      "line-cap": "round",
      "line-join": "round"
    },
    paint: {
      "line-color": "#ef9b20",
      "line-dasharray": [0.5, 2],
      "line-width": 3
    }
  },
  // vertex point halos
  {
    id: "gl-draw-polygon-and-line-vertex-halo-active",
    type: "circle",
    filter: ["all", ["==", "meta", "vertex"], ["==", "$type", "Point"], ["==", "active", "true"]],
    paint: {
      "circle-radius": 0,
      "circle-color": "#FFF"
    }
  },
  // vertex points
  {
    id: "gl-draw-polygon-and-line-vertex-active",
    type: "circle",
    filter: ["all", ["==", "meta", "vertex"], ["==", "$type", "Point"], ["==", "active", "true"]],
    paint: {
      "circle-radius": 0,
      "circle-color": "#D20C0C"
    }
  },

  // INACTIVE (static, already drawn)
  // line stroke
  {
    id: "gl-draw-line-static",
    type: "line",
    filter: ["all", ["==", "$type", "LineString"], ["==", "active", "false"]],
    layout: {
      "line-cap": "round",
      "line-join": "round"
    },
    paint: {
      "line-color": "#22a7f0",
      "line-dasharray": [0.2, 2],
      "line-width": 1.5
    }
  },
  // polygon fill
  {
    id: "gl-draw-polygon-fill-static",
    type: "fill",
    filter: ["all", ["==", "$type", "Polygon"], ["==", "active", "false"]],
    paint: {
      "fill-color": "#22a7f0",
      "fill-outline-color": "#22a7f0",
      "fill-opacity": 0.1
    }
  },
  // polygon outline
  {
    id: "gl-draw-polygon-stroke-static",
    type: "line",
    filter: ["all", ["==", "$type", "Polygon"], ["==", "active", "false"]],
    layout: {
      "line-cap": "round",
      "line-join": "round"
    },
    paint: {
      "line-color": "#22a7f0",
      "line-width": 1.5
    }
  }]
};

function mapDrawMixin(chart) {
  var _mapboxgl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : mapboxgl;

  var _MapboxDraw = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : MapboxDraw;

  var drawControlAdded = false;
  var coordFilter = null;
  var Draw = null;
  var drawMode = false;

  function drawEventHandler() {
    applyFilter();
    (0, _coreAsync.redrawAllAsync)(chart.chartGroup());
  }

  function applyFilter() {
    var _Draw$getAll = Draw.getAll(),
        features = _Draw$getAll.features;

    if (features.length) {
      var px = chart.xDim().value()[0];
      var py = chart.yDim().value()[0];
      var sql = utils.convertGeojsonToSql(features, px, py);
      coordFilter.filter(sql);
    } else {
      coordFilter.filter();
    }

    chart._invokeFilteredListener(chart.filters(), false);
  }

  function filters() {
    return Draw.getAll().features;
  }

  function filter(feature) {
    if (!arguments.length) {
      return Draw.getAll().features;
    }

    if (feature === null) {
      Draw.deleteAll();
    } else {
      Draw.add(feature);
    }

    applyFilter();
  }

  function changeDrawMode(a, b) {
    var _Draw$getSelected = Draw.getSelected(),
        features = _Draw$getSelected.features;

    if (features.length && Draw.getMode() === "direct_select") {
      Draw.changeMode("simple_select", features[0].id);
    }

    var mode = Draw.getMode();

    if (features.length || mode === "draw_polygon" || mode === "draw_circle") {
      chart.drawMode(true);
    } else {
      chart.drawMode(false);
    }
  }

  chart.drawMode = function (mode) {
    if (typeof mode === "boolean") {
      drawMode = mode;
      return chart;
    } else {
      return drawMode;
    }
  };

  chart.addDrawControl = function () {
    if (drawControlAdded) {
      return chart;
    }
    Draw = new _MapboxDraw(DRAW_OPTIONS);
    drawControlAdded = true;
    chart.map().addControl(Draw, "top-left");
    chart.map().on("draw.create", drawEventHandler);
    chart.map().on("draw.update", drawEventHandler);
    chart.map().on("draw.delete", function () {
      changeDrawMode();
      drawEventHandler();
    });
    chart.map().on("draw.modechange", changeDrawMode);
    chart.map().on("draw.selectionchange", changeDrawMode);
    chart.map().boxZoom.enable();

    chart.filter = filter;
    chart.filters = filters;

    chart.filterAll = function () {
      chart.drawMode(false);
      coordFilter.filter();
      Draw.deleteAll();
      return chart;
    };

    return chart;
  };

  chart.coordFilter = function (filter) {
    if (!filter) {
      return coordFilter;
    }

    if (coordFilter) {
      coordFilter.filter();
    }

    coordFilter = filter;
    return chart;
  };

  return chart;
}

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertGeojsonToSql = convertGeojsonToSql;

var _earcut = __webpack_require__(137);

var _earcut2 = _interopRequireDefault(_earcut);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var coordinates = function coordinates(index) {
  return function (features) {
    return features.map(function (feature) {
      return feature.geometry.coordinates[0].map(function (c) {
        return c[index];
      });
    }).reduce(function (accum, coords) {
      return accum.concat(coords);
    }, []);
  };
};

var LONGITUDE_INDEX = 0;
var LATITUDE_INDEX = 1;

var longitudes = coordinates(LONGITUDE_INDEX);
var latitudes = coordinates(LATITUDE_INDEX);

function convertFeaturesToUnlikelyStmt(features, px, py) {
  var lons = longitudes(features);
  var lats = latitudes(features);
  var left = Math.max.apply(Math, _toConsumableArray(lons));
  var right = Math.min.apply(Math, _toConsumableArray(lons));
  var top = Math.min.apply(Math, _toConsumableArray(lats));
  var bottom = Math.max.apply(Math, _toConsumableArray(lats));
  return "UNLIKELY( " + px + " >= " + right + " AND " + px + " <= " + left + " AND " + py + " >= " + top + " AND " + py + " <= " + bottom + ")";
}

function translateVertexIndexIntoLatLon(vertexIndexList, latLonList) {
  return vertexIndexList.map(function (i) {
    return [latLonList.vertices[i * latLonList.dimensions], latLonList.vertices[i * latLonList.dimensions + 1]];
  });
}

function writePointInTriangleSqlTest(p0, p1, p2, px, py) {
  function writeSign(p0, p1) {
    return "((" + px + ")-(" + p1[0] + "))*((" + p0[1] + ")-(" + p1[1] + ")) - " + ("((" + p0[0] + ")-(" + p1[0] + "))*((" + py + ")-(" + p1[1] + ")) < 0.0)");
  }

  var b1 = writeSign(p0, p1);
  var b2 = writeSign(p1, p2);
  var b3 = writeSign(p2, p0);
  return "((" + b1 + " = (" + b2 + ")) AND (" + b2 + " = (" + b3 + ")))";
}

function convertFeatureToCircleStmt(_ref, px, py) {
  var _ref$geometry = _ref.geometry,
      radius = _ref$geometry.radius,
      center = _ref$geometry.center;

  var lat2 = center[1];
  var lon2 = center[0];
  var meters = radius * 1000;
  return "DISTANCE_IN_METERS(" + lon2 + ", " + lat2 + ", " + px + ", " + py + ") < " + meters;
}

function convertGeojsonToSql(features, px, py) {
  var sql = "";
  var NUM_SIDES = 3;
  var triangleTests = [];
  var circleStmts = [];

  features.map(function (feature) {
    if (feature.properties.circle) {
      circleStmts.push(convertFeatureToCircleStmt(feature, px, py));
    } else {
      var data = _earcut2.default.flatten(feature.geometry.coordinates);
      var triangles = (0, _earcut2.default)(data.vertices, data.holes, data.dimensions);
      var result = translateVertexIndexIntoLatLon(triangles, data);
      for (var j = 0; j < result.length; j = j + NUM_SIDES) {
        var p2 = result[j + 2];
        var p1 = result[j + 1];
        var p0 = result[j];
        triangleTests.push(writePointInTriangleSqlTest(p0, p1, p2, px, py));
      }
    }
  });

  if (triangleTests.length) {
    var triangleClause = triangleTests.map(function (clause, index) {
      if (triangleTests.length - 1 === index) {
        return clause.substring(0, clause.length - 4);
      } else {
        return clause.substring(0, clause.length - 3);
      }
    }).join(" OR (");
    sql = sql + ("((" + px + " IS NOT NULL AND " + py + " IS NOT NULL) AND (" + triangleClause + "))");
  }

  if (circleStmts.length) {
    if (triangleTests.length) {
      sql = sql + (" OR (" + circleStmts.join(" OR ") + ")");
    } else {
      sql = sql + ("(" + circleStmts.join(" OR ") + ")");
    }

    sql = "(" + sql + ")";
  }

  if (triangleTests.length) {
    var unlikelyStmt = convertFeaturesToUnlikelyStmt(features, px, py);
    return "(" + unlikelyStmt + ") AND " + sql;
  } else {
    return sql;
  }
}

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

exports.getLatLonCircleClass = getLatLonCircleClass;

var _utilsLatlon = __webpack_require__(138);

var LatLonUtils = _interopRequireWildcard(_utilsLatlon);

var _mapdDraw = __webpack_require__(22);

var MapdDraw = _interopRequireWildcard(_mapdDraw);

var _simplifyJs = __webpack_require__(194);

var _simplifyJs2 = _interopRequireDefault(_simplifyJs);

var _logger = __webpack_require__(16);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* istanbul ignore next */
var LatLonCircleClass = null;

/* istanbul ignore next */
function getLatLonCircleClass() {
  if (!LatLonCircleClass) {
    LatLonCircleClass = function (_MapdDraw$Circle) {
      _inherits(LatLonCircle, _MapdDraw$Circle);

      function LatLonCircle(opts) {
        _classCallCheck(this, LatLonCircle);

        var _this = _possibleConstructorReturn(this, (LatLonCircle.__proto__ || Object.getPrototypeOf(LatLonCircle)).call(this, opts));

        _this._mercatorPts = [];
        _this._geomDirty = true;
        _this._initialRadius = _this._radius;
        return _this;
      }

      _createClass(LatLonCircle, [{
        key: "setScale",
        value: function setScale(scale) {
          this.radius = this._initialRadius * Math.min(scale[0], scale[1]);
        }
      }, {
        key: "resetInitialRadius",
        value: function resetInitialRadius() {
          this._initialRadius = this.radius;
        }
      }, {
        key: "_updateGeom",
        value: function _updateGeom() {
          if (this._geomDirty || this._boundsOutOfDate) {
            var centerMerc = [0, 0];
            var centerLatLon = [0, 0];
            var scale = [0, 0];
            var xform = this.globalXform;
            MapdDraw.Mat2d.svd(centerMerc, scale, null, xform);

            var degrees_between_points = 6.0;
            var number_of_points = Math.floor(360 / degrees_between_points);
            var dist_radians = this._radius / 6250;

            // convert from mercator to lat/lon
            LatLonUtils.conv900913To4326(centerLatLon, centerMerc);
            var center_lat_radians = centerLatLon[1] * MapdDraw.Math.DEG_TO_RAD;
            var center_lon_radians = centerLatLon[0] * MapdDraw.Math.DEG_TO_RAD;

            MapdDraw.AABox2d.initEmpty(this._aabox);
            this._mercatorPts = [];
            for (var index = 0; index < number_of_points; index = index + 1) {
              var degrees = index * degrees_between_points;
              var degree_radians = degrees * Math.PI / 180;
              var point_lat_radians = Math.asin(Math.sin(center_lat_radians) * Math.cos(dist_radians) + Math.cos(center_lat_radians) * Math.sin(dist_radians) * Math.cos(degree_radians));
              var point_lon_radians = center_lon_radians + Math.atan2(Math.sin(degree_radians) * Math.sin(dist_radians) * Math.cos(center_lat_radians), Math.cos(dist_radians) - Math.sin(center_lat_radians) * Math.sin(point_lat_radians));
              var point_lat = point_lat_radians * 180 / Math.PI;
              var point_lon = point_lon_radians * 180 / Math.PI;
              var point = MapdDraw.Point2d.create(point_lon, point_lat);

              // convert from lon/lat to mercator
              LatLonUtils.conv4326To900913(point, point);

              MapdDraw.AABox2d.encapsulatePt(this._aabox, this._aabox, point);
              this._mercatorPts.push(point);
            }

            var pivot = MapdDraw.Point2d.create(0, 0);
            MapdDraw.AABox2d.getCenter(pivot, this._aabox);
            MapdDraw.Point2d.sub(pivot, pivot, centerMerc);
            this.pivot = pivot;

            this._geomDirty = false;
            this._boundsOutOfDate = false;
          }
        }
      }, {
        key: "getDimensions",
        value: function getDimensions() {
          return [this.width, this.height];
        }
      }, {
        key: "_updateAABox",
        value: function _updateAABox() {
          this._updateGeom();
        }
      }, {
        key: "_draw",
        value: function _draw(ctx) {
          // only need the mercator to screen projection -- pull out any
          // local transforms here
          var xform = MapdDraw.Mat2d.clone(this.globalXform);
          MapdDraw.Mat2d.invert(xform, xform);
          MapdDraw.Mat2d.multiply(xform, this._fullXform, xform);
          ctx.setTransform(xform[0], xform[1], xform[2], xform[3], xform[4], xform[5]);

          this._updateGeom();

          if (this._mercatorPts.length) {
            ctx.moveTo(this._mercatorPts[0][0], this._mercatorPts[0][1]);
            for (var i = 1; i < this._mercatorPts.length; i = i + 1) {
              ctx.lineTo(this._mercatorPts[i][0], this._mercatorPts[i][1]);
            }
            ctx.closePath();
          }
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return Object.assign(_get(LatLonCircle.prototype.__proto__ || Object.getPrototypeOf(LatLonCircle.prototype), "toJSON", this).call(this), {
            type: "LatLonCircle" // this must match the name of the class
          });
        }
      }, {
        key: "initialRadius",
        set: function set(radius) {
          this.radius = radius;
          this._initialRadius = radius;
        }
      }, {
        key: "width",
        get: function get() {
          this._updateAABox();
          return this._aabox[2] - this._aabox[0];
        }
      }, {
        key: "height",
        get: function get() {
          this._updateAABox();
          return this._aabox[3] - this._aabox[1];
        }
      }]);

      return LatLonCircle;
    }(MapdDraw.Circle);
  }
  return LatLonCircleClass;
}

/* istanbul ignore next */

var ShapeHandler = function () {
  function ShapeHandler(parent, drawEngine, chart, buttonGroup, buttonId, defaultStyle, defaultSelectStyle) {
    _classCallCheck(this, ShapeHandler);

    this.parent = parent;
    this.drawEngine = drawEngine;
    this.canvas = drawEngine.getCanvas();
    this.chart = chart;
    this.baseMap = chart.map();
    this.buttonGroup = buttonGroup;
    this.buttonId = buttonId;
    this.defaultStyle = defaultStyle;
    this.defaultSelectStyle = defaultSelectStyle;
    this.mousedownCB = this.mousedownCB.bind(this);
    this.mouseupCB = this.mouseupCB.bind(this);
    this.mousemoveCB = this.mousemoveCB.bind(this);
    this.mouseoverCB = this.mouseoverCB.bind(this);
    this.clickCB = this.clickCB.bind(this);
    this.dblclickCB = this.dblclickCB.bind(this);
    this.keydownCB = this.keydownCB.bind(this);
    this.active = false;
  }

  _createClass(ShapeHandler, [{
    key: "disableBasemapEvents",
    value: function disableBasemapEvents() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.chart.hidePopup(true);
      this.chart.enableInteractions(false, options);
    }
  }, {
    key: "enableBasemapEvents",
    value: function enableBasemapEvents() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.chart.enableInteractions(true, options);
    }
  }, {
    key: "addShape",
    value: function addShape(shape) {
      var selectOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this.drawEngine.addShape(shape, selectOpts);
      this.drawEngine.moveShapeToTop(shape);
    }
  }, {
    key: "setupFinalShape",
    value: function setupFinalShape(shape) {
      var selectOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // deactivate the button associated with this shape handler
      // first to make sure that when the shape is selected,
      // the selection event handler is run. The selection event
      // handler is only run when all the button are deactivated,
      // so need to deactivate the button first, and the select
      // the new shape
      this.buttonGroup.deactivateButton(this.buttonId);
      if (this.drawEngine.hasShape(shape)) {
        this.drawEngine.selectShape(shape);
      } else {
        this.drawEngine.addShape(shape, selectOpts, true);
        this.drawEngine.moveShapeToTop(shape);
      }
      this.chart.addFilterShape(shape);
      this.canvas.focus();
    }
  }, {
    key: "mousedownCB",
    value: function mousedownCB(event) {}
  }, {
    key: "mouseupCB",
    value: function mouseupCB(event) {}
  }, {
    key: "mousemoveCB",
    value: function mousemoveCB(event) {}
  }, {
    key: "mouseoverCB",
    value: function mouseoverCB(event) {}
  }, {
    key: "clickCB",
    value: function clickCB(event) {}
  }, {
    key: "dblclickCB",
    value: function dblclickCB(event) {}
  }, {
    key: "keydownCB",
    value: function keydownCB(event) {}
  }, {
    key: "isMouseEventInCanvas",
    value: function isMouseEventInCanvas(mouseEvent) {
      var width = this.canvas.offsetWidth;
      var height = this.canvas.offsetHeight;
      var rect = this.canvas.getBoundingClientRect();

      var diffX = mouseEvent.clientX - rect.left - this.canvas.clientLeft;
      var diffY = mouseEvent.clientY - rect.top - this.canvas.clientTop;

      return diffX >= 0 && diffX < width && diffY >= 0 && diffY < height;
    }
  }, {
    key: "getRelativeMousePosFromEvent",
    value: function getRelativeMousePosFromEvent(mouseEvent) {
      var width = this.canvas.offsetWidth;
      var height = this.canvas.offsetHeight;
      var rect = this.canvas.getBoundingClientRect();

      var diffX = mouseEvent.clientX - rect.left - this.canvas.clientLeft;
      var diffY = mouseEvent.clientY - rect.top - this.canvas.clientTop;
      var mousepos = MapdDraw.Point2d.create(diffX, diffY);

      return mousepos;
    }
  }, {
    key: "activate",
    value: function activate() {
      if (!this.active) {
        document.addEventListener("mousedown", this.mousedownCB);
        document.addEventListener("mouseup", this.mouseupCB);
        document.addEventListener("mousemove", this.mousemoveCB);
        document.addEventListener("mouseover", this.mouseoverCB);
        document.addEventListener("click", this.clickCB);
        document.addEventListener("dblclick", this.dblclickCB);

        // NOTE: canvas div was setup to be focusable
        // and handle keyboard events in initControls()
        // function
        this.canvas.addEventListener("keydown", this.keydownCB);
        this.canvas.focus();

        this.active = true;
      }
    }
  }, {
    key: "deactivate",
    value: function deactivate() {
      if (this.active) {
        this.destroy();
        document.removeEventListener("mousedown", this.mousedownCB);
        document.removeEventListener("mouseup", this.mouseupCB);
        document.removeEventListener("mousemove", this.mousemoveCB);
        document.removeEventListener("mouseover", this.mouseoverCB);
        document.removeEventListener("click", this.clickCB);
        document.removeEventListener("dblclick", this.dblclickCB);

        this.canvas.removeEventListener("keydown", this.keydownCB);
        this.canvas.blur();

        this.active = false;
      }
    }
  }]);

  return ShapeHandler;
}();

/* istanbul ignore next */


var CircleShapeHandler = function (_ShapeHandler) {
  _inherits(CircleShapeHandler, _ShapeHandler);

  function CircleShapeHandler(parent, drawEngine, chart, buttonGroup, buttonId, defaultStyle, defaultSelectStyle) {
    _classCallCheck(this, CircleShapeHandler);

    var _this2 = _possibleConstructorReturn(this, (CircleShapeHandler.__proto__ || Object.getPrototypeOf(CircleShapeHandler)).call(this, parent, drawEngine, chart, buttonGroup, buttonId, defaultStyle, defaultSelectStyle));

    _this2.startmousepos = MapdDraw.Point2d.create(0, 0);
    _this2.startmouseworldpos = MapdDraw.Point2d.create(0, 0);

    _this2.useLonLat = typeof _this2.chart.useLonLat === "function" && _this2.chart.useLonLat();

    if (_this2.useLonLat) {
      _this2.startmouselatlonpos = MapdDraw.Point2d.create(0, 0);
    }
    _this2.activeshape = null;
    _this2.timer = null;
    return _this2;
  }

  _createClass(CircleShapeHandler, [{
    key: "deactivateShape",
    value: function deactivateShape() {
      if (this.activeShape) {
        var shape = this.activeShape;
        if (performance.now() - this.timer < 500) {
          // this is a click, so give the circle a default radius
          var bounds = this.chart.getDataRenderBounds();
          var currXRange = [bounds[0][0], bounds[1][0]];
          var currYRange = [bounds[0][1], bounds[2][1]];
          var projDims = [0.1 * Math.abs(currXRange[1] - currXRange[0]), 0.1 * Math.abs(currYRange[1] - currYRange[0])];
          if (this.useLonLat) {
            var pos = shape.getPosition();
            // convert from mercator to lat/lon
            LatLonUtils.conv900913To4326(pos, pos);

            projDims[0] = LatLonUtils.distance_in_meters(pos[0], pos[1], pos[0] + projDims[0], pos[1]) / 1000.0;
            projDims[1] = LatLonUtils.distance_in_meters(pos[0], pos[1], pos[0], pos[1] + projDims[1]) / 1000.0;
            shape.initialRadius = Math.min(projDims[0], projDims[1]);
          } else {
            shape.radius = Math.min(projDims[0], projDims[1]);
          }
        }
        // need to unset the active shape here first
        // before calling setupFinalShape, because
        // inside that call it's going to call destroy()
        this.activeShape = null;
        shape.setStyle(this.defaultStyle);
        this.setupFinalShape(shape);
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.activeShape) {
        this.drawEngine.deleteShape(this.activeShape);
        this.activeShape = null;
      }
    }
  }, {
    key: "mousedownCB",
    value: function mousedownCB(event) {
      if (!this.isMouseEventInCanvas(event)) {
        return;
      }

      this.disableBasemapEvents();
      MapdDraw.Point2d.copy(this.startmousepos, this.getRelativeMousePosFromEvent(event));
      this.drawEngine.project(this.startmouseworldpos, this.startmousepos);
      this.timer = performance.now();

      // convert from mercator to lat/lon
      var selectOpts = {};
      if (this.useLonLat) {
        LatLonUtils.conv900913To4326(this.startmouselatlonpos, this.startmouseworldpos);

        var CircleClass = getLatLonCircleClass();
        this.activeShape = new CircleClass(Object.assign({
          position: this.startmouseworldpos,
          radius: 0
        }, this.defaultSelectStyle));

        selectOpts.uniformScaleOnly = true;
        selectOpts.centerScaleOnly = true;
        selectOpts.rotatable = false;
      } else {
        this.activeShape = new MapdDraw.Circle(Object.assign({
          position: this.startmouseworldpos,
          radius: 0
        }, this.defaultSelectStyle));
      }
      this.canvas.focus();
      this.addShape(this.activeShape, selectOpts);
      event.stopImmediatePropagation();
      event.preventDefault();
    }
  }, {
    key: "mouseupCB",
    value: function mouseupCB(event) {
      this.deactivateShape();
    }
  }, {
    key: "mousemoveCB",
    value: function mousemoveCB(event) {
      if (this.activeShape) {
        var mousepos = this.getRelativeMousePosFromEvent(event);
        var mousescreenpos = MapdDraw.Point2d.create(0, 0);
        this.drawEngine.project(mousescreenpos, mousepos);

        if (this.useLonLat) {
          // convert from mercator to lat/lon
          LatLonUtils.conv900913To4326(mousescreenpos, mousescreenpos);
          var radius = LatLonUtils.distance_in_meters(this.startmouselatlonpos[0], this.startmouselatlonpos[1], mousescreenpos[0], mousescreenpos[1]);
          this.activeShape.initialRadius = radius / 1000;
        } else {
          var _radius = MapdDraw.Point2d.distance(this.startmouseworldpos, mousescreenpos);
          this.activeShape.radius = _radius;
        }

        // stopping all mousemove events, namely to stop hover callbacks
        event.stopImmediatePropagation();
        event.preventDefault();
      }
    }
  }, {
    key: "clickCB",
    value: function clickCB(event) {
      this.deactivateShape();
    }
  }, {
    key: "keydownCB",
    value: function keydownCB(event) {
      if (event.key === "Escape" || event.code === "Escape" || event.keyCode === 27) {
        this.destroy();
        this.enableBasemapEvents();
      }
    }
  }]);

  return CircleShapeHandler;
}(ShapeHandler);

/* istanbul ignore next */


var PolylineShapeHandler = function (_ShapeHandler2) {
  _inherits(PolylineShapeHandler, _ShapeHandler2);

  function PolylineShapeHandler(parent, drawEngine, chart, buttonGroup, buttonId, defaultStyle, defaultSelectStyle) {
    _classCallCheck(this, PolylineShapeHandler);

    var _this3 = _possibleConstructorReturn(this, (PolylineShapeHandler.__proto__ || Object.getPrototypeOf(PolylineShapeHandler)).call(this, parent, drawEngine, chart, buttonGroup, buttonId, defaultStyle, defaultSelectStyle));

    _this3.activeShape = null;
    _this3.startVert = null;
    _this3.lastVert = null;
    _this3.lineShape = null;
    _this3.prevVertPos = null;
    _this3.activeIdx = -1;
    _this3.startPosAABox = MapdDraw.AABox2d.create();
    _this3.timer = null;
    _this3.enableBasemapDebounceFunc = chart.debounce(function () {
      if (_this3.active) {
        _this3.enableBasemapEvents();
      }
    }, 100);
    return _this3;
  }

  _createClass(PolylineShapeHandler, [{
    key: "destroy",
    value: function destroy() {
      if (this.startVert) {
        this.drawEngine.deleteShape(this.startVert);
      }
      if (this.lastVert) {
        this.drawEngine.deleteShape(this.lastVert);
      }
      if (this.lineShape) {
        this.drawEngine.deleteShape(this.lineShape);
      }

      this.startVert = this.lastVert = this.lineShape = this.activeShape = this.prevVertPos = null;
      MapdDraw.AABox2d.initEmpty(this.startPosAABox);
      this.activeIdx = -1;
    }
  }, {
    key: "appendVertex",
    value: function appendVertex(mousepos, mouseworldpos) {
      if (this.lineShape) {
        if (!this.prevVertPos || Math.abs(mousepos[0] - this.prevVertPos[0]) > 2 || Math.abs(mousepos[1] - this.prevVertPos[1]) > 2) {
          this.prevVertPos = mousepos;
          return this.lineShape.appendVert(mouseworldpos);
        }
      }
      return -1;
    }
  }, {
    key: "finishShape",
    value: function finishShape() {
      var verts = this.lineShape ? this.lineShape.vertsRef : [];
      var removeLastVert = verts.length > 1 && !MapdDraw.Point2d.equals(verts[0], verts[verts.length - 1]) && this.lastVert && !MapdDraw.Point2d.equals(verts[verts.length - 1], this.lastVert.getPositionRef());
      if (verts.length > 2 && (!removeLastVert || verts.length > 3)) {
        // Check if there is a loop in the current verts, remove the last point
        // if so
        if (removeLastVert) {
          verts.pop();
        }

        var poly = new MapdDraw.Poly(Object.assign({
          verts: verts
        }, this.defaultStyle));
        this.setupFinalShape(poly);

        // clear out all other shapes using our destroy method
        this.destroy();
      } else {
        this.destroy();
        this.enableBasemapEvents();
      }
    }
  }, {
    key: "mousedownCB",
    value: function mousedownCB(event) {
      if (!this.isMouseEventInCanvas(event)) {
        this.timer = null;
        return;
      }

      this.timer = performance.now();
    }
  }, {
    key: "mouseupCB",
    value: function mouseupCB(event) {
      if (this.timer && performance.now() - this.timer < 500) {
        this.disableBasemapEvents();

        var shapeBuilt = false;
        var mousepos = this.getRelativeMousePosFromEvent(event);
        var mouseworldpos = MapdDraw.Point2d.create(0, 0);
        this.drawEngine.project(mouseworldpos, mousepos);

        if (!this.startVert) {
          this.lineShape = new MapdDraw.PolyLine(Object.assign({
            verts: [mouseworldpos]
          }, this.defaultSelectStyle));
          this.addShape(this.lineShape);
          this.startVert = new MapdDraw.Point({
            position: mouseworldpos,
            size: 5
          });
          this.addShape(this.startVert);
          this.activeShape = this.startVert;
          this.prevVertPos = mousepos;
          this.activeIdx = 0;
        } else if (!this.lastVert && this.lineShape.numVerts > 1) {
          var verts = this.lineShape.vertsRef;
          this.lastVert = new MapdDraw.Point({
            position: verts[1],
            size: 5
          });
          this.addShape(this.lastVert);
          this.activeShape = this.lastVert;
          this.activeIdx = 1;
        } else if (this.lastVert) {
          var startpos = this.startVert.getPosition();
          this.drawEngine.unproject(startpos, startpos);
          MapdDraw.AABox2d.initCenterExtents(this.startPosAABox, startpos, [10, 10]);
          if (MapdDraw.AABox2d.containsPt(this.startPosAABox, mousepos)) {
            this.finishShape();
            shapeBuilt = true;
          } else {
            var _verts = this.lineShape.vertsRef;
            this.lastVert.setPosition(_verts[_verts.length - 1]);
            this.activeShape = this.lastVert;
          }
        }

        if (!shapeBuilt) {
          this.enableBasemapDebounceFunc();
          this.canvas.focus();
          this.activeShape = null;
          this.activeIdx = -1;
        }
        event.preventDefault();
      }
    }
  }, {
    key: "mousemoveCB",
    value: function mousemoveCB(event) {
      if (this.startVert && this.lineShape && this.activeIdx < 0) {
        var mousepos = this.getRelativeMousePosFromEvent(event);
        var mouseworldpos = MapdDraw.Point2d.create(0, 0);
        this.drawEngine.project(mouseworldpos, mousepos);
        this.activeIdx = this.appendVertex(mousepos, mouseworldpos);
      }

      if (this.activeShape || this.activeIdx >= 0) {
        var _mousepos = this.getRelativeMousePosFromEvent(event);
        var _mouseworldpos = MapdDraw.Point2d.create(0, 0);
        this.drawEngine.project(_mouseworldpos, _mousepos);

        if (event.shiftKey) {
          if (this.activeIdx === 1) {
            var diff = [0, 0];
            var prevmousepos = [0, 0];
            var verts = this.lineShape.vertsRef;
            this.drawEngine.unproject(prevmousepos, verts[0]);
            MapdDraw.Point2d.sub(diff, _mousepos, prevmousepos);
            var angle = Math.atan2(diff[1], diff[0]);
            angle = MapdDraw.Math.round(angle / MapdDraw.Math.QUATER_PI) * MapdDraw.Math.QUATER_PI;
            var transformDir = [Math.cos(angle), Math.sin(angle)];
            MapdDraw.Vec2d.scale(diff, transformDir, MapdDraw.Vec2d.dot(diff, transformDir));
            MapdDraw.Point2d.addVec2(_mousepos, prevmousepos, diff);
            this.drawEngine.project(_mouseworldpos, _mousepos);
          } else if (this.activeIdx > 1) {
            var _verts2 = this.lineShape.vertsRef;
            var pt1 = [0, 0];
            this.drawEngine.unproject(pt1, _verts2[this.activeIdx - 2]);
            var pt2 = [0, 0];
            this.drawEngine.unproject(pt2, _verts2[this.activeIdx - 1]);
            var dir1 = [0, 0];
            MapdDraw.Point2d.sub(dir1, pt2, pt1);
            MapdDraw.Vec2d.normalize(dir1, dir1);
            var dir2 = [0, 0];
            MapdDraw.Point2d.sub(dir2, _mousepos, pt2);
            // MapdDraw.Vec2d.normalize(dir2, dir2)
            var _angle = MapdDraw.Vec2d.angle(dir1, dir2);
            _angle = MapdDraw.Math.round(_angle / MapdDraw.Math.QUATER_PI) * MapdDraw.Math.QUATER_PI;
            var matrix = MapdDraw.Mat2.create();
            MapdDraw.Mat2.fromRotation(matrix, _angle);
            var _transformDir = [0, 0];
            MapdDraw.Vec2d.transformMat2(_transformDir, dir1, matrix);
            MapdDraw.Vec2d.scale(_transformDir, _transformDir, MapdDraw.Vec2d.dot(dir2, _transformDir));
            MapdDraw.Point2d.addVec2(_mousepos, pt2, _transformDir);
            this.drawEngine.project(_mouseworldpos, _mousepos);
          }
        }

        if (this.activeShape) {
          this.activeShape.setPosition(_mouseworldpos);
        }

        if (this.activeIdx >= 0) {
          this.lineShape.setVertPosition(this.activeIdx, _mouseworldpos);
          this.canvas.focus();
        }
        event.preventDefault();
      }
    }
  }, {
    key: "dblclickCB",
    value: function dblclickCB(event) {
      if (!this.isMouseEventInCanvas(event)) {
        return;
      }

      this.finishShape();
    }
  }, {
    key: "keydownCB",
    value: function keydownCB(event) {
      if (event.key === "Escape" || event.code === "Escape" || event.keyCode === 27) {
        this.destroy();
        this.enableBasemapEvents();
      } else if (event.key === "Enter" || event.code === "Enter" || event.code === "NumpadEnter" || event.keyCode === 13) {
        this.finishShape();
      }
    }
  }]);

  return PolylineShapeHandler;
}(ShapeHandler);

/* istanbul ignore next */


var LassoShapeHandler = function (_ShapeHandler3) {
  _inherits(LassoShapeHandler, _ShapeHandler3);

  function LassoShapeHandler(parent, drawEngine, chart, buttonGroup, buttonId, defaultStyle, defaultSelectStyle) {
    _classCallCheck(this, LassoShapeHandler);

    var _this4 = _possibleConstructorReturn(this, (LassoShapeHandler.__proto__ || Object.getPrototypeOf(LassoShapeHandler)).call(this, parent, drawEngine, chart, buttonGroup, buttonId, defaultStyle, defaultSelectStyle));

    _this4.activeShape = null;
    _this4.lastPos = null;
    _this4.lastWorldPos = null;
    return _this4;
  }

  _createClass(LassoShapeHandler, [{
    key: "destroy",
    value: function destroy() {
      if (this.activeShape) {
        this.drawEngine.deleteShape(this.activeShape);
        this.activeShape = null;
      }
      this.lastPos = this.lastWorldPos = null;
    }
  }, {
    key: "mousedownCB",
    value: function mousedownCB(event) {
      if (!this.isMouseEventInCanvas(event)) {
        return;
      }

      this.disableBasemapEvents();
      this.activeShape = null;
      this.lastPos = this.getRelativeMousePosFromEvent(event);
      this.lastWorldPos = MapdDraw.Point2d.create(0, 0);
      this.drawEngine.project(this.lastWorldPos, this.lastPos);
      event.preventDefault();
    }
  }, {
    key: "mousemoveCB",
    value: function mousemoveCB(event) {
      if (!this.isMouseEventInCanvas(event)) {
        if (this.activeShape) {
          this.drawEngine.deleteShape(this.activeShape);
          this.activeShape = null;
          this.lastPos = null;
          this.lastWorldPos = null;
          this.enableBasemapEvents();
        }
        return;
      }

      if (this.lastPos) {
        var currPos = this.getRelativeMousePosFromEvent(event);
        var currWorldPos = MapdDraw.Point2d.create(0, 0);
        this.drawEngine.project(currWorldPos, currPos);
        if (!MapdDraw.Point2d.equals(currPos, this.lastPos)) {
          if (!this.activeShape) {
            this.activeShape = new MapdDraw.PolyLine(Object.assign({
              verts: [this.lastWorldPos, currWorldPos]
            }, this.defaultSelectStyle));
            this.addShape(this.activeShape);
          } else {
            this.activeShape.appendVert(currWorldPos);
          }
          MapdDraw.Point2d.copy(this.lastPos, currPos);
          MapdDraw.Point2d.copy(this.lastWorldPos, currWorldPos);
          this.canvas.focus();
        }
        event.preventDefault();
      }
    }
  }, {
    key: "mouseupCB",
    value: function mouseupCB(event) {
      var _this5 = this;

      if (this.activeShape) {
        var verts = this.activeShape.vertsRef;
        var screenVert = MapdDraw.Point2d.create(0, 0);
        var worldVert = MapdDraw.Point2d.create(0, 0);
        var simpleVerts = verts.map(function (vert) {
          _this5.drawEngine.unproject(screenVert, vert);
          return {
            x: screenVert[0],
            y: screenVert[1]
          };
        });
        simpleVerts = (0, _simplifyJs2.default)(simpleVerts, 4, true);
        var newverts = simpleVerts.map(function (vert) {
          MapdDraw.Point2d.set(screenVert, vert.x, vert.y);
          _this5.drawEngine.project(worldVert, screenVert);
          return MapdDraw.Point2d.clone(worldVert);
        });

        if (newverts.length < 3) {
          _logger.logger.warn("The resulting lasso shape is a point or a straight line. Cannot build a polygon from it. Please try again");
          this.drawEngine.deleteShape(this.activeShape);
          this.activeShape = null;
        } else {
          var poly = new MapdDraw.Poly(Object.assign({
            verts: newverts
          }, this.defaultStyle));
          this.drawEngine.deleteShape(this.activeShape);
          this.setupFinalShape(poly);
          event.preventDefault();
        }
      }
      this.lastPos = null;
      this.lastWorldPos = null;
    }
  }, {
    key: "keydownCB",
    value: function keydownCB(event) {
      if (event.key === "Escape" || event.code === "Escape" || event.keyCode === 27) {
        this.destroy();
        this.enableBasemapEvents();
      }
    }
  }]);

  return LassoShapeHandler;
}(ShapeHandler);

/* istanbul ignore next */


var LassoButtonGroupController = function () {
  function LassoButtonGroupController(parentContainer, parentChart, parentDrawEngine, defaultStyle, defaultSelectStyle) {
    _classCallCheck(this, LassoButtonGroupController);

    this._container = parentContainer;
    this._chart = parentChart;
    this._drawEngine = parentDrawEngine;
    this._buttonElements = {};
    this._activeButton = null;
    this._activeShape = null;

    this._selectionchangedCB = this._selectionchangedCB.bind(this);
    this._dragbeginCB = this._dragbeginCB.bind(this);
    this._dragendCB = this._dragendCB.bind(this);
    this._keyboardCB = this._keyboardCB.bind(this);
    this._initControls(defaultStyle, defaultSelectStyle);
  }

  _createClass(LassoButtonGroupController, [{
    key: "destroy",
    value: function destroy() {
      if (this._controlsInitted) {
        var canvas = this._drawEngine.getCanvas();
        canvas.removeEventListener("keydown", this._keyboardCB);

        this._circleHandler.deactivate();
        this._polylineHandler.deactivate();
        this._lassoHandler.deactivate();

        this._drawEngine.off(MapdDraw.ShapeBuilder.EventConstants.DRAG_END, this._dragendCB);
        this._drawEngine.off(MapdDraw.ShapeBuilder.EventConstants.DRAG_END, this._dragbeginCB);
        this._drawEngine.off(MapdDraw.ShapeBuilder.EventConstants.SELECTION_CHANGED, this._selectionchangedCB);

        this._controlContainer.removeChild(this._controlGroup);
        this._container.removeChild(this._controlContainer);
      }
    }
  }, {
    key: "_createControlButton",
    value: function _createControlButton(id) {
      var _this6 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var button = document.createElement("button");
      button.className = "mapd-draw-button " + options.className;
      button.setAttribute("title", options.title);
      this._controlGroup.appendChild(button);

      button.addEventListener("click", function (e) {
        e.preventDefault();
        e.stopPropagation();

        var clickedButton = e.target;
        if (_this6._activeButton && _this6._activeButton.button === clickedButton) {
          _this6.deactivateButtons();
          if (options.onDeactivate) {
            options.onDeactivate();
          }
          return;
        }

        _this6.setActiveButton(id, options);
        options.onActivate();
      }, true);

      button.addEventListener("mousedown", function (e) {
        _this6._chart.hidePopup(true);
        e.stopPropagation();
        e.preventDefault();
      });

      button.addEventListener("mouseover", function (e) {
        _this6._chart.hidePopup(true);
        _this6._chart.popupDisplayable(false);
        _this6._drawEngine.disableInteractions(false);
      });

      button.addEventListener("mouseout", function (e) {
        if (!_this6._activeShape && !_this6._activeButton) {
          _this6._chart.popupDisplayable(true);
          _this6._drawEngine.enableInteractions();
        }
      });

      button.addEventListener("mousemove", function (e) {
        e.stopImmediatePropagation();
        e.preventDefault();
      });

      return button;
    }
  }, {
    key: "_createButtonControl",
    value: function _createButtonControl(id, ShapeHandlerClass, defaultStyle, defaultSelectStyle) {
      var _this7 = this;

      var keybindingStr = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";

      var shapeHandler = new ShapeHandlerClass(this._container, this._drawEngine, this._chart, this, id, defaultStyle, defaultSelectStyle);
      this._buttonElements[id] = this._createControlButton(id, {
        className: "mapd-draw-button-" + id,
        title: "Create a " + id + (keybindingStr ? " [" + keybindingStr + "]" : ""),
        onActivate: function onActivate() {
          _this7._drawEngine.disableInteractions();
          _this7._activeShape = shapeHandler;
          _this7._activeShape.activate();
        },
        onDeactivate: function onDeactivate() {
          _this7._drawEngine.enableInteractions();
        }
      });
      return shapeHandler;
    }
  }, {
    key: "isActive",
    value: function isActive() {
      return Boolean(this._activeButton);
    }
  }, {
    key: "deactivateButton",
    value: function deactivateButton(id) {
      if (this._activeButton && this._buttonElements[id] === this._activeButton.button) {
        this.deactivateButtons();
        return true;
      }
      return false;
    }
  }, {
    key: "deactivateButtons",
    value: function deactivateButtons() {
      if (this._activeButton) {
        this._activeButton.button.classList.remove("mapd-draw-active-button");
        if (this._activeButton.options && this._activeButton.options.onDeactivate) {
          this._activeButton.options.onDeactivate();
        }
        this._activeButton = null;
      }

      if (this._activeShape) {
        this._activeShape.deactivate();
        this._activeShape = null;
      }

      // NOTE: not setting popup displayable here.
      // Leaving that for the "mouseout" event
    }
  }, {
    key: "setActiveButton",
    value: function setActiveButton(id, options) {
      var button = this._buttonElements[id];
      if (!button) {
        return;
      }

      if (button && id !== "trash") {
        this.deactivateButtons();
        button.classList.add("mapd-draw-active-button");
        this._activeButton = {
          button: button,
          id: id,
          options: options
        };
      }

      // NOTE: this does not stop chart.getClosestResult()
      // from being called, so there could be unnecessary
      // backend calls still although popups are disabled
      // We may want to consider a way to disable those as well
      this._chart.popupDisplayable(false);
    }
  }, {
    key: "_selectionchangedCB",
    value: function _selectionchangedCB(event) {
      if (!this._activeShape && !this._activeButton) {
        var canvas = this._drawEngine.getCanvas();
        if (event.selectedShapes && event.selectedShapes.length) {
          this._chart.hidePopup(true);
          this._chart.popupDisplayable(false);

          // deactivate all map interactions except scroll zoom
          this._chart.enableInteractions(false, {
            scrollZoom: true
          });

          canvas.focus();
        } else {
          this._chart.popupDisplayable(true);
          this._chart.enableInteractions(true);
          canvas.blur();
        }
      }
    }
  }, {
    key: "_dragbeginCB",
    value: function _dragbeginCB(event) {
      if (!this._activeShape && !this._activeButton) {
        var canvas = this._drawEngine.getCanvas();
        canvas.focus();
      }
    }
  }, {
    key: "_dragendCB",
    value: function _dragendCB(event) {
      var CircleClass = getLatLonCircleClass();
      event.shapes.forEach(function (shape) {
        if (shape instanceof CircleClass) {
          // need to reset the inital radius of the latlon circle
          // so that any rescaling is done relative to this
          // new radius
          shape.resetInitialRadius();
        }
      });
    }
  }, {
    key: "_keyboardCB",
    value: function _keyboardCB(event) {
      var _this8 = this;

      if ((event.key === "Backspace" || event.code === "Backspace" || event.keyCode === 8) && this._drawEngine) {
        var selectedShapes = this._drawEngine.selectedShapes;
        if (selectedShapes.length) {
          this._drawEngine.deleteSelectedShapes();
          selectedShapes.forEach(function (shape) {
            _this8._chart.deleteFilterShape(shape);
          });
        }
        event.preventDefault();
      }
    }
  }, {
    key: "_initControls",
    value: function _initControls(defaultStyle, defaultSelectStyle) {
      var margins = null;
      if (typeof this._chart.margins === "function") {
        margins = this._chart.margins();
      }

      this._controlContainer = document.createElement("div");
      this._controlContainer.style.top = (margins && margins.top ? margins.top : 0) + "px";
      this._controlContainer.style.left = (margins && margins.left ? margins.left : 0) + "px";
      this._controlContainer.style.position = "absolute";
      this._controlContainer.className = "mapd-draw-button-container";
      this._container.appendChild(this._controlContainer);

      var canvas = this._drawEngine.getCanvas();
      // make the canvas focusable so we can catch keyboard events
      // from it, but don't outline it when it is focused
      canvas.setAttribute("tabindex", -1);
      canvas.style.outline = "none";

      this._controlGroup = document.createElement("div");
      this._controlGroup.className = "mapd-draw-button-control-group";
      this._controlContainer.appendChild(this._controlGroup);

      this._drawEngine.on(MapdDraw.ShapeBuilder.EventConstants.SELECTION_CHANGED, this._selectionchangedCB);
      this._drawEngine.on(MapdDraw.ShapeBuilder.EventConstants.DRAG_BEGIN, this._dragbeginCB);
      this._drawEngine.on(MapdDraw.ShapeBuilder.EventConstants.DRAG_END, this._dragendCB);

      this._circleHandler = this._createButtonControl("circle", CircleShapeHandler, defaultStyle, defaultSelectStyle);
      this._polylineHandler = this._createButtonControl("polyline", PolylineShapeHandler, defaultStyle, defaultSelectStyle);
      this._lassoHandler = this._createButtonControl("lasso", LassoShapeHandler, defaultStyle, defaultSelectStyle);

      // NOTE: the canvas dom element needs to have a "tabindex" set to have
      // focusability, and best to have "outline: none" as part
      // of its style so an outline isn't shown when focused
      canvas.addEventListener("keydown", this._keyboardCB);

      this._controlsInitted = true;
    }
  }]);

  return LassoButtonGroupController;
}();

exports.default = LassoButtonGroupController;

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

(function () { 'use strict';

// to suit your point format, run search/replace for '.x' and '.y';
// for 3D version, see 3d branch (configurability would draw significant performance overhead)

// square distance between 2 points
function getSqDist(p1, p2) {

    var dx = p1.x - p2.x,
        dy = p1.y - p2.y;

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2) {

    var x = p1.x,
        y = p1.y,
        dx = p2.x - x,
        dy = p2.y - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2.x;
            y = p2.y;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p.x - x;
    dy = p.y - y;

    return dx * dx + dy * dy;
}
// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance) {

    var prevPoint = points[0],
        newPoints = [prevPoint],
        point;

    for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified) {
    var maxSqDist = sqTolerance,
        index;

    for (var i = first + 1; i < last; i++) {
        var sqDist = getSqSegDist(points[i], points[first], points[last]);

        if (sqDist > maxSqDist) {
            index = i;
            maxSqDist = sqDist;
        }
    }

    if (maxSqDist > sqTolerance) {
        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
        simplified.push(points[index]);
        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
    }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance) {
    var last = points.length - 1;

    var simplified = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
function simplify(points, tolerance, highestQuality) {

    if (points.length <= 2) return points;

    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}

// export as AMD module / Node module / browser or worker variable
if (true) !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return simplify; }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
else if (typeof module !== 'undefined') {
    module.exports = simplify;
    module.exports.default = simplify;
} else if (typeof self !== 'undefined') self.simplify = simplify;
else window.simplify = simplify;

})();


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var meta_1 = __webpack_require__(196);
/**
 * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.
 *
 * @name bbox
 * @param {GeoJSON} geojson any GeoJSON object
 * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order
 * @example
 * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);
 * var bbox = turf.bbox(line);
 * var bboxPolygon = turf.bboxPolygon(bbox);
 *
 * //addToMap
 * var addToMap = [line, bboxPolygon]
 */
function bbox(geojson) {
    var result = [Infinity, Infinity, -Infinity, -Infinity];
    meta_1.coordEach(geojson, function (coord) {
        if (result[0] > coord[0]) {
            result[0] = coord[0];
        }
        if (result[1] > coord[1]) {
            result[1] = coord[1];
        }
        if (result[2] < coord[0]) {
            result[2] = coord[0];
        }
        if (result[3] < coord[1]) {
            result[3] = coord[1];
        }
    });
    return result;
}
exports.default = bbox;


/***/ }),
/* 196 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["coordEach"] = coordEach;
/* harmony export (immutable) */ __webpack_exports__["coordReduce"] = coordReduce;
/* harmony export (immutable) */ __webpack_exports__["propEach"] = propEach;
/* harmony export (immutable) */ __webpack_exports__["propReduce"] = propReduce;
/* harmony export (immutable) */ __webpack_exports__["featureEach"] = featureEach;
/* harmony export (immutable) */ __webpack_exports__["featureReduce"] = featureReduce;
/* harmony export (immutable) */ __webpack_exports__["coordAll"] = coordAll;
/* harmony export (immutable) */ __webpack_exports__["geomEach"] = geomEach;
/* harmony export (immutable) */ __webpack_exports__["geomReduce"] = geomReduce;
/* harmony export (immutable) */ __webpack_exports__["flattenEach"] = flattenEach;
/* harmony export (immutable) */ __webpack_exports__["flattenReduce"] = flattenReduce;
/* harmony export (immutable) */ __webpack_exports__["segmentEach"] = segmentEach;
/* harmony export (immutable) */ __webpack_exports__["segmentReduce"] = segmentReduce;
/* harmony export (immutable) */ __webpack_exports__["lineEach"] = lineEach;
/* harmony export (immutable) */ __webpack_exports__["lineReduce"] = lineReduce;
/* harmony export (immutable) */ __webpack_exports__["findSegment"] = findSegment;
/* harmony export (immutable) */ __webpack_exports__["findPoint"] = findPoint;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__turf_helpers__ = __webpack_require__(197);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__turf_helpers___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__turf_helpers__);


/**
 * Callback for coordEach
 *
 * @callback coordEachCallback
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 */

/**
 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
 *
 * @name coordEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 * });
 */
function coordEach(geojson, callback, excludeWrapCoord) {
    // Handles null Geometry -- Skips this GeoJSON
    if (geojson === null) return;
    var j, k, l, geometry, stopG, coords,
        geometryMaybeCollection,
        wrapShrink = 0,
        coordIndex = 0,
        isGeometryCollection,
        type = geojson.type,
        isFeatureCollection = type === 'FeatureCollection',
        isFeature = type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :
            (isFeature ? geojson.geometry : geojson));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
            var multiFeatureIndex = 0;
            var geometryIndex = 0;
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;

            // Handles null Geometry -- Skips this geometry
            if (geometry === null) continue;
            coords = geometry.coordinates;
            var geomType = geometry.type;

            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;

            switch (geomType) {
            case null:
                break;
            case 'Point':
                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                coordIndex++;
                multiFeatureIndex++;
                break;
            case 'LineString':
            case 'MultiPoint':
                for (j = 0; j < coords.length; j++) {
                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                    coordIndex++;
                    if (geomType === 'MultiPoint') multiFeatureIndex++;
                }
                if (geomType === 'LineString') multiFeatureIndex++;
                break;
            case 'Polygon':
            case 'MultiLineString':
                for (j = 0; j < coords.length; j++) {
                    for (k = 0; k < coords[j].length - wrapShrink; k++) {
                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                        coordIndex++;
                    }
                    if (geomType === 'MultiLineString') multiFeatureIndex++;
                    if (geomType === 'Polygon') geometryIndex++;
                }
                if (geomType === 'Polygon') multiFeatureIndex++;
                break;
            case 'MultiPolygon':
                for (j = 0; j < coords.length; j++) {
                    if (geomType === 'MultiPolygon') geometryIndex = 0;
                    for (k = 0; k < coords[j].length; k++) {
                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                            coordIndex++;
                        }
                        geometryIndex++;
                    }
                    multiFeatureIndex++;
                }
                break;
            case 'GeometryCollection':
                for (j = 0; j < geometry.geometries.length; j++)
                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;
                break;
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
    }
}

/**
 * Callback for coordReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback coordReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 */

/**
 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
 *
 * @name coordReduce
 * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=previousValue
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   return currentCoord;
 * });
 */
function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
    var previousValue = initialValue;
    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;
        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
    }, excludeWrapCoord);
    return previousValue;
}

/**
 * Callback for propEach
 *
 * @callback propEachCallback
 * @param {Object} currentProperties The current Properties being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
 *
 * @name propEach
 * @param {FeatureCollection|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentProperties, featureIndex)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propEach(features, function (currentProperties, featureIndex) {
 *   //=currentProperties
 *   //=featureIndex
 * });
 */
function propEach(geojson, callback) {
    var i;
    switch (geojson.type) {
    case 'FeatureCollection':
        for (i = 0; i < geojson.features.length; i++) {
            if (callback(geojson.features[i].properties, i) === false) break;
        }
        break;
    case 'Feature':
        callback(geojson.properties, 0);
        break;
    }
}


/**
 * Callback for propReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback propReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {*} currentProperties The current Properties being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @name propReduce
 * @param {FeatureCollection|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
 *   //=previousValue
 *   //=currentProperties
 *   //=featureIndex
 *   return currentProperties
 * });
 */
function propReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    propEach(geojson, function (currentProperties, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;
        else previousValue = callback(previousValue, currentProperties, featureIndex);
    });
    return previousValue;
}

/**
 * Callback for featureEach
 *
 * @callback featureEachCallback
 * @param {Feature<any>} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Iterate over features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name featureEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.featureEach(features, function (currentFeature, featureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 * });
 */
function featureEach(geojson, callback) {
    if (geojson.type === 'Feature') {
        callback(geojson, 0);
    } else if (geojson.type === 'FeatureCollection') {
        for (var i = 0; i < geojson.features.length; i++) {
            if (callback(geojson.features[i], i) === false) break;
        }
    }
}

/**
 * Callback for featureReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback featureReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name featureReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   return currentFeature
 * });
 */
function featureReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    featureEach(geojson, function (currentFeature, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex);
    });
    return previousValue;
}

/**
 * Get all coordinates from any GeoJSON object.
 *
 * @name coordAll
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @returns {Array<Array<number>>} coordinate position array
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * var coords = turf.coordAll(features);
 * //= [[26, 37], [36, 53]]
 */
function coordAll(geojson) {
    var coords = [];
    coordEach(geojson, function (coord) {
        coords.push(coord);
    });
    return coords;
}

/**
 * Callback for geomEach
 *
 * @callback geomEachCallback
 * @param {Geometry} currentGeometry The current Geometry being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {Object} featureProperties The current Feature Properties being processed.
 * @param {Array<number>} featureBBox The current Feature BBox being processed.
 * @param {number|string} featureId The current Feature Id being processed.
 */

/**
 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
 *
 * @name geomEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
 *   //=currentGeometry
 *   //=featureIndex
 *   //=featureProperties
 *   //=featureBBox
 *   //=featureId
 * });
 */
function geomEach(geojson, callback) {
    var i, j, g, geometry, stopG,
        geometryMaybeCollection,
        isGeometryCollection,
        featureProperties,
        featureBBox,
        featureId,
        featureIndex = 0,
        isFeatureCollection = geojson.type === 'FeatureCollection',
        isFeature = geojson.type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (i = 0; i < stop; i++) {

        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :
            (isFeature ? geojson.geometry : geojson));
        featureProperties = (isFeatureCollection ? geojson.features[i].properties :
            (isFeature ? geojson.properties : {}));
        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :
            (isFeature ? geojson.bbox : undefined));
        featureId = (isFeatureCollection ? geojson.features[i].id :
            (isFeature ? geojson.id : undefined));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;

            // Handle null Geometry
            if (geometry === null) {
                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
                continue;
            }
            switch (geometry.type) {
            case 'Point':
            case 'LineString':
            case 'MultiPoint':
            case 'Polygon':
            case 'MultiLineString':
            case 'MultiPolygon': {
                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
                break;
            }
            case 'GeometryCollection': {
                for (j = 0; j < geometry.geometries.length; j++) {
                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;
                }
                break;
            }
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
        // Only increase `featureIndex` per each feature
        featureIndex++;
    }
}

/**
 * Callback for geomReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback geomReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Geometry} currentGeometry The current Geometry being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {Object} featureProperties The current Feature Properties being processed.
 * @param {Array<number>} featureBBox The current Feature BBox being processed.
 * @param {number|string} featureId The current Feature Id being processed.
 */

/**
 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
 *
 * @name geomReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
 *   //=previousValue
 *   //=currentGeometry
 *   //=featureIndex
 *   //=featureProperties
 *   //=featureBBox
 *   //=featureId
 *   return currentGeometry
 * });
 */
function geomReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;
        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);
    });
    return previousValue;
}

/**
 * Callback for flattenEach
 *
 * @callback flattenEachCallback
 * @param {Feature} currentFeature The current flattened feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 */

/**
 * Iterate over flattened features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name flattenEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 *   //=multiFeatureIndex
 * });
 */
function flattenEach(geojson, callback) {
    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {
        // Callback for single geometry
        var type = (geometry === null) ? null : geometry.type;
        switch (type) {
        case null:
        case 'Point':
        case 'LineString':
        case 'Polygon':
            if (callback(Object(__WEBPACK_IMPORTED_MODULE_0__turf_helpers__["feature"])(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;
            return;
        }

        var geomType;

        // Callback for multi-geometry
        switch (type) {
        case 'MultiPoint':
            geomType = 'Point';
            break;
        case 'MultiLineString':
            geomType = 'LineString';
            break;
        case 'MultiPolygon':
            geomType = 'Polygon';
            break;
        }

        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
            var coordinate = geometry.coordinates[multiFeatureIndex];
            var geom = {
                type: geomType,
                coordinates: coordinate
            };
            if (callback(Object(__WEBPACK_IMPORTED_MODULE_0__turf_helpers__["feature"])(geom, properties), featureIndex, multiFeatureIndex) === false) return false;
        }
    });
}

/**
 * Callback for flattenReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback flattenReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 */

/**
 * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
 *
 * @name flattenReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   return currentFeature
 * });
 */
function flattenReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {
        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);
    });
    return previousValue;
}

/**
 * Callback for segmentEach
 *
 * @callback segmentEachCallback
 * @param {Feature<LineString>} currentSegment The current Segment being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 * @param {number} segmentIndex The current index of the Segment being processed.
 * @returns {void}
 */

/**
 * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
 * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
 *   //=currentSegment
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   //=segmentIndex
 * });
 *
 * // Calculate the total number of segments
 * var total = 0;
 * turf.segmentEach(polygon, function () {
 *     total++;
 * });
 */
function segmentEach(geojson, callback) {
    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
        var segmentIndex = 0;

        // Exclude null Geometries
        if (!feature.geometry) return;
        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
        var type = feature.geometry.type;
        if (type === 'Point' || type === 'MultiPoint') return;

        // Generate 2-vertex line segments
        var previousCoords;
        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {
            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`
            if (previousCoords === undefined) {
                previousCoords = currentCoord;
                return;
            }
            var currentSegment = Object(__WEBPACK_IMPORTED_MODULE_0__turf_helpers__["lineString"])([previousCoords, currentCoord], feature.properties);
            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;
            segmentIndex++;
            previousCoords = currentCoord;
        }) === false) return false;
    });
}

/**
 * Callback for segmentReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback segmentReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentSegment The current Segment being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 * @param {number} segmentIndex The current index of the Segment being processed.
 */

/**
 * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
 * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
 *   //= previousSegment
 *   //= currentSegment
 *   //= featureIndex
 *   //= multiFeatureIndex
 *   //= geometryIndex
 *   //= segmentInex
 *   return currentSegment
 * });
 *
 * // Calculate the total number of segments
 * var initialValue = 0
 * var total = turf.segmentReduce(polygon, function (previousValue) {
 *     previousValue++;
 *     return previousValue;
 * }, initialValue);
 */
function segmentReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    var started = false;
    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
        if (started === false && initialValue === undefined) previousValue = currentSegment;
        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);
        started = true;
    });
    return previousValue;
}

/**
 * Callback for lineEach
 *
 * @callback lineEachCallback
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed
 * @param {number} featureIndex The current index of the Feature being processed
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
 * @param {number} geometryIndex The current index of the Geometry being processed
 */

/**
 * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
 * similar to Array.forEach.
 *
 * @name lineEach
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)
 * @example
 * var multiLine = turf.multiLineString([
 *   [[26, 37], [35, 45]],
 *   [[36, 53], [38, 50], [41, 55]]
 * ]);
 *
 * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=currentLine
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 * });
 */
function lineEach(geojson, callback) {
    // validation
    if (!geojson) throw new Error('geojson is required');

    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
        if (feature.geometry === null) return;
        var type = feature.geometry.type;
        var coords = feature.geometry.coordinates;
        switch (type) {
        case 'LineString':
            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;
            break;
        case 'Polygon':
            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
                if (callback(Object(__WEBPACK_IMPORTED_MODULE_0__turf_helpers__["lineString"])(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
            }
            break;
        }
    });
}

/**
 * Callback for lineReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback lineReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} featureIndex The current index of the Feature being processed
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
 * @param {number} geometryIndex The current index of the Geometry being processed
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name lineReduce
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var multiPoly = turf.multiPolygon([
 *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
 *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
 * ]);
 *
 * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=previousValue
 *   //=currentLine
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   return currentLine
 * });
 */
function lineReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;
        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);
    });
    return previousValue;
}

/**
 * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.
 *
 * Negative indexes are permitted.
 * Point & MultiPoint will always return null.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.featureIndex=0] Feature Index
 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
 * @param {number} [options.geometryIndex=0] Geometry Index
 * @param {number} [options.segmentIndex=0] Segment Index
 * @param {Object} [options.properties={}] Translate Properties to output LineString
 * @param {BBox} [options.bbox={}] Translate BBox to output LineString
 * @param {number|string} [options.id={}] Translate Id to output LineString
 * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString
 * @example
 * var multiLine = turf.multiLineString([
 *     [[10, 10], [50, 30], [30, 40]],
 *     [[-10, -10], [-50, -30], [-30, -40]]
 * ]);
 *
 * // First Segment (defaults are 0)
 * turf.findSegment(multiLine);
 * // => Feature<LineString<[[10, 10], [50, 30]]>>
 *
 * // First Segment of 2nd Multi Feature
 * turf.findSegment(multiLine, {multiFeatureIndex: 1});
 * // => Feature<LineString<[[-10, -10], [-50, -30]]>>
 *
 * // Last Segment of Last Multi Feature
 * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});
 * // => Feature<LineString<[[-50, -30], [-30, -40]]>>
 */
function findSegment(geojson, options) {
    // Optional Parameters
    options = options || {};
    if (!Object(__WEBPACK_IMPORTED_MODULE_0__turf_helpers__["isObject"])(options)) throw new Error('options is invalid');
    var featureIndex = options.featureIndex || 0;
    var multiFeatureIndex = options.multiFeatureIndex || 0;
    var geometryIndex = options.geometryIndex || 0;
    var segmentIndex = options.segmentIndex || 0;

    // Find FeatureIndex
    var properties = options.properties;
    var geometry;

    switch (geojson.type) {
    case 'FeatureCollection':
        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
        properties = properties || geojson.features[featureIndex].properties;
        geometry = geojson.features[featureIndex].geometry;
        break;
    case 'Feature':
        properties = properties || geojson.properties;
        geometry = geojson.geometry;
        break;
    case 'Point':
    case 'MultiPoint':
        return null;
    case 'LineString':
    case 'Polygon':
    case 'MultiLineString':
    case 'MultiPolygon':
        geometry = geojson;
        break;
    default:
        throw new Error('geojson is invalid');
    }

    // Find SegmentIndex
    if (geometry === null) return null;
    var coords = geometry.coordinates;
    switch (geometry.type) {
    case 'Point':
    case 'MultiPoint':
        return null;
    case 'LineString':
        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;
        return Object(__WEBPACK_IMPORTED_MODULE_0__turf_helpers__["lineString"])([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);
    case 'Polygon':
        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
        return Object(__WEBPACK_IMPORTED_MODULE_0__turf_helpers__["lineString"])([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);
    case 'MultiLineString':
        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
        return Object(__WEBPACK_IMPORTED_MODULE_0__turf_helpers__["lineString"])([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);
    case 'MultiPolygon':
        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
        return Object(__WEBPACK_IMPORTED_MODULE_0__turf_helpers__["lineString"])([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);
    }
    throw new Error('geojson is invalid');
}

/**
 * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.
 *
 * Negative indexes are permitted.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.featureIndex=0] Feature Index
 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
 * @param {number} [options.geometryIndex=0] Geometry Index
 * @param {number} [options.coordIndex=0] Coord Index
 * @param {Object} [options.properties={}] Translate Properties to output Point
 * @param {BBox} [options.bbox={}] Translate BBox to output Point
 * @param {number|string} [options.id={}] Translate Id to output Point
 * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point
 * @example
 * var multiLine = turf.multiLineString([
 *     [[10, 10], [50, 30], [30, 40]],
 *     [[-10, -10], [-50, -30], [-30, -40]]
 * ]);
 *
 * // First Segment (defaults are 0)
 * turf.findPoint(multiLine);
 * // => Feature<Point<[10, 10]>>
 *
 * // First Segment of the 2nd Multi-Feature
 * turf.findPoint(multiLine, {multiFeatureIndex: 1});
 * // => Feature<Point<[-10, -10]>>
 *
 * // Last Segment of last Multi-Feature
 * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});
 * // => Feature<Point<[-30, -40]>>
 */
function findPoint(geojson, options) {
    // Optional Parameters
    options = options || {};
    if (!Object(__WEBPACK_IMPORTED_MODULE_0__turf_helpers__["isObject"])(options)) throw new Error('options is invalid');
    var featureIndex = options.featureIndex || 0;
    var multiFeatureIndex = options.multiFeatureIndex || 0;
    var geometryIndex = options.geometryIndex || 0;
    var coordIndex = options.coordIndex || 0;

    // Find FeatureIndex
    var properties = options.properties;
    var geometry;

    switch (geojson.type) {
    case 'FeatureCollection':
        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
        properties = properties || geojson.features[featureIndex].properties;
        geometry = geojson.features[featureIndex].geometry;
        break;
    case 'Feature':
        properties = properties || geojson.properties;
        geometry = geojson.geometry;
        break;
    case 'Point':
    case 'MultiPoint':
        return null;
    case 'LineString':
    case 'Polygon':
    case 'MultiLineString':
    case 'MultiPolygon':
        geometry = geojson;
        break;
    default:
        throw new Error('geojson is invalid');
    }

    // Find Coord Index
    if (geometry === null) return null;
    var coords = geometry.coordinates;
    switch (geometry.type) {
    case 'Point':
        return Object(__WEBPACK_IMPORTED_MODULE_0__turf_helpers__["point"])(coords, properties, options);
    case 'MultiPoint':
        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
        return Object(__WEBPACK_IMPORTED_MODULE_0__turf_helpers__["point"])(coords[multiFeatureIndex], properties, options);
    case 'LineString':
        if (coordIndex < 0) coordIndex = coords.length + coordIndex;
        return Object(__WEBPACK_IMPORTED_MODULE_0__turf_helpers__["point"])(coords[coordIndex], properties, options);
    case 'Polygon':
        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;
        return Object(__WEBPACK_IMPORTED_MODULE_0__turf_helpers__["point"])(coords[geometryIndex][coordIndex], properties, options);
    case 'MultiLineString':
        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;
        return Object(__WEBPACK_IMPORTED_MODULE_0__turf_helpers__["point"])(coords[multiFeatureIndex][coordIndex], properties, options);
    case 'MultiPolygon':
        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
        return Object(__WEBPACK_IMPORTED_MODULE_0__turf_helpers__["point"])(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);
    }
    throw new Error('geojson is invalid');
}


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module helpers
 */
/**
 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
 *
 * @memberof helpers
 * @type {number}
 */
exports.earthRadius = 6371008.8;
/**
 * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
 *
 * @memberof helpers
 * @type {Object}
 */
exports.factors = {
    centimeters: exports.earthRadius * 100,
    centimetres: exports.earthRadius * 100,
    degrees: exports.earthRadius / 111325,
    feet: exports.earthRadius * 3.28084,
    inches: exports.earthRadius * 39.370,
    kilometers: exports.earthRadius / 1000,
    kilometres: exports.earthRadius / 1000,
    meters: exports.earthRadius,
    metres: exports.earthRadius,
    miles: exports.earthRadius / 1609.344,
    millimeters: exports.earthRadius * 1000,
    millimetres: exports.earthRadius * 1000,
    nauticalmiles: exports.earthRadius / 1852,
    radians: 1,
    yards: exports.earthRadius / 1.0936,
};
/**
 * Units of measurement factors based on 1 meter.
 *
 * @memberof helpers
 * @type {Object}
 */
exports.unitsFactors = {
    centimeters: 100,
    centimetres: 100,
    degrees: 1 / 111325,
    feet: 3.28084,
    inches: 39.370,
    kilometers: 1 / 1000,
    kilometres: 1 / 1000,
    meters: 1,
    metres: 1,
    miles: 1 / 1609.344,
    millimeters: 1000,
    millimetres: 1000,
    nauticalmiles: 1 / 1852,
    radians: 1 / exports.earthRadius,
    yards: 1 / 1.0936,
};
/**
 * Area of measurement factors based on 1 square meter.
 *
 * @memberof helpers
 * @type {Object}
 */
exports.areaFactors = {
    acres: 0.000247105,
    centimeters: 10000,
    centimetres: 10000,
    feet: 10.763910417,
    inches: 1550.003100006,
    kilometers: 0.000001,
    kilometres: 0.000001,
    meters: 1,
    metres: 1,
    miles: 3.86e-7,
    millimeters: 1000000,
    millimetres: 1000000,
    yards: 1.195990046,
};
/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature} a GeoJSON Feature
 * @example
 * var geometry = {
 *   "type": "Point",
 *   "coordinates": [110, 50]
 * };
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */
function feature(geom, properties, options) {
    if (options === void 0) { options = {}; }
    var feat = { type: "Feature" };
    if (options.id === 0 || options.id) {
        feat.id = options.id;
    }
    if (options.bbox) {
        feat.bbox = options.bbox;
    }
    feat.properties = properties || {};
    feat.geometry = geom;
    return feat;
}
exports.feature = feature;
/**
 * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
 * For GeometryCollection type use `helpers.geometryCollection`
 *
 * @name geometry
 * @param {string} type Geometry Type
 * @param {Array<any>} coordinates Coordinates
 * @param {Object} [options={}] Optional Parameters
 * @returns {Geometry} a GeoJSON Geometry
 * @example
 * var type = "Point";
 * var coordinates = [110, 50];
 * var geometry = turf.geometry(type, coordinates);
 * // => geometry
 */
function geometry(type, coordinates, options) {
    if (options === void 0) { options = {}; }
    switch (type) {
        case "Point": return point(coordinates).geometry;
        case "LineString": return lineString(coordinates).geometry;
        case "Polygon": return polygon(coordinates).geometry;
        case "MultiPoint": return multiPoint(coordinates).geometry;
        case "MultiLineString": return multiLineString(coordinates).geometry;
        case "MultiPolygon": return multiPolygon(coordinates).geometry;
        default: throw new Error(type + " is invalid");
    }
}
exports.geometry = geometry;
/**
 * Creates a {@link Point} {@link Feature} from a Position.
 *
 * @name point
 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Point>} a Point feature
 * @example
 * var point = turf.point([-75.343, 39.984]);
 *
 * //=point
 */
function point(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "Point",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.point = point;
/**
 * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.
 *
 * @name points
 * @param {Array<Array<number>>} coordinates an array of Points
 * @param {Object} [properties={}] Translate these properties to each Feature
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
 * associated with the FeatureCollection
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<Point>} Point Feature
 * @example
 * var points = turf.points([
 *   [-75, 39],
 *   [-80, 45],
 *   [-78, 50]
 * ]);
 *
 * //=points
 */
function points(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    return featureCollection(coordinates.map(function (coords) {
        return point(coords, properties);
    }), options);
}
exports.points = points;
/**
 * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Polygon>} Polygon Feature
 * @example
 * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
 *
 * //=polygon
 */
function polygon(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
        var ring = coordinates_1[_i];
        if (ring.length < 4) {
            throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
            // Check if first point of Polygon contains two numbers
            if (ring[ring.length - 1][j] !== ring[0][j]) {
                throw new Error("First and last Position are not equivalent.");
            }
        }
    }
    var geom = {
        type: "Polygon",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.polygon = polygon;
/**
 * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.
 *
 * @name polygons
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection
 * @example
 * var polygons = turf.polygons([
 *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],
 *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],
 * ]);
 *
 * //=polygons
 */
function polygons(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    return featureCollection(coordinates.map(function (coords) {
        return polygon(coords, properties);
    }), options);
}
exports.polygons = polygons;
/**
 * Creates a {@link LineString} {@link Feature} from an Array of Positions.
 *
 * @name lineString
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<LineString>} LineString Feature
 * @example
 * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});
 * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});
 *
 * //=linestring1
 * //=linestring2
 */
function lineString(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    if (coordinates.length < 2) {
        throw new Error("coordinates must be an array of two or more positions");
    }
    var geom = {
        type: "LineString",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.lineString = lineString;
/**
 * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.
 *
 * @name lineStrings
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
 * associated with the FeatureCollection
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<LineString>} LineString FeatureCollection
 * @example
 * var linestrings = turf.lineStrings([
 *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],
 *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]
 * ]);
 *
 * //=linestrings
 */
function lineStrings(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    return featureCollection(coordinates.map(function (coords) {
        return lineString(coords, properties);
    }), options);
}
exports.lineStrings = lineStrings;
/**
 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
 *
 * @name featureCollection
 * @param {Feature[]} features input features
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {FeatureCollection} FeatureCollection of Features
 * @example
 * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});
 * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});
 * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});
 *
 * var collection = turf.featureCollection([
 *   locationA,
 *   locationB,
 *   locationC
 * ]);
 *
 * //=collection
 */
function featureCollection(features, options) {
    if (options === void 0) { options = {}; }
    var fc = { type: "FeatureCollection" };
    if (options.id) {
        fc.id = options.id;
    }
    if (options.bbox) {
        fc.bbox = options.bbox;
    }
    fc.features = features;
    return fc;
}
exports.featureCollection = featureCollection;
/**
 * Creates a {@link Feature<MultiLineString>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiLineString
 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiLineString>} a MultiLineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
 *
 * //=multiLine
 */
function multiLineString(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "MultiLineString",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.multiLineString = multiLineString;
/**
 * Creates a {@link Feature<MultiPoint>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPoint
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiPoint>} a MultiPoint feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
 *
 * //=multiPt
 */
function multiPoint(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "MultiPoint",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.multiPoint = multiPoint;
/**
 * Creates a {@link Feature<MultiPolygon>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPolygon
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiPolygon>} a multipolygon feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
 *
 * //=multiPoly
 *
 */
function multiPolygon(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "MultiPolygon",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.multiPolygon = multiPolygon;
/**
 * Creates a {@link Feature<GeometryCollection>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name geometryCollection
 * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
 * @example
 * var pt = turf.geometry("Point", [100, 0]);
 * var line = turf.geometry("LineString", [[101, 0], [102, 1]]);
 * var collection = turf.geometryCollection([pt, line]);
 *
 * // => collection
 */
function geometryCollection(geometries, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "GeometryCollection",
        geometries: geometries,
    };
    return feature(geom, properties, options);
}
exports.geometryCollection = geometryCollection;
/**
 * Round number to precision
 *
 * @param {number} num Number
 * @param {number} [precision=0] Precision
 * @returns {number} rounded number
 * @example
 * turf.round(120.4321)
 * //=120
 *
 * turf.round(120.4321, 2)
 * //=120.43
 */
function round(num, precision) {
    if (precision === void 0) { precision = 0; }
    if (precision && !(precision >= 0)) {
        throw new Error("precision must be a positive number");
    }
    var multiplier = Math.pow(10, precision || 0);
    return Math.round(num * multiplier) / multiplier;
}
exports.round = round;
/**
 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name radiansToLength
 * @param {number} radians in radians across the sphere
 * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} distance
 */
function radiansToLength(radians, units) {
    if (units === void 0) { units = "kilometers"; }
    var factor = exports.factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return radians * factor;
}
exports.radiansToLength = radiansToLength;
/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name lengthToRadians
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} radians
 */
function lengthToRadians(distance, units) {
    if (units === void 0) { units = "kilometers"; }
    var factor = exports.factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return distance / factor;
}
exports.lengthToRadians = lengthToRadians;
/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
 *
 * @name lengthToDegrees
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} degrees
 */
function lengthToDegrees(distance, units) {
    return radiansToDegrees(lengthToRadians(distance, units));
}
exports.lengthToDegrees = lengthToDegrees;
/**
 * Converts any bearing angle from the north line direction (positive clockwise)
 * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
 *
 * @name bearingToAzimuth
 * @param {number} bearing angle, between -180 and +180 degrees
 * @returns {number} angle between 0 and 360 degrees
 */
function bearingToAzimuth(bearing) {
    var angle = bearing % 360;
    if (angle < 0) {
        angle += 360;
    }
    return angle;
}
exports.bearingToAzimuth = bearingToAzimuth;
/**
 * Converts an angle in radians to degrees
 *
 * @name radiansToDegrees
 * @param {number} radians angle in radians
 * @returns {number} degrees between 0 and 360 degrees
 */
function radiansToDegrees(radians) {
    var degrees = radians % (2 * Math.PI);
    return degrees * 180 / Math.PI;
}
exports.radiansToDegrees = radiansToDegrees;
/**
 * Converts an angle in degrees to radians
 *
 * @name degreesToRadians
 * @param {number} degrees angle between 0 and 360 degrees
 * @returns {number} angle in radians
 */
function degreesToRadians(degrees) {
    var radians = degrees % 360;
    return radians * Math.PI / 180;
}
exports.degreesToRadians = degreesToRadians;
/**
 * Converts a length to the requested unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @param {number} length to be converted
 * @param {Units} [originalUnit="kilometers"] of the length
 * @param {Units} [finalUnit="kilometers"] returned unit
 * @returns {number} the converted length
 */
function convertLength(length, originalUnit, finalUnit) {
    if (originalUnit === void 0) { originalUnit = "kilometers"; }
    if (finalUnit === void 0) { finalUnit = "kilometers"; }
    if (!(length >= 0)) {
        throw new Error("length must be a positive number");
    }
    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);
}
exports.convertLength = convertLength;
/**
 * Converts a area to the requested unit.
 * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches
 * @param {number} area to be converted
 * @param {Units} [originalUnit="meters"] of the distance
 * @param {Units} [finalUnit="kilometers"] returned unit
 * @returns {number} the converted distance
 */
function convertArea(area, originalUnit, finalUnit) {
    if (originalUnit === void 0) { originalUnit = "meters"; }
    if (finalUnit === void 0) { finalUnit = "kilometers"; }
    if (!(area >= 0)) {
        throw new Error("area must be a positive number");
    }
    var startFactor = exports.areaFactors[originalUnit];
    if (!startFactor) {
        throw new Error("invalid original units");
    }
    var finalFactor = exports.areaFactors[finalUnit];
    if (!finalFactor) {
        throw new Error("invalid final units");
    }
    return (area / startFactor) * finalFactor;
}
exports.convertArea = convertArea;
/**
 * isNumber
 *
 * @param {*} num Number to validate
 * @returns {boolean} true/false
 * @example
 * turf.isNumber(123)
 * //=true
 * turf.isNumber('foo')
 * //=false
 */
function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num);
}
exports.isNumber = isNumber;
/**
 * isObject
 *
 * @param {*} input variable to validate
 * @returns {boolean} true/false
 * @example
 * turf.isObject({elevation: 10})
 * //=true
 * turf.isObject('foo')
 * //=false
 */
function isObject(input) {
    return (!!input) && (input.constructor === Object);
}
exports.isObject = isObject;
/**
 * Validate BBox
 *
 * @private
 * @param {Array<number>} bbox BBox to validate
 * @returns {void}
 * @throws Error if BBox is not valid
 * @example
 * validateBBox([-180, -40, 110, 50])
 * //=OK
 * validateBBox([-180, -40])
 * //=Error
 * validateBBox('Foo')
 * //=Error
 * validateBBox(5)
 * //=Error
 * validateBBox(null)
 * //=Error
 * validateBBox(undefined)
 * //=Error
 */
function validateBBox(bbox) {
    if (!bbox) {
        throw new Error("bbox is required");
    }
    if (!Array.isArray(bbox)) {
        throw new Error("bbox must be an Array");
    }
    if (bbox.length !== 4 && bbox.length !== 6) {
        throw new Error("bbox must be an Array of 4 or 6 numbers");
    }
    bbox.forEach(function (num) {
        if (!isNumber(num)) {
            throw new Error("bbox must only contain numbers");
        }
    });
}
exports.validateBBox = validateBBox;
/**
 * Validate Id
 *
 * @private
 * @param {string|number} id Id to validate
 * @returns {void}
 * @throws Error if Id is not valid
 * @example
 * validateId([-180, -40, 110, 50])
 * //=Error
 * validateId([-180, -40])
 * //=Error
 * validateId('Foo')
 * //=OK
 * validateId(5)
 * //=OK
 * validateId(null)
 * //=Error
 * validateId(undefined)
 * //=Error
 */
function validateId(id) {
    if (!id) {
        throw new Error("id is required");
    }
    if (["string", "number"].indexOf(typeof id) === -1) {
        throw new Error("id must be a number or a string");
    }
}
exports.validateId = validateId;
// Deprecated methods
function radians2degrees() {
    throw new Error("method has been renamed to `radiansToDegrees`");
}
exports.radians2degrees = radians2degrees;
function degrees2radians() {
    throw new Error("method has been renamed to `degreesToRadians`");
}
exports.degrees2radians = degrees2radians;
function distanceToDegrees() {
    throw new Error("method has been renamed to `lengthToDegrees`");
}
exports.distanceToDegrees = distanceToDegrees;
function distanceToRadians() {
    throw new Error("method has been renamed to `lengthToRadians`");
}
exports.distanceToRadians = distanceToRadians;
function radiansToDistance() {
    throw new Error("method has been renamed to `radiansToLength`");
}
exports.radiansToDistance = radiansToDistance;
function bearingToAngle() {
    throw new Error("method has been renamed to `bearingToAzimuth`");
}
exports.bearingToAngle = bearingToAngle;
function convertDistance() {
    throw new Error("method has been renamed to `convertLength`");
}
exports.convertDistance = convertDistance;


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.heatMapKeyAccessor = heatMapKeyAccessor;
exports.heatMapValueAccesor = heatMapValueAccesor;
exports.heatMapRowsLabel = heatMapRowsLabel;
exports.heatMapColsLabel = heatMapColsLabel;
exports.isDescendingAppropriateData = isDescendingAppropriateData;
exports.default = heatMap;

var _formattingHelpers = __webpack_require__(6);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _baseMixin = __webpack_require__(5);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

var _colorMixin = __webpack_require__(7);

var _colorMixin2 = _interopRequireDefault(_colorMixin);

var _marginMixin = __webpack_require__(12);

var _marginMixin2 = _interopRequireDefault(_marginMixin);

var _events = __webpack_require__(9);

var _core = __webpack_require__(2);

var _utils = __webpack_require__(3);

var _filters = __webpack_require__(13);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** ***************************************************************************
 * OVERRIDE: dc.heatMap                                                       *
 * ***************************************************************************/
/**
 * A heat map is matrix that represents the values of two dimensions of data using colors.
 * @name heatMap
 * @memberof dc
 * @mixes dc.colorMixin
 * @mixes dc.marginMixin
 * @mixes dc.baseMixin
 * @example
 * // create a heat map under #chart-container1 element using the default global chart group
 * var heatMap1 = dc.heatMap('#chart-container1');
 * // create a heat map under #chart-container2 element using chart group A
 * var heatMap2 = dc.heatMap('#chart-container2', 'chartGroupA');
 * @param {String|node|d3.selection} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector} specifying
 * a dom block element such as a div; or a dom element or d3 selection.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
 * Interaction with a chart will only trigger events and redraws within the chart's group.
 * @return {dc.heatMap}
 */

var MAX_LABEL_WIDTH = 72;
var CHAR_WIDTH = 5;
var MIN_AXIS_HEIGHT = 52;

function heatMapKeyAccessor(_ref) {
  var key0 = _ref.key0;

  if (Array.isArray(key0)) {
    var value = (0, _formattingHelpers.isArrayOfObjects)(key0) ? key0[0].value : key0[0];
    this.colsMap.set(value, key0);
    return value;
  } else {
    return key0;
  }
}

function heatMapValueAccesor(_ref2) {
  var key1 = _ref2.key1;

  if (Array.isArray(key1)) {
    var value = (0, _formattingHelpers.isArrayOfObjects)(key1) ? key1[0].value : key1[0];
    this.rowsMap.set(value, key1);
    return value;
  } else {
    return key1;
  }
}

function heatMapRowsLabel(d) {
  var value = this.rowsMap.get(d) || d;

  var customFormatter = this.dateFormatter();
  if (customFormatter && d && d instanceof Date) {
    if (Array.isArray(value) && value[0]) {
      value = value[0].value || value[0];
    }
  }

  return customFormatter && customFormatter(value, this.yAxisLabel()) || (0, _formattingHelpers.formatDataValue)(value);
}

function heatMapColsLabel(d) {
  var value = this.colsMap.get(d) || d;

  var customFormatter = this.dateFormatter();
  if (customFormatter && d && d instanceof Date) {
    if (Array.isArray(value) && value[0]) {
      value = value[0].value || value[0];
    }
  }

  return customFormatter && customFormatter(value, this.xAxisLabel()) || (0, _formattingHelpers.formatDataValue)(value);
}

function isDescendingAppropriateData(_ref3) {
  var key1 = _ref3.key1;

  var value = Array.isArray(key1) ? key1[0] : key1;
  return typeof value !== "number";
}

function heatMap(parent, chartGroup) {
  var INTERVAL_LABELS = {
    // ISO DOW starts at 1, set null at 0 index
    DAY_OF_WEEK: [null, "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],

    // Months start at 1, set null at 0 index
    MONTH: [null, "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],

    HOUR_OF_DAY: ["12AM", "1AM", "2AM", "3AM", "4AM", "5AM", "6AM", "7AM", "8AM", "9AM", "10AM", "11AM", "12PM", "1PM", "2PM", "3PM", "4PM", "5PM", "6PM", "7PM", "8PM", "9PM", "10PM", "11PM"]
  };

  var DEFAULT_BORDER_RADIUS = 6.75;

  var _chartBody = void 0;

  var _cols = void 0;
  var _rows = void 0;

  var _colOrdering = _utils.utils.nullsFirst(_d2.default.ascending);
  var _rowOrdering = _utils.utils.nullsFirst(_d2.default.ascending);
  var _colScale = _d2.default.scale.ordinal();
  var _rowScale = _d2.default.scale.ordinal();

  var _xBorderRadius = DEFAULT_BORDER_RADIUS;
  var _yBorderRadius = DEFAULT_BORDER_RADIUS;

  /* OVERRIDE EXTEND ----------------------------------------------------------*/
  var _yLabel = void 0;
  var _xLabel = void 0;
  var _hasBeenRendered = false;
  var _minBoxSize = 16;
  var _scrollPos = { top: null, left: 0 };
  var _dockedAxes = void 0;
  var _dockedAxesSize = { left: 48, bottom: 56
    /* --------------------------------------------------------------------------*/

  };var _xBorderRadius = DEFAULT_BORDER_RADIUS;
  var _yBorderRadius = DEFAULT_BORDER_RADIUS;

  var _chart = (0, _colorMixin2.default)((0, _marginMixin2.default)((0, _baseMixin2.default)({})));
  _chart._mandatoryAttributes(["group"]);
  _chart.title(_chart.colorAccessor());

  var _colsLabel = function _colsLabel(d) {
    return d;
  };
  var _rowsLabel = function _rowsLabel(d) {
    return d;
  };

  _chart.dockedAxesSize = function (_) {
    if (!arguments.length) {
      return _dockedAxesSize;
    }
    _dockedAxesSize = _;
    return _chart;
  };

  /**
   * Set or get the column label function. The chart class uses this function to render
   * column labels on the X axis. It is passed the column name.
   * @name colsLabel
   * @memberof dc.heatMap
   * @instance
   * @example
   * // the default label function just returns the name
   * chart.colsLabel(function(d) { return d; });
   * @param  {Function} [labelFunction=function(d) { return d; }]
   * @return {Function}
   * @return {dc.heatMap}
   */
  _chart.colsLabel = function (labelFunction) {
    if (!arguments.length) {
      return _colsLabel;
    }
    _colsLabel = labelFunction;
    return _chart;
  };

  /**
   * Set or get the row label function. The chart class uses this function to render
   * row labels on the Y axis. It is passed the row name.
   * @name rowsLabel
   * @memberof dc.heatMap
   * @instance
   * @example
   * // the default label function just returns the name
   * chart.rowsLabel(function(d) { return d; });
   * @param  {Function} [labelFunction=function(d) { return d; }]
   * @return {Function}
   * @return {dc.heatMap}
   */
  _chart.rowsLabel = function (labelFunction) {
    if (!arguments.length) {
      return _rowsLabel;
    }
    _rowsLabel = labelFunction;
    return _chart;
  };

  /* OVERRIDE EXTEND ----------------------------------------------------------*/
  _chart.xAxisLabel = function (xLabel) {
    if (!arguments.length) {
      return _xLabel;
    }
    _xLabel = xLabel;
    return _chart;
  };

  _chart.yAxisLabel = function (yLabel) {
    if (!arguments.length) {
      return _yLabel;
    }
    _yLabel = yLabel;
    return _chart;
  };

  var _xAxisOnClick = function _xAxisOnClick(d) {
    filterAxis(0, d);
  };

  var _yAxisOnClick = function _yAxisOnClick(d) {
    filterAxis(1, d);
  };
  /* --------------------------------------------------------------------------*/

  var _boxOnClick = function _boxOnClick(d) {
    /* OVERRIDE -----------------------------------------------------------------*/
    var filter = [d.key0, d.key1];
    /* --------------------------------------------------------------------------*/
    _chart.handleFilterClick(_d2.default.event, filter);
  };

  function filterAxis(axis, value) {
    var cellsOnAxis = _chart.selectAll(".box-group").filter(function (d) {
      return (
        /* OVERRIDE ---------------------------------------------------------------*/
        (axis === 1 ? _chart.valueAccessor()(d) : _chart.keyAccessor()(d)) === value
      );
    }
    /* --------------------------------------------------------------------------*/
    );

    var unfilteredCellsOnAxis = cellsOnAxis.filter(function (d) {
      return (
        /* OVERRIDE -----------------------------------------------------------------*/
        !_chart.hasFilter([d.key0, d.key1])
      );
    }
    /* --------------------------------------------------------------------------*/
    );
    _events.events.trigger(function () {
      if (unfilteredCellsOnAxis.empty()) {
        cellsOnAxis.each(function (d) {
          /* OVERRIDE -----------------------------------------------------------------*/
          _chart.filter([d.key0, d.key1]);
          /* --------------------------------------------------------------------------*/
        });
      } else {
        unfilteredCellsOnAxis.each(function (d) {
          /* OVERRIDE -----------------------------------------------------------------*/
          _chart.filter([d.key0, d.key1]);
          /* --------------------------------------------------------------------------*/
        });
      }

      _chart.redrawGroup();
    });
  }

  (0, _core.override)(_chart, "filter", function (filter, isInverseFilter) {
    if (!arguments.length) {
      return _chart._filter();
    }

    return _chart._filter(_filters.filters.TwoDimensionalFilter(filter), isInverseFilter);
  });

  function uniq(d, i, a) {
    return !i || a[i - 1] !== d;
  }

  /**
   * Gets or sets the values used to create the rows of the heatmap, as an array. By default, all
   * the values will be fetched from the data using the value accessor, and they will be sorted in
   * ascending order.
   * @name rows
   * @memberof dc.heatMap
   * @instance
   * @param  {Array<String|Number>} [rows]
   * @return {Array<String|Number>}
   * @return {dc.heatMap}
   */
  _chart.rows = function (rows) {
    if (arguments.length) {
      _rows = rows;
      return _chart;
    }
    return _rows;
  };

  _chart.rowOrdering = function (_) {
    if (!arguments.length) {
      return _rowOrdering;
    }
    _rowOrdering = _;
    return _chart;
  };

  /**
   * Gets or sets the keys used to create the columns of the heatmap, as an array. By default, all
   * the values will be fetched from the data using the key accessor, and they will be sorted in
   * ascending order.
   * @name cols
   * @memberof dc.heatMap
   * @instance
   * @param  {Array<String|Number>} [cols]
   * @return {Array<String|Number>}
   * @return {dc.heatMap}
   */
  _chart.cols = function (cols) {
    if (arguments.length) {
      _cols = cols;
      return _chart;
    }
    return _cols;
  };

  _chart.colOrdering = function (_) {
    if (!arguments.length) {
      return _colOrdering;
    }
    _colOrdering = _;
    return _chart;
  };

  _chart._doRender = function () {
    _chart.resetSvg();

    /* OVERRIDE -----------------------------------------------------------------*/
    _chart.margins({ top: 8, right: 16, bottom: 0, left: 0 });
    /* --------------------------------------------------------------------------*/

    _chartBody = _chart.svg().append("g").attr("class", "heatmap").attr("transform", "translate(" + _chart.margins().left + "," + _chart.margins().top + ")");

    /* OVERRIDE -----------------------------------------------------------------*/
    _chartBody.append("g").attr("class", "box-wrapper");
    _hasBeenRendered = true;

    _dockedAxes = _chart.root().append("div").attr("class", "docked-axis-wrapper");
    /* --------------------------------------------------------------------------*/
    return _chart._doRedraw();
  };

  _chart._doRedraw = function () {
    if (!_hasBeenRendered) {
      return _chart._doRender();
    }

    var data = _chart.data(),
        cols = _chart.cols(),
        rows = _chart.rows() || data.map(_chart.valueAccessor()),
        cols = _chart.cols() || data.map(_chart.keyAccessor());

    if (_rowOrdering) {
      _rowOrdering = _chart.shouldSortYAxisDescending(data) ? _utils.utils.nullsLast(_d2.default.descending) : _utils.utils.nullsFirst(_d2.default.ascending);
      rows = rows.sort(_rowOrdering);
    }
    if (_colOrdering) {
      cols = cols.sort(_colOrdering);
    }
    rows = _rowScale.domain(rows);
    cols = _colScale.domain(cols);

    _chart.dockedAxesSize(_chart.getAxisSizes(cols.domain(), rows.domain()));

    var rowCount = rows.domain().length,
        colCount = cols.domain().length,
        availWidth = _chart.width() - _dockedAxesSize.left,
        availHeight = _chart.height() - _dockedAxesSize.bottom,
        boxWidth = Math.max((availWidth - _chart.margins().right) / colCount, _minBoxSize),
        boxHeight = Math.max((availHeight - _chart.margins().top) / rowCount, _minBoxSize),
        svgWidth = boxWidth * colCount + _chart.margins().right,
        svgHeight = boxHeight * rowCount + _chart.margins().top;

    cols.rangeBands([0, boxWidth * colCount]);
    rows.rangeBands([boxHeight * rowCount, 0]);

    _chart.svg().attr("width", svgWidth).attr("height", svgHeight);

    var scrollNode = _chart.root().classed("heatmap-scroll", true).select(".svg-wrapper").style("width", _chart.width() - _dockedAxesSize.left + "px").style("height", _chart.height() - _dockedAxesSize.bottom + "px").style("left", _dockedAxesSize.left + "px").on("scroll", function () {
      _scrollPos = {
        top: _d2.default.select(this).node().scrollTop,
        left: _d2.default.select(this).node().scrollLeft
      };
      _chart.root().select(".docked-x-axis").style("left", -_scrollPos.left + "px");
      _chart.root().select(".docked-y-axis").style("top", -_scrollPos.top + "px");
    }).node();

    scrollNode.scrollLeft = _scrollPos.left;
    scrollNode.scrollTop = _scrollPos.top === null && _rowOrdering === _d2.default.ascending ? svgHeight : _scrollPos.top || 0;

    var boxes = _chartBody.select(".box-wrapper").selectAll("g.box-group").data(_chart.data(), function (d, i) {
      return _chart.keyAccessor()(d, i) + "\0" + _chart.valueAccessor()(d, i);
    });

    var gEnter = boxes.enter().append("g").attr("class", "box-group");

    gEnter.append("rect").attr("class", "heat-box").attr("fill", "white").on("mouseenter", showPopup).on("mousemove", positionPopup).on("mouseleave", hidePopup).on("click", _chart.boxOnClick());

    (0, _core.transition)(boxes.select("rect"), _chart.transitionDuration()).attr("x", function (d, i) {
      return cols(_chart.keyAccessor()(d, i));
    }).attr("y", function (d, i) {
      return rows(_chart.valueAccessor()(d, i));
    }).attr("rx", _xBorderRadius).attr("ry", _yBorderRadius).attr("fill", _chart.getColor).attr("width", boxWidth).attr("height", boxHeight);

    boxes.exit().remove();

    var XAxis = _dockedAxes.selectAll(".docked-x-axis");

    if (XAxis.empty()) {
      XAxis = _dockedAxes.append("div").attr("class", "docked-x-axis");
    }

    var colsText = XAxis.style("height", _dockedAxesSize.bottom + "px").html("").selectAll("div.text").data(cols.domain());

    colsText.enter().append("div").attr("class", function () {
      return "text " + (_dockedAxesSize.bottom > 52 ? "rotate-down" : "center");
    }).style("left", function (d) {
      return cols(d) + boxWidth / 2 + _dockedAxesSize.left + "px";
    }).on("click", _chart.xAxisOnClick()).append("span").html(_chart.colsLabel()).attr("title", function (d) {
      // detect if a value is null or has the string "null"
      var val = "" + _chart.colsLabel()(d);
      return val.match(/null/gi) ? "NULL" : val;
    });

    var YAxis = _dockedAxes.selectAll(".docked-y-axis");

    if (YAxis.empty()) {
      YAxis = _dockedAxes.append("div").attr("class", "docked-y-axis");
    }

    var rowsText = YAxis.style("width", _dockedAxesSize.left + "px").style("left", _dockedAxesSize.left + "px").html("").selectAll("div.text").data(rows.domain());

    rowsText.enter().append("div").attr("class", "text").style("top", function (d) {
      return rows(d) + boxHeight / 2 + _chart.margins().top + "px";
    }).on("click", _chart.yAxisOnClick()).html(_chart.rowsLabel()).attr("title", function (d) {
      // detect if a value is null or has the string "null"
      var val = "" + _chart.rowsLabel()(d);
      return val.match(/null/gi) ? "NULL" : val;
    });

    var axesMask = _dockedAxes.selectAll(".axes-mask");

    if (axesMask.empty()) {
      axesMask = _dockedAxes.append("div").attr("class", "axes-mask");
    }

    axesMask.style("width", _dockedAxesSize.left + "px").style("height", _dockedAxesSize.bottom + "px");

    if (_chart.hasFilter()) {
      _chart.selectAll("g.box-group").each(function (d) {
        if (_chart.isSelectedNode(d)) {
          _chart.highlightSelected(this);
        } else {
          _chart.fadeDeselected(this);
        }
      });
    } else {
      _chart.selectAll("g.box-group").each(function () {
        _chart.resetHighlight(this);
      });
    }

    _chart.renderAxisLabels();

    return _chart;
  };

  /**
   * Gets or sets the handler that fires when an individual cell is clicked in the heatmap.
   * By default, filtering of the cell will be toggled.
   * @name boxOnClick
   * @memberof dc.heatMap
   * @instance
   * @example
   * // default box on click handler
   * chart.boxOnClick(function (d) {
   *     var filter = d.key;
   *     events.trigger(function () {
   *         _chart.filter(filter);
   *         _chart.redrawGroup();
   *     });
   * });
   * @param  {Function} [handler]
   * @return {Function}
   * @return {dc.heatMap}
   */
  _chart.boxOnClick = function (handler) {
    if (!arguments.length) {
      return _boxOnClick;
    }
    _boxOnClick = handler;
    return _chart;
  };

  /**
   * Gets or sets the handler that fires when a column tick is clicked in the x axis.
   * By default, if any cells in the column are unselected, the whole column will be selected,
   * otherwise the whole column will be unselected.
   * @name xAxisOnClick
   * @memberof dc.heatMap
   * @instance
   * @param  {Function} [handler]
   * @return {Function}
   * @return {dc.heatMap}
   */
  _chart.xAxisOnClick = function (handler) {
    if (!arguments.length) {
      return _xAxisOnClick;
    }
    _xAxisOnClick = handler;
    return _chart;
  };

  /**
   * Gets or sets the handler that fires when a row tick is clicked in the y axis.
   * By default, if any cells in the row are unselected, the whole row will be selected,
   * otherwise the whole row will be unselected.
   * @name yAxisOnClick
   * @memberof dc.heatMap
   * @instance
   * @param  {Function} [handler]
   * @return {Function}
   * @return {dc.heatMap}
   */
  _chart.yAxisOnClick = function (handler) {
    if (!arguments.length) {
      return _yAxisOnClick;
    }
    _yAxisOnClick = handler;
    return _chart;
  };

  /**
   * Gets or sets the X border radius.  Set to 0 to get full rectangles.
   * @name xBorderRadius
   * @memberof dc.heatMap
   * @instance
   * @param  {Number} [xBorderRadius=6.75]
   * @return {Number}
   * @return {dc.heatMap}
   */
  _chart.xBorderRadius = function (xBorderRadius) {
    if (!arguments.length) {
      return _xBorderRadius;
    }
    _xBorderRadius = xBorderRadius;
    return _chart;
  };

  /* OVERRIDE -----------------------------------------------------------------*/
  _chart.renderAxisLabels = function () {
    var root = _chart.root();

    var yLabel = root.selectAll(".y-axis-label");

    if (yLabel.empty()) {
      yLabel = root.append("div").attr("class", "y-axis-label").text(_yLabel);
    }

    yLabel.style("top", _chart.effectiveHeight() / 2 + _chart.margins().top + "px");

    _chart.prepareLabelEdit("y");

    var xLabel = root.selectAll(".x-axis-label");

    if (xLabel.empty()) {
      xLabel = root.append("div").attr("class", "x-axis-label").text(_xLabel);
    }

    xLabel.style("left", _chart.effectiveWidth() / 2 + _chart.margins().left + "px");

    _chart.prepareLabelEdit("x");
  };

  /* --------------------------------------------------------------------------*/

  /**
   * Gets or sets the Y border radius.  Set to 0 to get full rectangles.
   * @name yBorderRadius
   * @memberof dc.heatMap
   * @instance
   * @param  {Number} [yBorderRadius=6.75]
   * @return {Number}
   * @return {dc.heatMap}
   */
  _chart.yBorderRadius = function (yBorderRadius) {
    if (!arguments.length) {
      return _yBorderRadius;
    }
    _yBorderRadius = yBorderRadius;
    return _chart;
  };

  _chart.isSelectedNode = function (d) {
    /* OVERRIDE -----------------------------------------------------------------*/
    return _chart.hasFilter([d.key0, d.key1]) ^ _chart.filtersInverse();
    /* --------------------------------------------------------------------------*/
  };

  /* OVERRIDE ---------------------------------------------------------------- */
  function showPopup(d, i) {
    var popup = _chart.popup();

    var popupBox = popup.select(".chart-popup-content").html("").classed("popup-list", true);

    popupBox.append("div").attr("class", "popup-header").html(function () {
      return _colsLabel(_chart.keyAccessor()(d, i)) + " x " + _rowsLabel(_chart.valueAccessor()(d, i));
    });

    var popupItem = popupBox.append("div").attr("class", "popup-item");

    popupItem.append("div").attr("class", "popup-legend").style("background-color", _chart.getColor(d, i));

    popupItem.append("div").attr("class", "popup-item-value").html(function () {
      var customFormatter = _chart.valueFormatter();
      return customFormatter && customFormatter(d.color) || _utils.utils.formatValue(d.color);
    });

    popup.classed("js-showPopup", true);
  }

  function hidePopup() {
    _chart.popup().classed("js-showPopup", false);
  }

  function positionPopup() {
    var coordinates = [0, 0];
    coordinates = _chart.popupCoordinates(_d2.default.mouse(this));

    var scrollNode = _chart.root().select(".svg-wrapper").node();
    var x = coordinates[0] + _dockedAxesSize.left - scrollNode.scrollLeft;
    var y = coordinates[1] + _chart.margins().top - scrollNode.scrollTop;

    var popup = _chart.popup().attr("style", function () {
      return "transform:translate(" + x + "px," + y + "px)";
    });

    popup.select(".chart-popup-box").classed("align-right", function () {
      return x + _d2.default.select(this).node().getBoundingClientRect().width > _chart.width();
    });
  }
  /* ------------------------------------------------------------------------- */

  _chart.colsMap = new Map();
  _chart.rowsMap = new Map();
  _chart._axisPadding = { left: 36, bottom: 42 };

  var getMaxChars = function getMaxChars(domain, getLabel) {
    return domain.map(function (d) {
      return d === null ? "NULL" : d;
    }).map(function (d) {
      return getLabel(d) ? getLabel(d).toString().length : 0;
    }).reduce(function (prev, curr) {
      return Math.max(prev, curr);
    }, null);
  };

  _chart.getAxisSizes = function (colsDomain, rowsDomain) {
    return {
      left: Math.min(getMaxChars(rowsDomain, _chart.rowsLabel()) * CHAR_WIDTH, MAX_LABEL_WIDTH) + _chart._axisPadding.left,
      bottom: Math.max(Math.min(getMaxChars(colsDomain, _chart.colsLabel()) * CHAR_WIDTH, MAX_LABEL_WIDTH) + _chart._axisPadding.bottom, MIN_AXIS_HEIGHT)
    };
  };

  _chart.shouldSortYAxisDescending = function (data) {
    return data && data.length && isDescendingAppropriateData(data[0]);
  };

  _chart.keyAccessor(heatMapKeyAccessor.bind(_chart)).valueAccessor(heatMapValueAccesor.bind(_chart)).colorAccessor(function (d) {
    return d.value;
  }).rowsLabel(heatMapRowsLabel.bind(_chart)).colsLabel(heatMapColsLabel.bind(_chart));

  return _chart.anchor(parent, chartGroup);
}
/** ***************************************************************************
 * END OVERRIDE: dc.heatMap                                                   *
 * ***************************************************************************/

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = pieChart;

var _baseMixin = __webpack_require__(5);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

var _capMixin = __webpack_require__(10);

var _capMixin2 = _interopRequireDefault(_capMixin);

var _colorMixin = __webpack_require__(7);

var _colorMixin2 = _interopRequireDefault(_colorMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _multipleKeyLabelMixin = __webpack_require__(132);

var _multipleKeyLabelMixin2 = _interopRequireDefault(_multipleKeyLabelMixin);

var _formattingHelpers = __webpack_require__(6);

var _core = __webpack_require__(2);

var _utils = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The pie chart implementation is usually used to visualize a small categorical distribution.  The pie
 * chart uses keyAccessor to determine the slices, and valueAccessor to calculate the size of each
 * slice relative to the sum of all values. Slices are ordered by {@link #dc.baseMixin+ordering ordering}
 * which defaults to sorting by key.
 *
 * @name pieChart
 * @memberof dc
 * @mixes dc.capMixin
 * @mixes dc.colorMixin
 * @mixes dc.baseMixin
 * @example
 * // create a pie chart under #chart-container1 element using the default global chart group
 * var chart1 = dc.pieChart('#chart-container1');
 * // create a pie chart under #chart-container2 element using chart group A
 * var chart2 = dc.pieChart('#chart-container2', 'chartGroupA');
 * @param {String|node|d3.selection} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector} specifying
 * a dom block element such as a div; or a dom element or d3 selection.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
 * Interaction with a chart will only trigger events and redraws within the chart's group.
 * @return {dc.pieChart}
 */
function pieChart(parent, chartGroup) {
  var DEFAULT_MIN_ANGLE_FOR_LABEL = 0.4;

  var _sliceCssClass = "pie-slice";
  var _emptyCssClass = "empty-chart";
  var _emptyTitle = "empty";

  var _radius = void 0,
      _givenRadius = void 0,
      // specified radius, if any
  _innerRadius = 0,
      _externalRadiusPadding = 0;

  var _g = void 0;
  var _cx = void 0;
  var _cy = void 0;
  var _minAngleForLabel = DEFAULT_MIN_ANGLE_FOR_LABEL;
  var _externalLabelRadius = void 0;
  var _drawPaths = false;
  var _chart = (0, _capMixin2.default)((0, _colorMixin2.default)((0, _baseMixin2.default)({})));

  /* OVERRIDE ---------------------------------------------------------------- */
  var _pieStyle = void 0; // "pie" or "donut"
  var _pieSizeThreshold = 480;
  var _hasBeenRendered = false;
  _chart.redoSelect = highlightFilter;
  _chart.accent = accentSlice;
  _chart.unAccent = unAccentSlice;
  /* ------------------------------------------------------------------------- */

  _chart.colorAccessor(_chart.cappedKeyAccessor);

  _chart.title(function (d) {
    return _chart.cappedKeyAccessor(d) + ": " + _chart.cappedValueAccessor(d);
  });

  /**
   * Get or set the maximum number of slices the pie chart will generate. The top slices are determined by
   * value from high to low. Other slices exeeding the cap will be rolled up into one single *Others* slice.
   * @name slicesCap
   * @memberof dc.pieChart
   * @instance
   * @param {Number} [cap]
   * @return {Number}
   * @return {dc.pieChart}
   */
  _chart.slicesCap = _chart.cap;

  _chart.label(_chart.cappedKeyAccessor);
  _chart.renderLabel(true);

  _chart.transitionDuration(350);

  /* OVERRIDE ---------------------------------------------------------------- */
  _chart.measureValue = function (d) {
    var key = _chart.getMeasureName();
    var customFormatter = _chart.valueFormatter();
    var value = _chart.cappedValueAccessor(d);
    return customFormatter && customFormatter(value, key) || _utils.utils.formatValue(value);
  };

  _chart.redoSelect = highlightFilter;
  _chart.accent = accentSlice;
  _chart.unAccent = unAccentSlice;
  /* ------------------------------------------------------------------------- */

  _chart._doRender = function () {
    _chart.resetSvg();

    _g = _chart.svg().append("g").attr("class", "pie-wrapper").attr("transform", "translate(" + _chart.cx() + "," + _chart.cy() + ")");

    drawChart();

    /* OVERRIDE -----------------------------------------------------------------*/
    _hasBeenRendered = true;
    /* --------------------------------------------------------------------------*/
    return _chart;
  };

  function drawChart() {
    /* OVERRIDE ---------------------------------------------------------------- */
    // set radius on basis of chart dimension if missing
    // _radius = d3.min([_chart.width(), _chart.height()]) / 2;
    _radius = _givenRadius ? _givenRadius : _d2.default.min([_chart.width(), _chart.height()]) / 2;
    /* ------------------------------------------------------------------------- */

    var arc = buildArcs();

    var pie = pieLayout();
    var pieData = void 0;
    // if we have data...
    if (_d2.default.sum(_chart.data(), _chart.valueAccessor())) {
      pieData = pie(_utils.utils.maybeFormatInfinity(_chart.data()));
      _g.classed(_emptyCssClass, false);
    } else {
      // otherwise we'd be getting NaNs, so override
      // note: abuse others for its ignoring the value accessor
      pieData = pie([{ key: _emptyTitle, value: 1, others: [_emptyTitle] }]);
      _g.classed(_emptyCssClass, true);
    }

    if (_g) {
      var slices = _g.selectAll("g." + _sliceCssClass).data(pieData);

      createElements(slices, arc, pieData);

      updateElements(pieData, arc);

      removeElements(slices);

      highlightFilter();

      (0, _core.transition)(_g, _chart.transitionDuration()).attr("transform", "translate(" + _chart.cx() + "," + _chart.cy() + ")");
    }
  }

  function createElements(slices, arc, pieData) {
    var slicesEnter = createSliceNodes(slices);

    createSlicePath(slicesEnter, arc);

    createLabels(pieData, arc);
  }

  function createSliceNodes(slices) {
    var slicesEnter = slices.enter().append("g").attr("class", function (d, i) {
      return _sliceCssClass + " _" + i;
    })
    /* OVERRIDE ---------------------------------------------------------------- */
    .classed("stroke-thick", pieIsBig);
    /* ------------------------------------------------------------------------- */
    return slicesEnter;
  }

  function createSlicePath(slicesEnter, arc) {
    var slicePath = slicesEnter.append("path").attr("fill", fill).on("click", onClick)
    /* OVERRIDE ---------------------------------------------------------------- */
    .on("mouseenter", showPopup).on("mousemove", positionPopup).on("mouseleave", hidePopup)
    /* ------------------------------------------------------------------------- */
    .attr("d", function (d, i) {
      return safeArc(d, i, arc);
    });

    (0, _core.transition)(slicePath, _chart.transitionDuration(), function (s) {
      s.attrTween("d", tweenPie);
    });
  }

  function createTitles(slicesEnter) {
    if (_chart.renderTitle()) {
      slicesEnter.append("title").text(function (d) {
        return _chart.title()(d.data);
      });
    }
  }

  function positionLabels(labelsEnter, arc) {
    (0, _core.transition)(labelsEnter, _chart.transitionDuration()).attr("transform", function (d) {
      return labelPosition(d, arc);
    });

    /* OVERRIDE ---------------------------------------------------------------- */

    labelsEnter.style("font-size", pieIsBig() ? "14px" : "12px");

    labelsEnter.select(".value-dim").classed("deselected-label", function (d) {
      return _chart.hasFilter() && !isSelectedSlice(d);
    }).html(function (d) {
      return _chart.label()(d.data);
    }).html(function (d) {
      var availableLabelWidth = getAvailableLabelWidth(d);
      var width = _d2.default.select(this).node().getBoundingClientRect().width;
      var label = _chart.label()(d.data);
      var displayText = truncateLabelWithNull(label, width, availableLabelWidth);

      _d2.default.select(this.parentNode).classed("hide-label", displayText === "");

      return displayText;
    });

    if (_chart.measureLabelsOn()) {
      labelsEnter.select(".value-measure").classed("deselected-label", function (d) {
        return _chart.hasFilter() && !isSelectedSlice(d);
      })
      // the label needs to be in the DOM for computing its width
      .text(function (d) {
        if (_d2.default.select(this.parentNode).classed("hide-label")) {
          return "";
        } else {
          return _chart.measureValue(d.data);
        }
      }).text(function (d) {
        if (_d2.default.select(this.parentNode).classed("hide-label")) {
          return "";
        }
        var availableLabelWidth = getAvailableLabelWidth(d);
        var width = _d2.default.select(this).node().getBoundingClientRect().width;

        return width > availableLabelWidth ? truncateLabel(_chart.measureValue(d.data), width, availableLabelWidth) : _chart.measureValue(d.data);
      });
    }
    /* ------------------------------------------------------------------------- */
  }

  function createLabels(pieData, arc) {
    if (_chart.renderLabel()) {
      var labels = _g.selectAll("g.pie-label").data(pieData);

      labels.exit().remove();

      var labelsEnter = labels.enter()
      /* OVERRIDE ---------------------------------------------------------------- */
      .append("g").attr("class", function (d, i) {
        var classes = "pie-label _" + i;
        if (_externalLabelRadius) {
          classes = classes + " external";
        }
        return classes;
      }).attr("transform", function (d) {
        return labelPosition(d, arc);
      })
      /* ------------------------------------------------------------------------- */
      .on("click", onClick);

      /* OVERRIDE ---------------------------------------------------------------- */
      labelsEnter.append("text").attr("class", "value-dim").attr("dy", _chart.measureLabelsOn() ? "0" : ".4em");

      if (_chart.measureLabelsOn()) {
        labelsEnter.append("text").attr("class", "value-measure").attr("dy", "1.2em");
      }
      /* ------------------------------------------------------------------------- */

      positionLabels(labelsEnter, arc);
      if (_externalLabelRadius && _drawPaths) {
        updateLabelPaths(pieData, arc);
      }
    }
  }

  function updateLabelPaths(pieData, arc) {
    var polyline = _g.selectAll("polyline." + _sliceCssClass).data(pieData);

    polyline.enter().append("polyline").attr("class", function (d, i) {
      return "pie-path _" + i + " " + _sliceCssClass;
    });

    polyline.exit().remove();
    (0, _core.transition)(polyline, _chart.transitionDuration()).attrTween("points", function (d) {
      this._current = this._current || d;
      var interpolate = _d2.default.interpolate(this._current, d);
      this._current = interpolate(0);
      return function (t) {
        var arc2 = _d2.default.svg.arc().outerRadius(_radius - _externalRadiusPadding + _externalLabelRadius).innerRadius(_radius - _externalRadiusPadding);
        var d2 = interpolate(t);
        return [arc.centroid(d2), arc2.centroid(d2)];
      };
    }).style("visibility", function (d) {
      return d.endAngle - d.startAngle < 0.0001 ? "hidden" : "visible";
    });
  }

  function updateElements(pieData, arc) {
    updateSlicePaths(pieData, arc);
    updateLabels(pieData, arc);
    updateTitles(pieData);
  }

  function updateSlicePaths(pieData, arc) {
    var slicePaths = _g.selectAll("g." + _sliceCssClass).data(pieData).select("path").attr("d", function (d, i) {
      return safeArc(d, i, arc);
    });
    (0, _core.transition)(slicePaths, _chart.transitionDuration(), function (s) {
      s.attrTween("d", tweenPie);
    }).attr("fill", fill);
  }

  function updateLabels(pieData, arc) {
    if (_chart.renderLabel()) {
      /* OVERRIDE ---------------------------------------------------------------- */
      var labels = _g.selectAll("g.pie-label")
      /* ------------------------------------------------------------------------- */
      .data(pieData);
      positionLabels(labels, arc);
      if (_externalLabelRadius && _drawPaths) {
        updateLabelPaths(pieData, arc);
      }
    }
  }

  function updateTitles(pieData) {
    if (_chart.renderTitle()) {
      _g.selectAll("g." + _sliceCssClass).data(pieData).select("title").text(function (d) {
        return _chart.title()(d.data);
      });
    }
  }

  function removeElements(slices) {
    slices.exit().remove();
  }

  /* OVERRIDE ---------------------------------------------------------------- */
  function accentSlice(label) {
    _chart.selectAll("g." + _sliceCssClass).each(function (d) {
      if (_chart.cappedKeyAccessor(d.data) == label) {
        _chart.accentSelected(this);
      }
    });
  }

  function unAccentSlice(label) {
    _chart.selectAll("g." + _sliceCssClass).each(function (d) {
      if (_chart.cappedKeyAccessor(d.data) == label) {
        _chart.unAccentSelected(this);
      }
    });
  }
  /* ------------------------------------------------------------------------- */

  function highlightFilter() {
    if (_chart.hasFilter()) {
      _chart.selectAll("g." + _sliceCssClass).each(function (d) {
        if (isSelectedSlice(d)) {
          _chart.highlightSelected(this);
        } else {
          _chart.fadeDeselected(this);
        }
      });
    } else {
      _chart.selectAll("g." + _sliceCssClass).each(function () {
        _chart.resetHighlight(this);
      });
    }
  }

  /**
   * Get or set the external radius padding of the pie chart. This will force the radius of the
   * pie chart to become smaller or larger depending on the value.
   * @name externalRadiusPadding
   * @memberof dc.pieChart
   * @instance
   * @param {Number} [externalRadiusPadding=0]
   * @return {Number}
   * @return {dc.pieChart}
   */
  _chart.externalRadiusPadding = function (externalRadiusPadding) {
    if (!arguments.length) {
      return _externalRadiusPadding;
    }
    _externalRadiusPadding = externalRadiusPadding;
    return _chart;
  };

  /**
   * Get or set the inner radius of the pie chart. If the inner radius is greater than 0px then the
   * pie chart will be rendered as a doughnut chart.
   * @name innerRadius
   * @memberof dc.pieChart
   * @instance
   * @param {Number} [innerRadius=0]
   * @return {Number}
   * @return {dc.pieChart}
   */
  _chart.innerRadius = function (innerRadius) {
    if (!arguments.length) {
      /* OVERRIDE ---------------------------------------------------------------- */
      return _pieStyle ? _pieStyle === "donut" ? (Math.min(_chart.width(), _chart.height()) - _externalRadiusPadding) / 5 : 0 : _innerRadius;
      /* ------------------------------------------------------------------------- */
    }
    _innerRadius = innerRadius;
    return _chart;
  };
  /* OVERRIDE ---------------------------------------------------------------- */
  _chart.pieStyle = function (pieStyle) {
    if (!arguments.length) {
      return _pieStyle;
    }

    _pieStyle = pieStyle;
    return _chart;
  };
  /* ------------------------------------------------------------------------- */

  /**
   * Get or set the outer radius. If the radius is not set, it will be half of the minimum of the
   * chart width and height.
   * @name radius
   * @memberof dc.pieChart
   * @instance
   * @param {Number} [radius]
   * @return {Number}
   * @return {dc.pieChart}
   */
  _chart.radius = function (radius) {
    if (!arguments.length) {
      return _givenRadius;
    }
    _givenRadius = radius;
    return _chart;
  };

  /**
   * Get or set center x coordinate position. Default is center of svg.
   * @name cx
   * @memberof dc.pieChart
   * @instance
   * @param {Number} [cx]
   * @return {Number}
   * @return {dc.pieChart}
   */
  _chart.cx = function (cx) {
    if (!arguments.length) {
      return _cx || _chart.width() / 2;
    }
    _cx = cx;
    return _chart;
  };

  /**
   * Get or set center y coordinate position. Default is center of svg.
   * @name cy
   * @memberof dc.pieChart
   * @instance
   * @param {Number} [cy]
   * @return {Number}
   * @return {dc.pieChart}
   */
  _chart.cy = function (cy) {
    if (!arguments.length) {
      return _cy || _chart.height() / 2;
    }
    _cy = cy;
    return _chart;
  };

  function buildArcs() {
    /* OVERRIDE ---------------------------------------------------------------- */
    return _d2.default.svg.arc().outerRadius(_radius - _externalRadiusPadding).innerRadius(_chart.innerRadius());
    /* ------------------------------------------------------------------------- */
  }

  function isSelectedSlice(d) {
    return _chart.hasFilter(_chart.cappedKeyAccessor(d.data)) ^ _chart.filtersInverse();
  }

  _chart._doRedraw = function () {
    /* OVERRIDE ---------------------------------------------------------------- */
    if (!_hasBeenRendered) {
      // guard to prevent a redraw before a render
      return _chart._doRender();
    }
    /* ------------------------------------------------------------------------- */
    drawChart();
    return _chart;
  };

  /**
   * Get or set the minimal slice angle for label rendering. Any slice with a smaller angle will not
   * display a slice label.
   * @name minAngleForLabel
   * @memberof dc.pieChart
   * @instance
   * @param {Number} [minAngleForLabel=0.5]
   * @return {Number}
   * @return {dc.pieChart}
   */
  _chart.minAngleForLabel = function (minAngleForLabel) {
    if (!arguments.length) {
      return _minAngleForLabel;
    }
    _minAngleForLabel = minAngleForLabel;
    return _chart;
  };

  function pieLayout() {
    return _d2.default.layout.pie().sort(null).value(_chart.cappedValueAccessor);
  }

  /* OVERRIDE ---------------------------------------------------------------- */
  function getAvailableLabelWidth(d) {
    var angle = d.endAngle - d.startAngle;

    if (isNaN(angle) || angle * (_radius / 2) < (_chart.measureLabelsOn() ? 28 : 20)) {
      return 0;
    }

    var arc = buildArcs();
    var centroid = labelCentroid(d, arc);
    var adjacent = Math.abs(centroid[1]);
    var useAngle = centroid[0] * centroid[1] < 0 ? d.startAngle : d.endAngle;
    var refAngle = centroid[1] >= 0 ? Math.PI : centroid[0] < 0 ? Math.PI * 2 : 0;

    var tan = Math.tan(Math.abs(refAngle - useAngle));
    var opposite = tan * adjacent;
    var labelWidth = (refAngle >= d.startAngle && refAngle < d.endAngle ? Math.abs(centroid[0]) + opposite : Math.abs(centroid[0]) - opposite) * 2;
    var maxLabelWidth = _radius - _chart.innerRadius() - 24;

    return labelWidth > maxLabelWidth || labelWidth < 0 ? maxLabelWidth : labelWidth;
  }

  function truncateLabel(data, width, availableLabelWidth) {
    var labelText = "" + data;
    var labelLength = labelText.length;

    if (labelLength < 4) {
      return "";
    }

    var trimIndex = labelLength - Math.ceil((width - availableLabelWidth) / (width / labelLength) * 1.25);

    if (labelLength - trimIndex > 2) {
      labelText = trimIndex > 2 ? labelText.slice(0, trimIndex) + "" : "";
    }

    return labelText;
  }

  function truncateLabelWithNull(data, width, availableLabelWidth) {
    if (width > availableLabelWidth) {
      return truncateLabel(data.toString().replace(_formattingHelpers.nullLabelHtml, "NULL"), width, availableLabelWidth).replace(/\bNULL[^A-Za-z]/g, _formattingHelpers.nullLabelHtml + " ");
    } else {
      return data;
    }
  }

  /* ------------------------------------------------------------------------- */

  function sliceTooSmall(d) {
    var angle = d.endAngle - d.startAngle;
    return isNaN(angle) || angle < _minAngleForLabel;
  }

  function sliceHasNoData(d) {
    return _chart.cappedValueAccessor(d) === 0;
  }

  function tweenPie(b) {
    /* OVERRIDE ---------------------------------------------------------------- */
    b.innerRadius = _chart.innerRadius();
    /* ------------------------------------------------------------------------- */
    var current = this._current;
    if (isOffCanvas(current)) {
      current = { startAngle: 0, endAngle: 0 };
    }
    var i = _d2.default.interpolate(current, b);
    this._current = i(0);
    return function (t) {
      return safeArc(i(t), 0, buildArcs());
    };
  }

  function isOffCanvas(current) {
    return !current || isNaN(current.startAngle) || isNaN(current.endAngle);
  }

  function fill(d, i) {
    return _chart.getColor(d.data, i);
  }

  function onClick(d, i) {
    if (_g.attr("class") !== _emptyCssClass) {
      _chart.onClick(d.data, i);
    }
  }
  /* OVERRIDE ---------------------------------------------------------------- */
  function showPopup(d, i) {
    var popup = _chart.popup();

    var popupBox = popup.select(".chart-popup-content").html("");

    popupBox.append("div").attr("class", "popup-legend").style("background-color", fill(d, i));

    popupBox.append("div").attr("class", "popup-value").html(function () {
      return "\n                    <div class=\"popup-value-dim\">\n                        " + _chart.label()(d.data) + "\n                    </div>\n                    <div class=\"popup-value-measure\">\n                        " + _chart.measureValue(d.data) + "\n                    </div>";
    });

    popup.classed("js-showPopup", true);
  }

  function hidePopup() {
    _chart.popup().classed("js-showPopup", false);
  }

  function positionPopup() {
    var coordinates = [0, 0];
    coordinates = _chart.popupCoordinates(_d2.default.mouse(this));
    var x = coordinates[0] + _chart.width() / 2;
    var y = coordinates[1] + _chart.height() / 2;

    var popup = _chart.popup().attr("style", function () {
      return "transform:translate(" + x + "px," + y + "px)";
    });

    popup.select(".chart-popup-box").classed("align-center", function () {
      return x + _d2.default.select(this).node().getBoundingClientRect().width > _chart.width() && x - _d2.default.select(this).node().getBoundingClientRect().width / 2 >= 0;
    }).classed("align-right", function () {
      return x + _d2.default.select(this).node().getBoundingClientRect().width > _chart.width() && x - _d2.default.select(this).node().getBoundingClientRect().width >= 0;
    });
  }

  function pieIsBig() {
    return _pieSizeThreshold < Math.min(_chart.width(), _chart.height());
  }
  /* ------------------------------------------------------------------------- */

  function safeArc(d, i, arc) {
    var path = arc(d, i);
    if (path.indexOf("NaN") >= 0) {
      path = "M0,0";
    }
    return path;
  }

  /**
   * Title to use for the only slice when there is no data.
   * @name emptyTitle
   * @memberof dc.pieChart
   * @instance
   * @param {String} [title]
   * @return {String}
   * @return {dc.pieChart}
   */
  _chart.emptyTitle = function (title) {
    if (arguments.length === 0) {
      return _emptyTitle;
    }
    _emptyTitle = title;
    return _chart;
  };

  /**
   * Position slice labels offset from the outer edge of the chart
   *
   * The given argument sets the radial offset.
   * @name externalLabels
   * @memberof dc.pieChart
   * @instance
   * @param {Number} [externalLabelRadius]
   * @return {Number}
   * @return {dc.pieChart}
   */
  _chart.externalLabels = function (externalLabelRadius) {
    if (arguments.length === 0) {
      return _externalLabelRadius;
    } else if (externalLabelRadius) {
      _externalLabelRadius = externalLabelRadius;
    } else {
      _externalLabelRadius = undefined;
    }

    return _chart;
  };

  /**
   * Get or set whether to draw lines from pie slices to their labels.
   *
   * @name drawPaths
   * @memberof dc.pieChart
   * @instance
   * @param {Boolean} [drawPaths]
   * @return {Boolean}
   * @return {dc.pieChart}
   */
  _chart.drawPaths = function (drawPaths) {
    if (arguments.length === 0) {
      return _drawPaths;
    }
    _drawPaths = drawPaths;
    return _chart;
  };

  function labelPosition(d, arc) {
    var centroid = void 0;
    if (_externalLabelRadius) {
      centroid = _d2.default.svg.arc().outerRadius(_radius - _externalRadiusPadding + _externalLabelRadius).innerRadius(_radius - _externalRadiusPadding + _externalLabelRadius).centroid(d);
    } else {
      /* OVERRIDE -----------------------------------------------------------------*/
      centroid = labelCentroid(d, arc);
      /* --------------------------------------------------------------------------*/
    }
    if (isNaN(centroid[0]) || isNaN(centroid[1])) {
      return "translate(0,0)";
    } else {
      return "translate(" + centroid + ")";
    }
  }

  /* OVERRIDE -----------------------------------------------------------------*/
  function labelCentroid(d, arc) {
    var centroid = void 0;
    if (_externalLabelRadius) {
      centroid = _d2.default.svg.arc().outerRadius(_radius - _externalRadiusPadding + _externalLabelRadius).innerRadius(_radius - _externalRadiusPadding + _externalLabelRadius).centroid(d);
    } else {
      centroid = _innerRadius === 0 && _pieStyle != "donut" ? _d2.default.svg.arc().outerRadius(_radius - _externalRadiusPadding).innerRadius(_radius / 5).centroid(d) : arc.centroid(d);
    }

    return centroid;
  }
  /* --------------------------------------------------------------------------*/

  _chart.legendables = function () {
    return _chart.data().map(function (d, i) {
      /* OVERRIDE -----------------------------------------------------------------*/
      var legendable = {
        name: d.key0,
        data: d.value,
        others: d.others,
        chart: _chart
        /* --------------------------------------------------------------------------*/

      };legendable.color = _chart.getColor(d, i);
      return legendable;
    });
  };

  _chart.legendHighlight = function (d) {
    highlightSliceFromLegendable(d, true);
  };

  _chart.legendReset = function (d) {
    highlightSliceFromLegendable(d, false);
  };

  _chart.legendToggle = function (d) {
    _chart.onClick({ key: d.name, others: d.others });
  };

  function highlightSliceFromLegendable(legendable, highlighted) {
    _chart.selectAll("g.pie-slice").each(function (d) {
      if (legendable.name === d.data.key) {
        _d2.default.select(this).classed("highlight", highlighted);
      }
    });
  }

  _chart = (0, _multipleKeyLabelMixin2.default)(_chart);

  return _chart.anchor(parent, chartGroup);
}
/** ***************************************************************************
 * END OVERRIDE: dc.pieChart                                                  *
 * ***************************************************************************/

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = lineChart;

var _core = __webpack_require__(2);

var _utils = __webpack_require__(3);

var _coordinateGridMixin = __webpack_require__(11);

var _coordinateGridMixin2 = _interopRequireDefault(_coordinateGridMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _elasticDimensionMixin = __webpack_require__(134);

var _elasticDimensionMixin2 = _interopRequireDefault(_elasticDimensionMixin);

var _stackMixin = __webpack_require__(19);

var _stackMixin2 = _interopRequireDefault(_stackMixin);

var _multiSeriesMixin = __webpack_require__(136);

var _multiSeriesMixin2 = _interopRequireDefault(_multiSeriesMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Concrete line/area chart implementation.
 *
 * Examples:
 * - {@link https://mapd.github.io/mapd-charting/example/example1.html Number of Flights by Departure Time}
 * @name lineChart
 * @memberof dc
 * @mixes dc.stackMixin
 * @mixes dc.coordinateGridMixin
 * @example
 * // create a line chart under #chart-container1 element using the default global chart group
 * var chart1 = dc.lineChart('#chart-container1');
 * // create a line chart under #chart-container2 element using chart group A
 * var chart2 = dc.lineChart('#chart-container2', 'chartGroupA');
 * // create a sub-chart under a composite parent chart
 * var chart3 = dc.lineChart(compositeChart);
 * @param {String|node|d3.selection|dc.compositeChart} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector}
 * specifying a dom block element such as a div; or a dom element or d3 selection.  If the line
 * chart is a sub-chart in a {@link #dc.compositeChart Composite Chart} then pass in the parent
 * composite chart instance instead.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
 * Interaction with a chart will only trigger events and redraws within the chart's group.
 * @return {dc.lineChart}
 */
function lineChart(parent, chartGroup) {
  var DEFAULT_DOT_RADIUS = 5;
  var TOOLTIP_G_CLASS = "dc-tooltip";
  var DOT_CIRCLE_CLASS = "dot";
  var Y_AXIS_REF_LINE_CLASS = "yRef";
  var X_AXIS_REF_LINE_CLASS = "xRef";
  var DEFAULT_DOT_OPACITY = 1e-6;

  var _chart = (0, _elasticDimensionMixin2.default)((0, _stackMixin2.default)((0, _coordinateGridMixin2.default)({})));
  var _renderArea = false;
  var _dotRadius = DEFAULT_DOT_RADIUS;
  var _dataPointRadius = null;
  var _dataPointFillOpacity = DEFAULT_DOT_OPACITY;
  var _dataPointStrokeOpacity = DEFAULT_DOT_OPACITY;
  var _interpolate = "linear";
  var _tension = 0.7;
  var _defined = void 0;
  var _dashStyle = void 0;
  var _xyTipsOn = true;

  _chart.transitionDuration(500);
  _chart._rangeBandPadding(1);

  _chart.plotData = function () {
    var chartBody = _chart.chartBodyG();
    var layersList = chartBody.selectAll("g.stack-list");

    if (layersList.empty()) {
      layersList = chartBody.append("g").attr("class", "stack-list");
    }

    var layers = layersList.selectAll("g.stack").data(_chart.data());

    var layersEnter = layers.enter().append("g").attr("class", function (d, i) {
      return "stack " + "_" + i;
    });

    drawLine(layersEnter, layers);

    drawArea(layersEnter, layers);

    drawDots(chartBody, layers);
  };

  /**
   * Gets or sets the interpolator to use for lines drawn, by string name, allowing e.g. step
   * functions, splines, and cubic interpolation.  This is passed to
   * {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#line_interpolate d3.svg.line.interpolate} and
   * {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#area_interpolate d3.svg.area.interpolate},
   * where you can find a complete list of valid arguments
   * @name interpolate
   * @memberof dc.lineChart
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#line_interpolate d3.svg.line.interpolate}
   * @see {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#area_interpolate d3.svg.area.interpolate}
   * @param  {String} [interpolate='linear']
   * @return {String}
   * @return {dc.lineChart}
   */
  _chart.interpolate = function (interpolate) {
    if (!arguments.length) {
      return _interpolate;
    }
    _interpolate = interpolate;
    return _chart;
  };

  /**
   * Gets or sets the tension to use for lines drawn, in the range 0 to 1.
   * This parameter further customizes the interpolation behavior.  It is passed to
   * {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#line_tension d3.svg.line.tension} and
   * {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#area_tension d3.svg.area.tension}.
   * @name tension
   * @memberof dc.lineChart
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#line_interpolate d3.svg.line.interpolate}
   * @see {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#area_interpolate d3.svg.area.interpolate}
   * @param  {Number} [tension=0.7]
   * @return {Number}
   * @return {dc.lineChart}
   */
  _chart.tension = function (tension) {
    if (!arguments.length) {
      return _tension;
    }
    _tension = tension;
    return _chart;
  };

  /**
   * Gets or sets a function that will determine discontinuities in the line which should be
   * skipped: the path will be broken into separate subpaths if some points are undefined.
   * This function is passed to
   * {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#line_defined d3.svg.line.defined}
   *
   * Note: crossfilter will sometimes coerce nulls to 0, so you may need to carefully write
   * custom reduce functions to get this to work, depending on your data. See
   * https://github.com/dc-js/dc.js/issues/615#issuecomment-49089248
   * @name defined
   * @memberof dc.lineChart
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#line_defined d3.svg.line.defined}
   * @param  {Function} [defined]
   * @return {Function}
   * @return {dc.lineChart}
   */
  _chart.defined = function (defined) {
    if (!arguments.length) {
      return _defined;
    }
    _defined = defined;
    return _chart;
  };

  /**
   * Set the line's d3 dashstyle. This value becomes the 'stroke-dasharray' of line. Defaults to empty
   * array (solid line).
   * @name dashStyle
   * @memberof dc.lineChart
   * @instance
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray stroke-dasharray}
   * @example
   * // create a Dash Dot Dot Dot
   * chart.dashStyle([3,1,1,1]);
   * @param  {Array<Number>} [dashStyle=[]]
   * @return {Array<Number>}
   * @return {dc.lineChart}
   */
  _chart.dashStyle = function (dashStyle) {
    if (!arguments.length) {
      return _dashStyle;
    }
    _dashStyle = dashStyle;
    return _chart;
  };

  _chart.measureValue = function (value) {
    var customFormatter = _chart.valueFormatter();
    return customFormatter && customFormatter(value) || _utils.utils.formatValue(value);
  };

  _chart.dimensionValue = function (value) {
    var customFormatter = _chart.dateFormatter();
    return customFormatter && customFormatter(value) || _utils.utils.formatValue(value);
  };
  /**
   * Get or set render area flag. If the flag is set to true then the chart will render the area
   * beneath each line and the line chart effectively becomes an area chart.
   * @name renderArea
   * @memberof dc.lineChart
   * @instance
   * @param  {Boolean} [renderArea=false]
   * @return {Boolean}
   * @return {dc.lineChart}
   */
  _chart.renderArea = function (renderArea) {
    if (!arguments.length) {
      return _renderArea;
    }
    _renderArea = renderArea;
    return _chart;
  };

  function colors(d, i) {
    if (d.name) {
      d.layer = d.name;
      return _chart.getColor(d, i);
    } else {
      return _chart.getColor(d, i);
    }
  }

  function drawLine(layersEnter, layers) {
    var line = _d2.default.svg.line().x(function (d) {
      return _chart.x()(d.x);
    }).y(function (d) {
      /* OVERRIDE ---------------------------------------------------------------- */
      if (_renderArea) {
        return _chart.y()(d.y + d.y0);
      } else {
        return _chart.y()(d.y);
      }
      /* ------------------------------------------------------------------------- */
    }).interpolate(_interpolate).tension(_tension);
    if (_defined) {
      line.defined(_defined);
    }

    var path = layersEnter.append("path").attr("class", "line").attr("stroke", colors);
    if (_dashStyle) {
      path.attr("stroke-dasharray", _dashStyle);
    }

    (0, _core.transition)(layers.select("path.line"), _chart.transitionDuration())
    // .ease('linear')
    .attr("stroke", colors).attr("d", function (d) {
      return safeD(line(d.values));
    });
  }

  function drawArea(layersEnter, layers) {
    if (_renderArea) {
      var area = _d2.default.svg.area().x(function (d) {
        return _chart.x()(d.x);
      }).y(function (d) {
        return _chart.y()(d.y + d.y0);
      }).y0(function (d) {
        return _chart.y()(d.y0);
      }).interpolate(_interpolate).tension(_tension);
      if (_defined) {
        area.defined(_defined);
      }

      layersEnter.append("path").attr("class", "area").attr("fill", colors).attr("d", function (d) {
        return safeD(area(d.values));
      });

      (0, _core.transition)(layers.select("path.area"), _chart.transitionDuration())
      // .ease('linear')
      .attr("fill", colors).attr("d", function (d) {
        return safeD(area(d.values));
      });
    }
  }

  function safeD(d) {
    return !d || d.indexOf("NaN") >= 0 ? "M0,0" : d;
  }

  function hoverOverBrush() {
    var g = _chart.g().on("mouseout", function () {
      hideBrushDots();
    }).on("mousemove", function () {
      if (_chart.isBrushing()) {
        hidePopup();
      } else {
        showBrushDots(g, this);
      }
    });
  }

  function hideBrushDots() {
    _chart.g().selectAll(".dot").style("fill-opacity", 0);
    hidePopup();
  }

  function showBrushDots(g, e) {
    var coordinates = [0, 0];
    coordinates = _chart.popupCoordinates(_d2.default.mouse(e));
    var x = coordinates[0];
    var y = coordinates[1];
    var xAdjusted = x - _chart.margins().left;

    var popupRows = [];

    var toolTips = g.selectAll(".dc-tooltip").each(function () {
      var lastDot = null;
      var hoverDot = null;

      var dots = _d2.default.select(this).selectAll(".dot").style("fill-opacity", 0);

      dots[0].sort(function (a, b) {
        return _d2.default.select(a).attr("cx") - _d2.default.select(b).attr("cx");
      });

      dots[0].some(function (obj, i) {
        var elm = _d2.default.select(obj);

        if (xAdjusted < elm.attr("cx")) {
          hoverDot = { elm: elm, datum: elm.datum(), i: i };
          return true;
        }

        lastDot = { elm: elm, datum: elm.datum(), i: i };
      });

      hoverDot = lastDot && hoverDot ? Math.abs(lastDot.elm.attr("cx") - xAdjusted) < Math.abs(hoverDot.elm.attr("cx") - xAdjusted) ? lastDot : hoverDot : hoverDot;

      if (hoverDot && Math.abs(hoverDot.elm.attr("cx") - xAdjusted) < 32) {
        hoverDot.elm.style("fill-opacity", 1);
        popupRows.push(hoverDot);
      }
    });

    if (popupRows.length > 0) {
      showPopup(popupRows, x, y);
    } else {
      hidePopup();
    }
  }

  function showPopup(arr, x, y) {
    if (!_chart.popupIsEnabled()) {
      hidePopup();
      return false;
    }
    var popup = _chart.popup();

    var popupBox = popup.select(".chart-popup-content").html("").classed("popup-list", true);

    popupBox.append("div").attr("class", "popup-header").text(_chart.popupTextAccessor(arr));

    var popupItems = popupBox.selectAll(".popup-item").data(arr.sort(function (a, b) {
      return _renderArea ? b.datum.y + b.datum.y0 - (a.datum.y + a.datum.y0) : b.datum.y - a.datum.y;
    })).enter().append("div").attr("class", "popup-item");

    popupItems.append("div").attr("class", "popup-legend").style("background-color", function (d) {
      return colors(d.datum, d.i);
    });

    if (_chart.series().keys()) {
      popupItems.append("div").attr("class", "popup-item-key").text(function (d) {
        return _chart.colorDomain()[d.datum.idx];
      });
    }

    popupItems.append("div").attr("class", "popup-item-value").classed("text-align-right", Boolean(_chart.series().keys())).text(function (d) {
      return _chart.measureValue(d.datum.y);
    });

    positionPopup(x, y);
    popup.classed("js-showPopup", true);
  }

  function hidePopup() {
    _chart.popup().classed("js-showPopup", false);
  }

  function positionPopup(x, y) {
    var popup = _chart.popup().attr("style", function () {
      return "transform:translate(" + x + "px," + y + "px)";
    });

    popup.select(".chart-popup-box").classed("align-left-center", true).classed("align-right-center", function () {
      return x + (_d2.default.select(this).node().getBoundingClientRect().width + 32) > _chart.width();
    });
  }

  function drawDots(chartBody, layers) {
    /* OVERRIDE ---------------------------------------------------------------- */
    // if (!_chart.brushOn() && _chart.xyTipsOn()) {
    /* ------------------------------------------------------------------------- */

    var tooltipListClass = TOOLTIP_G_CLASS + "-list";
    var tooltips = chartBody.select("g." + tooltipListClass);

    if (tooltips.empty()) {
      tooltips = chartBody.append("g").attr("class", tooltipListClass);
    }

    layers.each(function (d, layerIndex) {
      var points = d.values;
      if (_defined) {
        points = points.filter(_defined);
      }

      var g = tooltips.select("g." + TOOLTIP_G_CLASS + "._" + layerIndex);
      if (g.empty()) {
        g = tooltips.append("g").attr("class", TOOLTIP_G_CLASS + " _" + layerIndex);
      }

      createRefLines(g);

      var dots = g.selectAll("circle." + DOT_CIRCLE_CLASS).data(points, (0, _utils.pluck)("x"));

      dots.enter().append("circle").attr("class", DOT_CIRCLE_CLASS).attr("r", getDotRadius()).style("fill-opacity", _dataPointFillOpacity).style("stroke-opacity", _dataPointStrokeOpacity).on("mousemove", function () {
        var dot = _d2.default.select(this);
        showDot(dot);
        showRefLines(dot, g);
      }).on("mouseout", function () {
        var dot = _d2.default.select(this);
        hideDot(dot);
        hideRefLines(g);
      });

      dots.attr("cx", function (d) {
        return _utils.utils.safeNumber(_chart.x()(d.x));
      }).attr("cy", function (d) {
        /* OVERRIDE ---------------------------------------------------------------- */
        if (_renderArea) {
          return _utils.utils.safeNumber(_chart.y()(d.y + d.y0));
        } else {
          return _utils.utils.safeNumber(_chart.y()(d.y));
        }
        /* ------------------------------------------------------------------------- */
      }).attr("fill", colors).call(renderTitle, d);

      dots.exit().remove();
    });

    if (_chart.brushOn() && !_chart.focusChart()) {
      hoverOverBrush();
    }

    /* OVERRIDE ---------------------------------------------------------------- */
    // }
    /* ------------------------------------------------------------------------- */
  }

  function createRefLines(g) {
    var yRefLine = g.select("path." + Y_AXIS_REF_LINE_CLASS).empty() ? g.append("path").attr("class", Y_AXIS_REF_LINE_CLASS) : g.select("path." + Y_AXIS_REF_LINE_CLASS);
    yRefLine.style("display", "none").attr("stroke-dasharray", "5,5");

    var xRefLine = g.select("path." + X_AXIS_REF_LINE_CLASS).empty() ? g.append("path").attr("class", X_AXIS_REF_LINE_CLASS) : g.select("path." + X_AXIS_REF_LINE_CLASS);
    xRefLine.style("display", "none").attr("stroke-dasharray", "5,5");
  }

  function showDot(dot) {
    dot.style("fill-opacity", 0.8);
    dot.style("stroke-opacity", 0.8);
    dot.attr("r", _dotRadius);
    return dot;
  }

  function showRefLines(dot, g) {
    var x = dot.attr("cx");
    var y = dot.attr("cy");
    var yAxisX = _chart._yAxisX() - _chart.margins().left;
    var yAxisRefPathD = "M" + yAxisX + " " + y + "L" + x + " " + y;
    var xAxisRefPathD = "M" + x + " " + _chart.yAxisHeight() + "L" + x + " " + y;
    g.select("path." + Y_AXIS_REF_LINE_CLASS).style("display", "").attr("d", yAxisRefPathD);
    g.select("path." + X_AXIS_REF_LINE_CLASS).style("display", "").attr("d", xAxisRefPathD);
  }

  function getDotRadius() {
    return _dataPointRadius || _dotRadius;
  }

  function hideDot(dot) {
    dot.style("fill-opacity", _dataPointFillOpacity).style("stroke-opacity", _dataPointStrokeOpacity).attr("r", getDotRadius());
  }

  function hideRefLines(g) {
    g.select("path." + Y_AXIS_REF_LINE_CLASS).style("display", "none");
    g.select("path." + X_AXIS_REF_LINE_CLASS).style("display", "none");
  }

  function renderTitle(dot, d) {
    if (_chart.renderTitle()) {
      dot.selectAll("title").remove();
      dot.append("title").text((0, _utils.pluck)("data", _chart.title(d.name)));
    }
  }

  /**
   * Turn on/off the mouseover behavior of an individual data point which renders a circle and x/y axis
   * dashed lines back to each respective axis.  This is ignored if the chart
   * {@link #dc.coordinateGridMixin+brushOn brush} is on
   * @name xyTipsOn
   * @memberof dc.lineChart
   * @instance
   * @param  {Boolean} [xyTipsOn=false]
   * @return {Boolean}
   * @return {dc.lineChart}
   */
  _chart.xyTipsOn = function (xyTipsOn) {
    if (!arguments.length) {
      return _xyTipsOn;
    }
    _xyTipsOn = xyTipsOn;
    return _chart;
  };

  /**
   * Get or set the radius (in px) for dots displayed on the data points.
   * @name dotRadius
   * @memberof dc.lineChart
   * @instance
   * @param  {Number} [dotRadius=5]
   * @return {Number}
   * @return {dc.lineChart}
   */
  _chart.dotRadius = function (dotRadius) {
    if (!arguments.length) {
      return _dotRadius;
    }
    _dotRadius = dotRadius;
    return _chart;
  };

  /**
   * Always show individual dots for each datapoint.
   * If `options` is falsy, it disables data point rendering.
   *
   * If no `options` are provided, the current `options` values are instead returned.
   * @name renderDataPoints
   * @memberof dc.lineChart
   * @instance
   * @example
   * chart.renderDataPoints({radius: 2, fillOpacity: 0.8, strokeOpacity: 0.8})
   * @param  {{fillOpacity: Number, strokeOpacity: Number, radius: Number}} [options={fillOpacity: 0.8, strokeOpacity: 0.8, radius: 2}]
   * @return {{fillOpacity: Number, strokeOpacity: Number, radius: Number}}
   * @return {dc.lineChart}
   */
  _chart.renderDataPoints = function (options) {
    if (!arguments.length) {
      return {
        fillOpacity: _dataPointFillOpacity,
        strokeOpacity: _dataPointStrokeOpacity,
        radius: _dataPointRadius
      };
    } else if (!options) {
      _dataPointFillOpacity = DEFAULT_DOT_OPACITY;
      _dataPointStrokeOpacity = DEFAULT_DOT_OPACITY;
      _dataPointRadius = null;
    } else {
      _dataPointFillOpacity = options.fillOpacity || 0.8;
      _dataPointStrokeOpacity = options.strokeOpacity || 0.8;
      _dataPointRadius = options.radius || 2;
    }
    return _chart;
  };

  function colorFilter(color, dashstyle, inv) {
    return function () {
      var item = _d2.default.select(this);
      var match = item.attr("stroke") === color && item.attr("stroke-dasharray") === (dashstyle instanceof Array ? dashstyle.join(",") : null) || item.attr("fill") === color;
      return inv ? !match : match;
    };
  }

  _chart.legendHighlight = function (d) {
    if (!_chart.isLegendableHidden(d)) {
      _chart.g().selectAll("path.line, path.area").classed("highlight", colorFilter(d.color, d.dashstyle)).classed("fadeout", colorFilter(d.color, d.dashstyle, true));
    }
  };

  _chart.legendReset = function () {
    _chart.g().selectAll("path.line, path.area").classed("highlight", false).classed("fadeout", false);
  };

  (0, _core.override)(_chart, "legendables", function () {
    var legendables = _chart._legendables();
    if (!_dashStyle) {
      return legendables;
    }
    return legendables.map(function (l) {
      l.dashstyle = _dashStyle;
      return l;
    });
  });

  _chart = (0, _multiSeriesMixin2.default)(_chart);

  _chart.destroyChart = function () {
    (0, _core.deregisterChart)(_chart, _chart.chartGroup());
    _chart.on("filtered", null);
    _chart.filterAll();
    _chart.resetSvg();
    _chart.root().attr("style", "").attr("class", "").html("");
    _chart._doRender = function () {
      return _chart;
    };
  };

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = numberChart;

var _baseMixin = __webpack_require__(5);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _utils = __webpack_require__(3);

var _coreAsync = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function numberChart(parent, chartGroup) {
  var _chart = (0, _baseMixin2.default)({});
  var _colors = "#22a7f0";
  var _fontSize = null;
  var _chartWidth = null;

  _chart.colors = function (_) {
    if (!arguments.length) {
      return _colors;
    }
    _colors = _;
    return _chart;
  };

  _chart.getColor = function (selected, all) {
    return typeof _colors === "string" ? _colors : _colors[0];
  };

  _chart.setDataAsync(function (group, callbacks) {
    return group.valueAsync().then(function (data) {
      if (group.getReduceExpression() === "COUNT(*) AS val") {
        var id = group.getCrossfilterId();
        var filterSize = (0, _coreAsync.lastFilteredSize)(id);
        if (filterSize !== undefined) {
          return Promise.resolve(filterSize);
        } else {
          return _chart.dimension().sizeAsync().then(group.valueAsync).then(function (value) {
            (0, _coreAsync.setLastFilteredSize)(id, value);
            return value;
          });
        }
      } else {
        return data;
      }
    }).then(function (data) {
      callbacks(null, data);
    }).catch(function (error) {
      callbacks(error);
    });
  });

  _chart._doRender = function (val) {
    var customFormatter = _chart.valueFormatter();
    var formattedValue = val;
    if (customFormatter && customFormatter(val)) {
      formattedValue = customFormatter(val);
    } else {
      formattedValue = _utils.utils.formatValue(val);
      if (formattedValue === "-0") {
        formattedValue = 0;
      }
    }

    var wrapper = _chart.root().html("").append("div").attr("class", "number-chart-wrapper");

    var TEXT_MARGINS = 64;
    var chartWidth = _chart.width() - TEXT_MARGINS;
    var chartHeight = _chart.height() - TEXT_MARGINS;
    var fontSize = _utils.utils.getFontSizeFromWidth(formattedValue, wrapper, chartWidth, chartHeight);
    wrapper.append("span").attr("class", "number-chart-number").style("color", _chart.getColor).style("font-size", fontSize + "px").html(formattedValue);

    return _chart;
  };

  _chart._doRedraw = function (val) {
    return _chart._doRender(val);
  };

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rasterChart;

var _stackedLegend = __webpack_require__(203);

var _coordinateGridRasterMixin = __webpack_require__(139);

var _coordinateGridRasterMixin2 = _interopRequireDefault(_coordinateGridRasterMixin);

var _mapMixin = __webpack_require__(20);

var _mapMixin2 = _interopRequireDefault(_mapMixin);

var _baseMixin = __webpack_require__(5);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

var _scatterMixin = __webpack_require__(140);

var _scatterMixin2 = _interopRequireDefault(_scatterMixin);

var _rasterDrawMixin = __webpack_require__(21);

var _coreAsync = __webpack_require__(4);

var _legendables = __webpack_require__(205);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function rasterChart(parent, useMap, chartGroup, _mapboxgl) {
  var _chart = null;
  var _legend = null;

  var _useMap = useMap !== undefined ? useMap : false;

  var parentDivId = parent.attributes.id.value;

  var browser = detectBrowser();
  function detectBrowser() {
    // from SO: http://bit.ly/1Wd156O
    var isOpera = Boolean(window.opr) && Boolean(opr.addons) || Boolean(window.opera) || navigator.userAgent.indexOf(" OPR/") >= 0;
    var isFirefox = typeof InstallTrigger !== "undefined";
    var isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf("Constructor") > 0;
    var isIE = /* @cc_on!@*/false || Boolean(document.documentMode);
    var isEdge = !isIE && Boolean(window.StyleMedia);
    var isChrome = Boolean(window.chrome) && Boolean(window.chrome.webstore);
    return { isOpera: isOpera, isFirefox: isFirefox, isSafari: isSafari, isIE: isIE, isEdge: isEdge, isChrome: isChrome };
  }

  if (_useMap) {
    _chart = (0, _mapMixin2.default)((0, _baseMixin2.default)({}), parentDivId, _mapboxgl, true, false);
  } else {
    _chart = (0, _scatterMixin2.default)((0, _coordinateGridRasterMixin2.default)({}, _mapboxgl, browser), _mapboxgl, true);
  }

  // unset predefined mandatory attributes
  _chart._mandatoryAttributes([]);

  var _con = window.hasOwnProperty("con") ? con : null;
  var _imageOverlay = null;
  var _renderBoundsMap = {};
  var _layerNames = {};
  var _layers = [];
  var _hasBeenRendered = false;

  var _x = null;
  var _y = null;
  var _xScaleName = "x";
  var _yScaleName = "y";

  var _xLatLngBnds = null;
  var _yLatLngBnds = null;
  var _useGeoTypes = false;

  var _usePixelRatio = false;
  var _pixelRatio = 1;

  var _minPopupShapeBoundsArea = 16 * 16;
  var _popupSearchRadius = 2;
  var _popupDivClassName = "map-popup";
  var _popupDisplayable = true;
  var _legendOpen = true;

  _chart.legendOpen = function (_) {
    if (!arguments.length) {
      return _legendOpen;
    }
    _legendOpen = _;
    return _chart;
  };

  _chart.popupDisplayable = function (displayable) {
    _popupDisplayable = Boolean(displayable);
  };

  _chart.x = function (x) {
    if (!arguments.length) {
      return _x;
    }
    _x = x;
    return _chart;
  };

  _chart.y = function (_) {
    if (!arguments.length) {
      return _y;
    }
    _y = _;
    return _chart;
  };

  _chart.xLatLngBnds = function (_) {
    if (!arguments.length) {
      return _xLatLngBnds;
    }
    _xLatLngBnds = _;
    return chart;
  };

  _chart.yLatLngBnds = function (_) {
    if (!arguments.length) {
      return _yLatLngBnds;
    }
    _yLatLngBnds = _;
    return chart;
  };

  _chart._resetRenderBounds = function () {
    _renderBoundsMap = {};
  };

  _chart._resetLayers = function () {
    _layers = [];
    _layerNames = {};
  };

  _chart.pushLayer = function (layerName, layer) {
    if (_layerNames[layerName]) {
      throw new Error('A layer with name "' + layerName + '" already exists.');
    } else if (!layerName.match(/^\w+$/)) {
      throw new Error("A layer name can only have alpha numeric characters (A-Z, a-z, 0-9, or _)");
    }

    _layers.push(layerName);
    _layerNames[layerName] = layer;
    return _chart;
  };

  _chart.popLayer = function () {
    var layerName = _layers.pop();
    var layer = _layerNames[layerName];
    delete _layerNames[layerName];
    return layer;
  };

  _chart.popAllLayers = function () {
    var poppedLayers = _layers.map(function (layerName) {
      var layer = _layerNames[layerName];
      delete _layerNames[layerName];
      return layer;
    });
    _layers = [];
    return poppedLayers;
  };

  _chart.getLayer = function (layerName) {
    return _layerNames[layerName];
  };

  _chart.getAllLayers = function () {
    return Object.keys(_layerNames).map(function (k) {
      return _layerNames[k];
    });
  };

  _chart.getLayerAt = function (idx) {
    var layerName = _layers[idx];
    return _layerNames[layerName];
  };

  _chart.getLayers = function () {
    return _layers.map(function (layerName) {
      return _layerNames[layerName];
    });
  };

  _chart.getLayerNames = function () {
    return _layers;
  };

  _chart.xRangeFilter = function (filter) {
    for (var layerName in _layerNames) {
      var _layer = _layerNames[layerName];
      // layer.xDim() & layer.xDim().filter(filter)
    }
  };

  _chart.yRangeFilter = function (filter) {
    for (var layerName in _layerNames) {
      var _layer2 = _layerNames[layerName];
      // layer.yDim() && layer.yDim().filter(filter)
    }
  };

  _chart.clearLayerFilters = function () {
    for (var layerName in _layerNames) {
      var _layer3 = _layerNames[layerName];
      if (typeof _layer3.filterAll === "function") {
        _layer3.filterAll();
      }
    }
  };

  _chart.destroyChart = function () {
    _legend.setState({});

    _chart.filterAll();
    for (var layerName in _layerNames) {
      var _layer4 = _layerNames[layerName];
      _layer4.destroyLayer(_chart);
    }

    _chart.map().remove();
  };

  _chart.con = function (_) {
    if (!arguments.length) {
      return _con;
    }
    _con = _;
    return _chart;
  };

  _chart.useGeoTypes = function (geoTypesEnabled) {
    _chart._useGeoTypes = geoTypesEnabled;
    return _chart;
  };

  // TODO(croot): pixel ratio should probably be configured on the backend
  // rather than here to deal with scenarios where data is used directly
  // in pixel-space.
  _chart.usePixelRatio = function (usePixelRatio) {
    if (!arguments.length) {
      return _usePixelRatio;
    }

    _usePixelRatio = Boolean(usePixelRatio);
    if (_usePixelRatio) {
      _pixelRatio = window.devicePixelRatio || 1;
    } else {
      _pixelRatio = 1;
    }

    return _chart;
  };

  _chart._getPixelRatio = function () {
    return _pixelRatio;
  };

  _chart.setSample = function () {
    _layers.forEach(function (layerName) {
      var layer = _layerNames[layerName];
      if (layer && typeof layer.setSample === "function") {
        layer.setSample();
      }
    });
  };

  _chart.setDataAsync(function (group, callback) {
    var bounds = _chart.getDataRenderBounds();
    _chart._updateXAndYScales(bounds);
    _chart._vegaSpec = genLayeredVega(_chart);
    var nonce = _chart.con().renderVega(_chart.__dcFlag__, JSON.stringify(_chart._vegaSpec), {}, callback);
    _renderBoundsMap[nonce] = bounds;
  });

  _chart.data(function (group) {
    if (_chart.dataCache !== null) {
      return _chart.dataCache;
    }

    var bounds = _chart.getDataRenderBounds();
    _chart._updateXAndYScales(bounds);

    _chart._vegaSpec = genLayeredVega(_chart, group, (0, _coreAsync.lastFilteredSize)(group.getCrossfilterId()));

    var result = _chart.con().renderVega(_chart.__dcFlag__, JSON.stringify(_chart._vegaSpec));

    _renderBoundsMap[result.nonce] = bounds;
    return result;
  });

  _chart._getXScaleName = function () {
    return _xScaleName;
  };

  _chart._getYScaleName = function () {
    return _yScaleName;
  };

  _chart._updateXAndYScales = function (renderBounds) {
    // renderBounds should be in this order - top left, top-right, bottom-right, bottom-left
    var useRenderBounds = renderBounds && renderBounds.length === 4 && renderBounds[0] instanceof Array && renderBounds[0].length === 2;

    if (_x === null) {
      _x = d3.scale.linear();
    }

    if (_y === null) {
      _y = d3.scale.linear();
    }

    // if _chart.useLonLat() is not true, the chart bounds have already been projected into mercator space
    // TODO(adb): could probably collape this into line 353
    if (_chart._useGeoTypes && typeof _chart.useLonLat === "function" && _chart.useLonLat()) {
      _xLatLngBnds = [renderBounds[0][0], renderBounds[1][0]];
      _yLatLngBnds = [renderBounds[2][1], renderBounds[0][1]];
    }

    if (useRenderBounds) {
      if (typeof _chart.useLonLat === "function" && _chart.useLonLat()) {
        _x.domain([_chart.conv4326To900913X(renderBounds[0][0]), _chart.conv4326To900913X(renderBounds[1][0])]);
        _y.domain([_chart.conv4326To900913Y(renderBounds[2][1]), _chart.conv4326To900913Y(renderBounds[0][1])]);
      } else {
        _x.domain([renderBounds[0][0], renderBounds[1][0]]);
        _y.domain([renderBounds[2][1], renderBounds[0][1]]);
      }
    } else {
      var layers = getLayers();
      var xRanges = [];
      var yRanges = [];

      for (layer in layers) {
        var xDim = layer.xDim(),
            yDim = layer.yDim();
        if (xDim) {
          var range = xDim.getFilter();
          if (range !== null) {
            xRanges.push(range);
          }
        }
        if (yDim) {
          var range = yDim.getFilter();
          if (range !== null) {
            yRanges.push(range);
          }
        }
      }

      if (xRanges.length) {
        var xRange = xRanges.reduce(function (prevVal, currVal) {
          return [Math.min(prevVal[0], currVal[0]), Math.max(prevVal[1], currVal[1])];
        }, [Number.MAX_VALUE, -Number.MAX_VALUE]);

        if (typeof _chart.useLonLat === "function" && _chart.useLonLat()) {
          _x.domain([_chart.conv4326To900913X(xRange[0]), _chart.conv4326To900913X(xRange[1])]);
        } else {
          _x.domain(xRange);
        }
      } else {
        _x.domain([0.001, 0.999]);
      }

      if (yRanges.length) {
        var yRange = yRanges.reduce(function (prevVal, currVal) {
          return [Math.min(prevVal[0], currVal[0]), Math.max(prevVal[1], currVal[1])];
        }, [Number.MAX_VALUE, -Number.MAX_VALUE]);

        if (typeof _chart.useLonLat === "function" && _chart.useLonLat()) {
          _y.domain([_chart.conv4326To900913X(yRange[0]), _chart.conv4326To900913X(yRange[1])]);
        } else {
          _y.domain(yRange);
        }
      } else {
        _y.domain([0.001, 0.999]);
      }
    }
  };

  _chart._determineScaleType = function (scale) {
    var scaleType = null;
    if (scale.rangeBand !== undefined) {
      return "ordinal";
    }
    if (scale.exponent !== undefined) {
      return "power";
    }
    if (scale.base !== undefined) {
      return "log";
    }
    if (scale.quantiles !== undefined) {
      return "quantiles";
    }
    if (scale.interpolate !== undefined) {
      return "linear";
    }
    return "quantize";
  };

  function removeOverlay(overlay) {
    _chart._removeOverlay(overlay);
  }

  _chart._doRender = function (data, redraw, doNotForceData) {
    if (!data && Boolean(!doNotForceData)) {
      data = _chart.data();
    }

    if (data.vega_metadata) {
      var vega_metadata = JSON.parse(data.vega_metadata);
      for (var layerName in _layerNames) {
        if (typeof _layerNames[layerName]._updateFromMetadata === "function") {
          _layerNames[layerName]._updateFromMetadata(vega_metadata, layerName);
        }
      }
    }

    var state = (0, _stackedLegend.getLegendStateFromChart)(_chart, useMap);
    _legend.setState(state);

    if (_chart.isLoaded()) {
      if (Object.keys(data).length) {
        _chart._setOverlay(data.image, _renderBoundsMap[data.nonce], data.nonce, browser, Boolean(redraw));
        _hasBeenRendered = true;
      } else {
        _chart._setOverlay(null, null, null, browser, Boolean(redraw));
      }
    } else {
      _chart.map().once("style.load", function () {
        _chart._doRender(data, redraw, doNotForceData);
      });
    }
  };

  _chart._doRedraw = function () {
    _chart._doRender(null, true);
  };

  _chart.minPopupShapeBoundsArea = function (minPopupShapeBoundsArea) {
    if (!arguments.length) {
      return _minPopupShapeBoundsArea;
    }
    _minPopupShapeBoundsArea = minPopupShapeBoundsArea;
    return _chart;
  };

  _chart.popupSearchRadius = function (popupSearchRadius) {
    if (!arguments.length) {
      return _popupSearchRadius;
    }
    _popupSearchRadius = popupSearchRadius;
    return _chart;
  };

  _chart.getClosestResult = function getClosestResult(point, callback) {
    var height = typeof _chart.effectiveHeight === "function" ? _chart.effectiveHeight() : _chart.height();
    var pixelRatio = _chart._getPixelRatio() || 1;
    var pixel = new TPixel({
      x: Math.round(point.x * pixelRatio),
      y: Math.round((height - point.y) * pixelRatio)
    });

    if (!point) {
      return;
    }

    var cnt = 0;
    var layerObj = {};
    _layers.forEach(function (layerName) {
      var layer = _layerNames[layerName];
      if (layer.getPopupAndRenderColumns && layer.hasPopupColumns && layer.hasPopupColumns()) {
        layerObj[layerName] = layer.getPopupAndRenderColumns(_chart);
        ++cnt;
      }
    });

    // TODO best to fail, skip cb, or call cb wo args?
    if (!cnt) {
      return;
    }

    return _chart.con().getResultRowForPixel(_chart.__dcFlag__, pixel, layerObj, [function (err, results) {
      if (err) {
        throw new Error("getResultRowForPixel failed with message: " + err.message);
      } else {
        return callback(results[0]);
      }
    }], Math.ceil(_popupSearchRadius * pixelRatio));
  };

  _chart.measureValue = function (value, key) {
    var customFormatter = _chart.valueFormatter();
    // hack to undo the popup concatenation like "AVG(arrdelay)"
    var keyTrimmed = null;
    if (key) {
      keyTrimmed = key.replace(/.*\((.*)\).*/, "$1");
    }
    return keyTrimmed && customFormatter && customFormatter(value, keyTrimmed) || value;
  };

  _chart.displayPopup = function displayPopup(result, animate) {
    if (!_popupDisplayable || !result || !result.row_set || !result.row_set.length) {
      return;
    }
    if (_chart.select("." + _popupDivClassName).empty()) {
      // only one popup at a time
      var _layer5 = _layerNames[result.vega_table_name];
      if (_layer5 && _layer5.areResultsValidForPopup(result.row_set)) {
        var mapPopup = _chart.root().append("div").attr("class", _popupDivClassName);
        _layer5.displayPopup(_chart, mapPopup, result, _minPopupShapeBoundsArea, animate);
      }
    }
  };

  _chart.hidePopup = function hidePopup(animate) {
    var popupElem = _chart.select("." + _popupDivClassName);
    if (!popupElem.empty()) {
      for (var i = 0; i < _layers.length; ++i) {
        var layerName = _layers[i];
        var _layer6 = _layerNames[layerName];
        if (_layer6 && _layer6.isPopupDisplayed(_chart)) {
          // TODO(croot): can this be improved? I presume only
          // one popup can be shown at a time
          if (animate) {
            _layer6.hidePopup(_chart, function () {
              _chart.select("." + _popupDivClassName).remove();
            });
          } else {
            _chart.select("." + _popupDivClassName).remove();
          }
          break;
        }
      }
    }
  };

  var anchored = _chart.anchor(parent, chartGroup);
  var legend = anchored.root().append("div").attr("class", "legend");
  _legend = new _legendables.Legend(legend.node());

  _legend.on("open", _stackedLegend.handleLegendOpen.bind(_chart));
  _legend.on("lock", _stackedLegend.handleLegendLock.bind(_chart));
  _legend.on("input", _stackedLegend.handleLegendInput.bind(_chart));
  _legend.on("toggle", _stackedLegend.handleLegendToggle.bind(_chart));
  _legend.on("doneRender", _stackedLegend.handleLegendDoneRender.bind(_chart));

  _chart.legend = function (l) {
    return _legend;
  };

  return anchored;
}

function valuesOb(obj) {
  return Object.keys(obj).map(function (key) {
    return obj[key];
  });
}

function genLayeredVega(chart) {
  var pixelRatio = chart._getPixelRatio();
  var width = (typeof chart.effectiveWidth === "function" ? chart.effectiveWidth() : chart.width()) * pixelRatio;
  var height = (typeof chart.effectiveHeight === "function" ? chart.effectiveHeight() : chart.height()) * pixelRatio;

  var xdom = chart.x().domain();
  var ydom = chart.y().domain();

  var data = [];

  var scales = [{
    name: chart._getXScaleName(),
    type: chart._determineScaleType(chart.x()),
    domain: chart.x().domain(),
    range: "width"
  }, {
    name: chart._getYScaleName(),
    type: chart._determineScaleType(chart.y()),
    domain: chart.y().domain(),
    range: "height"
  }];

  // NOTE(adb): When geo types are enabled, vega spatial projections are applied and the scales for the x and y properties are not being used. However, we still need the legacy scaling terms to properly size poly popups on hover, which is why _xLatLngBnds, etc are separate scales
  var projections = [];
  if (chart._useGeoTypes) {
    projections.push({
      name: "mercator_map_projection",
      type: "mercator",
      bounds: {
        x: chart.xLatLngBnds(),
        y: chart.yLatLngBnds()
      }
    });
  }
  var marks = [];

  chart.getLayerNames().forEach(function (layerName) {
    var layerVega = chart.getLayer(layerName).genVega(chart, layerName);

    data.push.apply(data, _toConsumableArray(layerVega.data));
    scales.push.apply(scales, _toConsumableArray(layerVega.scales));
    marks.push.apply(marks, _toConsumableArray(layerVega.marks));
  });

  var vegaSpec = {
    width: Math.round(width),
    height: Math.round(height),
    data: data,
    scales: scales,
    projections: projections,
    marks: marks
  };

  return vegaSpec;
}

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.getLegendStateFromChart = getLegendStateFromChart;
exports.handleLegendToggle = handleLegendToggle;
exports.handleLegendDoneRender = handleLegendDoneRender;
exports.handleLegendOpen = handleLegendOpen;
exports.handleLegendLock = handleLegendLock;
exports.handleLegendInput = handleLegendInput;
exports.toLegendState = toLegendState;
var hasLegendOpenProp = function hasLegendOpenProp(color) {
  return _typeof(color.legend) === "object" && color.legend.hasOwnProperty("open");
};
var hasLegendLockedProp = function hasLegendLockedProp(color) {
  return _typeof(color.legend) === "object" && color.legend.hasOwnProperty("locked");
};
var hasLegendTitleProp = function hasLegendTitleProp(color) {
  return _typeof(color.legend) === "object" && color.legend.hasOwnProperty("title");
};
var handleColorLegendOpenUndefined = function handleColorLegendOpenUndefined(color) {
  return typeof color.legend.open === "undefined" ? true : color.legend.open;
};
var handleNonStackedOpenState = function handleNonStackedOpenState(state) {
  return state.type === "gradient" ? Object.assign({}, state, { open: true }) : state;
};

var TOP_PADDING = 56;
var LASSO_TOOL_VERTICAL_SPACE = 120;

function setLegendState(setter) {
  return function setState(state) {
    return _extends({}, state, {
      encoding: _extends({}, state.encoding, {
        color: _extends({}, state.encoding.color, {
          legend: _extends({}, state.encoding.color.legend, setter(state.encoding.color))
        })
      })
    });
  };
}

function setColorState(setter) {
  return function setState(state) {
    return _extends({}, state, {
      encoding: _extends({}, state.encoding, {
        color: _extends({}, state.encoding.color, setter(state.encoding.color))
      })
    });
  };
}

function setColorScaleDomain(domain) {
  return function setState(state) {
    return _extends({}, state, {
      encoding: _extends({}, state.encoding, {
        color: _extends({}, state.encoding.color, {
          scale: _extends({}, state.encoding.color.scale, {
            domain: domain
          })
        })
      })
    });
  };
}

function getLegendStateFromChart(chart, useMap) {
  return toLegendState(chart.getLayerNames().map(function (layerName) {
    var layer = chart.getLayer(layerName);
    var color = layer.getState().encoding.color;
    if (_typeof(color.scale) === "object" && color.scale.domain === "auto") {
      return _extends({}, color, {
        scale: _extends({}, color.scale, {
          domain: layer.colorDomain()
        })
      });
    } else {
      return color;
    }
  }), chart, useMap);
}

function handleLegendToggle() {
  this.legend().setState(_extends({}, this.legend().state, {
    open: !this.legend().state.open
  }));
}

function handleLegendDoneRender() {
  var _this = this;

  this.root().classed("horizontal-lasso-tools", function () {
    var legendNode = _this.root().select(".legendables").node();
    var isHorizontal = legendNode && legendNode.clientHeight > _this.height() - LASSO_TOOL_VERTICAL_SPACE;

    _this.root().select(".mapd-draw-button-control-group").style("width", isHorizontal ? legendNode.clientWidth + 2 + "px" : "auto");

    return isHorizontal;
  });
}

function handleLegendOpen() {
  var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

  this.getLayers()[index].setState(setLegendState(function (color) {
    return {
      open: hasLegendOpenProp(color) ? !handleColorLegendOpenUndefined(color) : false
    };
  }));
  this.legend().setState(getLegendStateFromChart(this));
}

function handleLegendLock(_ref) {
  var locked = _ref.locked,
      _ref$index = _ref.index,
      index = _ref$index === undefined ? 0 : _ref$index;

  var layer = this.getLayers()[index];

  layer.setState(setLegendState(function (color) {
    return {
      locked: typeof locked === "undefined" ? true : !locked
    };
  }));

  var _layer$getState = layer.getState(),
      color = _layer$getState.encoding.color;

  if (_typeof(color.scale) === "object") {
    if (color.legend.locked) {
      layer.setState(setColorScaleDomain(layer.colorDomain()));
    } else {
      layer.setState(setColorScaleDomain("auto"));
    }
  }

  this.legend().setState(getLegendStateFromChart(this));
}

function handleLegendInput(_ref2) {
  var domain = _ref2.domain,
      _ref2$index = _ref2.index,
      index = _ref2$index === undefined ? 0 : _ref2$index;

  var layer = this.getLayers()[index];
  var scale = layer.getState().encoding.color.scale;


  if ((typeof scale === "undefined" ? "undefined" : _typeof(scale)) === "object") {
    layer.setState(setColorScaleDomain(domain));
  } else {
    layer.setState(setColorState(function () {
      return {
        domain: domain
      };
    }));
  }

  this.legend().setState(getLegendStateFromChart(this));
  this.renderAsync();
}

function legendState(state) {
  var useMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  if (state.type === "ordinal") {
    return {
      type: "nominal",
      title: hasLegendTitleProp(state) ? state.legend.title : "Legend",
      open: hasLegendOpenProp(state) ? state.legend.open : true,
      range: state.range,
      domain: state.domain,
      position: useMap ? "bottom-left" : "top-right"
    };
  } else if (state.type === "quantitative") {
    return {
      type: "gradient",
      title: hasLegendTitleProp(state) ? state.legend.title : "Legend",
      locked: hasLegendLockedProp(state) ? state.legend.locked : false,
      open: hasLegendOpenProp(state) ? state.legend.open : true,
      range: state.range,
      domain: state.domain,
      position: "bottom-left"
    };
  } else if (state.type === "quantize") {
    var scale = state.scale;

    return {
      type: "gradient",
      title: hasLegendTitleProp(state) ? state.legend.title : "Legend",
      locked: hasLegendLockedProp(state) ? state.legend.locked : false,
      open: hasLegendOpenProp(state) ? state.legend.open : true,
      range: scale.range,
      domain: scale.domain,
      position: "bottom-left"
    };
  } else {
    return {};
  }
}

function toLegendState() {
  var states = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var chart = arguments[1];
  var useMap = arguments[2];

  if (states.length === 1) {
    return handleNonStackedOpenState(legendState(states[0], useMap));
  } else if (states.length) {
    return {
      type: "stacked",
      list: states.map(legendState),
      open: typeof chart.legendOpen() === "undefined" ? true : chart.legendOpen(),
      maxHeight: chart.height() - TOP_PADDING
    };
  } else {
    return {};
  }
}

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = bindEventHandlers;

var _coreAsync = __webpack_require__(4);

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* istanbul ignore next */
function bindAll(funcNames, thisArg) {
  funcNames.forEach(function (funcName) {
    if (!thisArg[funcName]) {
      return;
    }
    thisArg[funcName] = thisArg[funcName].bind(thisArg);
  });
}

/* istanbul ignore next */
function isInChart(chart, container, e, mousePos) {
  var width = chart.effectiveWidth();
  var height = chart.effectiveHeight();
  var margins = chart.margins();
  var left = margins.left;
  var top = margins.top;
  var rect = container.getBoundingClientRect();

  e = e.touches ? e.touches[0] : e;

  var diffX = e.clientX - left - rect.left - container.clientLeft;
  var diffY = e.clientY - top - rect.top - container.clientTop;

  if (mousePos) {
    mousePos.x = diffX;
    mousePos.y = diffY;
  }

  return diffX >= 0 && diffX < width && diffY >= 0 && diffY < height;
}

/* istanbul ignore next */

var BaseHandler = function () {
  function BaseHandler(chart, container, dataBounds, dataScale, dataOffset, filterDimensionCB, chartRedrawCB, mapboxglModule) {
    _classCallCheck(this, BaseHandler);

    this._chart = chart;
    this._map = chart.map();
    this._container = container;
    this._currDataBounds = dataBounds;
    this._scale = dataScale;
    this._offset = dataOffset;
    this._filterDimensionCB = filterDimensionCB;
    this._chartRedrawCB = chartRedrawCB;
    this._mapboxglModule = mapboxglModule;
  }

  _createClass(BaseHandler, [{
    key: "isEnabled",
    value: function isEnabled() {
      return Boolean(this._enabled);
    }
  }, {
    key: "isActive",
    value: function isActive() {
      return Boolean(this._active);
    }
  }, {
    key: "enable",
    value: function enable() {
      if (this.isEnabled()) {
        return;
      }

      this._enable();
      this._enabled = true;
    }
  }, {
    key: "disable",
    value: function disable() {
      if (!this.isEnabled()) {
        return;
      }

      this._disable();
      this._enabled = false;
    }
  }, {
    key: "_fireEvent",
    value: function _fireEvent(type, e, eventMetaData) {
      if (!eventMetaData) {
        eventMetaData = {};
      }
      eventMetaData.originalEvent = e;

      return this._map.fire(type, eventMetaData);
    }
  }]);

  return BaseHandler;
}();

/* istanbul ignore next */


function testProp(props, docStyle) {
  for (var i = 0; i < props.length; i = i + 1) {
    if (props[i] in docStyle) {
      return props[i];
    }
  }
}

/* istanbul ignore next */
function createHTMLElement(tagName, className, container) {
  var el = document.createElement(tagName);
  if (className) {
    el.className = className;
  }
  if (container) {
    container.appendChild(el);
  }
  return el;
}

/* istanbul ignore next */

var BoxZoomHandler = function (_BaseHandler) {
  _inherits(BoxZoomHandler, _BaseHandler);

  function BoxZoomHandler(chart, container, dataBounds, dataScale, dataOffset, filterDimensionsCB, chartRedrawCB, mapboxglModule) {
    _classCallCheck(this, BoxZoomHandler);

    var _this = _possibleConstructorReturn(this, (BoxZoomHandler.__proto__ || Object.getPrototypeOf(BoxZoomHandler)).call(this, chart, container, dataBounds, dataScale, dataOffset, filterDimensionsCB, chartRedrawCB, mapboxglModule));

    _this._startBoxZoomPos = null;
    _this._boxZoomBox = null;
    var docStyle = document.documentElement.style;
    _this._selectProp = testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"], docStyle);
    _this._transformProp = testProp(["transform", "WebkitTransform"], docStyle);

    bindAll(["onBoxZoom", "onMouseMove", "onMouseUp", "onKeyDown"], _this);
    return _this;
  }

  _createClass(BoxZoomHandler, [{
    key: "_enable",
    value: function _enable() {
      this._container.addEventListener("mousedown", this.onBoxZoom);
    }
  }, {
    key: "_disable",
    value: function _disable() {
      if (this._active) {
        this._finish();
        this._fireEvent("boxzoomcancel", {});
      }
      this._container.removeEventListener("mousedown", this.onBoxZoom);
    }
  }, {
    key: "_enableDrag",
    value: function _enableDrag() {
      if (this._selectProp) {
        document.documentElement.style[this._selectProp] = this._userSelect;
      }
    }
  }, {
    key: "_disableDrag",
    value: function _disableDrag() {
      if (this._selectProp) {
        this._userSelect = document.documentElement.style[this._selectProp];
        document.documentElement.style[this._selectProp] = "none";
      }
    }
  }, {
    key: "onBoxZoom",
    value: function onBoxZoom(e) {
      // make sure the mouse position is in the
      // chart
      var pos = new this._mapboxglModule.Point(0, 0);
      if (!isInChart(this._chart, this._container, e, pos)) {
        return;
      }

      if (!(e.shiftKey && e.button === 0)) {
        return;
      }

      document.addEventListener("mousemove", this.onMouseMove, false);
      document.addEventListener("keydown", this.onKeyDown, false);
      document.addEventListener("mouseup", this.onMouseUp, false);

      this._disableDrag();

      this._startBoxZoomPos = pos;
      this._active = true;
    }
  }, {
    key: "onMouseMove",
    value: function onMouseMove(e) {
      var p0 = this._startBoxZoomPos;
      var p1 = new this._mapboxglModule.Point(0, 0);

      if (!isInChart(this._chart, this._container, e, p1) && !this._active) {
        return;
      }

      if (!this._boxZoomBox) {
        var rootNode = this._chart.root().node();
        this._boxZoomBox = createHTMLElement("div", "mapboxgl-boxzoom", rootNode);
        rootNode.classList.add("mapboxgl-crosshair");
        this._fireEvent("boxzoomstart", e);
      }

      var minX = Math.min(p0.x, p1.x);
      var maxX = Math.max(p0.x, p1.x);
      var minY = Math.min(p0.y, p1.y);
      var maxY = Math.max(p0.y, p1.y);

      var margins = this._chart.margins();

      this._boxZoomBox.style[this._transformProp] = "translate(" + (minX + margins.left) + "px," + (minY + margins.top) + "px)";
      this._boxZoomBox.style.width = maxX - minX + "px";
      this._boxZoomBox.style.height = maxY - minY + "px";
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp(e) {
      var _this2 = this;

      if (e.button !== 0) {
        return;
      }

      var p0 = this._startBoxZoomPos;
      var p1 = new this._mapboxglModule.Point(0, 0);
      if (!isInChart(this._chart, this._container, e, p1) && !this._active) {
        return;
      }

      this._finish();

      if (p0.x === p1.x && p0.y === p1.y) {
        this._fireEvent("boxzoomcancel", e);
      } else {
        var startPos = this._chart.unproject(p0);
        var endPos = this._chart.unproject(p1);

        var xmin = Math.min(startPos.x, endPos.x);
        var xmax = Math.max(startPos.x, endPos.x);

        var ymin = Math.min(startPos.y, endPos.y);
        var ymax = Math.max(startPos.y, endPos.y);

        var bounds = this._chart._fitToMaxBounds([[xmin, ymin], [xmax, ymax]], true);
        xmin = bounds[0][0];
        xmax = bounds[1][0];
        ymin = bounds[0][1];
        ymax = bounds[1][1];

        this._fireEvent("movestart", e);
        this._fireEvent("zoomstart", e);

        var startminx = this._currDataBounds[0][0];
        var startmaxx = this._currDataBounds[0][1];
        var endminx = xmin;
        var endmaxx = xmax;

        var startminy = this._currDataBounds[1][0];
        var startmaxy = this._currDataBounds[1][1];
        var endminy = ymin;
        var endmaxy = ymax;

        var diffminx = endminx - startminx;
        var diffmaxx = endmaxx - startmaxx;
        var diffminy = endminy - startminy;
        var diffmaxy = endmaxy - startmaxy;

        var duration = 500;
        this._active = true;

        var ease = this._mapboxglModule.util.bezier(0.25, 0.1, 0.25, 1);

        var abortFunc = this._mapboxglModule.util.browser.timed(function (t) {
          _this2._perFrameFunc(e, ease(t), startminx, diffminx, startmaxx, diffmaxx, startminy, diffminy, startmaxy, diffmaxy);
          if (t === 1) {
            _this2._boxZoomFinished(e, xmin, xmax, ymin, ymax);
          }
        }, duration);
      }
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(e) {
      if (e.keyCode === 27) {
        this._finish();
        this._fireEvent("boxzoomcancel", e);
      }
    }
  }, {
    key: "_boxZoomFinished",
    value: function _boxZoomFinished(e, xmin, xmax, ymin, ymax) {
      this._fireEvent("zoomend", e);
      this._fireEvent("moveend", e);

      this._filterDimensionCB([xmin, xmax], [ymin, ymax]);

      // upon box zoom, elasticity is turned off
      this._chart.elasticX(false);
      this._chart.elasticY(false);

      var bounds = [[xmin, ymax], [xmax, ymax], [xmax, ymin], [xmin, ymin]];

      (0, _coreAsync.redrawAllAsync)(this._chart.chartGroup());

      this._active = false;
      this._fireEvent("boxzoomend", e, {
        boxZoomBounds: bounds
      });
    }
  }, {
    key: "_perFrameFunc",
    value: function _perFrameFunc(e, t, startminx, diffminx, startmaxx, diffmaxx, startminy, diffminy, startmaxy, diffmaxy) {
      var xrange = [startminx + t * diffminx, startmaxx + t * diffmaxx];

      var yrange = [startminy + t * diffminy, startmaxy + t * diffmaxy];

      var xDiff = xrange[1] - xrange[0];
      var yDiff = yrange[1] - yrange[0];
      var xBoundsDiff = this._currDataBounds[0][1] - this._currDataBounds[0][0];
      var yBoundsDiff = this._currDataBounds[1][1] - this._currDataBounds[1][0];
      var xBoundsScale = xDiff / xBoundsDiff;
      var yBoundsScale = yDiff / yBoundsDiff;

      this._scale[0] = xBoundsScale;
      this._scale[1] = yBoundsScale;
      this._offset[0] = (xrange[0] - this._currDataBounds[0][0]) / xBoundsDiff;
      this._offset[1] = (yrange[0] - this._currDataBounds[1][0]) / yBoundsDiff;

      this._filterDimensionCB(xrange, yrange);

      this._chart._updateXAndYScales(this._chart.getDataRenderBounds());
      this._chartRedrawCB();

      this._fireEvent("move", e);
    }
  }, {
    key: "_finish",
    value: function _finish() {
      this._active = false;

      document.removeEventListener("mousemove", this.onMouseMove, false);
      document.removeEventListener("keydown", this.onKeyDown, false);
      document.removeEventListener("mouseup", this.onMouseUp, false);

      var rootNode = this._chart.root().node();
      rootNode.classList.remove("mapboxgl-crosshair");

      if (this._boxZoomBox) {
        this._boxZoomBox.parentNode.removeChild(this._boxZoomBox);
        this._boxZoomBox = null;
      }

      this._enableDrag();
    }
  }]);

  return BoxZoomHandler;
}(BaseHandler);

/* istanbul ignore next */


var ScrollZoomHandler = function (_BaseHandler2) {
  _inherits(ScrollZoomHandler, _BaseHandler2);

  function ScrollZoomHandler(chart, container, dataBounds, dataScale, dataOffset, filterDimensionsCB, chartRedrawCB, mapboxglModule, browser) {
    _classCallCheck(this, ScrollZoomHandler);

    var _this3 = _possibleConstructorReturn(this, (ScrollZoomHandler.__proto__ || Object.getPrototypeOf(ScrollZoomHandler)).call(this, chart, container, dataBounds, dataScale, dataOffset, filterDimensionsCB, chartRedrawCB, mapboxglModule));

    _this3._startWheelPos = null;
    _this3._wheelType = null;
    _this3._lastWheelVal = 0;
    _this3._singularWheelTimeout = null;
    _this3._wheelTimeout = null;
    _this3._browser = browser;

    bindAll(["_onSingularWheelTimeout", "_onWheelTimeout", "onWheel"], _this3);
    return _this3;
  }

  _createClass(ScrollZoomHandler, [{
    key: "_onSingularWheelTimeout",
    value: function _onSingularWheelTimeout() {
      this._wheelType = "wheel";
      this._wheelZoom(true, -this._lastWheelVal);
    }
  }, {
    key: "_onWheelTimeout",
    value: function _onWheelTimeout() {
      this._wheelZoom(true, -this._lastWheelVal);
    }

    // enable() {
    //   super.enable()
    //   console.log(`CROOT - scrollZoom enable ${this._enabled} ${this.isEnabled()}`)
    //   console.trace()
    // }

    // disable() {
    //   super.disable()
    //   console.log(`CROOT - scrollZoom disable ${this._enabled} ${this.isEnabled()}`)
    //   console.trace()
    // }

  }, {
    key: "_enable",
    value: function _enable() {
      this._container.addEventListener("wheel", this.onWheel);
      this._container.addEventListener("mousewheel", this.onWheel);
    }
  }, {
    key: "_disable",
    value: function _disable() {
      this._container.removeEventListener("wheel", this.onWheel);
      this._container.removeEventListener("mousewheel", this.onWheel);
    }
  }, {
    key: "onWheel",
    value: function onWheel(e) {
      var value = 0;

      // make sure the mouse position is in the
      // chart
      var pos = new this._mapboxglModule.Point(0, 0);
      if (!isInChart(this._chart, this._container, e, pos)) {
        return;
      }

      if (e.type === "wheel") {
        value = e.deltaY;
        // Firefox doubles the values on retina screens...
        if (this._browser.isFirefox && e.deltaMode === window.WheelEvent.DOM_DELTA_PIXEL) {
          value = value / (window.devicePixelRatio || 1);
        }

        if (e.deltaMode === window.WheelEvent.DOM_DELTA_LINE) {
          value = value * 40;
        }
      } else if (e.type === "mousewheel") {
        value = -e.wheelDeltaY;
        if (this._browser.isSafari) {
          value = value / 3;
        }
      }

      var now = Date.now();
      var timeDelta = now - (this._time || 0);

      this._startWheelPos = pos;
      this._time = now;

      if (value !== 0 && value % 4.000244140625 === 0) {
        // This one is definitely a mouse wheel event.
        this._wheelType = "wheel";

        // Normalize this value to match trackpad.
        value = Math.floor(value / 4);
      } else if (value !== 0 && Math.abs(value) < 4) {
        // This one is definitely a trackpad event because it is so small.
        this._wheelType = "trackpad";
      } else if (timeDelta > 400) {
        // This is likely a new scroll action.
        this._wheelType = null;
        this._lastWheelVal = value;

        // Start a timeout in case this was a singular event, and dely it by up to 40ms.
        this._singularWheelTimeout = setTimeout(this._onSingularWheelTimeout, 40);
      } else if (!this._wheelType) {
        // This is a repeating event, but we don"t know the type of event just yet.
        // If the delta per time is small, we assume it"s a fast trackpad; otherwise we switch into wheel mode.
        this._wheelType = Math.abs(timeDelta * value) < 200 ? "trackpad" : "wheel";
      }

      // Slow down zoom if shift key is held for more precise zooming
      if (e.shiftKey && value) {
        value = value / 4;
      }

      // Only fire the callback if we actually know what type of scrolling device the user uses.
      if (this._wheelType) {
        // Make sure our delayed event isn"t fired again, because we accumulate
        // the previous event (which was less than 40ms ago) into this event.
        if (this._singularWheelTimeout) {
          clearTimeout(this._singularWheelTimeout);
          this._singularWheelTimeout = null;
          value = value + this._lastWheelVal;
        }

        this._lastWheelVal = value;

        if (this._wheelTimeout) {
          clearTimeout(this._wheelTimeout);
          this._wheelTimeout = null;
        }

        // Start a timeout to do a full re-render when the scrolling event
        // is finished. Set it at an arbitrary timeout - 50ms
        this._wheelTimeout = setTimeout(this._onWheelTimeout, 50);

        this._wheelZoom(false, -value, e);
      }

      e.preventDefault();
    }
  }, {
    key: "_wheelZoom",
    value: function _wheelZoom(doFullRender, delta, e) {
      if (!doFullRender && delta === 0) {
        return;
      }

      if (delta !== 0) {
        // Scale by sigmoid of scroll wheel delta.
        var scale = 2 / (1 + Math.exp(-Math.abs(delta / 100)));
        if (delta < 0 && scale !== 0) {
          scale = 1 / scale;
        }

        scale = 1 / scale;

        var xRange = this._chart.xRange();
        var yRange = this._chart.yRange();

        if (xRange === null) {
          xRange = [0, 0];
        }

        if (yRange === null) {
          yRange = [0, 0];
        }

        var wheelData = this._chart.unproject(this._startWheelPos);

        var xDiff = scale * (xRange[1] - xRange[0]);
        var yDiff = scale * (yRange[1] - yRange[0]);

        // we want to keep wheelData where it is in pixel space,
        // so we need to extrapolate from there to get the data bounds
        // of the window

        // NOTE: the following is currently only designed
        // to work with linear scales.

        // TODO(croot): come up with a generic extrapolation
        // technique for any scale.

        var width = this._chart.effectiveWidth();
        var height = this._chart.effectiveHeight();

        var xmin = wheelData.x - xDiff * (this._startWheelPos.x / width);
        var xmax = xmin + xDiff;

        var ymin = wheelData.y - yDiff * ((height - this._startWheelPos.y - 1) / height);
        var ymax = ymin + yDiff;

        var bounds = this._chart._fitToMaxBounds([[xmin, ymin], [xmax, ymax]], true);
        xmin = bounds[0][0];
        ymin = bounds[0][1];
        xmax = bounds[1][0];
        ymax = bounds[1][1];

        xDiff = xmax - xmin;
        yDiff = ymax - ymin;

        var xBoundsDiff = this._currDataBounds[0][1] - this._currDataBounds[0][0];
        var yBoundsDiff = this._currDataBounds[1][1] - this._currDataBounds[1][0];
        var xBoundsScale = xDiff / xBoundsDiff;
        var yBoundsScale = yDiff / yBoundsDiff;

        this._scale[0] = xBoundsScale;
        this._scale[1] = yBoundsScale;
        this._offset[0] = (xmin - this._currDataBounds[0][0]) / xBoundsDiff;
        this._offset[1] = (ymin - this._currDataBounds[1][0]) / yBoundsDiff;

        this._filterDimensionCB([xmin, xmax], [ymin, ymax]);
        this._fireEvent("zoom", e);
        this._fireEvent("move", e);
      }

      // upon zoom, elasticity is turned off
      this._chart.elasticX(false);
      this._chart.elasticY(false);

      if (doFullRender) {
        (0, _coreAsync.redrawAllAsync)(this._chart.chartGroup());
      } else {
        this._chart._updateXAndYScales(this._chart.getDataRenderBounds());
        this._chartRedrawCB();
      }
    }
  }]);

  return ScrollZoomHandler;
}(BaseHandler);

/* istanbul ignore next */


var DragPanHandler = function (_BaseHandler3) {
  _inherits(DragPanHandler, _BaseHandler3);

  function DragPanHandler(chart, container, dataBounds, dataScale, dataOffset, filterDimensionsCB, chartRedrawCB, mapboxglModule) {
    _classCallCheck(this, DragPanHandler);

    var _this4 = _possibleConstructorReturn(this, (DragPanHandler.__proto__ || Object.getPrototypeOf(DragPanHandler)).call(this, chart, container, dataBounds, dataScale, dataOffset, filterDimensionsCB, chartRedrawCB, mapboxglModule));

    _this4._dragInertia = [];
    _this4._startDragPos = null;
    _this4._dragPos = null;

    bindAll(["onDrag", "onMove", "onTouchEnd", "onMouseUp"], _this4);
    return _this4;
  }

  _createClass(DragPanHandler, [{
    key: "_enable",
    value: function _enable() {
      this._container.addEventListener("mousedown", this.onDrag);
      this._container.addEventListener("touchstart", this.onDrag);
    }
  }, {
    key: "_disable",
    value: function _disable() {
      this._container.removeEventListener("mousedown", this.onDrag);
      this._container.removeEventListener("touchstart", this.onDrag);

      document.removeEventListener("touchmove", this.onMove);
      document.removeEventListener("touchend", this.onTouchEnd);
      document.removeEventListener("mousemove", this.onMove);
      document.removeEventListener("mouseup", this.onMouseUp);

      if (this._active) {
        this._active = false;
        this._fireEvent("dragend", {});
        this._fireEvent("moveend", {});
      }
    }
  }, {
    key: "onDrag",
    value: function onDrag(e) {
      if (this._ignoreEvent(e)) {
        return;
      }

      // make sure the mouse position is in the chart
      var pos = new this._mapboxglModule.Point(0, 0);
      if (!isInChart(this._chart, this._container, e, pos)) {
        return;
      }

      if (this._active) {
        return;
      }

      if (e.touches) {
        document.addEventListener("touchmove", this.onMove);
        document.addEventListener("touchend", this.onTouchEnd);
      } else {
        document.addEventListener("mousemove", this.onMove);
        document.addEventListener("mouseup", this.onMouseUp);
      }

      this._active = false;
      this._startDragPos = this._dragPos = pos;
      this._dragInertia = [[Date.now(), this._dragPos]];
    }
  }, {
    key: "onMove",
    value: function onMove(e) {
      // make sure the mouse position is in the chart
      if (this._ignoreEvent(e)) {
        return;
      }

      var pos = new this._mapboxglModule.Point(0, 0);
      if (!isInChart(this._chart, this._container, e, pos) && !this._active) {
        return;
      }

      if (!this._active) {
        this._active = true;
        this._fireEvent("dragstart", e);
        this._fireEvent("movestart", e);
      }

      // TODO(croot): stop other animated pans/zooms here if/when
      // they're supported.
      this._drainInertiaBuffer();
      this._dragInertia.push([Date.now(), pos]);

      var xRange = this._chart.xRange();
      if (xRange === null) {
        xRange = [0, 0];
      }

      var yRange = this._chart.yRange();
      if (yRange === null) {
        yRange = [0, 0];
      }

      var prevPos = this._chart.unproject(this._dragPos);
      var currPos = this._chart.unproject(pos);

      var deltaX = currPos.x - prevPos.x;
      var deltaY = currPos.y - prevPos.y;

      var xmin = xRange[0] - deltaX;
      var xmax = xRange[1] - deltaX;

      var ymin = yRange[0] - deltaY;
      var ymax = yRange[1] - deltaY;

      var bounds = this._chart._fitToMaxBounds([[xmin, ymin], [xmax, ymax]], true);
      deltaX = deltaX + (xmin - bounds[0][0]);
      deltaY = deltaY + (ymin - bounds[0][1]);
      xmin = bounds[0][0];
      ymin = bounds[0][1];
      xmax = bounds[1][0];
      ymax = bounds[1][1];

      var xBoundsDiff = this._currDataBounds[0][1] - this._currDataBounds[0][0];
      var yBoundsDiff = this._currDataBounds[1][1] - this._currDataBounds[1][0];

      this._offset[0] -= deltaX / xBoundsDiff;
      this._offset[1] -= deltaY / yBoundsDiff;

      this._filterDimensionCB([xmin, xmax], [ymin, ymax]);

      // upon pan, elasticity is turned off
      this._chart.elasticX(false);
      this._chart.elasticY(false);

      this._chart._updateXAndYScales(this._chart.getDataRenderBounds());
      this._chartRedrawCB();

      this._fireEvent("drag", e);
      this._fireEvent("move", e);

      this._dragPos = pos;

      e.preventDefault();
    }
  }, {
    key: "_onUp",
    value: function _onUp(e) {
      var _this5 = this;

      if (!this._active) {
        return;
      }

      this._active = false;
      this._fireEvent("dragend", e);
      this._drainInertiaBuffer();

      var finish = function finish() {
        (0, _coreAsync.redrawAllAsync)(_this5._chart.chartGroup());
        _this5._fireEvent("moveend", e);
      };

      var inertia = this._dragInertia;
      if (inertia.length < 2) {
        finish();
        return;
      }

      var last = inertia[inertia.length - 1];
      var first = inertia[0];
      var flingOffset = last[1].sub(first[1]);
      var flingDuration = (last[0] - first[0]) / 1000;

      if (flingDuration === 0 || last[1].equals(first[1])) {
        finish();
        return;
      }

      var inertiaLinearity = 0.3;
      var inertiaEasing = this._mapboxglModule.util.bezier(0, 0, inertiaLinearity, 1);
      var inertiaMaxSpeed = 1400; // pixels/second
      var inertiaDeceleration = 2500; // pixels/second squared

      // calculate px/s velocity & adjust for increased initial animation speed when easing out
      var velocity = flingOffset.mult(inertiaLinearity / flingDuration);
      var speed = velocity.mag(); // pixels/sec

      if (speed > inertiaMaxSpeed) {
        speed = inertiaMaxSpeed;
        velocity._unit()._mult(speed);
      }

      var duration = speed / (inertiaDeceleration * inertiaLinearity);
      var offset = velocity.mult(-duration / 2);

      finish();

      // TODO(croot):
      // Do the animated ease-out of the pan like mapbox
    }
  }, {
    key: "onTouchEnd",
    value: function onTouchEnd(e) {
      // TODO(croot): check that the event is in the chart window?
      if (this._ignoreEvent(e)) {
        return;
      }
      this._onUp(e);
      document.removeEventListener("touchmove", this.onMove);
      document.removeEventListener("touchend", this.onTouchEnd);
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp(e) {
      // TODO(croot): check that the event is in the chart window?
      if (this._ignoreEvent(e)) {
        return;
      }
      this._onUp(e);
      document.removeEventListener("mousemove", this.onMove);
      document.removeEventListener("mouseup", this.onMouseUp);
    }
  }, {
    key: "_ignoreEvent",
    value: function _ignoreEvent(e) {
      var map = this._chart.map();
      if (map.boxZoom && map.boxZoom.isActive()) {
        return true;
      }

      if (e.touches) {
        return e.touches.length > 1;
      } else {
        if (e.ctrlKey) {
          return true;
        }
        var buttons = 1;
        var button = 0;
        return e.type === "mousemove" ? e.buttons & buttons === 0 : e.button !== button;
      }
    }
  }, {
    key: "_drainInertiaBuffer",
    value: function _drainInertiaBuffer() {
      var now = Date.now();
      var cutoff = 160; // msec

      if (this._dragInertia) {
        while (this._dragInertia.length > 0 && now - this._dragInertia[0][0] > cutoff) {
          this._dragInertia.shift();
        }
      }
    }
  }]);

  return DragPanHandler;
}(BaseHandler);

/* istanbul ignore next */


function bindEventHandlers(chart, container, dataBounds, dataScale, dataOffset, filterDimensionsCB, chartRedrawCB, browser, mapboxglModule, enableInteractions) {
  var map = chart.map();
  var startPos = null;
  var tapped = null;

  map.scrollZoom = new ScrollZoomHandler(chart, container, dataBounds, dataScale, dataOffset, filterDimensionsCB, chartRedrawCB, mapboxglModule, browser);
  map.boxZoom = new BoxZoomHandler(chart, container, dataBounds, dataScale, dataOffset, filterDimensionsCB, chartRedrawCB, mapboxglModule);
  map.dragPan = new DragPanHandler(chart, container, dataBounds, dataScale, dataOffset, filterDimensionsCB, chartRedrawCB, mapboxglModule);

  container.addEventListener("mouseout", onMouseOut, false);
  container.addEventListener("mousedown", onMouseDown, false);
  container.addEventListener("mouseup", onMouseUp, false);
  container.addEventListener("mousemove", onMouseMove, false);
  container.addEventListener("touchstart", onTouchStart, false);
  container.addEventListener("touchend", onTouchEnd, false);
  container.addEventListener("touchmove", onTouchMove, false);
  container.addEventListener("touchcancel", onTouchCancel, false);
  container.addEventListener("click", onClick, false);
  container.addEventListener("dblclick", onDblClick, false);

  function destroyAllEvents() {
    container.removeEventListener("mouseout", onMouseOut);
    container.removeEventListener("mousedown", onMouseDown);
    container.removeEventListener("mouseup", onMouseUp);
    container.removeEventListener("mousemove", onMouseMove);
    container.removeEventListener("touchstart", onTouchStart);
    container.removeEventListener("touchend", onTouchEnd);
    container.removeEventListener("touchmove", onTouchMove);
    container.removeEventListener("touchcancel", onTouchCancel);
    container.removeEventListener("click", onClick);
    container.removeEventListener("dblclick", onDblClick);
  }

  function onMouseOut(e) {
    var pos = new mapboxglModule.Point(0, 0);
    if (isInChart(chart, container, e, pos)) {
      fireMouseEvent("mouseout", e, pos);
    }
  }

  function onMouseDown(e) {
    // TODO(croot): if we support animated
    // pans/zooms, we want to stop any currently
    // running animation here first:

    var pos = new mapboxglModule.Point(0, 0);
    if (isInChart(chart, container, e, pos)) {
      startPos = pos;
      fireMouseEvent("mousedown", e, pos);
    }
  }

  function onMouseUp(e) {
    var pos = new mapboxglModule.Point(0, 0);
    fireMouseEvent("mouseup", e, pos);
  }

  function onMouseMove(e) {
    var pos = new mapboxglModule.Point(0, 0);
    if (isInChart(chart, container, e, pos)) {
      if (map.dragPan && map.dragPan.isActive()) {
        return;
      }

      var target = e.toElement || e.target;
      while (target && target !== container) {
        target = target.parentNode;
      }
      if (target !== container) {
        return;
      }

      fireMouseEvent("mousemove", e, pos);
    }
  }

  function onTouchStart(e) {
    if (isInChart(chart, container, e)) {
      // TODO(croot): if we support animated
      // pans/zooms, we want to stop any currently
      // running animation here first:
      if (map.dragPan && map.dragPan.isActive() || map.bozZoom && map.boxZoom.isActive()) {
        return;
      }

      fireTouchEvent("touchstart", e);

      if (!e.touches || e.touches.length > 1) {
        return;
      }

      if (tapped) {
        clearTimeout(tapped);
        tapped = null;
        fireMouseEvent("dblclick", e);
      } else {
        tapped = setTimeout(onTouchTimeout, 300);
      }
    }
  }

  function onTouchMove(e) {
    if (isInChart(chart, container, e)) {
      fireTouchEvent("touchmove", e);
    }
  }

  function onTouchEnd(e) {
    if (isInChart(chart, container, e)) {
      fireTouchEvent("touchend", e);
    }
  }

  function onTouchCancel(e) {
    if (isInChart(chart, container, e)) {
      fireTouchEvent("touchcancel", e);
    }
  }

  function onTouchTimeout() {
    tapped = null;
  }

  function onClick(e) {
    var pos = new mapboxglModule.Point(0, 0);
    if (isInChart(chart, container, e, pos)) {
      if (pos.equals(startPos)) {
        fireMouseEvent("click", e, pos);
      }
    }
  }

  function onDblClick(e) {
    var pos = new mapboxglModule.Point(0, 0);
    if (isInChart(chart, container, e, pos)) {
      fireMouseEvent("dblclick", e, pos);
      e.preventDefault();
    }
  }

  function fireMouseEvent(type, e, pos) {
    return map.fire(type, {
      dataCoord: chart.unproject(pos),
      point: pos,
      originalEvent: e
    });
  }

  function touchPos(touchContainer, e) {
    var rect = touchContainer.getBoundingClientRect();
    var points = [];
    var margins = chart.margins();

    for (var i = 0; i < e.touches.length; i = i + 1) {
      // TODO(croot): should we only add points that are
      // within the container?
      points.push(new mapboxglModule.Point(e.touches[i].clientX - margins.left - rect.left - touchContainer.clientLeft, e.touches[i].clientY - margins.top - rect.top - touchContainer.clientTop));
    }
    return points;
  }

  function fireTouchEvent(type, e) {
    var touches = touchPos(container, e);
    var singular = touches.reduce(function (prev, curr, i, arr) {
      return prev.add(curr.div(arr.length));
    }, new mapboxglModule.Point(0, 0));

    return map.fire(type, {
      dataCoord: chart.unproject(singular),
      point: singular,
      dataCoords: touches.map(function (t) {
        return chart.unproject(t);
      }, this),
      points: touches,
      originalEvent: e
    });
  }

  function enableInteractionsInternal() {
    map.scrollZoom.enable();
    map.boxZoom.enable();
    // NOTE: box zoom must be enabled before dragPan
    map.dragPan.enable();
  }

  function disableInteractionsInternal() {
    map.dragPan.disable();
    map.boxZoom.disable();
    map.scrollZoom.disable();
  }

  var rtn = {
    enableInteractions: function enableInteractions() {
      enableInteractionsInternal();
    },

    disableInteractions: function disableInteractions() {
      disableInteractionsInternal();
    },

    destroy: function destroy() {
      destroyAllEvents();
      disableInteractionsInternal();
    },

    getInteractionPropNames: function getInteractionPropNames() {
      return ["scrollZoom", "boxZoom", "dragPan"];
    }
  };

  if (enableInteractions) {
    rtn.enableInteractions();
  }

  return rtn;
}

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var legend_1 = __webpack_require__(206);
exports.Legend = legend_1.default;
//# sourceMappingURL=index.js.map

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var h_1 = __webpack_require__(207);
var vdom_1 = __webpack_require__(210);
var d3_dispatch_1 = __webpack_require__(219);
var d3_format_1 = __webpack_require__(221);
var commafy = function (d) { return d3_format_1.format(",")(parseFloat(d.toFixed(2))); };
var formatNumber = function (d) { return String(d).length > 4 ? d3_format_1.format(".2s")(d) : commafy(d); };
function rangeStep(domain, index, bins) {
    if (bins === void 0) { bins = 9; }
    if (index === 0) {
        return domain[0];
    }
    else if (index + 1 === bins) {
        return domain[1];
    }
    else {
        var increment = (domain[1] - domain[0]) / bins;
        return domain[0] + increment * index;
    }
}
function validateNumericalInput(previousValue, nextValue) {
    if (isNaN(parseInt(nextValue))) {
        return parseInt(previousValue);
    }
    else {
        return parseInt(nextValue);
    }
}
function renderTickIcon(state, dispatch) {
    var _this = this;
    return h_1.default("div.tick", { on: { click: function () { return dispatch.call("open", _this, state.index); } } });
}
function renderToggleIcon(state, dispatch) {
    var _this = this;
    return h_1.default("div.open-toggle", {
        on: {
            click: function () {
                dispatch.call("toggle", _this, state);
            }
        }
    });
}
function renderLockIcon(locked, index, dispatch) {
    var _this = this;
    return h_1.default("div.lock" + (locked ? ".locked" : ".unlocked"), { on: { click: function () { return dispatch.call("lock", _this, { locked: locked, index: index }); } } }, [
        h_1.default("svg", { attrs: { viewBox: [0, 0, 48, 48] } }, [
            h_1.default("g", { style: { stroke: "white" } }, [
                h_1.default("path", {
                    attrs: {
                        d: locked
                            ? "M34,20v-4c0-5.5-4.5-10-10-10c-5.5,0-10,4.5-10,10v4H8v20h32V20H34z M18,16c0-3.3,2.7-6,6-6s6,2.7,6,6v4H18V16z"
                            : "M18,20v-8c0-3.3,2.7-6,6-6s6,2.7,6,6v2h4v-2c0-5.5-4.5-10-10-10c-5.5,0-10,4.5-10,10v8H8v20h32V20H18z"
                    }
                })
            ])
        ])
    ]);
}
function renderInput(state, domain, dispatch) {
    var _this = this;
    return h_1.default("input", {
        hook: {
            update: function (prevNode, nextNode) {
                nextNode.elm.value = domain.value;
            }
        },
        props: {
            value: domain.value
        },
        on: {
            focus: function (e) {
                e.target.select();
            },
            blur: function (e) {
                var value = validateNumericalInput(domain.value, e.target.value);
                var _a = state.domain, min = _a[0], max = _a[1];
                dispatch.call("input", _this, {
                    index: state.index,
                    domain: domain.index === 0 ? [value, max] : [min, value]
                });
            },
            keydown: function (e) {
                if (e.code === "Enter") {
                    e.target.blur();
                }
            }
        }
    });
}
function renderGradientLegend(state, dispatch) {
    var stacked = typeof state.index === "number";
    return h_1.default("div.legend.gradient-legend" + (stacked ? ".with-header" : ".legendables") + (state.open ? ".open" : ".collapsed") + (state.position ? "." + state.position : ""), [
        stacked ?
            h_1.default("div.header", [h_1.default("div.title-text", state.title), renderTickIcon(state, dispatch)]) : h_1.default("div"),
        state.open
            ? h_1.default("div.range", state.range.map(function (color, index) {
                var isMinMax = index === 0 || index === state.range.length - 1;
                var step = formatNumber(rangeStep(state.domain, index, state.range.length));
                var _a = state.domain, min = _a[0], max = _a[1];
                return h_1.default("div.block", [
                    h_1.default("div.color", { style: { background: color } }),
                    h_1.default("div.text." + (isMinMax ? "extent" : "step"), [h_1.default("span", "" + (state.domain.length > 2 ? state.domain[index] : step))].concat(isMinMax
                        ? [
                            renderInput(state, { value: state.domain.length === 2 ? state.domain[index === 0 ? 0 : 1] : state.domain[index], index: index }, dispatch)
                        ]
                        : []))
                ]);
            }).slice())
            : h_1.default("div"),
        state.open ?
            renderLockIcon(state.locked, state.index, dispatch) : h_1.default("div")
    ]);
}
exports.renderGradientLegend = renderGradientLegend;
function renderNominalLegend(state, dispatch) {
    var _this = this;
    var stacked = typeof state.index === "number";
    return h_1.default("div.legend.nominal-legend" + (stacked ? "" : ".legendables") + (state.open ? ".open" : ".collapsed") + (state.position ? "." + state.position : ""), [
        !stacked ? renderToggleIcon(state, dispatch) : h_1.default("div"),
        state.title &&
            h_1.default("div.header", [h_1.default("div.title-text", state.title), renderTickIcon(state, dispatch)]),
        state.open
            ? h_1.default("div.body", state.domain.map(function (value, index) {
                return h_1.default("div.legend-row", { on: { click: function () { return dispatch.call("filter", _this, value); } } }, [
                    h_1.default("div.color", {
                        style: { background: state.range[index] }
                    }),
                    h_1.default("div.text", value)
                ]);
            }))
            : h_1.default("div")
    ]);
}
exports.renderNominalLegend = renderNominalLegend;
function renderStackedLegend(state, dispatch) {
    return h_1.default("div.legendables" + (state.open ? ".open" : ".collapsed") + (state.list.length > 1 ? ".show-ticks" : ""), { style: { maxHeight: state.maxHeight + "px" } }, [renderToggleIcon(state, dispatch)].concat(state.list.map(function (legend, index) {
        if (legend.type === "gradient") {
            return renderGradientLegend(__assign({}, legend, { index: index }), dispatch);
        }
        else if (legend.type === "nominal") {
            return renderNominalLegend(__assign({}, legend, { index: index }), dispatch);
        }
    })));
}
exports.renderStackedLegend = renderStackedLegend;
var Legend = /** @class */ (function () {
    function Legend(node) {
        var _this = this;
        this.setState = function (state) {
            if (typeof state === "function") {
                _this.state = state(_this.state);
            }
            else {
                _this.state = state;
            }
            var vnode;
            if (_this.state.type === "gradient") {
                vnode = renderGradientLegend(_this.state, _this.dispatch);
            }
            else if (_this.state.type === "nominal") {
                vnode = renderNominalLegend(_this.state, _this.dispatch);
            }
            else if (_this.state.type === "stacked") {
                vnode = renderStackedLegend(_this.state, _this.dispatch);
            }
            else {
                vnode = h_1.default("div");
            }
            _this.node = vdom_1.patch(_this.node, vnode);
            _this.dispatch.call("doneRender", _this, state);
            return _this.node;
        };
        this.node = node;
        this.dispatch = d3_dispatch_1.dispatch("filter", "input", "open", "lock", "toggle", "doneRender");
        this.state = null;
    }
    Legend.prototype.on = function (event, callback) {
        this.dispatch.on(event, callback);
    };
    return Legend;
}());
exports.default = Legend;
//# sourceMappingURL=legend.js.map

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var vnode_1 = __webpack_require__(208);
var is = __webpack_require__(209);
function addNS(data, children, sel) {
    data.ns = 'http://www.w3.org/2000/svg';
    if (sel !== 'foreignObject' && children !== undefined) {
        for (var i = 0; i < children.length; ++i) {
            var childData = children[i].data;
            if (childData !== undefined) {
                addNS(childData, children[i].children, children[i].sel);
            }
        }
    }
}
function h(sel, b, c) {
    var data = {}, children, text, i;
    if (c !== undefined) {
        data = b;
        if (is.array(c)) {
            children = c;
        }
        else if (is.primitive(c)) {
            text = c;
        }
        else if (c && c.sel) {
            children = [c];
        }
    }
    else if (b !== undefined) {
        if (is.array(b)) {
            children = b;
        }
        else if (is.primitive(b)) {
            text = b;
        }
        else if (b && b.sel) {
            children = [b];
        }
        else {
            data = b;
        }
    }
    if (is.array(children)) {
        for (i = 0; i < children.length; ++i) {
            if (is.primitive(children[i]))
                children[i] = vnode_1.vnode(undefined, undefined, undefined, children[i], undefined);
        }
    }
    if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g' &&
        (sel.length === 3 || sel[3] === '.' || sel[3] === '#')) {
        addNS(data, children, sel);
    }
    return vnode_1.vnode(sel, data, children, text, undefined);
}
exports.h = h;
;
exports.default = h;
//# sourceMappingURL=h.js.map

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function vnode(sel, data, children, text, elm) {
    var key = data === undefined ? undefined : data.key;
    return { sel: sel, data: data, children: children,
        text: text, elm: elm, key: key };
}
exports.vnode = vnode;
exports.default = vnode;
//# sourceMappingURL=vnode.js.map

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.array = Array.isArray;
function primitive(s) {
    return typeof s === 'string' || typeof s === 'number';
}
exports.primitive = primitive;
//# sourceMappingURL=is.js.map

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var snabbdom_1 = __webpack_require__(211);
var attributes_1 = __webpack_require__(214);
var class_1 = __webpack_require__(215);
var props_1 = __webpack_require__(216);
var style_1 = __webpack_require__(217);
var eventlisteners_1 = __webpack_require__(218);
exports.patch = snabbdom_1.init([
    class_1.default,
    props_1.default,
    style_1.default,
    attributes_1.default,
    eventlisteners_1.default
]);
//# sourceMappingURL=vdom.js.map

/***/ }),
/* 211 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["init"] = init;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vnode__ = __webpack_require__(141);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__is__ = __webpack_require__(142);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__htmldomapi__ = __webpack_require__(212);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__h__ = __webpack_require__(143);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_3__h__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__thunk__ = __webpack_require__(213);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "thunk", function() { return __WEBPACK_IMPORTED_MODULE_4__thunk__["a"]; });



function isUndef(s) { return s === undefined; }
function isDef(s) { return s !== undefined; }
var emptyNode = Object(__WEBPACK_IMPORTED_MODULE_0__vnode__["a" /* default */])('', {}, [], undefined, undefined);
function sameVnode(vnode1, vnode2) {
    return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
}
function isVnode(vnode) {
    return vnode.sel !== undefined;
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
    var i, map = {}, key, ch;
    for (i = beginIdx; i <= endIdx; ++i) {
        ch = children[i];
        if (ch != null) {
            key = ch.key;
            if (key !== undefined)
                map[key] = i;
        }
    }
    return map;
}
var hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];


function init(modules, domApi) {
    var i, j, cbs = {};
    var api = domApi !== undefined ? domApi : __WEBPACK_IMPORTED_MODULE_2__htmldomapi__["a" /* default */];
    for (i = 0; i < hooks.length; ++i) {
        cbs[hooks[i]] = [];
        for (j = 0; j < modules.length; ++j) {
            var hook = modules[j][hooks[i]];
            if (hook !== undefined) {
                cbs[hooks[i]].push(hook);
            }
        }
    }
    function emptyNodeAt(elm) {
        var id = elm.id ? '#' + elm.id : '';
        var c = elm.className ? '.' + elm.className.split(' ').join('.') : '';
        return Object(__WEBPACK_IMPORTED_MODULE_0__vnode__["a" /* default */])(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);
    }
    function createRmCb(childElm, listeners) {
        return function rmCb() {
            if (--listeners === 0) {
                var parent_1 = api.parentNode(childElm);
                api.removeChild(parent_1, childElm);
            }
        };
    }
    function createElm(vnode, insertedVnodeQueue) {
        var i, data = vnode.data;
        if (data !== undefined) {
            if (isDef(i = data.hook) && isDef(i = i.init)) {
                i(vnode);
                data = vnode.data;
            }
        }
        var children = vnode.children, sel = vnode.sel;
        if (sel === '!') {
            if (isUndef(vnode.text)) {
                vnode.text = '';
            }
            vnode.elm = api.createComment(vnode.text);
        }
        else if (sel !== undefined) {
            // Parse selector
            var hashIdx = sel.indexOf('#');
            var dotIdx = sel.indexOf('.', hashIdx);
            var hash = hashIdx > 0 ? hashIdx : sel.length;
            var dot = dotIdx > 0 ? dotIdx : sel.length;
            var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
            var elm = vnode.elm = isDef(data) && isDef(i = data.ns) ? api.createElementNS(i, tag)
                : api.createElement(tag);
            if (hash < dot)
                elm.setAttribute('id', sel.slice(hash + 1, dot));
            if (dotIdx > 0)
                elm.setAttribute('class', sel.slice(dot + 1).replace(/\./g, ' '));
            for (i = 0; i < cbs.create.length; ++i)
                cbs.create[i](emptyNode, vnode);
            if (__WEBPACK_IMPORTED_MODULE_1__is__["a" /* array */](children)) {
                for (i = 0; i < children.length; ++i) {
                    var ch = children[i];
                    if (ch != null) {
                        api.appendChild(elm, createElm(ch, insertedVnodeQueue));
                    }
                }
            }
            else if (__WEBPACK_IMPORTED_MODULE_1__is__["b" /* primitive */](vnode.text)) {
                api.appendChild(elm, api.createTextNode(vnode.text));
            }
            i = vnode.data.hook; // Reuse variable
            if (isDef(i)) {
                if (i.create)
                    i.create(emptyNode, vnode);
                if (i.insert)
                    insertedVnodeQueue.push(vnode);
            }
        }
        else {
            vnode.elm = api.createTextNode(vnode.text);
        }
        return vnode.elm;
    }
    function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
        for (; startIdx <= endIdx; ++startIdx) {
            var ch = vnodes[startIdx];
            if (ch != null) {
                api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
            }
        }
    }
    function invokeDestroyHook(vnode) {
        var i, j, data = vnode.data;
        if (data !== undefined) {
            if (isDef(i = data.hook) && isDef(i = i.destroy))
                i(vnode);
            for (i = 0; i < cbs.destroy.length; ++i)
                cbs.destroy[i](vnode);
            if (vnode.children !== undefined) {
                for (j = 0; j < vnode.children.length; ++j) {
                    i = vnode.children[j];
                    if (i != null && typeof i !== "string") {
                        invokeDestroyHook(i);
                    }
                }
            }
        }
    }
    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
            var i_1 = void 0, listeners = void 0, rm = void 0, ch = vnodes[startIdx];
            if (ch != null) {
                if (isDef(ch.sel)) {
                    invokeDestroyHook(ch);
                    listeners = cbs.remove.length + 1;
                    rm = createRmCb(ch.elm, listeners);
                    for (i_1 = 0; i_1 < cbs.remove.length; ++i_1)
                        cbs.remove[i_1](ch, rm);
                    if (isDef(i_1 = ch.data) && isDef(i_1 = i_1.hook) && isDef(i_1 = i_1.remove)) {
                        i_1(ch, rm);
                    }
                    else {
                        rm();
                    }
                }
                else {
                    api.removeChild(parentElm, ch.elm);
                }
            }
        }
    }
    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
        var oldStartIdx = 0, newStartIdx = 0;
        var oldEndIdx = oldCh.length - 1;
        var oldStartVnode = oldCh[0];
        var oldEndVnode = oldCh[oldEndIdx];
        var newEndIdx = newCh.length - 1;
        var newStartVnode = newCh[0];
        var newEndVnode = newCh[newEndIdx];
        var oldKeyToIdx;
        var idxInOld;
        var elmToMove;
        var before;
        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (oldStartVnode == null) {
                oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
            }
            else if (oldEndVnode == null) {
                oldEndVnode = oldCh[--oldEndIdx];
            }
            else if (newStartVnode == null) {
                newStartVnode = newCh[++newStartIdx];
            }
            else if (newEndVnode == null) {
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldStartVnode, newStartVnode)) {
                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else if (sameVnode(oldEndVnode, newEndVnode)) {
                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldStartVnode, newEndVnode)) {
                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
                api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldEndVnode, newStartVnode)) {
                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
                api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else {
                if (oldKeyToIdx === undefined) {
                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                }
                idxInOld = oldKeyToIdx[newStartVnode.key];
                if (isUndef(idxInOld)) {
                    api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                    newStartVnode = newCh[++newStartIdx];
                }
                else {
                    elmToMove = oldCh[idxInOld];
                    if (elmToMove.sel !== newStartVnode.sel) {
                        api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                    }
                    else {
                        patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
                        oldCh[idxInOld] = undefined;
                        api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
                    }
                    newStartVnode = newCh[++newStartIdx];
                }
            }
        }
        if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
            if (oldStartIdx > oldEndIdx) {
                before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
                addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
            }
            else {
                removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
            }
        }
    }
    function patchVnode(oldVnode, vnode, insertedVnodeQueue) {
        var i, hook;
        if (isDef(i = vnode.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {
            i(oldVnode, vnode);
        }
        var elm = vnode.elm = oldVnode.elm;
        var oldCh = oldVnode.children;
        var ch = vnode.children;
        if (oldVnode === vnode)
            return;
        if (vnode.data !== undefined) {
            for (i = 0; i < cbs.update.length; ++i)
                cbs.update[i](oldVnode, vnode);
            i = vnode.data.hook;
            if (isDef(i) && isDef(i = i.update))
                i(oldVnode, vnode);
        }
        if (isUndef(vnode.text)) {
            if (isDef(oldCh) && isDef(ch)) {
                if (oldCh !== ch)
                    updateChildren(elm, oldCh, ch, insertedVnodeQueue);
            }
            else if (isDef(ch)) {
                if (isDef(oldVnode.text))
                    api.setTextContent(elm, '');
                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
            }
            else if (isDef(oldCh)) {
                removeVnodes(elm, oldCh, 0, oldCh.length - 1);
            }
            else if (isDef(oldVnode.text)) {
                api.setTextContent(elm, '');
            }
        }
        else if (oldVnode.text !== vnode.text) {
            api.setTextContent(elm, vnode.text);
        }
        if (isDef(hook) && isDef(i = hook.postpatch)) {
            i(oldVnode, vnode);
        }
    }
    return function patch(oldVnode, vnode) {
        var i, elm, parent;
        var insertedVnodeQueue = [];
        for (i = 0; i < cbs.pre.length; ++i)
            cbs.pre[i]();
        if (!isVnode(oldVnode)) {
            oldVnode = emptyNodeAt(oldVnode);
        }
        if (sameVnode(oldVnode, vnode)) {
            patchVnode(oldVnode, vnode, insertedVnodeQueue);
        }
        else {
            elm = oldVnode.elm;
            parent = api.parentNode(elm);
            createElm(vnode, insertedVnodeQueue);
            if (parent !== null) {
                api.insertBefore(parent, vnode.elm, api.nextSibling(elm));
                removeVnodes(parent, [oldVnode], 0, 0);
            }
        }
        for (i = 0; i < insertedVnodeQueue.length; ++i) {
            insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
        }
        for (i = 0; i < cbs.post.length; ++i)
            cbs.post[i]();
        return vnode;
    };
}
//# sourceMappingURL=snabbdom.js.map

/***/ }),
/* 212 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export htmlDomApi */
function createElement(tagName) {
    return document.createElement(tagName);
}
function createElementNS(namespaceURI, qualifiedName) {
    return document.createElementNS(namespaceURI, qualifiedName);
}
function createTextNode(text) {
    return document.createTextNode(text);
}
function createComment(text) {
    return document.createComment(text);
}
function insertBefore(parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
    node.removeChild(child);
}
function appendChild(node, child) {
    node.appendChild(child);
}
function parentNode(node) {
    return node.parentNode;
}
function nextSibling(node) {
    return node.nextSibling;
}
function tagName(elm) {
    return elm.tagName;
}
function setTextContent(node, text) {
    node.textContent = text;
}
function getTextContent(node) {
    return node.textContent;
}
function isElement(node) {
    return node.nodeType === 1;
}
function isText(node) {
    return node.nodeType === 3;
}
function isComment(node) {
    return node.nodeType === 8;
}
var htmlDomApi = {
    createElement: createElement,
    createElementNS: createElementNS,
    createTextNode: createTextNode,
    createComment: createComment,
    insertBefore: insertBefore,
    removeChild: removeChild,
    appendChild: appendChild,
    parentNode: parentNode,
    nextSibling: nextSibling,
    tagName: tagName,
    setTextContent: setTextContent,
    getTextContent: getTextContent,
    isElement: isElement,
    isText: isText,
    isComment: isComment,
};
/* harmony default export */ __webpack_exports__["a"] = (htmlDomApi);
//# sourceMappingURL=htmldomapi.js.map

/***/ }),
/* 213 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return thunk; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__h__ = __webpack_require__(143);

function copyToThunk(vnode, thunk) {
    thunk.elm = vnode.elm;
    vnode.data.fn = thunk.data.fn;
    vnode.data.args = thunk.data.args;
    thunk.data = vnode.data;
    thunk.children = vnode.children;
    thunk.text = vnode.text;
    thunk.elm = vnode.elm;
}
function init(thunk) {
    var cur = thunk.data;
    var vnode = cur.fn.apply(undefined, cur.args);
    copyToThunk(vnode, thunk);
}
function prepatch(oldVnode, thunk) {
    var i, old = oldVnode.data, cur = thunk.data;
    var oldArgs = old.args, args = cur.args;
    if (old.fn !== cur.fn || oldArgs.length !== args.length) {
        copyToThunk(cur.fn.apply(undefined, args), thunk);
        return;
    }
    for (i = 0; i < args.length; ++i) {
        if (oldArgs[i] !== args[i]) {
            copyToThunk(cur.fn.apply(undefined, args), thunk);
            return;
        }
    }
    copyToThunk(oldVnode, thunk);
}
var thunk = function thunk(sel, key, fn, args) {
    if (args === undefined) {
        args = fn;
        fn = key;
        key = undefined;
    }
    return Object(__WEBPACK_IMPORTED_MODULE_0__h__["a" /* h */])(sel, {
        key: key,
        hook: { init: init, prepatch: prepatch },
        fn: fn,
        args: args
    });
};
/* unused harmony default export */ var _unused_webpack_default_export = (thunk);
//# sourceMappingURL=thunk.js.map

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var xlinkNS = 'http://www.w3.org/1999/xlink';
var xmlNS = 'http://www.w3.org/XML/1998/namespace';
var colonChar = 58;
var xChar = 120;
function updateAttrs(oldVnode, vnode) {
    var key, elm = vnode.elm, oldAttrs = oldVnode.data.attrs, attrs = vnode.data.attrs;
    if (!oldAttrs && !attrs)
        return;
    if (oldAttrs === attrs)
        return;
    oldAttrs = oldAttrs || {};
    attrs = attrs || {};
    // update modified attributes, add new attributes
    for (key in attrs) {
        var cur = attrs[key];
        var old = oldAttrs[key];
        if (old !== cur) {
            if (cur === true) {
                elm.setAttribute(key, "");
            }
            else if (cur === false) {
                elm.removeAttribute(key);
            }
            else {
                if (key.charCodeAt(0) !== xChar) {
                    elm.setAttribute(key, cur);
                }
                else if (key.charCodeAt(3) === colonChar) {
                    // Assume xml namespace
                    elm.setAttributeNS(xmlNS, key, cur);
                }
                else if (key.charCodeAt(5) === colonChar) {
                    // Assume xlink namespace
                    elm.setAttributeNS(xlinkNS, key, cur);
                }
                else {
                    elm.setAttribute(key, cur);
                }
            }
        }
    }
    // remove removed attributes
    // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)
    // the other option is to remove all attributes with value == undefined
    for (key in oldAttrs) {
        if (!(key in attrs)) {
            elm.removeAttribute(key);
        }
    }
}
exports.attributesModule = { create: updateAttrs, update: updateAttrs };
exports.default = exports.attributesModule;
//# sourceMappingURL=attributes.js.map

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function updateClass(oldVnode, vnode) {
    var cur, name, elm = vnode.elm, oldClass = oldVnode.data.class, klass = vnode.data.class;
    if (!oldClass && !klass)
        return;
    if (oldClass === klass)
        return;
    oldClass = oldClass || {};
    klass = klass || {};
    for (name in oldClass) {
        if (!klass[name]) {
            elm.classList.remove(name);
        }
    }
    for (name in klass) {
        cur = klass[name];
        if (cur !== oldClass[name]) {
            elm.classList[cur ? 'add' : 'remove'](name);
        }
    }
}
exports.classModule = { create: updateClass, update: updateClass };
exports.default = exports.classModule;
//# sourceMappingURL=class.js.map

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function updateProps(oldVnode, vnode) {
    var key, cur, old, elm = vnode.elm, oldProps = oldVnode.data.props, props = vnode.data.props;
    if (!oldProps && !props)
        return;
    if (oldProps === props)
        return;
    oldProps = oldProps || {};
    props = props || {};
    for (key in oldProps) {
        if (!props[key]) {
            delete elm[key];
        }
    }
    for (key in props) {
        cur = props[key];
        old = oldProps[key];
        if (old !== cur && (key !== 'value' || elm[key] !== cur)) {
            elm[key] = cur;
        }
    }
}
exports.propsModule = { create: updateProps, update: updateProps };
exports.default = exports.propsModule;
//# sourceMappingURL=props.js.map

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var raf = (typeof window !== 'undefined' && window.requestAnimationFrame) || setTimeout;
var nextFrame = function (fn) { raf(function () { raf(fn); }); };
function setNextFrame(obj, prop, val) {
    nextFrame(function () { obj[prop] = val; });
}
function updateStyle(oldVnode, vnode) {
    var cur, name, elm = vnode.elm, oldStyle = oldVnode.data.style, style = vnode.data.style;
    if (!oldStyle && !style)
        return;
    if (oldStyle === style)
        return;
    oldStyle = oldStyle || {};
    style = style || {};
    var oldHasDel = 'delayed' in oldStyle;
    for (name in oldStyle) {
        if (!style[name]) {
            if (name[0] === '-' && name[1] === '-') {
                elm.style.removeProperty(name);
            }
            else {
                elm.style[name] = '';
            }
        }
    }
    for (name in style) {
        cur = style[name];
        if (name === 'delayed' && style.delayed) {
            for (var name2 in style.delayed) {
                cur = style.delayed[name2];
                if (!oldHasDel || cur !== oldStyle.delayed[name2]) {
                    setNextFrame(elm.style, name2, cur);
                }
            }
        }
        else if (name !== 'remove' && cur !== oldStyle[name]) {
            if (name[0] === '-' && name[1] === '-') {
                elm.style.setProperty(name, cur);
            }
            else {
                elm.style[name] = cur;
            }
        }
    }
}
function applyDestroyStyle(vnode) {
    var style, name, elm = vnode.elm, s = vnode.data.style;
    if (!s || !(style = s.destroy))
        return;
    for (name in style) {
        elm.style[name] = style[name];
    }
}
function applyRemoveStyle(vnode, rm) {
    var s = vnode.data.style;
    if (!s || !s.remove) {
        rm();
        return;
    }
    var name, elm = vnode.elm, i = 0, compStyle, style = s.remove, amount = 0, applied = [];
    for (name in style) {
        applied.push(name);
        elm.style[name] = style[name];
    }
    compStyle = getComputedStyle(elm);
    var props = compStyle['transition-property'].split(', ');
    for (; i < props.length; ++i) {
        if (applied.indexOf(props[i]) !== -1)
            amount++;
    }
    elm.addEventListener('transitionend', function (ev) {
        if (ev.target === elm)
            --amount;
        if (amount === 0)
            rm();
    });
}
exports.styleModule = {
    create: updateStyle,
    update: updateStyle,
    destroy: applyDestroyStyle,
    remove: applyRemoveStyle
};
exports.default = exports.styleModule;
//# sourceMappingURL=style.js.map

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function invokeHandler(handler, vnode, event) {
    if (typeof handler === "function") {
        // call function handler
        handler.call(vnode, event, vnode);
    }
    else if (typeof handler === "object") {
        // call handler with arguments
        if (typeof handler[0] === "function") {
            // special case for single argument for performance
            if (handler.length === 2) {
                handler[0].call(vnode, handler[1], event, vnode);
            }
            else {
                var args = handler.slice(1);
                args.push(event);
                args.push(vnode);
                handler[0].apply(vnode, args);
            }
        }
        else {
            // call multiple handlers
            for (var i = 0; i < handler.length; i++) {
                invokeHandler(handler[i]);
            }
        }
    }
}
function handleEvent(event, vnode) {
    var name = event.type, on = vnode.data.on;
    // call event handler(s) if exists
    if (on && on[name]) {
        invokeHandler(on[name], vnode, event);
    }
}
function createListener() {
    return function handler(event) {
        handleEvent(event, handler.vnode);
    };
}
function updateEventListeners(oldVnode, vnode) {
    var oldOn = oldVnode.data.on, oldListener = oldVnode.listener, oldElm = oldVnode.elm, on = vnode && vnode.data.on, elm = (vnode && vnode.elm), name;
    // optimization for reused immutable handlers
    if (oldOn === on) {
        return;
    }
    // remove existing listeners which no longer used
    if (oldOn && oldListener) {
        // if element changed or deleted we remove all existing listeners unconditionally
        if (!on) {
            for (name in oldOn) {
                // remove listener if element was changed or existing listeners removed
                oldElm.removeEventListener(name, oldListener, false);
            }
        }
        else {
            for (name in oldOn) {
                // remove listener if existing listener removed
                if (!on[name]) {
                    oldElm.removeEventListener(name, oldListener, false);
                }
            }
        }
    }
    // add new listeners which has not already attached
    if (on) {
        // reuse existing listener or create new
        var listener = vnode.listener = oldVnode.listener || createListener();
        // update vnode for listener
        listener.vnode = vnode;
        // if element changed or added we add all needed listeners unconditionally
        if (!oldOn) {
            for (name in on) {
                // add listener if element was changed or new listeners added
                elm.addEventListener(name, listener, false);
            }
        }
        else {
            for (name in on) {
                // add listener if new listener added
                if (!oldOn[name]) {
                    elm.addEventListener(name, listener, false);
                }
            }
        }
    }
}
exports.eventListenersModule = {
    create: updateEventListeners,
    update: updateEventListeners,
    destroy: updateEventListeners
};
exports.default = exports.eventListenersModule;
//# sourceMappingURL=eventlisteners.js.map

/***/ }),
/* 219 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_dispatch__ = __webpack_require__(220);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "dispatch", function() { return __WEBPACK_IMPORTED_MODULE_0__src_dispatch__["a"]; });



/***/ }),
/* 220 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var noop = {value: function() {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ __webpack_exports__["a"] = (dispatch);


/***/ }),
/* 221 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_defaultLocale__ = __webpack_require__(222);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "formatDefaultLocale", function() { return __WEBPACK_IMPORTED_MODULE_0__src_defaultLocale__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "format", function() { return __WEBPACK_IMPORTED_MODULE_0__src_defaultLocale__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "formatPrefix", function() { return __WEBPACK_IMPORTED_MODULE_0__src_defaultLocale__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_locale__ = __webpack_require__(144);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "formatLocale", function() { return __WEBPACK_IMPORTED_MODULE_1__src_locale__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_formatSpecifier__ = __webpack_require__(145);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "formatSpecifier", function() { return __WEBPACK_IMPORTED_MODULE_2__src_formatSpecifier__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_precisionFixed__ = __webpack_require__(228);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "precisionFixed", function() { return __WEBPACK_IMPORTED_MODULE_3__src_precisionFixed__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_precisionPrefix__ = __webpack_require__(229);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "precisionPrefix", function() { return __WEBPACK_IMPORTED_MODULE_4__src_precisionPrefix__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_precisionRound__ = __webpack_require__(230);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "precisionRound", function() { return __WEBPACK_IMPORTED_MODULE_5__src_precisionRound__["a"]; });








/***/ }),
/* 222 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return formatPrefix; });
/* harmony export (immutable) */ __webpack_exports__["a"] = defaultLocale;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__locale__ = __webpack_require__(144);


var locale;
var format;
var formatPrefix;

defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = Object(__WEBPACK_IMPORTED_MODULE_0__locale__["a" /* default */])(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}


/***/ }),
/* 223 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
});


/***/ }),
/* 224 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
});


/***/ }),
/* 225 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x, p) {
  x = x.toPrecision(p);

  out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (x[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      case "e": break out;
      default: if (i0 > 0) i0 = 0; break;
    }
  }

  return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
});


/***/ }),
/* 226 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__formatDecimal__ = __webpack_require__(23);


/* harmony default export */ __webpack_exports__["a"] = (function(x, p) {
  var d = Object(__WEBPACK_IMPORTED_MODULE_0__formatDecimal__["a" /* default */])(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
});


/***/ }),
/* 227 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return x;
});


/***/ }),
/* 228 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__exponent__ = __webpack_require__(14);


/* harmony default export */ __webpack_exports__["a"] = (function(step) {
  return Math.max(0, -Object(__WEBPACK_IMPORTED_MODULE_0__exponent__["a" /* default */])(Math.abs(step)));
});


/***/ }),
/* 229 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__exponent__ = __webpack_require__(14);


/* harmony default export */ __webpack_exports__["a"] = (function(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Object(__WEBPACK_IMPORTED_MODULE_0__exponent__["a" /* default */])(value) / 3))) * 3 - Object(__WEBPACK_IMPORTED_MODULE_0__exponent__["a" /* default */])(Math.abs(step)));
});


/***/ }),
/* 230 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__exponent__ = __webpack_require__(14);


/* harmony default export */ __webpack_exports__["a"] = (function(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, Object(__WEBPACK_IMPORTED_MODULE_0__exponent__["a" /* default */])(max) - Object(__WEBPACK_IMPORTED_MODULE_0__exponent__["a" /* default */])(step)) + 1;
});


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rowChart;

var _baseMixin = __webpack_require__(5);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

var _capMixin = __webpack_require__(10);

var _capMixin2 = _interopRequireDefault(_capMixin);

var _colorMixin = __webpack_require__(7);

var _colorMixin2 = _interopRequireDefault(_colorMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _lockAxisMixin = __webpack_require__(135);

var _lockAxisMixin2 = _interopRequireDefault(_lockAxisMixin);

var _marginMixin = __webpack_require__(12);

var _marginMixin2 = _interopRequireDefault(_marginMixin);

var _core = __webpack_require__(2);

var _utils = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Concrete row chart implementation.
 *
 * Examples:
 * - {@link https://mapd.github.io/mapd-charting/example/example1.html Total Number of Flights by State}
 * @name rowChart
 * @memberof dc
 * @mixes dc.capMixin
 * @mixes dc.marginMixin
 * @mixes dc.colorMixin
 * @mixes dc.baseMixin
 * @example
 * // create a row chart under #chart-container1 element using the default global chart group
 * var chart1 = dc.rowChart('#chart-container1');
 * // create a row chart under #chart-container2 element using chart group A
 * var chart2 = dc.rowChart('#chart-container2', 'chartGroupA');
 * @param {String|node|d3.selection} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector} specifying
 * a dom block element such as a div; or a dom element or d3 selection.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
 * Interaction with a chart will only trigger events and redraws within the chart's group.
 * @return {dc.rowChart}
 */
function rowChart(parent, chartGroup) {
  var _g = void 0;

  var _labelOffsetX = 8;
  var _labelOffsetY = 16;
  var _hasLabelOffsetY = false;
  var _dyOffset = "0.35em"; // this helps center labels https://github.com/mbostock/d3/wiki/SVG-Shapes#svg_text
  var _titleLabelOffsetX = 2;
  var MAX_TICK_WIDTH = 64;
  var DEFAULT_NUM_TICKS = 10;

  /* OVERRIDE -----------------------------------------------------------------*/
  var _xAxisLabel = void 0;
  var _yAxisLabel = void 0;
  var _autoScroll = false;
  var _minBarHeight = 16;
  var _isBigBar = false;
  var _scrollTop = 0;
  /* --------------------------------------------------------------------------*/

  var _gap = 4;

  var _fixedBarHeight = false;
  var _rowCssClass = "row";
  var _titleRowCssClass = "titlerow";
  var _renderTitleLabel = false;

  var _chart = (0, _lockAxisMixin2.default)((0, _capMixin2.default)((0, _marginMixin2.default)((0, _colorMixin2.default)((0, _baseMixin2.default)({})))));

  var _x = void 0;

  var _elasticX = void 0;

  var _xAxis = _d2.default.svg.axis().orient("bottom");

  var _rowData = void 0;

  _chart.rowsCap = _chart.cap;

  /* OVERRIDE -----------------------------------------------------------------*/
  _chart.accent = accentRow;
  _chart.unAccent = unAccentRow;

  _chart.setYAxisLabel = function (yAxisLabel) {
    _yAxisLabel = yAxisLabel;
  };

  _chart.xAxisLabel = function (_, padding) {
    if (!arguments.length) {
      return _xAxisLabel;
    }
    _xAxisLabel = _;

    return _chart;
  };

  _chart.scrollTop = function (_) {
    if (!arguments.length) {
      return _scrollTop;
    }
    _scrollTop = _;

    return _chart;
  };

  _chart.getNumTicksForXAxis = function () {
    var effectiveWidth = _chart.effectiveWidth();
    var numTicks = _chart.xAxis().scale().ticks().length;
    return effectiveWidth / numTicks < MAX_TICK_WIDTH ? Math.ceil(effectiveWidth / MAX_TICK_WIDTH) : DEFAULT_NUM_TICKS;
  };
  /* --------------------------------------------------------------------------*/

  function calculateAxisScale() {
    if (!_x) {
      _x = _d2.default.scale.linear();
    }
    _x.range([0, _chart.effectiveWidth()]);

    if (_elasticX) {
      var extent = _d2.default.extent(_rowData, _chart.cappedValueAccessor);
      if (extent[0] > 0) {
        extent[0] = 0;
      }
      _x.domain(extent);
    }
    _xAxis.scale(_x);

    _chart.xAxis().ticks(_chart.getNumTicksForXAxis());
  }

  function setXAxisFormat() {
    var numberFormatter = _chart.valueFormatter();
    if (numberFormatter) {
      var key = _chart.getMeasureName();
      _xAxis.tickFormat(function (d) {
        return numberFormatter(d, key);
      });
    } else {
      _xAxis.tickFormat(null);
    }
  }

  function drawAxis() {
    /* OVERRIDE -----------------------------------------------------------------*/
    var root = _chart.root();
    var axisG = root.select("g.axis");

    calculateAxisScale();

    if (axisG.empty()) {
      if (_chart.autoScroll()) {
        axisG = root.append("div").attr("class", "external-axis").style("height", _chart.margins().bottom + "px").append("svg").attr("height", 32).append("g").attr("class", "axis").attr("transform", "translate(" + _chart.margins().left + ", 1)");

        var saveScrollTop = _chart.debounce(function () {
          _scrollTop = _d2.default.select(this).node().scrollTop;
        }, 250);

        _chart.root().select(".svg-wrapper").on("scroll", saveScrollTop);
      } else {
        axisG = _g.append("g").attr("class", "axis").attr("transform", "translate(0, " + _chart.effectiveHeight() + ")");
      }
    }

    if (_chart.autoScroll()) {
      root.select(".external-axis svg").attr("width", _chart.width());
    }

    var yLabel = root.selectAll(".y-axis-label");

    if (yLabel.empty()) {
      yLabel = root.append("div").attr("class", "y-axis-label");
    }

    yLabel.text(typeof aliases !== "undefined" ? aliases[_yAxisLabel] : _yAxisLabel).style("top", _chart.effectiveHeight() / 2 + _chart.margins().top + "px");

    var xLabel = root.selectAll(".x-axis-label");

    if (xLabel.empty()) {
      xLabel = root.append("div").attr("class", "x-axis-label");
    }

    xLabel.text(_chart.xAxisLabel()).style("left", _chart.effectiveWidth() / 2 + _chart.margins().left + "px");
    /* --------------------------------------------------------------------------*/

    setXAxisFormat();
    (0, _core.transition)(axisG, _chart.transitionDuration()).call(_xAxis);

    _chart.prepareLockAxis("x");
  }

  _chart._doRender = function (data) {
    _chart.resetSvg();

    _g = _chart.svg().append("g").attr("transform", "translate(" + _chart.margins().left + "," + _chart.margins().top + ")");

    drawChart(data);

    return _chart;
  };

  _chart.title(function (d) {
    return _chart.cappedKeyAccessor(d) + ": " + _chart.cappedValueAccessor(d);
  });

  /* OVERRIDE ---------------------------------------------------------------- */
  _chart.measureValue = function (d) {
    var key = _chart.getMeasureName();
    var customFormatter = _chart.valueFormatter();
    var value = _chart.cappedValueAccessor(d);
    return customFormatter && customFormatter(value, key) || _utils.utils.formatValue(value);
  };
  /* ------------------------------------------------------------------------- */

  /**
   * Gets or sets the x scale. The x scale can be any d3
   * {@link https://github.com/mbostock/d3/wiki/Quantitative-Scales quantitive scale}
   * @name x
   * @memberof dc.rowChart
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/Quantitative-Scales quantitive scale}
   * @param {d3.scale} [scale]
   * @return {d3.scale}
   * @return {dc.rowChart}
   */
  _chart.x = function (scale) {
    if (!arguments.length) {
      return _x;
    }
    _x = scale;
    return _chart;
  };

  function drawGridLines() {
    _g.selectAll("g.tick").select("line.grid-line").remove();

    _g.selectAll("g.tick").append("line").attr("class", "grid-line").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", function () {
      return -_chart.effectiveHeight();
    });
  }

  function drawChart(data) {
    /* OVERRIDE -----------------------------------------------------------------*/
    var rData = data ? data : _chart.data();
    _rowData = _utils.utils.maybeFormatInfinity(rData);
    /* --------------------------------------------------------------------------*/

    drawAxis();
    drawGridLines();

    var rows = _g.selectAll("g." + _rowCssClass).data(_rowData);

    createElements(rows);
    removeElements(rows);
    updateElements(rows);

    if (_chart.autoScroll()) {
      _chart.root().select(".svg-wrapper").node().scrollTop = _scrollTop;
    }
  }

  function createElements(rows) {
    var rowEnter = rows.enter().append("g").attr("class", function (d, i) {
      return _rowCssClass + " _" + i;
    });

    rowEnter.append("rect").attr("width", 0);

    createLabels(rowEnter);
    updateLabels(rows);
  }

  function removeElements(rows) {
    rows.exit().remove();
  }

  function rootValue() {
    var root = _x(0);
    return root === -Infinity || root !== root ? _x(1) : root;
  }

  function updateElements(rows) {
    var n = _rowData.length;

    var height = void 0;

    if (!_fixedBarHeight) {
      height = (_chart.effectiveHeight() - _gap - (n + 1) * _gap) / n;
    } else {
      height = _fixedBarHeight;
    }

    /* OVERRIDE -----------------------------------------------------------------*/

    _isBigBar = _labelOffsetY * 2 > (_chart.measureLabelsOn() ? 64 : 32);

    if (_isBigBar) {
      height = (_chart.effectiveHeight() - _gap - (n + 1) * _gap) / n;
    }

    if (_chart.autoScroll()) {
      height = height < _minBarHeight ? _minBarHeight : height;
      _chart.root().select(".svg-wrapper").style("height", _chart.height() - _chart.margins().bottom + "px").style("overflow-y", "auto").style("overflow-x", "hidden");
      _chart.svg().attr("height", height === _minBarHeight ? n * (height + _gap) + 8 : _chart.height() - 56);
    }
    /* --------------------------------------------------------------------------*/

    // vertically align label in center unless they override the value via property setter
    if (!_hasLabelOffsetY) {
      _labelOffsetY = height / 2;
    }

    var rect = rows.attr("transform", function (d, i) {
      return "translate(0," + ((i + 1) * _gap + i * height) + ")";
    }).select("rect").attr("height", height).attr("fill", _chart.getColor).on("click", onClick).classed("deselected", function (d) {
      return _chart.hasFilter() ? !isSelectedRow(d) : false;
    }).classed("selected", function (d) {
      return _chart.hasFilter() ? isSelectedRow(d) : false;
    });

    (0, _core.transition)(rect, _chart.transitionDuration()).attr("width", function (d) {
      return Math.abs(rootValue() - _x(_chart.valueAccessor()(d)));
    }).attr("transform", translateX);

    if (!_chart.measureLabelsOn()) {
      createTitles(rows);
    }

    updateLabels(rows);
  }

  function createTitles(rows) {
    if (_chart.renderTitle()) {
      rows.selectAll("title").remove();
      rows.append("title").text(_chart.title());
    }
  }

  function createLabels(rowEnter) {
    if (_chart.renderLabel()) {
      rowEnter.append("text").on("click", onClick);
    }

    /* OVERRIDE -----------------------------------------------------------------*/
    if (_chart.measureLabelsOn()) {
      rowEnter.append("text").attr("class", "value-measure").on("click", onClick);
    }
    /* --------------------------------------------------------------------------*/

    if (_chart.renderTitleLabel()) {
      rowEnter.append("text").attr("class", _titleRowCssClass).on("click", onClick);
    }
  }

  function updateLabels(rows) {
    /* OVERRIDE -----------------------------------------------------------------*/
    rows.selectAll("text").style("font-size", _isBigBar ? "14px" : "12px");
    /* --------------------------------------------------------------------------*/

    if (_chart.renderLabel()) {
      var lab = rows.select("text").attr("x", _labelOffsetX).attr("y", _labelOffsetY).attr("dy", _dyOffset)
      /* OVERRIDE -----------------------------------------------------------------*/
      .attr("dy", isStackLabel() ? "-0.25em" : _dyOffset)
      /* --------------------------------------------------------------------------*/
      .on("click", onClick).attr("class", function (d, i) {
        return _rowCssClass + " _" + i;
      })
      /* OVERRIDE -----------------------------------------------------------------*/
      .classed("value-dim", true).classed("deselected-label", function (d) {
        return _chart.hasFilter() && !isSelectedRow(d);
      })
      /* --------------------------------------------------------------------------*/
      .html(_chart.label());
      (0, _core.transition)(lab, _chart.transitionDuration()).attr("transform", translateX);
    }

    /* OVERRIDE -----------------------------------------------------------------*/
    if (_chart.measureLabelsOn()) {
      var measureLab = rows.select(".value-measure").classed("deselected-label", function (d) {
        return _chart.hasFilter() && !isSelectedRow(d);
      }).attr("y", _labelOffsetY).attr("dy", isStackLabel() ? "1.1em" : _dyOffset).on("click", onClick).attr("text-anchor", isStackLabel() ? "start" : "end").html(function (d) {
        if (d.label) {
          return d.label;
        } else {
          return _chart.measureValue(d);
        }
      }).attr("x", function (d, i) {
        if (isStackLabel()) {
          return _labelOffsetX + 1;
        }

        var thisLabel = _d2.default.select(this);

        var width = Math.abs(rootValue() - _x(_chart.valueAccessor()(d)));

        //
        // handle Firefox getBBox bug
        // https://bugzilla.mozilla.org/show_bug.cgi?id=612118
        //
        var measureWidth = 0;
        var labelNode = thisLabel.node();
        if (labelNode && labelNode.getClientRects && labelNode.getClientRects().length > 0) {
          measureWidth = labelNode.getBBox().width;
        }

        var dimWidth = 0;
        var textNode = _chart.svg().select("text.value-dim._" + i).node();
        if (textNode && textNode.getClientRects && textNode.getClientRects().length > 0) {
          dimWidth = textNode.getBBox().width;
        }
        var minIdealWidth = measureWidth + dimWidth + 16;

        thisLabel.attr("text-anchor", isStackLabel() || width < minIdealWidth ? "start" : "end");

        return width > minIdealWidth ? width - 4 : dimWidth + 16;
      });
      (0, _core.transition)(measureLab, _chart.transitionDuration()).attr("transform", translateX);
    }
    /* --------------------------------------------------------------------------*/

    if (_chart.renderTitleLabel()) {
      var titlelab = rows.select("." + _titleRowCssClass).attr("x", _chart.effectiveWidth() - _titleLabelOffsetX).attr("y", _labelOffsetY).attr("text-anchor", "end").on("click", onClick).attr("class", function (d, i) {
        return _titleRowCssClass + " _" + i;
      }).text(function (d) {
        return _chart.title()(d);
      });
      (0, _core.transition)(titlelab, _chart.transitionDuration()).attr("transform", translateX);
    }
  }

  /**
   * Turn on/off Title label rendering (values) using SVG style of text-anchor 'end'
   * @name renderTitleLabel
   * @memberof dc.rowChart
   * @instance
   * @param {Boolean} [renderTitleLabel=false]
   * @return {Boolean}
   * @return {dc.rowChart}
   */
  _chart.renderTitleLabel = function (renderTitleLabel) {
    if (!arguments.length) {
      return _renderTitleLabel;
    }
    _renderTitleLabel = renderTitleLabel;
    return _chart;
  };

  function onClick(d) {
    _chart.onClick(d);
  }

  /* OVERRIDE -----------------------------------------------------------------*/
  function isStackLabel() {
    return _chart.measureLabelsOn() && _labelOffsetY > 16;
  }
  /* --------------------------------------------------------------------------*/

  function translateX(d) {
    var x = _x(_chart.cappedValueAccessor(d)),
        x0 = rootValue(),
        s = x > x0 ? x0 : x;
    return "translate(" + s + ",0)";
  }

  _chart._doRedraw = function (data) {
    if (!_g) {
      return _chart._doRender(data);
    }

    drawChart(data);
    return _chart;
  };

  /**
   * Get the x axis for the row chart instance.  Note: not settable for row charts.
   * See the {@link https://github.com/mbostock/d3/wiki/SVG-Axes#wiki-axis d3 axis object}
   * documention for more information.
   * @name xAxis
   * @memberof dc.rowChart
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/SVG-Axes#wiki-axis d3.svg.axis}
   * @example
   * // customize x axis tick format
   * chart.xAxis().tickFormat(function (v) {return v + '%';});
   * // customize x axis tick values
   * chart.xAxis().tickValues([0, 100, 200, 300]);
   * @return {d3.svg.axis}
   */
  _chart.xAxis = function () {
    return _xAxis;
  };

  /**
   * Get or set the fixed bar height. Default is [false] which will auto-scale bars.
   * For example, if you want to fix the height for a specific number of bars (useful in TopN charts)
   * you could fix height as follows (where count = total number of bars in your TopN and gap is
   * your vertical gap space).
   * @name fixedBarHeight
   * @memberof dc.rowChart
   * @instance
   * @example
   * chart.fixedBarHeight( chartheight - (count + 1) * gap / count);
   * @param {Boolean|Number} [fixedBarHeight=false]
   * @return {Boolean|Number}
   * @return {dc.rowChart}
   */
  _chart.fixedBarHeight = function (fixedBarHeight) {
    if (!arguments.length) {
      return _fixedBarHeight;
    }
    _fixedBarHeight = fixedBarHeight;
    return _chart;
  };

  /**
   * Get or set the vertical gap space between rows on a particular row chart instance
   * @name gap
   * @memberof dc.rowChart
   * @instance
   * @param {Number} [gap=5]
   * @return {Number}
   * @return {dc.rowChart}
   */
  _chart.gap = function (gap) {
    if (!arguments.length) {
      return _gap;
    }
    _gap = gap;
    return _chart;
  };

  /**
   * Get or set the elasticity on x axis. If this attribute is set to true, then the x axis will rescle to auto-fit the
   * data range when filtered.
   * @name elasticX
   * @memberof dc.rowChart
   * @instance
   * @param {Boolean} [elasticX]
   * @return {Boolean}
   * @return {dc.rowChart}
   */
  _chart.elasticX = function (elasticX) {
    if (!arguments.length) {
      return _elasticX;
    }
    _elasticX = elasticX;
    return _chart;
  };

  /* OVERRIDE -----------------------------------------------------------------*/
  _chart.autoScroll = function (autoScroll) {
    if (!arguments.length) {
      return _autoScroll;
    }
    _autoScroll = autoScroll;
    return _chart;
  };

  /* --------------------------------------------------------------------------*/
  /**
   * Get or set the x offset (horizontal space to the top left corner of a row) for labels on a particular row chart.
   * @name labelOffsetX
   * @memberof dc.rowChart
   * @instance
   * @param {Number} [labelOffsetX=10]
   * @return {Number}
   * @return {dc.rowChart}
   */
  _chart.labelOffsetX = function (labelOffsetX) {
    if (!arguments.length) {
      return _labelOffsetX;
    }
    _labelOffsetX = labelOffsetX;
    return _chart;
  };

  /**
   * Get or set the y offset (vertical space to the top left corner of a row) for labels on a particular row chart.
   * @name labelOffsetY
   * @memberof dc.rowChart
   * @instance
   * @param {Number} [labelOffsety=15]
   * @return {Number}
   * @return {dc.rowChart}
   */
  _chart.labelOffsetY = function (labelOffsety) {
    if (!arguments.length) {
      return _labelOffsetY;
    }
    _labelOffsetY = labelOffsety;
    _hasLabelOffsetY = true;
    return _chart;
  };

  /**
   * Get of set the x offset (horizontal space between right edge of row and right edge or text.
   * @name titleLabelOffsetX
   * @memberof dc.rowChart
   * @instance
   * @param {Number} [titleLabelOffsetX=2]
   * @return {Number}
   * @return {dc.rowChart}
   */
  _chart.titleLabelOffsetX = function (titleLabelOffsetX) {
    if (!arguments.length) {
      return _titleLabelOffsetX;
    }
    _titleLabelOffsetX = titleLabelOffsetX;
    return _chart;
  };

  /* OVERRIDE -----------------------------------------------------------------*/
  function accentRow(label) {
    _chart.selectAll("g." + _rowCssClass).each(function (d) {
      if (_chart.cappedKeyAccessor(d) == label) {
        _chart.accentSelected(this);
      }
    });
  }

  function unAccentRow(label) {
    _chart.selectAll("g." + _rowCssClass).each(function (d) {
      if (_chart.cappedKeyAccessor(d) == label) {
        _chart.unAccentSelected(this);
      }
    });
  }
  /* --------------------------------------------------------------------------*/

  function isSelectedRow(d) {
    return _chart.hasFilter(_chart.cappedKeyAccessor(d)) ^ _chart.filtersInverse();
  }

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = scatterPlot;

var _coordinateGridMixin = __webpack_require__(11);

var _coordinateGridMixin2 = _interopRequireDefault(_coordinateGridMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _events = __webpack_require__(9);

var _filters = __webpack_require__(13);

var _core = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A scatter plot chart
 *
 * Examples:
 * - {@link http://dc-js.github.io/dc.js/examples/scatter.html Scatter Chart}
 * - {@link http://dc-js.github.io/dc.js/examples/multi-scatter.html Multi-Scatter Chart}
 * @name scatterPlot
 * @memberof dc
 * @mixes dc.coordinateGridMixin
 * @example
 * // create a scatter plot under #chart-container1 element using the default global chart group
 * var chart1 = dc.scatterPlot('#chart-container1');
 * // create a scatter plot under #chart-container2 element using chart group A
 * var chart2 = dc.scatterPlot('#chart-container2', 'chartGroupA');
 * // create a sub-chart under a composite parent chart
 * var chart3 = dc.scatterPlot(compositeChart);
 * @param {String|node|d3.selection} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector} specifying
 * a dom block element such as a div; or a dom element or d3 selection.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
 * Interaction with a chart will only trigger events and redraws within the chart's group.
 * @return {dc.scatterPlot}
 */
function scatterPlot(parent, chartGroup) {
  var _chart = (0, _coordinateGridMixin2.default)({});
  var _symbol = _d2.default.svg.symbol();

  var _existenceAccessor = function _existenceAccessor(d) {
    return d.value;
  };

  var originalKeyAccessor = _chart.keyAccessor();
  _chart.keyAccessor(function (d) {
    return originalKeyAccessor(d)[0];
  });
  _chart.valueAccessor(function (d) {
    return originalKeyAccessor(d)[1];
  });
  _chart.colorAccessor(function () {
    return _chart._groupName;
  });

  var _locator = function _locator(d) {
    return "translate(" + _chart.x()(_chart.keyAccessor()(d)) + "," + _chart.y()(_chart.valueAccessor()(d)) + ")";
  };

  var _symbolSize = 3;
  var _highlightedSize = 5;
  var _hiddenSize = 0;

  _symbol.size(function (d) {
    if (!_existenceAccessor(d)) {
      return _hiddenSize;
    } else if (this.filtered) {
      return Math.pow(_highlightedSize, 2);
    } else {
      return Math.pow(_symbolSize, 2);
    }
  });

  (0, _core.override)(_chart, "_filter", function (filter) {
    if (!arguments.length) {
      return _chart.__filter();
    }

    return _chart.__filter(_filters.filters.RangedTwoDimensionalFilter(filter));
  });

  _chart.plotData = function () {
    var symbols = _chart.chartBodyG().selectAll("path.symbol").data(_chart.data());

    symbols.enter().append("path").attr("class", "symbol").attr("opacity", 0).attr("fill", _chart.getColor).attr("transform", _locator);

    (0, _core.transition)(symbols, _chart.transitionDuration()).attr("opacity", function (d) {
      return _existenceAccessor(d) ? 1 : 0;
    }).attr("fill", _chart.getColor).attr("transform", _locator).attr("d", _symbol);

    (0, _core.transition)(symbols.exit(), _chart.transitionDuration()).attr("opacity", 0).remove();
  };

  /**
   * Get or set the existence accessor.  If a point exists, it is drawn with
   * {@link #dc.scatterPlot+symbolSize symbolSize} radius and
   * opacity 1; if it does not exist, it is drawn with
   * {@link #dc.scatterPlot+hiddenSize hiddenSize} radius and opacity 0. By default,
   * the existence accessor checks if the reduced value is truthy.
   * @name existenceAccessor
   * @memberof dc.scatterPlot
   * @instance
   * @see {@link #dc.scatterPlot+symbolSize symbolSize}
   * @see {@link #dc.scatterPlot+hiddenSize hiddenSize}
   * @example
   * // default accessor
   * chart.existenceAccessor(function (d) { return d.value; });
   * @param {Function} [accessor]
   * @return {Function}
   * @return {dc.scatterPlot}
   */
  _chart.existenceAccessor = function (accessor) {
    if (!arguments.length) {
      return _existenceAccessor;
    }
    _existenceAccessor = accessor;
    return this;
  };

  /**
   * Get or set the symbol type used for each point. By default the symbol is a circle.
   * Type can be a constant or an accessor.
   * @name symbol
   * @memberof dc.scatterPlot
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#symbol_type d3.svg.symbol().type()}
   * @example
   * // Circle type
   * chart.symbol('circle');
   * // Square type
   * chart.symbol('square');
   * @param {String|Function} [type='circle']
   * @return {String|Function}
   * @return {dc.scatterPlot}
   */
  _chart.symbol = function (type) {
    if (!arguments.length) {
      return _symbol.type();
    }
    _symbol.type(type);
    return _chart;
  };

  /**
   * Set or get radius for symbols.
   * @name symbolSize
   * @memberof dc.scatterPlot
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#symbol_size d3.svg.symbol().size()}
   * @param {Number} [symbolSize=3]
   * @return {Number}
   * @return {dc.scatterPlot}
   */
  _chart.symbolSize = function (symbolSize) {
    if (!arguments.length) {
      return _symbolSize;
    }
    _symbolSize = symbolSize;
    return _chart;
  };

  /**
   * Set or get radius for highlighted symbols.
   * @name highlightedSize
   * @memberof dc.scatterPlot
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#symbol_size d3.svg.symbol().size()}
   * @param {Number} [highlightedSize=5]
   * @return {Number}
   * @return {dc.scatterPlot}
   */
  _chart.highlightedSize = function (highlightedSize) {
    if (!arguments.length) {
      return _highlightedSize;
    }
    _highlightedSize = highlightedSize;
    return _chart;
  };

  /**
   * Set or get radius for symbols when the group is empty.
   * @name hiddenSize
   * @memberof dc.scatterPlot
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#symbol_size d3.svg.symbol().size()}
   * @param {Number} [hiddenSize=0]
   * @return {Number}
   * @return {dc.scatterPlot}
   */
  _chart.hiddenSize = function (hiddenSize) {
    if (!arguments.length) {
      return _hiddenSize;
    }
    _hiddenSize = hiddenSize;
    return _chart;
  };

  _chart.legendables = function () {
    return [{ chart: _chart, name: _chart._groupName, color: _chart.getColor() }];
  };

  _chart.legendHighlight = function (d) {
    resizeSymbolsWhere(function (symbol) {
      return symbol.attr("fill") === d.color;
    }, _highlightedSize);
    _chart.selectAll(".chart-body path.symbol").filter(function () {
      return _d2.default.select(this).attr("fill") !== d.color;
    }).classed("fadeout", true);
  };

  _chart.legendReset = function (d) {
    resizeSymbolsWhere(function (symbol) {
      return symbol.attr("fill") === d.color;
    }, _symbolSize);
    _chart.selectAll(".chart-body path.symbol").filter(function () {
      return _d2.default.select(this).attr("fill") !== d.color;
    }).classed("fadeout", false);
  };

  function resizeSymbolsWhere(condition, size) {
    var symbols = _chart.selectAll(".chart-body path.symbol").filter(function () {
      return condition(_d2.default.select(this));
    });
    var oldSize = _symbol.size();
    _symbol.size(Math.pow(size, 2));
    (0, _core.transition)(symbols, _chart.transitionDuration()).attr("d", _symbol);
    _symbol.size(oldSize);
  }

  _chart.setHandlePaths = function () {
    // no handle paths for poly-brushes
  };

  _chart.extendBrush = function () {
    var extent = _chart.brush().extent();
    if (_chart.round()) {
      extent[0] = extent[0].map(_chart.round());
      extent[1] = extent[1].map(_chart.round());

      _chart.g().select(".brush").call(_chart.brush().extent(extent));
    }
    return extent;
  };

  _chart.brushIsEmpty = function (extent) {
    return _chart.brush().empty() || !extent || extent[0][0] >= extent[1][0] || extent[0][1] >= extent[1][1];
  };

  function resizeFiltered(filter) {
    var symbols = _chart.selectAll(".chart-body path.symbol").each(function (d) {
      this.filtered = filter && filter.isFiltered(d.key);
    });

    (0, _core.transition)(symbols, _chart.transitionDuration()).attr("d", _symbol);
  }

  _chart._brushing = function () {
    var extent = _chart.extendBrush();

    _chart.redrawBrush(_chart.g());

    if (_chart.brushIsEmpty(extent)) {
      _events.events.trigger(function () {
        _chart.filterAll();
        _chart.redrawGroup();
      });

      resizeFiltered(false);
    } else {
      var ranged2DFilter = _filters.filters.RangedTwoDimensionalFilter(extent);
      _events.events.trigger(function () {
        _chart.filterAll();
        _chart.filter(ranged2DFilter);
        _chart.redrawGroup();
      }, _core.constants.EVENT_DELAY);

      resizeFiltered(ranged2DFilter);
    }
  };

  _chart.setBrushY = function (gBrush) {
    gBrush.call(_chart.brush().y(_chart.y()));
  };

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.splitStrOnLastAs = undefined;
exports.default = mapdTable;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _formattingHelpers = __webpack_require__(6);

var _baseMixin = __webpack_require__(5);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

var _core = __webpack_require__(2);

var _coreAsync = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var INITIAL_SIZE = 50;
var GROUP_DATA_WIDTH = 20;
var NON_GROUP_DATA_WIDTH = 8;
var NON_INDEX = -1;
var ADDITIONAL_HEIGHT = 18;
var SCROLL_DIVISOR = 5;

var splitStrOnLastAs = exports.splitStrOnLastAs = function splitStrOnLastAs(str) {
  var splitStr = [];
  splitStr[0] = str.substring(0, str.lastIndexOf("as") - 1);
  splitStr[1] = str.substring(str.lastIndexOf("as") + 3, str.length);
  return splitStr;
};

function mapdTable(parent, chartGroup) {
  var _chart = (0, _baseMixin2.default)({});
  var _tableWrapper = null;

  var _size = INITIAL_SIZE;
  var _offset = 0;
  var _scrollTop = 0;
  var _pauseAutoLoad = false;

  var _filteredColumns = {};
  var _columnFilterMap = {};
  var _crossfilter = null;
  var _tableFilter = null;
  var _sortColumn = null;
  var _dimOrGroup = null;
  var _isGroupedData = false;
  var _colAliases = null;
  var _sampling = false;
  var _nullsOrder = "";

  var _table_events = ["sort"];
  var _listeners = _d2.default.dispatch.apply(_d2.default, _table_events);
  var _on = _chart.on.bind(_chart);

  _chart.on = function (event, listener) {
    if (_table_events.indexOf(event) === NON_INDEX) {
      _on(event, listener);
    } else {
      _listeners.on(event, listener);
    }
    return _chart;
  };

  _chart._invokeSortListener = function (f) {
    if (f !== "undefined") {
      _listeners.sort(_chart, f);
    }
  };

  _chart.resetTable = function () {
    _chart.root().html("");
  };

  _chart.crossfilter = function (_) {
    if (!arguments.length) {
      return _crossfilter;
    }
    _tableFilter = _.filter();
    _crossfilter = _;
    return _chart;
  };

  _chart.sortColumn = function (_) {
    if (!arguments.length) {
      return _sortColumn;
    }
    _sortColumn = _;
    return _chart;
  };

  _chart.nullsOrder = function (_) {
    if (!arguments.length) {
      return _nullsOrder;
    }
    _nullsOrder = _;
    return _chart;
  };

  _chart.tableWrapper = function (_) {
    if (!arguments.length) {
      return _tableWrapper;
    }
    _tableWrapper = _;
    return _chart;
  };

  _chart.colAliases = function (_) {
    if (!arguments.length) {
      return _colAliases;
    }
    _colAliases = _;
    return _chart;
  };

  _chart.addRowsCallback = function (error, data) {
    if (error) {
      return;
    }
    if (data.length > 0) {
      _pauseAutoLoad = false;
      _chart.dataCache = (_chart.dataCache || []).concat(data);
      _chart._doRedraw(_chart.dataCache);
    }
  };

  _chart.addRows = function () {
    _pauseAutoLoad = true;
    _offset = _offset + _size;
    _chart.getData(_size, _offset, _chart.addRowsCallback);
  };

  _chart.setDataAsync(function (group, callback) {
    var size = _chart.resetTableStateReturnSize();
    _chart.getData(size, 0, callback);
  });

  _chart.data(function () {
    return _chart.dataCache;
  });

  _chart.getData = function (size, offset, callback) {
    _isGroupedData = _chart.dimension().value()[0];
    _dimOrGroup = _isGroupedData ? _chart.group() : _chart.dimension();
    _dimOrGroup.order(_sortColumn ? _sortColumn.col.name : null);
    var sortFuncName = _sortColumn && _sortColumn.order === "asc" ? "bottomAsync" : "topAsync";

    if (!_isGroupedData) {
      _dimOrGroup.nullsOrder(_sortColumn ? _nullsOrder : "");
    }

    if (sortFuncName === "topAsync") {
      return _dimOrGroup[sortFuncName](size, offset).then(function (result) {
        return callback(null, result);
      }).catch(function (error) {
        return callback(error);
      });
    } else {
      return _dimOrGroup[sortFuncName](size, offset, null, callback);
    }
  };

  _chart.resetTableStateReturnSize = function () {
    _pauseAutoLoad = false;

    if (!_isGroupedData && _tableWrapper) {
      _tableWrapper.select(".md-table-scroll").node().scrollTop = 0;
    }
    var size = _size;

    if (_isGroupedData) {
      size = _offset > 0 ? _offset : size;
    } else {
      _offset = 0;
    }
    return size;
  };

  _chart.addFilteredColumn = function (columnName) {
    _filteredColumns[columnName] = null;
  };

  _chart.removeFilteredColumn = function (columnName) {
    delete _filteredColumns[columnName];
  };

  _chart.clearFilteredColumns = function () {
    _filteredColumns = {};
  };

  _chart.getFilteredColumns = function () {
    return _filteredColumns;
  };

  _chart.clearTableFilter = function () {
    _columnFilterMap = {};
    _chart.clearFilteredColumns();
    _tableFilter.filter();
  };

  _chart._doRender = function (data) {
    if (!_tableWrapper) {
      _chart.resetTable();
      _tableWrapper = _chart.root().append("div").attr("class", "md-table-wrapper");

      _tableWrapper.append("div").attr("class", "md-header-spacer");

      _tableWrapper.append("div").attr("class", "md-table-scroll").append("table");

      _tableWrapper.append("div").attr("class", "md-table-header");
    }

    renderTable(data);

    if (_isGroupedData) {
      _tableWrapper.select(".md-table-scroll").node().scrollTop = _scrollTop;
    }

    if (!_pauseAutoLoad) {
      shouldLoadMore();
    }

    return _chart;
  };

  function shouldLoadMore() {
    var scrollDivNode = _tableWrapper.select(".md-table-scroll").node();
    var tableNode = _tableWrapper.select("table").node();
    if (tableNode.scrollHeight > 0 && tableNode.scrollHeight <= scrollDivNode.scrollTop + scrollDivNode.getBoundingClientRect().height + ADDITIONAL_HEIGHT) {
      _chart.addRows();
    }
  }

  function getMeasureColHeaderLabel(d) {
    return d.agg_mode ? d.agg_mode.toUpperCase() + " " + d.expression : d.expression;
  }

  function renderTable() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    var table = _chart.tableWrapper().select("table").html("");

    if (data.length === 0) {
      return;
    }

    var cols = [];

    if (_isGroupedData) {
      _chart.dimension().value().forEach(function (d, i) {
        cols.push({
          expression: d,
          name: "key" + i,
          label: _colAliases ? _colAliases[i] : d,
          type: "dimension",
          measureName: d.measureName
        });
      });
      _chart.group().reduce().forEach(function (d, i) {
        if (d.expression) {
          cols.push({
            expression: d.expression,
            name: d.name,
            agg_mode: d.agg_mode,
            label: _colAliases ? _colAliases[_chart.dimension().value().length + i] : getMeasureColHeaderLabel(d),
            type: "measure",
            measureName: d.measureName
          });
        }
      });
    } else {
      cols = _chart.dimension().getProjectOn().map(function (d, i) {
        var splitStr = splitStrOnLastAs(d);
        return {
          expression: splitStr[0],
          name: splitStr[1],
          label: _colAliases ? _colAliases[i] : splitStr[0],
          type: "project",
          measureName: d.measureName
        };
      });
    }

    var tableHeader = table.append("tr").selectAll("th").data(cols).enter();

    tableHeader.append("th").text(function (d) {
      return d.label;
    });

    var tableRows = table.selectAll(".table-row").data(data).enter();

    var rowItem = tableRows.append("tr").attr("class", function (d) {
      var tableRowCls = "table-row ";
      if (_isGroupedData) {
        tableRowCls = tableRowCls + "grouped-data ";

        if (_chart.hasFilter()) {
          var keyArray = [];
          for (var key in d) {
            if (d.hasOwnProperty(key) && key.includes("key")) {
              keyArray.push(d[key]);
            }
          }
          tableRowCls = tableRowCls + (!_chart.hasFilter(keyArray) ^ _chart.filtersInverse() ? "deselected" : "selected");
        }
      }
      return tableRowCls;
    });

    cols.forEach(function (col) {
      rowItem.append("td").html(function (d) {
        // use custom formatter or default one
        var customFormatter = void 0;
        var val = d[col.name];
        if (col.type === "measure") {
          customFormatter = _chart.valueFormatter();
        } else if (Array.isArray(val) && val[0].value instanceof Date) {
          customFormatter = _chart.dateFormatter();
          val = val[0].value;
        } else {
          customFormatter = _chart.valueFormatter();
        }

        var key = val && val[0] && val[0].isExtract ? null : col.measureName || col.expression;
        return customFormatter && customFormatter(val, key) || (0, _formattingHelpers.formatDataValue)(val);
      }).classed("filtered", col.expression in _filteredColumns).on("click", function (d) {
        // detect if user is selecting text or clicking a value, if so don't filter data
        var s = window.getSelection().toString();
        if (s.length) {
          return;
        }

        if (_isGroupedData) {
          _chart.onClick(d);
        } else if (col.expression in _filteredColumns) {
          clearColFilter(col.expression);
        } else {
          filterCol(col.expression, d[col.name]);
        }
      });
    });

    var dockedHeader = _chart.tableWrapper().select(".md-table-header").html("").append("div").attr("class", "docked-table-header").style("left", function () {
      return "-" + _tableWrapper.select(".md-table-scroll").node().scrollLeft + "px";
    });

    _chart.tableWrapper().select(".md-table-scroll").on("scroll", function () {
      dockedHeader.style("left", "-" + _d2.default.select(this).node().scrollLeft + "px");

      var tableScrollElm = _d2.default.select(this).node();

      if (!_pauseAutoLoad) {
        var scrollHeight = tableScrollElm.scrollTop + tableScrollElm.getBoundingClientRect().height;

        if (tableScrollElm.scrollTop > _scrollTop && table.node().scrollHeight <= scrollHeight + scrollHeight / SCROLL_DIVISOR) {
          _chart.addRows();
        }
      }

      _scrollTop = tableScrollElm.scrollTop;
    });

    table.selectAll("th").each(function (d, i) {
      var headerItem = dockedHeader.append("div").attr("class", "table-header-item").classed("isFiltered", function () {
        return d.expression in _filteredColumns;
      });

      var sortLabel = headerItem.append("div").attr("class", "table-sort").classed("disabled", function () {
        var isString = data[0] ? typeof data[0]["col" + i] === "string" : false;
        return !_isGroupedData && isString;
      }).classed("active", _sortColumn ? _sortColumn.index === i : false).classed(_sortColumn ? _sortColumn.order : "", true).style("width", _d2.default.select(this).node().getBoundingClientRect().width + "px");

      var textSpan = sortLabel.append("span").text(d.label);

      var sortButton = sortLabel.append("div").attr("class", "sort-btn").on("click", function () {
        _tableWrapper.selectAll(".table-sort").classed("active asc desc", false);

        if (_sortColumn && _sortColumn.index === i) {
          _sortColumn = _sortColumn.order === "desc" ? { index: i, col: d, order: "asc" } : null;
        } else {
          _sortColumn = { index: i, col: d, order: "desc" };
        }

        _chart._invokeSortListener(_sortColumn);
        (0, _coreAsync.redrawAllAsync)(_chart.chartGroup());
      });

      sortButton.append("svg").attr("class", "svg-icon").classed("icon-sort", true).attr("viewBox", "0 0 48 48").append("use").attr("xlink:href", "#icon-sort");

      sortButton.append("svg").attr("class", "svg-icon").classed("icon-sort-arrow", true).attr("viewBox", "0 0 48 48").append("use").attr("xlink:href", "#icon-arrow1");

      headerItem.append("div").attr("class", "unfilter-btn").attr("data-expr", d.expression).on("click", function () {
        clearColFilter(_d2.default.select(this).attr("data-expr"));
      }).style("left", textSpan.node().getBoundingClientRect().width + GROUP_DATA_WIDTH + "px").append("svg").attr("class", "svg-icon").classed("icon-unfilter", true).attr("viewBox", "0 0 48 48").append("use").attr("xlink:href", "#icon-unfilter");
    });
  }

  function filterCol(expr, val) {
    var key = _crossfilter.getTable()[0] + "." + expr;
    var columns = _crossfilter.getColumns();
    var type = columns[key].type;

    if (type === "TIMESTAMP") {
      val = "TIMESTAMP(0) '" + val.toISOString().slice(0, 19).replace("T", " ") + "'";
    } else if (type === "DATE") {
      var dateFormat = _d2.default.time.format.utc("%Y-%m-%d");
      val = "DATE '" + dateFormat(val) + "'";
    } else if (val && typeof val === "string") {
      val = "'" + val.replace(/'/g, "''") + "'";
    }

    _chart.addFilteredColumn(expr);
    _columnFilterMap[expr] = val;
    _tableFilter.filter(computeTableFilter(_columnFilterMap));

    (0, _coreAsync.redrawAllAsync)(_chart.chartGroup());
  }

  function clearColFilter(expr) {
    delete _columnFilterMap[expr];
    _chart.removeFilteredColumn(expr);
    _tableFilter.filter(computeTableFilter(_columnFilterMap));
    (0, _coreAsync.redrawAllAsync)(_chart.chartGroup());
  }

  function computeTableFilter(columnFilterMap) {
    // should use class letiables?
    var filter = "";
    var subFilterExpression = null;

    for (var expr in columnFilterMap) {
      if (columnFilterMap[expr] === "null") {
        // null gets translated to "null" by this point
        subFilterExpression = expr + " IS null";
      } else {
        subFilterExpression = expr + " = " + columnFilterMap[expr];
      }

      if (filter === "") {
        filter = filter + subFilterExpression;
      } else {
        filter = filter + " AND " + subFilterExpression;
      }
    }
    return filter;
  }

  _chart._doRedraw = function (data) {
    return _chart._doRender(data);
  };

  _chart.size = function (size) {
    if (!arguments.length) {
      return _size;
    }
    _size = size;
    return _chart;
  };

  _chart.pauseAutoLoad = function () {
    return _pauseAutoLoad;
  };

  _chart.offset = function () {
    return _offset;
  };

  _chart.destroyChart = function () {
    _chart.sampling(false);
  };

  /* istanbul ignore next */
  _chart.sampling = function (setting) {
    // setting should be true or false
    if (!arguments.length) {
      return _sampling;
    }

    if (setting && !_sampling) {
      // if wasn't sampling
      (0, _core.incrementSampledCount)();
    } else if (!setting && _sampling) {
      (0, _core.decrementSampledCount)();
    }

    _sampling = setting;

    if (_sampling === false) {
      _chart.dimension().samplingRatio(null); // unset sampling
    }

    return _chart;
  };

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = boxPlot;

var _core = __webpack_require__(2);

var _coordinateGridMixin = __webpack_require__(11);

var _coordinateGridMixin2 = _interopRequireDefault(_coordinateGridMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _utils = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A box plot is a chart that depicts numerical data via their quartile ranges.
 * @name boxPlot
 * @memberof dc
 * @mixes dc.coordinateGridMixin
 * @example
 * // create a box plot under #chart-container1 element using the default global chart group
 * var boxPlot1 = dc.boxPlot('#chart-container1');
 * // create a box plot under #chart-container2 element using chart group A
 * var boxPlot2 = dc.boxPlot('#chart-container2', 'chartGroupA');
 * @param {String|node|d3.selection} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector} specifying
 * a dom block element such as a div; or a dom element or d3 selection.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
 * Interaction with a chart will only trigger events and redraws within the chart's group.
 * @return {dc.boxPlot}
 */
function boxPlot(parent, chartGroup) {
  var _chart = (0, _coordinateGridMixin2.default)({});

  // Returns a function to compute the interquartile range.
  function DEFAULT_WHISKERS_IQR(k) {
    return function (d) {
      var q1 = d.quartiles[0],
          q3 = d.quartiles[2],
          iqr = (q3 - q1) * k,
          i = -1,
          j = d.length;
      do {
        ++i;
      } while (d[i] < q1 - iqr);
      do {
        --j;
      } while (d[j] > q3 + iqr);
      return [i, j];
    };
  }

  var _whiskerIqrFactor = 1.5;
  var _whiskersIqr = DEFAULT_WHISKERS_IQR;
  var _whiskers = _whiskersIqr(_whiskerIqrFactor);

  var _box = _d2.default.box();
  var _tickFormat = null;

  var _boxWidth = function _boxWidth(innerChartWidth, xUnits) {
    if (_chart.isOrdinal()) {
      return _chart.x().rangeBand();
    } else {
      return innerChartWidth / (1 + _chart.boxPadding()) / xUnits;
    }
  };

  // default padding to handle min/max whisker text
  _chart.yAxisPadding(12);

  // default to ordinal
  _chart.x(_d2.default.scale.ordinal());
  _chart.xUnits(_core.units.ordinal);

  // valueAccessor should return an array of values that can be coerced into numbers
  // or if data is overloaded for a static array of arrays, it should be `Number`.
  // Empty arrays are not included.
  _chart.data(function (group) {
    return group.all().map(function (d) {
      d.map = function (accessor) {
        return accessor.call(d, d);
      };
      return d;
    }).filter(function (d) {
      var values = _chart.valueAccessor()(d);
      return values.length !== 0;
    });
  });

  /**
   * Get or set the spacing between boxes as a fraction of box size. Valid values are within 0-1.
   * See the {@link https://github.com/mbostock/d3/wiki/Ordinal-Scales#wiki-ordinal_rangeBands d3 docs}
   * for a visual description of how the padding is applied.
   * @name boxPadding
   * @memberof dc.boxPlot
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/Ordinal-Scales#wiki-ordinal_rangeBands d3.scale.ordinal.rangeBands}
   * @param {Number} [padding=0.8]
   * @return {Number}
   * @return {dc.boxPlot}
   */
  _chart.boxPadding = _chart._rangeBandPadding;
  _chart.boxPadding(0.8);

  /**
   * Get or set the outer padding on an ordinal box chart. This setting has no effect on non-ordinal charts
   * or on charts with a custom {@link #dc.boxPlot+boxWidth .boxWidth}. Will pad the width by
   * `padding * barWidth` on each side of the chart.
   * @name outerPadding
   * @memberof dc.boxPlot
   * @instance
   * @param {Number} [padding=0.5]
   * @return {Number}
   * @return {dc.boxPlot}
   */
  _chart.outerPadding = _chart._outerRangeBandPadding;
  _chart.outerPadding(0.5);

  /**
   * Get or set the numerical width of the boxplot box. The width may also be a function taking as
   * parameters the chart width excluding the right and left margins, as well as the number of x
   * units.
   * @example
   * // Using numerical parameter
   * chart.boxWidth(10);
   * // Using function
   * chart.boxWidth((innerChartWidth, xUnits) { ... });
   * @name boxWidth
   * @memberof dc.boxPlot
   * @instance
   * @param {Number|Function} [boxWidth=0.5]
   * @return {Number|Function}
   * @return {dc.boxPlot}
   */
  _chart.boxWidth = function (boxWidth) {
    if (!arguments.length) {
      return _boxWidth;
    }
    _boxWidth = _d2.default.functor(boxWidth);
    return _chart;
  };

  var boxTransform = function boxTransform(d, i) {
    var xOffset = _chart.x()(_chart.keyAccessor()(d, i));
    return "translate(" + xOffset + ", 0)";
  };

  _chart._preprocessData = function () {
    if (_chart.elasticX()) {
      _chart.x().domain([]);
    }
  };

  _chart.plotData = function () {
    var _calculatedBoxWidth = _boxWidth(_chart.effectiveWidth(), _chart.xUnitCount());

    _box.whiskers(_whiskers).width(_calculatedBoxWidth).height(_chart.effectiveHeight()).value(_chart.valueAccessor()).domain(_chart.y().domain()).duration(_chart.transitionDuration()).tickFormat(_tickFormat);

    var boxesG = _chart.chartBodyG().selectAll("g.box").data(_chart.data(), function (d) {
      return d.key;
    });

    renderBoxes(boxesG);
    updateBoxes(boxesG);
    removeBoxes(boxesG);

    _chart.fadeDeselectedArea();
  };

  function renderBoxes(boxesG) {
    var boxesGEnter = boxesG.enter().append("g");

    boxesGEnter.attr("class", "box").attr("transform", boxTransform).call(_box).on("click", function (d) {
      _chart.filter(d.key);
      _chart.redrawGroup();
    });
  }

  function updateBoxes(boxesG) {
    (0, _core.transition)(boxesG, _chart.transitionDuration()).attr("transform", boxTransform).call(_box).each(function () {
      _d2.default.select(this).select("rect.box").attr("fill", _chart.getColor);
    });
  }

  function removeBoxes(boxesG) {
    boxesG.exit().remove().call(_box);
  }

  _chart.fadeDeselectedArea = function () {
    if (_chart.hasFilter()) {
      _chart.g().selectAll("g.box").each(function (d) {
        if (_chart.isSelectedNode(d)) {
          _chart.highlightSelected(this);
        } else {
          _chart.fadeDeselected(this);
        }
      });
    } else {
      _chart.g().selectAll("g.box").each(function () {
        _chart.resetHighlight(this);
      });
    }
  };

  _chart.isSelectedNode = function (d) {
    return _chart.hasFilter(d.key);
  };

  _chart.yAxisMin = function () {
    var min = _d2.default.min(_chart.data(), function (e) {
      return _d2.default.min(_chart.valueAccessor()(e));
    });
    return _utils.utils.subtract(min, _chart.yAxisPadding());
  };

  _chart.yAxisMax = function () {
    var max = _d2.default.max(_chart.data(), function (e) {
      return _d2.default.max(_chart.valueAccessor()(e));
    });
    return _utils.utils.add(max, _chart.yAxisPadding());
  };

  /**
   * Set the numerical format of the boxplot median, whiskers and quartile labels. Defaults to
   * integer formatting.
   * @example
   * // format ticks to 2 decimal places
   * chart.tickFormat(d3.format('.2f'));
   * @name tickFormat
   * @memberof dc.boxPlot
   * @instance
   * @param {Function} [tickFormat]
   * @return {Number|Function}
   * @return {dc.boxPlot}
   */
  _chart.tickFormat = function (tickFormat) {
    if (!arguments.length) {
      return _tickFormat;
    }
    _tickFormat = tickFormat;
    return _chart;
  };

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = countWidget;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _core = __webpack_require__(2);

var _coreAsync = __webpack_require__(4);

var _baseMixin = __webpack_require__(5);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function countWidget(parent, chartGroup) {
  var _chart = (0, _baseMixin2.default)({});

  var _formatNumber = _d2.default.format(",");
  var _countLabel = "rows";
  var _tot = null;

  (0, _core.override)(_chart, "group", function (group, name) {
    if (!arguments.length) {
      return _chart._group();
    }

    (0, _coreAsync.groupAll)(group);
    return _chart._group(group, name);
  });

  var noop = function noop() {
    return null;
  };
  _chart.isCountChart = function () {
    return true;
  };
  _chart.dataFetchRequestCallback(noop);
  _chart.dataFetchSuccessfulCallback(noop);

  _chart.formatNumber = function (formatter) {
    if (!arguments.length) {
      return _formatNumber;
    }
    _formatNumber = formatter;
    return _chart;
  };

  _chart.countLabel = function (_) {
    if (!arguments.length) {
      return _countLabel;
    }
    _countLabel = _;
    return _chart;
  };

  _chart.tot = function (number) {
    if (!arguments.length) {
      return _tot;
    }
    _tot = number;
    return _chart;
  };

  _chart.getTotalRecordsAsync = function () {
    if (_chart.tot()) {
      return Promise.resolve();
    }

    return _chart.dimension().sizeAsync().then(function (tot) {
      _chart.tot(tot);
      return Promise.resolve();
    });
  };

  _chart.setDataAsync(function (group, callbacks) {
    return _chart.getTotalRecordsAsync().then(function () {
      var id = group.getCrossfilterId();
      var filterSize = (0, _coreAsync.lastFilteredSize)(id);
      if (filterSize !== undefined) {
        return Promise.resolve(filterSize);
      } else {
        return group.valueAsync().then(function (value) {
          (0, _coreAsync.setLastFilteredSize)(id, value);
          return value;
        });
      }
    }).then(function (value) {
      callbacks(null, value);
    }).catch(function (error) {
      callbacks(error);
    });
  });

  _chart._doRender = function (val) {
    var all = _formatNumber(_chart.tot());
    var selected = _formatNumber(val);

    var wrapper = _chart.root().style("width", "auto").style("height", "auto").html("").append("div").attr("class", "count-widget");

    wrapper.append("span").attr("class", "count-selected").classed("not-filtered", selected === all).text(selected === "-0" ? 0 : selected);

    wrapper.append("span").classed("not-filtered", selected === all).text(" of ");

    wrapper.append("span").attr("class", "count-all").text(all);

    wrapper.append("span").attr("class", "count-label").text(" " + _countLabel);

    return _chart;
  };

  _chart._doRedraw = function (val) {
    return _chart._doRender(val);
  };

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = rasterLayer;

var _capMixin = __webpack_require__(10);

var _capMixin2 = _interopRequireDefault(_capMixin);

var _rasterLayerPointMixin = __webpack_require__(149);

var _rasterLayerPointMixin2 = _interopRequireDefault(_rasterLayerPointMixin);

var _rasterLayerPolyMixin = __webpack_require__(150);

var _rasterLayerPolyMixin2 = _interopRequireDefault(_rasterLayerPolyMixin);

var _rasterLayerHeatmapMixin = __webpack_require__(148);

var _rasterLayerHeatmapMixin2 = _interopRequireDefault(_rasterLayerHeatmapMixin);

var _utilsVega = __webpack_require__(15);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var validLayerTypes = ["points", "polys", "heat"];

function rasterLayer(layerType) {
  var _layerType = layerType;

  var _dimension = null;
  var _group = null;
  var _groupName = null;
  var _mandatoryAttributes2 = [];

  var _layer = (0, _capMixin2.default)({
    setDataAsync: function setDataAsync(callback) {
      // noop.
      // This is to appease mixins that require an object initialized with a baseMixin
    },
    data: function data(callback) {
      // noop.
      // This is to appease mixins that require an object initialized with a baseMixin
    },
    filter: function filter() {
      // noop.
      // This is to appease mixins that require an object initialized with a baseMixin
    },
    _mandatoryAttributes: function _mandatoryAttributes(mandatoryAttributes) {
      // needed for layer mixins to control mandatory checks.

      if (!arguments.length) {
        return _mandatoryAttributes2;
      }
      _mandatoryAttributes2 = mandatoryAttributes;
      return _layer;
    }
  });

  _layer.othersGrouper(false); // TODO(croot): what does othersGrouper in capMixin do exactly?
  // Always set to false for now, tho user can override.

  if (layerType == "points") {
    _layer = (0, _rasterLayerPointMixin2.default)(_layer);
  } else if (layerType == "polys") {
    _layer = (0, _rasterLayerPolyMixin2.default)(_layer);
  } else if (/heat/.test(layerType)) {
    _layer = (0, _rasterLayerHeatmapMixin2.default)(_layer);
  } else {
    throw new Error('"' + layerType + '" is not a valid layer type. The valid layer types are: ' + validLayerTypes.join(", "));
  }

  var _opacity = 1;

  // NOTE: builds _layer.defaultFillColor(), _layer.nullFillColor(),
  //              _layer.fillColorScale(), & _layer.fillColorAttr()
  (0, _utilsVega.createVegaAttrMixin)(_layer, "fillColor", "#22A7F0", "#CACACA", true);

  // NOTE: builds _layer.defaultStrokeColor(), _layer.nullStrokeColor(),
  //              _layer.strokeColorScale(), & _layer.strokeColorAttr()
  (0, _utilsVega.createVegaAttrMixin)(_layer, "strokeColor", "white", "white", true);

  // NOTE: builds _layer.defaultStrokeWidth(), _layer.nullStrokeWidth(),
  //              _layer.strokeWidthScale(), & _layer.strokeWidthAttr()
  (0, _utilsVega.createVegaAttrMixin)(_layer, "strokeWidth", 0, 0, true);

  _layer.popupColumns = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, []);
  _layer.popupColumnsMapped = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, {});
  _layer.popupFunction = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);
  _layer.popupStyle = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, {});
  _layer.densityAccumulatorEnabled = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, false);

  var _popup_wrap_class = "map-popup-wrap-new";
  var _popup_box_class = "map-popup-box-new";
  var _popup_box_item_class = "map-popup-item";
  var _popup_item_key_class = "popup-item-key";
  var _popup_item_val_class = "popup-item-val";
  var _layerPopups = {};

  _layer.layerType = function () {
    return _layerType;
  };

  /**
   * **mandatory**
   *
   * Set or get the dimension attribute of a chart. In `dc`, a dimension can be any valid [crossfilter
   * dimension](https://github.com/square/crossfilter/wiki/API-Reference#wiki-dimension).
   *
   * If a value is given, then it will be used as the new dimension. If no value is specified then
   * the current dimension will be returned.
   * @name dimension
   * @memberof dc.baseMixin
   * @instance
   * @see {@link https://github.com/square/crossfilter/wiki/API-Reference#dimension crossfilter.dimension}
   * @example
   * var index = crossfilter([]);
   * var dimension = index.dimension(dc.pluck('key'));
   * chart.dimension(dimension);
   * @param {crossfilter.dimension} [dimension]
   * @return {crossfilter.dimension}
   * @return {dc.baseMixin}
   */
  _layer.dimension = function (dimension) {
    if (!arguments.length) {
      return _dimension;
    }
    _dimension = dimension;
    return _layer;
  };

  /**
   * **mandatory**
   *
   * Set or get the group attribute of a chart. In `dc` a group is a
   * {@link https://github.com/square/crossfilter/wiki/API-Reference#group-map-reduce crossfilter group}.
   * Usually the group should be created from the particular dimension associated with the same chart. If a value is
   * given, then it will be used as the new group.
   *
   * If no value specified then the current group will be returned.
   * If `name` is specified then it will be used to generate legend label.
   * @name group
   * @memberof dc.baseMixin
   * @instance
   * @see {@link https://github.com/square/crossfilter/wiki/API-Reference#group-map-reduce crossfilter.group}
   * @example
   * var index = crossfilter([]);
   * var dimension = index.dimension(dc.pluck('key'));
   * chart.dimension(dimension);
   * chart.group(dimension.group(crossfilter.reduceSum()));
   * @param {crossfilter.group} [group]
   * @param {String} [name]
   * @return {crossfilter.group}
   * @return {dc.baseMixin}
   */
  _layer.group = function (group, name) {
    if (!arguments.length) {
      return _group;
    }
    _group = group;
    _layer._groupName = name;
    return _layer;
  };

  _layer.opacity = function (opacity) {
    if (!arguments.length) {
      return _opacity;
    }
    _opacity = opacity;
    return _layer;
  };

  function checkForMandatoryLayerAttr(layer, a, layerName) {
    if (!layer[a] || !layer[a]()) {
      throw new Error("Mandatory attribute chart." + a + " is missing on raster layer " + layerName);
    }
  }

  function genHeatConfigFromChart(chart) {
    return {
      table: _layer.crossfilter().getTable()[0],
      width: Math.round(chart.width() * chart._getPixelRatio()),
      height: Math.round(chart.height() * chart._getPixelRatio()),
      min: chart.conv4326To900913(chart._minCoord),
      max: chart.conv4326To900913(chart._maxCoord),
      filter: _layer.crossfilter().getFilterString(),
      globalFilter: _layer.crossfilter().getGlobalFilterString(),
      neLat: chart._maxCoord[1],
      zoom: chart.zoom()
    };
  }

  _layer.genVega = function (chart, layerName) {
    var cap = _layer.cap();
    var group = _layer.group() || {};
    var query = "";
    if (group.type === "dimension") {
      query = group.writeTopQuery(cap, undefined, true);
    } else if (group.type === "group") {
      query = group.writeTopQuery(cap, undefined, false, true);
    }

    if (!query.length) {
      // throw new Error("Crossfilter group/dimension did not provide a sql query string for layer " + layerName + "." + (groupType.length ? " Group type: " + (group.type || "unknown") + "." : ""))
    }

    if (_layer.type === "heatmap") {
      var vega = _layer._genVega(_extends({}, genHeatConfigFromChart(chart), {
        layerName: layerName
      }));
      return vega;
    } else {
      var _vega = _layer._genVega(chart, layerName, group, query);
      return _vega;
    }
  };

  _layer.hasPopupColumns = function () {
    var popCols = _layer.popupColumns();
    return Boolean(popCols && popCols instanceof Array && popCols.length > 0);
  };

  function addPopupColumnToSet(colAttr, popupColSet) {
    // TODO(croot): getProjectOn for groups requires the two arguments,
    // dimension.getProjectOn() doesn't have any args.
    // Need to come up with a better API for group.getProjectOn()
    // and improve the api so that "as key0" are not automatically
    // added to those projection statements.

    // TODO(croot): performance could be improved here with a better
    // data structure, but probably not an issue given the amount
    // of popup col attrs to iterate through is small
    var dim = _layer.group() || _layer.dimension();
    if (dim || _layer.layerType() === "points") {
      var projExprs = _layer.layerType() === "points" ? _layer.getProjections() : dim.getProjectOn(true); // handles the group and dimension case
      var regex = /^\s*(\S+)\s+as\s+(\S+)/i;
      var funcRegex = /^\s*(\S+\s*\(.*\))\s+as\s+(\S+)/i;
      for (var i = 0; i < projExprs.length; ++i) {
        var projExpr = projExprs[i];
        var regexRtn = projExpr.match(regex);
        if (regexRtn) {
          if (regexRtn[2] === colAttr) {
            popupColSet.delete(colAttr);
            colAttr = projExpr;
            break;
          }
        } else if ((regexRtn = projExpr.match(funcRegex)) && regexRtn[2] === colAttr) {
          popupColSet.delete(colAttr);
          colAttr = projExpr;
          break;
        } else if (projExpr && projExpr.replace(/^\s+|\s+$/g, "") === colAttr) {
          break;
        }
      }
    }
    return popupColSet.add(colAttr);
  }

  _layer.getPopupAndRenderColumns = function (chart) {
    var popupColsSet = new Set();
    var popupCols = _layer.popupColumns();
    if (popupCols) {
      popupCols.forEach(function (colAttr) {
        addPopupColumnToSet(colAttr, popupColsSet);
      });
    }
    _layer._addRenderAttrsToPopupColumnSet(chart, popupColsSet);

    var rtnArray = [];
    popupColsSet.forEach(function (colName) {
      rtnArray.push(colName);
    });
    return rtnArray;
  };

  function mapDataViaColumns(data, popupColumns, chart) {
    var newData = {};
    var columnSet = new Set(popupColumns);
    for (var key in data) {
      if (!columnSet.has(key)) {
        continue;
      }
      newData[key] = data[key];
      if (typeof chart.useLonLat === "function" && chart.useLonLat()) {
        if (key === "x") {
          newData[key] = chart.conv900913To4326X(data[key]);
        } else if (key === "y") {
          newData[key] = chart.conv900913To4326Y(data[key]);
        }
      }
    }
    return newData;
  }

  _layer.areResultsValidForPopup = function (results) {
    if (!results) {
      return false;
    }
    return _layer._areResultsValidForPopup(results[0]);
  };

  function renderPopupHTML(data, columnOrder, columnMap, formatMeasureValue) {
    var html = "";
    columnOrder.forEach(function (key) {
      if (typeof data[key] === "undefined" || data[key] === null) {
        return;
      }

      var columnKey = columnMap && columnMap[key] ? columnMap[key] : key;
      var columnKeyTrimmed = columnKey.replace(/.*\((.*)\).*/, "$1");

      html = html + ('<div class="' + _popup_box_item_class + '"><span class="' + _popup_item_key_class + '">' + columnKey + ':</span><span class="' + _popup_item_val_class + '"> ' + formatMeasureValue(data[key], columnKeyTrimmed) + "</span></div>");
    });
    return html;
  }

  _layer.displayPopup = function (chart, parentElem, result, minPopupArea, animate) {
    var data = result.row_set[0];
    var popupColumns = _layer.popupColumns();
    var mappedColumns = _layer.popupColumnsMapped();
    var filteredData = mapDataViaColumns(data, popupColumns, chart);

    var width = typeof chart.effectiveWidth === "function" ? chart.effectiveWidth() : chart.width();
    var height = typeof chart.effectiveHeight === "function" ? chart.effectiveHeight() : chart.height();
    var margins = typeof chart.margins === "function" ? chart.margins() : { left: 0, right: 0, top: 0, bottom: 0 };

    var xscale = chart.x();
    var yscale = chart.y();

    var origXRange = xscale.range();
    var origYRange = yscale.range();

    xscale.range([0, width]);
    yscale.range([0, height]);

    var popupData = _layer._displayPopup(chart, parentElem, data, width, height, margins, xscale, yscale, minPopupArea, animate);

    // restore the original ranges so we don't screw anything else up
    xscale.range(origXRange);
    yscale.range(origYRange);

    var rndrProps = popupData.rndrPropSet;
    var bounds = popupData.bounds;

    var boundsWidth = bounds[1] - bounds[0];
    var boundsHeight = bounds[3] - bounds[2];
    var posX = bounds[0] + boundsWidth / 2;
    var posY = bounds[2] + boundsHeight / 2;

    var parentBounds = [0, width, 0, height];

    var overlapBounds = [Math.max(bounds[0], parentBounds[0]), Math.min(bounds[1], parentBounds[1]), Math.max(bounds[2], parentBounds[2]), Math.min(bounds[3], parentBounds[3])];

    if (overlapBounds[1] <= overlapBounds[0] || overlapBounds[3] <= overlapBounds[2]) {
      // there is no overlap with the two bounds, we should
      // never get here
      throw new Error("Found a non-overlapping bounds for a pop-up shape and its parent div");
    }

    var overlapBoundsWidth = overlapBounds[1] - overlapBounds[0];
    var overlapBoundsHeight = overlapBounds[3] - overlapBounds[2];
    var overlapCenterX = overlapBounds[0] + overlapBoundsWidth / 2;
    var overlapCenterY = overlapBounds[2] + overlapBoundsHeight / 2;

    var padding = 6; // in pixels TODO(croot): expose in css?
    var bottom = false;
    var topOffset = 0;

    var popupDiv = parentElem.append("div").attr("class", _popup_wrap_class).style({ left: posX + "px", top: posY + "px" });

    var popupBox = popupDiv.append("div").attr("class", _popup_box_class).html(_layer.popupFunction() ? _layer.popupFunction(filteredData, popupColumns, mappedColumns) : renderPopupHTML(filteredData, popupColumns, mappedColumns, chart.measureValue)).style("left", function () {
      var rect = d3.select(this).node().getBoundingClientRect();
      var boxWidth = rect.width;
      var halfBoxWidth = boxWidth / 2;
      var boxHeight = rect.height;
      var halfBoxHeight = boxHeight / 2;

      // check top first
      var left = 0;
      var hDiff = 0,
          wDiff = 0;

      if (overlapBoundsWidth >= boxWidth || posX + halfBoxWidth < width && posX - halfBoxWidth >= 0) {
        left = posX - overlapCenterX;
        hDiff = overlapBounds[2] - boxHeight;

        if (hDiff >= 0) {
          // can fit on top of shape and in the center of the shape horizontally
          topOffset = -(posY - overlapBounds[2] + Math.min(padding, hDiff) + halfBoxHeight);
          return left + "px";
        }

        hDiff = overlapBounds[3] + boxHeight;
        if (hDiff < height) {
          // can fit on bottom and in the center of the shape horizontally
          topOffset = overlapBounds[3] - posY + Math.min(padding, hDiff) + halfBoxHeight;
          return left + "px";
        }
      }

      if (overlapBoundsHeight >= boxHeight || posY + halfBoxHeight < height && posY - halfBoxHeight >= 0) {
        topOffset = overlapCenterY - posY;

        wDiff = overlapBounds[0] - boxWidth;
        if (wDiff >= 0) {
          // can fit on the left in the center of the shape vertically
          left = -(posX - overlapBounds[0] + Math.min(padding, wDiff) + halfBoxWidth);
          return left + "px";
        }

        wDiff = overlapBounds[1] + boxWidth;
        if (wDiff < width) {
          // can fit on right in the center of the shape vertically
          left = overlapBounds[1] - posX + Math.min(padding, wDiff) + halfBoxWidth;
          return left + "px";
        }
      }

      if (width - overlapBoundsWidth >= boxWidth && height - overlapBoundsHeight >= boxHeight) {
        // we can fit the popup box in the remaining negative space.
        // Let's figure out where exactly
        if (Math.abs(boxHeight - overlapBoundsHeight) < Math.abs(boxWidth - overlapBoundsWidth)) {
          hDiff = height - overlapBoundsHeight - boxHeight;
          if (overlapBounds[2] < height - overlapBounds[3]) {
            topOffset = Math.min(padding, hDiff) + halfBoxHeight - posY;
          } else {
            topOffset = height - Math.min(padding, hDiff) - halfBoxHeight - posY;
          }

          wDiff = overlapBounds[0] - boxWidth;
          if (wDiff >= 0) {
            // can fit on the left of the bounds
            left = -(posX - overlapBounds[0] + Math.min(padding, wDiff) + halfBoxWidth);
          } else {
            wDiff = overlapBounds[1] + boxWidth;
            // can fit on right right of the bounds
            left = overlapBounds[1] - posX + Math.min(padding, wDiff) + halfBoxWidth;
          }
          return left + "px";
        } else {
          wDiff = width - overlapBoundsWidth - boxWidth;
          if (overlapBounds[0] < width - overlapBounds[1]) {
            left = Math.min(padding, wDiff) + halfBoxWidth - posX;
          } else {
            left = width - Math.min(padding, wDiff) - halfBoxWidth - posX;
          }

          hDiff = overlapBounds[2] - boxHeight;
          if (hDiff >= 0) {
            // can fit on top of shape and in the center of the shape horizontally
            topOffset = -(posY - overlapBounds[2] + Math.min(padding, hDiff) + halfBoxHeight);
          } else {
            hDiff = overlapBounds[3] + boxHeight;
            // can fit on bottom and in the center of the shape horizontally
            topOffset = overlapBounds[3] - posY + Math.min(padding, hDiff) + halfBoxHeight;
          }
          return left + "px";
        }
      }

      if (boxWidth * boxHeight < overlapBoundsWidth * overlapBoundsHeight) {
        // use the center of the overlapping bounds in the case where the box
        // can't fit anwhere on the outside
        topOffset = overlapCenterY - posY;
        left = overlapCenterX - posX;
      } else {
        // use the center of the screen
        topOffset = height / 2 - posY;
        left = width / 2 - posX;
      }
      return left + "px";
    }).style("top", function () {
      return topOffset + "px";
    });

    _layerPopups[chart] = popupBox;

    if (animate) {
      popupDiv.classed("showPopup", true);
    }
  };

  _layer.isPopupDisplayed = function (chart) {
    return _layerPopups[chart] !== undefined;
  };

  _layer.hidePopup = function (chart, hideCallback) {
    if (_layerPopups[chart]) {
      var popup = chart.select("." + _popup_wrap_class);
      if (popup) {
        popup.classed("removePopup", true).on("animationend", function () {
          delete _layerPopups[chart];
          hideCallback(chart);
        });
      }

      _layer._hidePopup(chart);
    }
  };

  _layer.destroyLayer = function (chart) {
    // need to define a "_destroyLayer" method for each
    // layer mixin
    _layer._destroyLayer(chart);
  };

  _layer._addQueryDrivenRenderPropToSet = function (setObj, markPropObj, prop) {
    if (_typeof(markPropObj[prop]) !== "object") {
      return;
    }

    if (typeof markPropObj[prop].field !== "string") {
      return;
    }

    var queryAttr = markPropObj[prop].field;
    addPopupColumnToSet(queryAttr, setObj);
    return setObj;
  };

  return _layer;
}

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rasterMixin;

var _core = __webpack_require__(2);

var _coreAsync = __webpack_require__(4);

var _utils = __webpack_require__(3);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function rasterMixin(_chart) {
  var _con = window.hasOwnProperty("con") ? con : null;
  var _sampling = false;
  var _tableName = null;
  var _popupColumns = [];
  var _popupColumnsMapped = {};
  var _popupSearchRadius = 2;
  var _popupFunction = null;
  var _colorBy = null;
  var _sizeBy = null;
  var _showColorByInPopup = false;
  var _mouseLeave = false; // used by displayPopup to maybe return early
  var _minMaxCache = {};
  var _crossfilter = null;

  var _data_events = ["preData"];
  var _listeners = _d2.default.dispatch.apply(_d2.default, _data_events);
  var _on = _chart.on.bind(_chart);

  var _popupDisplayable = true;

  _chart.popupDisplayable = function (displayable) {
    _popupDisplayable = Boolean(displayable);
  };

  _chart.on = function (event, listener) {
    if (_data_events.indexOf(event) === -1) {
      _on(event, listener);
    } else {
      _listeners.on(event, listener);
    }
    return _chart;
  };

  _chart._invokePreDataListener = function (f) {
    if (f !== "undefined") {
      _listeners.preData(_chart, f);
    }
  };

  _chart.getMinMax = function (value) {
    if (_minMaxCache[value]) {
      return Promise.resolve(_minMaxCache[value]);
    }

    return _chart.crossfilter().groupAll().reduce([{ expression: value, agg_mode: "min", name: "minimum" }, { expression: value, agg_mode: "max", name: "maximum" }]).valuesAsync(true).then(function (bounds) {
      _minMaxCache[value] = [bounds.minimum, bounds.maximum];
      return _minMaxCache[value];
    });
  };

  _chart.getTopValues = function (value) {
    var NUM_TOP_VALUES = 10;
    var OFFSET = 0;

    if (_minMaxCache[value]) {
      return Promise.resolve(_minMaxCache[value]);
    }

    return _chart.crossfilter().dimension(value).order("val").group().reduceCount(value).topAsync(NUM_TOP_VALUES, OFFSET, null, true).then(function (results) {
      return results.map(function (result) {
        return result.key0;
      });
    });
  };

  _chart.crossfilter = function (_) {
    if (!arguments.length) {
      return _crossfilter;
    }
    _crossfilter = _;
    return _chart;
  };

  _chart.xRangeFilter = function (range) {
    if (!_chart.xDim()) {
      throw new Error("Must set xDim before invoking xRange");
    }

    var xValue = _chart.xDim().value()[0];

    if (!arguments.length) {
      return _minMaxCache[xValue];
    }

    _minMaxCache[xValue] = range;
    return _chart;
  };

  _chart.yRangeFilter = function (range) {
    if (!_chart.yDim()) {
      throw new Error("Must set yDim before invoking yRange");
    }

    var yValue = _chart.yDim().value()[0];

    if (!arguments.length) {
      return _minMaxCache[yValue];
    }

    _minMaxCache[yValue] = range;
    return _chart;
  };

  _chart.popupSearchRadius = function (popupSearchRadius) {
    if (!arguments.length) {
      return _popupSearchRadius;
    }
    _popupSearchRadius = popupSearchRadius;
    return _chart;
  };

  _chart._resetVegaSpec = function () {
    var pixelRatio = this._getPixelRatio();
    _chart._vegaSpec.width = Math.round(_chart.width() * pixelRatio);
    _chart._vegaSpec.height = Math.round(_chart.height() * pixelRatio);
    _chart._vegaSpec.data = [{
      name: "table",
      sql: "select x, y from tweets;"
    }];
    if (_tableName) {
      _chart._vegaSpec.data[0].dbTableName = _tableName;
    }
    _chart._vegaSpec.scales = [];
    _chart._vegaSpec.marks = [];
  };

  _chart.con = function (_) {
    if (!arguments.length) {
      return _con;
    }
    _con = _;
    return _chart;
  };

  _chart.popupColumns = function (popupColumns) {
    if (!arguments.length) {
      return _popupColumns;
    }
    _popupColumns = popupColumns;
    return _chart;
  };

  _chart.popupColumnsMapped = function (popupColumnsMapped) {
    if (!arguments.length) {
      return _popupColumnsMapped;
    }
    _popupColumnsMapped = popupColumnsMapped;
    return _chart;
  };

  _chart.tableName = function (tableName) {
    if (!arguments.length) {
      return _tableName;
    }
    _tableName = tableName;
    return _chart;
  };

  _chart.popupFunction = function (popupFunction) {
    if (!arguments.length) {
      return _popupFunction;
    }
    _popupFunction = popupFunction;
    return _chart;
  };

  // _determineScaleType because there is no way to determine the scale type
  // in d3 except for looking to see what member methods exist for it
  _chart.sampling = function (isSetting) {
    // isSetting should be true or false
    if (!arguments.length) {
      return _sampling;
    }
    if (isSetting && !_sampling) {
      // if wasn't sampling
      (0, _core.incrementSampledCount)();
    } else if (!isSetting && _sampling) {
      (0, _core.decrementSampledCount)();
    }
    _sampling = isSetting;
    if (_sampling === false) {
      _chart.dimension().samplingRatio(null); // unset sampling
    }
    return _chart;
  };

  _chart.setSample = function () {
    if (_sampling) {
      var id = _chart.dimension().getCrossfilterId();
      var filterSize = (0, _coreAsync.lastFilteredSize)(id);
      if (filterSize == undefined) {
        _chart.dimension().samplingRatio(null);
      } else {
        _chart.dimension().samplingRatio(Math.min(_chart.cap() / filterSize, 1.0));
      }
    }
  };

  _chart._determineScaleType = function (scale) {
    var scaleType = null;
    if (scale.rangeBand !== undefined) {
      return "ordinal";
    }
    if (scale.exponent !== undefined) {
      return "power";
    }
    if (scale.base !== undefined) {
      return "log";
    }
    if (scale.quantiles !== undefined) {
      return "quantiles";
    }
    if (scale.interpolate !== undefined) {
      return "linear";
    }
    return "quantize";
  };

  _chart.vegaSpec = function (_) {
    if (!arguments.length) {
      return _chart._vegaSpec;
    }
    _chart._vegaSpec = _;
    return _chart;
  };

  _chart.colorBy = function (_) {
    if (!arguments.length) {
      return _colorBy;
    }
    _colorBy = _;
    return _chart;
  };

  _chart.sizeBy = function (_) {
    if (!arguments.length) {
      return _sizeBy;
    }
    _sizeBy = _;
    return _chart;
  };

  _chart.getClosestResult = function getClosestResult(point, callback) {
    if (_chart.drawMode && _chart.drawMode() || !_chart.popupColumns().length) {
      return;
    }
    var height = typeof _chart.effectiveHeight === "function" ? _chart.effectiveHeight() : _chart.height();
    var pixelRatio = _chart._getPixelRatio() || 1;
    var pixel = new TPixel({
      x: Math.round(point.x * pixelRatio),
      y: Math.round((height - point.y) * pixelRatio)
    });
    var tableName = _chart.tableName();
    var columns = getColumnsWithPoints();
    // TODO best to fail, skip cb, or call cb wo args?
    if (!point || !tableName || !columns.length || columns.length === 3 && hideColorColumnInPopup()) {
      return;
    }
    return _chart.con().getResultRowForPixel(_chart.__dcFlag__, pixel, { table: columns }, [function (results) {
      return callback(results[0]);
    }], _popupSearchRadius * pixelRatio);
  };

  _chart.displayPopup = function displayPopup(result) {
    if (!_popupDisplayable || _mouseLeave || !result || !result.row_set || !result.row_set.length) {
      return;
    }
    if (_chart.select(".map-popup").empty()) {
      // show only one popup at a time.
      var data = result.row_set[0];
      var mappedData = mapDataViaColumns(data, _popupColumnsMapped);
      if (Object.keys(mappedData).length === 2) {
        return;
      } // xPoint && yPoint
      var offsetBridge = 0;

      var width = typeof _chart.effectiveWidth === "function" ? _chart.effectiveWidth() : _chart.width();
      var height = typeof _chart.effectiveHeight === "function" ? _chart.effectiveHeight() : _chart.height();
      var margins = typeof _chart.margins === "function" ? _chart.margins() : { left: 0, right: 0, top: 0, bottom: 0 };

      var xscale = _chart.x();
      var yscale = _chart.y();

      var origXRange = xscale.range();
      var origYRange = yscale.range();

      xscale.range([0, width]);
      yscale.range([0, height]);

      var xPixel = xscale(data.xPoint) + margins.left;
      var yPixel = height - yscale(data.yPoint) + margins.top;

      // restore the original ranges so we don't screw anything else up
      xscale.range(origXRange);
      yscale.range(origYRange);

      var mapPopup = _chart.root().append("div").attr("class", "map-popup");
      mapPopup.on("wheel", function () {
        _chart.select(".map-popup").remove();
      });
      mapPopup.append("div").attr("class", "map-point-wrap").append("div").attr("class", "map-point").style({ left: xPixel + "px", top: yPixel + "px" }).append("div").attr("class", "map-point-gfx").style("background", colorPopupBackground(result.row_set[0]));
      mapPopup.append("div").attr("class", "map-popup-wrap").style({ left: xPixel + "px", top: yPixel + "px" }).append("div").attr("class", "map-popup-box").html(_chart.popupFunction() ? _popupFunction(mappedData) : renderPopupHTML(mappedData)).style("left", function () {
        var boxWidth = _d2.default.select(this).node().getBoundingClientRect().width;
        var overflow = _chart.width() - (xPixel + boxWidth / 2) < 0 ? _chart.width() - (xPixel + boxWidth / 2) - 6 : xPixel - boxWidth / 2 < 0 ? -(xPixel - boxWidth / 2) + 6 : 0;
        offsetBridge = boxWidth / 2 - overflow;
        return overflow + "px";
      }).classed("pop-down", function () {
        var boxHeight = _d2.default.select(this).node().getBoundingClientRect().height;
        return yPixel - (boxHeight + 12) < 8;
      }).append("div").attr("class", "map-popup-bridge").style("left", function () {
        return offsetBridge + "px";
      });
    }
  };

  _chart.hidePopup = function hidePopup() {
    if (!_chart.select(".map-popup").empty()) {
      _chart.select(".map-popup-wrap").classed("removePopup", true).on("animationend", function () {
        _chart.select(".map-popup").remove();
      });
      _chart.select(".map-point").classed("removePoint", true);
    }
  };

  _chart._vegaSpec = {};

  return _chart;

  function getColumnsWithPoints() {
    var columns = _chart.popupColumns().slice();

    if (typeof _chart.useLonLat === "function" && _chart.useLonLat()) {
      columns.push("conv_4326_900913_x(" + _chart._xDimName + ") as xPoint");
      columns.push("conv_4326_900913_y(" + _chart._yDimName + ") as yPoint");
    } else {
      columns.push(_chart._xDimName + " as xPoint");
      columns.push(_chart._yDimName + " as yPoint");
    }

    if (_chart.colorBy() && columns.indexOf(_chart.colorBy().value) === -1) {
      columns.push(_chart.colorBy().value);
    }

    return columns;
  }

  function renderPopupHTML(data) {
    var html = "";
    for (var key in data) {
      if (key !== "xPoint" && key !== "yPoint" && !(_chart.colorBy() && key === _chart.colorBy().value && hideColorColumnInPopup())) {
        html = html + ('<div class="map-popup-item"><span class="popup-item-key">' + key + ':</span><span class="popup-item-val"> ' + _utils.utils.formatValue(data[key]) + "</span></div>");
      }
    }
    return html;
  }

  function colorPopupBackground(data) {
    if (!_chart.colors().domain || !_chart.colorBy()) {
      return _chart.defaultColor();
    } else if (isNaN(_chart.colors().domain()[0])) {
      var matchIndex = _chart.colors().domain().indexOf(data[_chart.colorBy().value]);
      return matchIndex !== -1 ? _chart.colors().range()[matchIndex] : _chart.defaultColor();
    } else {
      return _chart.colors()(data[_chart.colorBy().value]);
    }
  }

  function mapDataViaColumns(data, _popupColumnsMapped) {
    var newData = {};
    for (var key in data) {
      var newKey = _popupColumnsMapped[key] || key;
      newData[newKey] = data[key];
    }
    return newData;
  }

  function hideColorColumnInPopup() {
    return _chart.colorBy() && _chart.popupColumns().indexOf(_chart.colorBy().value) === -1;
  }
}

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = legendContinuous;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function legendContinuous() {
  var LABEL_GAP = 2;
  var _legend = {},
      _parent = void 0,
      _x = 0,
      _y = 0,
      _itemHeight = 12,
      _gap = 5,
      _horizontal = false,
      _legendWidth = 560,
      _itemWidth = 70,
      _autoItemWidth = false;

  var _g = void 0;

  /* OVERRIDE -----------------------------------------------------------------*/
  var _wrapper = void 0;
  var _lock = void 0;
  var _lockable = true;
  var _isLocked = false;
  /* --------------------------------------------------------------------------*/

  _legend.parent = function (p) {
    if (!arguments.length) {
      return _parent;
    }
    _parent = p;
    return _legend;
  };

  _legend.render = function () {
    /* OVERRIDE -----------------------------------------------------------------*/
    _parent.root().select(".legend-cont").remove();

    _wrapper = _parent.root().append("div").attr("class", "legend-cont").style("display", _parent.colorByExpr() === null ? "none" : "block");

    var title = _wrapper.append("div").attr("class", "legend-title").append("span").text(_parent.colorByExpr());

    var legendGroup = _wrapper.append("div").attr("class", "legend-group");

    if (_lockable) {
      generateLock();
    }

    var legendables = _parent.legendablesContinuous();

    var itemEnter = legendGroup.selectAll(".legend-item").data(legendables).enter().append("div").attr("class", "legend-item");

    itemEnter.append("div").attr("class", "legend-swatch").style("background-color", function (d) {
      return d ? d.color : "#e2e2e2";
    });

    itemEnter.append("div").attr("class", "legend-label").append("span").text(function (d) {
      return d ? d.value : 0;
    });

    legendGroup.selectAll(".legend-item:first-child , .legend-item:last-child").on("mouseenter", function () {
      var item = _d2.default.select(this);
      var w = item.select("span").node().getBoundingClientRect().width + 8;
      item.select(".legend-input input").style("width", w + "px");
    }).selectAll(".legend-label").append("div").attr("class", "legend-input").append("input").attr("value", function (d) {
      return d ? d.value : 0;
    }).on("focus", function () {
      this.select();

      var item = _d2.default.select(this.parentNode.parentNode);
      item.classed("active", true);

      var w = item.select("span").node().getBoundingClientRect().width + 8;
      item.select(".legend-input input").style("width", w + "px");
    }).on("blur", function () {
      _d2.default.select(this.parentNode.parentNode).classed("active", false);
    }).on("change", onChange);
  };

  function legendItemHeight() {
    return _gap + _itemHeight;
  }

  _legend.x = function (x) {
    if (!arguments.length) {
      return _x;
    }
    _x = x;
    return _legend;
  };

  _legend.y = function (y) {
    if (!arguments.length) {
      return _y;
    }
    _y = y;
    return _legend;
  };

  _legend.gap = function (gap) {
    if (!arguments.length) {
      return _gap;
    }
    _gap = gap;
    return _legend;
  };

  _legend.itemHeight = function (itemHeight) {
    if (!arguments.length) {
      return _itemHeight;
    }
    _itemHeight = itemHeight;
    return _legend;
  };

  _legend.horizontal = function (horizontal) {
    if (!arguments.length) {
      return _horizontal;
    }
    _horizontal = horizontal;
    return _legend;
  };

  _legend.legendWidth = function (legendWidth) {
    if (!arguments.length) {
      return _legendWidth;
    }
    _legendWidth = legendWidth;
    return _legend;
  };

  _legend.itemWidth = function (itemWidth) {
    if (!arguments.length) {
      return _itemWidth;
    }
    _itemWidth = itemWidth;
    return _legend;
  };

  _legend.autoItemWidth = function (autoItemWidth) {
    if (!arguments.length) {
      return _autoItemWidth;
    }
    _autoItemWidth = autoItemWidth;
    return _legend;
  };
  /* OVERRIDE -----------------------------------------------------------------*/
  function generateLock() {
    _lock = _wrapper.append("div").attr("class", "legend-lock").classed("js-isLocked", _isLocked).on("click", toggleLock);

    _lock.append("svg").attr("class", "svg-icon").classed("icon-lock", true).attr("viewBox", "0 0 48 48").append("use").attr("xlink:href", "#icon-lock");
    _lock.append("svg").attr("class", "svg-icon").classed("icon-unlock", true).attr("viewBox", "0 0 48 48").append("use").attr("xlink:href", "#icon-unlock");
    return _lock;
  }

  function toggleLock() {
    _isLocked = !_isLocked;
    _lock.classed("js-isLocked", _isLocked);

    if (_isLocked) {
      _parent.legendLock()();
    } else {
      _parent.legendUnlock()(true);
    }
  }

  function onChange() {
    var startVal = _wrapper.select(".legend-item:first-child .legend-input input")[0][0].value;
    var endVal = _wrapper.select(".legend-item:last-child .legend-input input")[0][0].value;

    _parent.legendInputChange()([startVal, endVal], _parent.colors().range().length);

    _isLocked = true;
    _lock.classed("js-isLocked", _isLocked);
  }

  /* --------------------------------------------------------------------------*/

  return _legend;
}

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = legend;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _utils = __webpack_require__(3);

var _dcLegendMixin = __webpack_require__(240);

var _dcLegendMixin2 = _interopRequireDefault(_dcLegendMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Legend is a attachable widget that can be added to other dc charts to render horizontal legend
 * labels.
 *
 * @name legend
 * @memberof dc
 * @example
 * chart.legend(dc.legend().x(400).y(10).itemHeight(13).gap(5))
 * @return {dc.legend}
 */
function legend() {
  var LABEL_GAP = 2;

  var _legend = {},
      _parent = void 0,
      _x = 0,
      _y = 0,
      _itemHeight = 12,
      _gap = 5,
      _horizontal = false,
      _legendWidth = 560,
      _itemWidth = 70,
      _autoItemWidth = false;

  var _g = void 0;

  _legend.parent = function (p) {
    if (!arguments.length) {
      return _parent;
    }
    _parent = p;
    return _legend;
  };

  _legend.render = function () {
    _parent.svg().select("g.dc-legend").remove();
    _g = _parent.svg().append("g").attr("class", "dc-legend").attr("transform", "translate(" + _x + "," + _y + ")");
    var legendables = _parent.legendables();

    var itemEnter = _g.selectAll("g.dc-legend-item").data(legendables).enter().append("g").attr("class", "dc-legend-item").on("mouseover", function (d) {
      _parent.legendHighlight(d);
    }).on("mouseout", function (d) {
      _parent.legendReset(d);
    }).on("click", function (d) {
      d.chart.legendToggle(d);
    });

    _g.selectAll("g.dc-legend-item").classed("fadeout", function (d) {
      return d.chart.isLegendableHidden(d);
    });

    if (legendables.some((0, _utils.pluck)("dashstyle"))) {
      itemEnter.append("line").attr("x1", 0).attr("y1", _itemHeight / 2).attr("x2", _itemHeight).attr("y2", _itemHeight / 2).attr("stroke-width", 2).attr("stroke-dasharray", (0, _utils.pluck)("dashstyle")).attr("stroke", (0, _utils.pluck)("color"));
    } else {
      itemEnter.append("rect").attr("width", _itemHeight).attr("height", _itemHeight).attr("fill", function (d) {
        return d ? d.color : "blue";
      });
    }

    itemEnter.append("text").text((0, _utils.pluck)("name")).attr("x", _itemHeight + LABEL_GAP).attr("y", function () {
      return _itemHeight / 2 + (this.clientHeight ? this.clientHeight : 13) / 2 - 2;
    });

    var _cumulativeLegendTextWidth = 0;
    var row = 0;
    itemEnter.attr("transform", function (d, i) {
      if (_horizontal) {
        var translateBy = "translate(" + _cumulativeLegendTextWidth + "," + row * legendItemHeight() + ")";
        var itemWidth = _autoItemWidth === true ? this.getBBox().width + _gap : _itemWidth;

        if (_cumulativeLegendTextWidth + itemWidth >= _legendWidth) {
          ++row;
          _cumulativeLegendTextWidth = 0;
        } else {
          _cumulativeLegendTextWidth = _cumulativeLegendTextWidth + itemWidth;
        }
        return translateBy;
      } else {
        return "translate(0," + i * legendItemHeight() + ")";
      }
    });
  };

  function legendItemHeight() {
    return _gap + _itemHeight;
  }

  /**
   * Set or get x coordinate for legend widget.
   * @name x
   * @memberof dc.legend
   * @instance
   * @param  {Number} [x=0]
   * @return {Number}
   * @return {dc.legend}
   */
  _legend.x = function (x) {
    if (!arguments.length) {
      return _x;
    }
    _x = x;
    return _legend;
  };

  /**
   * Set or get y coordinate for legend widget.
   * @name y
   * @memberof dc.legend
   * @instance
   * @param  {Number} [y=0]
   * @return {Number}
   * @return {dc.legend}
   */
  _legend.y = function (y) {
    if (!arguments.length) {
      return _y;
    }
    _y = y;
    return _legend;
  };

  /**
   * Set or get gap between legend items.
   * @name gap
   * @memberof dc.legend
   * @instance
   * @param  {Number} [gap=5]
   * @return {Number}
   * @return {dc.legend}
   */
  _legend.gap = function (gap) {
    if (!arguments.length) {
      return _gap;
    }
    _gap = gap;
    return _legend;
  };

  /**
   * Set or get legend item height.
   * @name itemHeight
   * @memberof dc.legend
   * @instance
   * @param  {Number} [itemHeight=12]
   * @return {Number}
   * @return {dc.legend}
   */
  _legend.itemHeight = function (itemHeight) {
    if (!arguments.length) {
      return _itemHeight;
    }
    _itemHeight = itemHeight;
    return _legend;
  };

  /**
   * Position legend horizontally instead of vertically.
   * @name horizontal
   * @memberof dc.legend
   * @instance
   * @param  {Boolean} [horizontal=false]
   * @return {Boolean}
   * @return {dc.legend}
   */
  _legend.horizontal = function (horizontal) {
    if (!arguments.length) {
      return _horizontal;
    }
    _horizontal = horizontal;
    return _legend;
  };

  /**
   * Maximum width for horizontal legend.
   * @name legendWidth
   * @memberof dc.legend
   * @instance
   * @param  {Number} [legendWidth=500]
   * @return {Number}
   * @return {dc.legend}
   */
  _legend.legendWidth = function (legendWidth) {
    if (!arguments.length) {
      return _legendWidth;
    }
    _legendWidth = legendWidth;
    return _legend;
  };

  /**
   * legendItem width for horizontal legend.
   * @name itemWidth
   * @memberof dc.legend
   * @instance
   * @param  {Number} [itemWidth=70]
   * @return {Number}
   * @return {dc.legend}
   */
  _legend.itemWidth = function (itemWidth) {
    if (!arguments.length) {
      return _itemWidth;
    }
    _itemWidth = itemWidth;
    return _legend;
  };

  /**
   * Turn automatic width for legend items on or off. If true, {@link #dc.legend+itemWidth itemWidth} is ignored.
   * This setting takes into account {@link #dc.legend+gap gap}.
   * @name autoItemWidth
   * @memberof dc.legend
   * @instance
   * @param  {Boolean} [autoItemWidth=false]
   * @return {Boolean}
   * @return {dc.legend}
   */
  _legend.autoItemWidth = function (autoItemWidth) {
    if (!arguments.length) {
      return _autoItemWidth;
    }
    _autoItemWidth = autoItemWidth;
    return _legend;
  };

  /**
    #### .legendText([legendTextFunction])
    Set or get the legend text function. The legend widget uses this function to render
    the legend text on each item. If no function is specified the legend widget will display
    the names associated with each group.
     Default: pluck('name')
     ```js
    // create numbered legend items
    chart.legend(dc.legend().legendText(function(d, i) { return i + '. ' + d.name; }))
     // create legend displaying group counts
    chart.legend(dc.legend().legendText(function(d) { return d.name + ': ' d.data; }))
    ```
    **/
  _legend.legendText = function (_) {
    if (!arguments.length) {
      return _legendText;
    }
    _legendText = _;
    return _legend;
  };

  _legend = (0, _dcLegendMixin2.default)(_legend);

  return _legend;
}

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = legendMixin;
function legendMixin(legend) {
  legend._scrollPos = 0;
  legend._expanded = true;
  legend._heightRatio = 3;
  legend._title = "Legend";
  legend._key = "key0";

  legend.legendType = function () {
    return "custom";
  };

  legend.render = function () {
    // Does not re-render if a custom cursor is on the screen
    if (document.getElementById("cursor") !== null) {
      return;
    }

    legend.parent().root().select(".dc-legend").remove();

    var wrapper = legend.parent().root().append("div").attr("class", "dc-legend").classed("collapsed", !legend._expanded);

    var header = wrapper.append("div").attr("class", "dc-legend-header").text(legend._expanded ? legend._title : "Legend").on("click", function () {
      legend._expanded = !legend._expanded;
      legend.render();
    });

    if (legend._expanded) {
      header.append("div").attr("class", "toggle-btn");

      var body = wrapper.append("div").attr("class", "dc-legend-body").style("max-height", legend.parent().height() / legend._heightRatio + "px").on("scroll", function () {
        legend._scrollPos = body.node().scrollTop;
      });

      var legendables = legend.legendables();

      var itemEnter = body.selectAll(".dc-legend-item").data(legendables).enter().append("div").attr("class", "dc-legend-item");

      itemEnter.append("div").attr("class", "legend-item-color").style("background", function (d) {
        return d ? d.color : "#a7a7a7";
      });

      itemEnter.append("div").attr("class", "legend-item-text").text(function (d) {
        return d.name;
      });

      var bodyNode = body.node();
      if (bodyNode) {
        // fix for #4196#issuecomment-376704328
        bodyNode.scrollTop = legend._scrollPos;
      }
    }
  };

  legend.removeLegend = function () {
    legend.parent().root().select(".dc-legend").remove();
    legend.parent().legend(null);
  };

  legend.legendables = function () {
    var colors = legend.parent().colors();
    return zip2(colors.domain(), colors.range()).map(function (data) {
      return {
        name: data[0],
        color: data[1],
        chart: legend.parent()
      };
    });
  };

  legend.setTitle = function (title) {
    legend._title = title;
    return legend;
  };

  legend.setKey = function (key) {
    legend._key = key;
    return legend;
  };

  function zip2(list1, list2) {
    return (list1.length < list2.length ? list1 : list2).map(function (_, i) {
      return [list1[i], list2[i]];
    });
  }

  return legend;
}

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = legendCont;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OFFSET_WIDTH = 8;

function unLockedPreRedrawRenderHandler(chart) {
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : chart.data();

  if (!data.image) {
    chart.colorDomain(_d2.default.extent(data, chart.colorAccessor()));
  }
}

function legendCont() {
  var _legend = {};
  var _parent = null;
  var _legendTitle = "";
  var _chartType = "";
  var _wrapper = null;
  var _lock = null;
  var _minMax = null;
  var _isLocked = false;

  _legend.legendType = function () {
    return "quantitative";
  };

  _legend.isLocked = function (_) {
    if (!arguments.length) {
      return _isLocked;
    }
    _isLocked = _;
    return _legend;
  };

  _legend.parent = function (p) {
    if (!arguments.length) {
      return _parent;
    }
    _parent = p;
    return _legend;
  };

  _legend.minMax = function (_) {
    if (!arguments.length) {
      return _minMax;
    }
    _minMax = _;
    return _legend;
  };

  _legend.legendTitle = function (_) {
    if (!arguments.length) {
      return _legendTitle;
    }
    _legendTitle = _;
    return _legend;
  };

  _legend.chartType = function (_) {
    if (!arguments.length) {
      return _chartType;
    }
    _chartType = _;
    return _legend;
  };

  _legend.removeLegend = function () {
    _parent.root().select(".legend-cont").remove();
    _parent._invokeClearCustomContLegendListener();
    _parent.legend(null);
  };

  _legend.render = function () {
    _parent.root().select(".legend-cont").remove();

    _wrapper = _parent.root().append("div").attr("class", "legend-cont");

    var legendGroup = _wrapper.append("div").attr("class", "legend-group");

    initLock();

    var legendables = _parent.legendablesContinuous();

    var itemEnter = legendGroup.selectAll(".legend-item").data(legendables).enter().append("div").attr("class", "legend-item");

    itemEnter.append("div").attr("class", "legend-swatch").style("background-color", function (d) {
      return d ? d.color : "#e2e2e2";
    }); // eslint-disable-line no-confusing-arrow

    itemEnter.append("div").attr("class", "legend-label").append("span").text(function (d) {
      return (typeof d === "undefined" ? "undefined" : _typeof(d)) === "object" && d.value !== "NaN" ? d.value : 0;
    }); // eslint-disable-line no-confusing-arrow

    legendGroup.selectAll(".legend-item:first-child , .legend-item:last-child").on("mouseenter", function () {
      var item = _d2.default.select(this);
      var w = item.select("span").node().getBoundingClientRect().width + OFFSET_WIDTH;
      item.select(".legend-input input").style("width", w + "px");
    }).selectAll(".legend-label").append("div").attr("class", "legend-input").append("input").attr("value", function (d) {
      return (typeof d === "undefined" ? "undefined" : _typeof(d)) === "object" && d.value !== "NaN" ? d.value : 0;
    }) // eslint-disable-line no-confusing-arrow
    .on("click", function () {
      this.select();
      var item = _d2.default.select(this.parentNode.parentNode);
      item.classed("active", true);

      var w = item.select("span").node().getBoundingClientRect().width + OFFSET_WIDTH;
      item.select(".legend-input input").style("width", w + "px");
    }).on("blur", function () {
      _d2.default.select(this.parentNode.parentNode).classed("active", false);
    }).on("change", onChange);
  };

  function initLock() {
    _lock = _wrapper.append("div").attr("class", "legend-lock").classed("js-isLocked", _isLocked).on("click", toggleLock);

    var lockIcon = _lock.append("svg").attr("class", "svg-icon").classed("icon-lock", true).attr("viewBox", "0 0 48 48");

    lockIcon.append("g").style("stroke", "white").style("stroke-width", "6").append("use").attr("xlink:href", "#icon-lock");

    lockIcon.append("use").attr("xlink:href", "#icon-lock");

    var unLockIcon = _lock.append("svg").attr("class", "svg-icon").classed("icon-unlock", true).attr("viewBox", "0 0 48 48");

    unLockIcon.append("g").style("stroke", "white").style("stroke-width", "6").append("use").attr("xlink:href", "#icon-unlock");

    unLockIcon.append("use").attr("xlink:href", "#icon-unlock");

    if (_isLocked) {
      _parent.on("preRender.color", null);
      _parent.on("preRedraw.color", null);
    } else {
      _parent.on("preRender.color", unLockedPreRedrawRenderHandler);
      _parent.on("preRedraw.color", unLockedPreRedrawRenderHandler);
    }
  }

  function toggleLock() {
    _isLocked = !_isLocked;

    if (_isLocked) {
      _parent._invokeSetCustomContLegendListener({
        detail: _parent.colors().domain()
      });
    } else {
      var minMax = _chartType === "pointmap" || _chartType === "backendScatter" ? _minMax : _d2.default.extent(_parent.data(), _parent.colorAccessor());
      if (minMax) {
        _parent.colorDomain(minMax);
      }
      _parent._invokeClearCustomContLegendListener();
    }
    _parent.redrawAsync();
  }

  function onChange() {
    var parseVal = function parseVal(val) {
      return parseFloat(val.replace(/,/g, ""));
    };
    var currVal = _d2.default.select(this).attr("value");
    var inputBox1 = parseVal(_wrapper.select(".legend-item:first-child .legend-input input").node().value);
    var inputBox2 = parseVal(_wrapper.select(".legend-item:last-child .legend-input input").node().value);

    var startVal = isFinite(inputBox1) ? inputBox1 : _parent.colorDomain()[0];
    var endVal = isFinite(inputBox2) ? inputBox2 : _parent.colorDomain()[1];

    if (!isNaN(startVal) && !isNaN(endVal)) {
      _isLocked = true;
      _parent.colorDomain([startVal, endVal]).on("preRedraw.color", null).redrawAsync();
      _parent._invokeSetCustomContLegendListener({
        detail: [startVal, endVal]
      });
    } else {
      _d2.default.select(this).property("value", currVal);
    }
  }

  return _legend;
}

/***/ })
/******/ ]);
});