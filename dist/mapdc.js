(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("d3"));
	else if(typeof define === 'function' && define.amd)
		define(["d3"], factory);
	else if(typeof exports === 'object')
		exports["mapdc"] = factory(require("d3"));
	else
		root["mapdc"] = factory(root["d3"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 222);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var require;//! moment.js

;(function (global, factory) {
     true ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

    var hookCallback;

    function hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return (Object.getOwnPropertyNames(obj).length === 0);
        } else {
            var k;
            for (k in obj) {
                if (obj.hasOwnProperty(k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null,
            rfc2822         : false,
            weekdayMismatch : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.weekdayMismatch &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid = isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            }
            else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid (flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (var key in arguments[0]) {
                            arg += key + ': ' + arguments[0][key] + ', ';
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        ss : '%d seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1 (mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            }
            else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        if (!m) {
            return isArray(this._months) ? this._months :
                this._months['standalone'];
        }
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort :
                this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate (y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
    }

    function createUTCDate (y) {
        var date;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            var args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 6th is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES
    function shiftWeekdays (ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        var weekdays = isArray(this._weekdays) ? this._weekdays :
            this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? 'format' : 'standalone'];
        return (m === true) ? shiftWeekdays(weekdays, this._week.dow)
            : (m) ? weekdays[m.day()] : weekdays;
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('k',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                var aliasedRequire = require;
                __webpack_require__(244)("./" + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
            else {
                if ((typeof console !==  'undefined') && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            var locale, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);


            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, tmpLocale, parentConfig = baseConfig;
            // MERGE
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            var curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to beginning of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    var obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10);
            var m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i));
        if (match) {
            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        // Final attempt, use Input Fallback
        hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
        'discouraged and will be removed in an upcoming major release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
        for (var key in m) {
            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                return false;
            }
        }

        var unitHasDecimal = false;
        for (var i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher);

        if (matches === null) {
            return null;
        }

        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ?
          0 :
          parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            }
            else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (isNumber(input)) {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])                         * sign,
                h  : toInt(match[HOUR])                         * sign,
                m  : toInt(match[MINUTE])                       * sign,
                s  : toInt(match[SECOND])                       * sign,
                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add      = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1 (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year': output = monthDiff(this, that) / 12; break;
            case 'month': output = monthDiff(this, that); break;
            case 'quarter': output = monthDiff(this, that) / 3; break;
            case 'second': output = (this - that) / 1e3; break; // 1000
            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default: output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true;
        var m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect () {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment';
        var zone = '';
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        var prefix = '[' + func + '("]';
        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
        var datetime = '-MM-DD[T]HH:mm:ss.SSS';
        var suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    var MS_PER_SECOND = 1000;
    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

    // actual modulo - handles negative numbers (for dates before 1970):
    function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }

    function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }

    function startOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function endOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return new Date(this.valueOf());
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2 () {
        return isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIORITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict ?
          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
          locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add               = add;
    proto.calendar          = calendar$1;
    proto.clone             = clone;
    proto.diff              = diff;
    proto.endOf             = endOf;
    proto.format            = format;
    proto.from              = from;
    proto.fromNow           = fromNow;
    proto.to                = to;
    proto.toNow             = toNow;
    proto.get               = stringGet;
    proto.invalidAt         = invalidAt;
    proto.isAfter           = isAfter;
    proto.isBefore          = isBefore;
    proto.isBetween         = isBetween;
    proto.isSame            = isSame;
    proto.isSameOrAfter     = isSameOrAfter;
    proto.isSameOrBefore    = isSameOrBefore;
    proto.isValid           = isValid$2;
    proto.lang              = lang;
    proto.locale            = locale;
    proto.localeData        = localeData;
    proto.max               = prototypeMax;
    proto.min               = prototypeMin;
    proto.parsingFlags      = parsingFlags;
    proto.set               = stringSet;
    proto.startOf           = startOf;
    proto.subtract          = subtract;
    proto.toArray           = toArray;
    proto.toObject          = toObject;
    proto.toDate            = toDate;
    proto.toISOString       = toISOString;
    proto.inspect           = inspect;
    proto.toJSON            = toJSON;
    proto.toString          = toString;
    proto.unix              = unix;
    proto.valueOf           = valueOf;
    proto.creationData      = creationData;
    proto.year       = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear    = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month       = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week           = proto.weeks        = getSetWeek;
    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
    proto.weeksInYear    = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date       = getSetDayOfMonth;
    proto.day        = proto.days             = getSetDayOfWeek;
    proto.weekday    = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear  = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset            = getSetOffset;
    proto.utc                  = setOffsetToUTC;
    proto.local                = setOffsetToLocal;
    proto.parseZone            = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST                = isDaylightSavingTime;
    proto.isLocal              = isLocal;
    proto.isUtcOffset          = isUtcOffset;
    proto.isUtc                = isUtc;
    proto.isUTC                = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix (input) {
        return createLocal(input * 1000);
    }

    function createInZone () {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat (string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar        = calendar;
    proto$1.longDateFormat  = longDateFormat;
    proto$1.invalidDate     = invalidDate;
    proto$1.ordinal         = ordinal;
    proto$1.preparse        = preParsePostFormat;
    proto$1.postformat      = preParsePostFormat;
    proto$1.relativeTime    = relativeTime;
    proto$1.pastFuture      = pastFuture;
    proto$1.set             = set;

    proto$1.months            =        localeMonths;
    proto$1.monthsShort       =        localeMonthsShort;
    proto$1.monthsParse       =        localeMonthsParse;
    proto$1.monthsRegex       = monthsRegex;
    proto$1.monthsShortRegex  = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays       =        localeWeekdays;
    proto$1.weekdaysMin    =        localeWeekdaysMin;
    proto$1.weekdaysShort  =        localeWeekdaysShort;
    proto$1.weekdaysParse  =        localeWeekdaysParse;

    proto$1.weekdaysRegex       =        weekdaysRegex;
    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1 (format, index, field, setter) {
        var locale = getLocale();
        var utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

    var mathAbs = Math.abs;

    function abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function addSubtract$1 (duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1 (input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1 (input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month':   return months;
                case 'quarter': return months / 3;
                case 'year':    return months / 12;
            }
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1 () {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asQuarters     = makeAs('Q');
    var asYears        = makeAs('y');

    function clone$1 () {
        return createDuration(this);
    }

    function get$2 (units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        ss: 44,         // a few seconds to seconds
        s : 45,         // seconds to minute
        m : 45,         // minutes to hour
        h : 22,         // hours to day
        d : 26,         // days to month
        M : 11          // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds <= thresholds.ss && ['s', seconds]  ||
                seconds < thresholds.s   && ['ss', seconds] ||
                minutes <= 1             && ['m']           ||
                minutes < thresholds.m   && ['mm', minutes] ||
                hours   <= 1             && ['h']           ||
                hours   < thresholds.h   && ['hh', hours]   ||
                days    <= 1             && ['d']           ||
                days    < thresholds.d   && ['dd', days]    ||
                months  <= 1             && ['M']           ||
                months  < thresholds.M   && ['MM', months]  ||
                years   <= 1             && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize (withSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var locale = this.localeData();
        var output = relativeTime$1(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return ((x > 0) - (x < 0)) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000;
        var days         = abs$1(this._days);
        var months       = abs$1(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        var totalSign = total < 0 ? '-' : '';
        var ymSign = sign(this._months) !== sign(total) ? '-' : '';
        var daysSign = sign(this._days) !== sign(total) ? '-' : '';
        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return totalSign + 'P' +
            (Y ? ymSign + Y + 'Y' : '') +
            (M ? ymSign + M + 'M' : '') +
            (D ? daysSign + D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? hmsSign + h + 'H' : '') +
            (m ? hmsSign + m + 'M' : '') +
            (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid        = isValid$1;
    proto$2.abs            = abs;
    proto$2.add            = add$1;
    proto$2.subtract       = subtract$1;
    proto$2.as             = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds      = asSeconds;
    proto$2.asMinutes      = asMinutes;
    proto$2.asHours        = asHours;
    proto$2.asDays         = asDays;
    proto$2.asWeeks        = asWeeks;
    proto$2.asMonths       = asMonths;
    proto$2.asQuarters     = asQuarters;
    proto$2.asYears        = asYears;
    proto$2.valueOf        = valueOf$1;
    proto$2._bubble        = bubble;
    proto$2.clone          = clone$1;
    proto$2.get            = get$2;
    proto$2.milliseconds   = milliseconds;
    proto$2.seconds        = seconds;
    proto$2.minutes        = minutes;
    proto$2.hours          = hours;
    proto$2.days           = days;
    proto$2.weeks          = weeks;
    proto$2.months         = months;
    proto$2.years          = years;
    proto$2.humanize       = humanize;
    proto$2.toISOString    = toISOString$1;
    proto$2.toString       = toISOString$1;
    proto$2.toJSON         = toISOString$1;
    proto$2.locale         = locale;
    proto$2.localeData     = localeData;

    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    hooks.version = '2.24.0';

    setHookCallback(createLocal);

    hooks.fn                    = proto;
    hooks.min                   = min;
    hooks.max                   = max;
    hooks.now                   = now;
    hooks.utc                   = createUTC;
    hooks.unix                  = createUnix;
    hooks.months                = listMonths;
    hooks.isDate                = isDate;
    hooks.locale                = getSetGlobalLocale;
    hooks.invalid               = createInvalid;
    hooks.duration              = createDuration;
    hooks.isMoment              = isMoment;
    hooks.weekdays              = listWeekdays;
    hooks.parseZone             = createInZone;
    hooks.localeData            = getLocale;
    hooks.isDuration            = isDuration;
    hooks.monthsShort           = listMonthsShort;
    hooks.weekdaysMin           = listWeekdaysMin;
    hooks.defineLocale          = defineLocale;
    hooks.updateLocale          = updateLocale;
    hooks.locales               = listLocales;
    hooks.weekdaysShort         = listWeekdaysShort;
    hooks.normalizeUnits        = normalizeUnits;
    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat        = getCalendarFormat;
    hooks.prototype             = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD',                             // <input type="date" />
        TIME: 'HH:mm',                                  // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW',                             // <input type="week" />
        MONTH: 'YYYY-MM'                                // <input type="month" />
    };

    return hooks;

})));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(53)(module)))

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["A"] = isEmpty;
/* harmony export (immutable) */ __webpack_exports__["G"] = keys;
/* harmony export (immutable) */ __webpack_exports__["U"] = values;
/* harmony export (immutable) */ __webpack_exports__["J"] = mapValues;
/* harmony export (immutable) */ __webpack_exports__["I"] = map;
/* harmony export (immutable) */ __webpack_exports__["t"] = flatten;
/* harmony export (immutable) */ __webpack_exports__["s"] = first;
/* harmony export (immutable) */ __webpack_exports__["H"] = last;
/* harmony export (immutable) */ __webpack_exports__["u"] = forEach;
/* harmony export (immutable) */ __webpack_exports__["E"] = isString;
/* harmony export (immutable) */ __webpack_exports__["F"] = isUndefined;
/* harmony export (immutable) */ __webpack_exports__["B"] = isFunction;
/* harmony export (immutable) */ __webpack_exports__["m"] = drop;
/* harmony export (immutable) */ __webpack_exports__["n"] = dropRight;
/* harmony export (immutable) */ __webpack_exports__["p"] = filter;
/* harmony export (immutable) */ __webpack_exports__["P"] = reject;
/* harmony export (immutable) */ __webpack_exports__["N"] = pick;
/* harmony export (immutable) */ __webpack_exports__["w"] = has;
/* harmony export (immutable) */ __webpack_exports__["j"] = contains;
/* harmony export (immutable) */ __webpack_exports__["g"] = cloneArr;
/* harmony export (immutable) */ __webpack_exports__["h"] = cloneObj;
/* harmony export (immutable) */ __webpack_exports__["q"] = find;
/* harmony export (immutable) */ __webpack_exports__["r"] = findAll;
/* harmony export (immutable) */ __webpack_exports__["O"] = reduce;
/* harmony export (immutable) */ __webpack_exports__["i"] = compact;
/* harmony export (immutable) */ __webpack_exports__["T"] = uniq;
/* unused harmony export partial */
/* harmony export (immutable) */ __webpack_exports__["y"] = isArray;
/* harmony export (immutable) */ __webpack_exports__["D"] = isRegExp;
/* harmony export (immutable) */ __webpack_exports__["C"] = isObject;
/* harmony export (immutable) */ __webpack_exports__["o"] = every;
/* harmony export (immutable) */ __webpack_exports__["l"] = difference;
/* harmony export (immutable) */ __webpack_exports__["Q"] = some;
/* harmony export (immutable) */ __webpack_exports__["x"] = indexOf;
/* unused harmony export sortBy */
/* unused harmony export zipObject */
/* harmony export (immutable) */ __webpack_exports__["f"] = assign;
/* unused harmony export assignNoOverwrite */
/* harmony export (immutable) */ __webpack_exports__["k"] = defaults;
/* harmony export (immutable) */ __webpack_exports__["v"] = groupBy;
/* harmony export (immutable) */ __webpack_exports__["K"] = merge;
/* harmony export (immutable) */ __webpack_exports__["b"] = NOOP;
/* harmony export (immutable) */ __webpack_exports__["a"] = IDENTITY;
/* harmony export (immutable) */ __webpack_exports__["L"] = packArray;
/* harmony export (immutable) */ __webpack_exports__["c"] = PRINT_ERROR;
/* harmony export (immutable) */ __webpack_exports__["d"] = PRINT_WARNING;
/* harmony export (immutable) */ __webpack_exports__["z"] = isES2015MapSupported;
/* harmony export (immutable) */ __webpack_exports__["e"] = applyMixins;
/* harmony export (immutable) */ __webpack_exports__["S"] = toFastProperties;
/* harmony export (immutable) */ __webpack_exports__["M"] = peek;
/* harmony export (immutable) */ __webpack_exports__["R"] = timer;
/*
 Utils using lodash style API. (not necessarily 100% compliant) for functional and other utils.
 These utils should replace usage of lodash in the production code base. not because they are any better...
 but for the purpose of being a dependency free library.

 The hotspots in the code are already written in imperative style for performance reasons.
 so writing several dozen utils which may be slower than the original lodash, does not matter as much
 considering they will not be invoked in hotspots...
 */
function isEmpty(arr) {
    return arr && arr.length === 0;
}
function keys(obj) {
    if (obj === undefined || obj === null) {
        return [];
    }
    return Object.keys(obj);
}
function values(obj) {
    var vals = [];
    var keys = Object.keys(obj);
    for (var i = 0; i < keys.length; i++) {
        vals.push(obj[keys[i]]);
    }
    return vals;
}
function mapValues(obj, callback) {
    var result = [];
    var objKeys = keys(obj);
    for (var idx = 0; idx < objKeys.length; idx++) {
        var currKey = objKeys[idx];
        result.push(callback.call(null, obj[currKey], currKey));
    }
    return result;
}
function map(arr, callback) {
    var result = [];
    for (var idx = 0; idx < arr.length; idx++) {
        result.push(callback.call(null, arr[idx], idx));
    }
    return result;
}
function flatten(arr) {
    var result = [];
    for (var idx = 0; idx < arr.length; idx++) {
        var currItem = arr[idx];
        if (Array.isArray(currItem)) {
            result = result.concat(flatten(currItem));
        }
        else {
            result.push(currItem);
        }
    }
    return result;
}
function first(arr) {
    return isEmpty(arr) ? undefined : arr[0];
}
function last(arr) {
    var len = arr && arr.length;
    return len ? arr[len - 1] : undefined;
}
function forEach(collection, iteratorCallback) {
    /* istanbul ignore else */
    if (Array.isArray(collection)) {
        for (var i = 0; i < collection.length; i++) {
            iteratorCallback.call(null, collection[i], i);
        }
    }
    else if (isObject(collection)) {
        var colKeys = keys(collection);
        for (var i = 0; i < colKeys.length; i++) {
            var key = colKeys[i];
            var value = collection[key];
            iteratorCallback.call(null, value, key);
        }
    }
    else {
        throw Error("non exhaustive match");
    }
}
function isString(item) {
    return typeof item === "string";
}
function isUndefined(item) {
    return item === undefined;
}
function isFunction(item) {
    return item instanceof Function;
}
function drop(arr, howMuch) {
    if (howMuch === void 0) { howMuch = 1; }
    return arr.slice(howMuch, arr.length);
}
function dropRight(arr, howMuch) {
    if (howMuch === void 0) { howMuch = 1; }
    return arr.slice(0, arr.length - howMuch);
}
function filter(arr, predicate) {
    var result = [];
    if (Array.isArray(arr)) {
        for (var i = 0; i < arr.length; i++) {
            var item = arr[i];
            if (predicate.call(null, item)) {
                result.push(item);
            }
        }
    }
    return result;
}
function reject(arr, predicate) {
    return filter(arr, function (item) { return !predicate(item); });
}
function pick(obj, predicate) {
    var keys = Object.keys(obj);
    var result = {};
    for (var i = 0; i < keys.length; i++) {
        var currKey = keys[i];
        var currItem = obj[currKey];
        if (predicate(currItem)) {
            result[currKey] = currItem;
        }
    }
    return result;
}
function has(obj, prop) {
    if (isObject(obj)) {
        return obj.hasOwnProperty(prop);
    }
    return false;
}
function contains(arr, item) {
    return find(arr, function (currItem) { return currItem === item; }) !== undefined ? true : false;
}
/**
 * shallow clone
 */
function cloneArr(arr) {
    var newArr = [];
    for (var i = 0; i < arr.length; i++) {
        newArr.push(arr[i]);
    }
    return newArr;
}
/**
 * shallow clone
 */
function cloneObj(obj) {
    var clonedObj = {};
    for (var key in obj) {
        /* istanbul ignore else */
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            clonedObj[key] = obj[key];
        }
    }
    return clonedObj;
}
function find(arr, predicate) {
    for (var i = 0; i < arr.length; i++) {
        var item = arr[i];
        if (predicate.call(null, item)) {
            return item;
        }
    }
    return undefined;
}
function findAll(arr, predicate) {
    var found = [];
    for (var i = 0; i < arr.length; i++) {
        var item = arr[i];
        if (predicate.call(null, item)) {
            found.push(item);
        }
    }
    return found;
}
function reduce(arrOrObj, iterator, initial) {
    var isArr = Array.isArray(arrOrObj);
    var vals = isArr ? arrOrObj : values(arrOrObj);
    var objKeys = isArr ? [] : keys(arrOrObj);
    var accumulator = initial;
    for (var i = 0; i < vals.length; i++) {
        accumulator = iterator.call(null, accumulator, vals[i], isArr ? i : objKeys[i]);
    }
    return accumulator;
}
function compact(arr) {
    return reject(arr, function (item) { return item === null || item === undefined; });
}
function uniq(arr, identity) {
    if (identity === void 0) { identity = function (item) { return item; }; }
    var identities = [];
    return reduce(arr, function (result, currItem) {
        var currIdentity = identity(currItem);
        if (contains(identities, currIdentity)) {
            return result;
        }
        else {
            identities.push(currIdentity);
            return result.concat(currItem);
        }
    }, []);
}
function partial(func) {
    var restArgs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        restArgs[_i - 1] = arguments[_i];
    }
    var firstArg = [null];
    var allArgs = firstArg.concat(restArgs);
    return Function.bind.apply(func, allArgs);
}
function isArray(obj) {
    return Array.isArray(obj);
}
function isRegExp(obj) {
    return obj instanceof RegExp;
}
function isObject(obj) {
    return obj instanceof Object;
}
function every(arr, predicate) {
    for (var i = 0; i < arr.length; i++) {
        if (!predicate(arr[i], i)) {
            return false;
        }
    }
    return true;
}
function difference(arr, values) {
    return reject(arr, function (item) { return contains(values, item); });
}
function some(arr, predicate) {
    for (var i = 0; i < arr.length; i++) {
        if (predicate(arr[i])) {
            return true;
        }
    }
    return false;
}
function indexOf(arr, value) {
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] === value) {
            return i;
        }
    }
    return -1;
}
function sortBy(arr, orderFunc) {
    var result = cloneArr(arr);
    result.sort(function (a, b) { return orderFunc(a) - orderFunc(b); });
    return result;
}
function zipObject(keys, values) {
    if (keys.length !== values.length) {
        throw Error("can't zipObject with different number of keys and values!");
    }
    var result = {};
    for (var i = 0; i < keys.length; i++) {
        result[keys[i]] = values[i];
    }
    return result;
}
/**
 * mutates! (and returns) target
 */
function assign(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    for (var i = 0; i < sources.length; i++) {
        var curSource = sources[i];
        var currSourceKeys = keys(curSource);
        for (var j = 0; j < currSourceKeys.length; j++) {
            var currKey = currSourceKeys[j];
            target[currKey] = curSource[currKey];
        }
    }
    return target;
}
/**
 * mutates! (and returns) target
 */
function assignNoOverwrite(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    for (var i = 0; i < sources.length; i++) {
        var curSource = sources[i];
        if (isUndefined(curSource)) {
            continue;
        }
        var currSourceKeys = keys(curSource);
        for (var j = 0; j < currSourceKeys.length; j++) {
            var currKey = currSourceKeys[j];
            if (!has(target, currKey)) {
                target[currKey] = curSource[currKey];
            }
        }
    }
    return target;
}
function defaults() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    return assignNoOverwrite.apply(null, [{}].concat(sources));
}
function groupBy(arr, groupKeyFunc) {
    var result = {};
    forEach(arr, function (item) {
        var currGroupKey = groupKeyFunc(item);
        var currGroupArr = result[currGroupKey];
        if (currGroupArr) {
            currGroupArr.push(item);
        }
        else {
            result[currGroupKey] = [item];
        }
    });
    return result;
}
/**
 * Merge obj2 into obj1.
 * Will overwrite existing properties with the same name
 */
function merge(obj1, obj2) {
    var result = cloneObj(obj1);
    var keys2 = keys(obj2);
    for (var i = 0; i < keys2.length; i++) {
        var key = keys2[i];
        var value = obj2[key];
        result[key] = value;
    }
    return result;
}
function NOOP() { }
function IDENTITY(item) {
    return item;
}
/**
 * Will return a new packed array with same values.
 */
function packArray(holeyArr) {
    var result = [];
    for (var i = 0; i < holeyArr.length; i++) {
        var orgValue = holeyArr[i];
        result.push(orgValue !== undefined ? orgValue : undefined);
    }
    return result;
}
function PRINT_ERROR(msg) {
    /* istanbul ignore else - can't override global.console in node.js */
    if (console && console.error) {
        console.error("Error: " + msg);
    }
}
function PRINT_WARNING(msg) {
    /* istanbul ignore else - can't override global.console in node.js*/
    if (console && console.warn) {
        // TODO: modify docs accordingly
        console.warn("Warning: " + msg);
    }
}
function isES2015MapSupported() {
    return typeof Map === "function";
}
function applyMixins(derivedCtor, baseCtors) {
    baseCtors.forEach(function (baseCtor) {
        var baseProto = baseCtor.prototype;
        Object.getOwnPropertyNames(baseProto).forEach(function (propName) {
            if (propName === "constructor") {
                return;
            }
            var basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);
            // Handle Accessors
            if (basePropDescriptor &&
                (basePropDescriptor.get || basePropDescriptor.set)) {
                Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);
            }
            else {
                derivedCtor.prototype[propName] = baseCtor.prototype[propName];
            }
        });
    });
}
// base on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216
function toFastProperties(toBecomeFast) {
    function FakeConstructor() { }
    // If our object is used as a constructor it would receive
    FakeConstructor.prototype = toBecomeFast;
    var fakeInstance = new FakeConstructor();
    function fakeAccess() {
        return typeof fakeInstance.bar;
    }
    // help V8 understand this is a "real" prototype by actually using
    // the fake instance.
    fakeAccess();
    fakeAccess();
    return toBecomeFast;
    // Eval prevents optimization of this method (even though this is dead code)
    /* istanbul ignore next */
    // tslint:disable-next-line
    eval(toBecomeFast);
}
function peek(arr) {
    return arr[arr.length - 1];
}
/* istanbul ignore next - for performance tracing*/
function timer(func) {
    var start = new Date().getTime();
    var val = func();
    var end = new Date().getTime();
    var total = end - start;
    return { time: total, value: val };
}
//# sourceMappingURL=utils.js.map

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.round = exports.units = exports.chartRegistry = exports.constants = undefined;
exports.logging = logging;
exports.sampledCount = sampledCount;
exports.incrementSampledCount = incrementSampledCount;
exports.decrementSampledCount = decrementSampledCount;
exports.refreshDisabled = refreshDisabled;
exports.disableRefresh = disableRefresh;
exports.enableRefresh = enableRefresh;
exports.globalTransitionDuration = globalTransitionDuration;
exports.disableTransitions = disableTransitions;
exports.registerChart = registerChart;
exports.getChart = getChart;
exports.deregisterChart = deregisterChart;
exports.hasChart = hasChart;
exports.deregisterAllCharts = deregisterAllCharts;
exports.filterAll = filterAll;
exports.refocusAll = refocusAll;
exports.transition = transition;
exports.optionalTransition = optionalTransition;
exports.afterTransition = afterTransition;
exports.override = override;
exports.renderlet = renderlet;
exports.instanceOfChart = instanceOfChart;

var _utils = __webpack_require__(4);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var _logging = false;
var _sampledCount = 0;
var _refreshDisabled = false;
var _globalTransitionDuration = null;
var _renderlet = null;
var _disableTransitions = false;

var constants = exports.constants = {
  CHART_CLASS: "dc-chart",
  DEBUG_GROUP_CLASS: "debug",
  STACK_CLASS: "stack",
  DESELECTED_CLASS: "deselected",
  SELECTED_CLASS: "selected",
  NODE_INDEX_NAME: "__index__",
  GROUP_INDEX_NAME: "__group_index__",
  DEFAULT_CHART_GROUP: "__default_chart_group__",
  NEGLIGIBLE_NUMBER: 1e-10,
  ACCENT_CLASS: "accented",
  EVENT_DELAY: 0
};

function logging(_) {
  if (!arguments.length) {
    return _logging;
  }
  _logging = _;
}

function sampledCount(_) {
  if (!arguments.length) {
    return _sampledCount;
  }
  _sampledCount = _;
}

function incrementSampledCount() {
  return _sampledCount++;
}

function decrementSampledCount() {
  return _sampledCount--;
}

function refreshDisabled(_) {
  if (!arguments.length) {
    return _refreshDisabled;
  }
  _refreshDisabled = _;
}

function disableRefresh() {
  _refreshDisabled = true;
}

function enableRefresh() {
  _refreshDisabled = false;
}

function globalTransitionDuration(_) {
  if (!arguments.length) {
    return _globalTransitionDuration;
  }
  _globalTransitionDuration = _;
}

function disableTransitions(_) {
  if (!arguments.length) {
    return _disableTransitions;
  }
  _disableTransitions = _;
}

var chartRegistry = exports.chartRegistry = function () {
  // chartGroup:string => charts:array
  var _chartMap = {};

  function initializeChartGroup(group) {
    if (!group) {
      group = constants.DEFAULT_CHART_GROUP;
    }

    if (!_chartMap[group]) {
      _chartMap[group] = [];
    }

    return group;
  }

  return {
    has: function has(chart) {
      for (var e in _chartMap) {
        if (_chartMap[e].indexOf(chart) >= 0) {
          return true;
        }
      }
      return false;
    },
    register: function register(chart, group) {
      if (Array.isArray(group)) {
        group.forEach(function (g) {
          return _chartMap[initializeChartGroup(g)].push(chart);
        });
      } else {
        _chartMap[initializeChartGroup(group)].push(chart);
      }
    },
    deregister: function deregister(chart, group) {
      if (Array.isArray(group)) {
        group.forEach(function (g) {
          group = initializeChartGroup(g);
          for (var i = 0; i < _chartMap[group].length; i++) {
            if (_chartMap[group][i].anchorName() === chart.anchorName()) {
              _chartMap[group].splice(i, 1);
              break;
            }
          }
        });
      } else {
        group = initializeChartGroup(group);
        for (var i = 0; i < _chartMap[group].length; i++) {
          if (_chartMap[group][i].anchorName() === chart.anchorName()) {
            _chartMap[group].splice(i, 1);
            break;
          }
        }
      }
    },
    clear: function clear(group) {
      if (Array.isArray(group)) {
        group.forEach(function (g) {
          return delete _chartMap[g];
        });
      } else if (group) {
        delete _chartMap[group];
      } else {
        _chartMap = {};
      }
    },
    list: function list(group) {
      if (Array.isArray(group)) {
        return group.reduce(function (accum, g) {
          return [].concat(_toConsumableArray(accum), _toConsumableArray(_chartMap[initializeChartGroup(g)]));
        }, []).filter(function (item, i, self) {
          return self.indexOf(item) === i;
        });
      } else {
        group = initializeChartGroup(group);
        return _chartMap[group];
      }
    },
    listAll: function listAll() {
      return Object.keys(_chartMap).reduce(function (accum, key) {
        return accum.concat(_chartMap[key]);
      }, []).filter(function (item, i, self) {
        return self.indexOf(item) === i;
      });
    }
  };
}();

function registerChart(chart, group) {
  chartRegistry.register(chart, group);
}

function getChart(dcFlag) {
  return chartRegistry.listAll().reduce(function (accum, chrt) {
    return chrt.__dcFlag__ === dcFlag ? chrt : accum;
  }, null);
}

function deregisterChart(chart, group) {
  chartRegistry.deregister(chart, group);
}

function hasChart(chart) {
  return chartRegistry.has(chart);
}

function deregisterAllCharts(group) {
  chartRegistry.clear(group);
}

/**
 * Clear all filters on all charts within the given chart group. If the chart group is not given then
 * only charts that belong to the default chart group will be reset.
 * @memberof dc
 * @name filterAll
 * @param {String} [group]
 */
function filterAll(group) {
  var charts = chartRegistry.list(group);
  for (var i = 0; i < charts.length; ++i) {
    charts[i].filterAll();
  }
}

/**
 * Reset zoom level / focus on all charts that belong to the given chart group. If the chart group is
 * not given then only charts that belong to the default chart group will be reset.
 * @memberof dc
 * @name refocusAll
 * @param {String} [group]
 */
function refocusAll(group) {
  var charts = chartRegistry.list(group);
  for (var i = 0; i < charts.length; ++i) {
    if (charts[i].focus) {
      charts[i].focus();
    }
  }
}

function transition(selections, duration, callback, name) {
  if (duration <= 0 || duration === undefined || _disableTransitions) {
    return selections;
  }

  var s = selections.transition(name).duration(duration);

  if (typeof callback === "function") {
    callback(s);
  }

  return s;
}

/* somewhat silly, but to avoid duplicating logic */
function optionalTransition(enable, duration, callback, name) {
  if (enable) {
    return function (selection) {
      return transition(selection, duration, callback, name);
    };
  } else {
    return function (selection) {
      return selection;
    };
  }
}

// See http://stackoverflow.com/a/20773846
function afterTransition(_transition, callback) {
  if (_transition.empty() || !_transition.duration) {
    callback.call(_transition);
  } else {
    var n = 0;
    _transition.each(function () {
      ++n;
    }).each("end", function () {
      if (! --n) {
        callback.call(_transition);
      }
    });
  }
}

/**
 * @name units
 * @memberof dc
 * @type {{}}
 */
var units = exports.units = {};

/**
 * The default value for {@link #dc.coordinateGridMixin+xUnits .xUnits} for the
 * {@link #dc.coordinateGridMixin Coordinate Grid Chart} and should
 * be used when the x values are a sequence of integers.
 * It is a function that counts the number of integers in the range supplied in its start and end parameters.
 * @name integers
 * @memberof units
 * @see {@link #dc.coordinateGridMixin+xUnits coordinateGridMixin.xUnits}
 * @example
 * chart.xUnits(units.integers) // already the default
 * @param {Number} start
 * @param {Number} end
 * @return {Number}
 */
units.integers = function (start, end) {
  return Math.abs(end - start);
};

/**
 * This argument can be passed to the {@link #dc.coordinateGridMixin+xUnits .xUnits} function of the to
 * specify ordinal units for the x axis. Usually this parameter is used in combination with passing
 * {@link https://github.com/mbostock/d3/wiki/Ordinal-Scales d3.scale.ordinal} to
 * {@link #dc.coordinateGridMixin+x .x}.
 * It just returns the domain passed to it, which for ordinal charts is an array of all values.
 * @name ordinal
 * @memberof units
 * @see {@link https://github.com/mbostock/d3/wiki/Ordinal-Scales d3.scale.ordinal}
 * @see {@link #dc.coordinateGridMixin+xUnits coordinateGridMixin.xUnits}
 * @see {@link #dc.coordinateGridMixin+x coordinateGridMixin.x}
 * @example
 * chart.xUnits(dc.units.ordinal)
 *      .x(d3.scale.ordinal())
 * @param {*} start
 * @param {*} end
 * @param {Array<String>} domain
 * @return {Array<String>}
 */
units.ordinal = function (start, end, domain) {
  return domain;
};

/**
 * @name fp
 * @memberof units
 * @type {{}}
 */
units.fp = {};
/**
 * This function generates an argument for the {@link #dc.coordinateGridMixin Coordinate Grid Chart}
 * {@link #dc.coordinateGridMixin+xUnits .xUnits} function specifying that the x values are floating-point
 * numbers with the given precision.
 * The returned function determines how many values at the given precision will fit into the range
 * supplied in its start and end parameters.
 * @name precision
 * @memberof units.fp
 * @see {@link #dc.coordinateGridMixin+xUnits coordinateGridMixin.xUnits}
 * @example
 * // specify values (and ticks) every 0.1 units
 * chart.xUnits(units.fp.precision(0.1)
 * // there are 500 units between 0.5 and 1 if the precision is 0.001
 * var thousandths = units.fp.precision(0.001);
 * thousandths(0.5, 1.0) // returns 500
 * @param {Number} precision
 * @return {Function} start-end unit function
 */
units.fp.precision = function (precision) {
  var _f = function _f(s, e) {
    var d = Math.abs((e - s) / _f.resolution);
    if (_utils.utils.isNegligible(d - Math.floor(d))) {
      return Math.floor(d);
    } else {
      return Math.ceil(d);
    }
  };
  _f.resolution = precision;
  return _f;
};

var round = exports.round = {};
round.floor = function (n) {
  return Math.floor(n);
};
round.ceil = function (n) {
  return Math.ceil(n);
};
round.round = function (n) {
  return Math.round(n);
};

function override(obj, functionName, newFunction) {
  var existingFunction = obj[functionName];
  obj["_" + functionName] = existingFunction;
  obj[functionName] = newFunction;
}

function renderlet(_) {
  if (!arguments.length) {
    return _renderlet;
  }
  _renderlet = _;
}

function instanceOfChart(o) {
  return o instanceof Object && o.__dcFlag__ && true;
}

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utils = exports.pluck = exports.maxVal = exports.minVal = exports.printers = exports.customTimeFormat = exports.TIME_UNITS = exports.deepClone = exports.deepEquals = exports.dateFormat = exports.parser = undefined;
exports.extractTickFormat = extractTickFormat;
exports.xDomain = xDomain;
exports.xScale = xScale;
exports.xAxisTickFormat = xAxisTickFormat;

var _mapdDataLayer = __webpack_require__(225);

var _formattingHelpers = __webpack_require__(10);

var _datesAndTimes = __webpack_require__(29);

var _fastDeepEqual = __webpack_require__(181);

var _fastDeepEqual2 = _interopRequireDefault(_fastDeepEqual);

var _moment = __webpack_require__(0);

var _moment2 = _interopRequireDefault(_moment);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _core = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var parser = exports.parser = (0, _mapdDataLayer.createParser)();

function hexBinSQL(sql, _ref, parser) {
  var width = _ref.width,
      height = _ref.height,
      mark = _ref.mark,
      x = _ref.x,
      y = _ref.y,
      aggregate = _ref.aggregate;

  var hexoffsetx = 0;
  var hexoffsety = 0;

  var heximgwidth = width;
  var heximgheight = height;

  var hexminmercx = x.domain[0];
  var hexmaxmercx = x.domain[1];
  var hexminmercy = y.domain[0];
  var hexmaxmercy = y.domain[1];

  if (hexoffsetx) {
    var mercxdiff = hexoffsetx * (hexmaxmercx - hexminmercx) / heximgwidth;
    hexminmercx = hexminmercx - mercxdiff;
    hexmaxmercx = hexmaxmercx - mercxdiff;
  }

  if (hexoffsety) {
    var mercydiff = hexoffsety * (hexmaxmercy - hexminmercy) / heximgheight;
    hexminmercy = hexminmercy - mercydiff;
    hexmaxmercy = hexmaxmercy - mercydiff;
  }

  var args = parser.parseExpression(x.field) + "," + (hexminmercx + ",") + (hexmaxmercx + ",") + (parser.parseExpression(y.field) + ",") + (hexminmercy + ",") + (hexmaxmercy + ",") + (mark.width + ",") + (mark.height + ",") + (hexoffsetx + ",") + (hexoffsety + ",") + (width + ",") + ("" + height);

  sql.select.push("reg_" + mark.shape + "_horiz_pixel_bin_packed(" + args + ") AS xy");
  sql.select.push(parser.parseExpression(aggregate) + " AS color");
  sql.groupby.push("xy");

  return sql;
}

function rectBinSQL(sql, _ref2, parser) {
  var width = _ref2.width,
      height = _ref2.height,
      mark = _ref2.mark,
      x = _ref2.x,
      y = _ref2.y,
      aggregate = _ref2.aggregate;

  sql.select.push("rect_pixel_bin_packed(" + parser.parseExpression(x.field) + ", " + x.domain[0] + ", " + x.domain[1] + ", " + parser.parseExpression(y.field) + ", " + y.domain[0] + ", " + y.domain[1] + ", " + mark.width + ", " + mark.height + ", 0, 0, " + width + ", " + height + ") AS xy");

  sql.select.push(parser.parseExpression(aggregate) + " AS color");
  sql.groupby.push("xy");

  return sql;
}

parser.registerParser({
  meta: "transform",
  type: "pixel_bin"
}, function (sql, transform, parser) {
  switch (transform.mark.shape) {
    case "hex":
      return hexBinSQL(sql, transform, parser);
    case "square":
      return rectBinSQL(sql, transform, parser);
    default:
      return sql;
  }
});

parser.registerParser({
  meta: "transform",
  type: "rowid"
}, function (sql, transform) {
  var rowid = transform.table + ".rowid";
  sql.select.push(rowid);
  sql.groupby.push(rowid);
  return sql;
});

var dateFormat = exports.dateFormat = _d2.default.time.format.utc("%m/%d/%Y");

var deepEquals = exports.deepEquals = __webpack_require__(181); // eslint-disable-line global-require

var deepClone = exports.deepClone = function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
};

var TIME_UNITS = exports.TIME_UNITS = {
  DATE: true,
  TIMESTAMP: true,
  date: true,
  datetime: true,
  timestamp: true,
  "timestamp without timezone": true,
  TIME: true

  /* istanbul ignore next */
};var customTimeFormat = exports.customTimeFormat = _d2.default.time.format.utc.multi([[".%L", function (d) {
  return d.getUTCMilliseconds();
}], [":%S", function (d) {
  return d.getUTCSeconds();
}], ["%I:%M", function (d) {
  return d.getUTCMinutes();
}], ["%I %p", function (d) {
  return d.getUTCHours();
}], ["%a %d", function (d) {
  return d.getUTCDay() && d.getUTCDate() != 1;
}], // eslint-disable-line eqeqeq
["%b %d", function (d) {
  return d.getUTCDate() != 1;
}], // eslint-disable-line eqeqeq
["%b", function (d) {
  return d.getUTCMonth();
}], ["%Y", function () {
  return true;
}]]);

function extractTickFormat(timeBin) {
  return function (tick) {
    switch (timeBin) {
      case "year":
        return Math.ceil(tick);
      case "isodow":
        return _datesAndTimes.DAYS[tick - 1];
      case "month":
        return _datesAndTimes.MONTHS[tick - 1];
      case "quarter":
        return _datesAndTimes.QUARTERS[tick - 1];
      case "hour":
      case "minute":
        return tick + 1;
      default:
        return tick;
    }
  };
}

function xDomain(extract, currentLowValue, currentHighValue, timeBin) {
  if (extract) {
    switch (timeBin) {
      case "year":
        return [currentLowValue.getFullYear(), currentHighValue.getFullYear()];
      case "quarter":
        return [1, 4]; // eslint-disable-line no-magic-numbers
      case "isodow":
        return [1, 7]; // eslint-disable-line no-magic-numbers
      case "month":
        return [1, 12]; // eslint-disable-line no-magic-numbers
      case "day":
        return [1, 31]; // eslint-disable-line no-magic-numbers
      case "hour":
        return [0, 23]; // eslint-disable-line no-magic-numbers
      case "minute":
        return [0, 59]; // eslint-disable-line no-magic-numbers
      default:
        return [1, 7]; // eslint-disable-line no-magic-numbers
    }
  } else {
    return [currentLowValue, currentHighValue];
  }
}

function xScale(extract, isChartDate) {
  if (extract || !isChartDate) {
    return _d2.default.scale.linear();
  } else {
    return _d2.default.time.scale.utc();
  }
}

function xAxisTickFormat(_ref3, isChartDate) {
  var extract = _ref3.extract,
      timeBin = _ref3.timeBin;

  if (extract) {
    return utils.extractTickFormat(timeBin);
  } else if (isChartDate) {
    return customTimeFormat;
  } else {
    return _d2.default.format(".2s");
  }
}

var printers = exports.printers = {};

printers.filters = function (filters) {
  var s = "";

  for (var i = 0; i < filters.length; ++i) {
    if (i > 0) {
      s = s + ", ";
    }
    s = s + printers.filter(filters[i]);
  }

  return s;
};

printers.filter = function (filter) {
  var s = "";

  if (typeof filter !== "undefined" && filter !== null) {
    if (filter instanceof Array) {
      if (filter.length >= 2) {
        s = "[" + utils.printSingleValue(filter[0]) + " -> " + utils.printSingleValue(filter[1]) + "]";
      } else if (filter.length >= 1) {
        s = utils.printSingleValue(filter[0]);
      }
    } else {
      s = utils.printSingleValue(filter);
    }
  }

  return s;
};

var getKeyValues = function getKeyValues(data) {
  var keys = Object.keys(data).filter(function (k) {
    return k.indexOf("key") === 0;
  });
  return keys.reduce(function (aggregate, k) {
    return aggregate.concat(Array.isArray(data[k]) ? data[k].map(function (v) {
      return typeof v === "number" ? v : v.value;
    }) : [data[k]]);
  }, []);
};

var minVal = exports.minVal = function minVal(_ref4) {
  var data = _ref4.data;
  return _d2.default.min(getKeyValues(data));
};

var maxVal = exports.maxVal = function maxVal(_ref5) {
  var data = _ref5.data;
  return _d2.default.max(getKeyValues(data));
};

var pluck = exports.pluck = function pluck(n, f) {
  if (!f) {
    return function (d) {
      return d[n];
    };
  }
  return function (d, i) {
    return f.call(d, d[n], i);
  };
};

var utils = exports.utils = {};

utils.printSingleValue = function (filter) {
  var s = String(filter);

  if (filter instanceof Date) {
    s = dateFormat(filter);
  } else if (typeof filter === "string") {
    s = filter;
  } else if (utils.isFloat(filter)) {
    s = utils.printSingleValue.fformat(filter);
  } else if (utils.isInteger(filter)) {
    s = Math.round(filter);
  }

  return s;
};
utils.printSingleValue.fformat = _d2.default.format(".2f");

// FIXME: these assume than any string r is a percentage (whether or not it
// includes %).
utils.add = function (l, r, c) {
  if (typeof r === "string") {
    r = r.replace("%", "");
  }

  if (l instanceof Date) {
    if (typeof r === "string") {
      r = Number(r);
    }
    var d = new Date();
    d.setTime(l.getTime());
    d.setDate(l.getDate() + r);
    return d;
  } else if (typeof r === "string") {
    var percentage = Number(r) / 100;
    return l + c * percentage;
  } else {
    return l + r;
  }
};

utils.subtract = function (l, r, c) {
  if (typeof r === "string") {
    r = r.replace("%", "");
  }

  if (l instanceof Date) {
    if (typeof r === "string") {
      r = Number(r);
    }
    var d = new Date();
    d.setTime(l.getTime());
    d.setDate(l.getDate() - r);
    return d;
  } else if (typeof r === "string") {
    var percentage = Number(r) / 100;
    return l - c * percentage;
  } else {
    return l - r;
  }
};

utils.isNumber = function (n) {
  return n === Number(n);
};

utils.isFloat = function (n) {
  return n === Number(n) && n !== (n | 0);
};

utils.isInteger = function (n) {
  return n === Number(n) && n === (n | 0);
};

utils.isNegligible = function (n) {
  return !utils.isNumber(n) || n < _core.constants.NEGLIGIBLE_NUMBER && n > -_core.constants.NEGLIGIBLE_NUMBER;
};

utils.clamp = function (val, min, max) {
  return val < min ? min : val > max ? max : val;
};

utils.uniqueId = function () {
  return Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
};

utils.nameToId = function (name) {
  if (parseFloat(name)) {
    return name;
  } else {
    return name.toLowerCase().replace(/[\s]/g, "_").replace(/[\.']/g, "");
  }
};

utils.appendOrSelect = function (parent, selector, tag) {
  tag = tag || selector;
  var element = parent.select(selector);
  if (element.empty()) {
    element = parent.append(tag);
  }
  return element;
};

utils.safeNumber = function (n) {
  return utils.isNumber(Number(n)) ? Number(n) : 0;
};

utils.b64toBlob = function (b64Data, contentType, sliceSize) {
  contentType = contentType || "";
  sliceSize = sliceSize || 512;

  var byteCharacters = atob(b64Data);
  var byteArrays = [];

  for (var offset = 0; offset < byteCharacters.length; offset = offset + sliceSize) {
    var slice = byteCharacters.slice(offset, offset + sliceSize);

    var byteNumbers = new Array(slice.length);
    for (var i = 0; i < slice.length; i++) {
      byteNumbers[i] = slice.charCodeAt(i);
    }

    var byteArray = new Uint8Array(byteNumbers);

    byteArrays.push(byteArray);
  }

  var blob = new Blob(byteArrays, { type: contentType });
  return blob;
};

utils.getFontSizeFromWidth = function (text, chartWidth, chartHeight) {
  var BASE_FONT_SIZE = 12;
  var MIN_FONT_SIZE = 4;
  var tmpText = _d2.default.select("body").append("span").attr("class", "tmp-text").style("font-size", BASE_FONT_SIZE + "px").style("position", "absolute").style("opacity", 0).style("margin-right", 10000).html(text);
  var node = tmpText.node();

  var textWidth = null;
  var textHeight = null;
  if (node.getBoundingClientRect) {
    var bbox = node.getBoundingClientRect();
    textWidth = bbox.width;
    textHeight = bbox.height;
  }

  tmpText.remove();

  var fontSizeWidth = BASE_FONT_SIZE * chartWidth / textWidth;
  var fontSizeHeight = BASE_FONT_SIZE * chartHeight / textHeight;

  return Math.max(Math.min(fontSizeWidth, fontSizeHeight), MIN_FONT_SIZE);
};

utils.isOrdinal = function (type) {
  var BOOL_TYPES = { BOOL: true };

  var TEXT_TYPES = {
    varchar: true,
    text: true,
    STR: true
  };

  var TEXT_AND_BOOL_TYPES = Object.assign({}, TEXT_TYPES, BOOL_TYPES);

  return type in TEXT_AND_BOOL_TYPES;
};

utils.isQuantitative = function (type) {
  var NUMERICAL_INTEGER_TYPES = {
    int2: true,
    int4: true,
    int8: true,
    SMALLINT: true,
    INT: true,
    BIGINT: true
  };

  var NUMERICAL_REAL_TYPES = {
    FLOAT: true,
    DOUBLE: true,
    DECIMAL: true
  };

  var NONCUSTOM_NUMERICAL_TYPES = Object.assign({}, NUMERICAL_INTEGER_TYPES, NUMERICAL_REAL_TYPES);

  return type in NONCUSTOM_NUMERICAL_TYPES;
};

utils.deepEquals = _fastDeepEqual2.default;
utils.customTimeFormat = customTimeFormat;
utils.extractTickFormat = extractTickFormat;
utils.formatValue = _formattingHelpers.formatDataValue;
utils.maybeFormatInfinity = _formattingHelpers.maybeFormatInfinity;

utils.nullsFirst = function (sorting) {
  return function (a, b) {
    if (a === null) {
      return -1;
    } else if (b === null) {
      return 1;
    }

    return sorting(a, b);
  };
};

utils.nullsLast = function (sorting) {
  return function (a, b) {
    if (a === null) {
      return 1;
    } else if (b === null) {
      return -1;
    }

    return sorting(a, b);
  };
};

utils.compareDates = function (sorting) {
  return function (a, b) {
    var defaultDateFormat = "mm, dd, YYYY  hh:mm:ss";
    var compareA = (0, _moment2.default)(a, defaultDateFormat, true).toDate();
    var compareB = (0, _moment2.default)(b, defaultDateFormat, true).toDate();
    if (compareA !== "Invalid date" && compareB !== "Invalid date") {
      return sorting(compareA.getTime(), compareB.getTime());
    }

    return sorting(a, b);
  };
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LockTracker = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.startRenderTime = startRenderTime;
exports.startRedrawTime = startRedrawTime;
exports.resetRedrawStack = resetRedrawStack;
exports.redrawStackEmpty = redrawStackEmpty;
exports.renderStackEmpty = renderStackEmpty;
exports.isEqualToRedrawCount = isEqualToRedrawCount;
exports.incrementRenderStack = incrementRenderStack;
exports.resetRenderStack = resetRenderStack;
exports.isEqualToRenderCount = isEqualToRenderCount;
exports.redrawAllAsync = redrawAllAsync;
exports.renderAllAsync = renderAllAsync;
exports.groupAll = groupAll;
exports.getLastFilteredSizeAsync = getLastFilteredSizeAsync;
exports.lastFilteredSize = lastFilteredSize;
exports.setLastFilteredSize = setLastFilteredSize;
exports.resetState = resetState;

var _core = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _renderId = 0;
var _redrawId = 0;
var _renderCount = 0;
var _redrawCount = 0;
var _startRenderTime = null;
var _startRedrawTime = null;

var _groupAll = {};
var _lastFilteredSize = {};

// NOTE: a "group" of null is valid!

var LockTracker = exports.LockTracker = function () {
  function LockTracker() {
    _classCallCheck(this, LockTracker);

    this.all = null;
    this.groups = {};
    this.pendingAll = null;
    this.pendingGroups = {};
  }

  _createClass(LockTracker, [{
    key: "shouldStart",


    // Utility function to check if a render/redraw should start for the given
    // group or "all".
    value: function shouldStart(group, all) {
      // Conditions are checked in this order:
      // 1. If currently rendering/redrawing all, return false.
      // 2. If we're requesting a render/redraw all and *anything* is currently
      //    rendering/redrawing, return false.
      // 3. If the requested group is rendering/redrawing, return false.
      // 4. Otherwise, return true.
      return !this.all && (all ? Object.keys(this.groups).length === 0 : !this.groups[group]);
    }

    // Returns true if nothing is currently rendering. If a "group" is given,
    // returns true if neither "all" nor the group is rendering.

  }, {
    key: "isEmpty",
    value: function isEmpty(group) {
      if (typeof group !== "undefined") {
        return this.shouldStart(group, false);
      }
      return this.shouldStart(null, true);
    }
  }, {
    key: "start",
    value: function start(group, all, runner) {
      var _this = this;

      // if we can safely start this group/all, go for it!
      if (this.shouldStart(group, all)) {
        return this._run(group, all, runner);
      }

      // otherwise, if we already have a pending promise, return it
      if (this.pendingAll) {
        return this.pendingAll;
      } else if (this.pendingGroups[group]) {
        return this.pendingGroups[group];
      }

      // Ok, we can't start running now, and we don't already have a pending
      // promise. We need to create a new pending promise to run after the
      // currently running promise is finished. If we got this far, one of the
      // following states must be true, otherwise shouldStart would have returned
      // true and we would have started running already:
      // 1. this.all is not-null, which means we can wait on that promise
      // 2. "all" is truthy, which means we need to wait on all of the groups
      //    that are currently running to finish
      // 3. "all" is not set, so we only need to wait on the group to finish
      var promise = this.all || (all ? // Promise.all returns immediately if any of the promises reject - we
      // want to wait on them all regardless if any reject, so we
      // explicitly catch and return an empty array so that if the promise
      // rejects, it'll end up resolving in this context
      Promise.all(Object.values(this.groups).map(function (p) {
        return p.catch(function () {
          return [];
        });
      })) : this.groups[group]);

      // Whether or not the running promise is resolved or rejected, we want to
      // run the next promise. Maybe if the current promise failed, re-running it
      // will succeed. We use then(nextRunner, nextRunner) in both blocks below
      // instead of finally() because we need nextRunner to return a new promise.
      // The return value from finally() is ignored. Not to mention, the
      // es6/es2015 polyfill doesn't include finally() anyway =)
      if (all) {
        var nextRunner = function nextRunner() {
          _this.pendingAll = null;
          return _this._run(group, all, runner);
        };
        promise = promise.then(nextRunner, nextRunner);
        this.pendingAll = promise;
      } else {
        var _nextRunner = function _nextRunner() {
          delete _this.pendingGroups[group];

          if (_this.pendingAll) {
            // Group was queued before "all", so, we just return the pendingAll
            // promise. When pendingAll is done, this group will technically
            // have been run along with all the other groups, so there's no
            // reason to handle the group individually.
            return _this.pendingAll;
          }

          return _this._run(group, all, runner);
        };
        promise = promise.then(_nextRunner, _nextRunner);
        this.pendingGroups[group] = promise;
      }
      return promise;
    }

    // private method to start a runner and save the promise

  }, {
    key: "_run",
    value: function _run(group, all, runner) {
      var _this2 = this;

      var cleanup = function cleanup() {
        if (all) {
          _this2.all = null;
        } else {
          delete _this2.groups[group];
        }
      };

      // Start the runner - whether it succeeds or not, cleanup.
      // The es6/es2015 polyfill doesn't include .finally(), so we use .then()
      // and make sure to pass the resolved/rejected state up the stack. If we
      // ever upgrade to the es7 polyfill, this can be rewritten as:
      // runner().finally(clean)
      var promise = null;
      try {
        promise = runner();
      } catch (err) {
        promise = Promise.reject(err);
      }
      promise = promise.then(function (val) {
        cleanup();
        return val;
      }, function (err) {
        cleanup();
        throw err;
      });

      // store a reference to the promise
      if (all) {
        this.all = promise;
      } else {
        this.groups[group] = promise;
      }

      return promise;
    }
  }]);

  return LockTracker;
}();

var renderAllTracker = new LockTracker();
var redrawAllTracker = new LockTracker();

function startRenderTime() {
  return _startRenderTime;
}

function startRedrawTime() {
  return _startRedrawTime;
}

function resetRedrawStack() {
  _redrawCount = 0;
}

function redrawStackEmpty(group) {
  return redrawAllTracker.isEmpty(group);
}

function renderStackEmpty(group) {
  return renderAllTracker.isEmpty(group);
}

function isEqualToRedrawCount(queryCount) {
  return ++_redrawCount === queryCount;
}

function incrementRenderStack() {
  var queryGroupId = _renderId++;
  return queryGroupId;
}

function resetRenderStack() {
  _renderCount = 0;
}

function isEqualToRenderCount(queryCount) {
  return ++_renderCount === queryCount;
}

function redrawAllAsync(group, allCharts, excludeChart) {
  if ((0, _core.refreshDisabled)()) {
    var charts = allCharts ? _core.chartRegistry.listAll() : _core.chartRegistry.list(group);
    return Promise.resolve(charts);
  }

  if (!startRenderTime()) {
    return Promise.reject("redrawAllAsync() is called before renderAllAsync(), please call renderAllAsync() first.");
  }

  return redrawAllTracker.start(group, allCharts, function () {
    var queryGroupId = _redrawId++;
    _startRedrawTime = new Date();

    var createRedrawPromises = function createRedrawPromises() {
      var charts = allCharts ? _core.chartRegistry.listAll() : _core.chartRegistry.list(group);
      if (excludeChart) {
        charts = charts.filter(function (c) {
          return c.__dcFlag__ !== excludeChart.__dcFlag__;
        });
      }
      return charts.map(function (chart) {
        chart.expireCache();
        chart._invokeDataFetchListener();
        // We have to force a render for HEATMAP, not redraw for crossfilters to
        //  work properly.  Mea culpa, mea culpa.
        return chart.isHeatMap ? chart.renderAsync(queryGroupId, charts.length).catch(function (e) {
          chart._invokeDataErrorListener(e);
          throw e;
        }) : chart.redrawAsync(queryGroupId, charts.length).catch(function (e) {
          chart._invokeDataErrorListener(e);
          throw e;
        });
      });
    };

    if ((0, _core.renderlet)() !== null) {
      (0, _core.renderlet)(group);
    }

    if (groupAll()) {
      return getLastFilteredSizeAsync().then(function () {
        return Promise.all(createRedrawPromises());
      }).catch(function (err) {
        console.log(err);
        resetRedrawStack();
        throw err;
      });
    } else {
      return Promise.all(createRedrawPromises()).catch(function (err) {
        console.log(err);
        resetRedrawStack();
        throw err;
      });
    }
  });
}

function renderAllAsync(group, allCharts) {
  if ((0, _core.refreshDisabled)()) {
    var charts = allCharts ? _core.chartRegistry.listAll() : _core.chartRegistry.list(group);
    return Promise.resolve(charts);
  }

  return renderAllTracker.start(group, allCharts, function () {
    var queryGroupId = _renderId++;
    _startRenderTime = new Date();

    var createRenderPromises = function createRenderPromises() {
      var charts = allCharts ? _core.chartRegistry.listAll() : _core.chartRegistry.list(group);
      return charts.map(function (chart) {
        chart.expireCache();
        return chart.renderAsync(queryGroupId, charts.length);
      });
    };

    if ((0, _core.renderlet)() !== null) {
      (0, _core.renderlet)(group);
    }

    if (groupAll()) {
      return getLastFilteredSizeAsync().then(function () {
        return Promise.all(createRenderPromises());
      });
    } else {
      return Promise.all(createRenderPromises());
    }
  });
}

function groupAll(group) {
  if (!arguments.length) {
    for (var key in _groupAll) {
      if (_groupAll.hasOwnProperty(key)) {
        return _groupAll;
      }
    }
    return null;
  }

  _groupAll[group.getCrossfilterId()] = group;

  return _groupAll;
}

function getLastFilteredSizeAsync(arg) {
  var keyArray = [];
  var crossfilterId = null;
  if (typeof arg === "number") {
    crossfilterId = arg;
  } else if ((typeof arg === "undefined" ? "undefined" : _typeof(arg)) === "object" && typeof arg.getCrossfilterId === "function") {
    crossfilterId = arg.getCrossfilterId();
  }

  if (crossfilterId !== null) {
    var group = _groupAll[crossfilterId];
    if (group) {
      return group.valueAsync().then(function (value) {
        _lastFilteredSize[crossfilterId] = value;
        return value;
      });
    } else {
      return new Promise(function (reject) {
        return reject("The group with crossfilterId " + crossfilterId + " is not an active groupAll() group");
      });
    }
  } else if (arg) {
    return new Promise(function (reject) {
      return reject("The argument to getLastFilteredSizeAsync must be a crossfilterId or a group/groupAll object, or call getLastFilteredSizeAsync without an argument to calculate all groupAlls");
    });
  }

  return Promise.all(Object.keys(_groupAll).map(function (key) {
    keyArray.push(key);
    return _groupAll[key].valueAsync();
  })).then(function (values) {
    for (var i = 0; i < values.length; ++i) {
      _lastFilteredSize[keyArray[i]] = values[i];
    }
  });
}

function lastFilteredSize(crossfilterId) {
  return _lastFilteredSize[crossfilterId];
}

function setLastFilteredSize(crossfilterId, value) {
  _lastFilteredSize[crossfilterId] = value;
}

function resetState() {
  _groupAll = {};
  _lastFilteredSize = {};
}

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AbstractProduction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return NonTerminal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return Rule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return Flat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return Option; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return RepetitionMandatory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return RepetitionMandatoryWithSeparator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return Repetition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return RepetitionWithSeparator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Alternation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return Terminal; });
/* harmony export (immutable) */ __webpack_exports__["l"] = serializeGrammar;
/* harmony export (immutable) */ __webpack_exports__["m"] = serializeProduction;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__scan_tokens_public__ = __webpack_require__(17);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var AbstractProduction = /** @class */ (function () {
    function AbstractProduction(definition) {
        this.definition = definition;
    }
    AbstractProduction.prototype.accept = function (visitor) {
        visitor.visit(this);
        Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(this.definition, function (prod) {
            prod.accept(visitor);
        });
    };
    return AbstractProduction;
}());

var NonTerminal = /** @class */ (function (_super) {
    __extends(NonTerminal, _super);
    function NonTerminal(options) {
        var _this = _super.call(this, []) || this;
        _this.idx = 1;
        Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["f" /* assign */])(_this, Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["N" /* pick */])(options, function (v) { return v !== undefined; }));
        return _this;
    }
    Object.defineProperty(NonTerminal.prototype, "definition", {
        get: function () {
            if (this.referencedRule !== undefined) {
                return this.referencedRule.definition;
            }
            return [];
        },
        set: function (definition) {
            // immutable
        },
        enumerable: true,
        configurable: true
    });
    NonTerminal.prototype.accept = function (visitor) {
        visitor.visit(this);
        // don't visit children of a reference, we will get cyclic infinite loops if we do so
    };
    return NonTerminal;
}(AbstractProduction));

var Rule = /** @class */ (function (_super) {
    __extends(Rule, _super);
    function Rule(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.orgText = "";
        Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["f" /* assign */])(_this, Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["N" /* pick */])(options, function (v) { return v !== undefined; }));
        return _this;
    }
    return Rule;
}(AbstractProduction));

// TODO: is this only used in an Alternation?
//       Perhaps `Flat` should be renamed to `Alternative`?
var Flat = /** @class */ (function (_super) {
    __extends(Flat, _super);
    // A named Flat production is used to indicate a Nested Rule in an alternation
    function Flat(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.ignoreAmbiguities = false;
        Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["f" /* assign */])(_this, Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["N" /* pick */])(options, function (v) { return v !== undefined; }));
        return _this;
    }
    return Flat;
}(AbstractProduction));

var Option = /** @class */ (function (_super) {
    __extends(Option, _super);
    function Option(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["f" /* assign */])(_this, Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["N" /* pick */])(options, function (v) { return v !== undefined; }));
        return _this;
    }
    return Option;
}(AbstractProduction));

var RepetitionMandatory = /** @class */ (function (_super) {
    __extends(RepetitionMandatory, _super);
    function RepetitionMandatory(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["f" /* assign */])(_this, Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["N" /* pick */])(options, function (v) { return v !== undefined; }));
        return _this;
    }
    return RepetitionMandatory;
}(AbstractProduction));

var RepetitionMandatoryWithSeparator = /** @class */ (function (_super) {
    __extends(RepetitionMandatoryWithSeparator, _super);
    function RepetitionMandatoryWithSeparator(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["f" /* assign */])(_this, Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["N" /* pick */])(options, function (v) { return v !== undefined; }));
        return _this;
    }
    return RepetitionMandatoryWithSeparator;
}(AbstractProduction));

var Repetition = /** @class */ (function (_super) {
    __extends(Repetition, _super);
    function Repetition(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["f" /* assign */])(_this, Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["N" /* pick */])(options, function (v) { return v !== undefined; }));
        return _this;
    }
    return Repetition;
}(AbstractProduction));

var RepetitionWithSeparator = /** @class */ (function (_super) {
    __extends(RepetitionWithSeparator, _super);
    function RepetitionWithSeparator(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["f" /* assign */])(_this, Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["N" /* pick */])(options, function (v) { return v !== undefined; }));
        return _this;
    }
    return RepetitionWithSeparator;
}(AbstractProduction));

var Alternation = /** @class */ (function (_super) {
    __extends(Alternation, _super);
    function Alternation(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        _this.ignoreAmbiguities = false;
        _this.hasPredicates = false;
        Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["f" /* assign */])(_this, Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["N" /* pick */])(options, function (v) { return v !== undefined; }));
        return _this;
    }
    return Alternation;
}(AbstractProduction));

var Terminal = /** @class */ (function () {
    function Terminal(options) {
        this.idx = 1;
        Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["f" /* assign */])(this, Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["N" /* pick */])(options, function (v) { return v !== undefined; }));
    }
    Terminal.prototype.accept = function (visitor) {
        visitor.visit(this);
    };
    return Terminal;
}());

function serializeGrammar(topRules) {
    return Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */])(topRules, serializeProduction);
}
function serializeProduction(node) {
    function convertDefinition(definition) {
        return Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */])(definition, serializeProduction);
    }
    /* istanbul ignore else */
    if (node instanceof NonTerminal) {
        return {
            type: "NonTerminal",
            name: node.nonTerminalName,
            idx: node.idx
        };
    }
    else if (node instanceof Flat) {
        return {
            type: "Flat",
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof Option) {
        return {
            type: "Option",
            idx: node.idx,
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof RepetitionMandatory) {
        return {
            type: "RepetitionMandatory",
            name: node.name,
            idx: node.idx,
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof RepetitionMandatoryWithSeparator) {
        return {
            type: "RepetitionMandatoryWithSeparator",
            name: node.name,
            idx: node.idx,
            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof RepetitionWithSeparator) {
        return {
            type: "RepetitionWithSeparator",
            name: node.name,
            idx: node.idx,
            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof Repetition) {
        return {
            type: "Repetition",
            name: node.name,
            idx: node.idx,
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof Alternation) {
        return {
            type: "Alternation",
            name: node.name,
            idx: node.idx,
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof Terminal) {
        var serializedTerminal = {
            type: "Terminal",
            name: node.terminalType.name,
            label: Object(__WEBPACK_IMPORTED_MODULE_1__scan_tokens_public__["e" /* tokenLabel */])(node.terminalType),
            idx: node.idx
        };
        var pattern = node.terminalType.PATTERN;
        if (node.terminalType.PATTERN) {
            serializedTerminal.pattern = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["D" /* isRegExp */])(pattern)
                ? pattern.source
                : pattern;
        }
        return serializedTerminal;
    }
    else if (node instanceof Rule) {
        return {
            type: "Rule",
            name: node.name,
            orgText: node.orgText,
            definition: convertDefinition(node.definition)
        };
    }
    else {
        throw Error("non exhaustive match");
    }
}
//# sourceMappingURL=gast_public.js.map

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = baseMixin;

var _utils = __webpack_require__(4);

var _core = __webpack_require__(3);

var _coreAsync = __webpack_require__(5);

var _asyncMixin = __webpack_require__(182);

var _asyncMixin2 = _interopRequireDefault(_asyncMixin);

var _legendMixin = __webpack_require__(246);

var _legendMixin2 = _interopRequireDefault(_legendMixin);

var _binningHelpers = __webpack_require__(22);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _errors = __webpack_require__(37);

var errors = _interopRequireWildcard(_errors);

var _filterMixin = __webpack_require__(247);

var _filterMixin2 = _interopRequireDefault(_filterMixin);

var _labelMixin = __webpack_require__(248);

var _labelMixin2 = _interopRequireDefault(_labelMixin);

var _logger = __webpack_require__(36);

var _multipleKeyAccessors = __webpack_require__(183);

var _multipleKeyLabelMixin = __webpack_require__(184);

var _multipleKeyLabelMixin2 = _interopRequireDefault(_multipleKeyLabelMixin);

var _spinnerMixin = __webpack_require__(185);

var _spinnerMixin2 = _interopRequireDefault(_spinnerMixin);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * `dc.baseMixin` is an abstract functional object representing a basic `dc` chart object
 * for all chart and widget implementations. Methods from the {@link #dc.baseMixin dc.baseMixin} are inherited
 * and available on all chart implementations in the `dc` library.
 * @name baseMixin
 * @memberof dc
 * @mixin
 * @param {Object} _chart
 * @return {dc.baseMixin}
 */
function baseMixin(_chart) {
  // This is intended to be random every time a chart is created, but then to
  // stay that same random number for as long as the chart exists in memory.
  //
  // The main reason for this is to support the raster chart and mixins, where
  // the renderVega and getResultRowForPixel methods to mapd-connector (.con())
  // expect to get a integer id unique to a given active rendered chart, and
  // the same for that chart across its active lifetime.
  _chart.__dcFlag__ = _utils.utils.uniqueId();

  var _dimension = void 0;
  var _group = void 0;
  var _anchor = void 0;
  var _root = void 0;
  var _svg = void 0;
  var _isChild = void 0;
  var _popup = void 0;
  var _popupIsEnabled = true;
  var _redrawBrushFlag = false;
  var _isTargeting = false;
  var _colorByExpr = null;
  var _legendLock = null;
  var _legendUnlock = null;
  var _legendInputChange = null;

  var _minWidth = 200;

  var _defaultWidth = function _defaultWidth(element) {
    var width = element && element.getBoundingClientRect && element.getBoundingClientRect().width;
    return width && width > _minWidth ? width : _minWidth;
  };
  var _width = _defaultWidth;

  var _minHeight = 200;
  var _defaultHeight = function _defaultHeight(element) {
    var height = element && element.getBoundingClientRect && element.getBoundingClientRect().height;
    return height && height > _minHeight ? height : _minHeight;
  };
  var _height = _defaultHeight;

  var _keyAccessor = (0, _utils.pluck)("key");
  var _label = (0, _utils.pluck)("key");

  var _valueAccessor = (0, _utils.pluck)("val");
  var _orderSort = void 0;

  var _renderLabel = false;

  var _title = function _title(d) {
    var key = _chart.keyAccessor()(d);
    var value = _chart.valueAccessor()(d);
    return (key instanceof Date ? key.toISOString() : key) + ": " + (value instanceof Date ? value.toISOString() : value);
  };
  var _renderTitle = true;
  var _controlsUseVisibility = true;

  var _transitionDuration = 500;

  var _filterPrinter = _utils.printers.filters;

  var _mandatoryAttributes = ["dimension", "group"];

  var _chartGroup = _core.constants.DEFAULT_CHART_GROUP;

  var _listeners = _d2.default.dispatch("preRender", "postRender", "preRedraw", "postRedraw", "filtered", "zoomed", "renderlet", "pretransition", "bboxFiltered");

  var _legend = void 0;
  var _commitHandler = void 0;
  var _valueFormatter = void 0;
  var _dateFormatter = void 0;

  /* OVERRIDE ---------------------------------------------------------------- */
  var _legendContinuous = void 0;

  var _topQueryCallback = null;

  var _registerQuery = function _registerQuery(callback) {
    var stackEmpty = _topQueryCallback == null;
    // need to check if max query?
    _topQueryCallback = callback;
    if (stackEmpty) {
      _topQueryCallback.func();
    }
  };

  var _popQueryStack = function _popQueryStack(id) {
    if (_topQueryCallback != null && id == _topQueryCallback.id) {
      _topQueryCallback = null;
    } else {
      _topQueryCallback.func();
    }
  };

  var _startNextQuery = function _startNextQuery() {
    _topQueryCallback.func();
    // var callback = _firstQueryCallback;
    // callback();
  };

  // override for count chart
  _chart.isCountChart = function () {
    return false;
  };
  /* ------------------------------------------------------------------------- */

  var _filters = [];

  var _filterHandler = function _filterHandler(dimension, filters) {
    if (filters.length === 0) {
      return filters;
    }
  };

  var _data = function _data(group) {
    return group.all();
  };
  /**
   * Set or get the height attribute of a chart. The height is applied to the SVGElement generated by
   * the chart when rendered (or re-rendered). If a value is given, then it will be used to calculate
   * the new height and the chart returned for method chaining.  The value can either be a numeric, a
   * function, or falsy. If no value is specified then the value of the current height attribute will
   * be returned.
   *
   * By default, without an explicit height being given, the chart will select the width of its
   * anchor element. If that isn't possible it defaults to 200 (provided by the
   * {@link #dc.baseMixin+minHeight minHeight} property). Setting the value falsy will return
   * the chart to the default behavior.
   * @name height
   * @memberof dc.baseMixin
   * @instance
   * @see {@link #dc.baseMixin+minHeight minHeight}
   * @example
   * // Default height
   * chart.height(function (element) {
   *     var height = element && element.getBoundingClientRect && element.getBoundingClientRect().height;
   *     return (height && height > chart.minHeight()) ? height : chart.minHeight();
   * });
   *
   * chart.height(250); // Set the chart's height to 250px;
   * chart.height(function(anchor) { return doSomethingWith(anchor); }); // set the chart's height with a function
   * chart.height(null); // reset the height to the default auto calculation
   * @param {Number|Function} [height]
   * @return {Number}
   * @return {dc.baseMixin}
   */
  _chart.height = function (height) {
    if (!arguments.length) {
      return _height(_root.node());
    }

    _height = _d2.default.functor(height || _defaultHeight);
    return _chart;
  };

  /**
   * Set or get the width attribute of a chart.
   * @name width
   * @memberof dc.baseMixin
   * @instance
   * @see {@link #dc.baseMixin+height height}
   * @see {@link #dc.baseMixin+minWidth minWidth}
   * @example
   * // Default width
   * chart.width(function (element) {
   *     var width = element && element.getBoundingClientRect && element.getBoundingClientRect().width;
   *     return (width && width > chart.minWidth()) ? width : chart.minWidth();
   * });
   * @param {Number|Function} [width]
   * @return {Number}
   * @return {dc.baseMixin}
   */
  _chart.width = function (width) {
    if (!arguments.length) {
      return _width(_root.node());
    }
    _width = _d2.default.functor(width || _defaultWidth);
    return _chart;
  };

  /* OVERRIDE ---------------------------------------------------------------- */
  _chart.accent = function () {}; // no-op
  _chart.unAccent = function () {}; // no-op
  /* ------------------------------------------------------------------------- */

  /**
   * Set or get the minimum width attribute of a chart. This only has effect when used with the default
   * {@link #dc.baseMixin+width width} function.
   * @name minWidth
   * @memberof dc.baseMixin
   * @instance
   * @see {@link #dc.baseMixin+width width}
   * @param {Number} [minWidth=200]
   * @return {Number}
   * @return {dc.baseMixin}
   */
  _chart.minWidth = function (minWidth) {
    if (!arguments.length) {
      return _minWidth;
    }
    _minWidth = minWidth;
    return _chart;
  };

  /**
   * Set or get the minimum height attribute of a chart. This only has effect when used with the default
   * {@link #dc.baseMixin+height height} function.
   * @name minHeight
   * @memberof dc.baseMixin
   * @instance
   * @see {@link #dc.baseMixin+height height}
   * @param {Number} [minHeight=200]
   * @return {Number}
   * @return {dc.baseMixin}
   */
  _chart.minHeight = function (minHeight) {
    if (!arguments.length) {
      return _minHeight;
    }
    _minHeight = minHeight;
    return _chart;
  };

  /**
   * **mandatory**
   *
   * Set or get the dimension attribute of a chart. In `dc`, a dimension can be any valid [crossfilter
   * dimension](https://github.com/square/crossfilter/wiki/API-Reference#wiki-dimension).
   *
   * If a value is given, then it will be used as the new dimension. If no value is specified then
   * the current dimension will be returned.
   * @name dimension
   * @memberof dc.baseMixin
   * @instance
   * @see {@link https://github.com/square/crossfilter/wiki/API-Reference#dimension crossfilter.dimension}
   * @example
   * var index = crossfilter([]);
   * var dimension = index.dimension(dc.pluck('key'));
   * chart.dimension(dimension);
   * @param {crossfilter.dimension} [dimension]
   * @return {crossfilter.dimension}
   * @return {dc.baseMixin}
   */
  _chart.dimension = function (dimension) {
    if (!arguments.length) {
      return _dimension;
    }
    _dimension = dimension;
    _chart.expireCache();
    return _chart;
  };

  /**
   * Set the data callback or retrieve the chart's data set. The data callback is passed the chart's
   * group and by default will return
   * {@link https://github.com/square/crossfilter/wiki/API-Reference#group_all group.all}.
   * This behavior may be modified to, for instance, return only the top 5 groups.
   * @name data
   * @memberof dc.baseMixin
   * @instance
   * @example
   * // Default data function
   * chart.data(function (group) { return group.all(); });
   *
   * chart.data(function (group) { return group.top(5); });
   * @param {Function} [callback]
   * @return {*}
   * @return {dc.baseMixin}
   */
  _chart.data = function (callback) {
    if (!arguments.length) {
      return _data.call(_chart, _group);
    }
    _data = _d2.default.functor(callback);
    _chart.expireCache();
    return _chart;
  };

  /**
   * **mandatory**
   *
   * Set or get the group attribute of a chart. In `dc` a group is a
   * {@link https://github.com/square/crossfilter/wiki/API-Reference#group-map-reduce crossfilter group}.
   * Usually the group should be created from the particular dimension associated with the same chart. If a value is
   * given, then it will be used as the new group.
   *
   * If no value specified then the current group will be returned.
   * If `name` is specified then it will be used to generate legend label.
   * @name group
   * @memberof dc.baseMixin
   * @instance
   * @see {@link https://github.com/square/crossfilter/wiki/API-Reference#group-map-reduce crossfilter.group}
   * @example
   * var index = crossfilter([]);
   * var dimension = index.dimension(dc.pluck('key'));
   * chart.dimension(dimension);
   * chart.group(dimension.group(crossfilter.reduceSum()));
   * @param {crossfilter.group} [group]
   * @param {String} [name]
   * @return {crossfilter.group}
   * @return {dc.baseMixin}
   */
  _chart.group = function (group, name) {
    if (!arguments.length) {
      return _group;
    }
    _group = group;
    _chart._groupName = name;
    _chart.expireCache();
    return _chart;
  };

  /**
   * Wrapper for binParams in Crossfilter.
   */
  _chart.binParams = function (binParams) {
    if (!arguments.length) {
      return _chart.group().binParams();
    }

    return (0, _binningHelpers.createBinParams)(_chart, binParams);
  };

  /**
   * Get or set an accessor to order ordinal dimensions.  This uses
   * {@link https://github.com/square/crossfilter/wiki/API-Reference#quicksort_by crossfilter.quicksort.by} as the
   * sort.
   * @name ordering
   * @memberof dc.baseMixin
   * @instance
   * @see {@link https://github.com/square/crossfilter/wiki/API-Reference#quicksort_by crossfilter.quicksort.by}
   * @example
   * // Default ordering accessor
   * _chart.ordering(dc.pluck('key'));
   * @param {Function} [orderFunction]
   * @return {Function}
   * @return {dc.baseMixin}
   */

  _chart.ordering = function (orderFunction) {
    if (!arguments.length) {
      return _ordering;
    }
    _ordering = orderFunction;
    _orderSort = crossfilter.quicksort.by(_ordering);
    _chart.expireCache();
    return _chart;
  };

  _chart._computeOrderedGroups = function (data) {
    var dataCopy = data.slice(0);

    /* OVERRIDE ---------------------------------------------------------------- */
    // if (dataCopy.length <= 1) {
    //     return dataCopy;
    // }
    //
    // if (!_orderSort) {
    //     _orderSort = crossfilter.quicksort.by(_ordering);
    // }
    //
    // return _orderSort(dataCopy, 0, dataCopy.length);
    /* ------------------------------------------------------------------------- */
    return dataCopy;
  };

  /**
   * Execute d3 single selection in the chart's scope using the given selector and return the d3
   * selection.
   *
   * This function is **not chainable** since it does not return a chart instance; however the d3
   * selection result can be chained to d3 function calls.
   * @name select
   * @memberof dc.baseMixin
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/Selections d3.selection}
   * @example
   * // Similar to:
   * d3.select('#chart-id').select(selector);
   * @return {d3.selection}
   */
  _chart.select = function (s) {
    return _root.select(s);
  };

  /**
   * Execute in scope d3 selectAll using the given selector and return d3 selection result.
   *
   * This function is **not chainable** since it does not return a chart instance; however the d3
   * selection result can be chained to d3 function calls.
   * @name selectAll
   * @memberof dc.baseMixin
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/Selections d3.selection}
   * @example
   * // Similar to:
   * d3.select('#chart-id').selectAll(selector);
   * @return {d3.selection}
   */
  _chart.selectAll = function (s) {
    return _root ? _root.selectAll(s) : null;
  };

  /**
   * Set the root SVGElement to either be an existing chart's root; or any valid [d3 single
   * selector](https://github.com/mbostock/d3/wiki/Selections#selecting-elements) specifying a dom
   * block element such as a div; or a dom element or d3 selection. Optionally registers the chart
   * within the chartGroup. This class is called internally on chart initialization, but be called
   * again to relocate the chart. However, it will orphan any previously created SVGElements.
   * @name anchor
   * @memberof dc.baseMixin
   * @instance
   * @param {anchorChart|anchorSelector|anchorNode} [parent]
   * @param {String} [chartGroup]
   * @return {String|node|d3.selection}
   * @return {dc.baseMixin}
   */
  _chart.anchor = function (parent, chartGroup) {
    if (!arguments.length) {
      return _anchor;
    }
    if ((0, _core.instanceOfChart)(parent)) {
      _anchor = parent.anchor();
      _root = parent.root();
      _isChild = true;
    } else if (parent) {
      if (parent.select && parent.classed) {
        // detect d3 selection
        _anchor = parent.node();
      } else {
        _anchor = parent;
      }
      _root = _d2.default.select(_anchor);
      _root.classed(_core.constants.CHART_CLASS, true);
      (0, _core.deregisterChart)(_chart, chartGroup);
      (0, _core.registerChart)(_chart, chartGroup);
      _isChild = false;
    } else {
      throw new errors.BadArgumentException("parent must be defined");
    }
    _chartGroup = chartGroup;
    return _chart;
  };

  /**
   * Returns the DOM id for the chart's anchored location.
   * @name anchorName
   * @memberof dc.baseMixin
   * @instance
   * @return {String}
   */
  _chart.anchorName = function () {
    var a = _chart.anchor();
    if (a && a.id) {
      return a.id;
    }
    if (a && a.replace) {
      return a.replace("#", "");
    }
    return "dc-chart" + _chart.chartID();
  };

  /**
   * Returns the root element where a chart resides. Usually it will be the parent div element where
   * the SVGElement was created. You can also pass in a new root element however this is usually handled by
   * dc internally. Resetting the root element on a chart outside of dc internals may have
   * unexpected consequences.
   * @name root
   * @memberof dc.baseMixin
   * @instance
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement HTMLElement}
   * @param {HTMLElement} [rootElement]
   * @return {HTMLElement}
   * @return {dc.baseMixin}
   */
  _chart.root = function (rootElement) {
    if (!arguments.length) {
      return _root;
    }
    _root = rootElement;
    return _chart;
  };

  /**
   * Returns the top SVGElement for this specific chart. You can also pass in a new SVGElement,
   * however this is usually handled by dc internally. Resetting the SVGElement on a chart outside
   * of dc internals may have unexpected consequences.
   * @name svg
   * @memberof dc.baseMixin
   * @instance
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/SVGElement SVGElement}
   * @param {SVGElement|d3.selection} [svgElement]
   * @return {SVGElement|d3.selection}
   * @return {dc.baseMixin}
   */
  _chart.svg = function (svgElement) {
    if (!arguments.length) {
      return _svg;
    }
    _svg = svgElement;
    return _chart;
  };

  /**
   * Remove the chart's SVGElements from the dom and recreate the container SVGElement.
   * @name resetSvg
   * @memberof dc.baseMixin
   * @instance
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/SVGElement SVGElement}
   * @return {SVGElement}
   */
  _chart.resetSvg = function () {
    /* OVERRIDE ---------------------------------------------------------------- */
    _chart.root().html("");
    /* ------------------------------------------------------------------------- */

    return _chart.generateSvg();
  };

  function sizeSvg() {
    if (_svg) {
      _svg.attr("width", _chart.width()).attr("height", _chart.height());
    }
  }

  _chart.generateSvg = function () {
    /* OVERRIDE ---------------------------------------------------------------- */
    _svg = _chart.root().append("div").attr("class", "svg-wrapper").append("svg");
    /* ------------------------------------------------------------------------- */

    sizeSvg();
    return _svg;
  };

  /* OVERRIDE ---------------------------------------------------------------- */
  function sizeRoot() {
    if (_root) {
      _root.style("height", _chart.height() + "px").style("width", _chart.width() + "px");
    }
  }

  _chart.popup = function (popupElement) {
    if (!arguments.length) {
      return _popup;
    }
    _popup = popupElement;
    return _chart;
  };

  _chart.enablePopup = function (popupIsEnabled) {
    _popupIsEnabled = popupIsEnabled;
    return _chart;
  };

  _chart.popupIsEnabled = function () {
    return _popupIsEnabled;
  };

  _chart.generatePopup = function () {
    _chart.select(".chart-popup").remove();

    _popup = _chart.root().append("div").attr("class", "chart-popup");

    _popup.append("div").attr("class", "chart-popup-box").append("div").attr("class", "chart-popup-content");

    return _popup;
  };

  _chart.popupCoordinates = function (coords) {
    var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") > -1;

    if (!isFirefox || _d2.default.selectAll(".react-grid-item.cssTransforms").empty() || !_d2.default.selectAll(".react-grid-layout.chart-edit-mode").empty()) {
      return coords;
    }

    var rootRect = _chart.root().node().getBoundingClientRect();
    var gridTop = _d2.default.select(".react-grid-layout").node().getBoundingClientRect().top;

    return [coords[0] - rootRect.x, coords[1] - Math.abs(gridTop - rootRect.y) + 40];
  };

  _chart.isTargeting = function (isTargeting) {
    if (!arguments.length) {
      return _isTargeting;
    }
    _isTargeting = isTargeting;
    return _chart;
  };

  _chart.colorByExpr = function (colorByExpr) {
    if (!arguments.length) {
      return _colorByExpr;
    }
    _colorByExpr = colorByExpr;
    return _chart;
  };
  /* ------------------------------------------------------------------------- */

  /**
   * Set or get the filter printer function. The filter printer function is used to generate human
   * friendly text for filter value(s) associated with the chart instance. By default dc charts use a
   * default filter printer `printers.filter` that provides simple printing support for both
   * single value and ranged filters.
   * @name filterPrinter
   * @memberof dc.baseMixin
   * @instance
   * @param {Function} [filterPrinterFunction=printers.filter]
   * @return {Function}
   * @return {dc.baseMixin}
   */
  _chart.filterPrinter = function (filterPrinterFunction) {
    if (!arguments.length) {
      return _filterPrinter;
    }
    _filterPrinter = filterPrinterFunction;
    return _chart;
  };

  /**
   * If set, use the `visibility` attribute instead of the `display` attribute for showing/hiding
   * chart reset and filter controls, for less disruption to the layout.
   * @name controlsUseVisibility
   * @memberof dc.baseMixin
   * @instance
   * @param {Boolean} [controlsUseVisibility=false]
   * @return {Boolean}
   * @return {dc.baseMixin}
   **/
  _chart.controlsUseVisibility = function (_) {
    if (!arguments.length) {
      return _controlsUseVisibility;
    }
    _controlsUseVisibility = _;
    return _chart;
  };

  /**
   * Turn on optional control elements within the root element. dc currently supports the
   * following html control elements.
   * * root.selectAll('.reset') - elements are turned on if the chart has an active filter. This type
   * of control element is usually used to store a reset link to allow user to reset filter on a
   * certain chart. This element will be turned off automatically if the filter is cleared.
   * * root.selectAll('.filter') elements are turned on if the chart has an active filter. The text
   * content of this element is then replaced with the current filter value using the filter printer
   * function. This type of element will be turned off automatically if the filter is cleared.
   * @name turnOnControls
   * @memberof dc.baseMixin
   * @instance
   * @return {dc.baseMixin}
   */
  _chart.turnOnControls = function () {
    if (_root) {
      var attribute = _chart.controlsUseVisibility() ? "visibility" : "display";
      _chart.selectAll(".reset").style(attribute, null);
      _chart.selectAll(".filter").text(_filterPrinter(_chart.filters())).style(attribute, null);
    }
    return _chart;
  };

  /**
   * Turn off optional control elements within the root element.
   * @name turnOffControls
   * @memberof dc.baseMixin
   * @see {@link #dc.baseMixin+turnOnControls turnOnControls}
   * @instance
   * @return {dc.baseMixin}
   */
  _chart.turnOffControls = function () {
    if (_root) {
      var attribute = _chart.controlsUseVisibility() ? "visibility" : "display";
      var value = _chart.controlsUseVisibility() ? "hidden" : "none";
      _chart.selectAll(".reset").style(attribute, value);
      _chart.selectAll(".filter").style(attribute, value).text(_chart.filter());
    }
    return _chart;
  };

  /**
   * Set or get the animation transition duration (in milliseconds) for this chart instance.
   * @name transitionDuration
   * @memberof dc.baseMixin
   * @instance
   * @param {Number} [duration=750]
   * @return {Number}
   * @return {dc.baseMixin}
   */
  _chart.transitionDuration = function (duration) {
    if (!arguments.length) {
      /* OVERRIDE ---------------------------------------------------------------- */
      return (0, _core.globalTransitionDuration)() != null ? (0, _core.globalTransitionDuration)() : _transitionDuration;
      /* ------------------------------------------------------------------------- */
    }
    _transitionDuration = duration;
    return _chart;
  };

  _chart._mandatoryAttributes = function (_) {
    if (!arguments.length) {
      return _mandatoryAttributes;
    }
    _mandatoryAttributes = _;
    return _chart;
  };

  function checkForMandatoryAttributes(a) {
    if (!_chart[a] || !_chart[a]()) {
      throw new errors.InvalidStateException("Mandatory attribute chart." + a + " is missing on chart[#" + _chart.anchorName() + "]");
    }
  }

  function maybeUpdateColorDomain(data) {
    var isFEQuantitativeColored = Array.isArray(data) && _chart.colorDomain && _legend && _legend.legendType() === "quantitative";

    if (isFEQuantitativeColored) {
      var isLegendLocked = _legend.isLocked && _legend.isLocked();

      if (!isLegendLocked) {
        var newColorDomain = _d2.default.extent(data, _chart.colorAccessor());
        _chart.colorDomain(newColorDomain);
      }
    }
  }

  /**
   * Invoking this method will force the chart to re-render everything from scratch. Generally it
   * should only be used to render the chart for the first time on the page or if you want to make
   * sure everything is redrawn from scratch instead of relying on the default incremental redrawing
   * behaviour.
   * @name render
   * @memberof dc.baseMixin
   * @instance
   * @param {Number} [id]
   * @param {Number} [queryGroupId]
   * @param {Number} [queryCount]
   * @param {Function} [callback]
   * @param {Any} [data]
   * @return {dc.baseMixin}
   */
  _chart.render = function (id, queryGroupId, queryCount, data, callback) {
    if ((0, _core.refreshDisabled)()) {
      return;
    }
    _chart.dataCache = typeof data !== "undefined" && data !== null ? data : null;

    sizeRoot();

    _listeners.preRender(_chart, data);

    if (_mandatoryAttributes) {
      _mandatoryAttributes.forEach(checkForMandatoryAttributes);
    }

    maybeUpdateColorDomain(data);

    var result = _chart._doRender(data);

    if (_legend && _chart.colorDomain) {
      _legend.render();
    }

    _chart.generatePopup();

    _chart._activateRenderlets("postRender", data);

    if (typeof queryGroupId !== "undefined" && queryGroupId !== null) {
      if ((0, _coreAsync.isEqualToRenderCount)(queryCount)) {
        if ((0, _core.logging)()) {
          var endTime = new Date();
          var elapsed = endTime - dc._startRenderTime;
          console.log("Render elapsed: " + elapsed + " ms");
        }

        (0, _core.globalTransitionDuration)(null);
        (0, _coreAsync.resetRenderStack)();

        if ((0, _coreAsync.renderStackEmpty)(null)) {
          return (0, _coreAsync.renderAllAsync)(null).then(function (result) {
            callback(null, result);
          }).catch(function (error) {
            callback(error);
          });
        }
      }
    }

    callback && callback(null, result || _chart);
    return result;
  };

  _chart._activateRenderlets = function (event, data) {
    _listeners.pretransition(_chart, data);
    if (_chart.transitionDuration() > 0 && _svg) {
      _svg.transition().duration(_chart.transitionDuration()).each("end", function () {
        _listeners.renderlet(_chart, data);
        if (event) {
          _listeners[event](_chart, data);
        }
      });
    } else {
      _listeners.renderlet(_chart, data);
      if (event) {
        _listeners[event](_chart, data);
      }
    }
  };

  /**
   * Calling redraw will cause the chart to re-render data changes incrementally. If there is no
   * change in the underlying data dimension then calling this method will have no effect on the
   * chart. Most chart interaction in dc will automatically trigger this method through internal
   * events (in particular {@link #dc.redrawAll dc.redrawAll}; therefore, you only need to
   * manually invoke this function if data is manipulated outside of dc's control (for example if
   * data is loaded in the background using
   * {@link https://github.com/square/crossfilter/wiki/API-Reference#crossfilter_add crossfilter.add}.
   * @name redraw
   * @memberof dc.baseMixin
   * @instance
   * @param {Number} [id]
   * @param {Number} [queryGroupId]
   * @param {Number} [queryCount]
   * @param {Function} [callback]
   * @param {Any} [data]
   * @return {dc.baseMixin}
   */
  _chart.redraw = function (id, queryGroupId, queryCount, data, callback) {
    if ((0, _core.refreshDisabled)()) {
      return;
    }
    _chart.dataCache = typeof data !== "undefined" && data !== null ? data : null;

    sizeSvg();

    _listeners.preRedraw(_chart, data);

    maybeUpdateColorDomain(data);

    var result = _chart._doRedraw(data);

    if (_legend && _chart.colorDomain) {
      _legend.render();
    }

    _chart._activateRenderlets("postRedraw", data);
    if (typeof queryGroupId !== "undefined" && queryGroupId !== null) {
      if ((0, _coreAsync.isEqualToRedrawCount)(queryCount)) {
        if ((0, _core.logging)()) {
          var endTime = new Date();
          var elapsed = endTime - dc._startRedrawTime;
          console.log("Redraw elapsed: " + elapsed + " ms");
        }

        (0, _core.globalTransitionDuration)(null); // reset to null if was brush
        (0, _coreAsync.resetRedrawStack)();

        var group = _chart.chartGroup();
        if ((0, _coreAsync.redrawStackEmpty)(group)) {
          return (0, _coreAsync.redrawAllAsync)(group).then(function (result) {
            callback(null, result);
          }).catch(function (error) {
            callback(error);
          });
        }
      }
    }

    callback && callback(null, result || _chart);
    return result;
  };

  /**
   * Gets/sets the commit handler. If the chart has a commit handler, the handler will be called when
   * the chart's filters have changed, in order to send the filter data asynchronously to a server.
   *
   * Unlike other functions in dc.js, the commit handler is asynchronous. It takes two arguments:
   * a flag indicating whether this is a render (true) or a redraw (false), and a callback to be
   * triggered once the commit is filtered. The callback has the standard node.js continuation signature
   * with error first and result second.
   * @name commitHandler
   * @memberof dc.baseMixin
   * @instance
   * @return {dc.baseMixin}
   */
  _chart.commitHandler = function (commitHandler) {
    if (!arguments.length) {
      return _commitHandler;
    }
    _commitHandler = commitHandler;
    return _chart;
  };

  /**
   * Redraws all charts in the same group as this chart, typically in reaction to a filter
   * change. If the chart has a {@link dc.baseMixin.commitFilter commitHandler}, it will
   * be executed and waited for.
   * @name redrawGroup
   * @memberof dc.baseMixin
   * @instance
   * @return {dc.baseMixin}
   */
  _chart.redrawGroup = function (callback) {
    if (_commitHandler) {
      _commitHandler(false, function (error, result) {
        if (error) {
          console.log(error);
          callback && callback(error);
        } else {
          dc.redrawAll(_chart.chartGroup(), callback);
        }
      });
    } else {
      dc.redrawAll(_chart.chartGroup(), callback);
    }
    return _chart;
  };

  /**
   * Renders all charts in the same group as this chart. If the chart has a
   * {@link dc.baseMixin.commitFilter commitHandler}, it will be executed and waited for
   * @name renderGroup
   * @memberof dc.baseMixin
   * @instance
   * @return {dc.baseMixin}
   */
  _chart.renderGroup = function (callback) {
    if (_commitHandler) {
      _commitHandler(false, function (error, result) {
        if (error) {
          console.log(error);
          callback && callback(error);
        } else {
          dc.renderAll(_chart.chartGroup(), callback);
        }
      });
    } else {
      dc.renderAll(_chart.chartGroup(), callback);
    }
    return _chart;
  };

  _chart._invokeFilteredListener = function (f, i) {
    if (f !== undefined) {
      _listeners.filtered(_chart, f, i);
    }
  };

  _chart._invokeZoomedListener = function () {
    _listeners.zoomed(_chart);
  };

  /**
   * listener used for immerse to decide if bbox from originating raster chart can be applied to others
   * if the other raster charts have linked-zoom enabled
   * @private
   */
  _chart._invokeBboxFilteredListener = function () {
    return _listeners.bboxFiltered(_chart);
  };

  var _hasFilterHandler = function _hasFilterHandler(filters, filter) {
    if (typeof filter === "undefined") {
      return filters.length > 0;
    }

    return filters.some(function (f) {
      return filter <= f && filter >= f;
    });
  };

  /**
   * Set or get the has filter handler. The has filter handler is a function that checks to see if
   * the chart's current filters include a specific filter.  Using a custom has filter handler allows
   * you to change the way filters are checked for and replaced.
   * @name hasFilterHandler
   * @memberof dc.baseMixin
   * @instance
   * @example
   * // default has filter handler
   * chart.hasFilterHandler(function (filters, filter) {
   *     if (filter === null || typeof(filter) === 'undefined') {
   *         return filters.length > 0;
   *     }
   *     return filters.some(function (f) {
   *         return filter <= f && filter >= f;
   *     });
   * });
   *
   * // custom filter handler (no-op)
   * chart.hasFilterHandler(function(filters, filter) {
   *     return false;
   * });
   * @param {Function} [hasFilterHandler]
   * @return {Function}
   * @return {dc.baseMixin}
   */
  _chart.hasFilterHandler = function (hasFilterHandler) {
    if (!arguments.length) {
      return _hasFilterHandler;
    }
    _hasFilterHandler = hasFilterHandler;
    return _chart;
  };

  /**
   * Check whether any active filter or a specific filter is associated with particular chart instance.
   * This function is **not chainable**.
   * @name hasFilter
   * @memberof dc.baseMixin
   * @instance
   * @see {@link #dc.baseMixin+hasFilterHandler hasFilterHandler}
   * @param {*} [filter]
   * @return {Boolean}
   */
  _chart.hasFilter = function (filter) {
    return _hasFilterHandler(_filters, filter);
  };

  var _removeFilterHandler = function _removeFilterHandler(filters, filter) {
    for (var i = 0; i < filters.length; i++) {
      if (_utils.utils.deepEquals(filters[i], filter)) {
        filters.splice(i, 1);
        break;
      }

      if (filters[i] <= filter && filters[i] >= filter) {
        filters.splice(i, 1);
        break;
      }
    }

    return filters;
  };

  /**
   * Set or get the remove filter handler. The remove filter handler is a function that removes a
   * filter from the chart's current filters. Using a custom remove filter handler allows you to
   * change how filters are removed or perform additional work when removing a filter, e.g. when
   * using a filter server other than crossfilter.
   *
   * Any changes should modify the `filters` array argument and return that array.
   * @name removeFilterHandler
   * @memberof dc.baseMixin
   * @instance
   * @example
   * // default remove filter handler
   * chart.removeFilterHandler(function (filters, filter) {
   *     for (var i = 0; i < filters.length; i++) {
   *         if (filters[i] <= filter && filters[i] >= filter) {
   *             filters.splice(i, 1);
   *             break;
   *         }
   *     }
   *     return filters;
   * });
   *
   * // custom filter handler (no-op)
   * chart.removeFilterHandler(function(filters, filter) {
   *     return filters;
   * });
   * @param {Function} [removeFilterHandler]
   * @return {Function}
   * @return {dc.baseMixin}
   */
  _chart.removeFilterHandler = function (removeFilterHandler) {
    if (!arguments.length) {
      return _removeFilterHandler;
    }
    _removeFilterHandler = removeFilterHandler;
    return _chart;
  };

  var _addFilterHandler = function _addFilterHandler(filters, filter) {
    filters.push(filter);
    return filters;
  };

  /**
   * Set or get the add filter handler. The add filter handler is a function that adds a filter to
   * the chart's filter list. Using a custom add filter handler allows you to change the way filters
   * are added or perform additional work when adding a filter, e.g. when using a filter server other
   * than crossfilter.
   *
   * Any changes should modify the `filters` array argument and return that array.
   * @name addFilterHandler
   * @memberof dc.baseMixin
   * @instance
   * @example
   * // default add filter handler
   * chart.addFilterHandler(function (filters, filter) {
   *     filters.push(filter);
   *     return filters;
   * });
   *
   * // custom filter handler (no-op)
   * chart.addFilterHandler(function(filters, filter) {
   *     return filters;
   * });
   * @param {Function} [addFilterHandler]
   * @return {Function}
   * @return {dc.baseMixin}
   */
  _chart.addFilterHandler = function (addFilterHandler) {
    if (!arguments.length) {
      return _addFilterHandler;
    }
    _addFilterHandler = addFilterHandler;
    return _chart;
  };

  var _resetFilterHandler = function _resetFilterHandler(filters) {
    return [];
  };

  /**
   * Set or get the reset filter handler. The reset filter handler is a function that resets the
   * chart's filter list by returning a new list. Using a custom reset filter handler allows you to
   * change the way filters are reset, or perform additional work when resetting the filters,
   * e.g. when using a filter server other than crossfilter.
   *
   * This function should return an array.
   * @name resetFilterHandler
   * @memberof dc.baseMixin
   * @instance
   * @example
   * // default remove filter handler
   * function (filters) {
   *     return [];
   * }
   *
   * // custom filter handler (no-op)
   * chart.resetFilterHandler(function(filters) {
   *     return filters;
   * });
   * @param {Function} [resetFilterHandler]
   * @return {dc.baseMixin}
   */
  _chart.resetFilterHandler = function (resetFilterHandler) {
    if (!arguments.length) {
      return _resetFilterHandler;
    }
    _resetFilterHandler = resetFilterHandler;
    return _chart;
  };

  function applyFilters() {
    if (_chart.dimension() && _chart.dimension().filter) {
      var fs = _filterHandler(_chart.dimension(), _filters);
      _filters = fs ? fs : _filters;
    }
  }

  _chart.replaceFilter = function (_) {
    _filters = [];
    _chart.filter(_);
  };

  /**
   * Filter the chart by the given value or return the current filter if the input parameter is missing.
   * If the passed filter is not currently in the chart's filters, it is added to the filters by the
   * {@link #dc.baseMixin+addFilterHandler addFilterHandler}.  If a filter exists already within the chart's
   * filters, it will be removed by the {@link #dc.baseMixin+removeFilterHandler removeFilterHandler}.  If
   * a `null` value was passed at the filter, this denotes that the filters should be reset, and is performed
   * by the {@link #dc.baseMixin+resetFilterHandler resetFilterHandler}.
   *
   * Once the filters array has been updated, the filters are applied to the crossfilter.dimension, using the
   * {@link #dc.baseMixin+filterHandler filterHandler}.
   * @name filter
   * @memberof dc.baseMixin
   * @instance
   * @see {@link #dc.baseMixin+addFilterHandler addFilterHandler}
   * @see {@link #dc.baseMixin+removeFilterHandler removeFilterHandler}
   * @see {@link #dc.baseMixin+resetFilterHandler resetFilterHandler}
   * @see {@link #dc.baseMixin+filterHandler filterHandler}
   * @example
   * // filter by a single string
   * chart.filter('Sunday');
   * // filter by a single age
   * chart.filter(18);
   * @param {*} [filter]
   * @return {dc.baseMixin}
   */
  _chart.filter = function (filter, isFilterInverse) {
    if (!arguments.length) {
      return _filters.length > 0 ? _filters[0] : null;
    }
    isFilterInverse = typeof isFilterInverse === "undefined" ? false : isFilterInverse;
    if (isFilterInverse !== _chart.filtersInverse()) {
      _filters = _resetFilterHandler(_filters);
      _chart.filtersInverse(isFilterInverse);
    }
    if (filter instanceof Array && filter[0] instanceof Array && !filter.isFiltered) {
      filter[0].forEach(function (d) {
        if (_chart.hasFilter(d)) {
          _removeFilterHandler(_filters, d);
        } else {
          _addFilterHandler(_filters, d);
        }
      });
    } else if (filter === Symbol.for("clear")) {
      filters = _resetFilterHandler(_filters);
    } else if (_chart.hasFilter(filter)) {
      _removeFilterHandler(_filters, filter);
    } else {
      _addFilterHandler(_filters, filter);
    }
    applyFilters();
    _chart._invokeFilteredListener(filter, isFilterInverse);

    if (_root !== null && _chart.hasFilter()) {
      _chart.turnOnControls();
    } else {
      _chart.turnOffControls();
    }

    return _chart;
  };

  /**
   * Returns all current filters. This method does not perform defensive cloning of the internal
   * filter array before returning, therefore any modification of the returned array will effect the
   * chart's internal filter storage.
   * @name filters
   * @memberof dc.baseMixin
   * @instance
   * @return {Array<*>}
   */
  _chart.filters = function () {
    return _filters;
  };

  /* OVERRIDE ---------------------------------------------------------------- */
  _chart.accentSelected = function (e) {
    _d2.default.select(e).classed(_core.constants.ACCENT_CLASS, true);
  };

  _chart.unAccentSelected = function (e) {
    _d2.default.select(e).classed(_core.constants.ACCENT_CLASS, false);
  };
  /* ------------------------------------------------------------------------- */

  _chart.highlightSelected = function (e) {
    _d2.default.select(e).classed(_core.constants.SELECTED_CLASS, true);
    _d2.default.select(e).classed(_core.constants.DESELECTED_CLASS, false);
  };

  _chart.fadeDeselected = function (e) {
    _d2.default.select(e).classed(_core.constants.SELECTED_CLASS, false);
    _d2.default.select(e).classed(_core.constants.DESELECTED_CLASS, true);
  };

  _chart.resetHighlight = function (e) {
    _d2.default.select(e).classed(_core.constants.SELECTED_CLASS, false);
    _d2.default.select(e).classed(_core.constants.DESELECTED_CLASS, false);
  };

  /**
   * This function is passed to d3 as the onClick handler for each chart. The default behavior is to
   * filter on the clicked datum (passed to the callback) and redraw the chart group.
   * @name onClick
   * @memberof dc.baseMixin
   * @instance
   * @param {*} datum
   */
  _chart.onClick = function (datum) {
    // filtering on dimension will have key, but for filtering on measures which is on column doesn't. Thus, the filter is the column value only
    var values = _chart.keyAccessor()(datum);
    var filter = null;
    if (Array.isArray(values) && values.length || !Array.isArray(values) && values !== undefined) {
      filter = values;
    } else {
      filter = datum;
    }
    _chart.handleFilterClick(_d2.default.event, filter);
  };

  /**
   * Set or get the filter handler. The filter handler is a function that performs the filter action
   * on a specific dimension. Using a custom filter handler allows you to perform additional logic
   * before or after filtering.
   * @name filterHandler
   * @memberof dc.baseMixin
   * @instance
   * @see {@link https://github.com/square/crossfilter/wiki/API-Reference#dimension_filter crossfilter.dimension.filter}
   * @example
   * // default filter handler
   * chart.filterHandler(function (dimension, filters) {
   *     dimension.filter(Symbol.for("clear"));
   *     if (filters.length === 0) {
   *         dimension.filter(Symbol.for("clear"));
   *     } else {
   *         dimension.filterFunction(function (d) {
   *             for (var i = 0; i < filters.length; i++) {
   *                 var filter = filters[i];
   *                 if (filter.isFiltered && filter.isFiltered(d)) {
   *                     return true;
   *                 } else if (filter <= d && filter >= d) {
   *                     return true;
   *                 }
   *             }
   *             return false;
   *         });
   *     }
   *     return filters;
   * });
   *
   * // custom filter handler
   * chart.filterHandler(function(dimension, filter){
   *     var newFilter = filter + 10;
   *     dimension.filter(newFilter);
   *     return newFilter; // set the actual filter value to the new value
   * });
   * @param {Function} [filterHandler]
   * @return {Function}
   * @return {dc.baseMixin}
   */
  _chart.filterHandler = function (filterHandler) {
    if (!arguments.length) {
      return _filterHandler;
    }
    _filterHandler = filterHandler;
    return _chart;
  };

  // abstract function stub
  _chart._doRender = function () {
    // do nothing in base, should be overridden by sub-function
    return _chart;
  };

  _chart._doRedraw = function () {
    // do nothing in base, should be overridden by sub-function
    return _chart;
  };

  _chart.legendables = function () {
    // do nothing in base, should be overridden by sub-function
    return [];
  };

  /* OVERRIDE -----------------------------------------------------------------*/

  _chart.legendLock = function (_) {
    if (!arguments.length) {
      return _legendLock;
    }
    _legendLock = _;
    return _chart;
  };

  _chart.legendUnlock = function (_) {
    if (!arguments.length) {
      return _legendUnlock;
    }
    _legendUnlock = _;
    return _chart;
  };

  _chart.legendInputChange = function (_) {
    if (!arguments.length) {
      return _legendInputChange;
    }
    _legendInputChange = _;
    return _chart;
  };

  /* ------------------------------------------------------------------------- */

  _chart.legendHighlight = function () {
    // do nothing in base, should be overridden by sub-function
  };

  _chart.legendReset = function () {
    // do nothing in base, should be overridden by sub-function
  };

  _chart.legendToggle = function () {
    // do nothing in base, should be overriden by sub-function
  };

  _chart.isLegendableHidden = function () {
    // do nothing in base, should be overridden by sub-function
    return false;
  };

  /**
   * Set or get the key accessor function. The key accessor function is used to retrieve the key
   * value from the crossfilter group. Key values are used differently in different charts, for
   * example keys correspond to slices in a pie chart and x axis positions in a grid coordinate chart.
   * @name keyAccessor
   * @memberof dc.baseMixin
   * @instance
   * @example
   * // default key accessor
   * chart.keyAccessor(function(d) { return d.key; });
   * // custom key accessor for a multi-value crossfilter reduction
   * chart.keyAccessor(function(p) { return p.value.absGain; });
   * @param {Function} [keyAccessor]
   * @return {Function}
   * @return {dc.baseMixin}
   */
  _chart.keyAccessor = function (keyAccessor) {
    if (!arguments.length) {
      return _keyAccessor;
    }
    _keyAccessor = keyAccessor;
    return _chart;
  };

  /**
   * Set or get the value accessor function. The value accessor function is used to retrieve the
   * value from the crossfilter group. Group values are used differently in different charts, for
   * example values correspond to slice sizes in a pie chart and y axis positions in a grid
   * coordinate chart.
   * @name valueAccessor
   * @memberof dc.baseMixin
   * @instance
   * @example
   * // default value accessor
   * chart.valueAccessor(function(d) { return d.value; });
   * // custom value accessor for a multi-value crossfilter reduction
   * chart.valueAccessor(function(p) { return p.value.percentageGain; });
   * @param {Function} [valueAccessor]
   * @return {Function}
   * @return {dc.baseMixin}
   */
  _chart.valueAccessor = function (valueAccessor) {
    if (!arguments.length) {
      return _valueAccessor;
    }
    _valueAccessor = valueAccessor;
    return _chart;
  };

  /**
   * Set or get the label function. The chart class will use this function to render labels for each
   * child element in the chart, e.g. slices in a pie chart or bubbles in a bubble chart. Not every
   * chart supports the label function, for example line chart does not use this function
   * at all. By default, enables labels; pass false for the second parameter if this is not desired.
   * @name label
   * @memberof dc.baseMixin
   * @instance
   * @example
   * // default label function just return the key
   * chart.label(function(d) { return d.key; });
   * // label function has access to the standard d3 data binding and can get quite complicated
   * chart.label(function(d) { return d.data.key + '(' + Math.floor(d.data.value / all.value() * 100) + '%)'; });
   * @param {Function} [labelFunction]
   * @param {Boolean} [enableLabels=true]
   * @return {Function}
   * @return {dc.baseMixin}
   */
  _chart.label = function (labelFunction, enableLabels) {
    if (!arguments.length) {
      return _label;
    }
    _label = labelFunction;
    if (enableLabels === undefined || enableLabels) {
      _renderLabel = true;
    }
    return _chart;
  };

  /**
   * Turn on/off label rendering
   * @name renderLabel
   * @memberof dc.baseMixin
   * @instance
   * @param {Boolean} [renderLabel=false]
   * @return {Boolean}
   * @return {dc.baseMixin}
   */
  _chart.renderLabel = function (renderLabel) {
    if (!arguments.length) {
      return _renderLabel;
    }
    _renderLabel = renderLabel;
    return _chart;
  };

  /**
   * Set or get the title function. The chart class will use this function to render the SVGElement title
   * (usually interpreted by browser as tooltips) for each child element in the chart, e.g. a slice
   * in a pie chart or a bubble in a bubble chart. Almost every chart supports the title function;
   * however in grid coordinate charts you need to turn off the brush in order to see titles, because
   * otherwise the brush layer will block tooltip triggering.
   * @name title
   * @memberof dc.baseMixin
   * @instance
   * @example
   * // default title function just return the key
   * chart.title(function(d) { return d.key + ': ' + d.value; });
   * // title function has access to the standard d3 data binding and can get quite complicated
   * chart.title(function(p) {
   *    return p.key.getFullYear()
   *        + '\n'
   *        + 'Index Gain: ' + numberFormat(p.value.absGain) + '\n'
   *        + 'Index Gain in Percentage: ' + numberFormat(p.value.percentageGain) + '%\n'
   *        + 'Fluctuation / Index Ratio: ' + numberFormat(p.value.fluctuationPercentage) + '%';
   * });
   * @param {Function} [titleFunction]
   * @return {Function}
   * @return {dc.baseMixin}
   */
  _chart.title = function (titleFunction) {
    if (!arguments.length) {
      return _title;
    }
    _title = titleFunction;
    return _chart;
  };

  /**
   * Turn on/off title rendering, or return the state of the render title flag if no arguments are
   * given.
   * @name renderTitle
   * @memberof dc.baseMixin
   * @instance
   * @param {Boolean} [renderTitle=true]
   * @return {Boolean}
   * @return {dc.baseMixin}
   */
  _chart.renderTitle = function (renderTitle) {
    if (!arguments.length) {
      return _renderTitle;
    }
    _renderTitle = renderTitle;
    return _chart;
  };

  /**
   * A renderlet is similar to an event listener on rendering event. Multiple renderlets can be added
   * to an individual chart.  Each time a chart is rerendered or redrawn the renderlets are invoked
   * right after the chart finishes its transitions, giving you a way to modify the SVGElements.
   * Renderlet functions take the chart instance as the only input parameter and you can
   * use the dc API or use raw d3 to achieve pretty much any effect.
   *
   * Use {@link #dc.baseMixin+on on} with a 'renderlet' prefix.
   * Generates a random key for the renderlet, which makes it hard to remove.
   * @name renderlet
   * @memberof dc.baseMixin
   * @instance
   * @deprecated
   * @example
   * // do this instead of .renderlet(function(chart) { ... })
   * chart.on("renderlet", function(chart){
   *     // mix of dc API and d3 manipulation
   *     chart.select('g.y').style('display', 'none');
   *     // its a closure so you can also access other chart variable available in the closure scope
   *     moveChart.filter(chart.filter());
   * });
   * @param {Function} renderletFunction
   * @return {dc.baseMixin}
   */
  _chart.renderlet = _logger.logger.deprecate(function (renderletFunction) {
    _chart.on("renderlet." + _utils.utils.uniqueId(), renderletFunction);
    return _chart;
  }, 'chart.renderlet has been deprecated.  Please use chart.on("renderlet.<renderletKey>", renderletFunction)');

  /**
   * Get or set the chart group to which this chart belongs. Chart groups are rendered or redrawn
   * together since it is expected they share the same underlying crossfilter data set.
   * @name chartGroup
   * @memberof dc.baseMixin
   * @instance
   * @param {String} [chartGroup]
   * @return {String}
   * @return {dc.baseMixin}
   */
  _chart.chartGroup = function (chartGroup) {
    if (!arguments.length) {
      return _chartGroup;
    }
    if (!_isChild) {
      (0, _core.deregisterChart)(_chart, _chartGroup);
    }
    _chartGroup = chartGroup;
    if (!_isChild) {
      (0, _core.registerChart)(_chart, _chartGroup);
    }
    return _chart;
  };

  /**
   * Expire the internal chart cache. dc charts cache some data internally on a per chart basis to
   * speed up rendering and avoid unnecessary calculation; however it might be useful to clear the
   * cache if you have changed state which will affect rendering.  For example if you invoke the
   * {@link https://github.com/square/crossfilter/wiki/API-Reference#crossfilter_add crossfilter.add}
   * function or reset group or dimension after rendering it is a good idea to
   * clear the cache to make sure charts are rendered properly.
   * @name expireCache
   * @memberof dc.baseMixin
   * @instance
   * @return {dc.baseMixin}
   */
  _chart.expireCache = function () {
    // do nothing in base, should be overridden by sub-function
    return _chart;
  };

  /**
   * MAPDC-extension function
   * Destroy all leftover parts of the chart.
   * @name destroyChart
   * @memberof dc.baseMixin
   * @instance
   * @return {dc.baseMixin}
   */
  _chart.destroyChart = function () {
    // do nothing in base, should be overridden by sub-function
    return _chart;
  };

  /**
   * Attach a dc.legend widget to this chart. The legend widget will automatically draw legend labels
   * based on the color setting and names associated with each group.
   * @name legend
   * @memberof dc.baseMixin
   * @instance
   * @example
   * chart.legend(dc.legend().x(400).y(10).itemHeight(13).gap(5))
   * @param {dc.legend} [legend]
   * @return {dc.legend}
   * @return {dc.baseMixin}
   */
  _chart.legend = function (legend) {
    if (!arguments.length) {
      return _legend;
    }
    _legend = legend;

    if (_legend) {
      _legend.parent(_chart);
    }

    return _chart;
  };

  /* OVERRIDE -----------------------------------------------------------------*/
  _chart.legendContinuous = function (legendContinuous) {
    if (!arguments.length) {
      return _legendContinuous;
    }
    _legendContinuous = legendContinuous;
    _legendContinuous.parent(_chart);
    return _chart;
  };
  /* --------------------------------------------------------------------------*/

  /**
   * Returns the internal numeric ID of the chart.
   * @name chartID
   * @memberof dc.baseMixin
   * @instance
   * @return {String}
   */
  _chart.chartID = function () {
    return _chart.__dcFlag__;
  };

  /**
   * Set chart options using a configuration object. Each key in the object will cause the method of
   * the same name to be called with the value to set that attribute for the chart.
   * @name options
   * @memberof dc.baseMixin
   * @instance
   * @example
   * chart.options({dimension: myDimension, group: myGroup});
   * @param {{}} opts
   * @return {dc.baseMixin}
   */
  _chart.options = function (opts) {
    var applyOptions = ["anchor", "group", "xAxisLabel", "yAxisLabel", "stack", "title", "point", "getColor", "overlayGeoJson"];

    for (var o in opts) {
      if (typeof _chart[o] === "function") {
        if (opts[o] instanceof Array && applyOptions.indexOf(o) !== -1) {
          _chart[o].apply(_chart, opts[o]);
        } else {
          _chart[o].call(_chart, opts[o]);
        }
      } else {
        dc.logger.debug("Not a valid option setter name: " + o);
      }
    }
    return _chart;
  };

  /**
   * All dc chart instance supports the following listeners.
   * Supports the following events:
   * * `renderlet` - This listener function will be invoked after transitions after redraw and render. Replaces the
   * deprecated {@link #dc.baseMixin+renderlet renderlet} method.
   * * `pretransition` - Like `.on('renderlet', ...)` but the event is fired before transitions start.
   * * `preRender` - This listener function will be invoked before chart rendering.
   * * `postRender` - This listener function will be invoked after chart finish rendering including
   * all renderlets' logic.
   * * `preRedraw` - This listener function will be invoked before chart redrawing.
   * * `postRedraw` - This listener function will be invoked after chart finish redrawing
   * including all renderlets' logic.
   * * `filtered` - This listener function will be invoked after a filter is applied, added or removed.
   * * `zoomed` - This listener function will be invoked after a zoom is triggered.
   * @name on
   * @memberof dc.baseMixin
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/Internals#dispatch_on d3.dispatch.on}
   * @example
   * .on('renderlet', function(chart, filter){...})
   * .on('pretransition', function(chart, filter){...})
   * .on('preRender', function(chart){...})
   * .on('postRender', function(chart){...})
   * .on('preRedraw', function(chart){...})
   * .on('postRedraw', function(chart){...})
   * .on('filtered', function(chart, filter){...})
   * .on('zoomed', function(chart, filter){...})
   * @param {String} event
   * @param {Function} listener
   * @return {dc.baseMixin}
   */
  _chart.on = function (event, listener) {
    _listeners.on(event, listener);
    return _chart;
  };

  _chart.debounce = function (func, wait, immediate) {
    var timeout = void 0;

    return function () {
      var context = this,
          args = arguments;
      var later = function later() {
        timeout = null;
        if (!immediate) {
          func.apply(context, args);
        }
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) {
        func.apply(context, args);
      }
    };
  };

  _chart.showNullDimensions = function (showNulls) {
    if (!arguments.length) {
      return !_chart.dimension().getEliminateNull();
    }

    _chart.expireCache();
    _chart.dimension().setEliminateNull(!showNulls);

    return _chart;
  };

  _chart.keyAccessor(_multipleKeyAccessors.multipleKeysAccessorForCap);
  _chart.ordering = function () {};
  _chart.rangeChartEnabled = function () {
    return false;
  };
  _chart.isTime = function () {
    return null;
  };

  _chart.isMulti = function () {
    return false;
  };

  _chart.valueFormatter = function (formatter) {
    if (!arguments.length) {
      return _valueFormatter;
    }
    _valueFormatter = formatter;
    return _chart;
  };

  _chart.dateFormatter = function (formatter) {
    if (!arguments.length) {
      return _dateFormatter;
    }
    _dateFormatter = formatter;
    return _chart;
  };

  _chart.getMeasureName = function () {
    var measure = _chart.group().reduce();
    return measure && measure[0] ? measure[0].measureName : null;
  };

  _chart = (0, _legendMixin2.default)((0, _filterMixin2.default)((0, _labelMixin2.default)((0, _multipleKeyLabelMixin2.default)((0, _spinnerMixin2.default)((0, _asyncMixin2.default)(_chart))))));

  return _chart;
}

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(194);
var isBuffer = __webpack_require__(277);

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Function equal to merge with the difference being that no reference
 * to original objects is kept.
 *
 * @see merge
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function deepMerge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = deepMerge(result[key], val);
    } else if (typeof val === 'object') {
      result[key] = deepMerge({}, val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  deepMerge: deepMerge,
  extend: extend,
  trim: trim
};


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return END_OF_FILE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return DEFAULT_PARSER_CONFIG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return DEFAULT_RULE_CONFIG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return ParserDefinitionErrorType; });
/* harmony export (immutable) */ __webpack_exports__["d"] = EMPTY_ALT;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return Parser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CstParser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return EmbeddedActionsParser; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__grammar_follow__ = __webpack_require__(325);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__scan_tokens_public__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__cst_cst__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__errors_public__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__grammar_gast_gast_resolver_public__ = __webpack_require__(219);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__traits_recoverable__ = __webpack_require__(220);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__traits_looksahead__ = __webpack_require__(328);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__traits_tree_builder__ = __webpack_require__(329);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__traits_lexer_adapter__ = __webpack_require__(331);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__traits_recognizer_api__ = __webpack_require__(332);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__traits_recognizer_engine__ = __webpack_require__(333);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__traits_error_handler__ = __webpack_require__(334);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__traits_context_assist__ = __webpack_require__(335);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__traits_gast_recorder__ = __webpack_require__(336);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__traits_perf_tracer__ = __webpack_require__(337);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
















var END_OF_FILE = Object(__WEBPACK_IMPORTED_MODULE_2__scan_tokens_public__["c" /* createTokenInstance */])(__WEBPACK_IMPORTED_MODULE_2__scan_tokens_public__["a" /* EOF */], "", NaN, NaN, NaN, NaN, NaN, NaN);
Object.freeze(END_OF_FILE);
var DEFAULT_PARSER_CONFIG = Object.freeze({
    recoveryEnabled: false,
    maxLookahead: 4,
    ignoredIssues: {},
    dynamicTokensEnabled: false,
    outputCst: true,
    errorMessageProvider: __WEBPACK_IMPORTED_MODULE_4__errors_public__["c" /* defaultParserErrorProvider */],
    nodeLocationTracking: "none",
    traceInitPerf: false,
    skipValidations: false
});
var DEFAULT_RULE_CONFIG = Object.freeze({
    recoveryValueFunc: function () { return undefined; },
    resyncEnabled: true
});
var ParserDefinitionErrorType;
(function (ParserDefinitionErrorType) {
    ParserDefinitionErrorType[ParserDefinitionErrorType["INVALID_RULE_NAME"] = 0] = "INVALID_RULE_NAME";
    ParserDefinitionErrorType[ParserDefinitionErrorType["DUPLICATE_RULE_NAME"] = 1] = "DUPLICATE_RULE_NAME";
    ParserDefinitionErrorType[ParserDefinitionErrorType["INVALID_RULE_OVERRIDE"] = 2] = "INVALID_RULE_OVERRIDE";
    ParserDefinitionErrorType[ParserDefinitionErrorType["DUPLICATE_PRODUCTIONS"] = 3] = "DUPLICATE_PRODUCTIONS";
    ParserDefinitionErrorType[ParserDefinitionErrorType["UNRESOLVED_SUBRULE_REF"] = 4] = "UNRESOLVED_SUBRULE_REF";
    ParserDefinitionErrorType[ParserDefinitionErrorType["LEFT_RECURSION"] = 5] = "LEFT_RECURSION";
    ParserDefinitionErrorType[ParserDefinitionErrorType["NONE_LAST_EMPTY_ALT"] = 6] = "NONE_LAST_EMPTY_ALT";
    ParserDefinitionErrorType[ParserDefinitionErrorType["AMBIGUOUS_ALTS"] = 7] = "AMBIGUOUS_ALTS";
    ParserDefinitionErrorType[ParserDefinitionErrorType["CONFLICT_TOKENS_RULES_NAMESPACE"] = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE";
    ParserDefinitionErrorType[ParserDefinitionErrorType["INVALID_TOKEN_NAME"] = 9] = "INVALID_TOKEN_NAME";
    ParserDefinitionErrorType[ParserDefinitionErrorType["INVALID_NESTED_RULE_NAME"] = 10] = "INVALID_NESTED_RULE_NAME";
    ParserDefinitionErrorType[ParserDefinitionErrorType["DUPLICATE_NESTED_NAME"] = 11] = "DUPLICATE_NESTED_NAME";
    ParserDefinitionErrorType[ParserDefinitionErrorType["NO_NON_EMPTY_LOOKAHEAD"] = 12] = "NO_NON_EMPTY_LOOKAHEAD";
    ParserDefinitionErrorType[ParserDefinitionErrorType["AMBIGUOUS_PREFIX_ALTS"] = 13] = "AMBIGUOUS_PREFIX_ALTS";
    ParserDefinitionErrorType[ParserDefinitionErrorType["TOO_MANY_ALTS"] = 14] = "TOO_MANY_ALTS";
})(ParserDefinitionErrorType || (ParserDefinitionErrorType = {}));
function EMPTY_ALT(value) {
    if (value === void 0) { value = undefined; }
    return function () {
        return value;
    };
}
var Parser = /** @class */ (function () {
    function Parser(tokenVocabulary, config) {
        if (config === void 0) { config = DEFAULT_PARSER_CONFIG; }
        this.ignoredIssues = DEFAULT_PARSER_CONFIG.ignoredIssues;
        this.definitionErrors = [];
        this.selfAnalysisDone = false;
        var that = this;
        that.initErrorHandler(config);
        that.initLexerAdapter();
        that.initLooksAhead(config);
        that.initRecognizerEngine(tokenVocabulary, config);
        that.initRecoverable(config);
        that.initTreeBuilder(config);
        that.initContentAssist();
        that.initGastRecorder(config);
        that.initPerformanceTracer(config);
        /* istanbul ignore if - complete over-kill to test this, we should only add a test when we actually hard deprecate it and throw an error... */
        if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(config, "ignoredIssues") &&
            config.ignoredIssues !== DEFAULT_PARSER_CONFIG.ignoredIssues) {
            Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["d" /* PRINT_WARNING */])("The <ignoredIssues> IParserConfig property is soft-deprecated and will be removed in future versions.\n\t" +
                "Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.");
        }
        this.ignoredIssues = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(config, "ignoredIssues")
            ? config.ignoredIssues
            : DEFAULT_PARSER_CONFIG.ignoredIssues;
        this.skipValidations = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(config, "skipValidations")
            ? config.skipValidations
            : DEFAULT_PARSER_CONFIG.skipValidations;
    }
    /**
     *  @deprecated use the **instance** method with the same name instead
     */
    Parser.performSelfAnalysis = function (parserInstance) {
        ;
        parserInstance.performSelfAnalysis();
    };
    Parser.prototype.performSelfAnalysis = function () {
        var _this = this;
        this.TRACE_INIT("performSelfAnalysis", function () {
            var defErrorsMsgs;
            _this.selfAnalysisDone = true;
            var className = _this.className;
            _this.TRACE_INIT("toFastProps", function () {
                // Without this voodoo magic the parser would be x3-x4 slower
                // It seems it is better to invoke `toFastProperties` **before**
                // Any manipulations of the `this` object done during the recording phase.
                Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["S" /* toFastProperties */])(_this);
            });
            _this.TRACE_INIT("Grammar Recording", function () {
                try {
                    _this.enableRecording();
                    // Building the GAST
                    Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(_this.definedRulesNames, function (currRuleName) {
                        var wrappedRule = _this[currRuleName];
                        var originalGrammarAction = wrappedRule["originalGrammarAction"];
                        var recordedRuleGast = undefined;
                        _this.TRACE_INIT(currRuleName + " Rule", function () {
                            recordedRuleGast = _this.topLevelRuleRecord(currRuleName, originalGrammarAction);
                        });
                        _this.gastProductionsCache[currRuleName] = recordedRuleGast;
                    });
                }
                finally {
                    _this.disableRecording();
                }
            });
            var resolverErrors = [];
            _this.TRACE_INIT("Grammar Resolving", function () {
                resolverErrors = Object(__WEBPACK_IMPORTED_MODULE_5__grammar_gast_gast_resolver_public__["b" /* resolveGrammar */])({
                    rules: Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["U" /* values */])(_this.gastProductionsCache)
                });
                _this.definitionErrors.push.apply(_this.definitionErrors, resolverErrors); // mutability for the win?
            });
            _this.TRACE_INIT("Grammar Validations", function () {
                // only perform additional grammar validations IFF no resolving errors have occurred.
                // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.
                if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["A" /* isEmpty */])(resolverErrors) && _this.skipValidations === false) {
                    var validationErrors = Object(__WEBPACK_IMPORTED_MODULE_5__grammar_gast_gast_resolver_public__["c" /* validateGrammar */])({
                        rules: Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["U" /* values */])(_this.gastProductionsCache),
                        maxLookahead: _this.maxLookahead,
                        tokenTypes: Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["U" /* values */])(_this.tokensMap),
                        ignoredIssues: _this.ignoredIssues,
                        errMsgProvider: __WEBPACK_IMPORTED_MODULE_4__errors_public__["b" /* defaultGrammarValidatorErrorProvider */],
                        grammarName: className
                    });
                    _this.definitionErrors.push.apply(_this.definitionErrors, validationErrors); // mutability for the win?
                }
            });
            // this analysis may fail if the grammar is not perfectly valid
            if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["A" /* isEmpty */])(_this.definitionErrors)) {
                // The results of these computations are not needed unless error recovery is enabled.
                if (_this.recoveryEnabled) {
                    _this.TRACE_INIT("computeAllProdsFollows", function () {
                        var allFollows = Object(__WEBPACK_IMPORTED_MODULE_1__grammar_follow__["a" /* computeAllProdsFollows */])(Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["U" /* values */])(_this.gastProductionsCache));
                        _this.resyncFollows = allFollows;
                    });
                }
                _this.TRACE_INIT("ComputeLookaheadFunctions", function () {
                    _this.preComputeLookaheadFunctions(Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["U" /* values */])(_this.gastProductionsCache));
                });
            }
            _this.TRACE_INIT("expandAllNestedRuleNames", function () {
                // TODO: is this needed for EmbeddedActionsParser?
                var cstAnalysisResult = Object(__WEBPACK_IMPORTED_MODULE_3__cst_cst__["d" /* expandAllNestedRuleNames */])(Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["U" /* values */])(_this.gastProductionsCache), _this.fullRuleNameToShort);
                _this.allRuleNames = cstAnalysisResult.allRuleNames;
            });
            if (!Parser.DEFER_DEFINITION_ERRORS_HANDLING &&
                !Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["A" /* isEmpty */])(_this.definitionErrors)) {
                defErrorsMsgs = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */])(_this.definitionErrors, function (defError) { return defError.message; });
                throw new Error("Parser Definition Errors detected:\n " + defErrorsMsgs.join("\n-------------------------------\n"));
            }
        });
    };
    // Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.
    // (normally during the parser's constructor).
    // This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,
    // for example: duplicate rule names, referencing an unresolved subrule, ect...
    // This flag should not be enabled during normal usage, it is used in special situations, for example when
    // needing to display the parser definition errors in some GUI(online playground).
    Parser.DEFER_DEFINITION_ERRORS_HANDLING = false;
    return Parser;
}());

Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["e" /* applyMixins */])(Parser, [
    __WEBPACK_IMPORTED_MODULE_6__traits_recoverable__["b" /* Recoverable */],
    __WEBPACK_IMPORTED_MODULE_7__traits_looksahead__["a" /* LooksAhead */],
    __WEBPACK_IMPORTED_MODULE_8__traits_tree_builder__["a" /* TreeBuilder */],
    __WEBPACK_IMPORTED_MODULE_9__traits_lexer_adapter__["a" /* LexerAdapter */],
    __WEBPACK_IMPORTED_MODULE_11__traits_recognizer_engine__["a" /* RecognizerEngine */],
    __WEBPACK_IMPORTED_MODULE_10__traits_recognizer_api__["a" /* RecognizerApi */],
    __WEBPACK_IMPORTED_MODULE_12__traits_error_handler__["a" /* ErrorHandler */],
    __WEBPACK_IMPORTED_MODULE_13__traits_context_assist__["a" /* ContentAssist */],
    __WEBPACK_IMPORTED_MODULE_14__traits_gast_recorder__["a" /* GastRecorder */],
    __WEBPACK_IMPORTED_MODULE_15__traits_perf_tracer__["a" /* PerformanceTracer */]
]);
var CstParser = /** @class */ (function (_super) {
    __extends(CstParser, _super);
    function CstParser(tokenVocabulary, config) {
        if (config === void 0) { config = DEFAULT_PARSER_CONFIG; }
        var _this = this;
        var configClone = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["h" /* cloneObj */])(config);
        configClone.outputCst = true;
        _this = _super.call(this, tokenVocabulary, configClone) || this;
        return _this;
    }
    return CstParser;
}(Parser));

var EmbeddedActionsParser = /** @class */ (function (_super) {
    __extends(EmbeddedActionsParser, _super);
    function EmbeddedActionsParser(tokenVocabulary, config) {
        if (config === void 0) { config = DEFAULT_PARSER_CONFIG; }
        var _this = this;
        var configClone = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["h" /* cloneObj */])(config);
        configClone.outputCst = false;
        _this = _super.call(this, tokenVocabulary, configClone) || this;
        return _this;
    }
    return EmbeddedActionsParser;
}(Parser));

//# sourceMappingURL=parser.js.map

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizeArrayByValue = exports.isArrayOfObjects = exports.hasAllObjects = exports.isPlainObject = exports.genericDateTimeFormat = exports.momentUTCFormat = exports.nullLabelHtml = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.formatDataValue = formatDataValue;
exports.maybeFormatInfinity = maybeFormatInfinity;
exports.formatNumber = formatNumber;
exports.formatPercentage = formatPercentage;
exports.formatArrayValue = formatArrayValue;
exports.formatTimeBinValue = formatTimeBinValue;
exports.formatExtractValue = formatExtractValue;
exports.normalizeFiltersArray = normalizeFiltersArray;
exports.formatCache = formatCache;

var _datesAndTimes = __webpack_require__(29);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _moment = __webpack_require__(0);

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var commafy = _d2.default.format(",");

var nullLabelHtml = exports.nullLabelHtml = '<tspan class="null-value"> NULL </tspan>';
var momentUTCFormat = exports.momentUTCFormat = function momentUTCFormat(d, f) {
  return _moment2.default.utc(d).locale("en").format(f);
};
var genericDateTimeFormat = exports.genericDateTimeFormat = function genericDateTimeFormat(d) {
  if (d.getMilliseconds() === 0) {
    return momentUTCFormat(d, "MMM D, YYYY") + " \u205F" + momentUTCFormat(d, "HH:mm:ss");
  }
  return momentUTCFormat(d, "MMM D, YYYY") + " \u205F" + momentUTCFormat(d, "HH:mm:ss.SSS");
};
var isPlainObject = exports.isPlainObject = function isPlainObject(value) {
  return !Array.isArray(value) && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" && !(value instanceof Date);
};
var hasAllObjects = exports.hasAllObjects = function hasAllObjects(collection) {
  return collection.reduce(function (accum, value) {
    return isPlainObject(value) && accum;
  }, true);
};
var isArrayOfObjects = exports.isArrayOfObjects = function isArrayOfObjects(value) {
  return Array.isArray(value) && hasAllObjects(value);
};
var normalizeArrayByValue = exports.normalizeArrayByValue = function normalizeArrayByValue(collection) {
  return isArrayOfObjects(collection) ? collection.map(function (data) {
    return data.value;
  }) : collection;
};

function formatDataValue(data) {
  if (typeof data === "number") {
    return formatNumber(data);
  } else if (Array.isArray(data)) {
    return formatArrayValue(data);
  } else if (data instanceof Date) {
    return genericDateTimeFormat(data);
  } else if (data === null) {
    return nullLabelHtml;
  }
  return data;
}

function maybeFormatInfinity(data) {
  return data.map(function (d) {
    if (d.val === "-Infinity" || d.val === "Infinity") {
      d.label = d.val;
      d.val = 0;
    }
    return d;
  });
}

function formatNumber(d) {
  if (typeof d !== "number") {
    return d;
  }

  if (d.toString().match(/e/)) {
    return d.toPrecision(2);
  } else {
    return commafy(parseFloat(d.toFixed(2)));
  }
}

var percentify = _d2.default.format(".0%");
var percentifyLow = _d2.default.format(".1%");

function formatPercentage(d, total) {
  var percentage = d / total;
  if (percentage < 0.01) {
    return percentifyLow(percentage);
  } else {
    return percentify(percentage);
  }
}

function formatArrayValue(data) {
  if (_typeof(data[0]) === "object" && !(data[0] instanceof Date)) {
    return data[0].isExtract ? formatExtractValue(data[0].value, data[0].extractUnit) : formatTimeBinValue(data);
  } else {
    return data.map(function (d) {
      return formatDataValue(d);
    }).join(" \u2013 ");
  }
}

function formatTimeBinValue(data) {
  var startTime = data[0];
  var endTime = data[1];
  switch (startTime.timeBin) {
    case "decade":
      return momentUTCFormat(startTime.value, "YYYY") + " \u2013 " + momentUTCFormat(endTime.value, "YYYY");
    case "year":
      return momentUTCFormat(startTime.value, "YYYY");
    case "quarter":
      return _moment2.default.utc(startTime.value).locale("en").quarter() + "Q " + momentUTCFormat(startTime.value, "YYYY");
    case "month":
      return momentUTCFormat(startTime.value, "MMM YYYY");
    case "week":
      return momentUTCFormat(startTime.value, "MMM D") + " \u2013 " + momentUTCFormat(endTime.value, "MMM D, YYYY");
    case "day":
      return momentUTCFormat(startTime.value, "MMM D, YYYY");
    case "hour":
    case "minute":
      return momentUTCFormat(startTime.value, "MMM D, YYYY") + " \u205F" + momentUTCFormat(startTime.value, "HH:mm");
    case "second":
      return "" + momentUTCFormat(startTime.value, "HH:mm:ss");
    case "millisecond":
      return "" + momentUTCFormat(startTime.value, "HH:mm:ss.SSS");
    default:
      return genericDateTimeFormat(startTime.value);
  }
}

function formatExtractValue(number, label) {
  switch (label) {
    case "isodow":
      return _datesAndTimes.DAYS[number - 1];
    case "month":
      return _datesAndTimes.MONTHS[number - 1];
    case "quarter":
      return _datesAndTimes.QUARTERS[number - 1];
    case "hour":
      return _datesAndTimes.HOURS[number];
    case "minute":
      return number + 1;
    default:
      return number;
  }
}

function normalizeFiltersArray(filters) {
  return filters.map(function (f) {
    if (isArrayOfObjects(f)) {
      return normalizeArrayByValue(f);
    } else {
      return f;
    }
  });
}

function formatCache(_axis) {
  var axis = _axis;
  var cachedTickFormat = false;

  function setTickFormat(tickFormat, fromCache) {
    if (tickFormat === false) {
      return null;
    }

    if (!fromCache && cachedTickFormat === false) {
      cachedTickFormat = axis.tickFormat();
    }

    axis.tickFormat(tickFormat);

    if (fromCache) {
      cachedTickFormat = false;
    }
  }

  function setTickFormatFromCache() {
    var FROM_CACHE = true;
    setTickFormat(cachedTickFormat, FROM_CACHE);
  }

  return {
    setTickFormat: setTickFormat,
    setTickFormatFromCache: setTickFormatFromCache
  };
}

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = createParser;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__parse_expression__ = __webpack_require__(226);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse_datastate__ = __webpack_require__(227);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__parse_transform__ = __webpack_require__(228);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__parse_source__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__write_sql__ = __webpack_require__(239);






/**
 * Creates a parser than can parse expressions, transforms, and intermediary
 * SQL representations. This parser is used internally by the data graph.
 * @see {@link Parser} for further information.
 * @memberof API
 */
function createParser() {
  var transformParsers = {};
  var expressionParsers = {};

  /**
   * A collection of functions used for parsing expressions, transforms, and
   * intermediary SQL representations
   * @namespace Parser
   */
  var parser = {
    parseExpression: parseExpression,
    parseTransform: parseTransform,
    parseDataState: parseDataState,
    parseSource: parseSource,
    writeSQL: writeSQL,
    write: __WEBPACK_IMPORTED_MODULE_4__write_sql__["b" /* write */],
    registerParser: registerParser
  };

  /**
   * Returns all child data node instances of the graph.
   * @memberof Parser
   * @inner
   */
  function registerParser(definition, typeParser) {
    if (definition.meta === "expression") {
      expressionParsers[definition.type] = typeParser;
    } else if (definition.meta === "transform") {
      transformParsers[definition.type] = typeParser;
    }
  }

  /**
   * Parses expressions and returns a valid SQL expression string
   * @memberof Parser
   * @inner
   * @see {@link Expression} for further information.
   */
  function parseExpression(expression) {
    if (expressionParsers[expression.type]) {
      return expressionParsers[expression.type](expression, parser);
    }
    return Object(__WEBPACK_IMPORTED_MODULE_0__parse_expression__["a" /* default */])(expression, parser);
  }

  /**
   * Parses transforms and returns an intermediary SQL representation
   * @memberof Parser
   * @inner
   * @see {@link Transform} for further information.
   */
  function parseTransform(sql, transform) {
    if (transformParsers[transform.type]) {
      return transformParsers[transform.type](sql, transform, parser);
    }
    return Object(__WEBPACK_IMPORTED_MODULE_2__parse_transform__["a" /* default */])(sql, transform, parser);
  }

  /**
   * Parses a data node state and returns an intermediary SQL representation
   * @memberof Parser
   * @inner
   */
  function parseDataState(data, sql) {
    return Object(__WEBPACK_IMPORTED_MODULE_1__parse_datastate__["a" /* default */])(data, parser, sql);
  }

  /**
   * Parses a source transform and returns a valid SQL FROM clause
   * @memberof Parser
   * @inner
   */
  function parseSource(sourceTransforms) {
    return Object(__WEBPACK_IMPORTED_MODULE_3__parse_source__["a" /* default */])(sourceTransforms, parser);
  }

  /**
  * Parses a data node state and returns a valid SQL string
   * @memberof Parser
   * @inner
   */
  function writeSQL(state) {
    return Object(__WEBPACK_IMPORTED_MODULE_4__write_sql__["a" /* default */])(state, parser);
  }

  return parser;
}

/* harmony default export */ __webpack_exports__["b"] = (createParser());

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = colorMixin;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The Color Mixin is an abstract chart functional class providing universal coloring support
 * as a mix-in for any concrete chart implementation.
 * @name colorMixin
 * @memberof dc
 * @mixin
 * @param {Object} _chart
 * @return {dc.colorMixin}
 */
function colorMixin(_chart) {
  var _colors = _d2.default.scale.category20c();
  var _defaultAccessor = true;

  var _colorAccessor = function _colorAccessor(d) {
    return _chart.keyAccessor()(d);
  };

  /**
   * Retrieve current color scale or set a new color scale. This methods accepts any function that
   * operates like a d3 scale.
   * @name colors
   * @memberof dc.colorMixin
   * @instance
   * @see {@link http://github.com/mbostock/d3/wiki/Scales d3.scale}
   * @example
   * // alternate categorical scale
   * chart.colors(d3.scale.category20b());
   * // ordinal scale
   * chart.colors(d3.scale.ordinal().range(['red','green','blue']));
   * // convenience method, the same as above
   * chart.ordinalColors(['red','green','blue']);
   * // set a linear scale
   * chart.linearColors(["#4575b4", "#ffffbf", "#a50026"]);
   * @param {d3.scale} [colorScale=d3.scale.category20c()]
   * @return {d3.scale}
   * @return {dc.colorMixin}
   */
  _chart.colors = function (colorScale) {
    if (!arguments.length) {
      return _colors;
    }
    if (colorScale instanceof Array) {
      _colors = _d2.default.scale.quantize().range(colorScale); // deprecated legacy support, note: this fails for ordinal domains
    } else {
      _colors = _d2.default.functor(colorScale);
    }
    return _chart;
  };

  /**
   * Convenience method to set the color scale to
   * {@link https://github.com/mbostock/d3/wiki/Ordinal-Scales#ordinal d3.scale.ordinal} with
   * range `r`.
   * @name ordinalColors
   * @memberof dc.colorMixin
   * @instance
   * @param {Array<String>} r
   * @return {dc.colorMixin}
   */
  _chart.ordinalColors = function (r) {
    return _chart.colors(_d2.default.scale.ordinal().range(r));
  };

  /**
   * Convenience method to set the color scale to an Hcl interpolated linear scale with range `r`.
   * @name linearColors
   * @memberof dc.colorMixin
   * @instance
   * @param {Array<Number>} r
   * @return {dc.colorMixin}
   */
  _chart.linearColors = function (r) {
    return _chart.colors(_d2.default.scale.linear().range(r).interpolate(_d2.default.interpolateHcl));
  };

  /**
   * Set or the get color accessor function. This function will be used to map a data point in a
   * crossfilter group to a color value on the color scale. The default function uses the key
   * accessor.
   * @name colorAccessor
   * @memberof dc.colorMixin
   * @instance
   * @example
   * // default index based color accessor
   * .colorAccessor(function (d, i){return i;})
   * // color accessor for a multi-value crossfilter reduction
   * .colorAccessor(function (d){return d.value.absGain;})
   * @param {Function} [colorAccessor]
   * @return {Function}
   * @return {dc.colorMixin}
   */
  _chart.colorAccessor = function (colorAccessor) {
    if (!arguments.length) {
      return _colorAccessor;
    }
    _colorAccessor = colorAccessor;
    _defaultAccessor = false;
    return _chart;
  };

  // what is this?
  _chart.defaultColorAccessor = function () {
    return _defaultAccessor;
  };

  /**
   * Set or get the current domain for the color mapping function. The domain must be supplied as an
   * array.
   *
   * Note: previously this method accepted a callback function. Instead you may use a custom scale
   * set by {@link #dc.colorMixin+colors .colors}.
   * @name colorDomain
   * @memberof dc.colorMixin
   * @instance
   * @param {Array<String>} [domain]
   * @return {Array<String>}
   * @return {dc.colorMixin}
   */
  _chart.colorDomain = function (domain) {
    if (!arguments.length) {
      return _colors.domain();
    }
    _colors.domain(domain);
    return _chart;
  };

  /**
   * Set the domain by determining the min and max values as retrieved by
   * {@link #dc.colorMixin+colorAccessor .colorAccessor} over the chart's dataset.
   * @name calculateColorDomain
   * @memberof dc.colorMixin
   * @instance
   * @return {dc.colorMixin}
   */
  _chart.calculateColorDomain = function () {
    var newDomain = [_d2.default.min(_chart.data(), _chart.colorAccessor()), _d2.default.max(_chart.data(), _chart.colorAccessor())];
    _colors.domain(newDomain);
    return _chart;
  };

  /**
   * Get the color for the datum d and counter i. This is used internally by charts to retrieve a color.
   * @name getColor
   * @memberof dc.colorMixin
   * @instance
   * @param {*} d
   * @param {Number} [i]
   * @return {String}
   */
  _chart.getColor = function (data, index) {
    if (typeof data === "undefined") {
      var GREY = "#e2e2e2";
      return GREY;
    }

    var range = _chart.colors().range();
    var middleColor = range[Math.floor(range.length / 2)];

    return _colors(_colorAccessor.call(this, data, index)) || middleColor;
  };

  /**
   * Get the color for the datum d and counter i. This is used internally by charts to retrieve a color.
   * @name colorCalculator
   * @memberof dc.colorMixin
   * @instance
   * @param {*} [colorCalculator]
   * @return {*}
   */
  _chart.colorCalculator = function (colorCalculator) {
    if (!arguments.length) {
      return _chart.getColor;
    }
    _chart.getColor = colorCalculator;
    return _chart;
  };

  return _chart;
}

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

!function(t,e){ true?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.MapdDraw=e():t.MapdDraw=e()}("undefined"!=typeof self?self:this,function(){return function(t){function e(n){if(r[n])return r[n].exports;var i=r[n]={i:n,l:!1,exports:{}};return t[n].call(i.exports,i,i.exports,e),i.l=!0,i.exports}var r={};return e.m=t,e.c=r,e.d=function(t,r,n){e.o(t,r)||Object.defineProperty(t,r,{configurable:!1,enumerable:!0,get:n})},e.n=function(t){var r=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(r,"a",r),r},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="",e(e.s=25)}([function(t,e,r){"use strict";function n(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return t[g]=e,t[w]=r,t}function i(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n(new b.a.ARRAY_TYPE(2),t,e)}function o(t){var e=new b.a.ARRAY_TYPE(2);return e[g]=t[g],e[w]=t[w],e}function a(t,e){return t[g]=e[g],t[w]=e[w],t}function s(t,e){return i(t,e)}function c(t,e,r){return m.a.add(t,e,r)}function u(t,e,r){return m.a.sub(t,e,r)}function l(t,e,r){return m.a.transformMat2(t,e,r)}function f(t,e,r){return m.a.transformMat2d(t,e,r)}function h(t){return"point2d(".concat(t[0]," , ").concat(t[1],")")}function p(t,e){return m.a.distance(t,e)}function d(t,e){return m.a.squaredDistance(t,e)}function _(t,e,r,n){return m.a.lerp(t,e,r,n)}function v(t,e){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;return m.a.equals(t,e,r)}function y(t,e){return m.a.exactEquals(t,e)}Object.defineProperty(e,"__esModule",{value:!0}),e.set=n,e.create=i,e.clone=o,e.copy=a,e.initFromValues=s,e.addVec2=c,e.sub=u,e.transformMat2=l,e.transformMat2d=f,e.str=h,e.distance=p,r.d(e,"dist",function(){return x}),e.squaredDistance=d,r.d(e,"sqrDist",function(){return k}),e.lerp=_,e.equals=v,e.exactEquals=y;var b=r(6),m=r(3),g=0,w=1,x=p,k=d},function(t,e,r){"use strict";function n(t){s=t}function i(t){return t*u}function o(t,e){return Math.abs(t-e)<=a*Math.max(1,Math.abs(t),Math.abs(e))}Object.defineProperty(e,"__esModule",{value:!0}),r.d(e,"EPSILON",function(){return a}),r.d(e,"ARRAY_TYPE",function(){return s}),r.d(e,"RANDOM",function(){return c}),e.setMatrixArrayType=n,e.toRadian=i,e.equals=o;var a=1e-6,s="undefined"!=typeof Float32Array?Float32Array:Array,c=Math.random,u=Math.PI/180},function(t,e,r){"use strict";var n=r(6),i=r(5);n.c.equals=function(t,e){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,n=t[0],o=t[1],a=t[2],s=t[3],c=t[4],u=t[5],l=e[0],f=e[1],h=e[2],p=e[3],d=e[4],_=e[5],v=null!==r?r:i.EPSILON;return Math.abs(n-l)<=v*Math.max(1,Math.abs(n),Math.abs(l))&&Math.abs(o-f)<=v*Math.max(1,Math.abs(o),Math.abs(f))&&Math.abs(a-h)<=v*Math.max(1,Math.abs(a),Math.abs(h))&&Math.abs(s-p)<=v*Math.max(1,Math.abs(s),Math.abs(p))&&Math.abs(c-d)<=v*Math.max(1,Math.abs(c),Math.abs(d))&&Math.abs(u-_)<=v*Math.max(1,Math.abs(u),Math.abs(_))},n.c.svd=function(t,e,r,n){if(t&&(t[0]=n[4],t[1]=n[5]),e||r){var i=(n[0]+n[3])/2,o=(n[0]-n[3])/2,a=(n[1]+n[2])/2,s=(n[1]-n[2])/2;if(e){var c=Math.sqrt(i*i+s*s),u=Math.sqrt(o*o+a*a);e[0]=c+u,e[1]=c-u}if(r){var l=Math.atan2(a,o),f=Math.atan2(s,i);r[0]=(f-l)/2,r[1]=(f+l)/2}}},e.a=n.c},function(t,e,r){"use strict";var n=r(6),i=r(5);n.d.equals=function(t,e){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,n=t[0],o=t[1],a=e[0],s=e[1],c=null!==r?r:i.EPSILON;return Math.abs(n-a)<=c*Math.max(1,Math.abs(n),Math.abs(a))&&Math.abs(o-s)<=c*Math.max(1,Math.abs(o),Math.abs(s))},n.d.cross2d=function(t,e){return t[0]*e[1]-t[1]*e[0]},n.d.angleFast=function(t,e){return Math.acos(n.d.dot(t,e))},n.d.angle=function(t,e){var r=n.d.dot(t,e),i=n.d.cross2d(t,e);return Math.atan2(i,r)},n.d.anglePosX=function(t){var e=Math.atan2(t[1],t[0]);return e<0&&(e*=-1),e},e.a=n.d},function(t,e,r){"use strict";function n(t,e,r,n,i){return t[D]="number"==typeof e?e:1/0,t[F]="number"==typeof r?r:1/0,t[R]="number"==typeof n?n:-1/0,t[T]="number"==typeof i?i:-1/0,t}function i(t,e,r,i){return n(new j.a.ARRAY_TYPE(B.BOX_SIDES),t,e,r,i)}function o(t){var e=new j.a.ARRAY_TYPE(B.BOX_SIDES);return e[D]=t[D],e[F]=t[F],e[R]=t[R],e[T]=t[T],e}function a(t,e){return t[D]=e[D],t[F]=e[F],t[R]=e[R],t[T]=e[T],t}function s(t){return t[D]=1/0,t[F]=1/0,t[R]=-1/0,t[T]=-1/0,t}function c(t){return t[D]=-1/0,t[F]=-1/0,t[R]=1/0,t[T]=1/0,t}function u(t,e){return e[0]<0?(t[D]=-e[0],t[R]=0):(t[D]=0,t[R]=e[0]),e[1]<0?(t[F]=-e[1],t[T]=0):(t[F]=0,t[T]=e[1]),t}function l(t,e,r){for(var n=0;n<2;n+=1)r[n]<0?(t[n]=e[n]-r[n],t[n+2]=e[n]):(t[n]=e[n],t[n+2]=e[n]+r[n]);return t}function f(t,e,r){for(var n=0;n<2;n+=1)r[n]<0?(t[n]=e[n]+r[n],t[n+2]=e[n]-r[n]):(t[n]=e[n]-r[n],t[n+2]=e[n]+r[n]);return t}function h(t){return t[D]>t[R]||t[F]>t[T]}function p(t){return!(isFinite(t[D])&&isFinite(t[F])&&isFinite(t[R])&&isFinite(t[T]))}function d(t,e){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,n=t[0],i=t[1],o=t[2],a=t[3],s=e[0],c=e[1],u=e[2],l=e[3],f=null!==r?r:A.EPSILON;return Math.abs(n-s)<=f&&Math.abs(i-c)<=f&&Math.abs(o-u)<=f&&Math.abs(a-l)<=f}function _(t,e){return I.a.set(t,e[R]-e[D],e[T]-e[F])}function v(t,e){return _(t,e),I.a.scale(t,t,.5)}function y(t,e){return v(t,e),t[D]+=e[D],t[F]+=e[F],t}function b(t,e,r){t[D]=e[D]-r[0],t[R]=e[R]+r[0],t[F]=e[F]-r[1],t[T]=e[T]+r[1]}function m(t){return(t[R]-t[D])*(t[T]-t[F])}function g(t,e,r){return i(Math.min(e[D],r[D]),Math.min(e[F],r[F]),Math.max(e[R],r[R]),Math.max(e[T],r[T]))}function w(t,e,r){var n=t;t===e&&(n=i());for(var o=D,c=R;o<=F&&!(e[c]<r[o]||e[o]>r[c]);o+=1,c+=1)n[o]=Math.max(e[o],r[o]),n[c]=Math.min(e[c],r[c]);return o!==F+1&&s(n),t===e&&a(t,n),t}function x(t,e){return!(t[R]<=e[D]||t[D]>=e[R]||t[T]<=e[F]||t[F]>=e[T])}function k(t,e){return!(e[D]<t[D]||e[R]>t[R]||e[F]<t[F]||e[T]>t[T])}function S(t,e){return e[D]>=t[D]&&e[D]<=t[R]&&e[F]>=t[F]&&e[F]<=t[T]}function O(t,e,r){return t!==e&&a(t,e),h(e)?(t[D]=r[D],t[R]=r[D],t[F]=r[F],t[T]=r[F]):(r[D]<t[D]?t[D]=r[D]:r[D]>t[R]&&(t[R]=r[D]),r[F]<t[F]?t[F]=r[F]:r[F]>t[T]&&(t[T]=r[F])),t}function E(t,e,r){t[D]=e[D]+r[0],t[F]=e[F]+r[1],t[R]=e[R]+r[0],t[T]=e[T]+r[1]}function M(t,e,r,n){var o=t;t===e&&(o=i()),s(o);var c=I.a.set(I.a.create(),e[D],e[F]),u=I.a.create();return n(u,c,r),O(o,o,u),c[D]=e[R],n(u,c,r),O(o,o,u),c[F]=e[T],n(u,c,r),O(o,o,u),c[D]=e[D],n(u,c,r),O(o,o,u),t===e&&a(t,o),t}function C(t,e,r){return M(t,e,r,I.a.transformMat2)}function P(t,e,r){return M(t,e,r,I.a.transformMat2d)}Object.defineProperty(e,"__esModule",{value:!0}),r.d(e,"MINX",function(){return D}),r.d(e,"MINY",function(){return F}),r.d(e,"MAXX",function(){return R}),r.d(e,"MAXY",function(){return T}),e.set=n,e.create=i,e.clone=o,e.copy=a,e.initEmpty=s,e.initInfinity=c,e.initSizeFromOrigin=u,e.initSizeFromLocation=l,e.initCenterExtents=f,e.isEmpty=h,e.isInfinite=p,e.equals=d,e.getSize=_,e.getExtents=v,e.getCenter=y,e.expand=b,e.area=m,e.hull=g,e.intersection=w,e.overlaps=x,e.contains=k,e.containsPt=S,e.encapsulatePt=O,e.translate=E,e.transformMat2=C,e.transformMat2d=P;var j=r(6),A=r(5),I=r(3),D=0,F=1,R=2,T=3,B={BOX_SIDES:4}},function(t,e,r){"use strict";function n(t){return o.a.setMatrixArrayType(t)}function i(t){a=t}Object.defineProperty(e,"__esModule",{value:!0}),r.d(e,"EPSILON",function(){return a}),e.setMatrixArrayType=n,e.setEpsilon=i;var o=r(6),a=o.a.EPSILON},function(t,e,r){"use strict";var n=r(1),i=r(27),o=r(28),a=(r(14),r(15),r(16),r(29),r(30));r(17),r(18);r.d(e,"a",function(){return n}),r.d(e,"b",function(){return i}),r.d(e,"c",function(){return o}),r.d(e,"d",function(){return a})},function(t,e,r){"use strict";function n(t){"@babel/helpers - typeof";return(n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&a(t,e)}function a(t,e){return(a=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function s(t){var e=l();return function(){var r,n=f(t);if(e){var i=f(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return c(this,r)}}function c(t,e){return!e||"object"!==n(e)&&"function"!=typeof e?u(t):e}function u(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function l(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(t){return!1}}function f(t){return(f=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var h=function(t){for(var e=arguments.length,r=new Array(e>1?e-1:0),n=1;n<e;n++)r[n-1]=arguments[n];var a=t?function(t){function e(){for(var t,o=arguments.length,a=new Array(o),s=0;s<o;s++)a[s]=arguments[s];return i(this,e),t=n.call.apply(n,[this].concat(a)),r.forEach(function(e){if("function"==typeof e.prototype.initializer){var r;(r=e.prototype.initializer).call.apply(r,[u(t)].concat(a))}}),t}o(e,t);var n=s(e);return e}(t):function(){},c=function(e,r){Object.getOwnPropertyNames(r).concat(Object.getOwnPropertySymbols(r)).forEach(function(n){n.match(/^(?:constructor|prototype|arguments|caller|name|bind|call|apply|toString|length)$/)||t&&n.match(/^(?:initializer)$/)||Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))})};return r.forEach(function(t){c(a.prototype,t.prototype),c(a,t)}),a};e.a=h},function(t,e,r){"use strict";function n(t,e,r){return t<e?e:t>r?r:t}function i(t){return t<0?0:t>1?1:t}function o(t,e,r){return t*(1-r)+e*r}var a=r(5);Math.QUATER_PI=.25*Math.PI,Math.HALF_PI=.5*Math.PI,Math.HALF_NPI=-.5*Math.PI,Math.TWO_PI=2*Math.PI,Math.NPI=-Math.PI,Math.NQUATER_PI=.25*Math.NPI,Math.NHALF_PI=.5*Math.NPI,Math.NTWO_PI=2*Math.NPI,Math.INV_PI=1/Math.PI,Math.RAD_TO_DEG=180/Math.PI,Math.DEG_TO_RAD=Math.PI/180,Math.clamp=n,Math.clamp01=i,Math.lerp=o,Math.floatingPtEquals=function(t,e){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,n=null!==r?r:a.EPSILON;return Math.abs(t-e)<=n*Math.max(1,Math.abs(t),Math.abs(e))},e.a=Math},function(t,e,r){"use strict";function n(t){"@babel/helpers - typeof";return(n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function a(t,e,r){return e&&o(t.prototype,e),r&&o(t,r),t}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&c(t,e)}function c(t,e){return(c=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function u(t){var e=h();return function(){var r,n=p(t);if(e){var i=p(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return l(this,r)}}function l(t,e){return!e||"object"!==n(e)&&"function"!=typeof e?f(t):e}function f(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function h(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(t){return!1}}function p(t){return(p=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}r.d(e,"a",function(){return O});var d=r(4),_=r(0),v=r(3),y=r(2),b=r(19),m=r(21),g=r(11),w=r(7),x=r(10),k=r(12),S=function(t){function e(t){var n;return i(this,e),n=r.call(this,["changed:xform","changed:style","changed:order","changed:visibility","changed:geom"]),n._aabox=d.create(),n._zIndex=t&&t.zIndex?t.zIndex:0,n._visible=!0,n._geomDirty=!1,n._fullXform=y.a.create(),n}s(e,t);var r=u(e);return a(e,[{key:"zIndex",get:function(){return this._zIndex},set:function(t){if(!Number.isInteger(t))throw new Error("zIndex must be an integer");if(t!==this._zIndex){var e=this._zIndex;this._zIndex=t,this.fire("changed:order",{attr:"zIndex",prevVal:e,currVal:this._zIndex})}return this}},{key:"aabox",get:function(){return this._updateAABox(),this._aabox}},{key:"visible",get:function(){return this._visible},set:function(t){if("boolean"!=typeof t)throw new Error("visible must be a boolean");return t!==this._visible&&(this._visible=t,this.fire("changed:visibility",{attr:"visible",prevVal:!this._visible,currVal:this._visible})),this}}]),e}(k.a),O=function(t){function e(t){var n;i(this,e),n=r.call(this,t),n._stateStack=[];var o=t.debug;return n._doDebugDraw="boolean"==typeof o&&o&&"function"==typeof n._drawDebug,n}s(e,t);var r=u(e);return a(e,[{key:"save",value:function(){var t=new x.a;return x.a.copyBasicStyle(this,t),t.zIndex=this.zIndex,this._stateStack.push(t),this}},{key:"restore",value:function(){var t=this._stateStack.pop();return t&&(x.a.copyBasicStyle(t,this),this.zIndex=t.zIndex),this}},{key:"visible",get:function(){return this._visible&&(this.isFillVisible()||this.isStrokeVisible())}},{key:"getGlobalDimensions",value:function(){var t=v.a.create();return y.a.svd(null,t,null,this.globalXform),t[0]*=this.width,t[1]*=this.height,t}},{key:"containsPoint",value:function(t,e,r,n){var i=!1,o=this.aabox;return this.visible&&d.containsPt(o,e)&&(n.save(),n.setTransform(1,0,0,1,0,0),n.beginPath(),this._draw(n),n.strokeStyle="rgba(0,0,0,0)",n.lineWidth=this.strokeWidth+5,n.dashPattern=[],n.setTransform(1,0,0,1,0,0),n.stroke(),(this.isFillVisible()&&n.isPointInPath(t[0],t[1])||this.isStrokeVisible()&&n.isPointInStroke(t[0],t[1]))&&(i=!0),n.restore()),i}},{key:"renderBounds",value:function(t,e,r){t.save(),t.setTransform(1,0,0,1,0,0),r.setStrokeCtx(t);var n=_.create(),i=_.create(),o=_.create(),a=this.aabox;d.getCenter(i,a),d.getExtents(o,a),t.beginPath(),_.set(n,i[0]-o[0],i[1]-o[1]),_.transformMat2d(n,n,e),t.moveTo(n[0],n[1]),_.set(n,i[0]+o[0],i[1]-o[1]),_.transformMat2d(n,n,e),t.lineTo(n[0],n[1]),_.set(n,i[0]+o[0],i[1]+o[1]),_.transformMat2d(n,n,e),t.lineTo(n[0],n[1]),_.set(n,i[0]-o[0],i[1]+o[1]),_.transformMat2d(n,n,e),t.lineTo(n[0],n[1]),t.closePath(),t.setTransform(1,0,0,1,0,0),t.stroke(),t.restore()}},{key:"_localXformUpdated",value:function(){this._boundsOutOfDate=!0}},{key:"_globalXformUpdated",value:function(){this._boundsOutOfDate=!0}},{key:"render",value:function(t,e,r){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;y.a.multiply(this._fullXform,e,this.globalXform),t.beginPath();var o=this._draw(t);(o||void 0===o)&&(this.isFillVisible()&&(null===n||Boolean(n))&&(r.setFillStyle(t,this),t.fill()),this.isStrokeVisible()&&(null===i||Boolean(i))&&(r.setStrokeStyle(t,this),t.setTransform(1,0,0,1,0,0),t.stroke()),this._doDebugDraw&&this._drawDebug(t))}},{key:"setStyle",value:function(t){return x.a.copyBasicStyle(t,this),this}},{key:"toJSON",value:function(){var t=this;return this._stateStack&&this._stateStack.length&&(t=this._stateStack[0]),Object.assign({visible:this.visible,zIndex:t.zIndex},x.a.toJSON(t),g.c.toJSON(this))}}],[{key:"shapeCompare",value:function(t,e){var r=t.zIndex,n=e.zIndex;if(r<n)return-1;if(r>n)return 1;var i=b.b.compareFillStyle(t,e);return i||(i=m.b.compareStrokeStyle(t,e)),i}}]),e}(Object(w.a)(S,Object(g.b)("changed:xform"),Object(b.a)("changed:style"),Object(m.a)("changed:style")))},function(t,e,r){"use strict";function n(t){"@babel/helpers - typeof";return(n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function a(t,e,r){return e&&o(t.prototype,e),r&&o(t,r),t}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&c(t,e)}function c(t,e){return(c=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function u(t){var e=h();return function(){var r,n=p(t);if(e){var i=p(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return l(this,r)}}function l(t,e){return!e||"object"!==n(e)&&"function"!=typeof e?f(t):e}function f(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function h(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(t){return!1}}function p(t){return(p=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}r.d(e,"a",function(){return y});var d=r(7),_=r(19),v=r(21),y=function(t){function e(){return i(this,e),r.apply(this,arguments)}s(e,t);var r=u(e);return a(e,null,[{key:"copyBasicStyle",value:function(t,e){_.b.copyFillStyle(t,e),v.b.copyStrokeStyle(t,e)}},{key:"toJSON",value:function(t){return Object.assign(_.b.toJSON(t),v.b.toJSON(t))}}]),e}(Object(d.a)(function t(){i(this,t)},_.b,v.b))},function(t,e,r){"use strict";function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function o(t,e,r){return e&&i(t.prototype,e),r&&i(t,r),t}function a(t,e,r,n,i){return l.a.identity(t),l.a.translate(t,t,[n[0]+i[0],n[1]+i[1]]),l.a.rotate(t,t,p.a.DEG_TO_RAD*e),l.a.scale(t,t,r),l.a.translate(t,t,[-i[0],-i[1]]),t}function s(t){t.forEach(function(t){t._xformDirty=!0,s(t._children)})}function c(t){return Object(h.a)(null,d,function(){function e(){n(this,e)}return o(e,[{key:"pivot",get:function(){return u.clone(this._pivot)},set:function(e){if(!u.equals(e,this._pivot)){var r=[this._pivot[0],this._pivot[1]];u.copy(this._pivot,e),this._lxformDirty=!0,s(this._children),this.fire(t,{attr:"pivot",prevVal:r,currVal:e})}return this}},{key:"setPosition",value:function(e){if(!u.equals(e,this._pos)){var r=[this._pos[0],this._pos[1]];u.copy(this._pos,e),this._lxformDirty=!0,s(this._children),this.fire(t,{attr:"position",prevVal:r,currVal:e})}return this}},{key:"translate",value:function(e){if(e[0]||e[1]){var r=[this._pos[0],this._pos[1]];u.addVec2(this._pos,this._pos,e),this._lxformDirty=!0,s(this._children),this.fire(t,{attr:"position",prevVal:r,currVal:[this._pos[0],this._pos[1]]})}return this}},{key:"setScale",value:function(e){if(!f.a.equals(e,this._scale)){var r=[this._scale[0],this._scale[1]];f.a.copy(this._scale,e),this._lxformDirty=!0,s(this._children),this.fire(t,{attr:"size",prevVal:r,currVal:e})}return this}},{key:"scale",value:function(e){if(1!==e[0]||1!==e[1]){var r=[this._scale[0],this._scale[1]];f.a.multiply(this._scale,this._scale,e),this._lxformDirty=!0,s(this._children),this.fire(t,{attr:"size",prevVal:r,currVal:[this._scale[0],this._scale[1]]})}return this}},{key:"setRotation",value:function(e){var r=e%360;if(r!==this._rotDeg){var n=this._rotDeg;this._rotDeg=r,this._lxformDirty=!0,s(this._children),this.fire(t,{attr:"orientation",prevVal:n,curral:this._rotDeg})}}},{key:"rotate",value:function(e){if(e){var r=this._rotDeg;this._rotDeg+=e,this._rotDeg%=360,this._lxformDirty=!0,s(this._children),this.fire(t,{attr:"orientation",prevVal:r,curral:this._rotDeg})}return this}},{key:"setTransformations",value:function(e,r,n,i,o){var a=[],c=[],l=[];if(!(void 0===e||void 0===r||p.a.floatingPtEquals(e,this._pos[0])&&p.a.floatingPtEquals(r,this._pos[1]))){var h=u.clone(this._pos);this._pos[0]=e,this._pos[1]=r,a.push("position"),c.push(h),l.push(u.clone(this._pos))}if(!(void 0===n||void 0===i||p.a.floatingPtEquals(n,this._scale[0])&&p.a.floatingPtEquals(i,this._scale[1]))){var d=f.a.clone(this._scale);f.a.set(this._scale,n,i),a.push("size"),c.push(d),l.push(f.a.clone(this._scale))}if(void 0!==o){var _=o%360;if(!p.a.floatingPtEquals(_,this._rotDeg)){var v=this._rotDeg;this._rotDeg=_,a.push("orientation"),c.push(v),l.push(this._rotDeg)}}return a.length&&(this._lxformDirty=!0,s(this._children),this.fire(t,{attrs:a,prevVals:c,currVals:l})),this}}]),e}())}e.a=a,r.d(e,"c",function(){return d}),e.b=c;var u=r(0),l=r(2),f=r(3),h=r(7),p=r(8),d=function(){function t(e){n(this,t),this.initializer(e)}return o(t,[{key:"_initTransformFromOptions",value:function(t){t&&(void 0!==t.position&&this.setPosition(t.position),void 0!==t.scale&&this.setScale(t.scale),void 0!==t.rotation&&this.setRotation(t.rotation),void 0!==t.pivot&&(this.pivot=t.pivot))}},{key:"initializer",value:function(t){this._localXform=l.a.create(),this._lxformDirty=!1,this._pivot=u.create(0,0),this._pos=u.create(0,0),this._scale=f.a.fromValues(1,1),this._rotDeg=0,this._globalXform=l.a.create(),this._xformDirty=!1,this._parent=null,this._children=new Set,this._initTransformFromOptions(t)}},{key:"addChildXform",value:function(t){this._children.has(t)||(this._children.add(t),t._parent&&t._parent.removeChild(t),t._parent=this,t._xformDirty=!0,s(t._children))}},{key:"removeChildXform",value:function(t){this._children.delete(t)}},{key:"unparentXform",value:function(){this._parent&&(this._parent.removeChild(this),this._parent=null,l.a.copy(this._globalXform,this.localXform))}},{key:"pivot",get:function(){return u.clone(this._pivot)},set:function(t){return u.copy(this._pivot,t),this._lxformDirty=!0,s(this._children),this}},{key:"pivotRef",get:function(){return this._pivot}},{key:"parent",get:function(){return this._parent}},{key:"getPosition",value:function(){return f.a.clone(this._pos)}},{key:"getPositionRef",value:function(){return this._pos}},{key:"getWorldPosition",value:function(){var t=this.globalXform;return u.create(t[4],t[5])}},{key:"setPosition",value:function(t){u.copy(this._pos,t),this._lxformDirty=!0,s(this._children)}},{key:"translate",value:function(t){return(t[0]||t[1])&&(u.addVec2(this._pos,this._pos,t),this._lxformDirty=!0,s(this._children)),this}},{key:"getScale",value:function(){return f.a.clone(this._scale)}},{key:"getScaleRef",value:function(){return this._scale}},{key:"setScale",value:function(t){return f.a.copy(this._scale,t),this._lxformDirty=!0,s(this._children),this}},{key:"scale",value:function(t){return 1===t[0]&&1===t[1]||(f.a.multiply(this._scale,this._scale,t),this._lxformDirty=!0,s(this._children)),this}},{key:"getRotation",value:function(){return this._rotDeg}},{key:"setRotation",value:function(t){return this._rotDeg=t,this._lxformDirty=!0,s(this._children),this}},{key:"rotate",value:function(t){return t&&(this._rotDeg+=t,this._lxformDirty=!0,s(this._children)),this}},{key:"_dirtyChildren",value:function(){s(this._children)}},{key:"_updatelocalxform",value:function(){this._lxformDirty&&(a(this._localXform,this._rotDeg,this._scale,this._pos,this._pivot),this._localXformUpdated&&this._localXformUpdated(),this._lxformDirty=!1)}},{key:"_updateglobalxform",value:function(){(this._lxformDirty||this._xformDirty)&&(this._updatelocalxform(),this._parent?l.a.multiply(this._globalXform,this._parent.globalXform,this._localXform):l.a.copy(this._globalXform,this._localXform),this._globalXformUpdated&&this._globalXformUpdated(),this._xformDirty=!1)}},{key:"localXform",get:function(){return this._updatelocalxform(),this._localXform}},{key:"globalXform",get:function(){return this._updateglobalxform(),this._globalXform}}],[{key:"toJSON",value:function(t){var e=t.getPositionRef(),r=t.getScaleRef(),n=t.pivotRef;return{position:[e[0],e[1]],scale:[r[0],r[1]],rotation:t.getRotation(),pivot:[n[0],n[1]]}}}]),t}()},function(t,e,r){"use strict";function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function o(t,e,r){return e&&i(t.prototype,e),r&&i(t,r),t}function a(t,e,r,n){var i=this;if(r>=e.length)return 0;var o=0,s=null;return s=t.get(e[r]),s&&(o=a(s[0],e,r+1,n),s[1].forEach(function(t){return t.call(i,n)}),o+=s[1].length),o}function s(t,e){var r=-1,n=t[0],i=t[1];i.length&&e.forEach(function(t){(r=i.indexOf(t))>=0&&i.splice(r,1)}),n.forEach(function(t){s(t,e)})}function c(t){var e=t;if("string"==typeof t)e=[t];else if(!Array.isArray(t))throw new Error("Input must be an array of strings");return e}r.d(e,"a",function(){return u});var u=function(){function t(e){n(this,t),this.initializer(e)}return o(t,[{key:"initializer",value:function(t){this._listeners=new Map,this.registerEvents(t)}},{key:"registerEvents",value:function(t){var e=this;if(t){var r=c(t);if("string"==typeof t)r=[t];else if(!Array.isArray(t))throw new Error("Events must be an array of strings");r.forEach(function(t){for(var r=t.split(":"),n=e._listeners,i=0;i<r.length;i+=1){var o=n.get(r[i]);o||(o=[new Map,[]],n.set(r[i],o)),n=o[0]}})}}},{key:"on",value:function(t,e){var r=this;return c(t).forEach(function(t){var n=t.split(":"),i=r._listeners,o=null;n.forEach(function(e){if(!(o=i.get(e))){var r=[];throw i.forEach(function(t,e){return r.push(e)}),new Error("".concat(t," is not a valid event type. The registered event types at this level are [").concat(r,"]"))}i=o[0]}),o[1].indexOf(e)<0&&o[1].push(e)}),this}},{key:"off",value:function(t,e){var r=this,n=c(t),i=e;return Array.isArray(i)||(i=[e]),n.forEach(function(t){var e=t.split(":"),n=r._listeners,o=null,a=0;for(a=0;a<e.length&&(o=n.get(e[a]));a+=1)n=o[0];o&&s(o,i)}),this}},{key:"once",value:function(t,e){var r=this,n=function n(i){r.off(t,n),e.call(r,i)};return this.on(t,n),this}},{key:"fire",value:function(t,e){var r=t.split(":"),n={type:t,target:this};return Object.assign(n,e),a(this._listeners,r,0,n),this._eventParent&&(n={},Object.getOwnPropertyNames(e).forEach(function(t){n[t]=e[t]}),this._eventParent.fire(t,n)),this}},{key:"listens",value:function(t){for(var e=t.split(":"),r=this._listeners,n=null,i=0;i<e.length&&(n=r.get(e[i]));i+=1)r=n[0];return n||this._eventParent&&this._eventParent.listens(t)}},{key:"setEventedParent",value:function(t,e){return this._eventParent=t,this._eventParentData=e,this}}]),t}()},function(t,e,r){"use strict";function n(t){"@babel/helpers - typeof";return(n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function a(t,e,r){return e&&o(t.prototype,e),r&&o(t,r),t}function s(t,e,r){return(s="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,r){var n=c(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(r):i.value}})(t,e,r||t)}function c(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=_(t)););return t}function u(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&l(t,e)}function l(t,e){return(l=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function f(t){var e=d();return function(){var r,n=_(t);if(e){var i=_(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return h(this,r)}}function h(t,e){return!e||"object"!==n(e)&&"function"!=typeof e?p(t):e}function p(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function d(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(t){return!1}}function _(t){return(_=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function v(t,e,r,n){m.isEmpty(t)?(t[0]=e[0],t[2]=e[0],n[0]=n[2]=r,t[1]=e[1],t[3]=e[1],n[1]=n[3]=r):(e[0]<t[0]?(t[0]=e[0],n[0]=r):e[0]>t[2]&&(t[2]=e[0],n[2]=r),e[1]<t[1]?(t[1]=e[1],n[1]=r):e[1]>t[3]&&(t[3]=e[1],n[3]=r))}function y(t,e,r){var n=e[0]*r[1]-r[0]*e[1];return t[0]+=(e[0]+r[0])*n,t[1]+=(e[1]+r[1])*n,n}function b(t){return Array.isArray(t)||ArrayBuffer&&ArrayBuffer.isView(t)}r.d(e,"a",function(){return E});var m=r(4),g=r(0),w=r(2),x=r(9),k=r(8),S=r(23),O=w.a.create(),E=function(t){function e(t){var n;i(this,e);var o=t.verts||[];if(n=r.call(this,t),!b(o)||0===o.length||b(o[0])&&o.length<1||!b(o[0])&&(o.length<2||o.length%2!=0))throw new Error("PolyLine shapes must be initialized with an array of 2d points and contain at least 1 points");n._extentIndices=[-1,-1,-1,-1],n._localaabox=m.create(),n._verts=[],n._centroid=g.create(),m.initEmpty(n._aabox);var a=0,s=0;if(b(o[0])){for(s=0;s<o.length-1;s+=1)n._verts.push(g.clone(o[s])),v(n._aabox,o[s],s,n._extentIndices),a+=y(n._centroid,o[s],o[s+1]);n._verts.push(g.clone(o[s])),v(n._aabox,o[s],s,n._extentIndices),a+=y(n._centroid,o[s],o[0])}else{n._verts.push(g.create(o[0],o[1])),v(n._aabox,n._verts[0],0,n._extentIndices);var c=1;for(s=2;s<o.length-2;s+=2,c+=1)n._verts.push(g.create(o[s],o[s+1])),v(n._aabox,n._verts[c],c,n._extentIndices),a+=y(n._centroid,n._verts[c-1],n._verts[c]);n._verts.push(g.create(o[s],o[s+1])),v(n._aabox,n._verts[c],c,n._extentIndices),a+=y(n._centroid,n._verts[c],n._verts[0])}a*=.5,n._centroid[0]/=6*a,n._centroid[1]/=6*a;var u=g.create();return m.getCenter(u,n._aabox),n.pivot=u,n._verts.length<3?n._convexHull=n._verts.map(function(t,e){return e}):n._convexHull=Object(S.a)(n._verts),n}u(e,t);var r=f(e);return a(e,[{key:"getDimensions",value:function(){return[this.width,this.height]}},{key:"width",get:function(){return this._updateAABox(),!this._verts.length||this._extentIndices[0]<0||this._extentIndices[2]<0?0:this._verts[this._extentIndices[2]][0]-this._verts[this._extentIndices[0]][0]}},{key:"height",get:function(){return this._updateAABox(),!this._verts.length||this._extentIndices[0]<0||this._extentIndices[2]<0?0:this._verts[this._extentIndices[3]][1]-this._verts[this._extentIndices[1]][1]}},{key:"vertsRef",get:function(){return this._verts}},{key:"numVerts",get:function(){return this._verts.length}},{key:"_collapseVerts",value:function(){var t=this;g.set(this._pivot,0,0);var e=this.localXform;if(w.a.equals(e,O))return!1;m.initEmpty(this._aabox);for(var r=0;r<this._verts.length;r+=1)g.transformMat2d(this._verts[r],this._verts[r],e);return this._verts.length<3?this._convexHull=this._verts.map(function(t,e){return e}):this._convexHull=Object(S.a)(this._verts),this._convexHull.forEach(function(e){v(t._aabox,t._verts[e],e,t._extentIndices)}),this.setTransformations(0,0,1,1,0),!0}},{key:"translateVert",value:function(t,e){if(t>=this._verts.length)throw new Error("Cannot translate vertex at index ".concat(t,". There are only ").concat(this._verts.length," vertices in the polygon."));if(e[0]||e[1]){var r=g.clone(this._verts[t]),n=g.clone(this._verts[t]);g.addVec2(n,n,e),this._collapseVerts(),this._resetAABox=!0,this._geomDirty=!0,g.copy(n),this.fire("changed:geom",{attr:"verts[".concat(t,"]"),prevVal:r,currVal:n})}return this}},{key:"setVertPosition",value:function(t,e){if(t>=this._verts.length)throw new Error("Cannot translate vertex at index ".concat(t,". There are only ").concat(this._verts.length," vertices in the polygon."));if(!g.equals(e,this._verts[t])){var r=g.clone(this._verts[t]);this._collapseVerts(),g.copy(this._verts[t],e),this._resetAABox=!0,this._geomDirty=!0,this.fire("changed:geom",{attr:"verts[".concat(t,"]"),prevVal:r,currVal:e})}}},{key:"insertVert",value:function(t,e){var r=k.a.min(k.a.max(t,0),this._verts.length);return this._collapseVerts(),t>=this._verts.length?(this._verts.push(g.clone(e)),r=this._verts.length-1):this._verts.splice(t,0,g.clone(e)),this._resetAABox=!0,this._geomDirty=!0,this.fire("changed:geom:addvert",{attr:"verts[".concat(r,"]"),currVal:e}),r}},{key:"appendVert",value:function(t){return this.insertVert(this._verts.length,t)}},{key:"removeVert",value:function(t){if(t>=this._verts.length||t<0)throw new Error("Cannot remove vertex ".concat(t,". Invalid index. There are only ").concat(this._verts.length," vertices in the shape."));var e=this._verts[t];return this._verts.splice(t,1),this._collapseVerts(),this._resetAABox=!0,this._geomDirty=!0,this.fire("changed:geom:removevert",{attr:"verts[".concat(t,"]"),currVal:e}),t}},{key:"_rebuildAABox",value:function(){var t=this;m.initEmpty(this._aabox),this._verts.length<3?this._convexHull=this._verts.map(function(t,e){return e}):this._convexHull=Object(S.a)(this._verts),this._convexHull.forEach(function(e){v(t._aabox,t._verts[e],e,t._extentIndices)});var e=g.create(0,0);m.getCenter(e,this._aabox),this.pivot=e}},{key:"_updateAABox",value:function(){var t=this;if(this._resetAABox&&(this._rebuildAABox(),this._resetAABox=!1),this._boundsOutOfDate||this._geomDirty){m.initEmpty(this._aabox);var e=g.create(),r=this.globalXform;if(this._convexHull.forEach(function(n){m.encapsulatePt(t._aabox,t._aabox,g.transformMat2d(e,t._verts[n],r))}),this._boundsOutOfDate=!1,this._geomDirty){var n=g.create();n[0]=this._verts[this._extentIndices[0]][0]+.5*(this._verts[this._extentIndices[2]][0]-this._verts[this._extentIndices[0]][0]),n[1]=this._verts[this._extentIndices[1]][1]+.5*(this._verts[this._extentIndices[3]][1]-this._verts[this._extentIndices[1]][1]),this.pivot=n,this._geomDirty=!1}}}},{key:"_draw",value:function(t){var e=!1;if(this._verts.length>=2){t.setTransform(1,0,0,1,0,0);var r=g.create();g.transformMat2d(r,this._verts[0],this._fullXform),t.moveTo(r[0],r[1]);for(var n=1;n<this._verts.length;n+=1)g.transformMat2d(r,this._verts[n],this._fullXform),t.lineTo(r[0],r[1]);e=!0}return e}},{key:"toJSON",value:function(){return Object.assign({type:"PolyLine",verts:this.vertsRef.map(function(t){return[t[0],t[1]]})},s(_(e.prototype),"toJSON",this).call(this))}}]),e}(x.a);E.aaboxEncapsulatePt=v},function(t,e,r){"use strict";function n(){var t=new i.ARRAY_TYPE(9);return i.ARRAY_TYPE!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[5]=0,t[6]=0,t[7]=0),t[0]=1,t[4]=1,t[8]=1,t}e.a=n;var i=r(1)},function(t,e,r){"use strict";function n(t,e){return t[0]=e[12],t[1]=e[13],t[2]=e[14],t}function i(t,e){var r=e[0]+e[5]+e[10],n=0;return r>0?(n=2*Math.sqrt(r+1),t[3]=.25*n,t[0]=(e[6]-e[9])/n,t[1]=(e[8]-e[2])/n,t[2]=(e[1]-e[4])/n):e[0]>e[5]&&e[0]>e[10]?(n=2*Math.sqrt(1+e[0]-e[5]-e[10]),t[3]=(e[6]-e[9])/n,t[0]=.25*n,t[1]=(e[1]+e[4])/n,t[2]=(e[8]+e[2])/n):e[5]>e[10]?(n=2*Math.sqrt(1+e[5]-e[0]-e[10]),t[3]=(e[8]-e[2])/n,t[0]=(e[1]+e[4])/n,t[1]=.25*n,t[2]=(e[6]+e[9])/n):(n=2*Math.sqrt(1+e[10]-e[0]-e[5]),t[3]=(e[1]-e[4])/n,t[0]=(e[8]+e[2])/n,t[1]=(e[6]+e[9])/n,t[2]=.25*n),t}e.b=n,e.a=i;r(1)},function(t,e,r){"use strict";function n(){var t=new l.ARRAY_TYPE(4);return l.ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t[3]=1,t}function i(t,e,r){r*=.5;var n=Math.sin(r);return t[0]=n*e[0],t[1]=n*e[1],t[2]=n*e[2],t[3]=Math.cos(r),t}function o(t,e,r){r*=.5;var n=e[0],i=e[1],o=e[2],a=e[3],s=Math.sin(r),c=Math.cos(r);return t[0]=n*c+a*s,t[1]=i*c+o*s,t[2]=o*c-i*s,t[3]=a*c-n*s,t}function a(t,e,r){r*=.5;var n=e[0],i=e[1],o=e[2],a=e[3],s=Math.sin(r),c=Math.cos(r);return t[0]=n*c-o*s,t[1]=i*c+a*s,t[2]=o*c+n*s,t[3]=a*c-i*s,t}function s(t,e,r){r*=.5;var n=e[0],i=e[1],o=e[2],a=e[3],s=Math.sin(r),c=Math.cos(r);return t[0]=n*c+i*s,t[1]=i*c-n*s,t[2]=o*c+a*s,t[3]=a*c-o*s,t}function c(t,e,r,n){var i=e[0],o=e[1],a=e[2],s=e[3],c=r[0],u=r[1],f=r[2],h=r[3],p=void 0,d=void 0,_=void 0,v=void 0,y=void 0;return d=i*c+o*u+a*f+s*h,d<0&&(d=-d,c=-c,u=-u,f=-f,h=-h),1-d>l.EPSILON?(p=Math.acos(d),_=Math.sin(p),v=Math.sin((1-n)*p)/_,y=Math.sin(n*p)/_):(v=1-n,y=n),t[0]=v*i+y*c,t[1]=v*o+y*u,t[2]=v*a+y*f,t[3]=v*s+y*h,t}function u(t,e){var r=e[0]+e[4]+e[8],n=void 0;if(r>0)n=Math.sqrt(r+1),t[3]=.5*n,n=.5/n,t[0]=(e[5]-e[7])*n,t[1]=(e[6]-e[2])*n,t[2]=(e[1]-e[3])*n;else{var i=0;e[4]>e[0]&&(i=1),e[8]>e[3*i+i]&&(i=2);var o=(i+1)%3,a=(i+2)%3;n=Math.sqrt(e[3*i+i]-e[3*o+o]-e[3*a+a]+1),t[i]=.5*n,n=.5/n,t[3]=(e[3*o+a]-e[3*a+o])*n,t[o]=(e[3*o+i]+e[3*i+o])*n,t[a]=(e[3*a+i]+e[3*i+a])*n}return t}e.b=n,e.e=o,e.f=a,e.g=s,r.d(e,"a",function(){return d}),r.d(e,"c",function(){return _}),r.d(e,"d",function(){return v}),r.d(e,"h",function(){return y});var l=r(1),f=r(14),h=r(17),p=r(18),d=(p.b,p.g,p.c),_=(p.l,p.a,p.k,p.d),v=(p.i,p.h),y=p.m,b=p.j;p.f,p.e,function(){var t=h.a(),e=h.d(1,0,0),r=h.d(0,1,0)}(),function(){var t=n(),e=n()}(),function(){var t=f.a()}()},function(t,e,r){"use strict";function n(){var t=new u.ARRAY_TYPE(3);return u.ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function i(t){var e=t[0],r=t[1],n=t[2];return Math.sqrt(e*e+r*r+n*n)}function o(t,e,r){var n=new u.ARRAY_TYPE(3);return n[0]=t,n[1]=e,n[2]=r,n}function a(t,e){var r=e[0],n=e[1],i=e[2],o=r*r+n*n+i*i;return o>0&&(o=1/Math.sqrt(o),t[0]=e[0]*o,t[1]=e[1]*o,t[2]=e[2]*o),t}function s(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]}function c(t,e,r){var n=e[0],i=e[1],o=e[2],a=r[0],s=r[1],c=r[2];return t[0]=i*c-o*s,t[1]=o*a-n*c,t[2]=n*s-i*a,t}e.a=n,e.d=o,e.f=a,e.c=s,e.b=c,r.d(e,"e",function(){return l});var u=r(1),l=i;!function(){var t=n()}()},function(t,e,r){"use strict";function n(){var t=new y.ARRAY_TYPE(4);return y.ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}function i(t){var e=new y.ARRAY_TYPE(4);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e}function o(t,e,r,n){var i=new y.ARRAY_TYPE(4);return i[0]=t,i[1]=e,i[2]=r,i[3]=n,i}function a(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}function s(t,e,r,n,i){return t[0]=e,t[1]=r,t[2]=n,t[3]=i,t}function c(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t[2]=e[2]+r[2],t[3]=e[3]+r[3],t}function u(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t}function l(t){var e=t[0],r=t[1],n=t[2],i=t[3];return Math.sqrt(e*e+r*r+n*n+i*i)}function f(t){var e=t[0],r=t[1],n=t[2],i=t[3];return e*e+r*r+n*n+i*i}function h(t,e){var r=e[0],n=e[1],i=e[2],o=e[3],a=r*r+n*n+i*i+o*o;return a>0&&(a=1/Math.sqrt(a),t[0]=r*a,t[1]=n*a,t[2]=i*a,t[3]=o*a),t}function p(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]+t[3]*e[3]}function d(t,e,r,n){var i=e[0],o=e[1],a=e[2],s=e[3];return t[0]=i+n*(r[0]-i),t[1]=o+n*(r[1]-o),t[2]=a+n*(r[2]-a),t[3]=s+n*(r[3]-s),t}function _(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]}function v(t,e){var r=t[0],n=t[1],i=t[2],o=t[3],a=e[0],s=e[1],c=e[2],u=e[3];return Math.abs(r-a)<=y.EPSILON*Math.max(1,Math.abs(r),Math.abs(a))&&Math.abs(n-s)<=y.EPSILON*Math.max(1,Math.abs(n),Math.abs(s))&&Math.abs(i-c)<=y.EPSILON*Math.max(1,Math.abs(i),Math.abs(c))&&Math.abs(o-u)<=y.EPSILON*Math.max(1,Math.abs(o),Math.abs(u))}e.b=i,e.g=o,e.c=a,e.l=s,e.a=c,e.k=u,e.h=l,e.m=f,e.j=h,e.d=p,e.i=d,e.f=_,e.e=v;var y=r(1);!function(){var t=n()}()},function(t,e,r){"use strict";function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function o(t,e,r){return e&&i(t.prototype,e),r&&i(t,r),t}function a(t){var e=Object(s.a)(t,"fillColor");return Object(c.a)(null,u,function(){function t(){n(this,t)}return o(t,[{key:"initializer",value:function(t){this._fillColor=new e("red",this),this._initFillStyleFromOptions(t)}}]),t}())}r.d(e,"b",function(){return u}),e.a=a;var s=r(20),c=r(7),u=function(){function t(e){n(this,t),this.initializer(e)}return o(t,[{key:"_initFillStyleFromOptions",value:function(t){t&&(void 0!==t.fillColor&&(this.fillColor=t.fillColor),void 0!==t.fillOpacity&&(this.fillOpacity=t.fillOpacity))}},{key:"initializer",value:function(t){this._fillColor=new s.b("black"),this._initFillStyleFromOptions(t)}},{key:"fillColor",get:function(){return this._fillColor.value},set:function(t){return this._fillColor.value=t,this}},{key:"fillOpacity",get:function(){return this._fillColor.opacity},set:function(t){return this._fillColor.opacity=t,this}},{key:"packedFillColor",get:function(){return this._fillColor.packedValue},set:function(t){return this._fillColor.packedValue=t,this}},{key:"isFillVisible",value:function(){return this._fillColor.opacity>0}},{key:"isTransparent",value:function(){return this._fillColor.isTransparent()}},{key:"setFillCtx",value:function(t){t.fillStyle=this.fillColor}}],[{key:"copyFillStyle",value:function(t,e){void 0===t.packedFillColor?(void 0!==t.fillColor&&(e.fillColor=t.fillColor),void 0!==t.fillOpacity&&(e.fillOpacity=t.fillOpacity)):e.packedFillColor=t.packedFillColor}},{key:"compareFillStyle",value:function(t,e){var r=t.isFillVisible(),n=e.isFillVisible();return r!==n?r-n:t.packedFillColor-e.packedFillColor}},{key:"toJSON",value:function(t){return{fillColor:t.fillColor}}}]),t}()},function(t,e,r){"use strict";function n(t){"@babel/helpers - typeof";return(n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function i(t,e,r){return(i="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,r){var n=o(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(r):i.value}})(t,e,r||t)}function o(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=h(t)););return t}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&s(t,e)}function s(t,e){return(s=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function c(t){var e=f();return function(){var r,n=h(t);if(e){var i=h(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return u(this,r)}}function u(t,e){return!e||"object"!==n(e)&&"function"!=typeof e?l(t):e}function l(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function f(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(t){return!1}}function h(t){return(h=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function p(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function d(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function _(t,e,r){return e&&d(t.prototype,e),r&&d(t,r),t}function v(t){return(255&t)/255}function y(t){return w.a.floor(255*w.a.clamp01(t))}function b(t){return"rgba(".concat(t>>>24,", ").concat((16711680&t)>>16,", ").concat((65280&t)>>8,", ").concat(v(t),")")}function m(t){if("string"!=typeof t)throw new Error("".concat(t," is not a valid color string"));var e=0,r=null;if(r=t.match(k))e=255,e|=w.a.clamp(Number.parseInt(r[3],10),0,255)<<8,e|=w.a.clamp(Number.parseInt(r[2],10),0,255)<<16,e|=w.a.clamp(Number.parseInt(r[1],10),0,255)<<24;else if(r=t.match(S))e=y(Number.parseFloat(r[4],10)),e|=w.a.clamp(Number.parseInt(r[3],10),0,255)<<8,e|=w.a.clamp(Number.parseInt(r[2],10),0,255)<<16,e|=w.a.clamp(Number.parseInt(r[1],10),0,255)<<24;else if(r=t.match(O))e=255,e|=w.a.clamp(Number.parseInt(r[3],16),0,255)<<8,e|=w.a.clamp(Number.parseInt(r[2],16),0,255)<<16,e|=w.a.clamp(Number.parseInt(r[1],16),0,255)<<24;else{if(!x.has(t))throw new Error("".concat(t," is not a valid color string"));r=x.get(t).match(O),e=255,e|=w.a.clamp(Number.parseInt(r[3],16),0,255)<<8,e|=w.a.clamp(Number.parseInt(r[2],16),0,255)<<16,e|=w.a.clamp(Number.parseInt(r[1],16),0,255)<<24}return e}function g(t,e){return function(r){function n(){return p(this,n),o.apply(this,arguments)}a(n,r);var o=c(n);return _(n,[{key:"initializer",value:function(t,e){this._eventHandler=e,i(h(n.prototype),"initializer",this).call(this,t)}},{key:"_checkPackedColorChanged",value:function(r){if(r!==this._color){var n=this._color,i=v(n),o=v(r);this._color=r,this._eventHandler.fire(t,{attr:e,prevVal:b(n),currVal:b(this._color)}),o!==i&&this._eventHandler.fire(t,{attr:"opacity",prevVal:i,currVal:o})}}},{key:"value",get:function(){return b(this._color)},set:function(t){var e=m(t);return this._checkPackedColorChanged(e),this}},{key:"packedValue",get:function(){return this._color},set:function(t){var e=0;return e|=t,this._checkPackedColorChanged(e),this}},{key:"opacity",get:function(){return v(this._color)},set:function(e){if("number"!=typeof e)throw new Error("Opacity must be a number between 0-1");var r=255&this._color,n=y(e);return n!==r&&(this._color&=4294967040,this._color|=n,this._eventHandler.fire(t,{attr:"opacity",prevVal:r/255,currVal:n/255})),this}}]),n}(E)}r.d(e,"b",function(){return E}),e.a=g;var w=r(8),x=new Map([["aliceblue","#F0F8FF"],["antiquewhite","#FAEBD7"],["aqua","#00FFFF"],["aquamarine","#7FFFD4"],["azure","#F0FFFF"],["beige","#F5F5DC"],["bisque","#FFE4C4"],["black","#000000"],["blanchedalmond","#FFEBCD"],["blue","#0000FF"],["blueviolet","#8A2BE2"],["brown","#A52A2A"],["burlywood","#DEB887"],["cadetblue","#5F9EA0"],["chartreuse","#7FFF00"],["chocolate","#D2691E"],["coral","#FF7F50"],["cornflowerblue","#6495ED"],["cornsilk","#FFF8DC"],["crimson","#DC143C"],["cyan","#00FFFF"],["darkblue","#00008B"],["darkcyan","#008B8B"],["darkgoldenrod","#B8860B"],["darkgray","#A9A9A9"],["darkgreen","#006400"],["darkkhaki","#BDB76B"],["darkmagenta","#8B008B"],["darkolivegreen","#556B2F"],["darkorange","#FF8C00"],["darkorchid","#9932CC"],["darkred","#8B0000"],["darksalmon","#E9967A"],["darkseagreen","#8FBC8F"],["darkslateblue","#483D8B"],["darkslategray","#2F4F4F"],["darkturquoise","#00CED1"],["darkviolet","#9400D3"],["deeppink","#FF1493"],["deepskyblue","#00BFFF"],["dimgray","#696969"],["dodgerblue","#1E90FF"],["firebrick","#B22222"],["floralwhite","#FFFAF0"],["forestgreen","#228B22"],["fuchsia","#FF00FF"],["gainsboro","#DCDCDC"],["ghostwhite","#F8F8FF"],["gold","#FFD700"],["goldenrod","#DAA520"],["gray","#808080"],["green","#008000"],["greenyellow","#ADFF2F"],["honeydew","#F0FFF0"],["hotpink","#FF69B4"],["indianred","#CD5C5C"],["indigo","#4B0082"],["ivory","#FFFFF0"],["khaki","#F0E68C"],["lavender","#E6E6FA"],["lavenderblush","#FFF0F5"],["lawngreen","#7CFC00"],["lemonchiffon","#FFFACD"],["lightblue","#ADD8E6"],["lightcoral","#F08080"],["lightcyan","#E0FFFF"],["lightgoldenrodyellow","#FAFAD2"],["lightgray","#D3D3D3"],["lightgreen","#90EE90"],["lightpink","#FFB6C1"],["lightsalmon","#FFA07A"],["lightseagreen","#20B2AA"],["lightskyblue","#87CEFA"],["lightslategray","#778899"],["lightsteelblue","#B0C4DE"],["lightyellow","#FFFFE0"],["lime","#00FF00"],["limegreen","#32CD32"],["linen","#FAF0E6"],["magenta","#FF00FF"],["maroon","#800000"],["mediumaquamarine","#66CDAA"],["mediumblue","#0000CD"],["mediumorchid","#BA55D3"],["mediumpurple","#9370DB"],["mediumseagreen","#3CB371"],["mediumslateblue","#7B68EE"],["mediumspringgreen","#00FA9A"],["mediumturquoise","#48D1CC"],["mediumvioletred","#C71585"],["midnightblue","#191970"],["mintcream","#F5FFFA"],["mistyrose","#FFE4E1"],["moccasin","#FFE4B5"],["navajowhite","#FFDEAD"],["navy","#000080"],["oldlace","#FDF5E6"],["olive","#808000"],["olivedrab","#6B8E23"],["orange","#FFA500"],["orangered","#FF4500"],["orchid","#DA70D6"],["palegoldenrod","#EEE8AA"],["palegreen","#98FB98"],["paleturquoise","#AFEEEE"],["palevioletred","#DB7093"],["papayawhip","#FFEFD5"],["peachpuff","#FFDAB9"],["peru","#CD853F"],["pink","#FFC0CB"],["plum","#DDA0DD"],["powderblue","#B0E0E6"],["purple","#800080"],["rebeccapurple","#663399"],["red","#FF0000"],["rosybrown","#BC8F8F"],["royalblue","#4169E1"],["saddlebrown","#8B4513"],["salmon","#FA8072"],["sandybrown","#F4A460"],["seagreen","#2E8B57"],["seashell","#FFF5EE"],["sienna","#A0522D"],["silver","#C0C0C0"],["skyblue","#87CEEB"],["slateblue","#6A5ACD"],["slategray","#708090"],["snow","#FFFAFA"],["springgreen","#00FF7F"],["steelblue","#4682B4"],["tan","#D2B48C"],["teal","#008080"],["thistle","#D8BFD8"],["tomato","#FF6347"],["turquoise","#40E0D0"],["violet","#EE82EE"],["wheat","#F5DEB3"],["white","#FFFFFF"],["whitesmoke","#F5F5F5"],["yellow","#FFFF00"],["yellowgreen","#9ACD32"]]),k=/^rgb\s*\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)\s*$/i,S=/^rgba\s*\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*([0,1](?:\.\d*)?)\s*\)\s*$/i,O=/^#([0-9,a-f,A-F]{2})([0-9,a-f,A-F]{2})([0-9,a-f,A-F]{2})\s*$/i,E=function(){function t(e){p(this,t);for(var r=arguments.length,n=new Array(r>1?r-1:0),i=1;i<r;i++)n[i-1]=arguments[i];this.initializer.apply(this,[e].concat(n))}return _(t,[{key:"initializer",value:function(t){this._color=0,t&&(this.value=t)}},{key:"value",get:function(){return b(this._color)},set:function(t){return this._color=m(t),this}},{key:"packedValue",get:function(){return this._color},set:function(t){return this._color=0,this._color|=t,this}},{key:"opacity",get:function(){return v(this._color)},set:function(t){if("number"!=typeof t)throw new Error("Opacity must be a number between 0-1");var e=255&this._color,r=y(t);return r!==e&&(this._color&=4294967040,this._color|=r),this}},{key:"isTransparent",value:function(){return v(this._color)<1}}]),t}()},function(t,e,r){"use strict";function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function o(t,e,r){return e&&i(t.prototype,e),r&&i(t,r),t}function a(t){if("number"!=typeof t)throw new Error("Stroke width must be a number")}function s(t){var e=-1;if("string"!=typeof t||(e=_.indexOf(t.toLowerCase()))<0)throw new Error("Line join must be a string and must be one of [".concat(_.join(", "),"]"));return e}function c(t){var e=-1;if("string"!=typeof t||(e=y.indexOf(t.toLowerCase()))<0)throw new Error("Line cap must be a string and must be one of [".concat(y.join(", "),"]"));return e}function u(t){if(!t||!Array.isArray(t)||t.length%2!=0)throw new Error("The dash pattern must be an array with an even number of numbers (or an empty array)")}function l(t){if("number"!=typeof t)throw new Error("The dash offset must be a number")}function f(t){var e=Object(h.a)(t,"strokeColor");return Object(p.a)(null,b,function(){function r(){n(this,r)}return o(r,[{key:"initializer",value:function(t){this._strokeColor=new e("black",this),this._strokeWidth=0,this._lineJoin=d.MITER,this._lineCap=v.BUTT,this._dashPattern=[],this._dashOffset=0,this._initStrokeStyleFromOptions(t)}},{key:"strokeWidth",get:function(){return this._strokeWidth},set:function(e){if(a(e),e!==this._strokeWidth){var r=this._strokeWidth;this._strokeWidth=e,this.fire(t,{attr:"strokeWidth",prevVal:r,curral:this._strokeWidth})}return this}},{key:"lineJoin",get:function(){return _[this._lineJoin]},set:function(e){var r=s(e);if(r!==this._lineJoin){var n=this._lineJoin;this._lineJoin=r,this.fire(t,{attr:"lineJoin",prevVal:n,curral:this._lineJoin})}return this}},{key:"lineCap",get:function(){return y[this._lineCap]},set:function(e){var r=c(e);if(r!==this._lineCap){var n=this._lineCap;this._lineCap=r,this.fire(t,{attr:"lineCap",prevVal:n,curral:this._lineCap})}return this}},{key:"dashPattern",get:function(){return this._dashPattern.slice()},set:function(e){u(e);var r=!1;if(e.length===this._dashPattern.length){for(var n=0;n<e.length;n+=1)if(e[n]!==this._dashPattern[n]){r=!0;break}}else r=!0;if(r){var i=this._dashPattern;this._dashPattern=e.slice(),this.fire(t,{attr:"dashPattern",prevVal:i,curral:this._dashPattern.slice()})}return this}},{key:"dashOffset",get:function(){return this._dashOffset},set:function(e){if(l(e),e!==this._dashOffset){var r=this._dashOffset;this._dashOffset=e,this._dashPattern.length&&this.fire(t,{attr:"dashOffset",prevVal:r,curral:this._dashOffset})}return this}}]),r}())}r.d(e,"b",function(){return b}),e.a=f;var h=r(20),p=r(7),d={MITER:0,BEVEL:1,ROUND:2},_=["miter","bevel","round"],v={BUTT:0,SQUARE:1,ROUND:2},y=["butt","square","round"],b=function(){function t(e){n(this,t),this.initializer(e)}return o(t,[{key:"_initStrokeStyleFromOptions",value:function(t){t&&(void 0!==t.strokeColor&&(this.strokeColor=t.strokeColor),void 0!==t.strokeOpacity&&(this.strokeOpacity=t.strokeOpacity),void 0!==t.strokeWidth&&(this.strokeWidth=t.strokeWidth),void 0!==t.lineMiter&&(this.lineJoin=t.lineMiter),void 0!==t.lineCap&&(this.lineCap=t.lineCap),void 0!==t.dashPattern&&(this.dashPattern=t.dashPattern),void 0!==t.dashOffset&&(this.dashOffset=t.dashOffset))}},{key:"initializer",value:function(t){this._strokeColor=new h.b("black"),this._strokeWidth=0,this._lineJoin=d.MITER,this._lineCap=v.BUTT,this._dashPattern=[],this._dashOffset=0,this._initStrokeStyleFromOptions(t)}},{key:"strokeColor",get:function(){return this._strokeColor.value},set:function(t){return this._strokeColor.value=t,this}},{key:"strokeOpacity",get:function(){return this._strokeColor.opacity},set:function(t){this._strokeColor.opacity=t}},{key:"packedStrokeColor",get:function(){return this._strokeColor.packedValue},set:function(t){this._strokeColor.packedValue=t}},{key:"strokeWidth",get:function(){return this._strokeWidth},set:function(t){return a(t),this._strokeWidth=t,this}},{key:"lineJoin",get:function(){return _[this._lineJoin]},set:function(t){var e=s(t);return this._lineJoin=e,this}},{key:"lineCap",get:function(){return y[this._lineJoin]},set:function(t){var e=c(t);return this._lineCap=e,this}},{key:"dashPattern",get:function(){return this._dashPattern.slice()},set:function(t){return u(t),this._dashPattern=t.slice(),this}},{key:"dashOffset",get:function(){return this._dashOffset},set:function(t){return l(t),this._dashOffset=t,this}},{key:"isStrokeVisible",value:function(){return this._strokeColor.opacity>0&&this._strokeWidth>0}},{key:"isTransparent",value:function(){return this._strokeColor.isTransparent()}},{key:"setStrokeCtx",value:function(t){t.strokeStyle=this.strokeColor,t.lineWidth=this._strokeWidth,t.lineJoin=this._lineJoin,t.lineCap=this._lineCap,t.setLineDash(this._dashPattern),t.lineDashOffset=this._dashOffset}}],[{key:"copyStrokeStyle",value:function(t,e){void 0===t.packedStrokeColor?(void 0!==t.strokeColor&&(e.strokeColor=t.strokeColor),void 0!==t.strokeOpacity&&(e.strokeOpacity=t.strokeOpacity)):e.packedStrokeColor=t.packedStrokeColor,void 0!==t.strokeWidth&&(e.strokeWidth=t.strokeWidth),void 0!==t.lineJoin&&(e.lineJoin=t.lineJoin),void 0!==t.lineCap&&(e.lineCap=t.lineCap),void 0!==t.dashPattern&&(e.dashPattern=t.dashPattern),void 0!==t.dashOffset&&(e.dashOffset=t.dashOffset)}},{key:"compareStrokeStyle",value:function(t,e){var r=t.isStrokeVisible(),n=e.isStrokeVisible();if(r!==n)return r-n;if(r=t.packedStrokeColor,n=e.packedStrokeColor,r!==n)return r-n;if(r=t.strokeWidth,n=e.strokeWidth,r!==n)return r-n;if(r=t._lineJoin,n=e._lineJoin,r!==n)return r-n;if(r=t._lineCap,n=e._lineCap,r!==n)return r-n;if(r=t._dashPattern,n=e._dashPattern,r.length===n.length&&r.length>0){for(var i=0;i<r.length;i+=1)if(r[i]!==n[i])return r[i]-n[i];return t.dashOffset-e.dashOffset}return r.length-n.length}},{key:"toJSON",value:function(t){return{strokeColor:t.strokeColor,strokeWidth:t.strokeWidth,lineJoin:t.lineJoin,lineCap:t.lineCap,dashPattern:t.dashPattern,dashOffset:t.dashOffset}}}]),t}()},function(t,e,r){"use strict";function n(t){"@babel/helpers - typeof";return(n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function a(t,e,r){return e&&o(t.prototype,e),r&&o(t,r),t}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&c(t,e)}function c(t,e){return(c=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function u(t){var e=h();return function(){var r,n=p(t);if(e){var i=p(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return l(this,r)}}function l(t,e){return!e||"object"!==n(e)&&"function"!=typeof e?f(t):e}function f(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function h(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(t){return!1}}function p(t){return(p=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function d(t,e){t&&" ".concat(t.className," ").indexOf(" ".concat(e," "))<0&&(t.className+=(t.className?" ":"")+e)}function _(t){var e=document.createElement("div");d(e,"mapd-draw-canvas-container");var r=document.createElement("canvas"),n=r.getContext("2d"),i=b.a(n);return d(r,"mapd-draw-canvas"),r.style.position="absolute",r.style.pointerEvents="none",e.appendChild(r),t.appendChild(e),{canvasContainer:e,canvas:r,canvasContext:n,ratio:i}}function v(t,e,r,n,i){t.forEach(function(t){e.set(t,{shapeObj:t,shapeId:r.shapeId,shapeIdx:-1}),t.on(["changed:order","changed:visibility","changed:style"],n),t.on(["changed:geom","changed:visibility","changed:xform"],i),r.shapeId+=1})}function y(t,e,r,n){var i=[];return t.forEach(function(t){var o=e.get(t);o&&i.push(o.shapeIdx),e.delete(t),t.off(["changed"],[r,n])}),i}r.d(e,"a",function(){return A});var b=r(33),m=r(0),g=r(9),w=r(10),x=r(34),k=r(35),S=r(12),O=r(36),E=r.n(O),M=["mousedown","mouseup","mousemove","click","dblclick","mouseover","mouseout"],C=["top","bottom","left","right"],P={MOUSEDOWN:"mousedown",MOUSEUP:"mouseup",MOUSEMOVE:"mousemove",CLICK:"click",DBLCLICK:"dblclick",MOUSEOVER:"mouseover",MOUSEOUT:"mouseout",SHAPE_ADD:"shape:add",SHAPE_DELETE:"shape:delete"},j=function(t){function e(){var t;i(this,e);for(var n=arguments.length,o=new Array(n),a=0;a<n;a++)o[a]=arguments[a];return t=r.call.apply(r,[this].concat(o)),t._defaults={packedFillColor:t.packedFillColor,packedStrokeColor:t.packedStrokeColor,strokeWidth:t.strokeWidth,lineJoin:t.lineJoin,lineCap:t.lineCap,dashPattern:t.dashPattern,dashOffset:t.dashOffset},t}s(e,t);var r=u(e);return a(e,[{key:"setFillStyle",value:function(t,e){e.packedFillColor!==this.packedFillColor&&(this.packedFillColor=e.packedFillColor,t.fillStyle=this.fillColor)}},{key:"setStrokeStyle",value:function(t,e){e.packedStrokeColor!==this.packedStrokeColor&&(this.packedStrokeColor=e.packedStrokeColor,t.strokeStyle=this.strokeColor),e.strokeWidth!==this._strokeWidth&&(this.strokeWidth=e.strokeWidth,t.lineWidth=this._strokeWidth),e.lineJoin!==this._lineJoin&&(this.lineJoin=e.lineJoin,t.lineJoin=this._lineJoin),e.lineCap!==this._lineCap&&(this.lineCap=e.lineCap,t.lineCap=this._lineCap);var r=e._dashPattern,n=!1;if(r.length===this._dashPattern.length){for(var i=0;i<r.length;i+=1)if(r[i]!==this._dashPattern[i]){n=!0;break}}else n=!0;n&&(this.dashPattern=r,t.setLineDash(this._dashPattern)),e.dashOffset!==this._dashOffset&&(this.dashOffset=e.dashOffset,t.lineDashOffset=this._dashOffset)}},{key:"applyDefaults",value:function(t){var e=this;Object.getOwnPropertyNames(this._defaults).forEach(function(t){e[t]=e._defaults[t]}),this.setFillCtx(t),this.setStrokeCtx(t)}}]),e}(w.a),A=function(t){function e(t,n){var o;return i(this,e),o=r.call(this),o._init(t,n),o}s(e,t);var r=u(e);return a(e,[{key:"destroy",value:function(){var t=this;this._destroyCanvas(),this._objects&&(this._objects.forEach(function(e,r){r.off("changed",[t._reorderCb,t._redrawCb])}),this._objects.clear(),this._sortedObjs=[],this._reorderedObjIdxs.clear())}},{key:"_resize",value:function(t){var e=0;this._parent.offsetWidth&&(e=Math.max(e,this._parent.offsetWidth-this._margins.left-this._margins.right));var r=0;if(this._parent.offsetHeight&&(r=Math.max(r,this._parent.offsetHeight-this._margins.top-this._margins.bottom)),this._drawCanvas.width=e*this._pixelRatio,this._drawCanvas.height=r*this._pixelRatio,this._drawCanvas.style.left="".concat(this._margins.left,"px"),this._drawCanvas.style.top="".concat(this._margins.top,"px"),this._drawCanvas.style.width="".concat(e,"px"),this._drawCanvas.style.height="".concat(r,"px"),this._camera);else{var n=t&&t.projectionDimensions?t.projectionDimensions:[e,r];this._camera=new k.a([0,0,e,r],n,!!t.flipY&&Boolean(t.flipY)),this._camera.setPosition(t&&t.cameraPosition?t.cameraPosition:[e/2,r/2]),this._camera.on("changed",this._rerenderCb)}this._rerenderCb()}},{key:"_mousedownCB",value:function(t){t.target===this._parent&&this.fire("mousedown",{originalEvent:t})}},{key:"_mouseupCB",value:function(t){t.target===this._parent&&this.fire("mouseup",{originalEvent:t})}},{key:"_mousemoveCB",value:function(t){t.target===this._parent&&this.fire("mousemove",{originalEvent:t})}},{key:"_clickCB",value:function(t){t.target===this._parent&&this.fire("click",{originalEvent:t})}},{key:"_dblclickCB",value:function(t){t.target===this._parent&&this.fire("dblclick",{originalEvent:t})}},{key:"_mouseoverCB",value:function(t){t.target===this._parent&&this.fire("mouseover",{originalEvent:t})}},{key:"_mouseoutCB",value:function(t){t.target===this._parent&&this.fire("mouseout",{originalEvent:t})}},{key:"_enableEvents",value:function(){this.registerEvents(M);for(var t=M.map(function(t){return"_".concat(t,"CB")}),e=0;e<M.length;e+=1)document.addEventListener(M[e],this[t[e]],!0)}},{key:"_disableEvents",value:function(){for(var t=M.map(function(t){return"_".concat(t,"CB")}),e=0;e<M.length;e+=1)document.removeEventListener(M[e],this[t[e]],!0)}},{key:"_initCanvas",value:function(t,e){var r=this,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;this._margins=e&&e.margins?Object.assign({},e.margins):{},C.forEach(function(t){"number"!=typeof r._margins[t]&&(r._margins[t]=0)});var i=_(t),o=i.canvasContainer,a=i.canvas,s=i.canvasContext,c=i.ratio;this._container=o,this._drawCanvas=a,this._drawCtx=s,this._pixelRatio=c,this._parent=t,Object(x.a)(["_resize"],this),this._resize(e),this._resizeSensor=new E.a(t,this._resize),(n||null===n&&e&&e.enableEvents)&&this._enableEvents()}},{key:"_destroyCanvas",value:function(){this._drawCanvas&&this._disableEvents(),this._parent&&(this._parent.removeChild(this._drawCanvas),this._resizeSensor&&this._resizeSensor.detach(this._parent,this._resize)),this._drawCanvas=null,this._drawCtx=null,this._parent=null}},{key:"_init",value:function(t,e){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;this.registerEvents([P.SHAPE_ADD,P.SHAPE_DELETE]),Object(x.a)(["_reorderCb","_rerenderCb"],this),Object(x.a)(["_mousedownCB","_mouseupCB","_mousemoveCB","_clickCB","_dblclickCB","_mouseoverCB","_mouseoutCB"],this),this._renderFrameCb=this.renderAll.bind(this),this._renderRequestTime=0,this._ids={shapeId:1},this._objects=new Map,this._sortedObjs=[],this._reorderedObjIdxs=new Set,this._initCanvas(t,e,r),this._styleState=new j({fillColor:"red"})}},{key:"getContainer",value:function(){return this._parent}},{key:"getCanvasContainer",value:function(){return this._container}},{key:"getCanvas",value:function(){return this._drawCanvas}},{key:"sortedShapes",get:function(){return this._reorderedObjIdxs.size&&(console.assert(this._sortedObjs.length===this._objects.size,"Size mismatch when rendering objets. Something got out of sync - sorted objs length: ".concat(this._sortedObjs.length,", objects length: ").concat(this._objects.size)),this._sortedObjs.sort(g.a.shapeCompare),this._reorderedObjIdxs.clear()),this._sortedObjs}},{key:"margins",get:function(){var t=this,e={};return C.forEach(function(r){e[r]=t._margins[r]}),e},set:function(t){var e=this;C.forEach(function(r){"number"==typeof t[r]&&t[r]!==e._margins[r]&&(e._margins[r]=t.prop)}),this._resize()}},{key:"camera",get:function(){return this._camera}},{key:"viewport",get:function(){return this._camera.viewport},set:function(t){this._camera.viewport=t}},{key:"projectionDimensions",get:function(){return this._camera.projectionDimensions},set:function(t){return this._camera.projectionDimensions=t,this}},{key:"cameraPosition",get:function(){return this._camera.getPosition()},set:function(t){return this._camera.setPosition(t),this}},{key:"project",value:function(t,e){var r=this._camera.screenToWorldMatrix;return m.transformMat2d(t,e,r)}},{key:"unproject",value:function(t,e){var r=this._camera.worldToScreenMatrix;return m.transformMat2d(t,e,r)}},{key:"hasShape",value:function(t){return this._objects.has(t)}},{key:"addShape",value:function(t){var e=t;Array.isArray(e)||(e=[t]),v(e,this._objects,this._ids,this._reorderCb,this._rerenderCb),this.fire("shape:add",{shape:e});var r={target:e};return this._reorderCb(r),this}},{key:"deleteShape",value:function(t){var e=t;Array.isArray(e)||(e=[t]);for(var r=y(e,this._objects,this._reorderCb,this._rerenderCb),n=-1,i=0;i<e.length;i+=1)(n=this._sortedObjs.indexOf(e[i]))>=0&&this._sortedObjs.splice(n,1),this._reorderedObjIdxs.add(r[i]);return this._rerenderCb(),this.fire("shape:delete",{shape:e}),this}},{key:"deleteAllShapes",value:function(){return this.deleteShape(this.sortedShapes.slice()),this}},{key:"moveShapeToTop",value:function(t){if(this._objects.has(t)){var e=this.sortedShapes,r=e[e.length-1].zIndex;t.zIndex=r+1}}},{key:"moveShapeToBack",value:function(t){if(this._objects.has(t)){var e=this.sortedShapes,r=e[0].zIndex;t.zIndex=r}}},{key:"getShapesAsJSON",value:function(){return this.sortedShapes.map(function(t){return t.toJSON()})}},{key:"_rerenderCb",value:function(){window.requestAnimationFrame(this._renderFrameCb)}},{key:"_reorderCb",value:function(t){var e=this,r=t.target;Array.isArray(r)||(r=[t.target]),r.forEach(function(t){console.assert(t,"A changed event doesn't have an object");var r=e._objects.get(t);console.assert(r,"A changed event target isn't in the list of shapes ".concat(t)),r.shapeIdx<0&&(r.shapeIdx=e._sortedObjs.push(t)-1),e._reorderedObjIdxs.add(r.shapeIdx)}),this._rerenderCb()}},{key:"_renderShapes",value:function(t,e,r){var n=this,i=r.worldToScreenMatrix;e.forEach(function(e){e.visible&&e.render(t,i,n._styleState)})}},{key:"renderAll",value:function(t){if(t){if(t<=this._renderRequestTime)return;this._renderRequestTime=t}else this._renderRequestTime=performance.now();var e=this._drawCtx;if(e.clearRect(0,0,this._drawCanvas.offsetWidth,this._drawCanvas.offsetHeight),this._objects.size){e.save();var r=this.sortedShapes;this._styleState.applyDefaults(e),this._renderShapes(e,r,this._camera),e.restore()}}}]),e}(S.a);A.EventConstants=P},function(t,e,r){"use strict";function n(t,e,r){return(e[o]-t[o])*(r[a]-t[a])-(r[o]-t[o])*(e[a]-t[a])}function i(t){var e=[],r=t.length;if(r<3){for(var i=0;i<r;i+=1)e[i]=i;return e}var o=new Array(2*r+1);o.fill(-1);var a=r-2,s=a+3;o[a]=o[s]=2,n(t[0],t[1],t[2])>0?(o[a+1]=0,o[a+2]=1):(o[a+1]=1,o[a+2]=0);for(var c=3;c<r;c+=1)if(n(t[o[a]],t[o[a+1]],t[c])<=0||n(t[o[s-1]],t[o[s]],t[c])<=0){for(;o[a]>=0&&o[a+1]>=0&&n(t[o[a]],t[o[a+1]],t[c])<=0;)a+=1;for(a-=1,o[a]=c;o[s]>=0&&o[s+1]>=0&&n(t[o[s-1]],t[o[s]],t[c])<=0;)s-=1;s+=1,o[s]=c}var u=0;for(u=0;u<=s-a-1;u+=1)e[u]=o[a+u];return o[a+u]!==e[0]&&(e[u]=o[a+u]),e}e.a=i;var o=0,a=1},function(t,e,r){"use strict";function n(t){"@babel/helpers - typeof";return(n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function a(t,e,r){return e&&o(t.prototype,e),r&&o(t,r),t}function s(t,e,r){return(s="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,r){var n=c(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(r):i.value}})(t,e,r||t)}function c(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=_(t)););return t}function u(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&l(t,e)}function l(t,e){return(l=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function f(t){var e=d();return function(){var r,n=_(t);if(e){var i=_(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return h(this,r)}}function h(t,e){return!e||"object"!==n(e)&&"function"!=typeof e?p(t):e}function p(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function d(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(t){return!1}}function _(t){return(_=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}r.d(e,"a",function(){return m});var v=r(4),y=r(9),b=r(0),m=function(t){function e(t){var n;return i(this,e),n=r.call(this,t),n._width=0,n._height=0,void 0!==t.width&&(n.width=t.width),void 0!==t.height&&(n.height=t.height),n}u(e,t);var r=f(e);return a(e,[{key:"getDimensions",value:function(){return[this._width,this._height]}},{key:"width",get:function(){return this._width},set:function(t){if("number"!=typeof t)throw new Error("Width must be a number");if(t!==this._width){var e=this._width;this._width=t,this._geomDirty=!0,this.fire("changed:geom",{attr:"width",prevVal:e,currVal:this._width})}return this}},{key:"height",get:function(){return this._height},set:function(t){if("number"!=typeof t)throw new Error("Height must be a number");if(t!==this._height){var e=this._height;this._height=t,this._geomDirty=!0,this.fire("changed:geom",{attr:"height",prevVal:e,currVal:this._height})}return this}},{key:"_updateAABox",value:function(){(this._geomDirty||this._boundsOutOfDate)&&(v.initCenterExtents(this._aabox,b.create(0,0),[this._width/2,this._height/2]),v.transformMat2d(this._aabox,this._aabox,this.globalXform),this._geomDirty=this._boundsOutOfDate=!1)}},{key:"_draw",value:function(t){t.setTransform(1,0,0,1,0,0);var e=this.width/2,r=this.height/2,n=b.create(-e,-r);b.transformMat2d(n,n,this._fullXform),t.moveTo(n[0],n[1]),b.set(n,e,-r),b.transformMat2d(n,n,this._fullXform),t.lineTo(n[0],n[1]),b.set(n,e,r),b.transformMat2d(n,n,this._fullXform),t.lineTo(n[0],n[1]),b.set(n,-e,r),b.transformMat2d(n,n,this._fullXform),t.lineTo(n[0],n[1]),t.closePath()}},{key:"toJSON",value:function(){return Object.assign({type:"Rect",width:this.width,height:this.height},s(_(e.prototype),"toJSON",this).call(this))}}]),e}(y.a)},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=r(26);r.n(n);r.o(n,"version")&&r.d(e,"version",function(){return n.version});var i=r(5);r.d(e,"Configure",function(){return i});var o=r(31);r.d(e,"ShapeBuilder",function(){return o.a});var a=r(22);r.d(e,"DrawEngine",function(){return a.a});var s=r(4);r.d(e,"AABox2d",function(){return s});var c=r(2);r.d(e,"Mat2d",function(){return c.a});var u=r(0);r.d(e,"Point2d",function(){return u});var l=r(39);r.d(e,"Mat2",function(){return l.a});var f=r(10);r.d(e,"BasicStyle",function(){return f.a});var h=r(3);r.d(e,"Vec2d",function(){return h.a});var p=r(40);r.d(e,"Circle",function(){return p.a});var d=r(24);r.d(e,"Rect",function(){return d.a});var _=r(41);r.d(e,"Poly",function(){return _.a});var v=r(13);r.d(e,"PolyLine",function(){return v.a});var y=r(42);r.d(e,"Point",function(){return y.a});var b=r(8);r.d(e,"Math",function(){return b.a});var m=r(23);r.d(e,"simpleHull_2D",function(){return m.a})},function(t,e){t.exports={name:"@mapd/mapd-draw",description:"A Utility Library for drawing and interacting with shapes using canvas",version:"1.1.0",homepage:"https://omnisci.com",bugs:"https://github.com/omnisci/mapd-draw/issues",main:"dist/mapd-draw.js",author:"MapD Technologies",license:"MIT",engines:{node:">=4.0.0"},repository:{type:"git",url:"git+https://github.com/omnisci/mapd-draw.git"},dependencies:{"css-element-queries":"^0.4.0","gl-matrix":"^2.3.2"},devDependencies:{"@babel/core":"^7.0.0","@babel/plugin-proposal-class-properties":"^7.0.0","@babel/plugin-proposal-decorators":"^7.0.0","@babel/plugin-proposal-do-expressions":"^7.0.0","@babel/plugin-proposal-export-default-from":"^7.0.0","@babel/plugin-proposal-export-namespace-from":"^7.0.0","@babel/plugin-proposal-function-bind":"^7.0.0","@babel/plugin-proposal-function-sent":"^7.0.0","@babel/plugin-proposal-json-strings":"^7.0.0","@babel/plugin-proposal-logical-assignment-operators":"^7.0.0","@babel/plugin-proposal-nullish-coalescing-operator":"^7.0.0","@babel/plugin-proposal-numeric-separator":"^7.0.0","@babel/plugin-proposal-optional-chaining":"^7.0.0","@babel/plugin-proposal-pipeline-operator":"^7.0.0","@babel/plugin-proposal-throw-expressions":"^7.0.0","@babel/plugin-syntax-dynamic-import":"^7.0.0","@babel/plugin-syntax-import-meta":"^7.0.0","@babel/preset-env":"^7.0.0","@babel/register":"^7.0.0","babel-eslint":"^10.0.1","babel-loader":"^8.0.0",chai:"^3.5.0",eslint:"^6.0.0","eslint-config-prettier":"^6.5.0","eslint-plugin-prettier":"^3.1.1","json-loader":"0.5.4",mocha:"^6.2.1","pre-commit":"^1.2.2",prettier:"1.18.2",webpack:"^3.12.0","webpack-dev-server":"^2.11.3"},scripts:{build:"npm run build:prod; npm run build:dev","build:prod":"npm run webpack","build:dev":"npm run webpack:dev",clean:"bash scripts/clean.sh","lint:fix":"eslint --rule 'prettier/prettier: 0' --fix $(find src -name \"*.js\" ! -name '*.spec.js'); prettier --write $(find src -name \"*.js\" ! -name '*.spec.js')",lint:"eslint $(find src -name \"*.js\" ! -name '*.spec.js')",start:"webpack-dev-server --config webpack.dev.config.js --content-base ./example --watch -d --open","watch:dev":"node node_modules/webpack/bin/webpack.js --progress --colors --watch --config webpack.dev.config.js",webpack:"node node_modules/webpack/bin/webpack.js","webpack:dev":"node node_modules/webpack/bin/webpack.js --config webpack.dev.config.js",test:"mocha --recursive --require @babel/register"},"pre-commit":["lint","test"]}},function(t,e,r){"use strict";function n(){var t=new M.ARRAY_TYPE(4);return M.ARRAY_TYPE!=Float32Array&&(t[1]=0,t[2]=0),t[0]=1,t[3]=1,t}function i(t){var e=new M.ARRAY_TYPE(4);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e}function o(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}function a(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t}function s(t,e,r,n){var i=new M.ARRAY_TYPE(4);return i[0]=t,i[1]=e,i[2]=r,i[3]=n,i}function c(t,e,r,n,i){return t[0]=e,t[1]=r,t[2]=n,t[3]=i,t}function u(t,e){if(t===e){var r=e[1];t[1]=e[2],t[2]=r}else t[0]=e[0],t[1]=e[2],t[2]=e[1],t[3]=e[3];return t}function l(t,e){var r=e[0],n=e[1],i=e[2],o=e[3],a=r*o-i*n;return a?(a=1/a,t[0]=o*a,t[1]=-n*a,t[2]=-i*a,t[3]=r*a,t):null}function f(t,e){var r=e[0];return t[0]=e[3],t[1]=-e[1],t[2]=-e[2],t[3]=r,t}function h(t){return t[0]*t[3]-t[2]*t[1]}function p(t,e,r){var n=e[0],i=e[1],o=e[2],a=e[3],s=r[0],c=r[1],u=r[2],l=r[3];return t[0]=n*s+o*c,t[1]=i*s+a*c,t[2]=n*u+o*l,t[3]=i*u+a*l,t}function d(t,e,r){var n=e[0],i=e[1],o=e[2],a=e[3],s=Math.sin(r),c=Math.cos(r);return t[0]=n*c+o*s,t[1]=i*c+a*s,t[2]=n*-s+o*c,t[3]=i*-s+a*c,t}function _(t,e,r){var n=e[0],i=e[1],o=e[2],a=e[3],s=r[0],c=r[1];return t[0]=n*s,t[1]=i*s,t[2]=o*c,t[3]=a*c,t}function v(t,e){var r=Math.sin(e),n=Math.cos(e);return t[0]=n,t[1]=r,t[2]=-r,t[3]=n,t}function y(t,e){return t[0]=e[0],t[1]=0,t[2]=0,t[3]=e[1],t}function b(t){return"mat2("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"}function m(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2))}function g(t,e,r,n){return t[2]=n[2]/n[0],r[0]=n[0],r[1]=n[1],r[3]=n[3]-t[2]*r[1],[t,e,r]}function w(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t[2]=e[2]+r[2],t[3]=e[3]+r[3],t}function x(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t[2]=e[2]-r[2],t[3]=e[3]-r[3],t}function k(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]}function S(t,e){var r=t[0],n=t[1],i=t[2],o=t[3],a=e[0],s=e[1],c=e[2],u=e[3];return Math.abs(r-a)<=M.EPSILON*Math.max(1,Math.abs(r),Math.abs(a))&&Math.abs(n-s)<=M.EPSILON*Math.max(1,Math.abs(n),Math.abs(s))&&Math.abs(i-c)<=M.EPSILON*Math.max(1,Math.abs(i),Math.abs(c))&&Math.abs(o-u)<=M.EPSILON*Math.max(1,Math.abs(o),Math.abs(u))}function O(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t}function E(t,e,r,n){return t[0]=e[0]+r[0]*n,t[1]=e[1]+r[1]*n,t[2]=e[2]+r[2]*n,t[3]=e[3]+r[3]*n,t}Object.defineProperty(e,"__esModule",{value:!0}),e.create=n,e.clone=i,e.copy=o,e.identity=a,e.fromValues=s,e.set=c,e.transpose=u,e.invert=l,e.adjoint=f,e.determinant=h,e.multiply=p,e.rotate=d,e.scale=_,e.fromRotation=v,e.fromScaling=y,e.str=b,e.frob=m,e.LDU=g,e.add=w,e.subtract=x,e.exactEquals=k,e.equals=S,e.multiplyScalar=O,e.multiplyScalarAndAdd=E,r.d(e,"mul",function(){return C}),r.d(e,"sub",function(){return P});var M=r(1),C=p,P=x},function(t,e,r){"use strict";function n(){var t=new E.ARRAY_TYPE(6);return E.ARRAY_TYPE!=Float32Array&&(t[1]=0,t[2]=0,t[4]=0,t[5]=0),t[0]=1,t[3]=1,t}function i(t){var e=new E.ARRAY_TYPE(6);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}function o(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t}function a(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t}function s(t,e,r,n,i,o){var a=new E.ARRAY_TYPE(6);return a[0]=t,a[1]=e,a[2]=r,a[3]=n,a[4]=i,a[5]=o,a}function c(t,e,r,n,i,o,a){return t[0]=e,t[1]=r,t[2]=n,t[3]=i,t[4]=o,t[5]=a,t}function u(t,e){var r=e[0],n=e[1],i=e[2],o=e[3],a=e[4],s=e[5],c=r*o-n*i;return c?(c=1/c,t[0]=o*c,t[1]=-n*c,t[2]=-i*c,t[3]=r*c,t[4]=(i*s-o*a)*c,t[5]=(n*a-r*s)*c,t):null}function l(t){return t[0]*t[3]-t[1]*t[2]}function f(t,e,r){var n=e[0],i=e[1],o=e[2],a=e[3],s=e[4],c=e[5],u=r[0],l=r[1],f=r[2],h=r[3],p=r[4],d=r[5];return t[0]=n*u+o*l,t[1]=i*u+a*l,t[2]=n*f+o*h,t[3]=i*f+a*h,t[4]=n*p+o*d+s,t[5]=i*p+a*d+c,t}function h(t,e,r){var n=e[0],i=e[1],o=e[2],a=e[3],s=e[4],c=e[5],u=Math.sin(r),l=Math.cos(r);return t[0]=n*l+o*u,t[1]=i*l+a*u,t[2]=n*-u+o*l,t[3]=i*-u+a*l,t[4]=s,t[5]=c,t}function p(t,e,r){var n=e[0],i=e[1],o=e[2],a=e[3],s=e[4],c=e[5],u=r[0],l=r[1];return t[0]=n*u,t[1]=i*u,t[2]=o*l,t[3]=a*l,t[4]=s,t[5]=c,t}function d(t,e,r){var n=e[0],i=e[1],o=e[2],a=e[3],s=e[4],c=e[5],u=r[0],l=r[1];return t[0]=n,t[1]=i,t[2]=o,t[3]=a,t[4]=n*u+o*l+s,t[5]=i*u+a*l+c,t}function _(t,e){var r=Math.sin(e),n=Math.cos(e);return t[0]=n,t[1]=r,t[2]=-r,t[3]=n,t[4]=0,t[5]=0,t}function v(t,e){return t[0]=e[0],t[1]=0,t[2]=0,t[3]=e[1],t[4]=0,t[5]=0,t}function y(t,e){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=e[0],t[5]=e[1],t}function b(t){return"mat2d("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+")"}function m(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+1)}function g(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t[2]=e[2]+r[2],t[3]=e[3]+r[3],t[4]=e[4]+r[4],t[5]=e[5]+r[5],t}function w(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t[2]=e[2]-r[2],t[3]=e[3]-r[3],t[4]=e[4]-r[4],t[5]=e[5]-r[5],t}function x(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t[4]=e[4]*r,t[5]=e[5]*r,t}function k(t,e,r,n){return t[0]=e[0]+r[0]*n,t[1]=e[1]+r[1]*n,t[2]=e[2]+r[2]*n,t[3]=e[3]+r[3]*n,t[4]=e[4]+r[4]*n,t[5]=e[5]+r[5]*n,t}function S(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]&&t[4]===e[4]&&t[5]===e[5]}function O(t,e){var r=t[0],n=t[1],i=t[2],o=t[3],a=t[4],s=t[5],c=e[0],u=e[1],l=e[2],f=e[3],h=e[4],p=e[5];return Math.abs(r-c)<=E.EPSILON*Math.max(1,Math.abs(r),Math.abs(c))&&Math.abs(n-u)<=E.EPSILON*Math.max(1,Math.abs(n),Math.abs(u))&&Math.abs(i-l)<=E.EPSILON*Math.max(1,Math.abs(i),Math.abs(l))&&Math.abs(o-f)<=E.EPSILON*Math.max(1,Math.abs(o),Math.abs(f))&&Math.abs(a-h)<=E.EPSILON*Math.max(1,Math.abs(a),Math.abs(h))&&Math.abs(s-p)<=E.EPSILON*Math.max(1,Math.abs(s),Math.abs(p))}Object.defineProperty(e,"__esModule",{value:!0}),e.create=n,e.clone=i,e.copy=o,e.identity=a,e.fromValues=s,e.set=c,e.invert=u,e.determinant=l,e.multiply=f,e.rotate=h,e.scale=p,e.translate=d,e.fromRotation=_,e.fromScaling=v,e.fromTranslation=y,e.str=b,e.frob=m,e.add=g,e.subtract=w,e.multiplyScalar=x,e.multiplyScalarAndAdd=k,e.exactEquals=S,e.equals=O,r.d(e,"mul",function(){return M}),r.d(e,"sub",function(){return C});var E=r(1),M=f,C=w},function(t,e,r){"use strict";var n=(r(1),r(16));r(15),n.a,n.a,n.c,n.d,n.h},function(t,e,r){"use strict";function n(){var t=new z.ARRAY_TYPE(2);return z.ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0),t}function i(t){var e=new z.ARRAY_TYPE(2);return e[0]=t[0],e[1]=t[1],e}function o(t,e){var r=new z.ARRAY_TYPE(2);return r[0]=t,r[1]=e,r}function a(t,e){return t[0]=e[0],t[1]=e[1],t}function s(t,e,r){return t[0]=e,t[1]=r,t}function c(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t}function u(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t}function l(t,e,r){return t[0]=e[0]*r[0],t[1]=e[1]*r[1],t}function f(t,e,r){return t[0]=e[0]/r[0],t[1]=e[1]/r[1],t}function h(t,e){return t[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t}function p(t,e){return t[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t}function d(t,e,r){return t[0]=Math.min(e[0],r[0]),t[1]=Math.min(e[1],r[1]),t}function _(t,e,r){return t[0]=Math.max(e[0],r[0]),t[1]=Math.max(e[1],r[1]),t}function v(t,e){return t[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t}function y(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t}function b(t,e,r,n){return t[0]=e[0]+r[0]*n,t[1]=e[1]+r[1]*n,t}function m(t,e){var r=e[0]-t[0],n=e[1]-t[1];return Math.sqrt(r*r+n*n)}function g(t,e){var r=e[0]-t[0],n=e[1]-t[1];return r*r+n*n}function w(t){var e=t[0],r=t[1];return Math.sqrt(e*e+r*r)}function x(t){var e=t[0],r=t[1];return e*e+r*r}function k(t,e){return t[0]=-e[0],t[1]=-e[1],t}function S(t,e){return t[0]=1/e[0],t[1]=1/e[1],t}function O(t,e){var r=e[0],n=e[1],i=r*r+n*n;return i>0&&(i=1/Math.sqrt(i),t[0]=e[0]*i,t[1]=e[1]*i),t}function E(t,e){return t[0]*e[0]+t[1]*e[1]}function M(t,e,r){var n=e[0]*r[1]-e[1]*r[0];return t[0]=t[1]=0,t[2]=n,t}function C(t,e,r,n){var i=e[0],o=e[1];return t[0]=i+n*(r[0]-i),t[1]=o+n*(r[1]-o),t}function P(t,e){e=e||1;var r=2*z.RANDOM()*Math.PI;return t[0]=Math.cos(r)*e,t[1]=Math.sin(r)*e,t}function j(t,e,r){var n=e[0],i=e[1];return t[0]=r[0]*n+r[2]*i,t[1]=r[1]*n+r[3]*i,t}function A(t,e,r){var n=e[0],i=e[1];return t[0]=r[0]*n+r[2]*i+r[4],t[1]=r[1]*n+r[3]*i+r[5],t}function I(t,e,r){var n=e[0],i=e[1];return t[0]=r[0]*n+r[3]*i+r[6],t[1]=r[1]*n+r[4]*i+r[7],t}function D(t,e,r){var n=e[0],i=e[1];return t[0]=r[0]*n+r[4]*i+r[12],t[1]=r[1]*n+r[5]*i+r[13],t}function F(t,e,r,n){var i=e[0]-r[0],o=e[1]-r[1],a=Math.sin(n),s=Math.cos(n);return t[0]=i*s-o*a+r[0],t[1]=i*a+o*s+r[1],t}function R(t,e){var r=t[0],n=t[1],i=e[0],o=e[1],a=r*r+n*n;a>0&&(a=1/Math.sqrt(a));var s=i*i+o*o;s>0&&(s=1/Math.sqrt(s));var c=(r*i+n*o)*a*s;return c>1?0:c<-1?Math.PI:Math.acos(c)}function T(t){return"vec2("+t[0]+", "+t[1]+")"}function B(t,e){return t[0]===e[0]&&t[1]===e[1]}function V(t,e){var r=t[0],n=t[1],i=e[0],o=e[1];return Math.abs(r-i)<=z.EPSILON*Math.max(1,Math.abs(r),Math.abs(i))&&Math.abs(n-o)<=z.EPSILON*Math.max(1,Math.abs(n),Math.abs(o))}Object.defineProperty(e,"__esModule",{value:!0}),e.create=n,e.clone=i,e.fromValues=o,e.copy=a,e.set=s,e.add=c,e.subtract=u,e.multiply=l,e.divide=f,e.ceil=h,e.floor=p,e.min=d,e.max=_,e.round=v,e.scale=y,e.scaleAndAdd=b,e.distance=m,e.squaredDistance=g,e.length=w,e.squaredLength=x,e.negate=k,e.inverse=S,e.normalize=O,e.dot=E,e.cross=M,e.lerp=C,e.random=P,e.transformMat2=j,e.transformMat2d=A,e.transformMat3=I,e.transformMat4=D,e.rotate=F,e.angle=R,e.str=T,e.exactEquals=B,e.equals=V,r.d(e,"len",function(){return N}),r.d(e,"sub",function(){return L}),r.d(e,"mul",function(){return X}),r.d(e,"div",function(){return W}),r.d(e,"dist",function(){return q}),r.d(e,"sqrDist",function(){return Y}),r.d(e,"sqrLen",function(){return H}),r.d(e,"forEach",function(){return J});var z=r(1),N=w,L=u,X=l,W=f,q=m,Y=g,H=x,J=function(){var t=n();return function(e,r,n,i,o,a){var s=void 0,c=void 0;for(r||(r=2),n||(n=0),c=i?Math.min(i*r+n,e.length):e.length,s=n;s<c;s+=r)t[0]=e[s],t[1]=e[s+1],o(t,t,a),e[s]=t[0],e[s+1]=t[1];return e}}()},function(t,e,r){"use strict";function n(t){"@babel/helpers - typeof";return(n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function a(t,e,r){return e&&o(t.prototype,e),r&&o(t,r),t}function s(t,e,r){return(s="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,r){var n=c(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(r):i.value}})(t,e,r||t)}function c(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=_(t)););return t}function u(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&l(t,e)}function l(t,e){return(l=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function f(t){var e=d();return function(){var r,n=_(t);if(e){var i=_(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return h(this,r)}}function h(t,e){return!e||"object"!==n(e)&&"function"!=typeof e?p(t):e}function p(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function d(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(t){return!1}}function _(t){return(_=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function v(t,e,r){var n=t.getBoundingClientRect(),i=0,o=0;return(i=e-n.left-t.clientLeft)>=0&&i<=t.clientWidth&&(o=r-n.top-t.clientTop)>=0&&o<=t.clientHeight}function y(t,e,r){var n=e.getBoundingClientRect();t[0]=r.clientX-n.left-e.clientLeft,t[1]=r.clientY-n.top-e.clientTop}function b(t,e,r,n,i,o){y(t,r,n),j.transformMat2d(e,t,o.screenToWorldMatrix);var a=i.shape;a instanceof T.a?P.a(a,i,t,e,o):a instanceof R.a?P.c(a,i,t,e,o):P.b(a,i,t,e,o)}function m(t,e){e.keys={altKey:t.altKey,ctrlKey:t.ctrlKey,shiftKey:t.shiftKey,metaKey:t.metaKey}}function g(t){var e=[];return t.forEach(function(t,r){e.push(r)}),e}function w(t,e,r,n,i,o){var a={unselectedShapes:g(r)};x(r),t.save();var s=e[e.length-1].zIndex;t.zIndex=s+1,A.a.copyBasicStyle(n,t),t.selected=!0;var c=null;return(o.scalable||o.rotatable)&&(c=new T.a(i||L,o),t.addChildXform(c)),r.set(t,c),a.selectedShapes=[t],a}function x(t){t.forEach(function(t,e){e.restore(),e.selected=!1,e.removeChildXform(t)}),t.clear()}function k(t,e){var r=[];return e.forEach(function(e){var n=t.get(e);e.restore(),e.selected=!1,e.removeChildXform(n),t.delete(e),r.push(e)}),r}function S(t,e){var r=document.querySelector("".concat("#".concat(e.id," canvas")));return{x:t.offsetX+r.offsetLeft,y:t.offsetY+r.offsetTop}}function O(t,e,r){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N.SVG_OFFSET,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:N.SVG_OFFSET,o=document.getElementById("cursor"),a=S(t,e);if(null===o){var s=document.createElement("span");s.setAttribute("id","cursor"),s.setAttribute("style","position: absolute; top: ".concat("".concat(a.y,"px"),"; left: ","".concat(a.x,"px"),"; width: 28px; height: 28px; background: ",r,"; cursor: none; z-index: 10; pointer-events: none; transform: translate(").concat(n,"px, ").concat(i,"px)")),e.appendChild(s)}else o.style.background===r?C(t,e):(o.style.background=r,C(t,e))}function E(){var t=document.getElementById("cursor");null!==t&&t.parentNode.removeChild(t)}function M(t,e,r){var n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];t.style.cursor=e;for(var i=0;i<t.childNodes.length;i+=1)t.childNodes[i].style.cursor=e,null===r||!n&&"canvas"===t.childNodes[i].nodeName.toLowerCase()||(t.childNodes[i].style.pointerEvents=r)}function C(t,e){var r=document.getElementById("cursor"),n=S(t,e);null!==r&&(r.style.top="".concat("".concat(n.y,"px")),r.style.left="".concat("".concat(n.x,"px")))}r.d(e,"a",function(){return H});var P=r(32),j=r(0),A=r(10),I=r(22),D=r(2),F=r(13),R=r(37),T=r(38),B="url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Cg transform='rotate(<degrees>,24,24)'%3E%3Cpolygon style='fill:%23ffffff;' points='16,20 16,12 4,24 16,36 16,28 32,28 32,36 44,24 32,12 32,20 '/%3E%3Cpolygon points='14,22 14,17 7,24 14,31 14,26 34,26 34,31 41,24 34,17 34,22 '/%3E%3C/g%3E%3C/svg%3E\") no-repeat",V="url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Cg transform='rotate(<degrees>,24,24)'%3E%3Cpath style='fill:%23ffffff;' d='M25.9,4C16.6,4,8.8,11.2,7.4,20.8H6.7H3.3l1.6,2.9l3.8,7.1l1.8,3.3l1.8-3.3l3.8-7.1l1.6-2.9h-3.3h-0.1 c1.3-5.7,6.1-9.9,11.7-9.9c8,0,12.1,4.4,12.1,13.1c0,7.2-5.4,13.1-12.1,13.1h-2v2V42v2h2c10.4,0,18.8-9,18.8-20 C44.7,11.7,37.5,4,25.9,4L25.9,4z'/%3E%3Cpath d='M25.9,6c10.5,0,16.8,6.7,16.8,18c0,9.9-7.5,18-16.8,18v-2.9c7.8,0,14.1-6.8,14.1-15.1c0-5.6-1.8-15.1-14.1-15.1 c-7.4,0-13.4,6.1-14,13.9h2.4l-3.8,7.1l-3.8-7.1h2.5C9.7,13.4,17,6,25.9,6'/%3E%3C/g%3E%3C/svg%3E\") no-repeat",z={SELECTION_CHANGED:"draw:selectionChanged",DRAG_BEGIN:"draw:drag:begin",DRAG_END:"draw:drag:end"},N={SVG_OFFSET:-14,QUICK_CLICK_TIME:500,RIGHT_ANGLE:90,STRAIGHT_ANGLE:180,FORTY_FIVE_ANGLE:45},L={fillColor:"white",strokeColor:"black",strokeWidth:2},X=function(){var t=document.getElementById("cursor");null!==t&&(t.style.display="none")},W=function(){var t=document.getElementById("cursor");null!==t&&(t.style.display="block")},q=function(t){t.target.parentNode.style.cursor="default",X()},Y=function(t){t.target.parentNode.style.cursor="none",W()},H=function(t){function e(t,n){var o;return i(this,e),o=r.call(this,t,n),o._tmp_pt1=j.create(),o._tmp_pt2=j.create(),o}u(e,t);var r=f(e);return a(e,[{key:"_mousedownCB",value:function(t){if(v(this._drawCanvas,t.clientX,t.clientY)){this.timer=performance.now(),j.set(this._tmp_pt1,t.offsetX,t.offsetY),j.transformMat2d(this._tmp_pt2,this._tmp_pt1,this._camera.screenToWorldMatrix);var e=this._camera.worldToScreenMatrix,r=this.sortedShapes,n=-1,i=null,o=null;for(n=r.length-1;n>=0;n-=1){var a=this._objects.get(r[n]);if(r[n].selected){i=this._selectedShapes.get(r[n]),o=a;var s=null;if(i&&(s=i.containsPoint(this._tmp_pt1,this._tmp_pt2,e,this._drawCtx)).hit){if(i instanceof R.a&&t.altKey&&s.controlIndex<r[n].numVerts)r[n].removeVert(s.controlIndex),i=null;else{var c=i.parent.localXform,u=D.a.clone(c);D.a.invert(u,u);var l=j.clone(this._tmp_pt2);j.transformMat2d(l,l,u),this._dragInfo=Object.assign({rotate:Boolean(s.rotate),controlIndex:s.controlIndex,startObjectPos:l,worldToObjectMatrix:u,startLocalPos:i.parent.getPosition(),startLocalScale:i.parent.getScale(),startLocalRot:i.parent.getRotation(),shapeWidth:i.parent.width,shapeHeight:i.parent.height},o)}break}if(r[n].containsPoint(this._tmp_pt1,this._tmp_pt2,e,this._drawCtx)){i=r[n];break}}}if(n<0&&this._selectedShapes.size)this._selectedShapes.size&&this.fire(z.SELECTION_CHANGED,{unselectedShapes:g(this._selectedShapes),selectedShapes:[]}),this._dragInfo=null,x(this._selectedShapes);else if(i&&o&&(o.movable||o.rotatable||o.scalable)){var f=document.querySelector("".concat("#".concat(this._parent.id," > canvas")));null===f?(this._parent.addEventListener("mouseout",X),this._parent.addEventListener("mouseover",W)):(f.addEventListener("mouseout",q),f.addEventListener("mouseover",Y)),!this._dragInfo&&o.movable&&(this._dragInfo={startLocalPos:i.getPosition()}),this._dragInfo&&(this._dragInfo.shape=i,this._dragInfo.startPos=j.clone(this._tmp_pt1),this._dragInfo.startWorldPos=j.clone(this._tmp_pt2),this._dragInfo.objectToWorldMatrix=D.a.clone(i.globalXform),m(t,this._dragInfo),t.stopImmediatePropagation(),this.fire(z.DRAG_BEGIN,{shapes:g(this._selectedShapes)})),t.preventDefault()}}}},{key:"_mouseupCB",value:function(t){if(this._dragInfo&&this._dragInfo.shape){t.stopImmediatePropagation(),t.preventDefault();var e=document.querySelector("".concat("#".concat(this._parent.id," > canvas")));null===e?(this._parent.removeEventListener("mouseout",X),this._parent.removeEventListener("mouseover",W)):(e.removeEventListener("mouseout",q),e.removeEventListener("mouseover",Y)),this._dragInfo=null,this.fire(z.DRAG_END,{shapes:g(this._selectedShapes)})}else if(performance.now()-this.timer<N.QUICK_CLICK_TIME){j.set(this._tmp_pt1,t.offsetX,t.offsetY),j.transformMat2d(this._tmp_pt2,this._tmp_pt1,this._camera.screenToWorldMatrix);for(var r=this._camera.worldToScreenMatrix,n=this.sortedShapes,i=null,o=null,a=n.length-1;a>=0;a-=1)if(o=this._objects.get(n[a]),o.selectable&&n[a].containsPoint(this._tmp_pt1,this._tmp_pt2,r,this._drawCtx)){i=n[a];break}if(i&&!i.selected){var s=w(i,n,this._selectedShapes,this._selectStyle,this._xformStyle,o);this.fire(z.SELECTION_CHANGED,s)}}}},{key:"_mousemoveCB",value:function(t){if(v(this._drawCanvas,t.clientX,t.clientY)||this._dragInfo)if(this._dragInfo&&this._dragInfo.shape)C(t,this._parent),m(t,this._dragInfo),b(this._tmp_pt1,this._tmp_pt2,this._drawCanvas,t,this._dragInfo,this._camera),t.stopImmediatePropagation(),t.preventDefault();else if(!t.buttons&&this._selectedShapes.size){j.set(this._tmp_pt1,t.offsetX,t.offsetY),j.transformMat2d(this._tmp_pt2,this._tmp_pt1,this._camera.screenToWorldMatrix);var e=this._camera.worldToScreenMatrix,r=this.sortedShapes,n=0,i=this._camera.isYFlipped();for(n=r.length-1;n>=0;n-=1)if(r[n].selected){var o=this._objects.get(r[n]),a=this._selectedShapes.get(r[n]),s=null;if(M(this._parent,"none","none",!1),a&&(s=a.containsPoint(this._tmp_pt1,this._tmp_pt2,e,this._drawCtx)).hit){if(a instanceof T.a)if(s.rotate){var c=r[n].getRotation();i?(c*=-1,1===s.controlIndex?c-=N.RIGHT_ANGLE:0===s.controlIndex?c+=N.STRAIGHT_ANGLE:2===s.controlIndex&&(c+=N.RIGHT_ANGLE)):0===s.controlIndex?c-=N.RIGHT_ANGLE:1===s.controlIndex?c+=N.STRAIGHT_ANGLE:3===s.controlIndex&&(c+=N.RIGHT_ANGLE),O(t,this._parent,"".concat(V.replace(/<degrees>/g,"".concat(c))))}else s.controlIndex<4?0===s.controlIndex||3===s.controlIndex?O(t,this._parent,"".concat(B.replace(/<degrees>/g,"".concat(-r[n].getRotation()-N.FORTY_FIVE_ANGLE)))):1!==s.controlIndex&&2!==s.controlIndex||O(t,this._parent,"".concat(B.replace(/<degrees>/g,"".concat(-r[n].getRotation()+N.FORTY_FIVE_ANGLE)))):s.controlIndex%2==0?O(t,this._parent,"".concat(B.replace(/<degrees>/g,"".concat(-r[n].getRotation())))):O(t,this._parent,"".concat(B.replace(/<degrees>/g,"".concat(-r[n].getRotation()+N.RIGHT_ANGLE))));else a instanceof R.a&&(M(this._parent,"none","none",!1),s.controlIndex>=r[n].numVerts?O(t,this._parent,"url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Cpolygon style='fill:%23ffffff;' points='31.2,28 24.8,28 24.8,32.8 20,32.8 20,39.2 24.8,39.2 24.8,44 31.2,44 31.2,39.2 36,39.2 36,32.8 31.2,32.8 '/%3E %3Cpolygon style='fill:%23ffffff' points='12,32 12,4 32.3,24.3 20,24.3 19.7,24.6 '/%3E%3Cpolygon points='13.8,8.2 13.8,27.8 19,22.8 19.2,22.5 28,22.5 '/%3E%3Cpolyline points='29.6,29.6 29.6,34.4 34.4,34.4 34.4,37.6 29.6,37.6 29.6,42.4 26.4,42.4 26.4,37.6 21.6,37.6 21.6,34.4 26.4,34.4 26.4,29.6 29.6,29.6  '/%3E%3C/svg%3E\") no-repeat",-8,-6):t.altKey?O(t,this._parent,"url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Crect style='fill:%23ffffff;' x='20' y='32.8' width='16' height='6.4'/%3E%3Cpolygon  style='fill:%23ffffff;' points='12,32 12,4 32.3,24.3 20,24.3 19.7,24.6 '/%3E%3Cpolygon points='13.8,8.2 13.8,27.8 19,22.8 19.2,22.5 28,22.5 '/%3E%3Cpolyline points='34.4,34.4 34.4,37.6 21.6,37.6 21.6,34.4 '/%3E%3C/svg%3E\") no-repeat",-8,-6):O(t,this._parent,"url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Cpath style='fill:%23ffffff;' d='M24,17.5c-3.6,0-6.5,2.9-6.5,6.5s2.9,6.5,6.5,6.5s6.5-2.9,6.5-6.5S27.6,17.5,24,17.5L24,17.5z'/%3E%3Cpath style='fill:%23ffffff;' d='M24,4L4,24l20,20l20-20L24,4z M31.5,31.5h-15v-15h15V31.5z'/%3E%3Cpolygon points='17,34 24,40.5 31,34  '/%3E%3Cpolygon points='31,14 24,7.5 17,14     '/%3E%3Cpolygon points='14,17 7.5,24 14,31   '/%3E%3Cpolygon points='34,31 40.5,24 34,17    '/%3E%3Cpath d='M24,20c2.2,0,4,1.8,4,4s-1.8,4-4,4s-4-1.8-4-4S21.8,20,24,20'/%3E%3C/svg%3E\") no-repeat",N.SVG_OFFSET,N.SVG_OFFSET));t.stopImmediatePropagation(),t.preventDefault();break}if(r[n].containsPoint(this._tmp_pt1,this._tmp_pt2,e,this._drawCtx)){if(o&&o.movable){var u=document.getElementById("cursor");null!==u&&u.parentNode.removeChild(u),M(this._parent,"move",null),t.stopImmediatePropagation(),t.preventDefault()}break}}n<0&&(E(),M(this._parent,"default","auto",!1))}}},{key:"_clickCB",value:function(){}},{key:"_dblclickCB",value:function(t){if(v(this._drawCanvas,t.clientX,t.clientY)){j.set(this._tmp_pt1,t.offsetX,t.offsetY),j.transformMat2d(this._tmp_pt2,this._tmp_pt1,this._camera.screenToWorldMatrix);var e=this._camera.worldToScreenMatrix,r=this.sortedShapes,n=-1;for(n=r.length-1;n>=0;n-=1){var i=this._objects.get(r[n]);if(i.selectable&&r[n].containsPoint(this._tmp_pt1,this._tmp_pt2,e,this._drawCtx)){if(i.editable&&r[n]instanceof F.a){var o=r[n],a=!1;if(r[n].selected){var s=this._selectedShapes.get(r[n]);s&&(o.restore(),o.removeChildXform(s),a=!(s instanceof T.a))}o.selected=!0,o.save();var c=r[r.length-1].zIndex;o.zIndex=c+1,A.a.copyBasicStyle(this._selectStyle,o);var u=null;a?(i.rotatable||i.scalable)&&(u=new T.a(this._xformStyle||L,i),o.addChildXform(u)):(u=new R.a(o,this._xformStyle),o.addChildXform(u)),this._selectedShapes.set(o,u)}else if(!r[n].selected){var l=w(r[n],r,this._selectedShapes,this._selectStyle,this._xformStyle,i);this.fire(z.SELECTION_CHANGED,l)}break}}n<0&&this._selectedShapes.size?(this._selectedShapes.size&&this.fire(z.SELECTION_CHANGED,{unselectedShapes:g(this._selectedShapes),selectedShapes:[]}),this._dragInfo=null,x(this._selectedShapes),E(),M(this._parent,"default","auto",!1)):t.stopImmediatePropagation(),t.preventDefault()}}},{key:"_mouseoverCB",value:function(){}},{key:"_mouseoutCB",value:function(){}},{key:"_init",value:function(t,r){this._activated=r&&r.enableInteractions,s(_(e.prototype),"_init",this).call(this,t,r,this._activated);var n=Object.getOwnPropertyNames(z).map(function(t){return z[t]});this.registerEvents(n),this._dragInfo=null,this._selectedShapes=new Map,this._selectStyle=new A.a(r&&r.selectStyle?r.selectStyle:{fillColor:"orange"}),this._xformStyle=new A.a(r&&r.xformStyle?r.xformStyle:{fillColor:"white",strokeColor:"black",strokeWidth:2}),this.timer=0}},{key:"_renderShapes",value:function(t,e,r){var n=this,i=r.worldToScreenMatrix;e.forEach(function(e){if(e.visible&&(e.render(t,i,n._styleState),e.selected)){var r=n._selectedShapes.get(e);r&&r.render(t,i,n._styleState)}})}},{key:"selectStyle",get:function(){return this._selectStyle},set:function(t){A.a.copyBasicStyle(t,this._selectStyle)}},{key:"selectedShapes",get:function(){return g(this._selectedShapes)}},{key:"selectShape",value:function(t){var e=this._objects.get(t);if(e&&e.selectable){var r=w(t,this.sortedShapes,this._selectedShapes,this._selectStyle,this._xformStyle,e);this.fire(z.SELECTION_CHANGED,r)}}},{key:"clearSelection",value:function(){if(this._selectedShapes.size){var t=g(this._selectedShapes);x(this._selectedShapes),this.fire(z.SELECTION_CHANGED,{unselectedShapes:t,selectedShapes:[]}),this._rerenderCb()}}},{key:"addShape",value:function(t){var r=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=t;if(Array.isArray(o)||(o=[t]),s(_(e.prototype),"addShape",this).call(this,o),o.forEach(function(t){var e=r._objects.get(t);e&&(e.selectable=!n||void 0===n.selectable||Boolean(n.selectable),e.movable=!n||void 0===n.movable||Boolean(n.movable),e.rotatable=!n||void 0===n.rotatable||Boolean(n.rotatable),e.scalable=!n||void 0===n.scalable||Boolean(n.scalable),e.uniformScaleOnly=!(!n||void 0===n.uniformScaleOnly)&&Boolean(n.uniformScaleOnly),e.centerScaleOnly=!(!n||void 0===n.centerScaleOnly)&&Boolean(n.centerScaleOnly),e.editable=!n||void 0===n.editable||Boolean(n.editable))}),i){var a={unselectedShapes:g(this._selectedShapes)},c=[];o.forEach(function(t){var e=r._objects.get(t);e.selectable&&(w(t,r.sortedShapes,r._selectedShapes,r._selectStyle,r._xformStyle,e),c.push(t))}),c.length&&(a.selectedShapes=c,this.fire(z.SELECTION_CHANGED,a))}return this}},{key:"deleteShape",value:function(t){var r=t;Array.isArray(r)||(r=[t]);var n=k(this._selectedShapes,r);return this.fire(z.SELECTION_CHANGED,{unselectedShapes:n,selectedShapes:g(this._selectedShapes)}),E(),M(this._parent,"default","auto",!0),s(_(e.prototype),"deleteShape",this).call(this,r)}},{key:"deleteSelectedShapes",value:function(){var t=g(this._selectedShapes);return x(this._selectedShapes),this.fire(z.SELECTION_CHANGED,{unselectedShapes:t,selectedShapes:[]}),E(),M(this._parent,"default","auto",!0),s(_(e.prototype),"deleteShape",this).call(this,t)}},{key:"interactionsEnabled",get:function(){return this._activated}},{key:"enableInteractions",value:function(){return this._enableEvents(),this._activated=!0,this}},{key:"disableInteractions",value:function(){return(!(arguments.length>0&&void 0!==arguments[0])||arguments[0])&&this.clearSelection(),this._disableEvents(),this._activated=!1,this}}]),e}(I.a);Object.assign(z,I.a.EventConstants),H.EventConstants=z},function(t,e,r){"use strict";function n(t,e,r,n,i){var o=s.create(),a=u.a.create();c.a.svd(o,a,null,r.objectToWorldMatrix);var l=u.a.create();s.sub(l,r.startWorldPos,o),u.a.normalize(l,l);var f=o;s.sub(f,i,o),u.a.normalize(f,f);var h=u.a.angle(l,f);r.keys.shiftKey&&(h=Math.round(h/Math.QUATER_PI)*Math.QUATER_PI),e.setRotation(r.startLocalRot+Math.RAD_TO_DEG*h)}function i(t,e,r,i,o){var a=t.parent,l=s.create(),f=s.create(),h=s.create();if(e.rotate)return void n(t,a,e,r,i,o);var p=e.keys.shiftKey||e.uniformScaleOnly,d=e.keys.altKey||e.centerScaleOnly,_=s.create();if(c.a.svd(_,null,null,e.objectToWorldMatrix),u.a.sub(f,i,e.startWorldPos),p&&e.controlIndex<4){var v=[e.objectToWorldMatrix[0],e.objectToWorldMatrix[1]],y=[e.objectToWorldMatrix[2],e.objectToWorldMatrix[3]],b=u.a.create();e.controlIndex<2&&u.a.negate(v,v),e.controlIndex%2==0&&u.a.negate(y,y),u.a.normalize(v,v),u.a.normalize(y,y),u.a.add(b,v,y),u.a.normalize(b,b);var m=u.a.cross2d(f,b),g=null;0===e.controlIndex||3===e.controlIndex?(g=y,m<0&&(g=v)):(g=v,m<0&&(g=y));var w=u.a.dot(f,g);w=Math.sign(w)*Math.sqrt(2*w*w),u.a.scale(f,b,w),s.addVec2(i,e.startWorldPos,f)}s.copy(l,i),s.transformMat2d(l,l,e.worldToObjectMatrix),u.a.sub(h,l,e.startObjectPos),s.copy(_,e.startLocalPos);var x=0,k=0;if(e.controlIndex<4)x=e.controlIndex<2?-1:1,k=e.controlIndex%2==0?-1:1,d||s.addVec2(_,_,u.a.scale(f,f,.5)),a.setPosition(_);else{var S=e.controlIndex-4,O=u.a.create();S%2==0?(u.a.set(O,e.objectToWorldMatrix[0],e.objectToWorldMatrix[1]),k=0,x=S<2?-1:1,p&&(k=x,h[1]=h[0])):(u.a.set(O,e.objectToWorldMatrix[2],e.objectToWorldMatrix[3]),x=0,k=S<2?-1:1,p&&(x=k,h[0]=h[1])),d||(u.a.normalize(O,O),u.a.scale(O,O,u.a.dot(f,O)),s.addVec2(_,_,u.a.scale(O,O,.5))),a.setPosition(_)}d&&(x*=2,k*=2),a.setScale([e.startLocalScale[0]*(1+x*h[0]/e.shapeWidth),e.startLocalScale[1]*(1+k*h[1]/e.shapeHeight)])}function o(t,e,r,n,i){var o=u.a.create(),a=s.create();if(c.a.svd(a,null,null,e.objectToWorldMatrix),e.keys.shiftKey){s.sub(o,r,e.startPos);var l=Math.atan2(o[1],o[0]);l=Math.round(l/Math.QUATER_PI)*Math.QUATER_PI;var f=[Math.cos(l),Math.sin(l)];u.a.scale(o,f,u.a.dot(o,f)),u.a.transformMat2(o,o,i.screenToWorldMatrix)}else u.a.sub(o,n,e.startWorldPos);s.addVec2(a,e.startLocalPos,o),t.setPosition(a)}function a(t,e,r,n){var i=t.parent,o=i.numVerts;if(e.controlIndex>=o){var a=Math.min(e.controlIndex-o,o-1),c=a===o-1?0:a+1,l=s.create(),f=s.create(),h=s.create(),p=u.a.create(),d=i.vertsRef,_=i.globalXform;s.transformMat2d(f,d[a],_),s.transformMat2d(h,d[c],_),s.sub(p,h,f),u.a.scale(p,p,.5),s.addVec2(l,f,p),e.controlIndex=i.insertVert(a+1,l)}else i.setVertPosition(e.controlIndex,n)}e.a=i,e.b=o,e.c=a;var s=r(0),c=r(2),u=r(3)},function(t,e,r){"use strict";function n(t){var e=t.backingStorePixelRatio||t.webkitBackingStorePixelRatio||t.mozBackingStorePixelRatio||t.msBackingStorePixelRatio||t.oBackingStorePixelRatio||t.backingStorePixelRatio||1;return(window.devicePixelRatio||1)/e}function i(t){var e=n(t);if(1===e)return 1;["fillRect","clearRect","strokeRect","isPointInPath","isPointInStroke"].forEach(function(r){t[r]=function(t){return function(){for(var r=arguments.length,n=new Array(r),i=0;i<r;i++)n[i]=arguments[i];return n=n.map(function(t){return t*e}),t.apply(this,n)}}(t[r])});var r=[e,0,0,e,0,0];return t.setTransform=function(t){return function(){t.apply(this,r),this.transform.apply(this,arguments)}}(t.setTransform),e}e.a=i},function(t,e,r){"use strict";function n(t,e){t.forEach(function(t){e[t]&&(e[t]=e[t].bind(e))})}e.a=n},function(t,e,r){"use strict";function n(t){"@babel/helpers - typeof";return(n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function a(t,e,r){return e&&o(t.prototype,e),r&&o(t,r),t}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&c(t,e)}function c(t,e){return(c=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function u(t){var e=h();return function(){var r,n=p(t);if(e){var i=p(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return l(this,r)}}function l(t,e){return!e||"object"!==n(e)&&"function"!=typeof e?f(t):e}function f(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function h(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(t){return!1}}function p(t){return(p=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}r.d(e,"a",function(){return x});var d=r(4),_=r(0),v=r(3),y=r(2),b=r(7),m=r(11),g=r(12),w=function(t){function e(t,n){var o,a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return i(this,e),o=r.call(this,["changed","changed:xform"]),o._viewport=d.clone(t),o._projectionDimensions=v.a.clone(n),o._yflip=a,o._screenMatrix=y.a.create(),o._screenDirty=!0,o}s(e,t);var r=u(e);return a(e,[{key:"isYFlipped",value:function(){return this._yflip}},{key:"viewport",get:function(){return d.clone(this._viewport)},set:function(t){if(!d.equals(t,this._viewport)){var e=d.clone(this._viewport);d.copy(this._viewport,t),this._screenDirty=!0,this._worldToScreenOutdated=!0,this.fire("changed",{attr:"viewport",prevVal:e,currVal:t})}return this}},{key:"viewportRef",get:function(){return this._viewport}},{key:"screenMatrix",get:function(){if(this._screenDirty){var t=_.create(),e=v.a.create();d.getCenter(t,this._viewport),d.getExtents(e,this._viewport),y.a.set(this._screenMatrix,e[0],0,0,e[1],t[0],t[1]),this._worldToScreenOutdated=!0,this._screenDirty=!1}return this._screenMatrix}}]),e}(g.a),x=function(t){function e(t,n,o){var a;return i(this,e),a=r.call(this,t,n,o),a._viewMatrix=y.a.create(),a._viewDirty=!0,a._projMatrix=y.a.create(),a._projDirty=!0,a}s(e,t);var r=u(e);return a(e,[{key:"projectionDimensions",get:function(){return v.a.clone(this._projectionDimensions)},set:function(t){if(!v.a.equals(t,this._projectionDimensions)){var e=v.a.clone(this._projectionDimensions);d.copy(this._projectionDimensions,t),this._viewDirty=!0,this._projDirty=!0,this.fire("changed",{attr:"projectionDimensions",prevVal:e,currVal:t})}return this}},{key:"projectionDimensionsRef",get:function(){return this._projectionDimensions}},{key:"_localXformUpdated",value:function(){this._boundsOutOfDate=!0}},{key:"_globalXformUpdated",value:function(){this._boundsOutOfDate=!0}},{key:"viewMatrix",get:function(){if(this._viewDirty||this._boundsOutOfDate||this._xformDirty||this._lxformDirty){var t=_.create(),e=v.a.create(),r=v.a.create(),n=this.globalXform;y.a.svd(t,e,r,n),y.a.fromTranslation(this._viewMatrix,v.a.negate(t,t)),y.a.rotate(this._viewMatrix,this._viewMatrix,-r[0]),y.a.scale(this._viewMatrix,this._viewMatrix,e),y.a.rotate(this._viewMatrix,this._viewMatrix,-r[1]),this._worldToScreenOutdated=!0,this._viewDirty=!1}return this._viewMatrix}},{key:"projMatrix",get:function(){if(this._projDirty){var t=this._yflip?-1:1;y.a.set(this._projMatrix,2/this._projectionDimensions[0],0,0,2*t/this._projectionDimensions[1],0,0),this._worldToScreenOutdated=!0,this._projDirty=!1}return this._projMatrix}},{key:"_matricesDirty",value:function(){return this._boundsOutOfDate||this._lxformDirty||this._xformDirty||this._viewDirty||this._projDirty||this._screenDirty}},{key:"worldToScreenMatrix",get:function(){return(!this._worldToScreenMatrix||this._worldToScreenOutdated||this._matricesDirty())&&(this._worldToScreenMatrix||(this._worldToScreenMatrix=y.a.create()),y.a.copy(this._worldToScreenMatrix,this.viewMatrix),y.a.multiply(this._worldToScreenMatrix,this.projMatrix,this._worldToScreenMatrix),y.a.multiply(this._worldToScreenMatrix,this.screenMatrix,this._worldToScreenMatrix),this._worldToScreenOutdated=!1,this._screenToWorldOutdated=!0),this._worldToScreenMatrix}},{key:"screenToWorldMatrix",get:function(){return(!this._screenToWorld||this._screenToWorldOutdated||this._matricesDirty())&&(this._screenToWorld||(this._screenToWorld=y.a.create()),y.a.copy(this._screenToWorld,this.worldToScreenMatrix),y.a.invert(this._screenToWorld,this._screenToWorld),this._screenToWorldOutdated=!1),this._screenToWorld}},{key:"worldViewBounds",get:function(){var t=this.viewport;return d.transformMat2d(t,t,this.screenToWorldMatrix),t}}]),e}(Object(b.a)(w,Object(m.b)("changed:xform")))},function(t,e,r){var n,i;!function(o,a){n=a,void 0!==(i="function"==typeof n?n.call(e,r,e,t):n)&&(t.exports=i)}(0,function(){function t(t,e){var r=Object.prototype.toString.call(t),n="[object Array]"===r||"[object NodeList]"===r||"[object HTMLCollection]"===r||"[object Object]"===r||"undefined"!=typeof jQuery&&t instanceof jQuery||"undefined"!=typeof Elements&&t instanceof Elements,i=0,o=t.length;if(n)for(;i<o;i++)e(t[i]);else e(t)}if("undefined"==typeof window)return null;var e=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||function(t){return window.setTimeout(t,20)},r=function(n,i){function o(){var t=[];this.add=function(e){t.push(e)};var e,r;this.call=function(){for(e=0,r=t.length;e<r;e++)t[e].call()},this.remove=function(n){var i=[];for(e=0,r=t.length;e<r;e++)t[e]!==n&&i.push(t[e]);t=i},this.length=function(){return t.length}}function a(t,e){return t.currentStyle?t.currentStyle[e]:window.getComputedStyle?window.getComputedStyle(t,null).getPropertyValue(e):t.style[e]}function s(t,r){if(t.resizedAttached){if(t.resizedAttached)return void t.resizedAttached.add(r)}else t.resizedAttached=new o,t.resizedAttached.add(r);t.resizeSensor=document.createElement("div"),t.resizeSensor.className="resize-sensor";var n="position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;",i="position: absolute; left: 0; top: 0; transition: 0s;";t.resizeSensor.style.cssText=n,t.resizeSensor.innerHTML='<div class="resize-sensor-expand" style="'+n+'"><div style="'+i+'"></div></div><div class="resize-sensor-shrink" style="'+n+'"><div style="'+i+' width: 200%; height: 200%"></div></div>',t.appendChild(t.resizeSensor),"static"==a(t,"position")&&(t.style.position="relative");var s,c,u,l,f=t.resizeSensor.childNodes[0],h=f.childNodes[0],p=t.resizeSensor.childNodes[1],d=t.offsetWidth,_=t.offsetHeight,v=function(){h.style.width="100000px",h.style.height="100000px",f.scrollLeft=1e5,f.scrollTop=1e5,p.scrollLeft=1e5,p.scrollTop=1e5};v();var y=function(){c=0,s&&(d=u,_=l,t.resizedAttached&&t.resizedAttached.call())},b=function(){u=t.offsetWidth,l=t.offsetHeight,s=u!=d||l!=_,s&&!c&&(c=e(y)),v()},m=function(t,e,r){t.attachEvent?t.attachEvent("on"+e,r):t.addEventListener(e,r)};m(f,"scroll",b),m(p,"scroll",b)}t(n,function(t){s(t,i)}),this.detach=function(t){r.detach(n,t)}};return r.detach=function(e,r){t(e,function(t){t.resizedAttached&&"function"==typeof r&&(t.resizedAttached.remove(r),t.resizedAttached.length())||t.resizeSensor&&(t.contains(t.resizeSensor)&&t.removeChild(t.resizeSensor),delete t.resizeSensor,delete t.resizedAttached)})},r})},function(t,e,r){"use strict";function n(t){"@babel/helpers - typeof";return(n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function a(t,e,r){return e&&o(t.prototype,e),r&&o(t,r),t}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&c(t,e)}function c(t,e){return(c=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function u(t){var e=h();return function(){var r,n=p(t);if(e){var i=p(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return l(this,r)}}function l(t,e){return!e||"object"!==n(e)&&"function"!=typeof e?f(t):e}function f(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function h(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(t){return!1}}function p(t){return(p=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}r.d(e,"a",function(){return m});var d=r(4),_=r(0),v=r(2),y=r(3),b=r(9),m=function(t){function e(t,n){var o;return i(this,e),o=r.call(this,n),o._baseVertShape=t,o._vertRadius=4,o._transformedVerts=[],o._baseaabox=d.create(),o._worldToScreenMatrix=v.a.create(),o}s(e,t);var r=u(e);return a(e,[{key:"_updateAABox",value:function(t){var e=this._baseVertShape.aabox;if(!d.equals(e,this._baseaabox)||!v.a.equals(t,this._worldToScreenMatrix)){d.copy(this._baseaabox,e),v.a.copy(this._worldToScreenMatrix,t),d.transformMat2d(this._aabox,this._baseaabox,this._worldToScreenMatrix);var r=this._vertRadius+this.strokeWidth;d.expand(this._aabox,this._aabox,[r,r])}}},{key:"containsPoint",value:function(t,e,r,n){var i={hit:!1,controlIndex:-1};if(this._updateAABox(r),this.visible&&d.containsPt(this._aabox,t)){var o=d.create(),a=this._vertRadius+this.strokeWidth/2,s=[a,a],c=0;for(c=0;c<this._transformedVerts.length;c+=1)if(d.initCenterExtents(o,this._transformedVerts[c],s),d.containsPt(o,t)){i.hit=!0,i.controlIndex=c;break}if(!i.hit){var u=_.create(),l=y.a.create(),f=1.5*n.lineWidth;for(y.a.set(s,f,f),c=0;c<this._transformedVerts.length-1;c+=1)if(_.sub(l,this._transformedVerts[c+1],this._transformedVerts[c]),y.a.scale(l,l,.5),_.addVec2(u,this._transformedVerts[c],l),d.initCenterExtents(o,u,s),d.containsPt(o,t)){i.hit=!0,i.controlIndex=this._transformedVerts.length+c;break}c>0&&c===this._transformedVerts.length-1&&(_.sub(l,this._transformedVerts[0],this._transformedVerts[c]),y.a.scale(l,l,.5),_.addVec2(u,this._transformedVerts[c],l),d.initCenterExtents(o,u,s),d.containsPt(o,t)&&(i.hit=!0,i.controlIndex=this._transformedVerts.length+c))}}return i}},{key:"renderBounds",value:function(t,e,r){this._updateAABox(e),t.save(),t.setTransform(1,0,0,1,0,0),r.setStrokeCtx(t);var n=_.create(),i=y.a.create();d.getCenter(n,this._aabox),d.getExtents(i,this._aabox),t.beginPath(),t.rect(n[0]-i[0],n[1]-i[1],2*i[0],2*i[1]),t.stroke(),t.restore()}},{key:"render",value:function(t){var e=this;t.save(),t.setTransform(1,0,0,1,0,0);var r=this._baseVertShape._fullXform,n=this._baseVertShape.vertsRef;this._transformedVerts=new Array(n.length);var i=_.create(),o=y.a.create();t.beginPath();var a=0;this._transformedVerts[a]=_.create(),_.transformMat2d(this._transformedVerts[a],n[a],r);var s=Math.max(1.5*t.lineWidth,2.5);for(a=0;a<n.length-1;a+=1)this._transformedVerts[a+1]=_.create(),_.transformMat2d(this._transformedVerts[a+1],n[a+1],r),_.sub(o,this._transformedVerts[a+1],this._transformedVerts[a]),y.a.scale(o,o,.5),_.addVec2(i,this._transformedVerts[a],o),t.moveTo(i[0]+s,i[1]),t.arc(i[0],i[1],s,0,Math.TWO_PI);a>0&&(_.sub(o,this._transformedVerts[0],this._transformedVerts[a]),y.a.scale(o,o,.5),_.addVec2(i,this._transformedVerts[a],o),t.moveTo(i[0]+s,i[1]),t.arc(i[0],i[1],s,0,Math.TWO_PI),t.fillStyle=t.strokeStyle,t.fill()),t.beginPath(),this._transformedVerts.forEach(function(r){t.moveTo(r[0]+e._vertRadius,r[1]),t.arc(r[0],r[1],e._vertRadius,0,Math.TWO_PI)}),this.isFillVisible()&&(this.setFillCtx(t),t.fill()),this.isStrokeVisible()&&(this.setStrokeCtx(t),t.stroke()),t.restore()}}]),e}(b.a)},function(t,e,r){"use strict";function n(t){"@babel/helpers - typeof";return(n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function a(t,e,r){return e&&o(t.prototype,e),r&&o(t,r),t}function s(t,e,r){return(s="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,r){var n=c(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(r):i.value}})(t,e,r||t)}function c(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=_(t)););return t}function u(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&l(t,e)}function l(t,e){return(l=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function f(t){var e=d();return function(){var r,n=_(t);if(e){var i=_(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return h(this,r)}}function h(t,e){return!e||"object"!==n(e)&&"function"!=typeof e?p(t):e}function p(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function d(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(t){return!1}}function _(t){return(_=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function v(t,e,r,n,i,o,a){m.transformMat2d(e,e,r),t.setTransform(1,0,0,1,0,0),t.translate(e[0],e[1]),t.rotate(o[1]),t.scale(a[0],a[1]),t.rotate(o[0]),t.translate(-e[0],-e[1]),t.rect(e[0]-i,e[1]-i,n,n)}function y(t,e,r,n,i,o,a,s,c,u){var l=!1,f=!1;if(m.transformMat2d(e,e,r),m.distance(e,t)<=s){k.a.negate(e,e),n[4]=n[0]*e[0]+n[2]*e[1],n[5]=n[1]*e[0]+n[3]*e[1];var h=0,p=0;m.transformMat2d(e,t,n),(Math.abs(e[0])<=i&&Math.abs(e[1])<=i||Boolean(c)&&Boolean(u)&&(f=(h=c*e[0])>-i&&h<=a&&(p=u*e[1])>-i&&p<=a))&&(l=!0)}return{hit:l,rotate:f}}r.d(e,"a",function(){return O});var b=r(4),m=r(0),g=r(11),w=r(2),x=r(24),k=r(3),S={SIDES:4},O=function(t){function e(t){var n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{scalable:!0,rotatable:!0};return i(this,e),n=r.call(this,t),n._interactiveBoxSize=8,n._interactiveBoxPadding=10,t&&void 0!==t.vertexSize&&(n._interactiveBoxSize=t.vertexSize),n._scalable=!0,n._rotatable=!0,o&&(void 0!==o.scalable&&(n._scalable=Boolean(o.scalable)),void 0!==o.rotatable&&(n._rotatable=Boolean(o.rotatable))),n}u(e,t);var r=f(e);return a(e,[{key:"containsPoint",value:function(t){var e={hit:!1,rotate:!1,controlIndex:-1},r=this.aabox;if((this._rotatable||this._scalable)&&this.visible&&b.containsPt(r,t)){var n=k.a.create(),i=k.a.create();w.a.svd(null,n,i,this._fullXform);var o=w.a.create();n[0]=n[0]<0?-1:1,n[1]=n[1]<0?-1:1,n[0]*n[1]>0&&k.a.negate(i,i),w.a.rotate(o,o,i[1]),w.a.scale(o,o,n),w.a.rotate(o,o,i[0]);for(var a=this._rotatable?this._interactiveBoxPadding:0,s=this._interactiveBoxSize/2,c=this.width/2,u=this.height/2,l=m.create(),f=s+a,h=Math.sqrt(2*f*f),p=0,d=0,_=0;_<S.SIDES;_+=1)if(p=_<2?-1:1,d=_%2==0?-1:1,m.set(l,p*c,d*u),e=y(t,l,this._fullXform,o,s,this._interactiveBoxSize,f,h,p,d),e.hit){e.controlIndex=_;break}if(!e.hit&&this._scalable)for(var v=0;v<S.SIDES;v+=1)if(p=v%2==0?v<2?-1:1:0,d=v%2==0?0:v<2?-1:1,m.set(l,p*c,d*u),e=y(t,l,this._fullXform,o,s,this._interactiveBoxSize,f,h,p,d),e.hit){e.controlIndex=v+S.SIDES;break}e.rotate&&!this._rotatable?e.rotate=!1:e.rotate||this._scalable||(e.rotate=!0)}return e}},{key:"_updatelocalxform",value:function(t){if(this._lxformDirty||t){var e=m.clone(this._pos);m.addVec2(e,e,this._parent.pivotRef),Object(g.a)(this._localXform,this._rotDeg,this._scale,e,this._pivot),this._localXformUpdated&&this._localXformUpdated(),this._lxformDirty=!1}}},{key:"_updateglobalxform",value:function(){(this._lxformDirty||this._xformDirty)&&(this._updatelocalxform(!0),this._parent?w.a.multiply(this._globalXform,this._parent.globalXform,this._localXform):w.a.copy(this._globalXform,this._localXform),this._globalXformUpdated&&this._globalXformUpdated(),this._xformDirty=!1)}},{key:"_updateAABox",value:function(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0]||this._geomDirty||this._boundsOutOfDate){var t=this._rotatable?this._interactiveBoxPadding:0,e=t+this._interactiveBoxSize/2;b.initCenterExtents(this._aabox,m.create(0,0),[this.width/2,this.height/2]),b.transformMat2d(this._aabox,this._aabox,this._fullXform),b.expand(this._aabox,this._aabox,[e,e]),this._aaboxUpdated=!0,this._geomDirty=this._boundsOutOfDate=!1}}},{key:"width",get:function(){return this.parent&&"undefined"!==this.parent.width?this.parent.width:0}},{key:"height",get:function(){return this.parent&&"undefined"!==this.parent.height?this.parent.height:0}},{key:"renderBounds",value:function(t,e,r){var n=this.aabox;t.save(),t.setTransform(1,0,0,1,0,0),r.setStrokeCtx(t);var i=m.create(),o=k.a.create();b.getCenter(i,n),b.getExtents(o,n),t.beginPath(),t.rect(i[0]-o[0],i[1]-o[1],2*o[0],2*o[1]),t.stroke(),t.restore()}},{key:"render",value:function(t,r,n){if(this.parent&&void 0!==this.parent.width&&"undefined"!==this.parent.height){this._aaboxUpdated=!1,s(_(e.prototype),"render",this).call(this,t,r,n,!1),this._aaboxUpdated||this._updateAABox(!0);var i=k.a.create(),o=k.a.create();w.a.svd(null,i,o,this._fullXform),i[0]=i[0]<0?-1:1,i[1]=i[1]<0?-1:1;var a=this._interactiveBoxSize/2,c=this.width/2,u=this.height/2,l=[c,u];t.save(),t.beginPath(),v(t,l,this._fullXform,this._interactiveBoxSize,a,o,i),m.set(l,c,-u),v(t,l,this._fullXform,this._interactiveBoxSize,a,o,i),m.set(l,-c,-u),v(t,l,this._fullXform,this._interactiveBoxSize,a,o,i),m.set(l,-c,u),v(t,l,this._fullXform,this._interactiveBoxSize,a,o,i),this._scalable&&(m.set(l,0,u),v(t,l,this._fullXform,this._interactiveBoxSize,a,o,i),m.set(l,0,-u),v(t,l,this._fullXform,this._interactiveBoxSize,a,o,i),m.set(l,c,0),v(t,l,this._fullXform,this._interactiveBoxSize,a,o,i),m.set(l,-c,0),v(t,l,this._fullXform,this._interactiveBoxSize,a,o,i)),this.isFillVisible()&&(n.setFillStyle(t,this),t.fill()),this.isStrokeVisible()&&(n.setStrokeStyle(t,this),t.setTransform(1,0,0,1,0,0),t.stroke()),t.restore()}}}]),e}(x.a)},function(t,e,r){"use strict";var n=r(6),i=r(5);n.b.equals=function(t,e){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,n=t[0],o=t[1],a=t[2],s=t[3],c=e[0],u=e[1],l=e[2],f=e[3],h=null!==r?r:i.EPSILON;return Math.abs(n-c)<=h*Math.max(1,Math.abs(n),Math.abs(c))&&Math.abs(o-u)<=h*Math.max(1,Math.abs(o),Math.abs(u))&&Math.abs(a-l)<=h*Math.max(1,Math.abs(a),Math.abs(l))&&Math.abs(s-f)<=h*Math.max(1,Math.abs(s),Math.abs(f))},e.a=n.b},function(t,e,r){"use strict";function n(t){"@babel/helpers - typeof";return(n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function a(t,e,r){return e&&o(t.prototype,e),r&&o(t,r),t}function s(t,e,r){return(s="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,r){var n=c(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(r):i.value}})(t,e,r||t)}function c(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=_(t)););return t}function u(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&l(t,e)}function l(t,e){return(l=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function f(t){var e=d();return function(){var r,n=_(t);if(e){var i=_(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return h(this,r)}}function h(t,e){return!e||"object"!==n(e)&&"function"!=typeof e?p(t):e}function p(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function d(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(t){return!1}}function _(t){return(_=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}r.d(e,"a",function(){return g});var v=r(4),y=r(0),b=r(9),m=r(8),g=function(t){function e(t){var n;return i(this,e),n=r.call(this,t),n._radius=10,void 0!==t.radius&&(n.radius=t.radius),v.initCenterExtents(n._aabox,y.create(0,0),[n._radius,n._radius]),n}u(e,t);var r=f(e);return a(e,[{key:"radius",get:function(){return this._radius},set:function(t){if("number"!=typeof t)throw new Error("Radius must be a number");if(t!==this._radius){var e=this._radius;this._radius=t,this._geomDirty=!0,this.fire("changed:geom",{attr:"radius",prevVal:e,currVal:this._radius})}return this}},{key:"getDimensions",value:function(){var t=2*this.radius;return[t,t]}},{key:"width",get:function(){return 2*this.radius}},{key:"height",get:function(){return 2*this.radius}},{key:"_updateAABox",value:function(){if(this._geomDirty||this._boundsOutOfDate){var t=this._pos,e=this._scale,r=m.a.DEG_TO_RAD*this._rotDeg,n=m.a.pow(m.a.cos(r),2),i=m.a.pow(m.a.sin(r),2),o=m.a.pow(e[0]*this._radius,2),a=m.a.pow(e[1]*this._radius,2),s=m.a.sqrt(a*i+o*n),c=m.a.sqrt(o*i+a*n);v.initCenterExtents(this._aabox,t,[s,c]),this._geomDirty=!1,this._boundsOutOfDate=!1}}},{key:"_draw",value:function(t){t.setTransform(this._fullXform[0],this._fullXform[1],this._fullXform[2],this._fullXform[3],this._fullXform[4],this._fullXform[5]),t.arc(0,0,this._radius,0,m.a.TWO_PI,!1)}},{key:"toJSON",value:function(){return Object.assign({type:"Circle",radius:this.radius},s(_(e.prototype),"toJSON",this).call(this))}}]),e}(b.a)},function(t,e,r){"use strict";function n(t){"@babel/helpers - typeof";return(n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function a(t,e,r){return e&&o(t.prototype,e),r&&o(t,r),t}function s(t,e,r){return(s="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,r){var n=c(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(r):i.value}})(t,e,r||t)}function c(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=_(t)););return t}function u(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&l(t,e)}function l(t,e){return(l=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function f(t){var e=d();return function(){var r,n=_(t);if(e){var i=_(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return h(this,r)}}function h(t,e){return!e||"object"!==n(e)&&"function"!=typeof e?p(t):e}function p(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function d(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(t){return!1}}function _(t){return(_=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}r.d(e,"a",function(){return m});var v=r(13),y=r(0),b={MINIMUM_POINTS:3},m=function(t){function e(t){var n;if(i(this,e),n=r.call(this,t),n._verts.length<b.MINIMUM_POINTS)throw new Error("Poly shapes must be initialized with an array of 2d points and contain at least 3 points");return n}u(e,t);var r=f(e);return a(e,[{key:"removeVert",value:function(t){if(this._verts.length<b.MINIMUM_POINTS)throw new Error("Cannot remove vertex ".concat(t,". It would result in a poly with < 3 points. A poly must contain at least 3 points."));s(_(e.prototype),"removeVert",this).call(this,t)}},{key:"_draw",value:function(t){var e=!1;if(this._verts.length>=b.MINIMUM_POINTS){t.setTransform(1,0,0,1,0,0);var r=y.create();y.transformMat2d(r,this._verts[0],this._fullXform),t.moveTo(r[0],r[1]);for(var n=1;n<this._verts.length;n+=1)y.transformMat2d(r,this._verts[n],this._fullXform),t.lineTo(r[0],r[1]);t.closePath(),e=!0}return e}},{key:"toJSON",value:function(){return Object.assign(s(_(e.prototype),"toJSON",this).call(this),{type:"Poly"})}}]),e}(v.a)},function(t,e,r){"use strict";function n(t){"@babel/helpers - typeof";return(n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function a(t,e,r){return e&&o(t.prototype,e),r&&o(t,r),t}function s(t,e,r){return(s="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,r){var n=c(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(r):i.value}})(t,e,r||t)}function c(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=_(t)););return t}function u(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&l(t,e)}function l(t,e){return(l=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function f(t){var e=d();return function(){var r,n=_(t);if(e){var i=_(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return h(this,r)}}function h(t,e){return!e||"object"!==n(e)&&"function"!=typeof e?p(t):e}function p(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function d(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(t){return!1}}function _(t){return(_=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}r.d(e,"a",function(){return w});var v=r(4),y=r(9),b=r(2),m=r(8),g=r(0),w=function(t){function e(t){var n;return i(this,e),n=r.call(this,t),n._size=5,void 0!==t.size&&(n.size=t.size),v.initCenterExtents(n._aabox,g.create(0,0),[n._radius,n._radius]),n.translate(t.x||0,t.y||0),n}u(e,t);var r=f(e);return a(e,[{key:"size",get:function(){return this._size},set:function(t){if("number"!=typeof t)throw new Error("Radius must be a number");if(t!==this._size){var e=this._size;this._size=t,this._geomDirty=!0,this.fire("changed:geom",{attr:"size",prevVal:e,currVal:this._size})}}},{key:"_updateAABox",value:function(){if(this._geomDirty||this._boundsOutOfDate){var t=this._pos,e=this._scale,r=m.a.DEG_TO_RAD*this._rotDeg,n=m.a.pow(m.a.cos(r),2),i=m.a.pow(m.a.sin(r),2),o=m.a.pow(e[0]*this._size,2),a=m.a.pow(e[1]*this._size,2),s=m.a.sqrt(a*i+o*n),c=m.a.sqrt(o*i+a*n);v.initCenterExtents(this._aabox,t,[s,c]),this._geomDirty=!1,this._boundsOutOfDate=!1}}},{key:"_draw",value:function(t){t.setTransform(1,0,0,1,0,0);var e=g.create();b.a.svd(e,null,null,this._fullXform),t.arc(e[0],e[1],this._size,0,m.a.TWO_PI,!1)}},{key:"toJSON",value:function(){return Object.assign({type:"Point",size:this.size},s(_(e.prototype),"toJSON",this).call(this))}}]),e}(y.a)}])});

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = coordinateGridMixin;

var _core = __webpack_require__(3);

var _baseMixin = __webpack_require__(7);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

var _binningMixin = __webpack_require__(252);

var _binningMixin2 = _interopRequireDefault(_binningMixin);

var _colorMixin = __webpack_require__(12);

var _colorMixin2 = _interopRequireDefault(_colorMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _events = __webpack_require__(15);

var _filters = __webpack_require__(21);

var _lockAxisMixin = __webpack_require__(40);

var _lockAxisMixin2 = _interopRequireDefault(_lockAxisMixin);

var _marginMixin = __webpack_require__(18);

var _marginMixin2 = _interopRequireDefault(_marginMixin);

var _utils = __webpack_require__(4);

var _coreAsync = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
  * Coordinate Grid is an abstract base chart designed to support a number of coordinate grid based
  * concrete chart types, e.g. bar chart, line chart, and bubble chart.
  * @name coordinateGridMixin
  * @memberof dc
  * @mixin
  * @mixes dc.colorMixin
  * @mixes dc.marginMixin
  * @mixes dc.baseMixin
  * @param {Object} _chart
  * @return {dc.coordinateGridMixin}
  */

var DEFAULT_NUM_TICKS = 10;
var MAX_TICK_WIDTH = 64;
var DEFAULT_TIME_DIMENSION_INDEX = 0;
var ENTER_KEY = 13;
var ONE_SECOND_IN_MS = 1000;

function coordinateGridMixin(_chart) {
  var GRID_LINE_CLASS = "grid-line";
  var HORIZONTAL_CLASS = "horizontal";
  var VERTICAL_CLASS = "vertical";
  var Y_AXIS_LABEL_CLASS = "y-axis-label";
  var X_AXIS_LABEL_CLASS = "x-axis-label";
  var DEFAULT_AXIS_LABEL_PADDING = 12;

  /* OVERRIDE EXTEND ----------------------------------------------------------*/
  var _hasBeenRendered = false;
  /* --------------------------------------------------------------------------*/

  _chart = (0, _lockAxisMixin2.default)((0, _colorMixin2.default)((0, _marginMixin2.default)((0, _baseMixin2.default)(_chart))));

  _chart.colors(_d2.default.scale.category10());
  _chart._mandatoryAttributes().push("x");
  _chart._rangeFocused = false;
  _chart._rangeInput = false;
  _chart._binInput = false;
  _chart._binSnap = false;

  var NO_CACHE = false;
  var cachedXTickFormat = NO_CACHE;
  var cachedYTickFormat = NO_CACHE;

  function zoomHandler() {
    _refocused = true;
    if (_zoomOutRestrict) {
      _chart.x().domain(constrainRange(_chart.x().domain(), _xOriginalDomain));
      if (_rangeChart) {
        _chart.x().domain(constrainRange(_chart.x().domain(), _rangeChart.x().domain()));
      }
    }

    var domain = _chart.x().domain();
    var domFilter = _filters.filters.RangedFilter(domain[0], domain[1]);

    _chart.replaceFilter(domFilter);
    _chart.rescale();
    (0, _coreAsync.redrawAllAsync)(_chart.chartGroup());
  }

  var _parent = void 0;
  var _g = void 0;
  var _chartBodyG = void 0;

  var _x = void 0;
  var _xOriginalDomain = void 0;
  var _xAxis = _d2.default.svg.axis().orient("bottom");
  var _xUnits = _core.units.integers;
  var _xAxisPadding = 0;
  var _xElasticity = false;
  var _xAxisLabel = void 0;
  var _xAxisLabelPadding = 0;
  var _lastXDomain = void 0;

  var _y = void 0;
  var _yAxis = _d2.default.svg.axis().orient("left");
  var _yAxisPadding = 0;
  var _yElasticity = false;
  var _yAxisLabel = void 0;
  var _yAxisLabelPadding = 0;

  var _brush = _d2.default.svg.brush();
  var _brushOn = true;
  var _isBrushing = false;
  var _round = void 0;

  var _renderHorizontalGridLine = false;
  var _renderVerticalGridLine = false;

  var _refocused = false,
      _resizing = false;

  var _unitCount = void 0;

  var _zoomScale = [1, Infinity];
  var _zoomOutRestrict = true;

  var _zoom = _d2.default.behavior.zoom().on("zoom", zoomHandler);
  var _nullZoom = _d2.default.behavior.zoom().on("zoom", null);
  var _hasBeenMouseZoomable = false;

  var _rangeChart = void 0;
  var _focusChart = void 0;

  var _mouseZoomable = false;
  var _clipPadding = 0;

  var _outerRangeBandPadding = 0.5;
  var _rangeBandPadding = 0;

  var _useRightYAxis = false;

  /**
      * When changing the domain of the x or y scale, it is necessary to tell the chart to recalculate
      * and redraw the axes. (`.rescale()` is called automatically when the x or y scale is replaced
      * with {@link #dc.coordinateGridMixin+x .x()} or {@link #dc.coordinateGridMixin+y .y()}, and has
      * no effect on elastic scales.)
      * @name rescale
      * @memberof dc.coordinateGridMixin
      * @instance
      * @return {dc.coordinateGridMixin}
      */
  _chart.rescale = function () {
    _unitCount = undefined;
    _resizing = true;
    return _chart;
  };

  _chart.resizing = function () {
    return _resizing;
  };

  /**
      * Get or set the range selection chart associated with this instance. Setting the range selection
      * chart using this function will automatically update its selection brush when the current chart
      * zooms in. In return the given range chart will also automatically attach this chart as its focus
      * chart hence zoom in when range brush updates.
      * @name rangeChart
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {dc.coordinateGridMixin} [rangeChart]
      * @return {dc.coordinateGridMixin}
      */
  _chart.rangeChart = function (rangeChart) {
    if (!arguments.length) {
      return _rangeChart;
    }
    _rangeChart = rangeChart;

    if (_rangeChart) {
      _rangeChart.focusChart(_chart);
    }

    return _chart;
  };

  /**
      * Get or set the scale extent for mouse zooms.
      * @name zoomScale
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {Array<Number|Date>} [extent=[1, Infinity]]
      * @return {Array<Number|Date>}
      * @return {dc.coordinateGridMixin}
      */
  _chart.zoomScale = function (extent) {
    if (!arguments.length) {
      return _zoomScale;
    }
    _zoomScale = extent;
    return _chart;
  };

  /**
      * Get or set the zoom restriction for the chart. If true limits the zoom to origional domain of the chart.
      * @name zoomOutRestrict
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {Boolean} [zoomOutRestrict=true]
      * @return {Boolean}
      * @return {dc.coordinateGridMixin}
      */
  _chart.zoomOutRestrict = function (zoomOutRestrict) {
    if (!arguments.length) {
      return _zoomOutRestrict;
    }
    _zoomScale[0] = zoomOutRestrict ? 1 : 0;
    _zoomOutRestrict = zoomOutRestrict;
    return _chart;
  };

  _chart._generateG = function (parent, g, chartBodyG) {
    if (g) {
      _g = g;
      _chartBodyG = chartBodyG;
      return _g;
    }
    if (parent === undefined) {
      _parent = _chart.svg();
    } else {
      _parent = parent;
    }

    _g = _parent.append("g");

    _chartBodyG = _g.append("g").attr("class", "chart-body").attr("transform", "translate(" + _chart.margins().left + ", " + _chart.margins().top + ")").attr("clip-path", "url(#" + getClipPathId() + ")");

    return _g;
  };

  /**
      * Get or set the root g element. This method is usually used to retrieve the g element in order to
      * overlay custom svg drawing programatically. **Caution**: The root g element is usually generated
      * by dc.js internals, and resetting it might produce unpredictable result.
      * @name g
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {SVGElement} [gElement]
      * @return {SVGElement}
      * @return {dc.coordinateGridMixin}
      */
  _chart.g = function (gElement) {
    if (!arguments.length) {
      return _g;
    }
    _g = gElement;
    return _chart;
  };

  /**
      * Set or get mouse zoom capability flag (default: false). When turned on the chart will be
      * zoomable using the mouse wheel. If the range selector chart is attached zooming will also update
      * the range selection brush on the associated range selector chart.
      * @name mouseZoomable
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {Boolean} [mouseZoomable=false]
      * @return {Boolean}
      * @return {dc.coordinateGridMixin}
      */
  _chart.mouseZoomable = function (mouseZoomable) {
    if (!arguments.length) {
      return _mouseZoomable;
    }
    _mouseZoomable = mouseZoomable;
    return _chart;
  };

  /**
      * Retrieve the svg group for the chart body.
      * @name chartBodyG
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {SVGElement} [chartBodyG]
      * @return {SVGElement}
      */
  _chart.chartBodyG = function (chartBodyG) {
    if (!arguments.length) {
      return _chartBodyG;
    }
    _chartBodyG = chartBodyG;
    return _chart;
  };

  /**
      * **mandatory**
      *
      * Get or set the x scale. The x scale can be any d3
      * {@link https://github.com/mbostock/d3/wiki/Quantitative-Scales quantitive scale} or
      * {@link https://github.com/mbostock/d3/wiki/Ordinal-Scales ordinal scale}.
      * @name x
      * @memberof dc.coordinateGridMixin
      * @instance
      * @see {@link http://github.com/mbostock/d3/wiki/Scales d3.scale}
      * @example
      * // set x to a linear scale
      * chart.x(d3.scale.linear().domain([-2500, 2500]))
      * // set x to a time scale to generate histogram
      * chart.x(d3.time.scale().domain([new Date(1985, 0, 1), new Date(2012, 11, 31)]))
      * @param {d3.scale} [xScale]
      * @return {d3.scale}
      * @return {dc.coordinateGridMixin}
      */
  _chart.x = function (xScale) {
    if (!arguments.length) {
      return _x;
    }
    _x = xScale;
    _xOriginalDomain = _x.domain();
    _chart.rescale();
    return _chart;
  };

  _chart.xOriginalDomain = function (domain) {
    if (!arguments.length) {
      return _xOriginalDomain;
    }
    _xOriginalDomain = domain;
    return _chart;
  };

  /**
      * Set or get the xUnits function. The coordinate grid chart uses the xUnits function to calculate
      * the number of data projections on x axis such as the number of bars for a bar chart or the
      * number of dots for a line chart. This function is expected to return a Javascript array of all
      * data points on x axis, or the number of points on the axis. [d3 time range functions
      * d3.time.days, d3.time.months, and
      * d3.time.years](https://github.com/mbostock/d3/wiki/Time-Intervals#aliases) are all valid xUnits
      * function. dc.js also provides a few units function, see the {@link #utilities Utilities} section for
      * a list of built-in units functions. The default xUnits function is dc.units.integers.
      * @name xUnits
      * @memberof dc.coordinateGridMixin
      * @instance
      * @todo Add docs for utilities
      * @example
      * // set x units to count days
      * chart.xUnits(d3.time.days);
      * // set x units to count months
      * chart.xUnits(d3.time.months);
      *
      * // A custom xUnits function can be used as long as it follows the following interface:
      * // units in integer
      * function(start, end, xDomain) {
      *      // simply calculates how many integers in the domain
      *      return Math.abs(end - start);
      * };
      *
      * // fixed units
      * function(start, end, xDomain) {
      *      // be aware using fixed units will disable the focus/zoom ability on the chart
      *      return 1000;
      * @param {Function} [xUnits]
      * @return {Function}
      * @return {dc.coordinateGridMixin}
      */
  _chart.xUnits = function (xUnits) {
    if (!arguments.length) {
      return _xUnits;
    }
    _xUnits = xUnits;
    return _chart;
  };

  /**
      * Set or get the x axis used by a particular coordinate grid chart instance. This function is most
      * useful when x axis customization is required. The x axis in dc.js is an instance of a [d3
      * axis object](https://github.com/mbostock/d3/wiki/SVG-Axes#wiki-axis); therefore it supports any
      * valid d3 axis manipulation. **Caution**: The x axis is usually generated internally by dc;
      * resetting it may cause unexpected results.
      * @name xAxis
      * @memberof dc.coordinateGridMixin
      * @instance
      * @see {@link http://github.com/mbostock/d3/wiki/SVG-Axes d3.svg.axis}
      * @example
      * // customize x axis tick format
      * chart.xAxis().tickFormat(function(v) {return v + '%';});
      * // customize x axis tick values
      * chart.xAxis().tickValues([0, 100, 200, 300]);
      * @param {d3.svg.axis} [xAxis=d3.svg.axis().orient('bottom')]
      * @return {d3.svg.axis}
      * @return {dc.coordinateGridMixin}
      */
  _chart.xAxis = function (xAxis) {
    if (!arguments.length) {
      return _xAxis;
    }
    _xAxis = xAxis;
    return _chart;
  };

  /**
      * Turn on/off elastic x axis behavior. If x axis elasticity is turned on, then the grid chart will
      * attempt to recalculate the x axis range whenever a redraw event is triggered.
      * @name elasticX
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {Boolean} [elasticX=false]
      * @return {Boolean}
      * @return {dc.coordinateGridMixin}
      */
  _chart.elasticX = function (elasticX) {
    if (!arguments.length) {
      return _xElasticity;
    }
    _xElasticity = elasticX;
    return _chart;
  };

  /**
      * Set or get x axis padding for the elastic x axis. The padding will be added to both end of the x
      * axis if elasticX is turned on; otherwise it is ignored.
      *
      * padding can be an integer or percentage in string (e.g. '10%'). Padding can be applied to
      * number or date x axes.  When padding a date axis, an integer represents number of days being padded
      * and a percentage string will be treated the same as an integer.
      * @name xAxisPadding
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {Number|String} [padding=0]
      * @return {Number|String}
      * @return {dc.coordinateGridMixin}
      */
  _chart.xAxisPadding = function (padding) {
    if (!arguments.length) {
      return _xAxisPadding;
    }
    _xAxisPadding = padding;
    return _chart;
  };

  /**
      * Returns the number of units displayed on the x axis using the unit measure configured by
      * .xUnits.
      * @name xUnitCount
      * @memberof dc.coordinateGridMixin
      * @instance
      * @return {Number}
      */
  _chart.xUnitCount = function () {
    if (_unitCount === undefined) {
      var _units = _chart.xUnits()(_chart.x().domain()[0], _chart.x().domain()[1], _chart.x().domain());

      if (_units instanceof Array) {
        _unitCount = _units.length;
      } else {
        _unitCount = _units;
      }
    }

    return _unitCount;
  };

  /**
      * Gets or sets whether the chart should be drawn with a right axis instead of a left axis. When
      * used with a chart in a composite chart, allows both left and right Y axes to be shown on a
      * chart.
      * @name useRightYAxis
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {Boolean} [useRightYAxis=false]
      * @return {Boolean}
      * @return {dc.coordinateGridMixin}
      */
  _chart.useRightYAxis = function (useRightYAxis) {
    if (!arguments.length) {
      return _useRightYAxis;
    }
    _useRightYAxis = useRightYAxis;
    return _chart;
  };

  /**
      * Returns true if the chart is using ordinal xUnits ({@link #dc.units.ordinal dc.units.ordinal}, or false
      * otherwise. Most charts behave differently with ordinal data and use the result of this method to
      * trigger the appropriate logic.
      * @name isOrdinal
      * @memberof dc.coordinateGridMixin
      * @instance
      * @return {Boolean}
      */
  _chart.isOrdinal = function () {
    return _chart.xUnits() === _core.units.ordinal;
  };

  _chart._useOuterPadding = function () {
    return true;
  };

  _chart._ordinalXDomain = function () {
    var groups = _chart._computeOrderedGroups(_chart.data());
    return groups.map(_chart.keyAccessor());
  };

  function compareDomains(d1, d2) {
    return !d1 || !d2 || d1.length !== d2.length || d1.some(function (elem, i) {
      // The date objects here may be invalid for some reason. We detect that by ensuring
      // getTime() doesn't return NaN. If invalid, we use toString() instead of toISOString,
      // since the former doesn't throw an exception with invalid dates.
      var elemString = elem instanceof Date && !isNaN(elem.getTime()) ? elem.toISOString() : elem.toString();
      var d2String = d2[i] instanceof Date && !isNaN(d2[i].getTime()) ? d2[i].toISOString() : d2[i].toString();
      return elem && d2[i] ? elemString !== d2String : elem === d2[i];
    });
  }

  function prepareXAxis(g, render) {
    if (!_chart.isOrdinal() && _chart.elasticX() && (!_chart.rangeChart() || _chart.rangeChart() && !_chart.rangeChart().filters().length)) {
      _x.domain([_chart.xAxisMin(), _chart.xAxisMax()]);
    } else if (_chart.elasticX() || _x.domain().length === 0) {
      _x.domain(_chart._ordinalXDomain());
    }

    var xdom = _x ? _x.domain() : [];
    if (render || compareDomains(_lastXDomain, xdom)) {
      _chart.rescale();
    }
    _lastXDomain = xdom;

    if (_chart.isOrdinal()) {
      _x.rangeBands([0, _chart.xAxisLength()], _rangeBandPadding, _chart._useOuterPadding() ? _outerRangeBandPadding : 0);
    } else {
      _x.range([0, _chart.xAxisLength()]);
    }

    _chart.xAxis().ticks(_chart.getNumTicksForXAxis());

    renderVerticalGridLines(g);
    _chart.prepareLabelEdit("x");
    _chart.prepareLockAxis("x");
  }

  /* istanbul ignore next */
  _chart.renderXAxis = function (g) {
    var axisXG = g.selectAll("g.x");

    setXAxisFormat();

    if (axisXG.empty()) {
      axisXG = g.append("g").attr("class", "axis x").attr("transform", "translate(" + _chart.margins().left + "," + _chart._xAxisY() + ")");
    }

    /* OVERRIDE -----------------------------------------------------------------*/
    var root = _chart.root();

    if (_chart.rangeInput()) {
      var rangeDisplay = root.selectAll(".range-display");

      if (rangeDisplay.empty()) {
        rangeDisplay = root.append("div").attr("class", "range-display").style("right", _chart.margins().right + "px");

        var group1 = rangeDisplay.append("div");

        rangeDisplay.append("span").html(" &mdash; ");

        var group2 = rangeDisplay.append("div");

        group1.append("input").attr("class", "range-start-day range-day");

        group1.append("input").attr("class", "range-start-time range-time");

        group2.append("input").attr("class", "range-end-day range-day");

        group2.append("input").attr("class", "range-end-time range-time");

        rangeDisplay.selectAll("input").each(function () {
          bindRangeInputEvents(this);
        });

        if (_chart.group().binParams()[0] && _chart.group().binParams()[0].timeBin) {
          _chart.updateRangeInput();
        }

        _chart.root().select("div > .svg-wrapper").on("mouseover", function () {
          rangeDisplay.selectAll("input").classed("active", true);
        }).on("mouseleave", function () {
          rangeDisplay.selectAll("input").classed("active", false);
        });
      }
    }

    var xLabel = root.selectAll(".x-axis-label");

    var shouldAppendLabel = _chart.rangeChart() ? false : xLabel.empty();
    if (shouldAppendLabel) {
      xLabel = root.append("div").attr("class", "x-axis-label");
    }

    if (!_chart.rangeChart()) {
      xLabel.style("left", _chart.effectiveWidth() / 2 + _chart.margins().left + "px").text(_chart.xAxisLabel());
    }

    (0, _core.transition)(axisXG, _chart.transitionDuration()).attr("transform", "translate(" + _chart.margins().left + "," + _chart._xAxisY() + ")").call(_chart.xAxis());

    _chart.updateBinInput();
  };

  function renderVerticalGridLines(g) {
    var gridLineG = g.selectAll("g." + VERTICAL_CLASS);

    if (_renderVerticalGridLine) {
      if (gridLineG.empty()) {
        gridLineG = g.insert("g", ":first-child").attr("class", GRID_LINE_CLASS + " " + VERTICAL_CLASS).attr("transform", "translate(" + _chart.margins().left + "," + _chart.margins().top + ")");
      }

      var ticks = _xAxis.tickValues() ? _xAxis.tickValues() : typeof _x.ticks === "function" ? _x.ticks(_xAxis.ticks()[0]) : _x.domain();

      var lines = gridLineG.selectAll("line").data(ticks);

      var linesGEnter = lines.enter().append("line").attr("x1", function (d) {
        return _x(d);
      }).attr("y1", _chart._xAxisY() - _chart.margins().top).attr("x2", function (d) {
        return _x(d);
      }).attr("y2", 0).attr("opacity", 0);
      (0, _core.transition)(linesGEnter, _chart.transitionDuration()).attr("opacity", 1);

      (0, _core.transition)(lines, _chart.transitionDuration()).attr("x1", function (d) {
        return _x(d);
      }).attr("y1", _chart._xAxisY() - _chart.margins().top).attr("x2", function (d) {
        return _x(d);
      }).attr("y2", 0);

      lines.exit().remove();
    } else {
      gridLineG.selectAll("line").remove();
    }
  }

  _chart._xAxisY = function () {
    return _chart.height() - _chart.margins().bottom;
  };

  _chart.xAxisLength = function () {
    return _chart.effectiveWidth();
  };

  /**
      * Set or get the x axis label. If setting the label, you may optionally include additional padding to
      * the margin to make room for the label. By default the padded is set to 12 to accomodate the text height.
      * @name xAxisLabel
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {String} [labelText]
      * @param {Number} [padding=12]
      * @return {String}
      */
  _chart.xAxisLabel = function (labelText, padding) {
    if (!arguments.length) {
      return _xAxisLabel;
    }
    _xAxisLabel = labelText;
    _chart.margins().bottom -= _xAxisLabelPadding;
    _xAxisLabelPadding = padding === undefined ? DEFAULT_AXIS_LABEL_PADDING : padding;
    _chart.margins().bottom += _xAxisLabelPadding;
    return _chart;
  };

  _chart._prepareXAxis = prepareXAxis;

  _chart._prepareYAxis = function (g) {
    if (_y === undefined || _chart.elasticY()) {
      if (_y === undefined) {
        _y = _d2.default.scale.linear();
      }
      var min = _chart.yAxisMin() || 0,
          max = _chart.yAxisMax() || 0;
      _y.domain([min, max]).rangeRound([_chart.yAxisHeight(), 0]);
    }

    _y.range([_chart.yAxisHeight(), 0]);
    _yAxis = _yAxis.scale(_y);

    _yAxis.ticks(_chart.effectiveHeight() / _yAxis.scale().ticks().length < 16 ? Math.ceil(_chart.effectiveHeight() / 16) : 10);

    if (_useRightYAxis) {
      _yAxis.orient("right");
    }

    _chart._renderHorizontalGridLinesForAxis(g, _y, _yAxis);
    _chart.prepareLockAxis("y");
  };

  function setYTickFormat(tickFormat, options) {
    if (options.toCache && cachedYTickFormat === NO_CACHE) {
      cachedYTickFormat = _yAxis.tickFormat();
    }

    _yAxis.tickFormat(tickFormat);

    if (options.fromCache) {
      cachedYTickFormat = NO_CACHE;
    }
  }

  function setYAxisFormat() {
    var numberFormatter = _chart.valueFormatter();
    var formatExistsForThisKey = numberFormatter && numberFormatter(null, _chart.yAxisLabel());

    if (formatExistsForThisKey) {
      setYTickFormat(function (d) {
        return numberFormatter(d, _chart.yAxisLabel());
      }, { toCache: true });
    } else if (cachedYTickFormat !== NO_CACHE) {
      setYTickFormat(cachedYTickFormat, { fromCache: true });
    }
  }

  function setXTickFormat(tickFormat, options) {
    if (options.toCache && cachedXTickFormat === NO_CACHE) {
      cachedXTickFormat = _xAxis.tickFormat();
    }

    _xAxis.tickFormat(tickFormat);

    if (options.fromCache) {
      cachedXTickFormat = NO_CACHE;
    }
  }

  function setXAxisFormat() {
    var timeBinParam = _chart.group().binParams()[DEFAULT_TIME_DIMENSION_INDEX] || {};

    var domain = _chart.x().domain();

    var dateFormatter = _chart.dateFormatter();
    var numberFormatter = _chart.valueFormatter();
    var dateFormatExistsForThisKey = Boolean(dateFormatter && dateFormatter(new Date(), _chart.xAxisLabel()));
    var numberFormatExistsForThisKey = Boolean(numberFormatter && numberFormatter(null, _chart.xAxisLabel()));

    if (domain && domain[0] && domain[0] instanceof Date && !timeBinParam.extract && dateFormatExistsForThisKey) {
      setXTickFormat(function (d) {
        return dateFormatter(d, _chart.xAxisLabel());
      }, { toCache: true });
    } else if (!timeBinParam.extract && numberFormatExistsForThisKey) {
      setXTickFormat(function (d) {
        return numberFormatter(d, _chart.xAxisLabel());
      }, { toCache: true });
    } else if (cachedXTickFormat !== NO_CACHE) {
      setXTickFormat(cachedXTickFormat, { fromCache: true });
    }
  }

  _chart.renderYAxisAt = function (axisClass, axis, position) {
    var axisYG = _chart.g().selectAll("g." + axisClass);
    if (axisYG.empty()) {
      axisYG = _chart.g().append("g").attr("class", "axis " + axisClass).attr("transform", "translate(" + position + "," + _chart.margins().top + ")");
    }

    (0, _core.transition)(axisYG, _chart.transitionDuration()).attr("transform", "translate(" + position + "," + _chart.margins().top + ")").call(axis);
  };

  _chart.renderYAxis = function () {
    var axisPosition = _useRightYAxis ? _chart.width() - _chart.margins().right : _chart._yAxisX();
    setYAxisFormat();
    _chart.renderYAxisAt("y", _yAxis, axisPosition);
    var labelPosition = _useRightYAxis ? _chart.width() - _yAxisLabelPadding : _yAxisLabelPadding;
    var rotation = _useRightYAxis ? 90 : -90;
    _chart.renderYAxisLabel("y", _chart.yAxisLabel(), rotation, labelPosition);
  };

  _chart._renderHorizontalGridLinesForAxis = function (g, scale, axis) {
    var gridLineG = g.selectAll("g." + HORIZONTAL_CLASS);

    if (_renderHorizontalGridLine) {
      var ticks = axis.tickValues() ? axis.tickValues() : scale.ticks(axis.ticks()[0]);

      if (gridLineG.empty()) {
        gridLineG = g.insert("g", ":first-child").attr("class", GRID_LINE_CLASS + " " + HORIZONTAL_CLASS).attr("transform", "translate(" + _chart.margins().left + "," + _chart.margins().top + ")");
      }

      var lines = gridLineG.selectAll("line").data(ticks);

      var linesGEnter = lines.enter().append("line").attr("x1", 1).attr("y1", function (d) {
        return scale(d);
      }).attr("x2", _chart.xAxisLength()).attr("y2", function (d) {
        return scale(d);
      }).attr("opacity", 0);
      (0, _core.transition)(linesGEnter, _chart.transitionDuration()).attr("opacity", 1);

      (0, _core.transition)(lines, _chart.transitionDuration()).attr("x1", 1).attr("y1", function (d) {
        return scale(d);
      }).attr("x2", _chart.xAxisLength()).attr("y2", function (d) {
        return scale(d);
      });

      lines.exit().remove();
    } else {
      gridLineG.selectAll("line").remove();
    }
  };

  _chart._yAxisX = function () {
    return _chart.useRightYAxis() ? _chart.width() - _chart.margins().right : _chart.margins().left;
  };

  /**
      * Set or get the y axis label. If setting the label, you may optionally include additional padding
      * to the margin to make room for the label. By default the padded is set to 12 to accomodate the
      * text height.
      * @name yAxisLabel
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {String} [labelText]
      * @param {Number} [padding=12]
      * @return {String}
      * @return {dc.coordinateGridMixin}
      */
  _chart.yAxisLabel = function (labelText, padding) {
    if (!arguments.length) {
      return _yAxisLabel;
    }
    _yAxisLabel = labelText;
    _chart.margins().left -= _yAxisLabelPadding;
    _yAxisLabelPadding = padding === undefined ? DEFAULT_AXIS_LABEL_PADDING : padding;
    _chart.margins().left += _yAxisLabelPadding;
    return _chart;
  };

  /**
      * Get or set the y scale. The y scale is typically automatically determined by the chart implementation.
      * @name y
      * @memberof dc.coordinateGridMixin
      * @instance
      * @see {@link http://github.com/mbostock/d3/wiki/Scales d3.scale}
      * @param {d3.scale} [yScale]
      * @return {d3.scale}
      * @return {dc.coordinateGridMixin}
      */
  _chart.y = function (yScale) {
    if (!arguments.length) {
      return _y;
    }
    _y = yScale;
    _chart.rescale();
    return _chart;
  };

  /**
      * Set or get the y axis used by the coordinate grid chart instance. This function is most useful
      * when y axis customization is required. The y axis in dc.js is simply an instance of a [d3 axis
      * object](https://github.com/mbostock/d3/wiki/SVG-Axes#wiki-_axis); therefore it supports any
      * valid d3 axis manipulation. **Caution**: The y axis is usually generated internally by dc;
      * resetting it may cause unexpected results.
      * @name yAxis
      * @memberof dc.coordinateGridMixin
      * @instance
      * @see {@link http://github.com/mbostock/d3/wiki/SVG-Axes d3.svg.axis}
      * @example
      * // customize y axis tick format
      * chart.yAxis().tickFormat(function(v) {return v + '%';});
      * // customize y axis tick values
      * chart.yAxis().tickValues([0, 100, 200, 300]);
      * @param {d3.svg.axis} [yAxis=d3.svg.axis().orient('left')]
      * @return {d3.svg.axis}
      * @return {dc.coordinateGridMixin}
      */
  _chart.yAxis = function (yAxis) {
    if (!arguments.length) {
      return _yAxis;
    }
    _yAxis = yAxis;
    return _chart;
  };

  /**
      * Turn on/off elastic y axis behavior. If y axis elasticity is turned on, then the grid chart will
      * attempt to recalculate the y axis range whenever a redraw event is triggered.
      * @name elasticY
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {Boolean} [elasticY=false]
      * @return {Boolean}
      * @return {dc.coordinateGridMixin}
      */
  _chart.elasticY = function (elasticY) {
    if (!arguments.length) {
      return _yElasticity;
    }
    _yElasticity = elasticY;
    return _chart;
  };

  /**
      * Turn on/off horizontal grid lines.
      * @name renderHorizontalGridLines
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {Boolean} [renderHorizontalGridLines=false]
      * @return {Boolean}
      * @return {dc.coordinateGridMixin}
      */
  _chart.renderHorizontalGridLines = function (renderHorizontalGridLines) {
    if (!arguments.length) {
      return _renderHorizontalGridLine;
    }
    _renderHorizontalGridLine = renderHorizontalGridLines;
    return _chart;
  };

  /**
      * Turn on/off vertical grid lines.
      * @name renderVerticalGridLines
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {Boolean} [renderVerticalGridLines=false]
      * @return {Boolean}
      * @return {dc.coordinateGridMixin}
      */
  _chart.renderVerticalGridLines = function (renderVerticalGridLines) {
    if (!arguments.length) {
      return _renderVerticalGridLine;
    }
    _renderVerticalGridLine = renderVerticalGridLines;
    return _chart;
  };

  var chooseKeyAccessor = function chooseKeyAccessor(forceMax) {
    return function (dataPoint) {
      return _chart.isHeatMap ? _chart.keyAccessorNoFormat(forceMax)(dataPoint) : _chart.keyAccessor()(dataPoint);
    };
  };

  var chooseValueAccessor = function chooseValueAccessor(forceMax) {
    return function (dataPoint) {
      return _chart.isHeatMap ? _chart.valueAccessorNoFormat(forceMax)(dataPoint) : _chart.valueAccessor()(dataPoint);
    };
  };

  /**
      * Calculates the minimum x value to display in the chart. Includes xAxisPadding if set.
      * @name xAxisMin
      * @memberof dc.coordinateGridMixin
      * @instance
      * @return {*}
      */
  _chart.xAxisMin = function () {
    var min = _d2.default.min(_chart.data(), chooseKeyAccessor());
    var max = _d2.default.max(_chart.data(), chooseKeyAccessor(true));
    var result = _utils.utils.subtract(min, _xAxisPadding, max - min);
    return min instanceof Date ? new Date(result) : result;
  };

  /**
      * Calculates the maximum x value to display in the chart. Includes xAxisPadding if set.
      * @name xAxisMax
      * @memberof dc.coordinateGridMixin
      * @instance
      * @return {*}
      */
  _chart.xAxisMax = function () {
    var max = _d2.default.max(_chart.data(), chooseKeyAccessor(true));
    var min = _d2.default.min(_chart.data(), chooseKeyAccessor());
    var result = _utils.utils.add(max, _xAxisPadding, max - min);
    return max instanceof Date ? new Date(result) : result;
  };

  /**
      * Calculates the minimum y value to display in the chart. Includes yAxisPadding if set.
      * @name yAxisMin
      * @memberof dc.coordinateGridMixin
      * @instance
      * @return {*}
      */
  _chart.yAxisMin = function () {
    var min = _d2.default.min(_chart.data(), chooseValueAccessor());
    var max = _d2.default.max(_chart.data(), chooseValueAccessor(true));
    var result = _utils.utils.subtract(min, _yAxisPadding, max - min);
    return min instanceof Date ? new Date(result) : result;
  };

  /**
      * Calculates the maximum y value to display in the chart. Includes yAxisPadding if set.
      * @name yAxisMax
      * @memberof dc.coordinateGridMixin
      * @instance
      * @return {*}
      */
  _chart.yAxisMax = function () {
    var max = _d2.default.max(_chart.data(), chooseValueAccessor(true));
    var min = _d2.default.min(_chart.data(), chooseValueAccessor());
    var result = _utils.utils.add(max, _yAxisPadding, max - min);
    return max instanceof Date ? new Date(result) : result;
  };

  /**
      * Set or get y axis padding for the elastic y axis. The padding will be added to the top of the y
      * axis if elasticY is turned on; otherwise it is ignored.
      *
      * padding can be an integer or percentage in string (e.g. '10%'). Padding can be applied to
      * number or date axes. When padding a date axis, an integer represents number of days being padded
      * and a percentage string will be treated the same as an integer.
      * @name yAxisPadding
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {Number|String} [padding=0]
      * @return {Number}
      * @return {dc.coordinateGridMixin}
      */
  _chart.yAxisPadding = function (padding) {
    if (!arguments.length) {
      return _yAxisPadding;
    }
    _yAxisPadding = padding;
    return _chart;
  };

  _chart.yAxisHeight = function () {
    var height = _chart.effectiveHeight();
    return height < 0 ? 0 : height;
  };

  /**
      * Set or get the rounding function used to quantize the selection when brushing is enabled.
      * @name round
      * @memberof dc.coordinateGridMixin
      * @instance
      * @example
      * // set x unit round to by month, this will make sure range selection brush will
      * // select whole months
      * chart.round(d3.time.month.round);
      * @param {Function} [round]
      * @return {Function}
      * @return {dc.coordinateGridMixin}
      */
  _chart.round = function (round) {
    if (!arguments.length) {
      return _round;
    }
    _round = round;
    return _chart;
  };

  _chart._rangeBandPadding = function (_) {
    if (!arguments.length) {
      return _rangeBandPadding;
    }
    _rangeBandPadding = _;
    return _chart;
  };

  _chart._outerRangeBandPadding = function (_) {
    if (!arguments.length) {
      return _outerRangeBandPadding;
    }
    _outerRangeBandPadding = _;
    return _chart;
  };

  function updateBinParamsForChart(_chart, filter) {
    var extract = _chart.binParams()[0] ? _chart.binParams()[0].extract : false;
    if (_chart.focusChart() && filter.length && !extract) {
      var FocusChart = _chart.focusChart();
      var currentBinParams = FocusChart.binParams();
      if (currentBinParams[0]) {
        currentBinParams[0].binBounds = filter;
        FocusChart.binParams(currentBinParams);
      }
      _chart.brush().extent(filter);
    }
  }

  function resetBinParamsForChart(_chart) {
    if (_chart.binParams()[0]) {
      var extract = _chart.binParams()[0].extract;
      var isRangeAndIsNotFiltered = _chart.focusChart() && !_chart.filters().length && !extract;

      if (isRangeAndIsNotFiltered) {
        var chartBinParams = _chart.focusChart().binParams().map(function (p) {
          return p;
        });
        chartBinParams[0].binBounds = _chart.binParams()[0].binBounds;
        _chart.focusChart().binParams(chartBinParams);
        _chart.focusChart().x().domain(_chart.x().domain().slice(0));
      }
    }
  }

  (0, _core.override)(_chart, "filter", function (filter, isInverseFilter) {
    if (!arguments.length) {
      return _chart._filter();
    }
    _chart._filter(filter, isInverseFilter);
    if (filter.length) {
      updateBinParamsForChart(_chart, filter);
      _chart.brush().extent(filter);
    } else {
      resetBinParamsForChart(_chart);
      _chart.brush().clear();
    }

    if (_chart.rangeInput()) {
      _chart.updateRangeInput();
    }
    return _chart;
  });

  _chart.brush = function (_) {
    if (!arguments.length) {
      return _brush;
    }
    _brush = _;
    return _chart;
  };

  _chart.isBrushing = function (_) {
    if (!arguments.length) {
      return _isBrushing;
    }
    _isBrushing = _;
    return _chart;
  };

  function brushHeight() {
    var height = _chart._xAxisY() - _chart.margins().top;
    return height < 0 ? 0 : height;
  }

  _chart.renderBrush = function (g) {
    if (_brushOn) {
      var gBrush = g.select("g.brush").empty() ? g.append("g") : g.select("g.brush");

      gBrush.attr("class", "brush").attr("transform", "translate(" + _chart.margins().left + "," + _chart.margins().top + ")").call(_brush.x(_chart.x()).clamp(false));

      gBrush.select("rect.extent").attr("clip-path", "url(#" + getClipPathId() + ")");

      _chart.setBrushY(gBrush, false);
      _chart.setHandlePaths(gBrush);

      _brush.on("brush", _chart._brushing);
      _brush.on("brushstart", function () {
        _isBrushing = true;
        _chart._disableMouseZoom();
        (0, _core.disableTransitions)(true);
      });
      _brush.on("brushend", function () {
        _isBrushing = false;
        configureMouseZoom();
        (0, _core.disableTransitions)(false);
      });

      if (_chart.hasFilter()) {
        _chart.redrawBrush(g, false);
      }
    }
  };

  _chart.brushSnap = function () {
    if (!_d2.default.event.sourceEvent) {
      return;
    } // only transition after input
    _chart.binBrush();
  };

  _chart.triggerReplaceFilter = function (shouldSetSizingFalse) {
    _resizing = false;
  };

  _chart.setHandlePaths = function (gBrush) {
    gBrush.selectAll(".resize").append("path").attr("d", _chart.resizeHandlePath);
  };

  _chart.setBrushY = function (gBrush) {
    gBrush.selectAll(".brush rect").attr("height", brushHeight());
    gBrush.selectAll(".resize path").attr("d", _chart.resizeHandlePath);
  };

  _chart.extendBrush = function () {
    var extent = _brush.extent();
    if (_chart.round()) {
      extent[0] = extent.map(_chart.round())[0];
      extent[1] = extent.map(_chart.round())[1];

      _g.select(".brush").call(_brush.extent(extent));
    }
    return extent;
  };

  _chart.brushIsEmpty = function (extent) {
    return _brush.empty() || !extent || extent[1] <= extent[0];
  };

  _chart._clampBrush = function () {
    if (!_d2.default.event.mode) {
      return;
    }

    // We need to "bin" the domain because that affects the actual brushable
    // min/max.
    var domain = _chart._binBrushExtent(_brush.x().domain());
    var extent = _brush.extent();
    if (extent[0] < domain[0] || extent[1] > domain[1]) {
      if (_d2.default.event.mode === "move") {
        var offset = extent[0] < domain[0] ? domain[0] - extent[0] : domain[1] - extent[1];
        if (extent[0].getTime) {
          extent = extent.map(function (e) {
            return new Date(e.getTime() + offset);
          });
        } else {
          extent = extent.map(function (e) {
            return e + offset;
          });
        }
      } else if (extent[0].getTime) {
        extent = extent.map(function (e) {
          return new Date(Math.max(domain[0], Math.min(domain[1], e.getTime())));
        });
      } else {
        extent = extent.map(function (e) {
          return Math.max(domain[0], Math.min(domain[1], e));
        });
      }
      _g.select(".brush").call(_brush.extent(extent));
    }
  };

  _chart._brushing = function () {
    _chart._clampBrush();
    _chart.brushSnap();
    var extent = _chart.extendBrush();

    _chart.redrawBrush(_g, false);

    if (_chart.brushIsEmpty(extent)) {
      _events.events.trigger(function () {
        if (_chart.focusChart()) {
          _chart.focusChart().filterAll();
        }
        _chart.filterAll();
        _chart.redrawGroup();
      }, _core.constants.EVENT_DELAY);
    } else {
      var rangedFilter = _filters.filters.RangedFilter(extent[0], extent[1]);

      _events.events.trigger(function () {
        /* OVERRIDE ---------------------------------------------------------------- */
        (0, _core.globalTransitionDuration)(10);
        /* ------------------------------------------------------------------------- */
        _chart.replaceFilter(rangedFilter);
        _chart.redrawGroup();
      }, _core.constants.EVENT_DELAY);
    }

    if (_chart.rangeInput()) {
      _chart.updateRangeInput();
    } else if (_chart.focusChart() && _chart.focusChart().rangeInput()) {
      _chart.focusChart().updateRangeInput();
    }
  };

  _chart.redrawBrush = function (g, doTransition) {
    if (_brushOn) {
      /* OVERRIDE ---------------------------------------------------------------- */
      if (_chart.filter() && (_chart.brush().empty() || _chart._redrawBrushFlag)) {
        _chart._redrawBrushFlag = false;
        /* ------------------------------------------------------------------------- */

        _chart.brush().extent(_chart.filter());
      }

      var gBrush = (0, _core.optionalTransition)(doTransition, _chart.transitionDuration())(g.select("g.brush"));
      _chart.setBrushY(gBrush);
      gBrush.call(_chart.brush().x(_chart.x()).extent(_chart.brush().extent()));
    }

    _chart.fadeDeselectedArea();
  };

  _chart.fadeDeselectedArea = function () {}
  // do nothing, sub-chart should override this function


  // borrowed from Crossfilter example
  ;_chart.resizeHandlePath = function (d) {
    var e = Number(d === "e"),
        x = e ? 1 : -1,
        y = brushHeight() / 3;
    return "M" + 0.5 * x + "," + y + "A6,6 0 0 " + e + " " + 6.5 * x + "," + (y + 6) + "V" + (2 * y - 6) + "A6,6 0 0 " + e + " " + 0.5 * x + "," + 2 * y + "Z" + "M" + 2.5 * x + "," + (y + 8) + "V" + (2 * y - 8) + "M" + 4.5 * x + "," + (y + 8) + "V" + (2 * y - 8);
  };

  function getClipPathId() {
    return _chart.anchorName().replace(/[ .#=\[\]]/g, "-") + "-clip";
  }

  /**
      * Get or set the padding in pixels for the clip path. Once set padding will be applied evenly to
      * the top, left, right, and bottom when the clip path is generated. If set to zero, the clip area
      * will be exactly the chart body area minus the margins.
      * @name clipPadding
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {Number} [padding=5]
      * @return {Number}
      * @return {dc.coordinateGridMixin}
      */
  _chart.clipPadding = function (padding) {
    if (!arguments.length) {
      return _clipPadding;
    }
    _clipPadding = padding;
    return _chart;
  };

  function generateClipPath() {
    var defs = _utils.utils.appendOrSelect(_parent, "defs");
    // cannot select <clippath> elements; bug in WebKit, must select by id
    // https://groups.google.com/forum/#!topic/d3-js/6EpAzQ2gU9I
    var id = getClipPathId();
    var chartBodyClip = _utils.utils.appendOrSelect(defs, "#" + id, "clipPath").attr("id", id);

    var padding = _clipPadding * 2;

    _utils.utils.appendOrSelect(chartBodyClip, "rect").attr("width", _chart.xAxisLength() + padding).attr("height", _chart.yAxisHeight() + padding).attr("transform", "translate(-" + _clipPadding + ", -" + _clipPadding + ")");
  }

  _chart._preprocessData = function (data) {};

  _chart._doRender = function () {
    _chart._redrawBrushFlag = true;

    _chart.resetSvg();

    _chart._preprocessData();

    _chart._generateG();

    _chart.root().classed("coordinate-chart", true);

    generateClipPath();

    drawChart(true);

    configureMouseZoom();

    /* OVERRIDE ---------------------------------------------------------------- */
    _hasBeenRendered = true;
    /* ------------------------------------------------------------------------- */
    return _chart;
  };

  _chart._doRedraw = function () {
    /* OVERRIDE ---------------------------------------------------------------- */
    if (!_hasBeenRendered) {
      // guard to prevent a redraw before a render
      return _chart._doRender();
    }
    /* ------------------------------------------------------------------------- */
    _chart._preprocessData();

    drawChart(false);
    generateClipPath();

    return _chart;
  };

  function drawChart(render) {
    if (_chart.isOrdinal()) {
      _brushOn = false;
    }

    prepareXAxis(_chart.g(), render);
    _chart._prepareYAxis(_chart.g());

    _chart.plotData();

    if (_chart.elasticX() || _resizing || render) {
      _chart.renderXAxis(_chart.g());
    }

    if (_chart.elasticY() || _resizing || render) {
      _chart.renderYAxis(_chart.g());
    }

    if (render) {
      _chart.renderBrush(_chart.g(), false);
    } else {
      _chart.redrawBrush(_chart.g(), _resizing);
    }
    _chart.fadeDeselectedArea();
    _resizing = false;
  }

  function configureMouseZoom() {
    if (_mouseZoomable) {
      _chart._enableMouseZoom();
    } else if (_hasBeenMouseZoomable) {
      _chart._disableMouseZoom();
    }
  }

  _chart._enableMouseZoom = function () {
    _hasBeenMouseZoomable = true;
    _zoom.x(_chart.x()).scaleExtent(_zoomScale).size([_chart.width(), _chart.height()]).duration(_chart.transitionDuration());
    _chart.root().call(_zoom);
  };

  _chart._disableMouseZoom = function () {
    _chart.root().call(_nullZoom);
  };

  function constrainRange(range, constraint) {
    var constrainedRange = [];
    constrainedRange[0] = _d2.default.max([range[0], constraint[0]]);
    constrainedRange[1] = _d2.default.min([range[1], constraint[1]]);
    return constrainedRange;
  }

  /**
      * Zoom this chart to focus on the given range. The given range should be an array containing only
      * 2 elements (`[start, end]`) defining a range in the x domain. If the range is not given or set
      * to null, then the zoom will be reset. _For focus to work elasticX has to be turned off;
      * otherwise focus will be ignored.
      * @name focus
      * @memberof dc.coordinateGridMixin
      * @instance
      * @example
      * chart.on('renderlet', function(chart) {
      *     // smooth the rendering through event throttling
      *     events.trigger(function(){
      *          // focus some other chart to the range selected by user on this chart
      *          someOtherChart.focus(chart.filter());
      *     });
      * })
      * @param {Array<Number>} [range]
      */
  _chart.focus = function (range) {
    if (hasRangeSelected(range)) {
      _chart.x().domain(range);
    } else {
      _chart.x().domain(_xOriginalDomain);
    }

    _zoom.x(_chart.x());

    zoomHandler();
  };

  _chart.refocused = function () {
    return _refocused;
  };

  _chart.focusChart = function (c) {
    if (!arguments.length) {
      return _focusChart;
    }
    _focusChart = c;
    _chart.on("filtered", function (chart) {
      /* OVERRIDE ---------------------------------------------------------------- */
      _focusChart.rangeFocused(true);
      /* ------------------------------------------------------------------------- */

      if (!chart.filter()) {
        _events.events.trigger(function () {
          _focusChart.x().domain(_focusChart.xOriginalDomain());
        });
      } else if (!rangesEqual(chart.filter(), _focusChart.filter())) {
        _events.events.trigger(function () {
          _focusChart.focus(chart.filter());
        });
      }

      /* OVERRIDE ---------------------------------------------------------------- */
      _focusChart.rangeFocused(false);
      /* ------------------------------------------------------------------------- */
    });
    return _chart;
  };

  function rangesEqual(range1, range2) {
    if (!range1 && !range2) {
      return true;
    } else if (!range1 || !range2) {
      return false;
    } else if (range1.length === 0 && range2.length === 0) {
      return true;
    } else if (range1[0].valueOf() === range2[0].valueOf() && range1[1].valueOf() === range2[1].valueOf()) {
      return true;
    }
    return false;
  }

  /**
      * Turn on/off the brush-based range filter. When brushing is on then user can drag the mouse
      * across a chart with a quantitative scale to perform range filtering based on the extent of the
      * brush, or click on the bars of an ordinal bar chart or slices of a pie chart to filter and
      * un-filter them. However turning on the brush filter will disable other interactive elements on
      * the chart such as highlighting, tool tips, and reference lines. Zooming will still be possible
      * if enabled, but only via scrolling (panning will be disabled.)
      * @name brushOn
      * @memberof dc.coordinateGridMixin
      * @instance
      * @param {Boolean} [brushOn=true]
      * @return {Boolean}
      * @return {dc.coordinateGridMixin}
      */
  _chart.brushOn = function (brushOn) {
    if (!arguments.length) {
      return _brushOn;
    }
    _brushOn = brushOn;
    return _chart;
  };

  function hasRangeSelected(range) {
    return range instanceof Array && range.length > 1;
  }

  _chart.popupTextAccessor = function (arr) {
    return function () {
      var dateFormatter = _chart.dateFormatter();
      var customFormatter = null;
      var value = arr[0].datum.data.key0;
      if (Array.isArray(value) && value[0]) {
        value = typeof value[0].value !== "undefined" ? value[0].value : value[0];
      }

      if (dateFormatter && value instanceof Date) {
        customFormatter = dateFormatter;
      }

      return customFormatter && customFormatter(value) || _utils.utils.formatValue(value);
    };
  };

  _chart.getNumTicksForXAxis = function () {
    var xDomain = _chart.x().domain();
    var timeBinParam = _chart.group().binParams()[DEFAULT_TIME_DIMENSION_INDEX];
    var effectiveWidth = _chart.effectiveWidth();

    if (timeBinParam && timeBinParam.extract) {
      var numTicks = xDomain[xDomain.length - 1] - xDomain[0];
      return effectiveWidth / numTicks < MAX_TICK_WIDTH ? Math.ceil(effectiveWidth / MAX_TICK_WIDTH) : numTicks;
    } else {
      var _numTicks = _chart.xAxis().scale().ticks().length;
      return effectiveWidth / _numTicks < MAX_TICK_WIDTH ? Math.ceil(effectiveWidth / MAX_TICK_WIDTH) : DEFAULT_NUM_TICKS;
    }
  };

  _chart.rangeFocused = function (_) {
    if (!arguments.length) {
      return _chart._rangeFocused;
    }
    _chart._rangeFocused = _;

    return _chart;
  };

  _chart.rangeInput = function (_) {
    if (!arguments.length) {
      return _chart._rangeInput;
    }
    _chart._rangeInput = _;

    return _chart;
  };

  _chart.binInput = function (_) {
    if (!arguments.length) {
      return _chart._binInput;
    }
    _chart._binInput = _;

    return _chart;
  };

  /* istanbul ignore next */
  _chart.updateRangeInput = function () {
    var dateFormat = _d2.default.time.format.utc("%b %d, %Y");
    var timeFormat = _d2.default.time.format.utc("%I:%M%p");

    var extent = _chart.filter() || _chart.x().domain();
    var rangeDisplay = _chart.root().selectAll(".range-display");
    var binNumSecs = _chart.binInputOptions().filter(function (d) {
      return _chart.group().binParams()[0].timeBin === d.val;
    })[0].numSeconds;

    rangeDisplay.select(".range-start-day").property("value", dateFormat(extent[0])).attr("value", dateFormat(extent[0]));

    rangeDisplay.select(".range-start-time").classed("disable", binNumSecs > 3600).property("value", timeFormat(extent[0])).attr("value", timeFormat(extent[0]));

    rangeDisplay.select(".range-end-day").property("value", dateFormat(extent[1])).attr("value", dateFormat(extent[1]));

    rangeDisplay.select(".range-end-time").classed("disable", binNumSecs > 3600).property("value", timeFormat(extent[1])).attr("value", timeFormat(extent[1]));
  };

  /* istanbul ignore next */
  function rangeInputOnFocus() {
    this.select();

    var dateInputFormat = _d2.default.time.format.utc("%m-%d-%Y");
    var timeInputFormat = _d2.default.time.format.utc("%I:%M%p");
    var currentInput = _d2.default.select(this);

    var extent = _chart.filter() || _chart.x().domain();
    var index = currentInput.attr("class").indexOf("start") >= 0 ? 0 : 1;

    currentInput.property("value", currentInput.classed("range-day") ? dateInputFormat(extent[index]) : timeInputFormat(extent[index]));
  }

  /* istanbul ignore next */
  function rangeInputChange(input) {
    var thisInput = this || input;
    var currentInput = _d2.default.select(thisInput);
    var currentValue = currentInput.attr("value");
    var newValue = currentInput.property("value");

    var currentExtent = _chart.filter() || _chart.x().domain();

    var binNumSecs = _chart.binInputOptions().filter(function (d) {
      return _chart.group().binParams()[0].timeBin === d.val;
    })[0].numSeconds;

    var inputFormat = binNumSecs > 3600 ? _d2.default.time.format.utc("%m-%d-%Y") : currentInput.attr("class").indexOf("day") >= 0 ? _d2.default.time.format.utc("%m-%d-%Y %I:%M%p") : _d2.default.time.format.utc("%b %d, %Y %I:%M%p");

    var inputStr = binNumSecs > 3600 ? newValue : _d2.default.select(thisInput.parentNode).selectAll(".range-day").property("value") + " " + _d2.default.select(thisInput.parentNode).selectAll(".range-time").property("value");

    var date = inputFormat.parse(inputStr);

    if (!date) {
      currentInput.property("value", currentValue);
      thisInput.blur();
      return;
    }

    var extentChart = _chart.rangeChart() ? _chart.rangeChart() : _chart;

    var extent = extentChart.filter() || extentChart.x().domain();

    var index = currentInput.attr("class").indexOf("start") >= 0 ? 0 : 1;

    var other = index === 0 ? 1 : 0;

    extent[index] = date < extentChart.xAxisMin() ? extentChart.xAxisMin() : date > extentChart.xAxisMax() ? extentChart.xAxisMax() : date;

    if (binNumSecs > 3600) {
      extent[other] = _d2.default.time.day.utc.round(extent[other]);
    }

    extent.sort(function (a, b) {
      return a - b;
    });

    if (extent[0].getTime() === extent[1].getTime()) {
      extent[1] = new Date(extent[1].getTime() + binNumSecs * ONE_SECOND_IN_MS);
    }

    if (_chart._binInput) {
      extent[1] = new Date(extent[1].getTime());
    }

    var domFilter = _filters.filters.RangedFilter(extent[0], extent[1]);

    extentChart.replaceFilter(domFilter);
    extentChart.rescale();
    extentChart.redrawAsync().then(function () {
      if (_chart.rangeChart()) {
        _chart._binSnap = _chart._binInput;
        _chart.focus(domFilter);
        _chart.replaceFilter(domFilter);
      }

      thisInput.blur();
      _chart.updateRangeInput();

      _chart.redrawGroup();
    });
  }

  /* istanbul ignore next */
  _chart.renderYAxisLabel = function (axisClass, text, rotation) {
    var root = _chart.root();

    var yLabel = root.selectAll(".y-axis-label");

    if (yLabel.empty()) {
      yLabel = root.append("div").attr("class", "y-axis-label");
    }

    if (text !== "") {
      var yOffset = _chart.rangeChart() ? _chart.rangeChart().height() - _chart.rangeChart().margins().bottom + _chart.margins().bottom : _chart.margins().bottom;

      yLabel.style("top", (_chart.effectiveHeight() + yOffset) / 2 + _chart.margins().top + "px").text(text);
    }
    _chart.prepareLabelEdit("y");
  };

  /* istanbul ignore next */
  _chart.updateBinInput = function () {
    if (_chart.binInput() && _chart.group().binParams()[0]) {
      var root = _chart.root();

      var binRow = root.selectAll(".bin-row");

      if (binRow.empty()) {
        binRow = root.append("div").attr("class", "bin-row").style("left", _chart.margins().left + "px");
      }

      binRow.html("").append("span").text("BIN:");

      var binRowItems = binRow.selectAll(".bin-row-item").data(_chart.binInputOptions()).enter();

      var rangeInSeconds = Math.abs((_chart.x().domain()[0].getTime() - _chart.x().domain()[1].getTime()) / ONE_SECOND_IN_MS);

      var _chart$group$binParam = _chart.group().binParams()[0],
          auto = _chart$group$binParam.auto,
          timeBin = _chart$group$binParam.timeBin,
          numBins = _chart$group$binParam.numBins;

      var shouldShowTimeBinOption = function shouldShowTimeBinOption(d) {
        return d.numSeconds && rangeInSeconds / d.numSeconds > numBins || d.numSeconds && rangeInSeconds / d.numSeconds < 2;
      };

      binRowItems.append("div").attr("class", "bin-row-item").classed("inactive", function (d) {
        return shouldShowTimeBinOption(d);
      }).classed("active", function (d) {
        if (d.val === "auto" && auto) {
          return true;
        } else if (!auto) {
          return d.val === timeBin;
        }
      }).classed("underline", function (d) {
        return auto && d.val === timeBin;
      }).text(function (d) {
        return d.label;
      }).on("click", function (d) {
        return _chart.changeBinVal(d.val);
      });
    }
  };

  /* istanbul ignore next */
  function bindRangeInputEvents(input) {
    _d2.default.select(input).on("focus", rangeInputOnFocus).on("keydown", function () {
      if (_d2.default.event.keyCode === ENTER_KEY) {
        rangeInputChange(this);
      }
    });
  }

  _chart = (0, _binningMixin2.default)(_chart);

  return _chart;
}

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var events = exports.events = {
  current: null

  /**
   * This function triggers a throttled event function with a specified delay (in milli-seconds).  Events
   * that are triggered repetitively due to user interaction such brush dragging might flood the library
   * and invoke more renders than can be executed in time. Using this function to wrap your event
   * function allows the library to smooth out the rendering by throttling events and only responding to
   * the most recent event.
   * @name events.trigger
   * @memberof dc
   * @example
   * chart.on('renderlet', function(chart) {
   *     // smooth the rendering through event throttling
   *     dc.events.trigger(function(){
   *         // focus some other chart to the range selected by user on this chart
   *         someOtherChart.focus(chart.filter());
   *     });
   * })
   * @param {Function} closure
   * @param {Number} [delay]
   */
};events.trigger = function (closure, delay) {
  if (!delay) {
    closure();
    return;
  }

  events.current = closure;

  setTimeout(function () {
    if (closure === events.current) {
      closure();
    }
  }, delay);
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = capMixin;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _core = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Cap is a mixin that groups small data elements below a _cap_ into an *others* grouping for both the
 * Row and Pie Charts.
 *
 * The top ordered elements in the group up to the cap amount will be kept in the chart, and the rest
 * will be replaced with an *others* element, with value equal to the sum of the replaced values. The
 * keys of the elements below the cap limit are recorded in order to filter by those keys when the
 * others* element is clicked.
 * @name capMixin
 * @memberof dc
 * @mixin
 * @param {Object} _chart
 * @return {dc.capMixin}
 */
function capMixin(_chart) {
  var _cap = void 0;
  var _ordering = "desc";

  var _othersLabel = "Others";

  var _othersGrouper = function _othersGrouper(topRows) {
    var topRowsSum = _d2.default.sum(topRows, _chart.valueAccessor()),
        allRows = _chart.group().all(),
        allRowsSum = _d2.default.sum(allRows, _chart.valueAccessor()),
        topKeys = topRows.map(_chart.keyAccessor()),
        allKeys = allRows.map(_chart.keyAccessor()),
        topSet = _d2.default.set(topKeys),
        others = allKeys.filter(function (d) {
      return !topSet.has(d);
    });
    if (allRowsSum > topRowsSum) {
      return topRows.concat([{ others: others, key: _othersLabel, value: allRowsSum - topRowsSum }]);
    }
    return topRows;
  };

  _chart._mandatoryAttributes().push("cap");

  _chart.cappedKeyAccessor = function (d, i) {
    if (d.others) {
      /* OVERRIDE ---------------------------------------------------------------- */
      return d.key;
      /* ------------------------------------------------------------------------- */
    }
    return _chart.keyAccessor()(d, i);
  };

  _chart.cappedValueAccessor = function (d, i) {
    if (d.others) {
      return d.value;
    }
    return _chart.valueAccessor()(d, i);
  };

  _chart.cappedLabel = function (d) {
    if (d.others) {
      return _chart.othersLabel();
    }
    return _chart.label()(d);
  };

  /* OVERRIDE EXTEND --------------------------------------------------------- */
  _chart.ordering = function (order) {
    _chart.expireCache();
    if (!order) {
      return _ordering;
    }
    _ordering = order;
    return _chart;
  };

  _chart.setDataAsync(function (group, callback) {
    function resultCallback(error, result) {
      if (error) {
        callback(error);
        return;
      }
      var rows = _chart._computeOrderedGroups(result);
      if (_othersGrouper) {
        callback(null, _othersGrouper(rows));
      } else {
        callback(null, rows);
      }
    }

    if (_cap === undefined) {
      if (_chart.dataCache != null) {
        callback(null, _chart._computeOrderedGroups(_chart.dataCache));
      } else {
        group.allAsync(function (error, result) {
          if (error) {
            callback(error);
            return;
          }
          callback(null, _chart._computeOrderedGroups(result));
        });
      }
    } else if (_chart.dataCache != null) {
      resultCallback(null, _chart.dataCache);
    } else if (_ordering === "desc") {
      return group.topAsync(_cap).then(function (result) {
        resultCallback(null, result);
      }).catch(function (error) {
        resultCallback(error);
      });
    } else if (_ordering === "asc") {
      group.bottomAsync(_cap, undefined, undefined, resultCallback); // ordered by crossfilter group order (default value)
    }
  });

  _chart.expireCache = function () {
    _chart.dataCache = null;
  };

  _chart.data(function (group) {
    if (!_chart.dataCache) {
      console.warn("Empty dataCache. Please fetch new data");
    }
    if (_cap === undefined) {
      return _chart._computeOrderedGroups(_chart.dataCache);
    } else {
      var rows = _chart.dataCache;
      if (_othersGrouper) {
        return _othersGrouper(rows);
      }
      return rows;
    }
  });

  /* ------------------------------------------------------------------------- */

  /**
   * Get or set the count of elements to that will be included in the cap.
   * @name cap
   * @memberof dc.capMixin
   * @instance
   * @param {Number} [count=Infinity]
   * @return {Number}
   * @return {dc.capMixin}
   */
  _chart.cap = function (count) {
    if (!arguments.length) {
      return _cap;
    }
    _cap = count;
    _chart.expireCache();
    return _chart;
  };

  /**
   * Get or set the label for *Others* slice when slices cap is specified
   * @name othersLabel
   * @memberof dc.capMixin
   * @instance
   * @param {String} [label="Others"]
   * @return {String}
   * @return {dc.capMixin}
   */
  _chart.othersLabel = function (label) {
    if (!arguments.length) {
      return _othersLabel;
    }
    _othersLabel = label;
    return _chart;
  };

  /**
   * Get or set the grouper function that will perform the insertion of data for the *Others* slice
   * if the slices cap is specified. If set to a falsy value, no others will be added. By default the
   * grouper function computes the sum of all values below the cap.
   * @name othersGrouper
   * @memberof dc.capMixin
   * @instance
   * @example
   * // Default others grouper
   * chart.othersGrouper(function (topRows) {
   *    var topRowsSum = d3.sum(topRows, _chart.valueAccessor()),
   *        allRows = _chart.group().all(),
   *        allRowsSum = d3.sum(allRows, _chart.valueAccessor()),
   *        topKeys = topRows.map(_chart.keyAccessor()),
   *        allKeys = allRows.map(_chart.keyAccessor()),
   *        topSet = d3.set(topKeys),
   *        others = allKeys.filter(function (d) {return !topSet.has(d);});
   *    if (allRowsSum > topRowsSum) {
   *        return topRows.concat([{'others': others, 'key': _othersLabel, 'value': allRowsSum - topRowsSum}]);
   *    }
   *    return topRows;
   * });
   * // Custom others grouper
   * chart.othersGrouper(function (data) {
   *     // compute the value for others, presumably the sum of all values below the cap
   *     var othersSum  = yourComputeOthersValueLogic(data)
   *
   *     // the keys are needed to properly filter when the others element is clicked
   *     var othersKeys = yourComputeOthersKeysArrayLogic(data);
   *
   *     // add the others row to the dataset
   *     data.push({'key': 'Others', 'value': othersSum, 'others': othersKeys });
   *
   *     return data;
   * });
   * @param {Function} [grouperFunction]
   * @return {Function}
   * @return {dc.capMixin}
   */
  _chart.othersGrouper = function (grouperFunction) {
    if (!arguments.length) {
      return _othersGrouper;
    }
    _othersGrouper = grouperFunction;
    return _chart;
  };

  (0, _core.override)(_chart, "onClick", function (d) {
    if (d.others) {
      _chart.filter([d.others]);
    }
    if (_chart._onClick) {
      _chart._onClick(d);
    }
  });

  return _chart;
}

/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["e"] = tokenLabel;
/* harmony export (immutable) */ __webpack_exports__["g"] = tokenName;
/* harmony export (immutable) */ __webpack_exports__["d"] = hasTokenLabel;
/* harmony export (immutable) */ __webpack_exports__["b"] = createToken;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EOF; });
/* harmony export (immutable) */ __webpack_exports__["c"] = createTokenInstance;
/* harmony export (immutable) */ __webpack_exports__["f"] = tokenMatcher;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lexer_public__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__tokens__ = __webpack_require__(25);



function tokenLabel(tokType) {
    if (hasTokenLabel(tokType)) {
        return tokType.LABEL;
    }
    else {
        return tokType.name;
    }
}
function tokenName(tokType) {
    return tokType.name;
}
function hasTokenLabel(obj) {
    return Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["E" /* isString */])(obj.LABEL) && obj.LABEL !== "";
}
var PARENT = "parent";
var CATEGORIES = "categories";
var LABEL = "label";
var GROUP = "group";
var PUSH_MODE = "push_mode";
var POP_MODE = "pop_mode";
var LONGER_ALT = "longer_alt";
var LINE_BREAKS = "line_breaks";
var START_CHARS_HINT = "start_chars_hint";
function createToken(config) {
    return createTokenInternal(config);
}
function createTokenInternal(config) {
    var pattern = config.pattern;
    var tokenType = {};
    tokenType.name = config.name;
    if (!Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["F" /* isUndefined */])(pattern)) {
        tokenType.PATTERN = pattern;
    }
    if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(config, PARENT)) {
        throw "The parent property is no longer supported.\n" +
            "See: https://github.com/SAP/chevrotain/issues/564#issuecomment-349062346 for details.";
    }
    if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(config, CATEGORIES)) {
        // casting to ANY as this will be fixed inside `augmentTokenTypes``
        tokenType.CATEGORIES = config[CATEGORIES];
    }
    Object(__WEBPACK_IMPORTED_MODULE_2__tokens__["a" /* augmentTokenTypes */])([tokenType]);
    if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(config, LABEL)) {
        tokenType.LABEL = config[LABEL];
    }
    if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(config, GROUP)) {
        tokenType.GROUP = config[GROUP];
    }
    if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(config, POP_MODE)) {
        tokenType.POP_MODE = config[POP_MODE];
    }
    if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(config, PUSH_MODE)) {
        tokenType.PUSH_MODE = config[PUSH_MODE];
    }
    if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(config, LONGER_ALT)) {
        tokenType.LONGER_ALT = config[LONGER_ALT];
    }
    if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(config, LINE_BREAKS)) {
        tokenType.LINE_BREAKS = config[LINE_BREAKS];
    }
    if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(config, START_CHARS_HINT)) {
        tokenType.START_CHARS_HINT = config[START_CHARS_HINT];
    }
    return tokenType;
}
var EOF = createToken({ name: "EOF", pattern: __WEBPACK_IMPORTED_MODULE_1__lexer_public__["a" /* Lexer */].NA });
Object(__WEBPACK_IMPORTED_MODULE_2__tokens__["a" /* augmentTokenTypes */])([EOF]);
function createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {
    return {
        image: image,
        startOffset: startOffset,
        endOffset: endOffset,
        startLine: startLine,
        endLine: endLine,
        startColumn: startColumn,
        endColumn: endColumn,
        tokenTypeIdx: tokType.tokenTypeIdx,
        tokenType: tokType
    };
}
function tokenMatcher(token, tokType) {
    return Object(__WEBPACK_IMPORTED_MODULE_2__tokens__["d" /* tokenStructuredMatcher */])(token, tokType);
}
//# sourceMappingURL=tokens_public.js.map

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = marginMixin;
/**
 * Margin is a mixin that provides margin utility functions for both the Row Chart and Coordinate Grid
 * Charts.
 * @name marginMixin
 * @memberof dc
 * @mixin
 * @param {Object} _chart
 * @return {dc.marginMixin}
 */
function marginMixin(_chart) {
  /* OVERRIDE ---------------------------------------------------------------- */
  var _margin = { top: 10, right: 50, bottom: 48, left: 60
    /* ------------------------------------------------------------------------- */

    /**
     * Get or set the margins for a particular coordinate grid chart instance. The margins is stored as
     * an associative Javascript array.
     * @name margins
     * @memberof dc.marginMixin
     * @instance
     * @example
     * var leftMargin = chart.margins().left; // 30 by default
     * chart.margins().left = 50;
     * leftMargin = chart.margins().left; // now 50
     * @param {{top: Number, right: Number, left: Number, bottom: Number}} [margins={top: 10, right: 50, bottom: 30, left: 30}]
     * @return {{top: Number, right: Number, left: Number, bottom: Number}}
     * @return {dc.marginMixin}
     */
  };_chart.margins = function (margins) {
    if (!arguments.length) {
      return _margin;
    }
    _margin = margins;
    return _chart;
  };

  _chart.effectiveWidth = function () {
    return _chart.width() - _chart.margins().left - _chart.margins().right;
  };

  _chart.effectiveHeight = function () {
    return _chart.height() - _chart.margins().top - _chart.margins().bottom;
  };

  return _chart;
}

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderAttributes = exports.GeoSvgFormatter = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.notNull = notNull;
exports.adjustOpacity = adjustOpacity;
exports.adjustRGBAOpacity = adjustRGBAOpacity;
exports.createVegaAttrMixin = createVegaAttrMixin;
exports.createRasterLayerGetterSetter = createRasterLayerGetterSetter;
exports.__displayPopup = __displayPopup;
exports.getSizeScaleName = getSizeScaleName;
exports.getColorScaleName = getColorScaleName;
exports.getScales = getScales;
exports.getRealLayers = getRealLayers;

var _d2 = __webpack_require__(1);

var _d3 = _interopRequireDefault(_d2);

var _wellknown = __webpack_require__(271);

var _wellknown2 = _interopRequireDefault(_wellknown);

var _mapdDraw = __webpack_require__(13);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function notNull(value) {
  return value != null; /* double-equals also catches undefined */
}

function adjustOpacity(color) {
  var opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

  if (!/#/.test(color)) {
    return color;
  }
  var hex = color.replace("#", "");
  var r = parseInt(hex.substring(0, 2), 16);
  var g = parseInt(hex.substring(2, 4), 16);
  var b = parseInt(hex.substring(4, 6), 16);
  return "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
}

function adjustRGBAOpacity(rgba, opacity) {
  var _rgba$split$1$split$ = rgba.split("(")[1].split(")")[0].split(","),
      _rgba$split$1$split$2 = _slicedToArray(_rgba$split$1$split$, 4),
      r = _rgba$split$1$split$2[0],
      g = _rgba$split$1$split$2[1],
      b = _rgba$split$1$split$2[2],
      a = _rgba$split$1$split$2[3];

  if (a) {
    var relativeOpacity = parseFloat(a) - (1 - opacity);
    a = "" + (relativeOpacity > 0 ? relativeOpacity : 0.01);
  } else {
    a = opacity;
  }
  return "rgba(" + r + "," + g + "," + b + "," + a + ")";
}

var ordScale = _d3.default.scale.ordinal();
var quantScale = _d3.default.scale.quantize();
var linearScale = _d3.default.scale.linear();

var capAttrMap = {
  FillColor: "color",
  Size: "size"
};

function createVegaAttrMixin(layerObj, attrName, defaultVal, nullVal, useScale, prePostFuncs) {
  var scaleFunc = "",
      fieldAttrFunc = "";
  var capAttrName = attrName.charAt(0).toUpperCase() + attrName.slice(1);
  var defaultFunc = "default" + capAttrName;
  var nullFunc = "null" + capAttrName;
  layerObj[defaultFunc] = createRasterLayerGetterSetter(layerObj, defaultVal, prePostFuncs ? prePostFuncs.preDefault : null, prePostFuncs ? prePostFuncs.postDefault : null);
  layerObj[nullFunc] = createRasterLayerGetterSetter(layerObj, nullVal, prePostFuncs ? prePostFuncs.preNull : null, prePostFuncs ? prePostFuncs.postNull : null);

  if (useScale) {
    scaleFunc = attrName + "Scale";
    fieldAttrFunc = attrName + "Attr";
    layerObj[scaleFunc] = createRasterLayerGetterSetter(layerObj, null, prePostFuncs ? prePostFuncs.preScale : null, prePostFuncs ? prePostFuncs.postScale : null);
    layerObj[fieldAttrFunc] = createRasterLayerGetterSetter(layerObj, null, prePostFuncs ? prePostFuncs.preField : null, prePostFuncs ? prePostFuncs.postField : null);

    layerObj["_build" + capAttrName + "Scale"] = function (chart, layerName) {
      var scale = layerObj[scaleFunc]();
      if (scale && scale.domain && scale.domain().length && scale.range().length && scaleFunc === "fillColorScale") {
        var colorScaleName = layerName + "_" + attrName;
        var rtnObj = {
          name: colorScaleName,
          type: chart._determineScaleType(scale),
          domain: scale.domain().filter(notNull),
          range: scale.range(),
          default: layerObj[defaultFunc](),
          nullValue: layerObj[nullFunc]()
        };

        if (scale.clamp) {
          rtnObj.clamp = scale.clamp();
        }

        return rtnObj;
      } else if (layerObj.densityAccumulatorEnabled()) {
        var _colorScaleName = layerName + "_" + attrName,
            colorsToUse = layerObj.defaultFillColor(),
            domainInterval = 100 / (colorsToUse.length - 1),
            linearColorScale = colorsToUse.map(function (color, i) {
          return i * domainInterval / 100;
        }),
            range = colorsToUse.map(function (color, i, colorArray) {
          var normVal = i / (colorArray.length - 1);
          var interp = Math.min(normVal / 0.65, 1.0);
          interp = interp * 0.375 + 0.625;
          return convertHexToRGBA(color, interp * 100);
        });

        var _rtnObj = {
          name: _colorScaleName,
          type: "linear",
          domain: linearColorScale,
          range: range,
          accumulator: "density",
          minDensityCnt: "-2ndStdDev",
          maxDensityCnt: "2ndStdDev",
          clamp: true
        };

        return _rtnObj;
      }
    };
  }

  var getValFunc = "get" + capAttrName + "Val";
  layerObj[getValFunc] = function (input) {
    var rtnVal = layerObj[defaultFunc]();
    if (input === null) {
      rtnVal = layerObj[nullFunc]();
    } else if (input !== undefined && useScale) {
      var encodingAttrName = capAttrMap[capAttrName];
      var capAttrObj = layerObj.getState().encoding[encodingAttrName];
      if (capAttrObj && capAttrObj.domain && capAttrObj.domain.length && capAttrObj.range.length) {
        var domainVals = capAttrObj.domain;
        if (domainVals === "auto") {
          var domainGetterFunc = encodingAttrName + "Domain";
          if (typeof layerObj[domainGetterFunc] !== "function") {
            throw new Error("Looking for a " + domainGetterFunc + " function on for attr " + attrName);
          }
          domainVals = layerObj[domainGetterFunc]();
        }
        if (capAttrObj.type === "ordinal") {
          ordScale.domain(domainVals).range(capAttrObj.range);
          // if color range is not in domain, it's an Other item
          rtnVal = domainVals.indexOf(input) === -1 ? ordScale("Other") : ordScale(input);
        } else if (Array.isArray(domainVals) && domainVals[0] === domainVals[1]) {
          // handling case where domain min/max are the same (FE-7408)
          linearScale.domain(domainVals).range(capAttrObj.range);
          rtnVal = Math.round(linearScale(input));
        } else {
          quantScale.domain(domainVals).range(capAttrObj.range);
          rtnVal = quantScale(input);
        }
      }
    }

    return rtnVal;
  };
}

function createRasterLayerGetterSetter(layerObj, attrVal, preSetFunc, postSetFunc) {
  return function (newVal) {
    if (!arguments.length) {
      return attrVal;
    }
    if (preSetFunc) {
      var rtnVal = preSetFunc(newVal, attrVal);
      if (rtnVal !== undefined) {
        newVal = rtnVal;
      }
    }
    attrVal = newVal;
    if (postSetFunc) {
      var rtnVal = postSetFunc(attrVal);
      if (rtnVal !== undefined) {
        attrVal = rtnVal;
      }
    }
    return layerObj;
  };
}

// Polygon and line svg on hovering

// NOTE: Reqd until ST_Transform supported on projection columns
function conv4326To900913(x, y) {
  var transCoord = [0.0, 0.0];
  transCoord[0] = x * 111319.49077777777778;
  transCoord[1] = Math.log(Math.tan((90.0 + y) * 0.00872664625997)) * 6378136.99911215736947;
  return transCoord;
}

var SvgFormatter = function () {
  function SvgFormatter() {
    _classCallCheck(this, SvgFormatter);
  }

  _createClass(SvgFormatter, [{
    key: "getBounds",

    /**
     * Builds the bounds from the incoming poly data
     * @param {AABox2d} out AABox2d to return
     * @param {object} data Object with return data from getResultRowForPixel()
     * @param {Number} width Width of the visualization div
     * @param {Number} height Height of the visualization div
     * @param {object} margin Margins of the visualization div
     * @param {Function} xscale d3 scale in x dimension from world space to pixel space (i.e. mercatorx-to-pixel)
     * @param {Function} yscale d3 scale in y dimension from world space to pixel space (i.e. mercatory-to-pixel)
     */
    value: function getBounds(data, width, height, margins, xscale, yscale) {
      throw new Error("This must be overridden");
    }

    /**
     * Builds the svg path string to use with the d svg attr:
     * https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d
     * This function should be called after the getBounds().
     * The t/s arguments are the transformations to properly place the points underneath
     * a parent SVG group node. That node is what ultimately handles animations and such
     * so we need to transform all the points into local space. t is the translation
     * and s is the scale to transform the points from pixel space to model/object space.
     * @param {string} out Returns the svg path string
     * @param {Point2d} t Translation from world to object space.
     * @param {Number} s Scale from world to object space.
     */

  }, {
    key: "getSvgPath",
    value: function getSvgPath(t, s) {
      throw new Error("This must be overridden");
    }
  }]);

  return SvgFormatter;
}();

var LegacyPolySvgFormatter = function (_SvgFormatter) {
  _inherits(LegacyPolySvgFormatter, _SvgFormatter);

  function LegacyPolySvgFormatter() {
    _classCallCheck(this, LegacyPolySvgFormatter);

    var _this = _possibleConstructorReturn(this, (LegacyPolySvgFormatter.__proto__ || Object.getPrototypeOf(LegacyPolySvgFormatter)).call(this));

    _this._polys = [];
    return _this;
  }

  _createClass(LegacyPolySvgFormatter, [{
    key: "getBounds",
    value: function getBounds(data, width, height, margins, xscale, yscale) {
      // NOTE: this is handling legacy poly storage for backwards compatibility.
      // Once we've put everything post 4.0 behind us, this can be fully deprecated.
      //
      // verts and drawinfo should be valid as the _resultsAreValidForPopup()
      // method should've been called beforehand
      var verts = data[polyTableGeomColumns.verts_LEGACY];
      var drawinfo = data[polyTableGeomColumns.linedrawinfo_LEGACY];

      var startIdxDiff = drawinfo.length ? drawinfo[2] : 0;
      var FLT_MAX = 1e37;

      var bounds = _mapdDraw.AABox2d.create();
      var screenPt = _mapdDraw.Point2d.create();
      for (var i = 0; i < drawinfo.length; i = i + 4) {
        // Draw info struct:
        //     0: count,         // number of verts in loop -- might include 3 duplicate verts at end for closure
        //     1: instanceCount, // should always be 1
        //     2: firstIndex,    // the start index (includes x & y) where the verts for the loop start
        //     3: baseInstance   // irrelevant for our purposes -- should always be 0
        var polypts = [];
        var count = (drawinfo[i] - 3) * 2; // include x&y, and drop 3 duplicated pts at the end
        var startIdx = (drawinfo[i + 2] - startIdxDiff) * 2; // include x&y
        var endIdx = startIdx + count; // remove the 3 duplicate pts at the end
        for (var idx = startIdx; idx < endIdx; idx = idx + 2) {
          if (verts[idx] <= -FLT_MAX) {
            // -FLT_MAX is a separator for multi-polygons (like Hawaii,
            // where there would be a polygon per island), so when we hit a separator,
            // remove the 3 duplicate points that would end the polygon prior to the separator
            // and start a new polygon
            polypts.pop();
            polypts.pop();
            polypts.pop();
            this._polys.push(polypts);
            polypts = [];
          } else {
            _mapdDraw.Point2d.set(screenPt, xscale(verts[idx]) + margins.left, height - yscale(verts[idx + 1]) - 1 + margins.top);

            if (screenPt[0] >= 0 && screenPt[0] <= width && screenPt[1] >= 0 && screenPt[1] <= height) {
              _mapdDraw.AABox2d.encapsulatePt(bounds, bounds, screenPt);
            }
            polypts.push(screenPt[0]);
            polypts.push(screenPt[1]);
          }
        }

        this._polys.push(polypts);
      }

      return bounds;
    }
  }, {
    key: "getSvgPath",
    value: function getSvgPath(t, s) {
      var rtnPointStr = "";
      this._polys.forEach(function (pts) {
        if (!pts) {
          return;
        }

        var pointStr = "";
        for (var i = 0; i < pts.length; i = i + 2) {
          if (!isNaN(pts[i]) && !isNaN(pts[i + 1])) {
            pointStr += (pointStr.length ? "L" : "M") + s * (pts[i] - t[0]) + "," + s * (pts[i + 1] - t[1]);
          }
        }
        if (pointStr.length) {
          pointStr += "Z";
        }
        rtnPointStr += pointStr;
      });
      return rtnPointStr;
    }
  }]);

  return LegacyPolySvgFormatter;
}(SvgFormatter);

function buildGeoProjection(width, height, margins, xscale, yscale) {
  var clamp = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
  var t = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [0, 0];
  var s = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 1;

  var _translation = t,
      _scale = s,
      _clamp = clamp;

  var project = _d3.default.geo.transform({
    point: function point(lon, lat) {
      var projectedCoord = conv4326To900913(lon, lat);
      var pt = [_scale * (xscale(projectedCoord[0]) + margins.left - _translation[0]), _scale * (height - yscale(projectedCoord[1]) - 1 + margins.top - _translation[1])];
      if (_clamp) {
        if (pt[0] >= 0 && pt[0] < width && pt[1] >= 0 && pt[1] < height) {
          return this.stream.point(pt[0], pt[1]);
        }
      } else {
        return this.stream.point(pt[0], pt[1]);
      }
    }
  });

  project.setTransforms = function (t, s) {
    _translation = t;
    _scale = s;
  };

  project.setClamp = function (clamp) {
    _clamp = Boolean(clamp);
  };

  return project;
}

var GeoSvgFormatter = exports.GeoSvgFormatter = function (_SvgFormatter2) {
  _inherits(GeoSvgFormatter, _SvgFormatter2);

  function GeoSvgFormatter(geocol) {
    _classCallCheck(this, GeoSvgFormatter);

    var _this2 = _possibleConstructorReturn(this, (GeoSvgFormatter.__proto__ || Object.getPrototypeOf(GeoSvgFormatter)).call(this));

    _this2._geojson = null;
    _this2._projector = null;
    _this2._d3projector = null;
    _this2._geocol = geocol;
    return _this2;
  }

  _createClass(GeoSvgFormatter, [{
    key: "getBounds",
    value: function getBounds(data, width, height, margins, xscale, yscale) {
      var wkt = data[this._geocol];
      if (typeof wkt !== "string") {
        throw new Error("Cannot create SVG from geo polygon column \"" + this._geocol + "\". The data returned is not a WKT string. It is of type: " + (typeof wkt === "undefined" ? "undefined" : _typeof(wkt)));
      }
      this._geojson = _wellknown2.default.parse(wkt);
      this._projector = buildGeoProjection(width, height, margins, xscale, yscale, true);

      // NOTE: d3.geo.path() streaming requires polygons to duplicate the first vertex in the last slot
      // to complete a full loop. If the first vertex is not duplicated, the last vertex can be dropped.
      // This is currently a requirement for the incoming WKT string, but is not error checked by d3.
      this._d3projector = _d3.default.geo.path().projection(this._projector);
      var d3bounds = this._d3projector.bounds(this._geojson);
      return _mapdDraw.AABox2d.create(d3bounds[0][0], d3bounds[0][1], d3bounds[1][0], d3bounds[1][1]);
    }
  }, {
    key: "getSvgPath",
    value: function getSvgPath(t, s) {
      this._projector.setTransforms(t, s);
      this._projector.setClamp(false);
      return this._d3projector(this._geojson);
    }
  }]);

  return GeoSvgFormatter;
}(SvgFormatter);

var renderAttributes = exports.renderAttributes = ["x", "y", "fillColor", "strokeColor", "strokeWidth", "lineJoin", "miterLimit", "opacity"];

var _scaledPopups = {};

function __displayPopup(svgProps) {
  var chart = svgProps.chart,
      parentElem = svgProps.parentElem,
      data = svgProps.data,
      width = svgProps.width,
      height = svgProps.height,
      margins = svgProps.margins,
      xscale = svgProps.xscale,
      yscale = svgProps.yscale,
      minPopupArea = svgProps.minPopupArea,
      animate = svgProps.animate,
      _vega = svgProps._vega,
      _layer = svgProps._layer,
      state = svgProps.state;


  var layerType = _layer.layerType();

  var geoPathFormatter = null;
  if (chart._useGeoTypes) {
    if (!state.encoding.geocol) {
      throw new Error("No poly/multipolygon column specified. Cannot build poly outline popup.");
    }
    // For linemap dimension selection, we are using alias "sampled_geo"
    var geoCol = state.transform.groupby && state.transform.groupby.length && state.mark.type === "lines" ? "sampled_geo" : state.encoding.geocol;
    geoPathFormatter = new GeoSvgFormatter(geoCol);
  } else if (!chart._useGeoTypes && layerType === "polys") {
    geoPathFormatter = new LegacyPolySvgFormatter();
  } else {
    throw new Error("Cannot build outline popup.");
  }

  var bounds = geoPathFormatter.getBounds(data, width, height, margins, xscale, yscale);

  // Check for 2 special cases:
  // 1) zoomed in so far in that the poly encompasses the entire view, so all points are
  //    outside the view
  // 2) the poly only has 1 point in view.
  // Both cases can be handled by checking whether the bounds is empty (infinite) in
  // either x/y or the bounds size is 0 in x/y.
  var boundsSz = _mapdDraw.AABox2d.getSize(_mapdDraw.Point2d.create(), bounds);
  if (!isFinite(boundsSz[0]) || boundsSz[0] === 0) {
    bounds[_mapdDraw.AABox2d.MINX] = 0;
    bounds[_mapdDraw.AABox2d.MAXX] = width;
    boundsSz[0] = width;
  }
  if (!isFinite(boundsSz[1]) || boundsSz[1] === 0) {
    bounds[_mapdDraw.AABox2d.MINY] = 0;
    bounds[_mapdDraw.AABox2d.MAXY] = height;
    boundsSz[1] = height;
  }

  // Get the data from the hit-test object used to drive render properties
  // These will be used to properly style the svg popup object
  var rndrProps = {};
  if (_vega && Array.isArray(_vega.marks) && _vega.marks.length > 0 && _vega.marks[0].properties) {
    var propObj = _vega.marks[0].properties;

    renderAttributes.forEach(function (prop) {
      if (_typeof(propObj[prop]) === "object" && propObj[prop].field && typeof propObj[prop].field === "string") {
        rndrProps[prop] = propObj[prop].field;
      }
    });
  }

  // If the poly we hit-test is small, we'll scale it so that it
  // can be seen. The minPopupArea is the minimum area of the popup
  // poly, so if the poly's bounds is < minPopupArea, we'll scale it
  // up to that size.
  var scale = 1;
  var scaleRatio = minPopupArea / _mapdDraw.AABox2d.area(bounds);
  var isScaled = scaleRatio > 1;
  if (isScaled) {
    scale = Math.sqrt(scaleRatio);
  }

  // Now grab the style properties for the svg calculated from the vega
  var popupStyle = _layer.popupStyle();
  var fillColor = _layer.getFillColorVal(data[rndrProps.fillColor]);
  var strokeColor = _layer.getStrokeColorVal(data[rndrProps.strokeColor]);
  var strokeWidth = 1;
  if ((typeof popupStyle === "undefined" ? "undefined" : _typeof(popupStyle)) === "object" && !isScaled) {
    fillColor = popupStyle.fillColor || fillColor;
    strokeColor = popupStyle.strokeColor || strokeColor;
    strokeWidth = popupStyle.strokeWidth;
  }

  // build out the svg
  var svg = parentElem.append("svg").attr("width", width).attr("height", height);

  // transform svg node. This node will position the svg appropriately. Need
  // to offset according to the scale above (scale >= 1)
  var boundsCtr = _mapdDraw.AABox2d.getCenter(_mapdDraw.Point2d.create(), bounds);
  var xform = svg.append("g").attr("class", layerType === "polys" ? "map-poly-xform" : "map-polyline").attr("transform", "translate(" + (scale * bounds[_mapdDraw.AABox2d.MINX] - (scale - 1) * boundsCtr[0]) + ", " + (scale * (bounds[_mapdDraw.AABox2d.MINY] + 1) - (scale - 1) * (boundsCtr[1] + 1)) + ")");

  // now add a transform node that will be used to apply animated scales to
  // We want the animation to happen from the center of the bounds, so we
  // place the transform origin there.
  var group = xform.append("g").attr("class", layerType === "polys" ? "map-poly" : "map-polyline").attr("transform-origin", boundsSz[0] / 2 + " " + boundsSz[1] / 2);

  // inherited animation classes from css
  if (animate) {
    if (isScaled) {
      group.classed("popupPoly", true);
    } else {
      group.classed("fadeInPoly", true);
    }
  }

  // now apply the styles
  if (typeof strokeWidth === "number") {
    group.style("stroke-width", strokeWidth);
  }

  if (layerType === "lines") {
    // applying shadow
    var defs = group.append("defs");

    var filter = defs.append("filter").attr("id", "drop-shadow").attr("width", "200%").attr("height", "200%");

    filter.append("feOffset").attr("in", "SourceAlpha").attr("result", "offOut").attr("dx", "2").attr("dy", "2");

    filter.append("feGaussianBlur").attr("in", "offOut").attr("stdDeviation", 2).attr("result", "blurOut");

    filter.append("feBlend").attr("in", "SourceGraphic").attr("in2", "blurOut").attr("mode", "normal");
  }

  group.append("path").attr("d", geoPathFormatter.getSvgPath(_mapdDraw.Point2d.create(bounds[_mapdDraw.AABox2d.MINX], bounds[_mapdDraw.AABox2d.MINY]), scale)).attr("class", layerType === "polys" ? "map-polygon-shape" : "map-polyline").attr("fill", layerType === "polys" ? fillColor : "none").attr("fill-rule", "evenodd").attr("stroke-width", strokeWidth).attr("stroke", strokeColor).style("filter", layerType === "polys" ? "none" : "url(#drop-shadow)").on("click", function () {
    if (layerType === "polys") {
      return _layer.onClick(chart, data, _d3.default.event);
    } else {
      return null;
    }
  });

  _scaledPopups[chart] = isScaled;

  return bounds;
}

function getSizeScaleName(layerName) {
  if (layerName === "linemap") {
    return layerName + "_strokeWidth";
  } else {
    return layerName + "_size";
  }
}

function getColorScaleName(layerName) {
  if (layerName === "linemap") {
    return layerName + "_strokeColor";
  } else {
    return layerName + "_fillColor";
  }
}

function getScales(_ref, layerName, scaleDomainFields, xformDataSource) {
  var size = _ref.size,
      color = _ref.color,
      orientation = _ref.orientation;

  var scales = [];

  if ((typeof size === "undefined" ? "undefined" : _typeof(size)) === "object" && (size.type === "quantitative" || size.type === "custom")) {
    scales.push({
      name: getSizeScaleName(layerName),
      type: "linear",
      domain: size.domain === "auto" ? { data: xformDataSource, fields: scaleDomainFields.size } : size.domain,
      range: size.range,
      clamp: true
    });
  }

  if ((typeof color === "undefined" ? "undefined" : _typeof(color)) === "object" && color.type === "density") {
    scales.push({
      name: getColorScaleName(layerName),
      type: "linear",
      domain: color.range.map(function (c, i) {
        return i * 100 / (color.range.length - 1) / 100;
      }),
      range: color.range.map(function (c) {
        return adjustOpacity(c, color.opacity);
      }).map(function (c, i, colorArray) {
        var normVal = i / (colorArray.length - 1);
        var interp = Math.min(normVal / 0.65, 1.0);
        interp = interp * 0.375 + 0.625;
        return adjustRGBAOpacity(c, interp);
      }),
      accumulator: "density",
      minDensityCnt: "-2ndStdDev",
      maxDensityCnt: "2ndStdDev",
      clamp: true
    });
  }

  if ((typeof color === "undefined" ? "undefined" : _typeof(color)) === "object" && color.type === "ordinal") {
    scales.push({
      name: getColorScaleName(layerName),
      type: "ordinal",
      domain: color.domain === "auto" ? { data: xformDataSource, fields: scaleDomainFields.color } : color.domain,
      range: color.range.map(function (c) {
        return adjustOpacity(c, color.opacity);
      }),
      default: adjustOpacity(color.defaultOtherRange, // color passed from immerse color palette for 'Other' category
      color.hasOwnProperty("showOther") && !color.showOther ? 0 // When Other is toggled OFF, we make the Other category transparent
      : color.opacity),
      nullValue: adjustOpacity("#CACACA", color.opacity)
    });
  }

  if ((typeof color === "undefined" ? "undefined" : _typeof(color)) === "object" && color.type === "quantitative") {
    scales.push({
      name: getColorScaleName(layerName),
      type: "quantize",
      domain: color.domain === "auto" ? { data: xformDataSource, fields: scaleDomainFields.color } : color.domain,
      range: color.range.map(function (c) {
        return adjustOpacity(c, color.opacity);
      })
    });
  }

  if ((typeof orientation === "undefined" ? "undefined" : _typeof(orientation)) === "object" && orientation.type === "quantitative") {
    scales.push({
      name: layerName + "_symbolAngle",
      type: "linear",
      domain: orientation.domain,
      range: orientation.range,
      clamp: false
    });
  }

  return scales;
}

/**
 * Filters z-indexed layers and returns non duplicate layer. Z-indexed layers is for temporary hack FE-13136
 * For z-indexed layer (layer that has top color category applied), only returns the first z-index, z_0
 * @param layers
 * @returns {[]}
 */
function getRealLayers(layers) {
  var filteredLayers = [];
  var visited = {};

  layers.forEach(function (layerName) {
    if (layerName.includes("_z")) {
      var idx = layerName.indexOf("_z");
      var realLayerName = layerName.substring(0, idx); // real layer name is substring up to _z...
      if (!visited[realLayerName]) {
        visited[realLayerName] = layerName; // can use only the first z-index layerName
        filteredLayers.push(layerName);
      }
    } else {
      filteredLayers.push(layerName);
    }
  });
  return filteredLayers;
}

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GAstVisitor; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gast_public__ = __webpack_require__(6);

var GAstVisitor = /** @class */ (function () {
    function GAstVisitor() {
    }
    GAstVisitor.prototype.visit = function (node) {
        var nodeAny = node;
        switch (nodeAny.constructor) {
            case __WEBPACK_IMPORTED_MODULE_0__gast_public__["d" /* NonTerminal */]:
                return this.visitNonTerminal(nodeAny);
            case __WEBPACK_IMPORTED_MODULE_0__gast_public__["c" /* Flat */]:
                return this.visitFlat(nodeAny);
            case __WEBPACK_IMPORTED_MODULE_0__gast_public__["e" /* Option */]:
                return this.visitOption(nodeAny);
            case __WEBPACK_IMPORTED_MODULE_0__gast_public__["g" /* RepetitionMandatory */]:
                return this.visitRepetitionMandatory(nodeAny);
            case __WEBPACK_IMPORTED_MODULE_0__gast_public__["h" /* RepetitionMandatoryWithSeparator */]:
                return this.visitRepetitionMandatoryWithSeparator(nodeAny);
            case __WEBPACK_IMPORTED_MODULE_0__gast_public__["i" /* RepetitionWithSeparator */]:
                return this.visitRepetitionWithSeparator(nodeAny);
            case __WEBPACK_IMPORTED_MODULE_0__gast_public__["f" /* Repetition */]:
                return this.visitRepetition(nodeAny);
            case __WEBPACK_IMPORTED_MODULE_0__gast_public__["b" /* Alternation */]:
                return this.visitAlternation(nodeAny);
            case __WEBPACK_IMPORTED_MODULE_0__gast_public__["k" /* Terminal */]:
                return this.visitTerminal(nodeAny);
            case __WEBPACK_IMPORTED_MODULE_0__gast_public__["j" /* Rule */]:
                return this.visitRule(nodeAny);
            /* istanbul ignore next */
            default:
                throw Error("non exhaustive match");
        }
    };
    GAstVisitor.prototype.visitNonTerminal = function (node) { };
    GAstVisitor.prototype.visitFlat = function (node) { };
    GAstVisitor.prototype.visitOption = function (node) { };
    GAstVisitor.prototype.visitRepetition = function (node) { };
    GAstVisitor.prototype.visitRepetitionMandatory = function (node) { };
    GAstVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) { };
    GAstVisitor.prototype.visitRepetitionWithSeparator = function (node) { };
    GAstVisitor.prototype.visitAlternation = function (node) { };
    GAstVisitor.prototype.visitTerminal = function (node) { };
    GAstVisitor.prototype.visitRule = function (node) { };
    return GAstVisitor;
}());

//# sourceMappingURL=gast_visitor_public.js.map

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.filters = undefined;

var _formattingHelpers = __webpack_require__(10);

/**
 * The dc.js filters are functions which are passed into crossfilter to chose which records will be
 * accumulated to produce values for the charts.  In the crossfilter model, any filters applied on one
 * dimension will affect all the other dimensions but not that one.  dc always applies a filter
 * function to the dimension; the function combines multiple filters and if any of them accept a
 * record, it is filtered in.
 *
 * These filter constructors are used as appropriate by the various charts to implement brushing.  We
 * mention below which chart uses which filter.  In some cases, many instances of a filter will be added.
 *
 * Each of the dc.js filters is an object with the following properties:
 * * `isFiltered` - a function that returns true if a value is within the filter
 * * `filterType` - a string identifying the filter, here the name of the constructor
 *
 * Currently these filter objects are also arrays, but this is not a requirement. Custom filters
 * can be used as long as they have the properties above.
 * @name filters
 * @memberof dc
 * @type {{}}
 */
var filters = exports.filters = {};

/**
 * RangedFilter is a filter which accepts keys between `low` and `high`.  It is used to implement X
 * axis brushing for the {@link #dc.coordinateGridMixin coordinate grid charts}.
 *
 * Its `filterType` is 'RangedFilter'
 * @name RangedFilter
 * @memberof dc.filters
 * @param {Number} low
 * @param {Number} high
 * @return {Array<Number>}
 * @constructor
 */
filters.RangedFilter = function (low, high) {
  var range = new Array(low, high);
  range.isFiltered = function (value) {
    return value >= this[0] && value <= this[1];
  };
  range.filterType = "RangedFilter";

  return range;
};

/**
 * TwoDimensionalFilter is a filter which accepts a single two-dimensional value.  It is used by the
 * {@link #dc.heatMap heat map chart} to include particular cells as they are clicked.  (Rows and columns are
 * filtered by filtering all the cells in the row or column.)
 *
 * Its `filterType` is 'TwoDimensionalFilter'
 * @name TwoDimensionalFilter
 * @memberof filters
 * @param {Array<Number>} filter
 * @return {Array<Number>}
 * @constructor
 */
filters.TwoDimensionalFilter = function () {
  var filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  if (filter === null) {
    return null;
  }
  if (filter === Symbol.for("clear")) {
    return filter;
  }

  var f = (0, _formattingHelpers.normalizeFiltersArray)(filter);
  f.isFiltered = function (value) {
    return value.length && value.length === f.length && value[0] === f[0] && value[1] === f[1];
  };
  f.filterType = "TwoDimensionalFilter";

  return f;
};

/**
 * The RangedTwoDimensionalFilter allows filtering all values which fit within a rectangular
 * region. It is used by the {@link #dc.scatterPlot scatter plot} to implement rectangular brushing.
 *
 * It takes two two-dimensional points in the form `[[x1,y1],[x2,y2]]`, and normalizes them so that
 * `x1 <= x2` and `y1 <- y2`. It then returns a filter which accepts any points which are in the
 * rectangular range including the lower values but excluding the higher values.
 *
 * If an array of two values are given to the RangedTwoDimensionalFilter, it interprets the values as
 * two x coordinates `x1` and `x2` and returns a filter which accepts any points for which `x1 <= x <
 * x2`.
 *
 * Its `filterType` is 'RangedTwoDimensionalFilter'
 * @name RangedTwoDimensionalFilter
 * @memberof filters
 * @param {Array<Array<Number>>} filter
 * @return {Array<Array<Number>>}
 * @constructor
 */
filters.RangedTwoDimensionalFilter = function (filter) {
  if (filter === null) {
    return null;
  }
  if (filter === Symbol.for("clear")) {
    return filter;
  }

  var f = filter;
  var fromBottomLeft = void 0;

  if (f[0] instanceof Array) {
    fromBottomLeft = [[Math.min(filter[0][0], filter[1][0]), Math.min(filter[0][1], filter[1][1])], [Math.max(filter[0][0], filter[1][0]), Math.max(filter[0][1], filter[1][1])]];
  } else {
    fromBottomLeft = [[filter[0], -Infinity], [filter[1], Infinity]];
  }

  f.isFiltered = function (value) {
    var x = void 0,
        y = void 0;

    if (value instanceof Array) {
      if (value.length !== 2) {
        return false;
      }
      x = value[0];
      y = value[1];
    } else {
      x = value;
      y = fromBottomLeft[0][1];
    }

    return x >= fromBottomLeft[0][0] && x < fromBottomLeft[1][0] && y >= fromBottomLeft[0][1] && y < fromBottomLeft[1][1];
  };
  f.filterType = "RangedTwoDimensionalFilter";

  return f;
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFirstNonNullDatumForAxis = exports.createBinParams = exports.BIN_INPUT_OPTIONS = exports.TIME_SPANS = exports.DEFAULT_EXTRACT_INTERVAL = undefined;
exports.autoBinParams = autoBinParams;
exports.checkIfTimeBinInRange = checkIfTimeBinInRange;

var _datesAndTimes = __webpack_require__(29);

var DEFAULT_EXTRACT_INTERVAL = exports.DEFAULT_EXTRACT_INTERVAL = "isodow";

var DEFAULT_NULL_TIME_RANGE = "day";

var TIME_SPANS = exports.TIME_SPANS = _datesAndTimes.TIME_LABELS.map(function (label) {
  return {
    label: label,
    numSeconds: _datesAndTimes.TIME_LABEL_TO_SECONDS[label]
  };
});

var BIN_INPUT_OPTIONS = exports.BIN_INPUT_OPTIONS = [{ val: "auto", label: "auto", numSeconds: null }, { val: "century", label: "1c", numSeconds: _datesAndTimes.CENTURY_IN_SECONDS }, { val: "decade", label: "10y", numSeconds: _datesAndTimes.DECADE_IN_SECONDS }, { val: "year", label: "1y", numSeconds: _datesAndTimes.YEAR_IN_SECONDS }, { val: "quarter", label: "1q", numSeconds: _datesAndTimes.QUARTER_IN_SECONDS }, { val: "month", label: "1mo", numSeconds: _datesAndTimes.MONTH_IN_SECONDS }, { val: "week", label: "1w", numSeconds: _datesAndTimes.WEEK_IN_SECONDS }, { val: "day", label: "1d", numSeconds: _datesAndTimes.DAY_IN_SECONDS }, { val: "hour", label: "1h", numSeconds: _datesAndTimes.HOUR_IN_SECONDS }, { val: "minute", label: "1m", numSeconds: _datesAndTimes.MIN_IN_SECONDS }, { val: "second", label: "1s", numSeconds: _datesAndTimes.SECOND }, { val: "millisecond", label: "1ms", numSeconds: _datesAndTimes.MS_IN_SECONDS }];

function autoBinParams(timeBounds, maxNumBins, reverse) {
  var epochTimeBounds = [timeBounds[0] * 0.001, timeBounds[1] * 0.001];
  var timeRange = epochTimeBounds[1] - epochTimeBounds[0]; // in seconds
  if (timeRange === 0) {
    return DEFAULT_NULL_TIME_RANGE;
  }
  var timeSpans = reverse ? TIME_SPANS.slice().reverse() : TIME_SPANS;

  for (var s = 0; s < timeSpans.length; s++) {
    if (timeRange / timeSpans[s].numSeconds < maxNumBins) {
      return timeSpans[s].label;
    }
  }
  return "century"; // default
}

function checkIfTimeBinInRange(timeBounds, timeBin, maxNumBins) {
  var epochTimeBounds = [timeBounds[0] * 0.001, timeBounds[1] * 0.001];
  var timeRange = epochTimeBounds[1] - epochTimeBounds[0]; // in seconds
  var timeLabelToSecs = _datesAndTimes.TIME_LABEL_TO_SECONDS;
  if (timeRange / timeLabelToSecs[timeBin] > maxNumBins) {
    return autoBinParams(timeBounds, maxNumBins);
  } else if (timeRange / timeLabelToSecs[timeBin] < 2) {
    return autoBinParams(timeBounds, maxNumBins, true);
  } else {
    return timeBin;
  }
}

var createBinParams = exports.createBinParams = function createBinParams(chart, binParams) {
  if (!chart.group() || !chart.group().binParams) {
    return;
  }

  binParams = Array.isArray(binParams) ? binParams : [binParams];

  var parsedBinParams = binParams.map(function (param) {
    if (param) {
      var _param$timeBin = param.timeBin,
          timeBin = _param$timeBin === undefined ? "auto" : _param$timeBin,
          binBounds = param.binBounds,
          numBins = param.numBins;

      var extract = param.extract || false;
      var isDate = binBounds[0] instanceof Date;
      if (isDate && timeBin === "auto") {
        var bounds = binBounds.map(function (date) {
          return date.getTime();
        });
        return Object.assign({}, param, {
          extract: extract,
          timeBin: extract ? DEFAULT_EXTRACT_INTERVAL : autoBinParams(bounds, numBins),
          binBounds: binBounds.slice(),
          auto: true // hightlights the "auto" UI button
        });
      } else {
        return Object.assign({}, param, {
          extract: extract,
          timeBin: timeBin,
          binBounds: binBounds.slice()
        });
      }
    }
    return param;
  });

  chart.group().binParams(parsedBinParams);
  return chart;
};

var getFirstNonNullDatumForAxis = exports.getFirstNonNullDatumForAxis = function getFirstNonNullDatumForAxis(data, axisType) {
  return data && Array.isArray(data) && data.find(function () {
    var datum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var keyVal = datum["key" + (axisType === "x" ? "0" : "1")];
    var value = Array.isArray(keyVal) ? keyVal[0] : keyVal;
    return value !== null;
  });
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.15';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
      FUNC_ERROR_TEXT = 'Expected a function';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295,
      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]',
      weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g,
      reTrimStart = /^\s+/,
      reTrimEnd = /\s+$/;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat,
      freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection) {
      if (predicate(value, key, collection)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  var runInContext = (function runInContext(context) {
    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

    /** Built-in constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = context['__core-js_shared__'];

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /** Mocked built-ins. */
    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse;

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack);
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      var index = -1;
      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array == null ? 0 : array.length,
          valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
    var clearTimeout = ctxClearTimeout || function(id) {
      return root.clearTimeout(id);
    };

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = getIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG,
          isBind = bitmask & WRAP_BIND_FLAG,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
          isFlip = bitmask & WRAP_FLIP_FLAG,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision && nativeIsFinite(number)) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set(values);
    };

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }

    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return new Ctor;

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return new Ctor;

        case symbolTag:
          return cloneSymbol(object);
      }
    }

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      if (key === 'constructor' && typeof object[key] === 'function') {
        return;
      }

      if (key == '__proto__') {
        return;
      }

      return object[key];
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    var setTimeout = ctxSetTimeout || function(func, wait) {
      return root.setTimeout(func, wait);
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index);
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax(length + index, 0)
          : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, getIteratee(iteratee, 2))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, getIteratee(iteratee, 2))
        : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(getIteratee(predicate, 3)));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = ctxNow || function() {
      return root.Date.now();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(getIteratee()))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start == null ? 0 : nativeMax(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value),
          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

      return func(value);
    }

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
    }

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      result[value] = key;
    }, constant(identity));

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(getIteratee(predicate)));
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = getIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor(mid), chars) +
        string +
        createPadding(nativeCeil(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      // The sourceURL gets injected into the source that's eval-ed, so be careful
      // with lookup (in case of e.g. prototype pollution), and strip newlines if any.
      // A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.
      var sourceURL = '//# sourceURL=' +
        (hasOwnProperty.call(options, 'sourceURL')
          ? (options.sourceURL + '').replace(/[\r\n]/g, ' ')
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      // Like with sourceURL, we take care to not check the option's prototype,
      // as this configuration is a code injection vector.
      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrim, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimEnd, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
      });
      return object;
    });

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = getIteratee();

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      if (options == null &&
          !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     */
    var overSome = createOver(arraySome);

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH,
          length = nativeMin(n, MAX_ARRAY_LENGTH);

      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
        : undefined;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee, 2));
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
        : undefined;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, getIteratee(iteratee, 2))
        : 0;
    }

    /*------------------------------------------------------------------------*/

    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.conformsTo = conformsTo;
    lodash.deburr = deburr;
    lodash.defaultTo = defaultTo;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.stubArray = stubArray;
    lodash.stubFalse = stubFalse;
    lodash.stubObject = stubObject;
    lodash.stubString = stubString;
    lodash.stubTrue = stubTrue;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;

    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(getIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name + '';
        if (!hasOwnProperty.call(realNames, key)) {
          realNames[key] = [];
        }
        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = wrapperToIterator;
    }
    return lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (true) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return _;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else if (freeModule) {
    // Export for Node.js.
    (freeModule.exports = _)._ = _;
    // Export for CommonJS support.
    freeExports._ = _;
  }
  else {
    // Export to the global object.
    root._ = _;
  }
}.call(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(48), __webpack_require__(53)(module)))

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.distance_in_meters = distance_in_meters;
exports.conv900913To4326X = conv900913To4326X;
exports.conv900913To4326Y = conv900913To4326Y;
exports.conv900913To4326 = conv900913To4326;
exports.conv4326To900913X = conv4326To900913X;
exports.conv4326To900913Y = conv4326To900913Y;
exports.conv4326To900913 = conv4326To900913;

var _mapdDraw = __webpack_require__(13);

var MapdDraw = _interopRequireWildcard(_mapdDraw);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Calculates the distance in meters between two lon/lat coordinates
 * @param  {number} fromlon Longitude to start from
 * @param  {number} fromlat Latitude to start from
 * @param  {number} tolon   Longitude to end at
 * @param  {number} tolat   Latitude to end at
 * @return {number}         Distance in meters from two lon/lat coords
 */
function distance_in_meters(fromlon, fromlat, tolon, tolat) {
  var latitudeArc = (fromlat - tolat) * MapdDraw.Math.DEG_TO_RAD;
  var longitudeArc = (fromlon - tolon) * MapdDraw.Math.DEG_TO_RAD;
  var latitudeH = Math.sin(latitudeArc * 0.5);
  latitudeH = latitudeH * latitudeH;
  var lontitudeH = Math.sin(longitudeArc * 0.5);
  lontitudeH = lontitudeH * lontitudeH;
  var tmp = Math.cos(fromlat * MapdDraw.Math.DEG_TO_RAD) * Math.cos(tolat * MapdDraw.Math.DEG_TO_RAD);
  return 6372797.560856 * (2.0 * Math.asin(Math.sqrt(latitudeH + tmp * lontitudeH)));
}

/**
 * Converts mercator x coordinate to longitude
 * @param  {number} x X coordinate in mercator projected space
 * @return {number}   Longitude
 */
function conv900913To4326X(x) {
  return x / 111319.490778;
}

/**
 * Converts mercator y coordinate to latitude
 * @param  {number} y Y coordinate in mercator projected space
 * @return {number}   Latitude
 */
function conv900913To4326Y(y) {
  return 57.295779513 * (2 * Math.atan(Math.exp(y / 6378136.99911)) - 1.570796327);
}

/**
 * Converts 2d point in mercator projected space to a lon/lat coordinate
 * @param  {Point2d} out   2d point to store the converted lat/lon coordinate
 * @param  {Point2d} coord 2d point in mercator projected space to convert
 * @return {Point2d}       Point referred to by the out arg
 */
function conv900913To4326(out, coord) {
  return MapdDraw.Point2d.set(out, conv900913To4326X(coord[0]), conv900913To4326Y(coord[1]));
}

/**
 * Converts a longitude coordinate to an x coordinate in mercator projected space
 * @param  {number} x Longitude
 * @return {number}   X coordinate in mercator projected space
 */
function conv4326To900913X(x) {
  return x * 111319.490778;
}

/**
 * Converts a latitude coordinate to a y coordinate in mercator projected space
 * @param  {number} x Latitude
 * @return {number}   Y coordinate in mercator projected space
 */
function conv4326To900913Y(y) {
  return 6378136.99911 * Math.log(Math.tan(0.00872664626 * y + 0.785398163397));
}

/**
 * Converts 2d lon/lat point to a point in mercator projected space
 * @param  {Point2d} out   2d point to store the converted mercator coordinate
 * @param  {Point2d} coord 2d point in lon/lat to convert
 * @return {Point2d}       Point referred to by the out arg
 */
function conv4326To900913(out, coord) {
  return MapdDraw.Point2d.set(out, conv4326To900913X(coord[0]), conv4326To900913Y(coord[1]));
}

/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["d"] = tokenStructuredMatcher;
/* harmony export (immutable) */ __webpack_exports__["e"] = tokenStructuredMatcherNoCategories;
/* unused harmony export tokenShortNameIdx */
/* unused harmony export tokenIdxToClass */
/* harmony export (immutable) */ __webpack_exports__["a"] = augmentTokenTypes;
/* unused harmony export expandCategories */
/* unused harmony export assignTokenDefaultProps */
/* unused harmony export assignCategoriesTokensProp */
/* unused harmony export assignCategoriesMapProp */
/* unused harmony export singleAssignCategoriesToksMap */
/* harmony export (immutable) */ __webpack_exports__["b"] = hasShortKeyProperty;
/* unused harmony export hasCategoriesProperty */
/* unused harmony export hasExtendingTokensTypesProperty */
/* unused harmony export hasExtendingTokensTypesMapProperty */
/* harmony export (immutable) */ __webpack_exports__["c"] = isTokenType;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);

function tokenStructuredMatcher(tokInstance, tokConstructor) {
    var instanceType = tokInstance.tokenTypeIdx;
    if (instanceType === tokConstructor.tokenTypeIdx) {
        return true;
    }
    else {
        return (tokConstructor.isParent === true &&
            tokConstructor.categoryMatchesMap[instanceType] === true);
    }
}
// Optimized tokenMatcher in case our grammar does not use token categories
// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead
function tokenStructuredMatcherNoCategories(token, tokType) {
    return token.tokenTypeIdx === tokType.tokenTypeIdx;
}
var tokenShortNameIdx = 1;
var tokenIdxToClass = {};
function augmentTokenTypes(tokenTypes) {
    // collect the parent Token Types as well.
    var tokenTypesAndParents = expandCategories(tokenTypes);
    // add required tokenType and categoryMatches properties
    assignTokenDefaultProps(tokenTypesAndParents);
    // fill up the categoryMatches
    assignCategoriesMapProp(tokenTypesAndParents);
    assignCategoriesTokensProp(tokenTypesAndParents);
    Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(tokenTypesAndParents, function (tokType) {
        tokType.isParent = tokType.categoryMatches.length > 0;
    });
}
function expandCategories(tokenTypes) {
    var result = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["g" /* cloneArr */])(tokenTypes);
    var categories = tokenTypes;
    var searching = true;
    while (searching) {
        categories = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["i" /* compact */])(Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["t" /* flatten */])(Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */])(categories, function (currTokType) { return currTokType.CATEGORIES; })));
        var newCategories = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["l" /* difference */])(categories, result);
        result = result.concat(newCategories);
        if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["A" /* isEmpty */])(newCategories)) {
            searching = false;
        }
        else {
            categories = newCategories;
        }
    }
    return result;
}
function assignTokenDefaultProps(tokenTypes) {
    Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(tokenTypes, function (currTokType) {
        if (!hasShortKeyProperty(currTokType)) {
            tokenIdxToClass[tokenShortNameIdx] = currTokType;
            currTokType.tokenTypeIdx = tokenShortNameIdx++;
        }
        // CATEGORIES? : TokenType | TokenType[]
        if (hasCategoriesProperty(currTokType) &&
            !Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["y" /* isArray */])(currTokType.CATEGORIES)
        // &&
        // !isUndefined(currTokType.CATEGORIES.PATTERN)
        ) {
            currTokType.CATEGORIES = [currTokType.CATEGORIES];
        }
        if (!hasCategoriesProperty(currTokType)) {
            currTokType.CATEGORIES = [];
        }
        if (!hasExtendingTokensTypesProperty(currTokType)) {
            currTokType.categoryMatches = [];
        }
        if (!hasExtendingTokensTypesMapProperty(currTokType)) {
            currTokType.categoryMatchesMap = {};
        }
    });
}
function assignCategoriesTokensProp(tokenTypes) {
    Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(tokenTypes, function (currTokType) {
        // avoid duplications
        currTokType.categoryMatches = [];
        Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(currTokType.categoryMatchesMap, function (val, key) {
            currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);
        });
    });
}
function assignCategoriesMapProp(tokenTypes) {
    Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(tokenTypes, function (currTokType) {
        singleAssignCategoriesToksMap([], currTokType);
    });
}
function singleAssignCategoriesToksMap(path, nextNode) {
    Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(path, function (pathNode) {
        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;
    });
    Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(nextNode.CATEGORIES, function (nextCategory) {
        var newPath = path.concat(nextNode);
        // avoids infinite loops due to cyclic categories.
        if (!Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["j" /* contains */])(newPath, nextCategory)) {
            singleAssignCategoriesToksMap(newPath, nextCategory);
        }
    });
}
function hasShortKeyProperty(tokType) {
    return Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(tokType, "tokenTypeIdx");
}
function hasCategoriesProperty(tokType) {
    return Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(tokType, "CATEGORIES");
}
function hasExtendingTokensTypesProperty(tokType) {
    return Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(tokType, "categoryMatches");
}
function hasExtendingTokensTypesMapProperty(tokType) {
    return Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(tokType, "categoryMatchesMap");
}
function isTokenType(tokType) {
    return Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(tokType, "tokenTypeIdx");
}
//# sourceMappingURL=tokens.js.map

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["f"] = isSequenceProd;
/* harmony export (immutable) */ __webpack_exports__["e"] = isOptionalProd;
/* harmony export (immutable) */ __webpack_exports__["d"] = isBranchingProd;
/* harmony export (immutable) */ __webpack_exports__["c"] = getProductionDslName;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DslMethodsCollectorVisitor; });
/* harmony export (immutable) */ __webpack_exports__["b"] = collectMethods;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__gast_public__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__gast_visitor_public__ = __webpack_require__(20);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



function isSequenceProd(prod) {
    return (prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_public__["c" /* Flat */] ||
        prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_public__["e" /* Option */] ||
        prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_public__["f" /* Repetition */] ||
        prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_public__["g" /* RepetitionMandatory */] ||
        prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_public__["h" /* RepetitionMandatoryWithSeparator */] ||
        prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_public__["i" /* RepetitionWithSeparator */] ||
        prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_public__["k" /* Terminal */] ||
        prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_public__["j" /* Rule */]);
}
function isOptionalProd(prod, alreadyVisited) {
    if (alreadyVisited === void 0) { alreadyVisited = []; }
    var isDirectlyOptional = prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_public__["e" /* Option */] ||
        prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_public__["f" /* Repetition */] ||
        prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_public__["i" /* RepetitionWithSeparator */];
    if (isDirectlyOptional) {
        return true;
    }
    // note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another
    // empty optional top rule
    // may be indirectly optional ((A?B?C?) | (D?E?F?))
    if (prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_public__["b" /* Alternation */]) {
        // for OR its enough for just one of the alternatives to be optional
        return Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["Q" /* some */])(prod.definition, function (subProd) {
            return isOptionalProd(subProd, alreadyVisited);
        });
    }
    else if (prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_public__["d" /* NonTerminal */] && Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["j" /* contains */])(alreadyVisited, prod)) {
        // avoiding stack overflow due to infinite recursion
        return false;
    }
    else if (prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_public__["a" /* AbstractProduction */]) {
        if (prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_public__["d" /* NonTerminal */]) {
            alreadyVisited.push(prod);
        }
        return Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["o" /* every */])(prod.definition, function (subProd) {
            return isOptionalProd(subProd, alreadyVisited);
        });
    }
    else {
        return false;
    }
}
function isBranchingProd(prod) {
    return prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_public__["b" /* Alternation */];
}
function getProductionDslName(prod) {
    /* istanbul ignore else */
    if (prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_public__["d" /* NonTerminal */]) {
        return "SUBRULE";
    }
    else if (prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_public__["e" /* Option */]) {
        return "OPTION";
    }
    else if (prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_public__["b" /* Alternation */]) {
        return "OR";
    }
    else if (prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_public__["g" /* RepetitionMandatory */]) {
        return "AT_LEAST_ONE";
    }
    else if (prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_public__["h" /* RepetitionMandatoryWithSeparator */]) {
        return "AT_LEAST_ONE_SEP";
    }
    else if (prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_public__["i" /* RepetitionWithSeparator */]) {
        return "MANY_SEP";
    }
    else if (prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_public__["f" /* Repetition */]) {
        return "MANY";
    }
    else if (prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_public__["k" /* Terminal */]) {
        return "CONSUME";
    }
    else {
        throw Error("non exhaustive match");
    }
}
var DslMethodsCollectorVisitor = /** @class */ (function (_super) {
    __extends(DslMethodsCollectorVisitor, _super);
    function DslMethodsCollectorVisitor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // A minus is never valid in an identifier name
        _this.separator = "-";
        _this.dslMethods = {
            option: [],
            alternation: [],
            repetition: [],
            repetitionWithSeparator: [],
            repetitionMandatory: [],
            repetitionMandatoryWithSeparator: []
        };
        return _this;
    }
    DslMethodsCollectorVisitor.prototype.reset = function () {
        this.dslMethods = {
            option: [],
            alternation: [],
            repetition: [],
            repetitionWithSeparator: [],
            repetitionMandatory: [],
            repetitionMandatoryWithSeparator: []
        };
    };
    DslMethodsCollectorVisitor.prototype.visitTerminal = function (terminal) {
        var key = terminal.terminalType.name + this.separator + "Terminal";
        if (!Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(this.dslMethods, key)) {
            this.dslMethods[key] = [];
        }
        this.dslMethods[key].push(terminal);
    };
    DslMethodsCollectorVisitor.prototype.visitNonTerminal = function (subrule) {
        var key = subrule.nonTerminalName + this.separator + "Terminal";
        if (!Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(this.dslMethods, key)) {
            this.dslMethods[key] = [];
        }
        this.dslMethods[key].push(subrule);
    };
    DslMethodsCollectorVisitor.prototype.visitOption = function (option) {
        this.dslMethods.option.push(option);
    };
    DslMethodsCollectorVisitor.prototype.visitRepetitionWithSeparator = function (manySep) {
        this.dslMethods.repetitionWithSeparator.push(manySep);
    };
    DslMethodsCollectorVisitor.prototype.visitRepetitionMandatory = function (atLeastOne) {
        this.dslMethods.repetitionMandatory.push(atLeastOne);
    };
    DslMethodsCollectorVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {
        this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);
    };
    DslMethodsCollectorVisitor.prototype.visitRepetition = function (many) {
        this.dslMethods.repetition.push(many);
    };
    DslMethodsCollectorVisitor.prototype.visitAlternation = function (or) {
        this.dslMethods.alternation.push(or);
    };
    return DslMethodsCollectorVisitor;
}(__WEBPACK_IMPORTED_MODULE_2__gast_visitor_public__["a" /* GAstVisitor */]));

var collectorVisitor = new DslMethodsCollectorVisitor();
function collectMethods(rule) {
    collectorVisitor.reset();
    rule.accept(collectorVisitor);
    var dslMethods = collectorVisitor.dslMethods;
    // avoid uncleaned references
    collectorVisitor.reset();
    return dslMethods;
}
//# sourceMappingURL=gast.js.map

/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return BITS_FOR_METHOD_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return BITS_FOR_OCCURRENCE_IDX; });
/* unused harmony export BITS_FOR_RULE_IDX */
/* unused harmony export BITS_FOR_ALT_IDX */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return OR_IDX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return OPTION_IDX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return MANY_IDX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AT_LEAST_ONE_IDX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return MANY_SEP_IDX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return AT_LEAST_ONE_SEP_IDX; });
/* harmony export (immutable) */ __webpack_exports__["j"] = getKeyForAutomaticLookahead;
/* harmony export (immutable) */ __webpack_exports__["i"] = getKeyForAltIndex;
// Lookahead keys are 32Bit integers in the form
// TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX
// XXXX -> Occurrence Index bitmap.
// YYYY -> DSL Method Type bitmap.
// ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.
// TTTTTTTTT -> alternation alternative index bitmap
var BITS_FOR_METHOD_TYPE = 4;
var BITS_FOR_OCCURRENCE_IDX = 8;
var BITS_FOR_RULE_IDX = 12;
// TODO: validation, this means that there may at most 2^8 --> 256 alternatives for an alternation.
var BITS_FOR_ALT_IDX = 8;
// short string used as part of mapping keys.
// being short improves the performance when composing KEYS for maps out of these
// The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)
/* tslint:disable */
var OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX;
var OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX;
var MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX;
var AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX;
var MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX;
var AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX;
/* tslint:enable */
// this actually returns a number, but it is always used as a string (object prop key)
function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {
    /* tslint:disable */
    return occurrence | dslMethodIdx | ruleIdx;
    /* tslint:enable */
}
var BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX;
function getKeyForAltIndex(ruleIdx, dslMethodIdx, occurrence, altIdx) {
    /* tslint:disable */
    // alternative indices are zero based, thus must always add one (turn on one bit) to guarantee uniqueness.
    var altIdxBitMap = (altIdx + 1) << BITS_START_FOR_ALT_IDX;
    return (getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) |
        altIdxBitMap);
    /* tslint:enable */
}
//# sourceMappingURL=keys.js.map

/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["e"] = isRecognitionException;
/* harmony export (immutable) */ __webpack_exports__["b"] = MismatchedTokenException;
/* harmony export (immutable) */ __webpack_exports__["c"] = NoViableAltException;
/* harmony export (immutable) */ __webpack_exports__["d"] = NotAllInputParsedException;
/* harmony export (immutable) */ __webpack_exports__["a"] = EarlyExitException;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);

var MISMATCHED_TOKEN_EXCEPTION = "MismatchedTokenException";
var NO_VIABLE_ALT_EXCEPTION = "NoViableAltException";
var EARLY_EXIT_EXCEPTION = "EarlyExitException";
var NOT_ALL_INPUT_PARSED_EXCEPTION = "NotAllInputParsedException";
var RECOGNITION_EXCEPTION_NAMES = [
    MISMATCHED_TOKEN_EXCEPTION,
    NO_VIABLE_ALT_EXCEPTION,
    EARLY_EXIT_EXCEPTION,
    NOT_ALL_INPUT_PARSED_EXCEPTION
];
Object.freeze(RECOGNITION_EXCEPTION_NAMES);
// hacks to bypass no support for custom Errors in javascript/typescript
function isRecognitionException(error) {
    // can't do instanceof on hacked custom js exceptions
    return Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["j" /* contains */])(RECOGNITION_EXCEPTION_NAMES, error.name);
}
function MismatchedTokenException(message, token, previousToken) {
    this.name = MISMATCHED_TOKEN_EXCEPTION;
    this.message = message;
    this.token = token;
    this.previousToken = previousToken;
    this.resyncedTokens = [];
}
// must use the "Error.prototype" instead of "new Error"
// because the stack trace points to where "new Error" was invoked"
MismatchedTokenException.prototype = Error.prototype;
function NoViableAltException(message, token, previousToken) {
    this.name = NO_VIABLE_ALT_EXCEPTION;
    this.message = message;
    this.token = token;
    this.previousToken = previousToken;
    this.resyncedTokens = [];
}
NoViableAltException.prototype = Error.prototype;
function NotAllInputParsedException(message, token) {
    this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;
    this.message = message;
    this.token = token;
    this.resyncedTokens = [];
}
NotAllInputParsedException.prototype = Error.prototype;
function EarlyExitException(message, token, previousToken) {
    this.name = EARLY_EXIT_EXCEPTION;
    this.message = message;
    this.token = token;
    this.previousToken = previousToken;
    this.resyncedTokens = [];
}
EarlyExitException.prototype = Error.prototype;
//# sourceMappingURL=exceptions_public.js.map

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var DAYS = exports.DAYS = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];

var MONTHS = exports.MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

var QUARTERS = exports.QUARTERS = ["Q1", "Q2", "Q3", "Q4"];

var HOURS = exports.HOURS = ["12AM", "1AM", "2AM", "3AM", "4AM", "5AM", "6AM", "7AM", "8AM", "9AM", "10AM", "11AM", "12PM", "1PM", "2PM", "3PM", "4PM", "5PM", "6PM", "7PM", "8PM", "9PM", "10PM", "11PM"];

var MS_IN_SECONDS = exports.MS_IN_SECONDS = 0.001;
var SECOND = exports.SECOND = 1;
var MIN_IN_SECONDS = exports.MIN_IN_SECONDS = 60;
var HOUR_IN_SECONDS = exports.HOUR_IN_SECONDS = 60 * MIN_IN_SECONDS;
var DAY_IN_SECONDS = exports.DAY_IN_SECONDS = 24 * HOUR_IN_SECONDS;
var WEEK_IN_SECONDS = exports.WEEK_IN_SECONDS = 7 * DAY_IN_SECONDS;
var MONTH_IN_SECONDS = exports.MONTH_IN_SECONDS = 30 * DAY_IN_SECONDS;
var QUARTER_IN_SECONDS = exports.QUARTER_IN_SECONDS = 3 * MONTH_IN_SECONDS;
var YEAR_IN_SECONDS = exports.YEAR_IN_SECONDS = 365 * DAY_IN_SECONDS;
var DECADE_IN_SECONDS = exports.DECADE_IN_SECONDS = 10 * YEAR_IN_SECONDS;
var CENTURY_IN_SECONDS = exports.CENTURY_IN_SECONDS = 10 * DECADE_IN_SECONDS;

var TIME_LABELS = exports.TIME_LABELS = ["millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year", "decade"];

var TIME_LABEL_TO_SECONDS = exports.TIME_LABEL_TO_SECONDS = {
  century: CENTURY_IN_SECONDS,
  decade: DECADE_IN_SECONDS,
  year: YEAR_IN_SECONDS,
  quarter: QUARTER_IN_SECONDS,
  month: MONTH_IN_SECONDS,
  week: WEEK_IN_SECONDS,
  day: DAY_IN_SECONDS,
  hour: HOUR_IN_SECONDS,
  minute: MIN_IN_SECONDS,
  second: SECOND,
  millisecond: MS_IN_SECONDS
};

/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__formatDecimal__ = __webpack_require__(43);


/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return x = Object(__WEBPACK_IMPORTED_MODULE_0__formatDecimal__["a" /* default */])(Math.abs(x)), x ? x[1] : NaN;
});


/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return LexerDefinitionErrorType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Lexer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lexer__ = __webpack_require__(215);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__tokens__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__scan_lexer_errors_public__ = __webpack_require__(216);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__reg_exp_parser__ = __webpack_require__(46);





var LexerDefinitionErrorType;
(function (LexerDefinitionErrorType) {
    LexerDefinitionErrorType[LexerDefinitionErrorType["MISSING_PATTERN"] = 0] = "MISSING_PATTERN";
    LexerDefinitionErrorType[LexerDefinitionErrorType["INVALID_PATTERN"] = 1] = "INVALID_PATTERN";
    LexerDefinitionErrorType[LexerDefinitionErrorType["EOI_ANCHOR_FOUND"] = 2] = "EOI_ANCHOR_FOUND";
    LexerDefinitionErrorType[LexerDefinitionErrorType["UNSUPPORTED_FLAGS_FOUND"] = 3] = "UNSUPPORTED_FLAGS_FOUND";
    LexerDefinitionErrorType[LexerDefinitionErrorType["DUPLICATE_PATTERNS_FOUND"] = 4] = "DUPLICATE_PATTERNS_FOUND";
    LexerDefinitionErrorType[LexerDefinitionErrorType["INVALID_GROUP_TYPE_FOUND"] = 5] = "INVALID_GROUP_TYPE_FOUND";
    LexerDefinitionErrorType[LexerDefinitionErrorType["PUSH_MODE_DOES_NOT_EXIST"] = 6] = "PUSH_MODE_DOES_NOT_EXIST";
    LexerDefinitionErrorType[LexerDefinitionErrorType["MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE"] = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE";
    LexerDefinitionErrorType[LexerDefinitionErrorType["MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY"] = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY";
    LexerDefinitionErrorType[LexerDefinitionErrorType["MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST"] = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST";
    LexerDefinitionErrorType[LexerDefinitionErrorType["LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED"] = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED";
    LexerDefinitionErrorType[LexerDefinitionErrorType["SOI_ANCHOR_FOUND"] = 11] = "SOI_ANCHOR_FOUND";
    LexerDefinitionErrorType[LexerDefinitionErrorType["EMPTY_MATCH_PATTERN"] = 12] = "EMPTY_MATCH_PATTERN";
    LexerDefinitionErrorType[LexerDefinitionErrorType["NO_LINE_BREAKS_FLAGS"] = 13] = "NO_LINE_BREAKS_FLAGS";
    LexerDefinitionErrorType[LexerDefinitionErrorType["UNREACHABLE_PATTERN"] = 14] = "UNREACHABLE_PATTERN";
    LexerDefinitionErrorType[LexerDefinitionErrorType["IDENTIFY_TERMINATOR"] = 15] = "IDENTIFY_TERMINATOR";
    LexerDefinitionErrorType[LexerDefinitionErrorType["CUSTOM_LINE_BREAK"] = 16] = "CUSTOM_LINE_BREAK";
})(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));
var DEFAULT_LEXER_CONFIG = {
    deferDefinitionErrorsHandling: false,
    positionTracking: "full",
    lineTerminatorsPattern: /\n|\r\n?/g,
    lineTerminatorCharacters: ["\n", "\r"],
    ensureOptimizations: false,
    safeMode: false,
    errorMessageProvider: __WEBPACK_IMPORTED_MODULE_3__scan_lexer_errors_public__["a" /* defaultLexerErrorProvider */],
    traceInitPerf: false,
    skipValidations: false
};
Object.freeze(DEFAULT_LEXER_CONFIG);
var Lexer = /** @class */ (function () {
    function Lexer(lexerDefinition, config) {
        var _this = this;
        if (config === void 0) { config = DEFAULT_LEXER_CONFIG; }
        this.lexerDefinition = lexerDefinition;
        this.lexerDefinitionErrors = [];
        this.lexerDefinitionWarning = [];
        this.patternIdxToConfig = {};
        this.charCodeToPatternIdxToConfig = {};
        this.modes = [];
        this.emptyGroups = {};
        this.config = undefined;
        this.trackStartLines = true;
        this.trackEndLines = true;
        this.hasCustom = false;
        this.canModeBeOptimized = {};
        if (typeof config === "boolean") {
            throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\n" +
                "a boolean 2nd argument is no longer supported");
        }
        // todo: defaults func?
        this.config = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["K" /* merge */])(DEFAULT_LEXER_CONFIG, config);
        var traceInitVal = this.config.traceInitPerf;
        if (traceInitVal === true) {
            this.traceInitMaxIdent = Infinity;
            this.traceInitPerf = true;
        }
        else if (typeof traceInitVal === "number") {
            this.traceInitMaxIdent = traceInitVal;
            this.traceInitPerf = true;
        }
        this.traceInitIndent = -1;
        this.TRACE_INIT("Lexer Constructor", function () {
            var actualDefinition;
            var hasOnlySingleMode = true;
            _this.TRACE_INIT("Lexer Config handling", function () {
                if (_this.config.lineTerminatorsPattern ===
                    DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {
                    // optimized built-in implementation for the defaults definition of lineTerminators
                    _this.config.lineTerminatorsPattern = __WEBPACK_IMPORTED_MODULE_0__lexer__["b" /* LineTerminatorOptimizedTester */];
                }
                else {
                    if (_this.config.lineTerminatorCharacters ===
                        DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {
                        throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n" +
                            "\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS");
                    }
                }
                if (config.safeMode && config.ensureOptimizations) {
                    throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
                }
                _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);
                _this.trackEndLines = /full/i.test(_this.config.positionTracking);
                // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.
                if (Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["y" /* isArray */])(lexerDefinition)) {
                    actualDefinition = { modes: {} };
                    actualDefinition.modes[__WEBPACK_IMPORTED_MODULE_0__lexer__["a" /* DEFAULT_MODE */]] = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["g" /* cloneArr */])(lexerDefinition);
                    actualDefinition[__WEBPACK_IMPORTED_MODULE_0__lexer__["a" /* DEFAULT_MODE */]] = __WEBPACK_IMPORTED_MODULE_0__lexer__["a" /* DEFAULT_MODE */];
                }
                else {
                    // no conversion needed, input should already be a IMultiModeLexerDefinition
                    hasOnlySingleMode = false;
                    actualDefinition = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["h" /* cloneObj */])((lexerDefinition));
                }
            });
            if (_this.config.skipValidations === false) {
                _this.TRACE_INIT("performRuntimeChecks", function () {
                    _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat(Object(__WEBPACK_IMPORTED_MODULE_0__lexer__["h" /* performRuntimeChecks */])(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
                });
                _this.TRACE_INIT("performWarningRuntimeChecks", function () {
                    _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat(Object(__WEBPACK_IMPORTED_MODULE_0__lexer__["i" /* performWarningRuntimeChecks */])(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
                });
            }
            // for extra robustness to avoid throwing an none informative error message
            actualDefinition.modes = actualDefinition.modes
                ? actualDefinition.modes
                : {};
            // an error of undefined TokenTypes will be detected in "performRuntimeChecks" above.
            // this transformation is to increase robustness in the case of partially invalid lexer definition.
            Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["u" /* forEach */])(actualDefinition.modes, function (currModeValue, currModeName) {
                actualDefinition.modes[currModeName] = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["P" /* reject */])(currModeValue, function (currTokType) { return Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["F" /* isUndefined */])(currTokType); });
            });
            var allModeNames = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["G" /* keys */])(actualDefinition.modes);
            Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["u" /* forEach */])(actualDefinition.modes, function (currModDef, currModName) {
                _this.TRACE_INIT("Mode: <" + currModName + "> processing", function () {
                    _this.modes.push(currModName);
                    if (_this.config.skipValidations === false) {
                        _this.TRACE_INIT("validatePatterns", function () {
                            _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat(Object(__WEBPACK_IMPORTED_MODULE_0__lexer__["j" /* validatePatterns */])(currModDef, allModeNames));
                        });
                    }
                    // If definition errors were encountered, the analysis phase may fail unexpectedly/
                    // Considering a lexer with definition errors may never be used, there is no point
                    // to performing the analysis anyhow...
                    if (Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["A" /* isEmpty */])(_this.lexerDefinitionErrors)) {
                        Object(__WEBPACK_IMPORTED_MODULE_2__tokens__["a" /* augmentTokenTypes */])(currModDef);
                        var currAnalyzeResult_1;
                        _this.TRACE_INIT("analyzeTokenTypes", function () {
                            currAnalyzeResult_1 = Object(__WEBPACK_IMPORTED_MODULE_0__lexer__["d" /* analyzeTokenTypes */])(currModDef, {
                                lineTerminatorCharacters: _this.config
                                    .lineTerminatorCharacters,
                                positionTracking: config.positionTracking,
                                ensureOptimizations: config.ensureOptimizations,
                                safeMode: config.safeMode,
                                tracer: _this.TRACE_INIT.bind(_this)
                            });
                        });
                        _this.patternIdxToConfig[currModName] =
                            currAnalyzeResult_1.patternIdxToConfig;
                        _this.charCodeToPatternIdxToConfig[currModName] =
                            currAnalyzeResult_1.charCodeToPatternIdxToConfig;
                        _this.emptyGroups = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["K" /* merge */])(_this.emptyGroups, currAnalyzeResult_1.emptyGroups);
                        _this.hasCustom =
                            currAnalyzeResult_1.hasCustom || _this.hasCustom;
                        _this.canModeBeOptimized[currModName] =
                            currAnalyzeResult_1.canBeOptimized;
                    }
                });
            });
            _this.defaultMode = actualDefinition.defaultMode;
            if (!Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["A" /* isEmpty */])(_this.lexerDefinitionErrors) &&
                !_this.config.deferDefinitionErrorsHandling) {
                var allErrMessages = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["I" /* map */])(_this.lexerDefinitionErrors, function (error) {
                    return error.message;
                });
                var allErrMessagesString = allErrMessages.join("-----------------------\n");
                throw new Error("Errors detected in definition of Lexer:\n" +
                    allErrMessagesString);
            }
            // Only print warning if there are no errors, This will avoid pl
            Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["u" /* forEach */])(_this.lexerDefinitionWarning, function (warningDescriptor) {
                Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["d" /* PRINT_WARNING */])(warningDescriptor.message);
            });
            _this.TRACE_INIT("Choosing sub-methods implementations", function () {
                // Choose the relevant internal implementations for this specific parser.
                // These implementations should be in-lined by the JavaScript engine
                // to provide optimal performance in each scenario.
                if (__WEBPACK_IMPORTED_MODULE_0__lexer__["c" /* SUPPORT_STICKY */]) {
                    _this.chopInput = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["a" /* IDENTITY */];
                    _this.match = _this.matchWithTest;
                }
                else {
                    _this.updateLastIndex = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["b" /* NOOP */];
                    _this.match = _this.matchWithExec;
                }
                if (hasOnlySingleMode) {
                    _this.handleModes = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["b" /* NOOP */];
                }
                if (_this.trackStartLines === false) {
                    _this.computeNewColumn = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["a" /* IDENTITY */];
                }
                if (_this.trackEndLines === false) {
                    _this.updateTokenEndLineColumnLocation = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["b" /* NOOP */];
                }
                if (/full/i.test(_this.config.positionTracking)) {
                    _this.createTokenInstance = _this.createFullToken;
                }
                else if (/onlyStart/i.test(_this.config.positionTracking)) {
                    _this.createTokenInstance = _this.createStartOnlyToken;
                }
                else if (/onlyOffset/i.test(_this.config.positionTracking)) {
                    _this.createTokenInstance = _this.createOffsetOnlyToken;
                }
                else {
                    throw Error("Invalid <positionTracking> config option: \"" + _this.config.positionTracking + "\"");
                }
                if (_this.hasCustom) {
                    _this.addToken = _this.addTokenUsingPush;
                    _this.handlePayload = _this.handlePayloadWithCustom;
                }
                else {
                    _this.addToken = _this.addTokenUsingMemberAccess;
                    _this.handlePayload = _this.handlePayloadNoCustom;
                }
            });
            _this.TRACE_INIT("Failed Optimization Warnings", function () {
                var unOptimizedModes = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["O" /* reduce */])(_this.canModeBeOptimized, function (cannotBeOptimized, canBeOptimized, modeName) {
                    if (canBeOptimized === false) {
                        cannotBeOptimized.push(modeName);
                    }
                    return cannotBeOptimized;
                }, []);
                if (config.ensureOptimizations && !Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["A" /* isEmpty */])(unOptimizedModes)) {
                    throw Error("Lexer Modes: < " + unOptimizedModes.join(", ") + " > cannot be optimized.\n" +
                        '\t Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n' +
                        "\t Or inspect the console log for details on how to resolve these issues.");
                }
            });
            _this.TRACE_INIT("clearRegExpParserCache", function () {
                Object(__WEBPACK_IMPORTED_MODULE_4__reg_exp_parser__["a" /* clearRegExpParserCache */])();
            });
            _this.TRACE_INIT("toFastProperties", function () {
                Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["S" /* toFastProperties */])(_this);
            });
        });
    }
    Lexer.prototype.tokenize = function (text, initialMode) {
        if (initialMode === void 0) { initialMode = this.defaultMode; }
        if (!Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["A" /* isEmpty */])(this.lexerDefinitionErrors)) {
            var allErrMessages = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["I" /* map */])(this.lexerDefinitionErrors, function (error) {
                return error.message;
            });
            var allErrMessagesString = allErrMessages.join("-----------------------\n");
            throw new Error("Unable to Tokenize because Errors detected in definition of Lexer:\n" +
                allErrMessagesString);
        }
        var lexResult = this.tokenizeInternal(text, initialMode);
        return lexResult;
    };
    // There is quite a bit of duplication between this and "tokenizeInternalLazy"
    // This is intentional due to performance considerations.
    Lexer.prototype.tokenizeInternal = function (text, initialMode) {
        var _this = this;
        var i, j, matchAltImage, longerAltIdx, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;
        var orgText = text;
        var orgLength = orgText.length;
        var offset = 0;
        var matchedTokensIndex = 0;
        // initializing the tokensArray to the "guessed" size.
        // guessing too little will still reduce the number of array re-sizes on pushes.
        // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory
        // but would still have a faster runtime by avoiding (All but one) array resizing.
        var guessedNumberOfTokens = this.hasCustom
            ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.
            : Math.floor(text.length / 10);
        var matchedTokens = new Array(guessedNumberOfTokens);
        var errors = [];
        var line = this.trackStartLines ? 1 : undefined;
        var column = this.trackStartLines ? 1 : undefined;
        var groups = Object(__WEBPACK_IMPORTED_MODULE_0__lexer__["f" /* cloneEmptyGroups */])(this.emptyGroups);
        var trackLines = this.trackStartLines;
        var lineTerminatorPattern = this.config.lineTerminatorsPattern;
        var currModePatternsLength = 0;
        var patternIdxToConfig = [];
        var currCharCodeToPatternIdxToConfig = [];
        var modeStack = [];
        var emptyArray = [];
        Object.freeze(emptyArray);
        var getPossiblePatterns = undefined;
        function getPossiblePatternsSlow() {
            return patternIdxToConfig;
        }
        function getPossiblePatternsOptimized(charCode) {
            var optimizedCharIdx = Object(__WEBPACK_IMPORTED_MODULE_0__lexer__["e" /* charCodeToOptimizedIndex */])(charCode);
            var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];
            if (possiblePatterns === undefined) {
                return emptyArray;
            }
            else {
                return possiblePatterns;
            }
        }
        var pop_mode = function (popToken) {
            // TODO: perhaps avoid this error in the edge case there is no more input?
            if (modeStack.length === 1 &&
                // if we have both a POP_MODE and a PUSH_MODE this is in-fact a "transition"
                // So no error should occur.
                popToken.tokenType.PUSH_MODE === undefined) {
                // if we try to pop the last mode there lexer will no longer have ANY mode.
                // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.
                var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);
                errors.push({
                    offset: popToken.startOffset,
                    line: popToken.startLine !== undefined
                        ? popToken.startLine
                        : undefined,
                    column: popToken.startColumn !== undefined
                        ? popToken.startColumn
                        : undefined,
                    length: popToken.image.length,
                    message: msg_1
                });
            }
            else {
                modeStack.pop();
                var newMode = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["H" /* last */])(modeStack);
                patternIdxToConfig = _this.patternIdxToConfig[newMode];
                currCharCodeToPatternIdxToConfig = _this
                    .charCodeToPatternIdxToConfig[newMode];
                currModePatternsLength = patternIdxToConfig.length;
                var modeCanBeOptimized = _this.canModeBeOptimized[newMode] &&
                    _this.config.safeMode === false;
                if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
                    getPossiblePatterns = getPossiblePatternsOptimized;
                }
                else {
                    getPossiblePatterns = getPossiblePatternsSlow;
                }
            }
        };
        function push_mode(newMode) {
            modeStack.push(newMode);
            currCharCodeToPatternIdxToConfig = this
                .charCodeToPatternIdxToConfig[newMode];
            patternIdxToConfig = this.patternIdxToConfig[newMode];
            currModePatternsLength = patternIdxToConfig.length;
            currModePatternsLength = patternIdxToConfig.length;
            var modeCanBeOptimized = this.canModeBeOptimized[newMode] &&
                this.config.safeMode === false;
            if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
                getPossiblePatterns = getPossiblePatternsOptimized;
            }
            else {
                getPossiblePatterns = getPossiblePatternsSlow;
            }
        }
        // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not
        // seem to matter performance wise.
        push_mode.call(this, initialMode);
        var currConfig;
        while (offset < orgLength) {
            matchedImage = null;
            var nextCharCode = orgText.charCodeAt(offset);
            var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);
            var chosenPatternsLength = chosenPatternIdxToConfig.length;
            for (i = 0; i < chosenPatternsLength; i++) {
                currConfig = chosenPatternIdxToConfig[i];
                var currPattern = currConfig.pattern;
                payload = null;
                // manually in-lined because > 600 chars won't be in-lined in V8
                var singleCharCode = currConfig.short;
                if (singleCharCode !== false) {
                    if (nextCharCode === singleCharCode) {
                        // single character string
                        matchedImage = currPattern;
                    }
                }
                else if (currConfig.isCustom === true) {
                    match = currPattern.exec(orgText, offset, matchedTokens, groups);
                    if (match !== null) {
                        matchedImage = match[0];
                        if (match.payload !== undefined) {
                            payload = match.payload;
                        }
                    }
                    else {
                        matchedImage = null;
                    }
                }
                else {
                    this.updateLastIndex(currPattern, offset);
                    matchedImage = this.match(currPattern, text, offset);
                }
                if (matchedImage !== null) {
                    // even though this pattern matched we must try a another longer alternative.
                    // this can be used to prioritize keywords over identifiers
                    longerAltIdx = currConfig.longerAlt;
                    if (longerAltIdx !== undefined) {
                        // TODO: micro optimize, avoid extra prop access
                        // by saving/linking longerAlt on the original config?
                        var longerAltConfig = patternIdxToConfig[longerAltIdx];
                        var longerAltPattern = longerAltConfig.pattern;
                        altPayload = null;
                        // single Char can never be a longer alt so no need to test it.
                        // manually in-lined because > 600 chars won't be in-lined in V8
                        if (longerAltConfig.isCustom === true) {
                            match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);
                            if (match !== null) {
                                matchAltImage = match[0];
                                if (match.payload !== undefined) {
                                    altPayload = match.payload;
                                }
                            }
                            else {
                                matchAltImage = null;
                            }
                        }
                        else {
                            this.updateLastIndex(longerAltPattern, offset);
                            matchAltImage = this.match(longerAltPattern, text, offset);
                        }
                        if (matchAltImage &&
                            matchAltImage.length > matchedImage.length) {
                            matchedImage = matchAltImage;
                            payload = altPayload;
                            currConfig = longerAltConfig;
                        }
                    }
                    break;
                }
            }
            // successful match
            if (matchedImage !== null) {
                imageLength = matchedImage.length;
                group = currConfig.group;
                if (group !== undefined) {
                    tokType = currConfig.tokenTypeIdx;
                    // TODO: "offset + imageLength" and the new column may be computed twice in case of "full" location information inside
                    // createFullToken method
                    newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);
                    this.handlePayload(newToken, payload);
                    // TODO: optimize NOOP in case there are no special groups?
                    if (group === false) {
                        matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);
                    }
                    else {
                        groups[group].push(newToken);
                    }
                }
                text = this.chopInput(text, imageLength);
                offset = offset + imageLength;
                // TODO: with newlines the column may be assigned twice
                column = this.computeNewColumn(column, imageLength);
                if (trackLines === true &&
                    currConfig.canLineTerminator === true) {
                    var numOfLTsInMatch = 0;
                    var foundTerminator = void 0;
                    var lastLTEndOffset = void 0;
                    lineTerminatorPattern.lastIndex = 0;
                    do {
                        foundTerminator = lineTerminatorPattern.test(matchedImage);
                        if (foundTerminator === true) {
                            lastLTEndOffset =
                                lineTerminatorPattern.lastIndex - 1;
                            numOfLTsInMatch++;
                        }
                    } while (foundTerminator === true);
                    if (numOfLTsInMatch !== 0) {
                        line = line + numOfLTsInMatch;
                        column = imageLength - lastLTEndOffset;
                        this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);
                    }
                }
                // will be NOOP if no modes present
                this.handleModes(currConfig, pop_mode, push_mode, newToken);
            }
            else {
                // error recovery, drop characters until we identify a valid token's start point
                var errorStartOffset = offset;
                var errorLine = line;
                var errorColumn = column;
                var foundResyncPoint = false;
                while (!foundResyncPoint && offset < orgLength) {
                    // drop chars until we succeed in matching something
                    droppedChar = orgText.charCodeAt(offset);
                    // Identity Func (when sticky flag is enabled)
                    text = this.chopInput(text, 1);
                    offset++;
                    for (j = 0; j < currModePatternsLength; j++) {
                        var currConfig_1 = patternIdxToConfig[j];
                        var currPattern = currConfig_1.pattern;
                        // manually in-lined because > 600 chars won't be in-lined in V8
                        var singleCharCode = currConfig_1.short;
                        if (singleCharCode !== false) {
                            if (orgText.charCodeAt(offset) === singleCharCode) {
                                // single character string
                                foundResyncPoint = true;
                            }
                        }
                        else if (currConfig_1.isCustom === true) {
                            foundResyncPoint =
                                currPattern.exec(orgText, offset, matchedTokens, groups) !== null;
                        }
                        else {
                            this.updateLastIndex(currPattern, offset);
                            foundResyncPoint = currPattern.exec(text) !== null;
                        }
                        if (foundResyncPoint === true) {
                            break;
                        }
                    }
                }
                errLength = offset - errorStartOffset;
                // at this point we either re-synced or reached the end of the input text
                msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);
                errors.push({
                    offset: errorStartOffset,
                    line: errorLine,
                    column: errorColumn,
                    length: errLength,
                    message: msg
                });
            }
        }
        // if we do have custom patterns which push directly into the
        // TODO: custom tokens should not push directly??
        if (!this.hasCustom) {
            // if we guessed a too large size for the tokens array this will shrink it to the right size.
            matchedTokens.length = matchedTokensIndex;
        }
        return {
            tokens: matchedTokens,
            groups: groups,
            errors: errors
        };
    };
    Lexer.prototype.handleModes = function (config, pop_mode, push_mode, newToken) {
        if (config.pop === true) {
            // need to save the PUSH_MODE property as if the mode is popped
            // patternIdxToPopMode is updated to reflect the new mode after popping the stack
            var pushMode = config.push;
            pop_mode(newToken);
            if (pushMode !== undefined) {
                push_mode.call(this, pushMode);
            }
        }
        else if (config.push !== undefined) {
            push_mode.call(this, config.push);
        }
    };
    Lexer.prototype.chopInput = function (text, length) {
        return text.substring(length);
    };
    Lexer.prototype.updateLastIndex = function (regExp, newLastIndex) {
        regExp.lastIndex = newLastIndex;
    };
    // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler
    Lexer.prototype.updateTokenEndLineColumnLocation = function (newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {
        var lastCharIsLT, fixForEndingInLT;
        if (group !== undefined) {
            // a none skipped multi line Token, need to update endLine/endColumn
            lastCharIsLT = lastLTIdx === imageLength - 1;
            fixForEndingInLT = lastCharIsLT ? -1 : 0;
            if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {
                // if a token ends in a LT that last LT only affects the line numbering of following Tokens
                newToken.endLine = line + fixForEndingInLT;
                // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)
                // inclusive to exclusive range.
                newToken.endColumn = column - 1 + -fixForEndingInLT;
            }
            // else single LT in the last character of a token, no need to modify the endLine/EndColumn
        }
    };
    Lexer.prototype.computeNewColumn = function (oldColumn, imageLength) {
        return oldColumn + imageLength;
    };
    // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.
    /* istanbul ignore next - place holder */
    Lexer.prototype.createTokenInstance = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    };
    Lexer.prototype.createOffsetOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType) {
        return {
            image: image,
            startOffset: startOffset,
            tokenTypeIdx: tokenTypeIdx,
            tokenType: tokenType
        };
    };
    Lexer.prototype.createStartOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {
        return {
            image: image,
            startOffset: startOffset,
            startLine: startLine,
            startColumn: startColumn,
            tokenTypeIdx: tokenTypeIdx,
            tokenType: tokenType
        };
    };
    Lexer.prototype.createFullToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {
        return {
            image: image,
            startOffset: startOffset,
            endOffset: startOffset + imageLength - 1,
            startLine: startLine,
            endLine: startLine,
            startColumn: startColumn,
            endColumn: startColumn + imageLength - 1,
            tokenTypeIdx: tokenTypeIdx,
            tokenType: tokenType
        };
    };
    // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.
    /* istanbul ignore next - place holder */
    Lexer.prototype.addToken = function (tokenVector, index, tokenToAdd) {
        return 666;
    };
    Lexer.prototype.addTokenUsingPush = function (tokenVector, index, tokenToAdd) {
        tokenVector.push(tokenToAdd);
        return index;
    };
    Lexer.prototype.addTokenUsingMemberAccess = function (tokenVector, index, tokenToAdd) {
        tokenVector[index] = tokenToAdd;
        index++;
        return index;
    };
    // Place holder, will be replaced by the correct variant according to the hasCustom flag option at runtime.
    /* istanbul ignore next - place holder */
    Lexer.prototype.handlePayload = function (token, payload) { };
    Lexer.prototype.handlePayloadNoCustom = function (token, payload) { };
    Lexer.prototype.handlePayloadWithCustom = function (token, payload) {
        if (payload !== null) {
            token.payload = payload;
        }
    };
    /* istanbul ignore next - place holder to be replaced with chosen alternative at runtime */
    Lexer.prototype.match = function (pattern, text, offset) {
        return null;
    };
    Lexer.prototype.matchWithTest = function (pattern, text, offset) {
        var found = pattern.test(text);
        if (found === true) {
            return text.substring(offset, pattern.lastIndex);
        }
        return null;
    };
    Lexer.prototype.matchWithExec = function (pattern, text) {
        var regExpArray = pattern.exec(text);
        return regExpArray !== null ? regExpArray[0] : regExpArray;
    };
    // Duplicated from the parser's perf trace trait to allow future extraction
    // of the lexer to a separate package.
    Lexer.prototype.TRACE_INIT = function (phaseDesc, phaseImpl) {
        // No need to optimize this using NOOP pattern because
        // It is not called in a hot spot...
        if (this.traceInitPerf === true) {
            this.traceInitIndent++;
            var indent = new Array(this.traceInitIndent + 1).join("\t");
            if (this.traceInitIndent < this.traceInitMaxIdent) {
                console.log(indent + "--> <" + phaseDesc + ">");
            }
            var _a = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["R" /* timer */])(phaseImpl), time = _a.time, value = _a.value;
            /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */
            var traceMethod = time > 10 ? console.warn : console.log;
            if (this.traceInitIndent < this.traceInitMaxIdent) {
                traceMethod(indent + "<-- <" + phaseDesc + "> time: " + time + "ms");
            }
            this.traceInitIndent--;
            return value;
        }
        else {
            return phaseImpl();
        }
    };
    Lexer.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it will" +
        "be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.";
    Lexer.NA = /NOT_APPLICABLE/;
    return Lexer;
}());

//# sourceMappingURL=lexer_public.js.map

/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return defaultParserErrorProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return defaultGrammarResolverErrorProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return defaultGrammarValidatorErrorProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__scan_tokens_public__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__grammar_gast_gast_public__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__grammar_gast_gast__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__grammar_checks__ = __webpack_require__(33);






var defaultParserErrorProvider = {
    buildMismatchTokenMessage: function (_a) {
        var expected = _a.expected, actual = _a.actual, previous = _a.previous, ruleName = _a.ruleName;
        var hasLabel = Object(__WEBPACK_IMPORTED_MODULE_0__scan_tokens_public__["d" /* hasTokenLabel */])(expected);
        var expectedMsg = hasLabel
            ? "--> " + Object(__WEBPACK_IMPORTED_MODULE_0__scan_tokens_public__["e" /* tokenLabel */])(expected) + " <--"
            : "token of type --> " + expected.name + " <--";
        var msg = "Expecting " + expectedMsg + " but found --> '" + actual.image + "' <--";
        return msg;
    },
    buildNotAllInputParsedMessage: function (_a) {
        var firstRedundant = _a.firstRedundant, ruleName = _a.ruleName;
        return ("Redundant input, expecting EOF but found: " + firstRedundant.image);
    },
    buildNoViableAltMessage: function (_a) {
        var expectedPathsPerAlt = _a.expectedPathsPerAlt, actual = _a.actual, previous = _a.previous, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;
        var errPrefix = "Expecting: ";
        // TODO: issue: No Viable Alternative Error may have incomplete details. #502
        var actualText = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["s" /* first */])(actual).image;
        var errSuffix = "\nbut found: '" + actualText + "'";
        if (customUserDescription) {
            return errPrefix + customUserDescription + errSuffix;
        }
        else {
            var allLookAheadPaths = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["O" /* reduce */])(expectedPathsPerAlt, function (result, currAltPaths) { return result.concat(currAltPaths); }, []);
            var nextValidTokenSequences = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["I" /* map */])(allLookAheadPaths, function (currPath) {
                return "[" + Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["I" /* map */])(currPath, function (currTokenType) {
                    return Object(__WEBPACK_IMPORTED_MODULE_0__scan_tokens_public__["e" /* tokenLabel */])(currTokenType);
                }).join(", ") + "]";
            });
            var nextValidSequenceItems = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["I" /* map */])(nextValidTokenSequences, function (itemMsg, idx) { return "  " + (idx + 1) + ". " + itemMsg; });
            var calculatedDescription = "one of these possible Token sequences:\n" + nextValidSequenceItems.join("\n");
            return errPrefix + calculatedDescription + errSuffix;
        }
    },
    buildEarlyExitMessage: function (_a) {
        var expectedIterationPaths = _a.expectedIterationPaths, actual = _a.actual, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;
        var errPrefix = "Expecting: ";
        // TODO: issue: No Viable Alternative Error may have incomplete details. #502
        var actualText = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["s" /* first */])(actual).image;
        var errSuffix = "\nbut found: '" + actualText + "'";
        if (customUserDescription) {
            return errPrefix + customUserDescription + errSuffix;
        }
        else {
            var nextValidTokenSequences = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["I" /* map */])(expectedIterationPaths, function (currPath) {
                return "[" + Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["I" /* map */])(currPath, function (currTokenType) {
                    return Object(__WEBPACK_IMPORTED_MODULE_0__scan_tokens_public__["e" /* tokenLabel */])(currTokenType);
                }).join(",") + "]";
            });
            var calculatedDescription = "expecting at least one iteration which starts with one of these possible Token sequences::\n  " +
                ("<" + nextValidTokenSequences.join(" ,") + ">");
            return errPrefix + calculatedDescription + errSuffix;
        }
    }
};
Object.freeze(defaultParserErrorProvider);
var defaultGrammarResolverErrorProvider = {
    buildRuleNotFoundError: function (topLevelRule, undefinedRule) {
        var msg = "Invalid grammar, reference to a rule which is not defined: ->" +
            undefinedRule.nonTerminalName +
            "<-\n" +
            "inside top level rule: ->" +
            topLevelRule.name +
            "<-";
        return msg;
    }
};
var defaultGrammarValidatorErrorProvider = {
    buildDuplicateFoundError: function (topLevelRule, duplicateProds) {
        function getExtraProductionArgument(prod) {
            if (prod instanceof __WEBPACK_IMPORTED_MODULE_2__grammar_gast_gast_public__["k" /* Terminal */]) {
                return prod.terminalType.name;
            }
            else if (prod instanceof __WEBPACK_IMPORTED_MODULE_2__grammar_gast_gast_public__["d" /* NonTerminal */]) {
                return prod.nonTerminalName;
            }
            else {
                return "";
            }
        }
        var topLevelName = topLevelRule.name;
        var duplicateProd = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["s" /* first */])(duplicateProds);
        var index = duplicateProd.idx;
        var dslName = Object(__WEBPACK_IMPORTED_MODULE_3__grammar_gast_gast__["c" /* getProductionDslName */])(duplicateProd);
        var extraArgument = getExtraProductionArgument(duplicateProd);
        var hasExplicitIndex = index > 0;
        var msg = "->" + dslName + (hasExplicitIndex ? index : "") + "<- " + (extraArgument ? "with argument: ->" + extraArgument + "<-" : "") + "\n                  appears more than once (" + duplicateProds.length + " times) in the top level rule: ->" + topLevelName + "<-.                  \n                  For further details see: https://sap.github.io/chevrotain/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  ";
        // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...
        msg = msg.replace(/[ \t]+/g, " ");
        msg = msg.replace(/\s\s+/g, "\n");
        return msg;
    },
    buildInvalidNestedRuleNameError: function (topLevelRule, nestedProd) {
        var msg = "Invalid nested rule name: ->" + nestedProd.name + "<- inside rule: ->" + topLevelRule.name + "<-\n" +
            ("it must match the pattern: ->" + __WEBPACK_IMPORTED_MODULE_4__grammar_checks__["a" /* validNestedRuleName */].toString() + "<-.\n") +
            "Note that this means a nested rule name must start with the '$'(dollar) sign.";
        return msg;
    },
    buildDuplicateNestedRuleNameError: function (topLevelRule, nestedProd) {
        var duplicateName = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["s" /* first */])(nestedProd).name;
        var errMsg = "Duplicate nested rule name: ->" + duplicateName + "<- inside rule: ->" + topLevelRule.name + "<-\n" +
            "A nested name must be unique in the scope of a top level grammar rule.";
        return errMsg;
    },
    buildNamespaceConflictError: function (rule) {
        var errMsg = "Namespace conflict found in grammar.\n" +
            ("The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <" + rule.name + ">.\n") +
            "To resolve this make sure each Terminal and Non-Terminal names are unique\n" +
            "This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\n" +
            "and Non-Terminal names start with a lower case letter.";
        return errMsg;
    },
    buildAlternationPrefixAmbiguityError: function (options) {
        var pathMsg = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["I" /* map */])(options.prefixPath, function (currTok) {
            return Object(__WEBPACK_IMPORTED_MODULE_0__scan_tokens_public__["e" /* tokenLabel */])(currTok);
        }).join(", ");
        var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
        var errMsg = "Ambiguous alternatives: <" + options.ambiguityIndices.join(" ,") + "> due to common lookahead prefix\n" +
            ("in <OR" + occurrence + "> inside <" + options.topLevelRule.name + "> Rule,\n") +
            ("<" + pathMsg + "> may appears as a prefix path in all these alternatives.\n") +
            "See: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\n" +
            "For Further details.";
        return errMsg;
    },
    buildAlternationAmbiguityError: function (options) {
        var pathMsg = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["I" /* map */])(options.prefixPath, function (currtok) {
            return Object(__WEBPACK_IMPORTED_MODULE_0__scan_tokens_public__["e" /* tokenLabel */])(currtok);
        }).join(", ");
        var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
        var currMessage = "Ambiguous Alternatives Detected: <" + options.ambiguityIndices.join(" ,") + "> in <OR" + occurrence + ">" +
            (" inside <" + options.topLevelRule.name + "> Rule,\n") +
            ("<" + pathMsg + "> may appears as a prefix path in all these alternatives.\n");
        currMessage =
            currMessage +
                "See: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\n" +
                "For Further details.";
        return currMessage;
    },
    buildEmptyRepetitionError: function (options) {
        var dslName = Object(__WEBPACK_IMPORTED_MODULE_3__grammar_gast_gast__["c" /* getProductionDslName */])(options.repetition);
        if (options.repetition.idx !== 0) {
            dslName += options.repetition.idx;
        }
        var errMsg = "The repetition <" + dslName + "> within Rule <" + options.topLevelRule.name + "> can never consume any tokens.\n" +
            "This could lead to an infinite loop.";
        return errMsg;
    },
    buildTokenNameError: function (options) {
        var tokTypeName = options.tokenType.name;
        var errMsg = "Invalid Grammar Token name: ->" + tokTypeName + "<- it must match the pattern: ->" + options.expectedPattern.toString() + "<-";
        return errMsg;
    },
    buildEmptyAlternationError: function (options) {
        var errMsg = "Ambiguous empty alternative: <" + (options.emptyChoiceIdx + 1) + ">" +
            (" in <OR" + options.alternation.idx + "> inside <" + options.topLevelRule.name + "> Rule.\n") +
            "Only the last alternative may be an empty alternative.";
        return errMsg;
    },
    buildTooManyAlternativesError: function (options) {
        var errMsg = "An Alternation cannot have more than 256 alternatives:\n" +
            ("<OR" + options.alternation.idx + "> inside <" + options.topLevelRule.name + "> Rule.\n has " + (options.alternation.definition.length +
                1) + " alternatives.");
        return errMsg;
    },
    buildLeftRecursionError: function (options) {
        var ruleName = options.topLevelRule.name;
        var pathNames = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["I" /* map */](options.leftRecursionPath, function (currRule) { return currRule.name; });
        var leftRecursivePath = ruleName + " --> " + pathNames
            .concat([ruleName])
            .join(" --> ");
        var errMsg = "Left Recursion found in grammar.\n" +
            ("rule: <" + ruleName + "> can be invoked from itself (directly or indirectly)\n") +
            ("without consuming any Tokens. The grammar path that causes this is: \n " + leftRecursivePath + "\n") +
            " To fix this refactor your grammar to remove the left recursion.\n" +
            "see: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.";
        return errMsg;
    },
    buildInvalidRuleNameError: function (options) {
        var ruleName = options.topLevelRule.name;
        var expectedPatternString = options.expectedPattern.toString();
        var errMsg = "Invalid grammar rule name: ->" + ruleName + "<- it must match the pattern: ->" + expectedPatternString + "<-";
        return errMsg;
    },
    buildDuplicateRuleNameError: function (options) {
        var ruleName;
        if (options.topLevelRule instanceof __WEBPACK_IMPORTED_MODULE_2__grammar_gast_gast_public__["j" /* Rule */]) {
            ruleName = options.topLevelRule.name;
        }
        else {
            ruleName = options.topLevelRule;
        }
        var errMsg = "Duplicate definition, rule: ->" + ruleName + "<- is already defined in the grammar: ->" + options.grammarName + "<-";
        return errMsg;
    }
};
//# sourceMappingURL=errors_public.js.map

/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = validateGrammar;
/* unused harmony export identifyProductionForDuplicates */
/* unused harmony export OccurrenceValidationCollector */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return validTermsPattern; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return validNestedRuleName; });
/* unused harmony export validateRuleName */
/* unused harmony export validateNestedRuleName */
/* unused harmony export validateTokenName */
/* unused harmony export validateRuleDoesNotAlreadyExist */
/* harmony export (immutable) */ __webpack_exports__["d"] = validateRuleIsOverridden;
/* unused harmony export validateNoLeftRecursion */
/* unused harmony export getFirstNoneTerminal */
/* unused harmony export validateEmptyOrAlternative */
/* unused harmony export validateAmbiguousAlternationAlternatives */
/* unused harmony export RepetionCollector */
/* unused harmony export validateTooManyAlts */
/* unused harmony export validateSomeNonEmptyLookaheadPath */
/* unused harmony export checkPrefixAlternativesAmbiguities */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parser_parser__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__gast_gast__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lookahead__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__cst_cst__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__interpreter__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__gast_gast_public__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__gast_gast_visitor_public__ = __webpack_require__(20);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();









function validateGrammar(topLevels, globalMaxLookahead, tokenTypes, ignoredIssues, errMsgProvider, grammarName) {
    var duplicateErrors = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */](topLevels, function (currTopLevel) {
        return validateDuplicateProductions(currTopLevel, errMsgProvider);
    });
    var leftRecursionErrors = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */](topLevels, function (currTopRule) {
        return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);
    });
    var emptyAltErrors = [];
    var ambiguousAltsErrors = [];
    var emptyRepetitionErrors = [];
    // left recursion could cause infinite loops in the following validations.
    // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.
    if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["o" /* every */])(leftRecursionErrors, __WEBPACK_IMPORTED_MODULE_0__utils_utils__["A" /* isEmpty */])) {
        emptyAltErrors = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */])(topLevels, function (currTopRule) {
            return validateEmptyOrAlternative(currTopRule, errMsgProvider);
        });
        ambiguousAltsErrors = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */])(topLevels, function (currTopRule) {
            return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, ignoredIssues, errMsgProvider);
        });
        emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);
    }
    var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);
    var tokenNameErrors = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */](tokenTypes, function (currTokType) {
        return validateTokenName(currTokType, errMsgProvider);
    });
    var nestedRulesNameErrors = validateNestedRulesNames(topLevels, errMsgProvider);
    var nestedRulesDuplicateErrors = validateDuplicateNestedRules(topLevels, errMsgProvider);
    var tooManyAltsErrors = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */])(topLevels, function (curRule) {
        return validateTooManyAlts(curRule, errMsgProvider);
    });
    var ruleNameErrors = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */])(topLevels, function (curRule) {
        return validateRuleName(curRule, errMsgProvider);
    });
    var duplicateRulesError = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */])(topLevels, function (curRule) {
        return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);
    });
    return (__WEBPACK_IMPORTED_MODULE_0__utils_utils__["t" /* flatten */](duplicateErrors.concat(tokenNameErrors, nestedRulesNameErrors, nestedRulesDuplicateErrors, emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, ruleNameErrors, duplicateRulesError)));
}
function validateNestedRulesNames(topLevels, errMsgProvider) {
    var result = [];
    Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(topLevels, function (curTopLevel) {
        var namedCollectorVisitor = new __WEBPACK_IMPORTED_MODULE_4__cst_cst__["a" /* NamedDSLMethodsCollectorVisitor */]("");
        curTopLevel.accept(namedCollectorVisitor);
        var nestedProds = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */])(namedCollectorVisitor.result, function (currItem) { return currItem.orgProd; });
        result.push(Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */])(nestedProds, function (currNestedProd) {
            return validateNestedRuleName(curTopLevel, currNestedProd, errMsgProvider);
        }));
    });
    return Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["t" /* flatten */])(result);
}
function validateDuplicateProductions(topLevelRule, errMsgProvider) {
    var collectorVisitor = new OccurrenceValidationCollector();
    topLevelRule.accept(collectorVisitor);
    var allRuleProductions = collectorVisitor.allProductions;
    var productionGroups = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["v" /* groupBy */](allRuleProductions, identifyProductionForDuplicates);
    var duplicates = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["N" /* pick */](productionGroups, function (currGroup) {
        return currGroup.length > 1;
    });
    var errors = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */](__WEBPACK_IMPORTED_MODULE_0__utils_utils__["U" /* values */](duplicates), function (currDuplicates) {
        var firstProd = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["s" /* first */](currDuplicates);
        var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);
        var dslName = Object(__WEBPACK_IMPORTED_MODULE_2__gast_gast__["c" /* getProductionDslName */])(firstProd);
        var defError = {
            message: msg,
            type: __WEBPACK_IMPORTED_MODULE_1__parser_parser__["h" /* ParserDefinitionErrorType */].DUPLICATE_PRODUCTIONS,
            ruleName: topLevelRule.name,
            dslName: dslName,
            occurrence: firstProd.idx
        };
        var param = getExtraProductionArgument(firstProd);
        if (param) {
            defError.parameter = param;
        }
        return defError;
    });
    return errors;
}
function identifyProductionForDuplicates(prod) {
    return Object(__WEBPACK_IMPORTED_MODULE_2__gast_gast__["c" /* getProductionDslName */])(prod) + "_#_" + prod.idx + "_#_" + getExtraProductionArgument(prod);
}
function getExtraProductionArgument(prod) {
    if (prod instanceof __WEBPACK_IMPORTED_MODULE_6__gast_gast_public__["k" /* Terminal */]) {
        return prod.terminalType.name;
    }
    else if (prod instanceof __WEBPACK_IMPORTED_MODULE_6__gast_gast_public__["d" /* NonTerminal */]) {
        return prod.nonTerminalName;
    }
    else {
        return "";
    }
}
var OccurrenceValidationCollector = /** @class */ (function (_super) {
    __extends(OccurrenceValidationCollector, _super);
    function OccurrenceValidationCollector() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allProductions = [];
        return _this;
    }
    OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {
        this.allProductions.push(subrule);
    };
    OccurrenceValidationCollector.prototype.visitOption = function (option) {
        this.allProductions.push(option);
    };
    OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {
        this.allProductions.push(manySep);
    };
    OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {
        this.allProductions.push(atLeastOne);
    };
    OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {
        this.allProductions.push(atLeastOneSep);
    };
    OccurrenceValidationCollector.prototype.visitRepetition = function (many) {
        this.allProductions.push(many);
    };
    OccurrenceValidationCollector.prototype.visitAlternation = function (or) {
        this.allProductions.push(or);
    };
    OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {
        this.allProductions.push(terminal);
    };
    return OccurrenceValidationCollector;
}(__WEBPACK_IMPORTED_MODULE_7__gast_gast_visitor_public__["a" /* GAstVisitor */]));

var validTermsPattern = /^[a-zA-Z_]\w*$/;
var validNestedRuleName = new RegExp(validTermsPattern.source.replace("^", "^\\$"));
// TODO: remove this limitation now that we use recorders
function validateRuleName(rule, errMsgProvider) {
    var errors = [];
    var ruleName = rule.name;
    if (!ruleName.match(validTermsPattern)) {
        errors.push({
            message: errMsgProvider.buildInvalidRuleNameError({
                topLevelRule: rule,
                expectedPattern: validTermsPattern
            }),
            type: __WEBPACK_IMPORTED_MODULE_1__parser_parser__["h" /* ParserDefinitionErrorType */].INVALID_RULE_NAME,
            ruleName: ruleName
        });
    }
    return errors;
}
// TODO: did the nested rule name regExp now change?
function validateNestedRuleName(topLevel, nestedProd, errMsgProvider) {
    var errors = [];
    var errMsg;
    if (!nestedProd.name.match(validNestedRuleName)) {
        errMsg = errMsgProvider.buildInvalidNestedRuleNameError(topLevel, nestedProd);
        errors.push({
            message: errMsg,
            type: __WEBPACK_IMPORTED_MODULE_1__parser_parser__["h" /* ParserDefinitionErrorType */].INVALID_NESTED_RULE_NAME,
            ruleName: topLevel.name
        });
    }
    return errors;
}
// TODO: remove this limitation now that we use recorders
function validateTokenName(tokenType, errMsgProvider) {
    var errors = [];
    var tokTypeName = tokenType.name;
    if (!tokTypeName.match(validTermsPattern)) {
        errors.push({
            message: errMsgProvider.buildTokenNameError({
                tokenType: tokenType,
                expectedPattern: validTermsPattern
            }),
            type: __WEBPACK_IMPORTED_MODULE_1__parser_parser__["h" /* ParserDefinitionErrorType */].INVALID_TOKEN_NAME
        });
    }
    return errors;
}
function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {
    var errors = [];
    var occurrences = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["O" /* reduce */])(allRules, function (result, curRule) {
        if (curRule.name === rule.name) {
            return result + 1;
        }
        return result;
    }, 0);
    if (occurrences > 1) {
        var errMsg = errMsgProvider.buildDuplicateRuleNameError({
            topLevelRule: rule,
            grammarName: className
        });
        errors.push({
            message: errMsg,
            type: __WEBPACK_IMPORTED_MODULE_1__parser_parser__["h" /* ParserDefinitionErrorType */].DUPLICATE_RULE_NAME,
            ruleName: rule.name
        });
    }
    return errors;
}
// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?
// This is not part of the IGrammarErrorProvider because the validation cannot be performed on
// The grammar structure, only at runtime.
function validateRuleIsOverridden(ruleName, definedRulesNames, className) {
    var errors = [];
    var errMsg;
    if (!__WEBPACK_IMPORTED_MODULE_0__utils_utils__["j" /* contains */](definedRulesNames, ruleName)) {
        errMsg =
            "Invalid rule override, rule: ->" + ruleName + "<- cannot be overridden in the grammar: ->" + className + "<-" +
                "as it is not defined in any of the super grammars ";
        errors.push({
            message: errMsg,
            type: __WEBPACK_IMPORTED_MODULE_1__parser_parser__["h" /* ParserDefinitionErrorType */].INVALID_RULE_OVERRIDE,
            ruleName: ruleName
        });
    }
    return errors;
}
function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {
    if (path === void 0) { path = []; }
    var errors = [];
    var nextNonTerminals = getFirstNoneTerminal(currRule.definition);
    if (__WEBPACK_IMPORTED_MODULE_0__utils_utils__["A" /* isEmpty */](nextNonTerminals)) {
        return [];
    }
    else {
        var ruleName = topRule.name;
        var foundLeftRecursion = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["j" /* contains */](nextNonTerminals, topRule);
        if (foundLeftRecursion) {
            errors.push({
                message: errMsgProvider.buildLeftRecursionError({
                    topLevelRule: topRule,
                    leftRecursionPath: path
                }),
                type: __WEBPACK_IMPORTED_MODULE_1__parser_parser__["h" /* ParserDefinitionErrorType */].LEFT_RECURSION,
                ruleName: ruleName
            });
        }
        // we are only looking for cyclic paths leading back to the specific topRule
        // other cyclic paths are ignored, we still need this difference to avoid infinite loops...
        var validNextSteps = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["l" /* difference */](nextNonTerminals, path.concat([topRule]));
        var errorsFromNextSteps = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */](validNextSteps, function (currRefRule) {
            var newPath = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["g" /* cloneArr */](path);
            newPath.push(currRefRule);
            return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);
        });
        return errors.concat(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["t" /* flatten */](errorsFromNextSteps));
    }
}
function getFirstNoneTerminal(definition) {
    var result = [];
    if (__WEBPACK_IMPORTED_MODULE_0__utils_utils__["A" /* isEmpty */](definition)) {
        return result;
    }
    var firstProd = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["s" /* first */](definition);
    /* istanbul ignore else */
    if (firstProd instanceof __WEBPACK_IMPORTED_MODULE_6__gast_gast_public__["d" /* NonTerminal */]) {
        result.push(firstProd.referencedRule);
    }
    else if (firstProd instanceof __WEBPACK_IMPORTED_MODULE_6__gast_gast_public__["c" /* Flat */] ||
        firstProd instanceof __WEBPACK_IMPORTED_MODULE_6__gast_gast_public__["e" /* Option */] ||
        firstProd instanceof __WEBPACK_IMPORTED_MODULE_6__gast_gast_public__["g" /* RepetitionMandatory */] ||
        firstProd instanceof __WEBPACK_IMPORTED_MODULE_6__gast_gast_public__["h" /* RepetitionMandatoryWithSeparator */] ||
        firstProd instanceof __WEBPACK_IMPORTED_MODULE_6__gast_gast_public__["i" /* RepetitionWithSeparator */] ||
        firstProd instanceof __WEBPACK_IMPORTED_MODULE_6__gast_gast_public__["f" /* Repetition */]) {
        result = result.concat(getFirstNoneTerminal(firstProd.definition));
    }
    else if (firstProd instanceof __WEBPACK_IMPORTED_MODULE_6__gast_gast_public__["b" /* Alternation */]) {
        // each sub definition in alternation is a FLAT
        result = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["t" /* flatten */](__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */](firstProd.definition, function (currSubDef) {
            return getFirstNoneTerminal(currSubDef.definition);
        }));
    }
    else if (firstProd instanceof __WEBPACK_IMPORTED_MODULE_6__gast_gast_public__["k" /* Terminal */]) {
        // nothing to see, move along
    }
    else {
        throw Error("non exhaustive match");
    }
    var isFirstOptional = Object(__WEBPACK_IMPORTED_MODULE_2__gast_gast__["e" /* isOptionalProd */])(firstProd);
    var hasMore = definition.length > 1;
    if (isFirstOptional && hasMore) {
        var rest = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["m" /* drop */](definition);
        return result.concat(getFirstNoneTerminal(rest));
    }
    else {
        return result;
    }
}
var OrCollector = /** @class */ (function (_super) {
    __extends(OrCollector, _super);
    function OrCollector() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.alternations = [];
        return _this;
    }
    OrCollector.prototype.visitAlternation = function (node) {
        this.alternations.push(node);
    };
    return OrCollector;
}(__WEBPACK_IMPORTED_MODULE_7__gast_gast_visitor_public__["a" /* GAstVisitor */]));
function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {
    var orCollector = new OrCollector();
    topLevelRule.accept(orCollector);
    var ors = orCollector.alternations;
    var errors = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["O" /* reduce */](ors, function (errors, currOr) {
        var exceptLast = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["n" /* dropRight */](currOr.definition);
        var currErrors = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */](exceptLast, function (currAlternative, currAltIdx) {
            var possibleFirstInAlt = Object(__WEBPACK_IMPORTED_MODULE_5__interpreter__["f" /* nextPossibleTokensAfter */])([currAlternative], [], null, 1);
            if (__WEBPACK_IMPORTED_MODULE_0__utils_utils__["A" /* isEmpty */](possibleFirstInAlt)) {
                return {
                    message: errMsgProvider.buildEmptyAlternationError({
                        topLevelRule: topLevelRule,
                        alternation: currOr,
                        emptyChoiceIdx: currAltIdx
                    }),
                    type: __WEBPACK_IMPORTED_MODULE_1__parser_parser__["h" /* ParserDefinitionErrorType */].NONE_LAST_EMPTY_ALT,
                    ruleName: topLevelRule.name,
                    occurrence: currOr.idx,
                    alternative: currAltIdx + 1
                };
            }
            else {
                return null;
            }
        });
        return errors.concat(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["i" /* compact */](currErrors));
    }, []);
    return errors;
}
function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, ignoredIssues, errMsgProvider) {
    var orCollector = new OrCollector();
    topLevelRule.accept(orCollector);
    var ors = orCollector.alternations;
    // TODO: this filtering should be deprecated once we remove the ignoredIssues
    //  IParserConfig property
    var ignoredIssuesForCurrentRule = ignoredIssues[topLevelRule.name];
    if (ignoredIssuesForCurrentRule) {
        ors = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["P" /* reject */])(ors, function (currOr) {
            return ignoredIssuesForCurrentRule[Object(__WEBPACK_IMPORTED_MODULE_2__gast_gast__["c" /* getProductionDslName */])(currOr) +
                (currOr.idx === 0 ? "" : currOr.idx)];
        });
    }
    // New Handling of ignoring ambiguities
    // - https://github.com/SAP/chevrotain/issues/869
    ors = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["P" /* reject */])(ors, function (currOr) { return currOr.ignoreAmbiguities === true; });
    var errors = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["O" /* reduce */](ors, function (result, currOr) {
        var currOccurrence = currOr.idx;
        var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;
        var alternatives = Object(__WEBPACK_IMPORTED_MODULE_3__lookahead__["h" /* getLookaheadPathsForOr */])(currOccurrence, topLevelRule, actualMaxLookahead, currOr);
        var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
        var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
        return result.concat(altsAmbiguityErrors, altsPrefixAmbiguityErrors);
    }, []);
    return errors;
}
var RepetionCollector = /** @class */ (function (_super) {
    __extends(RepetionCollector, _super);
    function RepetionCollector() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allProductions = [];
        return _this;
    }
    RepetionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {
        this.allProductions.push(manySep);
    };
    RepetionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {
        this.allProductions.push(atLeastOne);
    };
    RepetionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {
        this.allProductions.push(atLeastOneSep);
    };
    RepetionCollector.prototype.visitRepetition = function (many) {
        this.allProductions.push(many);
    };
    return RepetionCollector;
}(__WEBPACK_IMPORTED_MODULE_7__gast_gast_visitor_public__["a" /* GAstVisitor */]));

function validateTooManyAlts(topLevelRule, errMsgProvider) {
    var orCollector = new OrCollector();
    topLevelRule.accept(orCollector);
    var ors = orCollector.alternations;
    var errors = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["O" /* reduce */](ors, function (errors, currOr) {
        if (currOr.definition.length > 255) {
            errors.push({
                message: errMsgProvider.buildTooManyAlternativesError({
                    topLevelRule: topLevelRule,
                    alternation: currOr
                }),
                type: __WEBPACK_IMPORTED_MODULE_1__parser_parser__["h" /* ParserDefinitionErrorType */].TOO_MANY_ALTS,
                ruleName: topLevelRule.name,
                occurrence: currOr.idx
            });
        }
        return errors;
    }, []);
    return errors;
}
function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {
    var errors = [];
    Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(topLevelRules, function (currTopRule) {
        var collectorVisitor = new RepetionCollector();
        currTopRule.accept(collectorVisitor);
        var allRuleProductions = collectorVisitor.allProductions;
        Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(allRuleProductions, function (currProd) {
            var prodType = Object(__WEBPACK_IMPORTED_MODULE_3__lookahead__["i" /* getProdType */])(currProd);
            var actualMaxLookahead = currProd.maxLookahead || maxLookahead;
            var currOccurrence = currProd.idx;
            var paths = Object(__WEBPACK_IMPORTED_MODULE_3__lookahead__["g" /* getLookaheadPathsForOptionalProd */])(currOccurrence, currTopRule, prodType, actualMaxLookahead);
            var pathsInsideProduction = paths[0];
            if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["A" /* isEmpty */])(Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["t" /* flatten */])(pathsInsideProduction))) {
                var errMsg = errMsgProvider.buildEmptyRepetitionError({
                    topLevelRule: currTopRule,
                    repetition: currProd
                });
                errors.push({
                    message: errMsg,
                    type: __WEBPACK_IMPORTED_MODULE_1__parser_parser__["h" /* ParserDefinitionErrorType */].NO_NON_EMPTY_LOOKAHEAD,
                    ruleName: currTopRule.name
                });
            }
        });
    });
    return errors;
}
function checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
    var foundAmbiguousPaths = [];
    var identicalAmbiguities = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["O" /* reduce */])(alternatives, function (result, currAlt, currAltIdx) {
        // ignore (skip) ambiguities with this alternative
        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {
            return result;
        }
        Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(currAlt, function (currPath) {
            var altsCurrPathAppearsIn = [currAltIdx];
            Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(alternatives, function (currOtherAlt, currOtherAltIdx) {
                if (currAltIdx !== currOtherAltIdx &&
                    Object(__WEBPACK_IMPORTED_MODULE_3__lookahead__["f" /* containsPath */])(currOtherAlt, currPath) &&
                    // ignore (skip) ambiguities with this "other" alternative
                    alternation.definition[currOtherAltIdx]
                        .ignoreAmbiguities !== true) {
                    altsCurrPathAppearsIn.push(currOtherAltIdx);
                }
            });
            if (altsCurrPathAppearsIn.length > 1 &&
                !Object(__WEBPACK_IMPORTED_MODULE_3__lookahead__["f" /* containsPath */])(foundAmbiguousPaths, currPath)) {
                foundAmbiguousPaths.push(currPath);
                result.push({
                    alts: altsCurrPathAppearsIn,
                    path: currPath
                });
            }
        });
        return result;
    }, []);
    var currErrors = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */](identicalAmbiguities, function (currAmbDescriptor) {
        var ambgIndices = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */])(currAmbDescriptor.alts, function (currAltIdx) { return currAltIdx + 1; });
        var currMessage = errMsgProvider.buildAlternationAmbiguityError({
            topLevelRule: rule,
            alternation: alternation,
            ambiguityIndices: ambgIndices,
            prefixPath: currAmbDescriptor.path
        });
        return {
            message: currMessage,
            type: __WEBPACK_IMPORTED_MODULE_1__parser_parser__["h" /* ParserDefinitionErrorType */].AMBIGUOUS_ALTS,
            ruleName: rule.name,
            occurrence: alternation.idx,
            alternatives: [currAmbDescriptor.alts]
        };
    });
    return currErrors;
}
function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
    var errors = [];
    // flatten
    var pathsAndIndices = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["O" /* reduce */])(alternatives, function (result, currAlt, idx) {
        var currPathsAndIdx = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */])(currAlt, function (currPath) {
            return { idx: idx, path: currPath };
        });
        return result.concat(currPathsAndIdx);
    }, []);
    Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(pathsAndIndices, function (currPathAndIdx) {
        var alternativeGast = alternation.definition[currPathAndIdx.idx];
        // ignore (skip) ambiguities with this alternative
        if (alternativeGast.ignoreAmbiguities === true) {
            return;
        }
        var targetIdx = currPathAndIdx.idx;
        var targetPath = currPathAndIdx.path;
        var prefixAmbiguitiesPathsAndIndices = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["r" /* findAll */])(pathsAndIndices, function (searchPathAndIdx) {
            // prefix ambiguity can only be created from lower idx (higher priority) path
            return (
            // ignore (skip) ambiguities with this "other" alternative
            alternation.definition[searchPathAndIdx.idx]
                .ignoreAmbiguities !== true &&
                searchPathAndIdx.idx < targetIdx &&
                // checking for strict prefix because identical lookaheads
                // will be be detected using a different validation.
                Object(__WEBPACK_IMPORTED_MODULE_3__lookahead__["j" /* isStrictPrefixOfPath */])(searchPathAndIdx.path, targetPath));
        });
        var currPathPrefixErrors = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */])(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {
            var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];
            var occurrence = alternation.idx === 0 ? "" : alternation.idx;
            var message = errMsgProvider.buildAlternationPrefixAmbiguityError({
                topLevelRule: rule,
                alternation: alternation,
                ambiguityIndices: ambgIndices,
                prefixPath: currAmbPathAndIdx.path
            });
            return {
                message: message,
                type: __WEBPACK_IMPORTED_MODULE_1__parser_parser__["h" /* ParserDefinitionErrorType */].AMBIGUOUS_PREFIX_ALTS,
                ruleName: rule.name,
                occurrence: occurrence,
                alternatives: ambgIndices
            };
        });
        errors = errors.concat(currPathPrefixErrors);
    });
    return errors;
}
function checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {
    var errors = [];
    var tokenNames = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */])(tokenTypes, function (currToken) { return currToken.name; });
    Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(topLevels, function (currRule) {
        var currRuleName = currRule.name;
        if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["j" /* contains */])(tokenNames, currRuleName)) {
            var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);
            errors.push({
                message: errMsg,
                type: __WEBPACK_IMPORTED_MODULE_1__parser_parser__["h" /* ParserDefinitionErrorType */].CONFLICT_TOKENS_RULES_NAMESPACE,
                ruleName: currRuleName
            });
        }
    });
    return errors;
}
function validateDuplicateNestedRules(topLevelRules, errMsgProvider) {
    var errors = [];
    Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(topLevelRules, function (currTopRule) {
        var namedCollectorVisitor = new __WEBPACK_IMPORTED_MODULE_4__cst_cst__["a" /* NamedDSLMethodsCollectorVisitor */]("");
        currTopRule.accept(namedCollectorVisitor);
        var prodsByGroup = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["v" /* groupBy */])(namedCollectorVisitor.result, function (item) { return item.name; });
        var duplicates = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["N" /* pick */])(prodsByGroup, function (currGroup) {
            return currGroup.length > 1;
        });
        Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["U" /* values */])(duplicates), function (currDupGroup) {
            var currDupProds = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */])(currDupGroup, function (dupGroup) { return dupGroup.orgProd; });
            var errMsg = errMsgProvider.buildDuplicateNestedRuleNameError(currTopRule, currDupProds);
            errors.push({
                message: errMsg,
                type: __WEBPACK_IMPORTED_MODULE_1__parser_parser__["h" /* ParserDefinitionErrorType */].DUPLICATE_NESTED_NAME,
                ruleName: currTopRule.name
            });
        });
    });
    return errors;
}
//# sourceMappingURL=checks.js.map

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PROD_TYPE; });
/* harmony export (immutable) */ __webpack_exports__["i"] = getProdType;
/* harmony export (immutable) */ __webpack_exports__["d"] = buildLookaheadFuncForOr;
/* harmony export (immutable) */ __webpack_exports__["c"] = buildLookaheadFuncForOptionalProd;
/* harmony export (immutable) */ __webpack_exports__["b"] = buildAlternativesLookAheadFunc;
/* harmony export (immutable) */ __webpack_exports__["e"] = buildSingleAlternativeLookaheadFunction;
/* unused harmony export lookAheadSequenceFromAlternatives */
/* harmony export (immutable) */ __webpack_exports__["h"] = getLookaheadPathsForOr;
/* harmony export (immutable) */ __webpack_exports__["g"] = getLookaheadPathsForOptionalProd;
/* harmony export (immutable) */ __webpack_exports__["f"] = containsPath;
/* harmony export (immutable) */ __webpack_exports__["j"] = isStrictPrefixOfPath;
/* unused harmony export areTokenCategoriesNotUsed */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__interpreter__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__rest__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__scan_tokens__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__gast_gast_public__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__gast_gast_visitor_public__ = __webpack_require__(20);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();






var PROD_TYPE;
(function (PROD_TYPE) {
    PROD_TYPE[PROD_TYPE["OPTION"] = 0] = "OPTION";
    PROD_TYPE[PROD_TYPE["REPETITION"] = 1] = "REPETITION";
    PROD_TYPE[PROD_TYPE["REPETITION_MANDATORY"] = 2] = "REPETITION_MANDATORY";
    PROD_TYPE[PROD_TYPE["REPETITION_MANDATORY_WITH_SEPARATOR"] = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR";
    PROD_TYPE[PROD_TYPE["REPETITION_WITH_SEPARATOR"] = 4] = "REPETITION_WITH_SEPARATOR";
    PROD_TYPE[PROD_TYPE["ALTERNATION"] = 5] = "ALTERNATION";
})(PROD_TYPE || (PROD_TYPE = {}));
function getProdType(prod) {
    /* istanbul ignore else */
    if (prod instanceof __WEBPACK_IMPORTED_MODULE_4__gast_gast_public__["e" /* Option */]) {
        return PROD_TYPE.OPTION;
    }
    else if (prod instanceof __WEBPACK_IMPORTED_MODULE_4__gast_gast_public__["f" /* Repetition */]) {
        return PROD_TYPE.REPETITION;
    }
    else if (prod instanceof __WEBPACK_IMPORTED_MODULE_4__gast_gast_public__["g" /* RepetitionMandatory */]) {
        return PROD_TYPE.REPETITION_MANDATORY;
    }
    else if (prod instanceof __WEBPACK_IMPORTED_MODULE_4__gast_gast_public__["h" /* RepetitionMandatoryWithSeparator */]) {
        return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;
    }
    else if (prod instanceof __WEBPACK_IMPORTED_MODULE_4__gast_gast_public__["i" /* RepetitionWithSeparator */]) {
        return PROD_TYPE.REPETITION_WITH_SEPARATOR;
    }
    else if (prod instanceof __WEBPACK_IMPORTED_MODULE_4__gast_gast_public__["b" /* Alternation */]) {
        return PROD_TYPE.ALTERNATION;
    }
    else {
        throw Error("non exhaustive match");
    }
}
function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {
    var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);
    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)
        ? __WEBPACK_IMPORTED_MODULE_3__scan_tokens__["e" /* tokenStructuredMatcherNoCategories */]
        : __WEBPACK_IMPORTED_MODULE_3__scan_tokens__["d" /* tokenStructuredMatcher */];
    return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);
}
/**
 *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare
 *  the lookahead "inside" the production and the lookahead immediately "after" it in the same top level rule (context free).
 *
 *  Example: given a production:
 *  ABC(DE)?DF
 *
 *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two
 *  alternatives.
 *
 *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.
 */
function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {
    var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);
    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)
        ? __WEBPACK_IMPORTED_MODULE_3__scan_tokens__["e" /* tokenStructuredMatcherNoCategories */]
        : __WEBPACK_IMPORTED_MODULE_3__scan_tokens__["d" /* tokenStructuredMatcher */];
    return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);
}
function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {
    var numOfAlts = alts.length;
    var areAllOneTokenLookahead = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["o" /* every */])(alts, function (currAlt) {
        return Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["o" /* every */])(currAlt, function (currPath) {
            return currPath.length === 1;
        });
    });
    // This version takes into account the predicates as well.
    if (hasPredicates) {
        /**
         * @returns {number} - The chosen alternative index
         */
        return function (orAlts) {
            // unfortunately the predicates must be extracted every single time
            // as they cannot be cached due to references to parameters(vars) which are no longer valid.
            // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)
            var predicates = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */])(orAlts, function (currAlt) { return currAlt.GATE; });
            for (var t = 0; t < numOfAlts; t++) {
                var currAlt = alts[t];
                var currNumOfPaths = currAlt.length;
                var currPredicate = predicates[t];
                if (currPredicate !== undefined &&
                    currPredicate.call(this) === false) {
                    // if the predicate does not match there is no point in checking the paths
                    continue;
                }
                nextPath: for (var j = 0; j < currNumOfPaths; j++) {
                    var currPath = currAlt[j];
                    var currPathLength = currPath.length;
                    for (var i = 0; i < currPathLength; i++) {
                        var nextToken = this.LA(i + 1);
                        if (tokenMatcher(nextToken, currPath[i]) === false) {
                            // mismatch in current path
                            // try the next pth
                            continue nextPath;
                        }
                    }
                    // found a full path that matches.
                    // this will also work for an empty ALT as the loop will be skipped
                    return t;
                }
                // none of the paths for the current alternative matched
                // try the next alternative
            }
            // none of the alternatives could be matched
            return undefined;
        };
    }
    else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
        // optimized (common) case of all the lookaheads paths requiring only
        // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.
        var singleTokenAlts = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */])(alts, function (currAlt) {
            return Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["t" /* flatten */])(currAlt);
        });
        var choiceToAlt_1 = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["O" /* reduce */])(singleTokenAlts, function (result, currAlt, idx) {
            Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(currAlt, function (currTokType) {
                if (!Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(result, currTokType.tokenTypeIdx)) {
                    result[currTokType.tokenTypeIdx] = idx;
                }
                Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(currTokType.categoryMatches, function (currExtendingType) {
                    if (!Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(result, currExtendingType)) {
                        result[currExtendingType] = idx;
                    }
                });
            });
            return result;
        }, []);
        /**
         * @returns {number} - The chosen alternative index
         */
        return function () {
            var nextToken = this.LA(1);
            return choiceToAlt_1[nextToken.tokenTypeIdx];
        };
    }
    else {
        // optimized lookahead without needing to check the predicates at all.
        // this causes code duplication which is intentional to improve performance.
        /**
         * @returns {number} - The chosen alternative index
         */
        return function () {
            for (var t = 0; t < numOfAlts; t++) {
                var currAlt = alts[t];
                var currNumOfPaths = currAlt.length;
                nextPath: for (var j = 0; j < currNumOfPaths; j++) {
                    var currPath = currAlt[j];
                    var currPathLength = currPath.length;
                    for (var i = 0; i < currPathLength; i++) {
                        var nextToken = this.LA(i + 1);
                        if (tokenMatcher(nextToken, currPath[i]) === false) {
                            // mismatch in current path
                            // try the next pth
                            continue nextPath;
                        }
                    }
                    // found a full path that matches.
                    // this will also work for an empty ALT as the loop will be skipped
                    return t;
                }
                // none of the paths for the current alternative matched
                // try the next alternative
            }
            // none of the alternatives could be matched
            return undefined;
        };
    }
}
function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {
    var areAllOneTokenLookahead = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["o" /* every */])(alt, function (currPath) {
        return currPath.length === 1;
    });
    var numOfPaths = alt.length;
    // optimized (common) case of all the lookaheads paths requiring only
    // a single token lookahead.
    if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
        var singleTokensTypes = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["t" /* flatten */])(alt);
        if (singleTokensTypes.length === 1 &&
            Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["A" /* isEmpty */])(singleTokensTypes[0].categoryMatches)) {
            var expectedTokenType = singleTokensTypes[0];
            var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;
            return function () {
                return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;
            };
        }
        else {
            var choiceToAlt_2 = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["O" /* reduce */])(singleTokensTypes, function (result, currTokType, idx) {
                result[currTokType.tokenTypeIdx] = true;
                Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(currTokType.categoryMatches, function (currExtendingType) {
                    result[currExtendingType] = true;
                });
                return result;
            }, []);
            return function () {
                var nextToken = this.LA(1);
                return choiceToAlt_2[nextToken.tokenTypeIdx] === true;
            };
        }
    }
    else {
        return function () {
            nextPath: for (var j = 0; j < numOfPaths; j++) {
                var currPath = alt[j];
                var currPathLength = currPath.length;
                for (var i = 0; i < currPathLength; i++) {
                    var nextToken = this.LA(i + 1);
                    if (tokenMatcher(nextToken, currPath[i]) === false) {
                        // mismatch in current path
                        // try the next pth
                        continue nextPath;
                    }
                }
                // found a full path that matches.
                return true;
            }
            // none of the paths matched
            return false;
        };
    }
}
var RestDefinitionFinderWalker = /** @class */ (function (_super) {
    __extends(RestDefinitionFinderWalker, _super);
    function RestDefinitionFinderWalker(topProd, targetOccurrence, targetProdType) {
        var _this = _super.call(this) || this;
        _this.topProd = topProd;
        _this.targetOccurrence = targetOccurrence;
        _this.targetProdType = targetProdType;
        return _this;
    }
    RestDefinitionFinderWalker.prototype.startWalking = function () {
        this.walk(this.topProd);
        return this.restDef;
    };
    RestDefinitionFinderWalker.prototype.checkIsTarget = function (node, expectedProdType, currRest, prevRest) {
        if (node.idx === this.targetOccurrence &&
            this.targetProdType === expectedProdType) {
            this.restDef = currRest.concat(prevRest);
            return true;
        }
        // performance optimization, do not iterate over the entire Grammar ast after we have found the target
        return false;
    };
    RestDefinitionFinderWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {
        if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);
        }
    };
    RestDefinitionFinderWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {
        if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);
        }
    };
    RestDefinitionFinderWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {
        if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);
        }
    };
    RestDefinitionFinderWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {
        if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);
        }
    };
    RestDefinitionFinderWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {
        if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);
        }
    };
    return RestDefinitionFinderWalker;
}(__WEBPACK_IMPORTED_MODULE_2__rest__["a" /* RestWalker */]));
/**
 * Returns the definition of a target production in a top level level rule.
 */
var InsideDefinitionFinderVisitor = /** @class */ (function (_super) {
    __extends(InsideDefinitionFinderVisitor, _super);
    function InsideDefinitionFinderVisitor(targetOccurrence, targetProdType, targetRef) {
        var _this = _super.call(this) || this;
        _this.targetOccurrence = targetOccurrence;
        _this.targetProdType = targetProdType;
        _this.targetRef = targetRef;
        _this.result = [];
        return _this;
    }
    InsideDefinitionFinderVisitor.prototype.checkIsTarget = function (node, expectedProdName) {
        if (node.idx === this.targetOccurrence &&
            this.targetProdType === expectedProdName &&
            (this.targetRef === undefined || node === this.targetRef)) {
            this.result = node.definition;
        }
    };
    InsideDefinitionFinderVisitor.prototype.visitOption = function (node) {
        this.checkIsTarget(node, PROD_TYPE.OPTION);
    };
    InsideDefinitionFinderVisitor.prototype.visitRepetition = function (node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION);
    };
    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatory = function (node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);
    };
    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);
    };
    InsideDefinitionFinderVisitor.prototype.visitRepetitionWithSeparator = function (node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);
    };
    InsideDefinitionFinderVisitor.prototype.visitAlternation = function (node) {
        this.checkIsTarget(node, PROD_TYPE.ALTERNATION);
    };
    return InsideDefinitionFinderVisitor;
}(__WEBPACK_IMPORTED_MODULE_5__gast_gast_visitor_public__["a" /* GAstVisitor */]));
function initializeArrayOfArrays(size) {
    var result = new Array(size);
    for (var i = 0; i < size; i++) {
        result[i] = [];
    }
    return result;
}
/**
 * A sort of hash function between a Path in the grammar and a string.
 * Note that this returns multiple "hashes" to support the scenario of token categories.
 * -  A single path with categories may match multiple **actual** paths.
 */
function pathToHashKeys(path) {
    var keys = [""];
    for (var i = 0; i < path.length; i++) {
        var tokType = path[i];
        var longerKeys = [];
        for (var j = 0; j < keys.length; j++) {
            var currShorterKey = keys[j];
            longerKeys.push(currShorterKey + "_" + tokType.tokenTypeIdx);
            for (var t = 0; t < tokType.categoryMatches.length; t++) {
                var categoriesKeySuffix = "_" + tokType.categoryMatches[t];
                longerKeys.push(currShorterKey + categoriesKeySuffix);
            }
        }
        keys = longerKeys;
    }
    return keys;
}
/**
 * Imperative style due to being called from a hot spot
 */
function isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {
    for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {
        // We only want to test vs the other alternatives
        if (currAltIdx === idx) {
            continue;
        }
        var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];
        for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {
            var searchKey = searchPathKeys[searchIdx];
            if (otherAltKnownPathsKeys[searchKey] === true) {
                return false;
            }
        }
    }
    // None of the SearchPathKeys were found in any of the other alternatives
    return true;
}
function lookAheadSequenceFromAlternatives(altsDefs, k) {
    var partialAlts = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */])(altsDefs, function (currAlt) { return Object(__WEBPACK_IMPORTED_MODULE_1__interpreter__["g" /* possiblePathsFrom */])([currAlt], 1); });
    var finalResult = initializeArrayOfArrays(partialAlts.length);
    var altsHashes = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */])(partialAlts, function (currAltPaths) {
        var dict = {};
        Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(currAltPaths, function (item) {
            var keys = pathToHashKeys(item.partialPath);
            Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(keys, function (currKey) {
                dict[currKey] = true;
            });
        });
        return dict;
    });
    var newData = partialAlts;
    // maxLookahead loop
    for (var pathLength = 1; pathLength <= k; pathLength++) {
        var currDataset = newData;
        newData = initializeArrayOfArrays(currDataset.length);
        var _loop_1 = function (altIdx) {
            var currAltPathsAndSuffixes = currDataset[altIdx];
            // paths in current alternative loop
            for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {
                var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;
                var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;
                var prefixKeys = pathToHashKeys(currPathPrefix);
                var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);
                // End of the line for this path.
                if (isUnique ||
                    Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["A" /* isEmpty */])(suffixDef) ||
                    currPathPrefix.length === k) {
                    var currAltResult = finalResult[altIdx];
                    // TODO: Can we implement a containsPath using Maps/Dictionaries?
                    if (containsPath(currAltResult, currPathPrefix) === false) {
                        currAltResult.push(currPathPrefix);
                        // Update all new  keys for the current path.
                        for (var j = 0; j < prefixKeys.length; j++) {
                            var currKey = prefixKeys[j];
                            altsHashes[altIdx][currKey] = true;
                        }
                    }
                }
                // Expand longer paths
                else {
                    var newPartialPathsAndSuffixes = Object(__WEBPACK_IMPORTED_MODULE_1__interpreter__["g" /* possiblePathsFrom */])(suffixDef, pathLength + 1, currPathPrefix);
                    newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);
                    // Update keys for new known paths
                    Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(newPartialPathsAndSuffixes, function (item) {
                        var prefixKeys = pathToHashKeys(item.partialPath);
                        Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(prefixKeys, function (key) {
                            altsHashes[altIdx][key] = true;
                        });
                    });
                }
            }
        };
        // alternatives loop
        for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {
            _loop_1(altIdx);
        }
    }
    return finalResult;
}
function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {
    var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);
    ruleGrammar.accept(visitor);
    return lookAheadSequenceFromAlternatives(visitor.result, k);
}
function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {
    var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);
    ruleGrammar.accept(insideDefVisitor);
    var insideDef = insideDefVisitor.result;
    var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);
    var afterDef = afterDefWalker.startWalking();
    var insideFlat = new __WEBPACK_IMPORTED_MODULE_4__gast_gast_public__["c" /* Flat */]({ definition: insideDef });
    var afterFlat = new __WEBPACK_IMPORTED_MODULE_4__gast_gast_public__["c" /* Flat */]({ definition: afterDef });
    return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);
}
function containsPath(alternative, searchPath) {
    compareOtherPath: for (var i = 0; i < alternative.length; i++) {
        var otherPath = alternative[i];
        if (otherPath.length !== searchPath.length) {
            continue;
        }
        for (var j = 0; j < otherPath.length; j++) {
            var searchTok = searchPath[j];
            var otherTok = otherPath[j];
            var matchingTokens = searchTok === otherTok ||
                otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !==
                    undefined;
            if (matchingTokens === false) {
                continue compareOtherPath;
            }
        }
        return true;
    }
    return false;
}
function isStrictPrefixOfPath(prefix, other) {
    return (prefix.length < other.length &&
        Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["o" /* every */])(prefix, function (tokType, idx) {
            var otherTokType = other[idx];
            return (tokType === otherTokType ||
                otherTokType.categoryMatchesMap[tokType.tokenTypeIdx]);
        }));
}
function areTokenCategoriesNotUsed(lookAheadPaths) {
    return Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["o" /* every */])(lookAheadPaths, function (singleAltPaths) {
        return Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["o" /* every */])(singleAltPaths, function (singlePath) {
            return Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["o" /* every */])(singlePath, function (token) { return Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["A" /* isEmpty */])(token.categoryMatches); });
        });
    });
}
//# sourceMappingURL=lookahead.js.map

/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export AbstractNextPossibleTokensWalker */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NextAfterTokenWalker; });
/* unused harmony export AbstractNextTerminalAfterProductionWalker */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return NextTerminalAfterManyWalker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return NextTerminalAfterManySepWalker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return NextTerminalAfterAtLeastOneWalker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return NextTerminalAfterAtLeastOneSepWalker; });
/* harmony export (immutable) */ __webpack_exports__["g"] = possiblePathsFrom;
/* harmony export (immutable) */ __webpack_exports__["f"] = nextPossibleTokensAfter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rest__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__first__ = __webpack_require__(217);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__ = __webpack_require__(6);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var AbstractNextPossibleTokensWalker = /** @class */ (function (_super) {
    __extends(AbstractNextPossibleTokensWalker, _super);
    function AbstractNextPossibleTokensWalker(topProd, path) {
        var _this = _super.call(this) || this;
        _this.topProd = topProd;
        _this.path = path;
        _this.possibleTokTypes = [];
        _this.nextProductionName = "";
        _this.nextProductionOccurrence = 0;
        _this.found = false;
        _this.isAtEndOfPath = false;
        return _this;
    }
    AbstractNextPossibleTokensWalker.prototype.startWalking = function () {
        this.found = false;
        if (this.path.ruleStack[0] !== this.topProd.name) {
            throw Error("The path does not start with the walker's top Rule!");
        }
        // immutable for the win
        this.ruleStack = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["g" /* cloneArr */])(this.path.ruleStack).reverse(); // intelij bug requires assertion
        this.occurrenceStack = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["g" /* cloneArr */])(this.path.occurrenceStack).reverse(); // intelij bug requires assertion
        // already verified that the first production is valid, we now seek the 2nd production
        this.ruleStack.pop();
        this.occurrenceStack.pop();
        this.updateExpectedNext();
        this.walk(this.topProd);
        return this.possibleTokTypes;
    };
    AbstractNextPossibleTokensWalker.prototype.walk = function (prod, prevRest) {
        if (prevRest === void 0) { prevRest = []; }
        // stop scanning once we found the path
        if (!this.found) {
            _super.prototype.walk.call(this, prod, prevRest);
        }
    };
    AbstractNextPossibleTokensWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {
        // found the next production, need to keep walking in it
        if (refProd.referencedRule.name === this.nextProductionName &&
            refProd.idx === this.nextProductionOccurrence) {
            var fullRest = currRest.concat(prevRest);
            this.updateExpectedNext();
            this.walk(refProd.referencedRule, fullRest);
        }
    };
    AbstractNextPossibleTokensWalker.prototype.updateExpectedNext = function () {
        // need to consume the Terminal
        if (Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["A" /* isEmpty */])(this.ruleStack)) {
            // must reset nextProductionXXX to avoid walking down another Top Level production while what we are
            // really seeking is the last Terminal...
            this.nextProductionName = "";
            this.nextProductionOccurrence = 0;
            this.isAtEndOfPath = true;
        }
        else {
            this.nextProductionName = this.ruleStack.pop();
            this.nextProductionOccurrence = this.occurrenceStack.pop();
        }
    };
    return AbstractNextPossibleTokensWalker;
}(__WEBPACK_IMPORTED_MODULE_0__rest__["a" /* RestWalker */]));

var NextAfterTokenWalker = /** @class */ (function (_super) {
    __extends(NextAfterTokenWalker, _super);
    function NextAfterTokenWalker(topProd, path) {
        var _this = _super.call(this, topProd, path) || this;
        _this.path = path;
        _this.nextTerminalName = "";
        _this.nextTerminalOccurrence = 0;
        _this.nextTerminalName = _this.path.lastTok.name;
        _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;
        return _this;
    }
    NextAfterTokenWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {
        if (this.isAtEndOfPath &&
            terminal.terminalType.name === this.nextTerminalName &&
            terminal.idx === this.nextTerminalOccurrence &&
            !this.found) {
            var fullRest = currRest.concat(prevRest);
            var restProd = new __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["c" /* Flat */]({ definition: fullRest });
            this.possibleTokTypes = Object(__WEBPACK_IMPORTED_MODULE_2__first__["a" /* first */])(restProd);
            this.found = true;
        }
    };
    return NextAfterTokenWalker;
}(AbstractNextPossibleTokensWalker));

/**
 * This walker only "walks" a single "TOP" level in the Grammar Ast, this means
 * it never "follows" production refs
 */
var AbstractNextTerminalAfterProductionWalker = /** @class */ (function (_super) {
    __extends(AbstractNextTerminalAfterProductionWalker, _super);
    function AbstractNextTerminalAfterProductionWalker(topRule, occurrence) {
        var _this = _super.call(this) || this;
        _this.topRule = topRule;
        _this.occurrence = occurrence;
        _this.result = {
            token: undefined,
            occurrence: undefined,
            isEndOfRule: undefined
        };
        return _this;
    }
    AbstractNextTerminalAfterProductionWalker.prototype.startWalking = function () {
        this.walk(this.topRule);
        return this.result;
    };
    return AbstractNextTerminalAfterProductionWalker;
}(__WEBPACK_IMPORTED_MODULE_0__rest__["a" /* RestWalker */]));

var NextTerminalAfterManyWalker = /** @class */ (function (_super) {
    __extends(NextTerminalAfterManyWalker, _super);
    function NextTerminalAfterManyWalker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NextTerminalAfterManyWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {
        if (manyProd.idx === this.occurrence) {
            var firstAfterMany = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["s" /* first */])(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterMany === undefined;
            if (firstAfterMany instanceof __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["k" /* Terminal */]) {
                this.result.token = firstAfterMany.terminalType;
                this.result.occurrence = firstAfterMany.idx;
            }
        }
        else {
            _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);
        }
    };
    return NextTerminalAfterManyWalker;
}(AbstractNextTerminalAfterProductionWalker));

var NextTerminalAfterManySepWalker = /** @class */ (function (_super) {
    __extends(NextTerminalAfterManySepWalker, _super);
    function NextTerminalAfterManySepWalker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NextTerminalAfterManySepWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {
        if (manySepProd.idx === this.occurrence) {
            var firstAfterManySep = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["s" /* first */])(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterManySep === undefined;
            if (firstAfterManySep instanceof __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["k" /* Terminal */]) {
                this.result.token = firstAfterManySep.terminalType;
                this.result.occurrence = firstAfterManySep.idx;
            }
        }
        else {
            _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);
        }
    };
    return NextTerminalAfterManySepWalker;
}(AbstractNextTerminalAfterProductionWalker));

var NextTerminalAfterAtLeastOneWalker = /** @class */ (function (_super) {
    __extends(NextTerminalAfterAtLeastOneWalker, _super);
    function NextTerminalAfterAtLeastOneWalker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NextTerminalAfterAtLeastOneWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {
        if (atLeastOneProd.idx === this.occurrence) {
            var firstAfterAtLeastOne = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["s" /* first */])(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterAtLeastOne === undefined;
            if (firstAfterAtLeastOne instanceof __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["k" /* Terminal */]) {
                this.result.token = firstAfterAtLeastOne.terminalType;
                this.result.occurrence = firstAfterAtLeastOne.idx;
            }
        }
        else {
            _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);
        }
    };
    return NextTerminalAfterAtLeastOneWalker;
}(AbstractNextTerminalAfterProductionWalker));

// TODO: reduce code duplication in the AfterWalkers
var NextTerminalAfterAtLeastOneSepWalker = /** @class */ (function (_super) {
    __extends(NextTerminalAfterAtLeastOneSepWalker, _super);
    function NextTerminalAfterAtLeastOneSepWalker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NextTerminalAfterAtLeastOneSepWalker.prototype.walkAtLeastOneSep = function (atleastOneSepProd, currRest, prevRest) {
        if (atleastOneSepProd.idx === this.occurrence) {
            var firstAfterfirstAfterAtLeastOneSep = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["s" /* first */])(currRest.concat(prevRest));
            this.result.isEndOfRule =
                firstAfterfirstAfterAtLeastOneSep === undefined;
            if (firstAfterfirstAfterAtLeastOneSep instanceof __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["k" /* Terminal */]) {
                this.result.token =
                    firstAfterfirstAfterAtLeastOneSep.terminalType;
                this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;
            }
        }
        else {
            _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);
        }
    };
    return NextTerminalAfterAtLeastOneSepWalker;
}(AbstractNextTerminalAfterProductionWalker));

function possiblePathsFrom(targetDef, maxLength, currPath) {
    if (currPath === void 0) { currPath = []; }
    // avoid side effects
    currPath = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["g" /* cloneArr */])(currPath);
    var result = [];
    var i = 0;
    // TODO: avoid inner funcs
    function remainingPathWith(nextDef) {
        return nextDef.concat(Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["m" /* drop */])(targetDef, i + 1));
    }
    // TODO: avoid inner funcs
    function getAlternativesForProd(definition) {
        var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);
        return result.concat(alternatives);
    }
    /**
     * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the
     * following (rest) of the targetDef.
     *
     * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the
     * the optional production.
     */
    while (currPath.length < maxLength && i < targetDef.length) {
        var prod = targetDef[i];
        /* istanbul ignore else */
        if (prod instanceof __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["c" /* Flat */]) {
            return getAlternativesForProd(prod.definition);
        }
        else if (prod instanceof __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["d" /* NonTerminal */]) {
            return getAlternativesForProd(prod.definition);
        }
        else if (prod instanceof __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["e" /* Option */]) {
            result = getAlternativesForProd(prod.definition);
        }
        else if (prod instanceof __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["g" /* RepetitionMandatory */]) {
            var newDef = prod.definition.concat([
                new __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["f" /* Repetition */]({
                    definition: prod.definition
                })
            ]);
            return getAlternativesForProd(newDef);
        }
        else if (prod instanceof __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["h" /* RepetitionMandatoryWithSeparator */]) {
            var newDef = [
                new __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["c" /* Flat */]({ definition: prod.definition }),
                new __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["f" /* Repetition */]({
                    definition: [
                        new __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["k" /* Terminal */]({ terminalType: prod.separator })
                    ].concat(prod.definition)
                })
            ];
            return getAlternativesForProd(newDef);
        }
        else if (prod instanceof __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["i" /* RepetitionWithSeparator */]) {
            var newDef = prod.definition.concat([
                new __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["f" /* Repetition */]({
                    definition: [
                        new __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["k" /* Terminal */]({ terminalType: prod.separator })
                    ].concat(prod.definition)
                })
            ]);
            result = getAlternativesForProd(newDef);
        }
        else if (prod instanceof __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["f" /* Repetition */]) {
            var newDef = prod.definition.concat([
                new __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["f" /* Repetition */]({
                    definition: prod.definition
                })
            ]);
            result = getAlternativesForProd(newDef);
        }
        else if (prod instanceof __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["b" /* Alternation */]) {
            Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["u" /* forEach */])(prod.definition, function (currAlt) {
                result = getAlternativesForProd(currAlt.definition);
            });
            return result;
        }
        else if (prod instanceof __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["k" /* Terminal */]) {
            currPath.push(prod.terminalType);
        }
        else {
            throw Error("non exhaustive match");
        }
        i++;
    }
    result.push({
        partialPath: currPath,
        suffixDef: Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["m" /* drop */])(targetDef, i)
    });
    return result;
}
function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {
    var EXIT_NON_TERMINAL = "EXIT_NONE_TERMINAL";
    // to avoid creating a new Array each time.
    var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];
    var EXIT_ALTERNATIVE = "EXIT_ALTERNATIVE";
    var foundCompletePath = false;
    var tokenVectorLength = tokenVector.length;
    var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;
    var result = [];
    var possiblePaths = [];
    possiblePaths.push({
        idx: -1,
        def: initialDef,
        ruleStack: [],
        occurrenceStack: []
    });
    while (!Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["A" /* isEmpty */])(possiblePaths)) {
        var currPath = possiblePaths.pop();
        // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)
        if (currPath === EXIT_ALTERNATIVE) {
            if (foundCompletePath &&
                Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["H" /* last */])(possiblePaths).idx <= minimalAlternativesIndex) {
                // remove irrelevant alternative
                possiblePaths.pop();
            }
            continue;
        }
        var currDef = currPath.def;
        var currIdx = currPath.idx;
        var currRuleStack = currPath.ruleStack;
        var currOccurrenceStack = currPath.occurrenceStack;
        // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT
        if (Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["A" /* isEmpty */])(currDef)) {
            continue;
        }
        var prod = currDef[0];
        /* istanbul ignore else */
        if (prod === EXIT_NON_TERMINAL) {
            var nextPath = {
                idx: currIdx,
                def: Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["m" /* drop */])(currDef),
                ruleStack: Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["n" /* dropRight */])(currRuleStack),
                occurrenceStack: Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["n" /* dropRight */])(currOccurrenceStack)
            };
            possiblePaths.push(nextPath);
        }
        else if (prod instanceof __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["k" /* Terminal */]) {
            /* istanbul ignore else */
            if (currIdx < tokenVectorLength - 1) {
                var nextIdx = currIdx + 1;
                var actualToken = tokenVector[nextIdx];
                if (tokMatcher(actualToken, prod.terminalType)) {
                    var nextPath = {
                        idx: nextIdx,
                        def: Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["m" /* drop */])(currDef),
                        ruleStack: currRuleStack,
                        occurrenceStack: currOccurrenceStack
                    };
                    possiblePaths.push(nextPath);
                }
                // end of the line
            }
            else if (currIdx === tokenVectorLength - 1) {
                // IGNORE ABOVE ELSE
                result.push({
                    nextTokenType: prod.terminalType,
                    nextTokenOccurrence: prod.idx,
                    ruleStack: currRuleStack,
                    occurrenceStack: currOccurrenceStack
                });
                foundCompletePath = true;
            }
            else {
                throw Error("non exhaustive match");
            }
        }
        else if (prod instanceof __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["d" /* NonTerminal */]) {
            var newRuleStack = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["g" /* cloneArr */])(currRuleStack);
            newRuleStack.push(prod.nonTerminalName);
            var newOccurrenceStack = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["g" /* cloneArr */])(currOccurrenceStack);
            newOccurrenceStack.push(prod.idx);
            var nextPath = {
                idx: currIdx,
                def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["m" /* drop */])(currDef)),
                ruleStack: newRuleStack,
                occurrenceStack: newOccurrenceStack
            };
            possiblePaths.push(nextPath);
        }
        else if (prod instanceof __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["e" /* Option */]) {
            // the order of alternatives is meaningful, FILO (Last path will be traversed first).
            var nextPathWithout = {
                idx: currIdx,
                def: Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["m" /* drop */])(currDef),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWithout);
            // required marker to avoid backtracking paths whose higher priority alternatives already matched
            possiblePaths.push(EXIT_ALTERNATIVE);
            var nextPathWith = {
                idx: currIdx,
                def: prod.definition.concat(Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["m" /* drop */])(currDef)),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWith);
        }
        else if (prod instanceof __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["g" /* RepetitionMandatory */]) {
            // TODO:(THE NEW operators here take a while...) (convert once?)
            var secondIteration = new __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["f" /* Repetition */]({
                definition: prod.definition,
                idx: prod.idx
            });
            var nextDef = prod.definition.concat([secondIteration], Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["m" /* drop */])(currDef));
            var nextPath = {
                idx: currIdx,
                def: nextDef,
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPath);
        }
        else if (prod instanceof __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["h" /* RepetitionMandatoryWithSeparator */]) {
            // TODO:(THE NEW operators here take a while...) (convert once?)
            var separatorGast = new __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["k" /* Terminal */]({
                terminalType: prod.separator
            });
            var secondIteration = new __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["f" /* Repetition */]({
                definition: [separatorGast].concat(prod.definition),
                idx: prod.idx
            });
            var nextDef = prod.definition.concat([secondIteration], Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["m" /* drop */])(currDef));
            var nextPath = {
                idx: currIdx,
                def: nextDef,
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPath);
        }
        else if (prod instanceof __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["i" /* RepetitionWithSeparator */]) {
            // the order of alternatives is meaningful, FILO (Last path will be traversed first).
            var nextPathWithout = {
                idx: currIdx,
                def: Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["m" /* drop */])(currDef),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWithout);
            // required marker to avoid backtracking paths whose higher priority alternatives already matched
            possiblePaths.push(EXIT_ALTERNATIVE);
            var separatorGast = new __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["k" /* Terminal */]({
                terminalType: prod.separator
            });
            var nthRepetition = new __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["f" /* Repetition */]({
                definition: [separatorGast].concat(prod.definition),
                idx: prod.idx
            });
            var nextDef = prod.definition.concat([nthRepetition], Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["m" /* drop */])(currDef));
            var nextPathWith = {
                idx: currIdx,
                def: nextDef,
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWith);
        }
        else if (prod instanceof __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["f" /* Repetition */]) {
            // the order of alternatives is meaningful, FILO (Last path will be traversed first).
            var nextPathWithout = {
                idx: currIdx,
                def: Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["m" /* drop */])(currDef),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWithout);
            // required marker to avoid backtracking paths whose higher priority alternatives already matched
            possiblePaths.push(EXIT_ALTERNATIVE);
            // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?
            var nthRepetition = new __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["f" /* Repetition */]({
                definition: prod.definition,
                idx: prod.idx
            });
            var nextDef = prod.definition.concat([nthRepetition], Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["m" /* drop */])(currDef));
            var nextPathWith = {
                idx: currIdx,
                def: nextDef,
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWith);
        }
        else if (prod instanceof __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["b" /* Alternation */]) {
            // the order of alternatives is meaningful, FILO (Last path will be traversed first).
            for (var i = prod.definition.length - 1; i >= 0; i--) {
                var currAlt = prod.definition[i];
                var currAltPath = {
                    idx: currIdx,
                    def: currAlt.definition.concat(Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["m" /* drop */])(currDef)),
                    ruleStack: currRuleStack,
                    occurrenceStack: currOccurrenceStack
                };
                possiblePaths.push(currAltPath);
                possiblePaths.push(EXIT_ALTERNATIVE);
            }
        }
        else if (prod instanceof __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["c" /* Flat */]) {
            possiblePaths.push({
                idx: currIdx,
                def: prod.definition.concat(Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["m" /* drop */])(currDef)),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            });
        }
        else if (prod instanceof __WEBPACK_IMPORTED_MODULE_3__gast_gast_public__["j" /* Rule */]) {
            // last because we should only encounter at most a single one of these per invocation.
            possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));
        }
        else {
            throw Error("non exhaustive match");
        }
    }
    return result;
}
function expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {
    var newRuleStack = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["g" /* cloneArr */])(currRuleStack);
    newRuleStack.push(topRule.name);
    var newCurrOccurrenceStack = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["g" /* cloneArr */])(currOccurrenceStack);
    // top rule is always assumed to have been called with occurrence index 1
    newCurrOccurrenceStack.push(1);
    return {
        idx: currIdx,
        def: topRule.definition,
        ruleStack: newRuleStack,
        occurrenceStack: newCurrOccurrenceStack
    };
}
//# sourceMappingURL=interpreter.js.map

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var logger = exports.logger = {};

logger.enableDebugLog = false;

/* istanbul ignore next */
logger.warn = function (msg) {
  if (console) {
    if (console.warn) {
      console.warn(msg);
    } else if (console.log) {
      console.log(msg);
    }
  }

  return logger;
};

/* istanbul ignore next */
logger.debug = function (msg) {
  if (logger.enableDebugLog && console) {
    if (console.debug) {
      console.debug(msg);
    } else if (console.log) {
      console.log(msg);
    }
  }

  return logger;
};

/* istanbul ignore next */
logger.deprecate = function (fn, msg) {
  // Allow logging of deprecation
  var warned = false;
  function deprecated() {
    if (!warned) {
      logger.warn(msg);
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Exception = Exception;
exports.InvalidStateException = InvalidStateException;
exports.BadArgumentException = BadArgumentException;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function Exception(msg) {
  var _msg = msg || "Unexpected internal error";

  this.message = _msg;

  this.toString = function () {
    return _msg;
  };
  this.stack = new Error().stack;
}

Exception.prototype = Object.create(Error.prototype);
Exception.prototype.constructor = Exception;

function InvalidStateException() {
  Exception.apply(this, arguments);
}

InvalidStateException.prototype = Object.create(Exception.prototype);
InvalidStateException.prototype.constructor = InvalidStateException;

function BadArgumentException() {
  Exception.apply(this, arguments);
}

BadArgumentException.prototype = Object.create(Exception.prototype);
BadArgumentException.prototype.constructor = BadArgumentException;

// Used to cancel async operations that could resolve after a chart has been
// destroyed

var DestroyedChartError = exports.DestroyedChartError = function (_Error) {
  _inherits(DestroyedChartError, _Error);

  function DestroyedChartError(message) {
    _classCallCheck(this, DestroyedChartError);

    var _this = _possibleConstructorReturn(this, (DestroyedChartError.__proto__ || Object.getPrototypeOf(DestroyedChartError)).call(this, message));

    _this.name = "DestroyedChartError";
    _this.message = message || "Chart was destroyed before operation completed";
    return _this;
  }

  return DestroyedChartError;
}(Error);

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = bubbleMixin;

var _colorMixin = __webpack_require__(12);

var _colorMixin2 = _interopRequireDefault(_colorMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _core = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This Mixin provides reusable functionalities for any chart that needs to visualize data using bubbles.
 * @name bubbleMixin
 * @memberof dc
 * @mixin
 * @mixes dc.colorMixin
 * @param {Object} _chart
 * @return {dc.bubbleMixin}
 */
function bubbleMixin(_chart) {
  var _maxBubbleRelativeSize = 0.3;
  var _minBubbleRelativeSize = 0.004;

  /* OVERRIDE ---------------------------------------------------------------- */
  var _minRadiusWithLabel = 2;
  /* ------------------------------------------------------------------------- */

  _chart.BUBBLE_NODE_CLASS = "node";
  _chart.BUBBLE_CLASS = "bubble";
  _chart.MIN_RADIUS = 10;

  /* OVERRIDE ---------------------------------------------------------------- */
  _chart.accent = accentBubble;
  _chart.unAccent = unAccentBubble;
  /* ------------------------------------------------------------------------- */

  _chart = (0, _colorMixin2.default)(_chart);

  _chart.renderLabel(true);

  /* OVERRIDE ---------------------------------------------------------------- */
  _chart.setDataAsync(function (group, callbacks) {
    if (_chart.cap() !== undefined) {
      return group.topAsync(_chart.cap()).then(function (result) {
        callbacks(null, result);
      }).catch(function (error) {
        callbacks(error);
      });
    } else {
      group.allAsync(callbacks);
    }
  });
  /* ------------------------------------------------------------------------- */

  _chart.data(function (group) {
    /* OVERRIDE ---------------------------------------------------------------- */
    if (_chart.dataCache !== null) {
      return _chart.dataCache;
    } else {
      return group.top(_chart.cap() !== undefined ? _chart.cap() : Infinity);
    }
    /* ------------------------------------------------------------------------- */
  });

  var _r = _d2.default.scale.linear().domain([0, 100]);

  var _rValueAccessor = function _rValueAccessor(d) {
    return d.r;
  };

  /**
   * Get or set the bubble radius scale. By default the bubble chart uses
   * {@link https://github.com/mbostock/d3/wiki/Quantitative-Scales#linear d3.scale.linear().domain([0, 100])}
   * as its radius scale.
   * @name r
   * @memberof dc.bubbleMixin
   * @instance
   * @see {@link http://github.com/mbostock/d3/wiki/Scales d3.scale}
   * @param {d3.scale} [bubbleRadiusScale=d3.scale.linear().domain([0, 100])]
   * @return {d3.scale}
   * @return {dc.bubbleMixin}
   */
  _chart.r = function (bubbleRadiusScale) {
    if (!arguments.length) {
      return _r;
    }
    _r = bubbleRadiusScale;
    return _chart;
  };

  /**
   * Get or set the radius value accessor function. If set, the radius value accessor function will
   * be used to retrieve a data value for each bubble. The data retrieved then will be mapped using
   * the r scale to the actual bubble radius. This allows you to encode a data dimension using bubble
   * size.
   * @name radiusValueAccessor
   * @memberof dc.bubbleMixin
   * @instance
   * @param {Function} [radiusValueAccessor]
   * @return {Function}
   * @return {dc.bubbleMixin}
   */
  _chart.radiusValueAccessor = function (radiusValueAccessor) {
    if (!arguments.length) {
      return _rValueAccessor;
    }
    _rValueAccessor = radiusValueAccessor;
    return _chart;
  };

  _chart.rMin = function () {
    var min = _d2.default.min(_chart.data(), function (e) {
      return _chart.radiusValueAccessor()(e);
    });
    return min;
  };

  _chart.rMax = function () {
    var max = _d2.default.max(_chart.data(), function (e) {
      return _chart.radiusValueAccessor()(e);
    });
    return max;
  };

  _chart.bubbleR = function (d) {
    var value = _chart.radiusValueAccessor()(d);
    var r = _chart.r()(value);
    if (isNaN(r) || value <= 0) {
      r = 0;
    }
    return r;
  };

  var labelFunction = function labelFunction(d) {
    return _chart.label()(d);
  };

  var shouldLabel = function shouldLabel(d) {
    return _chart.bubbleR(d) > _minRadiusWithLabel;
  };

  var labelOpacity = function labelOpacity(d) {
    return shouldLabel(d) ? 1 : 0;
  };

  var labelPointerEvent = function labelPointerEvent(d) {
    return shouldLabel(d) ? "all" : "none";
  };

  _chart._doRenderLabel = function (bubbleGEnter) {
    if (_chart.renderLabel()) {
      var label = bubbleGEnter.select("text");

      if (label.empty()) {
        label = bubbleGEnter.append("text").attr("text-anchor", "middle").attr("dy", ".3em").on("click", _chart.onClick);
      }

      label.attr("opacity", 0).attr("pointer-events", labelPointerEvent).html(labelFunction);

      (0, _core.transition)(label, _chart.transitionDuration()).attr("opacity", 1);

      _chart.hideOverlappedLabels();
    }
  };

  _chart.doUpdateLabels = function (bubbleGEnter) {
    _chart._doRenderLabel(bubbleGEnter);
  };

  var titleFunction = function titleFunction(d) {
    return _chart.title()(d);
  };

  _chart._doRenderTitles = function (g) {
    if (_chart.renderTitle()) {
      var title = g.select("title");

      if (title.empty()) {
        g.append("title").text(titleFunction);
      }
    }
  };

  _chart.doUpdateTitles = function (g) {
    if (_chart.renderTitle()) {
      g.selectAll("title").text(titleFunction);
    }
  };

  /**
   * Get or set the minimum radius. This will be used to initialize the radius scale's range.
   * @name minRadius
   * @memberof dc.bubbleMixin
   * @instance
   * @param {Number} [radius=10]
   * @return {Number}
   * @return {dc.bubbleMixin}
   */
  _chart.minRadius = function (radius) {
    if (!arguments.length) {
      return _chart.MIN_RADIUS;
    }
    _chart.MIN_RADIUS = radius;
    return _chart;
  };

  /**
   * Get or set the minimum radius for label rendering. If a bubble's radius is less than this value
   * then no label will be rendered.
   * @name minRadiusWithLabel
   * @memberof dc.bubbleMixin
   * @instance
   * @param {Number} [radius=10]
   * @return {Number}
   * @return {dc.bubbleMixin}
   */

  _chart.minRadiusWithLabel = function (radius) {
    if (!arguments.length) {
      return _minRadiusWithLabel;
    }
    _minRadiusWithLabel = radius;
    return _chart;
  };

  /**
   * Get or set the maximum relative size of a bubble to the length of x axis. This value is useful
   * when the difference in radius between bubbles is too great.
   * @name maxBubbleRelativeSize
   * @memberof dc.bubbleMixin
   * @instance
   * @param {Number} [relativeSize=0.3]
   * @return {Number}
   * @return {dc.bubbleMixin}
   */
  _chart.maxBubbleRelativeSize = function (relativeSize) {
    if (!arguments.length) {
      return _maxBubbleRelativeSize;
    }
    _maxBubbleRelativeSize = relativeSize;
    return _chart;
  };

  _chart.minBubbleRelativeSize = function (relativeSize) {
    if (!arguments.length) {
      return _minBubbleRelativeSize;
    }
    _minBubbleRelativeSize = relativeSize;
    return _chart;
  };

  _chart.fadeDeselectedArea = function () {
    if (_chart.hasFilter()) {
      _chart.selectAll("g." + _chart.BUBBLE_NODE_CLASS).each(function (d) {
        if (_chart.isSelectedNode(d)) {
          _chart.highlightSelected(this);
        } else {
          _chart.fadeDeselected(this);
        }
      });
    } else {
      _chart.selectAll("g." + _chart.BUBBLE_NODE_CLASS).each(function () {
        _chart.resetHighlight(this);
      });
    }
  };

  _chart.isSelectedNode = function (d) {
    /* OVERRIDE -----------------------------------------------------------------*/
    return _chart.hasFilter(d.key0) ^ _chart.filtersInverse();
    /* --------------------------------------------------------------------------*/
  };

  _chart.onClick = function (d) {
    /* OVERRIDE -----------------------------------------------------------------*/
    // need to match with the new filter structure
    var filter = Array.isArray(d.key0) ? d.key0.map(function (k) {
      return k.hasOwnProperty("value") ? k.value : k;
    }) : d.key0;
    /* --------------------------------------------------------------------------*/
    _chart.handleFilterClick(_d2.default.event, filter);
    _chart.updatePopup(d);
  };

  /* OVERRIDE -----------------------------------------------------------------*/
  function accentBubble(label) {
    _chart.selectAll("g." + _chart.BUBBLE_NODE_CLASS).each(function (d) {
      if (d.key0 === label) {
        _chart.accentSelected(this);
      }
    });
  }

  function unAccentBubble(label) {
    _chart.selectAll("g." + _chart.BUBBLE_NODE_CLASS).each(function (d) {
      if (d.key0 === label) {
        _chart.unAccentSelected(this);
      }
    });
  }
  /* --------------------------------------------------------------------------*/

  return _chart;
}

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = stackMixin;

var _binningHelpers = __webpack_require__(22);

var _utils = __webpack_require__(4);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _core = __webpack_require__(3);

var _multipleKeyAccessors = __webpack_require__(183);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Stack Mixin is an mixin that provides cross-chart support of stackability using d3.layout.stack.
 * @name stackMixin
 * @memberof dc
 * @mixin
 * @param {Object} _chart
 * @return {dc.stackMixin}
 */

function stackMixin(_chart) {
  function prepareValues(layer, layerIdx) {
    var valAccessor = layer.accessor || _chart.valueAccessor();
    layer.name = String(layer.name || "series_" + (layerIdx + 1));
    layer.layer = layer.name;
    layer.idx = layerIdx;

    /* OVERRIDE ---------------------------------------------------------------- */
    // WARNING: probably destroys stack functionality: find workaround
    var preValues = _chart.dataCache != null ? _chart.dataCache : layer.group.all();
    // layer.values = layer.group.all().map(function (d, i) {
    layer.values = preValues.map(function (d, i) {
      return {
        x: _chart.keyAccessor()(d, i),
        y: layer.hidden ? null : valAccessor(d, i) || 0,
        idx: layerIdx,
        data: d,
        layer: layer.name,
        hidden: layer.hidden
      };
    });
    /* ------------------------------------------------------------------------- */
    layer.values = layer.values.filter(domainFilter());
    return layer.values;
  }

  var _stackLayout = _d2.default.layout.stack().values(prepareValues);

  var _stack = [];
  var _titles = {};

  var _hidableStacks = false;
  var _colorByLayerId = false;

  function domainFilter() {
    if (!_chart.x()) {
      return _d2.default.functor(true);
    }
    if (_chart.isOrdinal()) {
      // TODO #416
      // var domainSet = d3.set(xDomain);
      return function () {
        return true; // domainSet.has(p.x);
      };
    }
    if (_chart.elasticX()) {
      return function () {
        return true;
      };
    }
    return function (p) {
      return true;
    };
  }

  /**
   * Stack a new crossfilter group onto this chart with an optional custom value accessor. All stacks
   * in the same chart will share the same key accessor and therefore the same set of keys.
   *
   * For example, in a stacked bar chart, the bars of each stack will be positioned using the same set
   * of keys on the x axis, while stacked vertically. If name is specified then it will be used to
   * generate the legend label.
   * @name stack
   * @memberof dc.stackMixin
   * @instance
   * @see {@link https://github.com/square/crossfilter/wiki/API-Reference#group-map-reduce crossfilter.group}
   * @example
   * // stack group using default accessor
   * chart.stack(valueSumGroup)
   * // stack group using custom accessor
   * .stack(avgByDayGroup, function(d){return d.value.avgByDay;});
   * @param {crossfilter.group} group
   * @param {String} [name]
   * @param {Function} [accessor]
   * @return {Array<{group: crossfilter.group, name: String, accessor: Function}>}
   * @return {dc.stackMixin}
   */
  _chart.stack = function (group, name, accessor) {
    if (!arguments.length) {
      return _stack;
    }

    if (arguments.length <= 2) {
      accessor = name;
    }

    var layer = { group: group };
    if (typeof name === "string") {
      layer.name = name;
    }
    if (typeof accessor === "function") {
      layer.accessor = accessor;
    }
    _stack.push(layer);

    return _chart;
  };

  (0, _core.override)(_chart, "group", function (g, n, f) {
    if (!arguments.length) {
      return _chart._group();
    }
    _stack = [];
    _titles = {};
    _chart.stack(g, n);
    if (f) {
      _chart.valueAccessor(f);
    }
    return _chart._group(g, n);
  });

  /**
   * Allow named stacks to be hidden or shown by clicking on legend items.
   * This does not affect the behavior of hideStack or showStack.
   * @name hidableStacks
   * @memberof dc.stackMixin
   * @instance
   * @param {Boolean} [hidableStacks=false]
   * @return {Boolean}
   * @return {dc.stackMixin}
   */
  _chart.hidableStacks = function (hidableStacks) {
    if (!arguments.length) {
      return _hidableStacks;
    }
    _hidableStacks = hidableStacks;
    return _chart;
  };

  function findLayerByName(n) {
    var i = _stack.map((0, _utils.pluck)("name")).indexOf(n);
    return _stack[i];
  }

  /**
   * Hide all stacks on the chart with the given name.
   * The chart must be re-rendered for this change to appear.
   * @name hideStack
   * @memberof dc.stackMixin
   * @instance
   * @param {String} stackName
   * @return {dc.stackMixin}
   */
  _chart.hideStack = function (stackName) {
    var layer = findLayerByName(stackName);
    if (layer) {
      layer.hidden = true;
    }
    return _chart;
  };

  /**
   * Show all stacks on the chart with the given name.
   * The chart must be re-rendered for this change to appear.
   * @name showStack
   * @memberof dc.stackMixin
   * @instance
   * @param {String} stackName
   * @return {dc.stackMixin}
   */
  _chart.showStack = function (stackName) {
    var layer = findLayerByName(stackName);
    if (layer) {
      layer.hidden = false;
    }
    return _chart;
  };

  _chart.getValueAccessorByIndex = function (index) {
    return _stack[index].accessor || _chart.valueAccessor();
  };

  _chart.yAxisMin = function () {
    var min = _d2.default.min(flattenStack(), function (p) {
      /* OVERRIDE ---------------------------------------------------------------- */
      if (_chart.renderArea === undefined || _chart.renderArea()) {
        return p.y + p.y0 < p.y0 ? p.y + p.y0 : p.y0;
      } else {
        return p.y;
      }
    });
    /* ------------------------------------------------------------------------- */

    return _utils.utils.subtract(min, _chart.yAxisPadding());
  };

  _chart.yAxisMax = function () {
    var max = _d2.default.max(flattenStack(), function (p) {
      /* OVERRIDE ---------------------------------------------------------------- */
      if (_chart.renderArea === undefined || _chart.renderArea()) {
        return p.y + p.y0;
      } else {
        return p.y;
      }
      /* ------------------------------------------------------------------------- */
    });

    return _utils.utils.add(max, _chart.yAxisPadding());
  };

  function flattenStack() {
    var valueses = _chart.data().map(function (layer) {
      return layer.values;
    });
    return Array.prototype.concat.apply([], valueses);
  }

  _chart.xAxisMin = function () {
    return _utils.utils.subtract(_d2.default.min(flattenStack(), _utils.minVal), _chart.xAxisPadding());
  };

  _chart.xAxisMax = function () {
    return _utils.utils.add(_d2.default.max(flattenStack(), _utils.maxVal), _chart.xAxisPadding());
  };

  /**
   * Set or get the title function. Chart class will use this function to render svg title (usually interpreted by
   * browser as tooltips) for each child element in the chart, i.e. a slice in a pie chart or a bubble in a bubble chart.
   * Almost every chart supports title function however in grid coordinate chart you need to turn off brush in order to
   * use title otherwise the brush layer will block tooltip trigger.
   *
   * If the first argument is a stack name, the title function will get or set the title for that stack. If stackName
   * is not provided, the first stack is implied.
   * @name title
   * @memberof dc.stackMixin
   * @instance
   * @example
   * // set a title function on 'first stack'
   * chart.title('first stack', function(d) { return d.key + ': ' + d.value; });
   * // get a title function from 'second stack'
   * var secondTitleFunction = chart.title('second stack');
   * @param {String} [stackName]
   * @param {Function} [titleAccessor]
   * @return {String}
   * @return {dc.stackMixin}
   */
  (0, _core.override)(_chart, "title", function (stackName, titleAccessor) {
    if (!stackName) {
      return _chart._title();
    }

    if (typeof stackName === "function") {
      return _chart._title(stackName);
    }
    if (stackName === _chart._groupName && typeof titleAccessor === "function") {
      return _chart._title(titleAccessor);
    }

    if (typeof titleAccessor !== "function") {
      return _titles[stackName] || _chart._title();
    }

    _titles[stackName] = titleAccessor;

    return _chart;
  });

  /**
   * Gets or sets the stack layout algorithm, which computes a baseline for each stack and
   * propagates it to the next
   * @name stackLayout
   * @memberof dc.stackMixin
   * @instance
   * @see {@link http://github.com/mbostock/d3/wiki/Stack-Layout d3.layout.stack}
   * @param {Function} [stack=d3.layout.stack]
   * @return {Function}
   * @return {dc.stackMixin}
   */
  _chart.stackLayout = function (stack) {
    if (!arguments.length) {
      return _stackLayout;
    }
    _stackLayout = stack;
    return _chart;
  };

  function visability(l) {
    return !l.hidden;
  }

  _chart.data(function () {
    var layers = _stack.filter(visability);
    return layers.length ? _chart.stackLayout()(layers) : [];
  });

  _chart._ordinalXDomain = function () {
    var flat = flattenStack().map((0, _utils.pluck)("data"));
    var ordered = _chart._computeOrderedGroups(flat);
    return ordered.map(_chart.keyAccessor());
  };

  _chart.colorByLayerId = function (_) {
    if (!arguments.length) {
      return _colorByLayerId;
    }
    _colorByLayerId = _;
    return _chart;
  };

  _chart.colorAccessor(function (d) {
    /* OVERRIDE ---------------------------------------------------------------- */
    var layer = null;
    if (_colorByLayerId) {
      layer = this.idx;
    } else {
      layer = this.layer || this.name || d.name || d.layer;
    }
    /* ------------------------------------------------------------------------- */
    return layer;
  });

  _chart.legendables = function () {
    return _stack.map(function (layer, i) {
      return {
        chart: _chart,
        name: layer.name,
        hidden: layer.hidden || false,
        color: _chart.getColor.call(layer, layer.values, i)
      };
    });
  };

  _chart.isLegendableHidden = function (d) {
    var layer = findLayerByName(d.name);
    return layer ? layer.hidden : false;
  };

  _chart.legendToggle = function (d) {
    if (_hidableStacks) {
      if (_chart.isLegendableHidden(d)) {
        _chart.showStack(d.name);
      } else {
        _chart.hideStack(d.name);
      }
      _chart.renderGroup();
    }
  };

  (0, _core.override)(_chart, "binParams", function (binParams) {
    if (!arguments.length) {
      return _chart.group().binParams();
    }

    binParams = Array.isArray(binParams) ? binParams : [binParams];

    var parsedBinParams = binParams.map(function (param) {
      if (param) {
        var _param$timeBin = param.timeBin,
            timeBin = _param$timeBin === undefined ? "auto" : _param$timeBin,
            binBounds = param.binBounds,
            numBins = param.numBins,
            auto = param.auto;

        var extract = param.extract || false;
        var isDate = binBounds[0] instanceof Date;
        if (isDate && timeBin && !extract) {
          var bounds = binBounds.map(function (date) {
            return date.getTime();
          });
          return Object.assign({}, param, {
            extract: extract,
            timeBin: (0, _binningHelpers.checkIfTimeBinInRange)(bounds, timeBin, numBins),
            binBounds: binBounds.slice()
          });
        } else {
          return param;
        }
      }
      return null;
    });

    return (0, _binningHelpers.createBinParams)(_chart, parsedBinParams);
  });

  _chart.keyAccessor(_multipleKeyAccessors.multipleKeysAccessorForStack);

  return _chart;
}

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = lockAxisMixin;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _formattingHelpers = __webpack_require__(10);

var _moment = __webpack_require__(0);

var _moment2 = _interopRequireDefault(_moment);

var _utils = __webpack_require__(4);

var _heatmap = __webpack_require__(187);

var _binningHelpers = __webpack_require__(22);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CHART_HEIGHT = 0.75;
var TOGGLE_SIZE = 24;
var NON_INDEX = -1;
var RETURN_KEY = 13;
var DATE_FORMAT = "MM-DD-YYYY";

function formatVal(val) {
  return val instanceof Date ? _d2.default.time.format.utc("%m-%d-%Y")(val) : (0, _formattingHelpers.formatDataValue)(val);
}

function parseFloatStrict(value) {
  if (/^(\-|\+)?([0-9]+(\.[0-9]+)?)$/.test(value)) {
    return Number(value);
  } else {
    return NaN;
  }
}

function lockAxisMixin(chart) {
  var events = ["elasticX", "elasticY", "xDomain", "yDomain"];
  var _listeners = _d2.default.dispatch.apply(_d2.default, events);
  var _on = chart.on.bind(chart);

  chart.on = function (event, listener) {
    var baseEvent = event.includes(".") ? event.slice(0, event.indexOf(".")) : event;
    if (events.indexOf(baseEvent) === NON_INDEX) {
      _on(event, listener);
    } else {
      _listeners.on(event, listener);
    }
    return chart;
  };

  chart._invokeelasticYListener = function () {
    var scatterLayer = chart.getLayer && chart.getLayer("backendScatter");
    if (chart.elasticY && chart.elasticY() && scatterLayer) {
      scatterLayer.yDim().filter([chart.originalYMinMax]);
      chart.y().domain(chart.originalYMinMax);
    }
    _listeners.elasticY(chart);
  };
  chart._invokeYDomainListener = function (minMax) {
    _listeners.yDomain(chart, minMax);
  };

  chart._invokeelasticXListener = function () {
    var scatterLayer = chart.getLayer && chart.getLayer("backendScatter");
    if (chart.elasticX && chart.elasticX() && scatterLayer) {
      scatterLayer.xDim().filter([chart.originalXMinMax]);
      chart.x().domain(chart.originalXMinMax);
    }
    _listeners.elasticX(chart);
  };
  chart._invokeXDomainListener = function (minMax) {
    _listeners.xDomain(chart, minMax);
  };

  function handleRangeFocus(chart, minMax) {
    if (chart.filters().length) {
      if (minMax[0] <= chart.filter()[0] && chart.filter()[1] <= minMax[1]) {
        var preserveFilter = chart.filter().slice();
        chart.rangeChart().replaceFilter(minMax);
        chart.replaceFilter(preserveFilter);
      } else {
        chart.rangeChart().replaceFilter(minMax);
      }
    } else {
      chart.rangeChart().filter(minMax);
    }
  }

  function setAxis(type, minMax) {
    if (type === "y") {
      chart.elasticY(false);
      chart._invokeelasticYListener();
      chart.y().domain(minMax);
      chart._invokeYDomainListener(minMax);
    } else {
      if (chart.rangeChart && chart.rangeChart()) {
        return handleRangeFocus(chart, minMax);
      }

      chart.elasticX(false);
      chart._invokeelasticXListener();
      chart.x().domain(minMax);
      chart._invokeXDomainListener(minMax);
      if (chart.focusChart && chart.focusChart()) {
        chart.focusChart().elasticX(false);
        chart.focusChart()._invokeelasticXListener();
        chart.focusChart()._invokeXDomainListener(minMax);
        if (!chart.filters().length) {
          chart.focusChart().x().domain(minMax);
        }
        chart.focusChart().xOriginalDomain(minMax);
        chart.focusChart().renderAsync();
      }
    }
    chart.renderAsync();
  }

  function toggleLock(type) {
    if (type === "y") {
      chart.elasticY(!chart.elasticY());
      var yDomain = chart.y().domain().slice(0);
      chart._invokeYDomainListener(chart.elasticY() ? chart.originalYMinMax || yDomain : yDomain);
      chart._invokeelasticYListener();
    } else {
      chart.elasticX(!chart.elasticX());
      var xDomain = chart.x().domain().slice();
      chart._invokeXDomainListener(chart.elasticX() ? chart.originalXMinMax || xDomain : xDomain);
      chart._invokeelasticXListener();
      if (chart.focusChart && chart.focusChart()) {
        chart.focusChart().elasticX(!chart.focusChart().elasticX());
        if (chart.elasticX()) {
          chart.focusChart()._invokeXDomainListener(null);
        } else {
          chart.focusChart()._invokeXDomainListener(chart.x().domain().slice());
        }
        chart.focusChart()._invokeelasticXListener();
        chart.focusChart().redrawAsync();
      }
    }
    chart.redrawAsync();
  }

  var valueOutOfBounds = function valueOutOfBounds(value, originalMinMax) {
    return originalMinMax && (value[0] < originalMinMax[0] || value[1] < originalMinMax[0] || value[0] > originalMinMax[1] || value[1] > originalMinMax[1]);
  };

  function updateMinMax(type, value) {
    var valOutOfBounds = valueOutOfBounds(value, type === "x" ? chart.originalXMinMax : chart.originalYMinMax);
    if (valOutOfBounds || value.some(isNaN) || value[1] <= value[0] || type === "x" && chart.rangeChart && chart.rangeChart() && (value[0] < chart.rangeChart().x().domain()[0] || value[1] > chart.rangeChart().x().domain()[1])) {
      chart.prepareLockAxis(type);
    } else {
      setAxis(type, value);
    }
  }

  chart.prepareLockAxis = function () {
    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "y";

    var data = chart.data && chart.data();
    var firstNonNullDatum = (0, _binningHelpers.getFirstNonNullDatumForAxis)(data, type);
    var heatDataIncompatible = chart.isHeatMap && data && Array.isArray(data) && firstNonNullDatum && (type === "y" ? (0, _heatmap.yAxisDataIsNonNumerical)(firstNonNullDatum) : (0, _heatmap.xAxisDataIsNonNumerical)(firstNonNullDatum));
    if (chart.focusChart && chart.focusChart() && type === "y" || heatDataIncompatible) {
      return;
    }

    var chartLeftPixels = chart.dockedAxesSize && chart.dockedAxesSize() ? chart.dockedAxesSize().left : chart.margins().left;
    var chartBottomPixels = chart.dockedAxesSize && chart.dockedAxesSize() ? chart.dockedAxesSize().bottom : chart.margins().bottom;

    var iconPosition = {
      left: type === "y" ? chartLeftPixels - TOGGLE_SIZE / 2 + "px" : chart.width() - chart.margins().right + "px",
      top: type === "y" ? chart.margins().top - TOGGLE_SIZE + "px" : chart.height() - chartBottomPixels + "px"
    };

    var inputsPosition = {
      minLeft: type === "y" ? chartLeftPixels + "px" : chartLeftPixels + "px",
      minTop: chart.height() - chartBottomPixels + "px",
      maxLeft: type === "y" ? chartLeftPixels + "px" : chart.width() - chart.margins().right + "px",
      maxTop: type === "y" ? chart.margins().top + "px" : chart.height() - chartBottomPixels + "px"
    };

    var hitBoxDim = {
      top: type === "y" ? 0 : chart.height() - chartBottomPixels /* chart.margins().bottom*/
      + "px",
      left: type === "y" ? 0 : chartLeftPixels /* chart.margins().left*/ + "px",
      width: type === "y" ? chartLeftPixels + "px" : chart.width() - chartLeftPixels + "px",
      height: type === "y" ? chart.height() + "px" : chartBottomPixels /* chart.margins().bottom*/ + "px"
    };

    var minMax = chart[type]().domain().slice();

    // Horrible hack to ensure the inputs aren't inverted from whatever order
    //  the Y axis decides to display.  Mea culpa.
    var shouldFlipYMinMax = false;
    var isHeatY = chart.isHeatMap && type === "y";
    if (isHeatY) {
      var _data = chart.data && chart.data();
      var rowOrdering = chart.shouldSortYAxisDescending(_data) ? _utils.utils.nullsLast(_d2.default.descending) : _utils.utils.nullsFirst(_d2.default.ascending);
      var rows = chart.rows() || _data.map(chart.valueAccessor());
      rows = rows.sort(rowOrdering);
      var firstRowValue = rows.find(function (r) {
        return r !== null;
      });
      var lastRowValue = null;
      for (var i = rows.length - 1; i >= 0; i--) {
        if (rows[i] !== null) {
          lastRowValue = rows[i];
          break;
        }
      }
      var minMaxIsAscending = minMax[0] < minMax[1];
      var rowsAreAscending = firstRowValue < lastRowValue;
      shouldFlipYMinMax = firstRowValue !== lastRowValue && !minMaxIsAscending === rowsAreAscending;
      if (shouldFlipYMinMax) {
        minMax.reverse();
      }
    }

    chart.root().selectAll(".axis-lock.type-" + type).remove();

    var lockWrapper = chart.root().append("div").attr("class", "axis-lock type-" + type);

    lockWrapper.append("div").attr("class", "hit-box").style("width", hitBoxDim.width).style("height", hitBoxDim.height).style("top", hitBoxDim.top).style("left", hitBoxDim.left);

    // Occasionally, the x-axis domain of a chart can be empty due to a global
    // or chart filter. mapd-charting will see the domain extent as [NaN, NaN],
    // and we don't want the user to lock the chart with this faulty extent. So,
    // we're going to use this funciton to see if we should disable the axis
    // lock feature. Conditions:
    //  1. Only the x-axis lock togggle can be disabled (for now?)
    //  2. We only want to prevent the user from locking the x-axis, not unlocking it
    //  3. We want to disable it if any value in the extent === NaN
    var shouldDisableAxisLock = function shouldDisableAxisLock() {
      if (type === "x" && chart.elasticX()) {
        var xDomain = chart.x().domain().slice();
        return isNaN(xDomain[0]) || isNaN(xDomain[1]);
      }
      return false;
    };

    lockWrapper.append("div").attr("class", "lock-toggle type-" + type).classed("is-locked", function () {
      return type === "y" ? !chart.elasticY() : !chart.elasticX();
    }).classed("disabled", shouldDisableAxisLock).style("top", iconPosition.top).style("left", iconPosition.left).on("click", function () {
      if (!shouldDisableAxisLock()) {
        toggleLock(type);
      }
    });

    if (chart.rangeChart && chart.rangeChart() && type === "x") {
      lockWrapper.selectAll(".lock-toggle.type-x").remove();
    }

    var axisMax = lockWrapper.append("div").attr("class", "axis-input max").style("top", inputsPosition.maxTop).style("left", inputsPosition.maxLeft);

    axisMax.append("input").attr("pattern", "[0-9-]").attr("value", formatVal(minMax[1])).on("focus", function () {
      this.select();
    }).on("change", function () {
      var max = minMax[1];
      var min = minMax[0];
      var val = max instanceof Date ? (0, _moment2.default)(this.value, DATE_FORMAT).toDate() : parseFloatStrict(this.value.replace(/,/g, ""));
      updateMinMax(type, shouldFlipYMinMax ? [val, min] : [min, val]);
    }).on("keyup", function () {
      if (_d2.default.event.keyCode === RETURN_KEY) {
        this.blur();
      }
    });

    var maxVal = formatVal(minMax[1]);
    axisMax.append("div").text(maxVal);

    var axisMin = lockWrapper.append("div").attr("class", "axis-input min").style("top", inputsPosition.minTop).style("left", inputsPosition.minLeft);

    axisMin.append("input").attr("value", formatVal(minMax[0])).on("focus", function () {
      this.select();
    }).on("change", function () {
      var max = minMax[1];
      var min = minMax[0];
      var val = min instanceof Date ? (0, _moment2.default)(this.value, DATE_FORMAT).toDate() : parseFloatStrict(this.value.replace(/,/g, ""));
      updateMinMax(type, shouldFlipYMinMax ? [max, val] : [val, max]);
    }).on("keyup", function () {
      if (_d2.default.event.keyCode === RETURN_KEY) {
        this.blur();
      }
    });

    axisMin.append("div").text(formatVal(minMax[0]));
  };

  return chart;
}

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = mapMixin;

var _d2 = __webpack_require__(1);

var _d3 = _interopRequireDefault(_d2);

var _lodash = __webpack_require__(23);

var _ = _interopRequireWildcard(_lodash);

var _coreAsync = __webpack_require__(5);

var _utils = __webpack_require__(4);

var _rasterDrawMixin = __webpack_require__(189);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function valuesOb(obj) {
  return Object.keys(obj).map(function (key) {
    return obj[key];
  });
}

function mapMixin(_chart, chartDivId, _mapboxgl) {
  var mixinDraw = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  var DEFAULT_ZOOM_LEVEL = 15;
  var EASE_DURATION_MS = 1500;
  var SMALL_AMOUNT = 0.00001; // Mapbox doesn't like coords being exactly on the edge.
  var LONMAX = 180 - SMALL_AMOUNT;
  var LONMIN = -180 + SMALL_AMOUNT;
  var LATMAX = 85 - SMALL_AMOUNT;
  var LATMIN = -85 + SMALL_AMOUNT;

  var _mapboxgl = typeof _mapboxgl === "undefined" ? mapboxgl : _mapboxgl;
  var _map = null;
  var _mapboxAccessToken = null;
  var _lastWidth = null;
  var _lastHeight = null;
  var _mapId = chartDivId;

  _chart._xDimName = null;
  _chart._yDimName = null;
  _chart._viewBoxDimName = null;
  var hasAppliedInitialBounds = false;
  var _hasRendered = false;
  var _activeLayer = null;
  var _mapInitted = false;
  var _xDim = null;
  var _yDim = null;
  var _viewBoxDim = null;
  var _lastMapMoveType = null;
  var _lastMapUpdateTime = 0;
  var _isFirstMoveEvent = true;
  var _mapUpdateInterval = 100; // default
  var _mapStyle = "mapbox://styles/mapbox/light-v9";
  var _center = [0, 30];
  var _zoom = 1;
  var _attribLocation = "bottom-right";

  var _popupFunction = null;
  var _colorBy = null;
  var _mouseLeave = false;
  var _useLonLat = true;
  _chart._minCoord = null;
  _chart._maxCoord = null;
  _chart._reProjMapbox = true;

  var _clientClickX = null;
  var _clientClickY = null;

  var _arr = [[LONMIN, LATMIN], [LONMAX, LATMAX]];

  var _llb = _mapboxgl.LngLatBounds.convert(_arr);
  var _initialBounds = _llb;

  var _geocoder = null;

  var _minMaxCache = {};
  var _interactionsEnabled = true;

  _chart.useLonLat = function (useLonLat) {
    if (!arguments.length) {
      return _useLonLat;
    }
    _useLonLat = useLonLat;
    return _chart;
  };
  _chart.map = function () {
    return _map;
  };

  _chart.lonMin = function () {
    return LONMIN;
  };

  _chart.lonMax = function () {
    return LONMAX;
  };

  _chart.latMin = function () {
    return LATMIN;
  };

  _chart.latMax = function () {
    return LATMAX;
  };

  _chart.setInitialBounds = function (newBounds) {
    _initialBounds = newBounds;
  };

  function makeBoundsArrSafe(_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        _ref2$ = _slicedToArray(_ref2[0], 2),
        lowerLon = _ref2$[0],
        lowerLat = _ref2$[1],
        _ref2$2 = _slicedToArray(_ref2[1], 2),
        upperLon = _ref2$2[0],
        upperLat = _ref2$2[1];

    return [[Math.max(LONMIN, lowerLon), Math.max(LATMIN, lowerLat)], [Math.min(LONMAX, upperLon), Math.min(LATMAX, upperLat)]];
  }

  _chart.convertBounds = function (arr) {
    if (!_mapboxgl) {
      throw new Error("Cannot convert bounds: mapboxgl uninitialized.");
    }
    return _mapboxgl.LngLatBounds.convert(makeBoundsArrSafe(arr));
  };

  _chart.enableInteractions = function (enableInteractions) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!arguments.length) {
      return _interactionsEnabled;
    }

    var mapboxInteractionProps = ["scrollZoom", "boxZoom", "dragPan", "keyboard", "doubleClickZoom"];
    _interactionsEnabled = Boolean(enableInteractions);

    if (_mapInitted) {
      mapboxInteractionProps.forEach(function (prop) {
        if (_map[prop]) {
          var enable = typeof opts[prop] !== "undefined" ? Boolean(opts[prop]) : _interactionsEnabled;
          if (enable) {
            _map[prop].enable();
          } else {
            _map[prop].disable();

            if (prop === "dragPan") {
              // force a clear of the current event state on the map
              // to fully disable pans
              _map[prop]._onMouseUp({
                button: 0
              });
            }
          }
        }
      });
    }
    return _chart;
  };

  _chart.getDataRenderBounds = function () {
    var bounds = _map.getBounds();

    if (!hasAppliedInitialBounds) {
      _chart.setFilterBounds(bounds);
    }

    var renderBounds = [valuesOb(bounds.getNorthWest()), valuesOb(bounds.getNorthEast()), valuesOb(bounds.getSouthEast()), valuesOb(bounds.getSouthWest())];

    if (!_useLonLat) {
      renderBounds = [_chart.conv4326To900913(renderBounds[0]), _chart.conv4326To900913(renderBounds[1]), _chart.conv4326To900913(renderBounds[2]), _chart.conv4326To900913(renderBounds[3])];
    }
    hasAppliedInitialBounds = true;
    return renderBounds;
  };

  _chart.xDim = function (xDim) {
    if (!arguments.length) {
      return _xDim;
    }
    _xDim = xDim;
    if (_xDim) {
      _chart._xDimName = _xDim.value()[0];
    }
    return _chart;
  };

  _chart.yDim = function (yDim) {
    if (!arguments.length) {
      return _yDim;
    }
    _yDim = yDim;
    if (_yDim) {
      _chart._yDimName = _yDim.value()[0];
    }
    return _chart;
  };

  _chart.viewBoxDim = function (viewBoxDim) {
    if (!arguments.length) {
      return _viewBoxDim;
    }
    _viewBoxDim = viewBoxDim;
    if (_viewBoxDim) {
      _chart._viewBoxDimName = _viewBoxDim.value()[0];
    }
    return _chart;
  };

  _chart.resetLayer = function () {
    if (typeof _chart._resetRenderBounds === "function") {
      _chart._resetRenderBounds();
    }

    _activeLayer = null;
  };

  _chart.colorBy = function (_) {
    if (!arguments.length) {
      return _colorBy;
    }
    _colorBy = _;
    return _chart;
  };

  _chart.mapUpdateInterval = function (mapUpdateInterval) {
    if (!arguments.length) {
      return _mapUpdateInterval;
    }
    _mapUpdateInterval = mapUpdateInterval;
    return _chart;
  };

  _chart.conv900913To4326X = function (x) {
    return x / 111319.490778;
  };

  _chart.conv900913To4326Y = function (y) {
    return 57.295779513 * (2 * Math.atan(Math.exp(y / 6378136.99911)) - 1.570796327);
  };

  _chart.conv900913To4326 = function (coord) {
    return [_chart.conv900913To4326X(coord[0]), _chart.conv900913To4326Y(coord[1])];
  };

  _chart.conv4326To900913X = function (x) {
    return x * 111319.490778;
  };

  _chart.conv4326To900913Y = function (y) {
    return 6378136.99911 * Math.log(Math.tan(0.00872664626 * y + 0.785398163397));
  };

  _chart.conv4326To900913 = function (coord) {
    return [_chart.conv4326To900913X(coord[0]), _chart.conv4326To900913Y(coord[1])];
  };

  function onLoad(e) {
    if (_geocoder) {
      initGeocoder();
    }
    initMouseLatLonCoordinate();
  }

  // if shiftToZoom is enabled, then we've added an event handler on mouseDown.
  // if we click while holding shift, then enable the zoom/pan handlers. And if not,
  // disable them.
  //
  // and why don't we just do it in the move handler? Because once we've disabled drag, we need
  // a way to re-enable it. Ideally, we'd just stop the event from firing the default actions, but
  // that doesn't seem to handle it. So here we are.
  function onMouseDownCheckForShiftToZoom(e) {
    _map.boxZoom.disable();
    if (!e.originalEvent.shiftKey) {
      _map.scrollZoom.disable();
      _map.dragPan.disable();
    } else {
      _map.scrollZoom.enable();
      _map.dragPan.enable();
    }
  }

  function onMapMove(e) {
    if (_chart.shiftToZoom() && (e.originalEvent && !e.originalEvent.shiftKey || e.type === "moveend")) {
      _map.scrollZoom.disable();
      _map.dragPan.disable();
      return;
    } else {
      _map.dragPan.enable();
      _map.scrollZoom.enable();
    }

    if (e.type === "moveend" && _lastMapMoveType === "moveend" || !_hasRendered || e.skipRedraw) {
      return;
    }

    _lastMapMoveType = e.type;
    var curTime = new Date().getTime();

    var bounds = _map.getBounds();

    if (!_useLonLat) {
      _chart._minCoord = _chart.conv4326To900913([bounds._sw.lng, bounds._sw.lat]);
      _chart._maxCoord = _chart.conv4326To900913([bounds._ne.lng, bounds._ne.lat]);
    } else {
      _chart._minCoord = [bounds._sw.lng, bounds._sw.lat];
      _chart._maxCoord = [bounds._ne.lng, bounds._ne.lat];
    }

    if (e.type !== "moveend") {
      if (_isFirstMoveEvent) {
        _lastMapUpdateTime = curTime;
        _isFirstMoveEvent = false;
      }
      if (_mapUpdateInterval === Infinity || curTime - _lastMapUpdateTime < _mapUpdateInterval) {
        return;
      }
    } else if (e.type === "moveend") {
      _isFirstMoveEvent = true;
    }
    _lastMapUpdateTime = curTime;

    var redrawall = false;
    if (typeof _chart.getLayers === "function") {
      _chart.getLayers().forEach(function (layer) {
        if (typeof layer.xDim === "function" && typeof layer.yDim === "function") {
          var xdim = layer.xDim();
          var ydim = layer.yDim();
          if (xdim !== null && ydim !== null) {
            redrawall = true;
            xdim.filter([_chart._minCoord[0], _chart._maxCoord[0]]);
            ydim.filter([_chart._minCoord[1], _chart._maxCoord[1]]);
          }
        } else if (typeof layer.viewBoxDim === "function" && layer.getState().data.length < 2) {
          // spatial filter on only single data source
          var viewBoxDim = layer.viewBoxDim();
          if (viewBoxDim !== null) {
            redrawall = true;
            viewBoxDim.filterST_Min_ST_Max({
              lonMin: bounds._sw.lng,
              lonMax: bounds._ne.lng,
              latMin: bounds._sw.lat,
              latMax: bounds._ne.lat
            });
          }
        }
      });
    }

    // when in doubt, setTimeout
    // defer the redraw calls to the next tick of the event loop, so that the drag handler has woken up and updated the filters.
    // this is a band-aid and should be fixed in the future.
    setTimeout(function () {
      if (_xDim !== null && _yDim !== null) {
        _xDim.filter([_chart._minCoord[0], _chart._maxCoord[0]]);
        _yDim.filter([_chart._minCoord[1], _chart._maxCoord[1]]);
        // when bbox changes, we send bbox filter change event to the event listener in immerse where we decide whether or not
        // to update other charts bbox filter and their map extent based on their linkedZoomEnabled flag
        (0, _coreAsync.redrawAllAsync)(_chart.chartGroup()).catch(function (error) {
          (0, _coreAsync.resetRedrawStack)();
          console.log("on move event redrawall error:", error);
        });
      } else if (redrawall) {
        // when bbox changes, we send bbox filter change event to the event listener in immerse where we decide whether or not
        // to update other charts bbox filter and their map extent based on their linkedZoomEnabled flag
        (0, _coreAsync.redrawAllAsync)(_chart.chartGroup()).catch(function (error) {
          (0, _coreAsync.resetRedrawStack)();
          console.log("on move event redrawall error:", error);
        });
      } else if (_viewBoxDim !== null && layer.getState().data.length < 2) {
        // spatial filter on only single data source
        _viewBoxDim.filterST_Min_ST_Max({
          lonMin: _chart._minCoord[0],
          lonMax: _chart._maxCoord[0],
          latMin: _chart._minCoord[1],
          latMax: _chart._maxCoord[1]
        });
        // when bbox changes, we send bbox filter change event to the event listener in immerse where we decide whether or not
        // to update other charts bbox filter and their map extent based on their linkedZoomEnabled flag
        (0, _coreAsync.redrawAllAsync)(_chart.chartGroup()).catch(function (error) {
          (0, _coreAsync.resetRedrawStack)();
          console.log("on move event redrawall error:", error);
        });
      } else {
        _chart._projectionFlag = true;
        _chart.redrawAsync();
      }
    }, 0);
  }

  // Force the map to display the mapbox logo
  var showMapLogo = function showMapLogo() {
    var logos = document.querySelectorAll(".mapboxgl-ctrl-logo");
    logos.forEach(function (logo) {
      if (logo.parentElement) {
        logo.parentElement.style.display = "block";
      }
    });
  };

  // Finds rendered layer from the given map style layers
  function getRenderLayer(activeLayer, cb) {
    _map.getStyle().layers.forEach(function (layer) {
      if (!layer.id.includes(activeLayer)) {
        return;
      }

      cb(layer);
    });
  }

  // When mapbox map basemap gets changed, basically changes the style of the map (_map.setStyle(_mapStyle)),
  // the render layer is deleted, so we need to save the render layer source and layer from the old style
  // in savedLayers and savedSource and reapply to the newly styled map in _map.on("style.load", ...)
  var savedLayers = [];
  var savedSources = {};

  _chart.mapStyle = function (style) {
    if (!arguments.length) {
      return _mapStyle;
    }
    _mapStyle = style;
    if (_map) {
      if (!_activeLayer) {
        _activeLayer = "_points";
      }
      var toBeAddedOverlay = "overlay" + _activeLayer;

      getRenderLayer(toBeAddedOverlay, function (layer) {
        if (!savedSources[layer.source]) {
          savedSources[layer.source] = _map.getSource(layer.source).serialize();
          savedLayers.push(layer);
        }
      });

      _map.setStyle(_mapStyle);
      if (typeof _chart.resetLayer !== "undefined") {
        _chart.resetLayer();
      }
    }

    return _chart;
  };

  _chart.mapboxToken = function (mapboxToken) {
    if (!arguments.length) {
      return _mapboxAccessToken;
    }
    _mapboxAccessToken = mapboxToken;
    return _chart;
  };

  _chart.center = function (_) {
    if (!arguments.length) {
      _center = _map.getCenter();
      return _center;
    }
    _center = _;
    if (_mapInitted) {
      _map.setCenter(_center);
    }
    return _chart;
  };

  _chart.zoom = function (_) {
    if (!arguments.length) {
      _zoom = _map.getZoom();
      return _zoom;
    }
    _zoom = _;
    if (_mapInitted) {
      _map.setZoom(_zoom);
    }
    return _chart;
  };

  _chart.attribLocation = function (_) {
    if (!arguments.length) {
      return _attribLocation;
    }
    _attribLocation = _;
    return _chart;
  };

  _chart.resetSvg = function () {
    if (_chart.svg()) {
      _chart.svg().remove();
    }
    if (_chart.map()) {
      var mapContainer = _d3.default.select(_chart.map().getCanvasContainer());
      var svg = mapContainer.append("svg").attr("class", "poly-svg");
      svg.attr("width", _chart.width()).attr("height", _chart.height());
      _chart.svg(svg);
    }
  };

  _chart.mapProject = function (input) {
    // keep both methods before now until we can establish performance
    // profiles of each - seem about equally fast at first glance
    if (_chart._reProjMapbox == false) {
      var xDiff = this._maxCoord[0] - this._minCoord[0];
      var yDiff = this._maxCoord[1] - this._minCoord[1];
      var projectedPoint = this.conv4326To900913(input);
      return [(projectedPoint[0] - this._minCoord[0]) / xDiff * this.width(), (1.0 - (projectedPoint[1] - this._minCoord[1]) / yDiff) * this.height()];
    } else {
      var projectedPoint = this.map().project(input);
      return [projectedPoint.x, projectedPoint.y];
    }
  };

  _chart._setOverlay = function (_ref3) {
    var data = _ref3.data,
        bounds = _ref3.bounds,
        browser = _ref3.browser,
        redraw = _ref3.redraw;

    var map = _chart.map();

    var allMapboxCanvasContainer = document.getElementsByClassName("mapboxgl-canvas-container");
    var chartIdFromCanvasContainer = _chart.selectAll(".mapboxgl-canvas-container")[0].parentNode.id;

    var chartMapboxCanvasContainer = _.filter(allMapboxCanvasContainer, function (mbcc) {
      return mbcc.parentNode.id === chartIdFromCanvasContainer || mbcc.parentNode.parentNode.id === chartIdFromCanvasContainer;
    });

    var allMapboxCanvas = document.getElementsByClassName("mapboxgl-canvas");
    var chartIdFromCanvas = _chart.selectAll(".mapboxgl-canvas")[0].parentNode.id;

    var chartMapboxCanvas = _.filter(allMapboxCanvas, function (mbc) {
      return mbc.parentNode.id === chartIdFromCanvas || mbc.parentNode.parentNode.id === chartIdFromCanvas;
    });

    if (chartMapboxCanvasContainer.length > 1) {
      // we use only one canvas for the chart map, thus remove extra
      chartMapboxCanvasContainer[0].remove();
    }
    if (chartMapboxCanvas.length > 1) {
      chartMapboxCanvas[0].remove();
    }

    var boundsToUse = bounds;
    if (boundsToUse === undefined) {
      return;
    } else if (!_useLonLat) {
      boundsToUse = [_chart.conv900913To4326(bounds[0]), _chart.conv900913To4326(bounds[1]), _chart.conv900913To4326(bounds[2]), _chart.conv900913To4326(bounds[3])];
    }

    if (browser.isSafari || browser.isIE || browser.isEdge) {
      var blob = _utils.utils.b64toBlob(data, "image/png");
      var blobUrl = URL.createObjectURL(blob);
    } else {
      var blobUrl = "data:image/png;base64," + data;
    }

    function setSourceAndAddLayer(toBeAddedOverlay) {
      var firstSymbolLayerId = getFirstSymbolLayerId();
      map.addSource(toBeAddedOverlay, {
        type: "image",
        url: blobUrl,
        coordinates: boundsToUse
      });
      map.addLayer({
        id: toBeAddedOverlay,
        source: toBeAddedOverlay,
        type: "raster",
        paint: { "raster-opacity": 1, "raster-fade-duration": 0 }
      }, firstSymbolLayerId);
    }

    if (!_activeLayer) {
      _activeLayer = "_points";
      var toBeAddedOverlay = "overlay" + _activeLayer;
      if (!map.getSource(toBeAddedOverlay)) {
        setSourceAndAddLayer(toBeAddedOverlay);
      }
    } else {
      var overlayName = "overlay" + _activeLayer;
      var imageSrc = map.getSource(overlayName);
      if (imageSrc) {
        imageSrc.updateImage({
          url: blobUrl,
          coordinates: boundsToUse
        });
      } else {
        // for some reason, the source is lost some of the time, so adding it again FE-9833
        setSourceAndAddLayer(overlayName);
      }
    }
  };

  _chart._removeOverlay = function () {
    var map = _chart.map();

    var overlay = "overlay" + _activeLayer;
    map.removeLayer(overlay);
    map.removeSource(overlay);
  };

  _chart.isLoaded = function () {
    return _map._loaded && _map.style && _map.style._loaded;
  };

  function initMap() {
    if (_mapInitted) {
      return;
    }
    _mapboxgl.accessToken = _mapboxAccessToken;

    _chart.root().style("width", _chart.width() + "px").style("height", _chart.height() + "px");

    _map = new _mapboxgl.Map({
      container: _mapId, // container id
      style: _mapStyle,
      interactive: true,
      center: _center, // starting position
      zoom: _zoom, // starting zoom
      maxBounds: _llb,
      preserveDrawingBuffer: true,
      attributionControl: false,
      logoPosition: "bottom-right"
    }).fitBounds([_initialBounds._sw, _initialBounds._ne], {
      linear: true,
      duration: 0
    });

    _map.dragRotate.disable();
    _map.touchZoomRotate.disableRotation();
    _map.addControl(new _mapboxgl.NavigationControl(), "bottom-right");
    _map.addControl(new _mapboxgl.AttributionControl(), _attribLocation);
    _map.addControl(new _mapboxgl.ScaleControl({ maxWidth: 80, unit: "metric" }), "bottom-right");
    _chart.addMapListeners();
    _mapInitted = true;
    _chart.enableInteractions(_interactionsEnabled);
    if (_chart.shiftToZoom()) {
      _map.on("mousedown", onMouseDownCheckForShiftToZoom);
    }
  }

  _chart.addMapListeners = function () {
    _map.on("moveend", onMapMove);
    _map.on("sourcedata", showMapLogo);
    // if we're using shiftToZoom, then add on explicit drag/wheel events.
    // otherwise, do it as we did before with a single "move"
    //
    // we need the separate wheel event so we can hop in and disable it from within the handler
    if (_chart.shiftToZoom()) {
      _map.on("drag", onMapMove);
      _map.on("wheel", onMapMove);
    } else {
      _map.on("move", onMapMove);
    }
  };

  _chart.removeMapListeners = function () {
    _map.off("move", onMapMove);
    _map.off("moveend", onMapMove);
  };

  _chart.on("postRender", function () {
    _hasRendered = true;
  });

  _chart.on("preRender", function (chart) {
    var width = chart.width();
    var height = chart.height();

    if (width !== _lastWidth || height !== _lastHeight) {
      _chart.root().select("#" + _mapId + " canvas").attr("width", width).attr("height", height);

      _lastWidth = width;
      _lastHeight = height;
      _map.resize();
    }
  });

  function getFirstSymbolLayerId() {
    var firstSymbolId = null;
    var currentStyle = _map.getStyle();

    // Streets and Outdoors styles are sets of layers thus only need to make the street label layer on top of omnisci layer
    if (currentStyle.name === "Mapbox Outdoors" || currentStyle.name === "Mapbox Streets") {
      firstSymbolId = "road-label-large";
    } else {
      var layers = currentStyle.layers;
      for (var i = 0; i < layers.length; ++i) {
        if (layers[i].type === "symbol") {
          firstSymbolId = layers[i].id;
          break;
        }
      }
    }

    return firstSymbolId;
  }

  function getMinMax(value) {
    return _chart.crossfilter().groupAll().reduce([{ expression: value, agg_mode: "min", name: "minimum" }, { expression: value, agg_mode: "max", name: "maximum" }]).valuesAsync(true, true).then(function (bounds) {
      return [bounds.minimum, bounds.maximum];
    });
  }

  function createRangeMinMaxPromises(promises, value) {
    if (!_minMaxCache[value]) {
      return promises.concat(getMinMax(value).then(function (bounds) {
        _minMaxCache[value] = bounds;
      }));
    } else {
      return promises;
    }
  }

  var _fitInitialBounds = void 0;

  _chart.fitInitialBounds = function (callback) {
    if (!arguments.length) {
      _fitInitialBounds();
    }
    _fitInitialBounds = callback;
    return _chart;
  };

  function init(_bounds) {
    return Promise.resolve();
  }

  _chart.init = function (bounds) {
    if (_mapInitted) {
      return;
    }

    var styleLoaded = false;
    var loaded = false;

    _mapboxgl.accessToken = _mapboxAccessToken;
    if (!_mapboxgl.supported()) {
      throw { name: "WebGL", message: "WebGL Not Enabled" };
    } else {
      initMap();
    }

    return new Promise(function (resolve, reject) {
      _map.on("load", function (e) {
        onLoad(e);
        loaded = true;
        if (styleLoaded) {
          init(bounds).then(function () {
            resolve(_chart);
          });
        }
      });

      _map.on("style.load", function () {
        styleLoaded = true;
        if (loaded) {
          init(bounds).then(function () {
            resolve(_chart);
          });
        }
      });

      _map.on("styledata", function () {
        // reapplying the previous style's render layer to the new style layer when basemap gets changed
        if (savedLayers.length) {
          Object.entries(savedSources).forEach(function (_ref4) {
            var _ref5 = _slicedToArray(_ref4, 2),
                id = _ref5[0],
                source = _ref5[1];

            if (!_map.getSource(source)) {
              _map.addSource(id, source);
              savedLayers.forEach(function (layer) {
                _map.addLayer(layer);
              });
              savedLayers = [];
              savedSources = {};
            }
          });
        }
      });

      _map.on("mousedown", function (event) {
        _clientClickX = event.point.x;
        _clientClickY = event.point.y;
      });

      _map.on("mouseup", function (event) {
        // Make sure that the user is clicking to filter, and not dragging or panning the map
        if (_clientClickX === event.point.x && _clientClickY === event.point.y) {
          _chart.getClosestResult(event.point, function (result) {
            var data = result.row_set[0];
            _chart.getLayerNames().forEach(function (layerName) {
              var layer = _chart.getLayer(layerName);
              if (typeof layer.onClick === "function") {
                layer.onClick(_chart, data, event.originalEvent);
              }
            });
          });
        }
      });
      _map.on("mousemove", function (e) {
        // Show mouse position (lat and lon) on the map
        var lon = e.lngLat.lng.toFixed(8);
        var lat = e.lngLat.lat.toFixed(8);
        var latLonContainer = _map.getContainer().getElementsByClassName("latLonCoordinate")[0];
        if (latLonContainer) {
          latLonContainer.classList.add("visible");
          latLonContainer.innerHTML = "Lon: " + lon + " </br> Lat: " + lat;
        }
      });

      // remove the mouse lat lon container from map when mouse is out
      _map.on("mouseout", function (e) {
        var latLonContainer = _map.getContainer().getElementsByClassName("latLonCoordinate")[0];

        if (latLonContainer) {
          latLonContainer.classList.remove("visible");
        }
      });
    });
  };

  _chart.setFilterBounds = function (bounds) {
    if (!_useLonLat) {
      _chart._minCoord = _chart.conv4326To900913([bounds._sw.lng, bounds._sw.lat]);
      _chart._maxCoord = _chart.conv4326To900913([bounds._ne.lng, bounds._ne.lat]);
    } else {
      _chart._minCoord = [bounds._sw.lng, bounds._sw.lat];
      _chart._maxCoord = [bounds._ne.lng, bounds._ne.lat];
    }

    _chart.getLayers().forEach(function (layer) {
      if (typeof layer.xDim === "function" && typeof layer.yDim === "function") {
        var xdim = layer.xDim();
        var ydim = layer.yDim();
        if (xdim !== null && ydim !== null) {
          xdim.filter([_chart._minCoord[0], _chart._maxCoord[0]]);
          ydim.filter([_chart._minCoord[1], _chart._maxCoord[1]]);
        }
      }
    });
  };

  function boundsRoughlyEqual(a, b) {
    return a.getSouthWest().lat === b.getSouthWest().lat || a.getSouthWest().lng === b.getSouthWest().lng || a.getNorthEast().lat === b.getNorthEast().lat || a.getNorthEast().lng === b.getNorthEast().lng;
  }

  _chart.geocoder = function (geocoder) {
    if (!arguments.length) {
      return _geocoder;
    }
    if (typeof geocoder.locate !== "function") {
      throw new Error("Geocoder must have a location function");
    }
    _geocoder = geocoder;
    return _chart;
  };

  function initGeocoder() {
    _chart.root().append("input").attr("type", "text").attr("placeholder", "Zoom to").classed("geocoder-input", true).style("top", "5px").style("right", "5px").style("float", "right").style("position", "absolute").on("keydown", function () {
      if (_d3.default.event.key === "Enter" || _d3.default.event.keyCode === 13) {
        _geocoder.locate(this.value).then(_chart.zoomToLocation);
      }
    });
  }

  // Mouse position (lat and lon) container
  function initMouseLatLonCoordinate() {
    _chart.root().append("div").classed("latLonCoordinate", true);
  }

  function validateBounds(data) {
    var sw = data.bounds.sw;
    var ne = data.bounds.ne;
    /* eslint-disable operator-linebreak */
    return !isNaN(sw[0]) && !isNaN(ne[0]) && !isNaN(sw[1]) && !isNaN(ne[1]) && sw[0] <= ne[0] && sw[1] < ne[1] && sw[0] >= LONMIN && sw[0] <= LONMAX && sw[1] >= LATMIN && sw[1] <= LATMAX && ne[0] >= LONMIN && ne[0] <= LONMAX && ne[1] >= LATMIN && ne[1] <= LATMAX;
    /* eslint-enable operator-linebreak */
  }

  _chart.zoomToLocation = function (data) {
    if (!_mapInitted) {
      return _chart;
    }
    if (data.bounds && data.zoom === undefined) {
      if (validateBounds(data)) {
        _map.fitBounds([data.bounds.sw, data.bounds.ne], {
          linear: true,
          duration: EASE_DURATION_MS
        });
      }
    } else {
      _map.setZoom(data.zoom || DEFAULT_ZOOM_LEVEL);
      var center = data.center;
      _map.setCenter(center);
    }
    return _chart;
  };

  if (mixinDraw) {
    _chart = (0, _rasterDrawMixin.rasterDrawMixin)(_chart);
  }

  return _chart;
}

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module helpers
 */
/**
 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
 *
 * @memberof helpers
 * @type {number}
 */
exports.earthRadius = 6371008.8;
/**
 * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
 *
 * @memberof helpers
 * @type {Object}
 */
exports.factors = {
    centimeters: exports.earthRadius * 100,
    centimetres: exports.earthRadius * 100,
    degrees: exports.earthRadius / 111325,
    feet: exports.earthRadius * 3.28084,
    inches: exports.earthRadius * 39.370,
    kilometers: exports.earthRadius / 1000,
    kilometres: exports.earthRadius / 1000,
    meters: exports.earthRadius,
    metres: exports.earthRadius,
    miles: exports.earthRadius / 1609.344,
    millimeters: exports.earthRadius * 1000,
    millimetres: exports.earthRadius * 1000,
    nauticalmiles: exports.earthRadius / 1852,
    radians: 1,
    yards: exports.earthRadius / 1.0936,
};
/**
 * Units of measurement factors based on 1 meter.
 *
 * @memberof helpers
 * @type {Object}
 */
exports.unitsFactors = {
    centimeters: 100,
    centimetres: 100,
    degrees: 1 / 111325,
    feet: 3.28084,
    inches: 39.370,
    kilometers: 1 / 1000,
    kilometres: 1 / 1000,
    meters: 1,
    metres: 1,
    miles: 1 / 1609.344,
    millimeters: 1000,
    millimetres: 1000,
    nauticalmiles: 1 / 1852,
    radians: 1 / exports.earthRadius,
    yards: 1 / 1.0936,
};
/**
 * Area of measurement factors based on 1 square meter.
 *
 * @memberof helpers
 * @type {Object}
 */
exports.areaFactors = {
    acres: 0.000247105,
    centimeters: 10000,
    centimetres: 10000,
    feet: 10.763910417,
    inches: 1550.003100006,
    kilometers: 0.000001,
    kilometres: 0.000001,
    meters: 1,
    metres: 1,
    miles: 3.86e-7,
    millimeters: 1000000,
    millimetres: 1000000,
    yards: 1.195990046,
};
/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature} a GeoJSON Feature
 * @example
 * var geometry = {
 *   "type": "Point",
 *   "coordinates": [110, 50]
 * };
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */
function feature(geom, properties, options) {
    if (options === void 0) { options = {}; }
    var feat = { type: "Feature" };
    if (options.id === 0 || options.id) {
        feat.id = options.id;
    }
    if (options.bbox) {
        feat.bbox = options.bbox;
    }
    feat.properties = properties || {};
    feat.geometry = geom;
    return feat;
}
exports.feature = feature;
/**
 * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
 * For GeometryCollection type use `helpers.geometryCollection`
 *
 * @name geometry
 * @param {string} type Geometry Type
 * @param {Array<any>} coordinates Coordinates
 * @param {Object} [options={}] Optional Parameters
 * @returns {Geometry} a GeoJSON Geometry
 * @example
 * var type = "Point";
 * var coordinates = [110, 50];
 * var geometry = turf.geometry(type, coordinates);
 * // => geometry
 */
function geometry(type, coordinates, options) {
    if (options === void 0) { options = {}; }
    switch (type) {
        case "Point": return point(coordinates).geometry;
        case "LineString": return lineString(coordinates).geometry;
        case "Polygon": return polygon(coordinates).geometry;
        case "MultiPoint": return multiPoint(coordinates).geometry;
        case "MultiLineString": return multiLineString(coordinates).geometry;
        case "MultiPolygon": return multiPolygon(coordinates).geometry;
        default: throw new Error(type + " is invalid");
    }
}
exports.geometry = geometry;
/**
 * Creates a {@link Point} {@link Feature} from a Position.
 *
 * @name point
 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Point>} a Point feature
 * @example
 * var point = turf.point([-75.343, 39.984]);
 *
 * //=point
 */
function point(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "Point",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.point = point;
/**
 * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.
 *
 * @name points
 * @param {Array<Array<number>>} coordinates an array of Points
 * @param {Object} [properties={}] Translate these properties to each Feature
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
 * associated with the FeatureCollection
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<Point>} Point Feature
 * @example
 * var points = turf.points([
 *   [-75, 39],
 *   [-80, 45],
 *   [-78, 50]
 * ]);
 *
 * //=points
 */
function points(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    return featureCollection(coordinates.map(function (coords) {
        return point(coords, properties);
    }), options);
}
exports.points = points;
/**
 * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Polygon>} Polygon Feature
 * @example
 * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
 *
 * //=polygon
 */
function polygon(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
        var ring = coordinates_1[_i];
        if (ring.length < 4) {
            throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
            // Check if first point of Polygon contains two numbers
            if (ring[ring.length - 1][j] !== ring[0][j]) {
                throw new Error("First and last Position are not equivalent.");
            }
        }
    }
    var geom = {
        type: "Polygon",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.polygon = polygon;
/**
 * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.
 *
 * @name polygons
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection
 * @example
 * var polygons = turf.polygons([
 *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],
 *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],
 * ]);
 *
 * //=polygons
 */
function polygons(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    return featureCollection(coordinates.map(function (coords) {
        return polygon(coords, properties);
    }), options);
}
exports.polygons = polygons;
/**
 * Creates a {@link LineString} {@link Feature} from an Array of Positions.
 *
 * @name lineString
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<LineString>} LineString Feature
 * @example
 * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});
 * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});
 *
 * //=linestring1
 * //=linestring2
 */
function lineString(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    if (coordinates.length < 2) {
        throw new Error("coordinates must be an array of two or more positions");
    }
    var geom = {
        type: "LineString",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.lineString = lineString;
/**
 * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.
 *
 * @name lineStrings
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
 * associated with the FeatureCollection
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<LineString>} LineString FeatureCollection
 * @example
 * var linestrings = turf.lineStrings([
 *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],
 *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]
 * ]);
 *
 * //=linestrings
 */
function lineStrings(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    return featureCollection(coordinates.map(function (coords) {
        return lineString(coords, properties);
    }), options);
}
exports.lineStrings = lineStrings;
/**
 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
 *
 * @name featureCollection
 * @param {Feature[]} features input features
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {FeatureCollection} FeatureCollection of Features
 * @example
 * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});
 * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});
 * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});
 *
 * var collection = turf.featureCollection([
 *   locationA,
 *   locationB,
 *   locationC
 * ]);
 *
 * //=collection
 */
function featureCollection(features, options) {
    if (options === void 0) { options = {}; }
    var fc = { type: "FeatureCollection" };
    if (options.id) {
        fc.id = options.id;
    }
    if (options.bbox) {
        fc.bbox = options.bbox;
    }
    fc.features = features;
    return fc;
}
exports.featureCollection = featureCollection;
/**
 * Creates a {@link Feature<MultiLineString>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiLineString
 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiLineString>} a MultiLineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
 *
 * //=multiLine
 */
function multiLineString(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "MultiLineString",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.multiLineString = multiLineString;
/**
 * Creates a {@link Feature<MultiPoint>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPoint
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiPoint>} a MultiPoint feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
 *
 * //=multiPt
 */
function multiPoint(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "MultiPoint",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.multiPoint = multiPoint;
/**
 * Creates a {@link Feature<MultiPolygon>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPolygon
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiPolygon>} a multipolygon feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
 *
 * //=multiPoly
 *
 */
function multiPolygon(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "MultiPolygon",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.multiPolygon = multiPolygon;
/**
 * Creates a {@link Feature<GeometryCollection>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name geometryCollection
 * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
 * @example
 * var pt = turf.geometry("Point", [100, 0]);
 * var line = turf.geometry("LineString", [[101, 0], [102, 1]]);
 * var collection = turf.geometryCollection([pt, line]);
 *
 * // => collection
 */
function geometryCollection(geometries, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "GeometryCollection",
        geometries: geometries,
    };
    return feature(geom, properties, options);
}
exports.geometryCollection = geometryCollection;
/**
 * Round number to precision
 *
 * @param {number} num Number
 * @param {number} [precision=0] Precision
 * @returns {number} rounded number
 * @example
 * turf.round(120.4321)
 * //=120
 *
 * turf.round(120.4321, 2)
 * //=120.43
 */
function round(num, precision) {
    if (precision === void 0) { precision = 0; }
    if (precision && !(precision >= 0)) {
        throw new Error("precision must be a positive number");
    }
    var multiplier = Math.pow(10, precision || 0);
    return Math.round(num * multiplier) / multiplier;
}
exports.round = round;
/**
 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name radiansToLength
 * @param {number} radians in radians across the sphere
 * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} distance
 */
function radiansToLength(radians, units) {
    if (units === void 0) { units = "kilometers"; }
    var factor = exports.factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return radians * factor;
}
exports.radiansToLength = radiansToLength;
/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name lengthToRadians
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} radians
 */
function lengthToRadians(distance, units) {
    if (units === void 0) { units = "kilometers"; }
    var factor = exports.factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return distance / factor;
}
exports.lengthToRadians = lengthToRadians;
/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
 *
 * @name lengthToDegrees
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} degrees
 */
function lengthToDegrees(distance, units) {
    return radiansToDegrees(lengthToRadians(distance, units));
}
exports.lengthToDegrees = lengthToDegrees;
/**
 * Converts any bearing angle from the north line direction (positive clockwise)
 * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
 *
 * @name bearingToAzimuth
 * @param {number} bearing angle, between -180 and +180 degrees
 * @returns {number} angle between 0 and 360 degrees
 */
function bearingToAzimuth(bearing) {
    var angle = bearing % 360;
    if (angle < 0) {
        angle += 360;
    }
    return angle;
}
exports.bearingToAzimuth = bearingToAzimuth;
/**
 * Converts an angle in radians to degrees
 *
 * @name radiansToDegrees
 * @param {number} radians angle in radians
 * @returns {number} degrees between 0 and 360 degrees
 */
function radiansToDegrees(radians) {
    var degrees = radians % (2 * Math.PI);
    return degrees * 180 / Math.PI;
}
exports.radiansToDegrees = radiansToDegrees;
/**
 * Converts an angle in degrees to radians
 *
 * @name degreesToRadians
 * @param {number} degrees angle between 0 and 360 degrees
 * @returns {number} angle in radians
 */
function degreesToRadians(degrees) {
    var radians = degrees % 360;
    return radians * Math.PI / 180;
}
exports.degreesToRadians = degreesToRadians;
/**
 * Converts a length to the requested unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @param {number} length to be converted
 * @param {Units} [originalUnit="kilometers"] of the length
 * @param {Units} [finalUnit="kilometers"] returned unit
 * @returns {number} the converted length
 */
function convertLength(length, originalUnit, finalUnit) {
    if (originalUnit === void 0) { originalUnit = "kilometers"; }
    if (finalUnit === void 0) { finalUnit = "kilometers"; }
    if (!(length >= 0)) {
        throw new Error("length must be a positive number");
    }
    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);
}
exports.convertLength = convertLength;
/**
 * Converts a area to the requested unit.
 * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches
 * @param {number} area to be converted
 * @param {Units} [originalUnit="meters"] of the distance
 * @param {Units} [finalUnit="kilometers"] returned unit
 * @returns {number} the converted distance
 */
function convertArea(area, originalUnit, finalUnit) {
    if (originalUnit === void 0) { originalUnit = "meters"; }
    if (finalUnit === void 0) { finalUnit = "kilometers"; }
    if (!(area >= 0)) {
        throw new Error("area must be a positive number");
    }
    var startFactor = exports.areaFactors[originalUnit];
    if (!startFactor) {
        throw new Error("invalid original units");
    }
    var finalFactor = exports.areaFactors[finalUnit];
    if (!finalFactor) {
        throw new Error("invalid final units");
    }
    return (area / startFactor) * finalFactor;
}
exports.convertArea = convertArea;
/**
 * isNumber
 *
 * @param {*} num Number to validate
 * @returns {boolean} true/false
 * @example
 * turf.isNumber(123)
 * //=true
 * turf.isNumber('foo')
 * //=false
 */
function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\s*$/.test(num);
}
exports.isNumber = isNumber;
/**
 * isObject
 *
 * @param {*} input variable to validate
 * @returns {boolean} true/false
 * @example
 * turf.isObject({elevation: 10})
 * //=true
 * turf.isObject('foo')
 * //=false
 */
function isObject(input) {
    return (!!input) && (input.constructor === Object);
}
exports.isObject = isObject;
/**
 * Validate BBox
 *
 * @private
 * @param {Array<number>} bbox BBox to validate
 * @returns {void}
 * @throws Error if BBox is not valid
 * @example
 * validateBBox([-180, -40, 110, 50])
 * //=OK
 * validateBBox([-180, -40])
 * //=Error
 * validateBBox('Foo')
 * //=Error
 * validateBBox(5)
 * //=Error
 * validateBBox(null)
 * //=Error
 * validateBBox(undefined)
 * //=Error
 */
function validateBBox(bbox) {
    if (!bbox) {
        throw new Error("bbox is required");
    }
    if (!Array.isArray(bbox)) {
        throw new Error("bbox must be an Array");
    }
    if (bbox.length !== 4 && bbox.length !== 6) {
        throw new Error("bbox must be an Array of 4 or 6 numbers");
    }
    bbox.forEach(function (num) {
        if (!isNumber(num)) {
            throw new Error("bbox must only contain numbers");
        }
    });
}
exports.validateBBox = validateBBox;
/**
 * Validate Id
 *
 * @private
 * @param {string|number} id Id to validate
 * @returns {void}
 * @throws Error if Id is not valid
 * @example
 * validateId([-180, -40, 110, 50])
 * //=Error
 * validateId([-180, -40])
 * //=Error
 * validateId('Foo')
 * //=OK
 * validateId(5)
 * //=OK
 * validateId(null)
 * //=Error
 * validateId(undefined)
 * //=Error
 */
function validateId(id) {
    if (!id) {
        throw new Error("id is required");
    }
    if (["string", "number"].indexOf(typeof id) === -1) {
        throw new Error("id must be a number or a string");
    }
}
exports.validateId = validateId;
// Deprecated methods
function radians2degrees() {
    throw new Error("method has been renamed to `radiansToDegrees`");
}
exports.radians2degrees = radians2degrees;
function degrees2radians() {
    throw new Error("method has been renamed to `degreesToRadians`");
}
exports.degrees2radians = degrees2radians;
function distanceToDegrees() {
    throw new Error("method has been renamed to `lengthToDegrees`");
}
exports.distanceToDegrees = distanceToDegrees;
function distanceToRadians() {
    throw new Error("method has been renamed to `lengthToRadians`");
}
exports.distanceToRadians = distanceToRadians;
function radiansToDistance() {
    throw new Error("method has been renamed to `radiansToLength`");
}
exports.radiansToDistance = radiansToDistance;
function bearingToAngle() {
    throw new Error("method has been renamed to `bearingToAzimuth`");
}
exports.bearingToAngle = bearingToAngle;
function convertDistance() {
    throw new Error("method has been renamed to `convertLength`");
}
exports.convertDistance = convertDistance;


/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
/* harmony default export */ __webpack_exports__["a"] = (function(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
});


/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RestWalker; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__gast_gast_public__ = __webpack_require__(6);


/**
 *  A Grammar Walker that computes the "remaining" grammar "after" a productions in the grammar.
 */
var RestWalker = /** @class */ (function () {
    function RestWalker() {
    }
    RestWalker.prototype.walk = function (prod, prevRest) {
        var _this = this;
        if (prevRest === void 0) { prevRest = []; }
        Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(prod.definition, function (subProd, index) {
            var currRest = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["m" /* drop */])(prod.definition, index + 1);
            /* istanbul ignore else */
            if (subProd instanceof __WEBPACK_IMPORTED_MODULE_1__gast_gast_public__["d" /* NonTerminal */]) {
                _this.walkProdRef(subProd, currRest, prevRest);
            }
            else if (subProd instanceof __WEBPACK_IMPORTED_MODULE_1__gast_gast_public__["k" /* Terminal */]) {
                _this.walkTerminal(subProd, currRest, prevRest);
            }
            else if (subProd instanceof __WEBPACK_IMPORTED_MODULE_1__gast_gast_public__["c" /* Flat */]) {
                _this.walkFlat(subProd, currRest, prevRest);
            }
            else if (subProd instanceof __WEBPACK_IMPORTED_MODULE_1__gast_gast_public__["e" /* Option */]) {
                _this.walkOption(subProd, currRest, prevRest);
            }
            else if (subProd instanceof __WEBPACK_IMPORTED_MODULE_1__gast_gast_public__["g" /* RepetitionMandatory */]) {
                _this.walkAtLeastOne(subProd, currRest, prevRest);
            }
            else if (subProd instanceof __WEBPACK_IMPORTED_MODULE_1__gast_gast_public__["h" /* RepetitionMandatoryWithSeparator */]) {
                _this.walkAtLeastOneSep(subProd, currRest, prevRest);
            }
            else if (subProd instanceof __WEBPACK_IMPORTED_MODULE_1__gast_gast_public__["i" /* RepetitionWithSeparator */]) {
                _this.walkManySep(subProd, currRest, prevRest);
            }
            else if (subProd instanceof __WEBPACK_IMPORTED_MODULE_1__gast_gast_public__["f" /* Repetition */]) {
                _this.walkMany(subProd, currRest, prevRest);
            }
            else if (subProd instanceof __WEBPACK_IMPORTED_MODULE_1__gast_gast_public__["b" /* Alternation */]) {
                _this.walkOr(subProd, currRest, prevRest);
            }
            else {
                throw Error("non exhaustive match");
            }
        });
    };
    RestWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) { };
    RestWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) { };
    RestWalker.prototype.walkFlat = function (flatProd, currRest, prevRest) {
        // ABCDEF => after the D the rest is EF
        var fullOrRest = currRest.concat(prevRest);
        this.walk(flatProd, fullOrRest);
    };
    RestWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {
        // ABC(DE)?F => after the (DE)? the rest is F
        var fullOrRest = currRest.concat(prevRest);
        this.walk(optionProd, fullOrRest);
    };
    RestWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {
        // ABC(DE)+F => after the (DE)+ the rest is (DE)?F
        var fullAtLeastOneRest = [
            new __WEBPACK_IMPORTED_MODULE_1__gast_gast_public__["e" /* Option */]({ definition: atLeastOneProd.definition })
        ].concat(currRest, prevRest);
        this.walk(atLeastOneProd, fullAtLeastOneRest);
    };
    RestWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {
        // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F
        var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);
        this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);
    };
    RestWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {
        // ABC(DE)*F => after the (DE)* the rest is (DE)?F
        var fullManyRest = [
            new __WEBPACK_IMPORTED_MODULE_1__gast_gast_public__["e" /* Option */]({ definition: manyProd.definition })
        ].concat(currRest, prevRest);
        this.walk(manyProd, fullManyRest);
    };
    RestWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {
        // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F
        var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);
        this.walk(manySepProd, fullManySepRest);
    };
    RestWalker.prototype.walkOr = function (orProd, currRest, prevRest) {
        var _this = this;
        // ABC(D|E|F)G => when finding the (D|E|F) the rest is G
        var fullOrRest = currRest.concat(prevRest);
        // walk all different alternatives
        Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(orProd.definition, function (alt) {
            // wrapping each alternative in a single definition wrapper
            // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows
            // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1
            var prodWrapper = new __WEBPACK_IMPORTED_MODULE_1__gast_gast_public__["c" /* Flat */]({ definition: [alt] });
            _this.walk(prodWrapper, fullOrRest);
        });
    };
    return RestWalker;
}());

function restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {
    var repSepRest = [
        new __WEBPACK_IMPORTED_MODULE_1__gast_gast_public__["e" /* Option */]({
            definition: [
                new __WEBPACK_IMPORTED_MODULE_1__gast_gast_public__["k" /* Terminal */]({ terminalType: repSepProd.separator })
            ].concat(repSepProd.definition)
        })
    ];
    var fullRepSepRest = repSepRest.concat(currRest, prevRest);
    return fullRepSepRest;
}
//# sourceMappingURL=rest.js.map

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;;(function(root, factory) {
    // istanbul ignore next
    if (true) {
        // istanbul ignore next
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    } else if (typeof module === "object" && module.exports) {
        module.exports = factory()
    } else {
        // istanbul ignore next
        root.regexpToAst = factory()
    }
})(
    typeof self !== "undefined"
        ? // istanbul ignore next
          self
        : this,
    function() {
        // references
        // https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983
        // https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern
        function RegExpParser() {}

        RegExpParser.prototype.saveState = function() {
            return {
                idx: this.idx,
                input: this.input,
                groupIdx: this.groupIdx
            }
        }

        RegExpParser.prototype.restoreState = function(newState) {
            this.idx = newState.idx
            this.input = newState.input
            this.groupIdx = newState.groupIdx
        }

        RegExpParser.prototype.pattern = function(input) {
            // parser state
            this.idx = 0
            this.input = input
            this.groupIdx = 0

            this.consumeChar("/")
            var value = this.disjunction()
            this.consumeChar("/")

            var flags = {
                type: "Flags",
                global: false,
                ignoreCase: false,
                multiLine: false,
                unicode: false,
                sticky: false
            }

            while (this.isRegExpFlag()) {
                switch (this.popChar()) {
                    case "g":
                        addFlag(flags, "global")
                        break
                    case "i":
                        addFlag(flags, "ignoreCase")
                        break
                    case "m":
                        addFlag(flags, "multiLine")
                        break
                    case "u":
                        addFlag(flags, "unicode")
                        break
                    case "y":
                        addFlag(flags, "sticky")
                        break
                }
            }

            if (this.idx !== this.input.length) {
                throw Error(
                    "Redundant input: " + this.input.substring(this.idx)
                )
            }
            return { type: "Pattern", flags: flags, value: value }
        }

        RegExpParser.prototype.disjunction = function() {
            var alts = []
            alts.push(this.alternative())

            while (this.peekChar() === "|") {
                this.consumeChar("|")
                alts.push(this.alternative())
            }

            return { type: "Disjunction", value: alts }
        }

        RegExpParser.prototype.alternative = function() {
            var terms = []

            while (this.isTerm()) {
                terms.push(this.term())
            }

            return { type: "Alternative", value: terms }
        }

        RegExpParser.prototype.term = function() {
            if (this.isAssertion()) {
                return this.assertion()
            } else {
                return this.atom()
            }
        }

        RegExpParser.prototype.assertion = function() {
            switch (this.popChar()) {
                case "^":
                    return { type: "StartAnchor" }
                case "$":
                    return { type: "EndAnchor" }
                // '\b' or '\B'
                case "\\":
                    switch (this.popChar()) {
                        case "b":
                            return { type: "WordBoundary" }
                        case "B":
                            return { type: "NonWordBoundary" }
                    }
                    // istanbul ignore next
                    throw Error("Invalid Assertion Escape")
                // '(?=' or '(?!'
                case "(":
                    this.consumeChar("?")

                    var type
                    switch (this.popChar()) {
                        case "=":
                            type = "Lookahead"
                            break
                        case "!":
                            type = "NegativeLookahead"
                            break
                    }
                    ASSERT_EXISTS(type)

                    var disjunction = this.disjunction()

                    this.consumeChar(")")

                    return { type: type, value: disjunction }
            }
            // istanbul ignore next
            ASSERT_NEVER_REACH_HERE()
        }

        RegExpParser.prototype.quantifier = function(isBacktracking) {
            var range
            switch (this.popChar()) {
                case "*":
                    range = {
                        atLeast: 0,
                        atMost: Infinity
                    }
                    break
                case "+":
                    range = {
                        atLeast: 1,
                        atMost: Infinity
                    }
                    break
                case "?":
                    range = {
                        atLeast: 0,
                        atMost: 1
                    }
                    break
                case "{":
                    var atLeast = this.integerIncludingZero()
                    switch (this.popChar()) {
                        case "}":
                            range = {
                                atLeast: atLeast,
                                atMost: atLeast
                            }
                            break
                        case ",":
                            var atMost
                            if (this.isDigit()) {
                                atMost = this.integerIncludingZero()
                                range = {
                                    atLeast: atLeast,
                                    atMost: atMost
                                }
                            } else {
                                range = {
                                    atLeast: atLeast,
                                    atMost: Infinity
                                }
                            }
                            this.consumeChar("}")
                            break
                    }
                    // throwing exceptions from "ASSERT_EXISTS" during backtracking
                    // causes severe performance degradations
                    if (isBacktracking === true && range === undefined) {
                        return undefined
                    }
                    ASSERT_EXISTS(range)
                    break
            }

            // throwing exceptions from "ASSERT_EXISTS" during backtracking
            // causes severe performance degradations
            if (isBacktracking === true && range === undefined) {
                return undefined
            }

            ASSERT_EXISTS(range)

            if (this.peekChar(0) === "?") {
                this.consumeChar("?")
                range.greedy = false
            } else {
                range.greedy = true
            }

            range.type = "Quantifier"
            return range
        }

        RegExpParser.prototype.atom = function() {
            var atom
            switch (this.peekChar()) {
                case ".":
                    atom = this.dotAll()
                    break
                case "\\":
                    atom = this.atomEscape()
                    break
                case "[":
                    atom = this.characterClass()
                    break
                case "(":
                    atom = this.group()
                    break
            }

            if (atom === undefined && this.isPatternCharacter()) {
                atom = this.patternCharacter()
            }

            ASSERT_EXISTS(atom)

            if (this.isQuantifier()) {
                atom.quantifier = this.quantifier()
            }

            return atom
        }

        RegExpParser.prototype.dotAll = function() {
            this.consumeChar(".")
            return {
                type: "Set",
                complement: true,
                value: [cc("\n"), cc("\r"), cc("\u2028"), cc("\u2029")]
            }
        }

        RegExpParser.prototype.atomEscape = function() {
            this.consumeChar("\\")

            switch (this.peekChar()) {
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                case "8":
                case "9":
                    return this.decimalEscapeAtom()
                case "d":
                case "D":
                case "s":
                case "S":
                case "w":
                case "W":
                    return this.characterClassEscape()
                case "f":
                case "n":
                case "r":
                case "t":
                case "v":
                    return this.controlEscapeAtom()
                case "c":
                    return this.controlLetterEscapeAtom()
                case "0":
                    return this.nulCharacterAtom()
                case "x":
                    return this.hexEscapeSequenceAtom()
                case "u":
                    return this.regExpUnicodeEscapeSequenceAtom()
                default:
                    return this.identityEscapeAtom()
            }
        }

        RegExpParser.prototype.decimalEscapeAtom = function() {
            var value = this.positiveInteger()

            return { type: "GroupBackReference", value: value }
        }

        RegExpParser.prototype.characterClassEscape = function() {
            var set
            var complement = false
            switch (this.popChar()) {
                case "d":
                    set = digitsCharCodes
                    break
                case "D":
                    set = digitsCharCodes
                    complement = true
                    break
                case "s":
                    set = whitespaceCodes
                    break
                case "S":
                    set = whitespaceCodes
                    complement = true
                    break
                case "w":
                    set = wordCharCodes
                    break
                case "W":
                    set = wordCharCodes
                    complement = true
                    break
            }

            ASSERT_EXISTS(set)

            return { type: "Set", value: set, complement: complement }
        }

        RegExpParser.prototype.controlEscapeAtom = function() {
            var escapeCode
            switch (this.popChar()) {
                case "f":
                    escapeCode = cc("\f")
                    break
                case "n":
                    escapeCode = cc("\n")
                    break
                case "r":
                    escapeCode = cc("\r")
                    break
                case "t":
                    escapeCode = cc("\t")
                    break
                case "v":
                    escapeCode = cc("\v")
                    break
            }
            ASSERT_EXISTS(escapeCode)

            return { type: "Character", value: escapeCode }
        }

        RegExpParser.prototype.controlLetterEscapeAtom = function() {
            this.consumeChar("c")
            var letter = this.popChar()
            if (/[a-zA-Z]/.test(letter) === false) {
                throw Error("Invalid ")
            }

            var letterCode = letter.toUpperCase().charCodeAt(0) - 64
            return { type: "Character", value: letterCode }
        }

        RegExpParser.prototype.nulCharacterAtom = function() {
            // TODO implement '[lookahead  DecimalDigit]'
            // TODO: for the deprecated octal escape sequence
            this.consumeChar("0")
            return { type: "Character", value: cc("\0") }
        }

        RegExpParser.prototype.hexEscapeSequenceAtom = function() {
            this.consumeChar("x")
            return this.parseHexDigits(2)
        }

        RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function() {
            this.consumeChar("u")
            return this.parseHexDigits(4)
        }

        RegExpParser.prototype.identityEscapeAtom = function() {
            // TODO: implement "SourceCharacter but not UnicodeIDContinue"
            // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments
            var escapedChar = this.popChar()
            return { type: "Character", value: cc(escapedChar) }
        }

        RegExpParser.prototype.classPatternCharacterAtom = function() {
            switch (this.peekChar()) {
                // istanbul ignore next
                case "\n":
                // istanbul ignore next
                case "\r":
                // istanbul ignore next
                case "\u2028":
                // istanbul ignore next
                case "\u2029":
                // istanbul ignore next
                case "\\":
                // istanbul ignore next
                case "]":
                    throw Error("TBD")
                default:
                    var nextChar = this.popChar()
                    return { type: "Character", value: cc(nextChar) }
            }
        }

        RegExpParser.prototype.characterClass = function() {
            var set = []
            var complement = false
            this.consumeChar("[")
            if (this.peekChar(0) === "^") {
                this.consumeChar("^")
                complement = true
            }

            while (this.isClassAtom()) {
                var from = this.classAtom()
                var isFromSingleChar = from.type === "Character"
                if (isFromSingleChar && this.isRangeDash()) {
                    this.consumeChar("-")
                    var to = this.classAtom()
                    var isToSingleChar = to.type === "Character"

                    // a range can only be used when both sides are single characters
                    if (isToSingleChar) {
                        if (to.value < from.value) {
                            throw Error("Range out of order in character class")
                        }
                        set.push({ from: from.value, to: to.value })
                    } else {
                        // literal dash
                        insertToSet(from.value, set)
                        set.push(cc("-"))
                        insertToSet(to.value, set)
                    }
                } else {
                    insertToSet(from.value, set)
                }
            }

            this.consumeChar("]")

            return { type: "Set", complement: complement, value: set }
        }

        RegExpParser.prototype.classAtom = function() {
            switch (this.peekChar()) {
                // istanbul ignore next
                case "]":
                // istanbul ignore next
                case "\n":
                // istanbul ignore next
                case "\r":
                // istanbul ignore next
                case "\u2028":
                // istanbul ignore next
                case "\u2029":
                    throw Error("TBD")
                case "\\":
                    return this.classEscape()
                default:
                    return this.classPatternCharacterAtom()
            }
        }

        RegExpParser.prototype.classEscape = function() {
            this.consumeChar("\\")
            switch (this.peekChar()) {
                // Matches a backspace.
                // (Not to be confused with \b word boundary outside characterClass)
                case "b":
                    this.consumeChar("b")
                    return { type: "Character", value: cc("\u0008") }
                case "d":
                case "D":
                case "s":
                case "S":
                case "w":
                case "W":
                    return this.characterClassEscape()
                case "f":
                case "n":
                case "r":
                case "t":
                case "v":
                    return this.controlEscapeAtom()
                case "c":
                    return this.controlLetterEscapeAtom()
                case "0":
                    return this.nulCharacterAtom()
                case "x":
                    return this.hexEscapeSequenceAtom()
                case "u":
                    return this.regExpUnicodeEscapeSequenceAtom()
                default:
                    return this.identityEscapeAtom()
            }
        }

        RegExpParser.prototype.group = function() {
            var capturing = true
            this.consumeChar("(")
            switch (this.peekChar(0)) {
                case "?":
                    this.consumeChar("?")
                    this.consumeChar(":")
                    capturing = false
                    break
                default:
                    this.groupIdx++
                    break
            }
            var value = this.disjunction()
            this.consumeChar(")")

            var groupAst = {
                type: "Group",
                capturing: capturing,
                value: value
            }

            if (capturing) {
                groupAst.idx = this.groupIdx
            }

            return groupAst
        }

        RegExpParser.prototype.positiveInteger = function() {
            var number = this.popChar()

            // istanbul ignore next - can't ever get here due to previous lookahead checks
            // still implementing this error checking in case this ever changes.
            if (decimalPatternNoZero.test(number) === false) {
                throw Error("Expecting a positive integer")
            }

            while (decimalPattern.test(this.peekChar(0))) {
                number += this.popChar()
            }

            return parseInt(number, 10)
        }

        RegExpParser.prototype.integerIncludingZero = function() {
            var number = this.popChar()
            if (decimalPattern.test(number) === false) {
                throw Error("Expecting an integer")
            }

            while (decimalPattern.test(this.peekChar(0))) {
                number += this.popChar()
            }

            return parseInt(number, 10)
        }

        RegExpParser.prototype.patternCharacter = function() {
            var nextChar = this.popChar()
            switch (nextChar) {
                // istanbul ignore next
                case "\n":
                // istanbul ignore next
                case "\r":
                // istanbul ignore next
                case "\u2028":
                // istanbul ignore next
                case "\u2029":
                // istanbul ignore next
                case "^":
                // istanbul ignore next
                case "$":
                // istanbul ignore next
                case "\\":
                // istanbul ignore next
                case ".":
                // istanbul ignore next
                case "*":
                // istanbul ignore next
                case "+":
                // istanbul ignore next
                case "?":
                // istanbul ignore next
                case "(":
                // istanbul ignore next
                case ")":
                // istanbul ignore next
                case "[":
                // istanbul ignore next
                case "|":
                    // istanbul ignore next
                    throw Error("TBD")
                default:
                    return { type: "Character", value: cc(nextChar) }
            }
        }
        RegExpParser.prototype.isRegExpFlag = function() {
            switch (this.peekChar(0)) {
                case "g":
                case "i":
                case "m":
                case "u":
                case "y":
                    return true
                default:
                    return false
            }
        }

        RegExpParser.prototype.isRangeDash = function() {
            return this.peekChar() === "-" && this.isClassAtom(1)
        }

        RegExpParser.prototype.isDigit = function() {
            return decimalPattern.test(this.peekChar(0))
        }

        RegExpParser.prototype.isClassAtom = function(howMuch) {
            if (howMuch === undefined) {
                howMuch = 0
            }

            switch (this.peekChar(howMuch)) {
                case "]":
                case "\n":
                case "\r":
                case "\u2028":
                case "\u2029":
                    return false
                default:
                    return true
            }
        }

        RegExpParser.prototype.isTerm = function() {
            return this.isAtom() || this.isAssertion()
        }

        RegExpParser.prototype.isAtom = function() {
            if (this.isPatternCharacter()) {
                return true
            }

            switch (this.peekChar(0)) {
                case ".":
                case "\\": // atomEscape
                case "[": // characterClass
                // TODO: isAtom must be called before isAssertion - disambiguate
                case "(": // group
                    return true
                default:
                    return false
            }
        }

        RegExpParser.prototype.isAssertion = function() {
            switch (this.peekChar(0)) {
                case "^":
                case "$":
                    return true
                // '\b' or '\B'
                case "\\":
                    switch (this.peekChar(1)) {
                        case "b":
                        case "B":
                            return true
                        default:
                            return false
                    }
                // '(?=' or '(?!'
                case "(":
                    return (
                        this.peekChar(1) === "?" &&
                        (this.peekChar(2) === "=" || this.peekChar(2) === "!")
                    )
                default:
                    return false
            }
        }

        RegExpParser.prototype.isQuantifier = function() {
            var prevState = this.saveState()
            try {
                return this.quantifier(true) !== undefined
            } catch (e) {
                return false
            } finally {
                this.restoreState(prevState)
            }
        }

        RegExpParser.prototype.isPatternCharacter = function() {
            switch (this.peekChar()) {
                case "^":
                case "$":
                case "\\":
                case ".":
                case "*":
                case "+":
                case "?":
                case "(":
                case ")":
                case "[":
                case "|":
                case "/":
                case "\n":
                case "\r":
                case "\u2028":
                case "\u2029":
                    return false
                default:
                    return true
            }
        }

        RegExpParser.prototype.parseHexDigits = function(howMany) {
            var hexString = ""
            for (var i = 0; i < howMany; i++) {
                var hexChar = this.popChar()
                if (hexDigitPattern.test(hexChar) === false) {
                    throw Error("Expecting a HexDecimal digits")
                }
                hexString += hexChar
            }
            var charCode = parseInt(hexString, 16)
            return { type: "Character", value: charCode }
        }

        RegExpParser.prototype.peekChar = function(howMuch) {
            if (howMuch === undefined) {
                howMuch = 0
            }
            return this.input[this.idx + howMuch]
        }

        RegExpParser.prototype.popChar = function() {
            var nextChar = this.peekChar(0)
            this.consumeChar()
            return nextChar
        }

        RegExpParser.prototype.consumeChar = function(char) {
            if (char !== undefined && this.input[this.idx] !== char) {
                throw Error(
                    "Expected: '" +
                        char +
                        "' but found: '" +
                        this.input[this.idx] +
                        "' at offset: " +
                        this.idx
                )
            }

            if (this.idx >= this.input.length) {
                throw Error("Unexpected end of input")
            }
            this.idx++
        }

        // consts and utilities
        var hexDigitPattern = /[0-9a-fA-F]/
        var decimalPattern = /[0-9]/
        var decimalPatternNoZero = /[1-9]/

        function cc(char) {
            return char.charCodeAt(0)
        }

        function insertToSet(item, set) {
            if (item.length !== undefined) {
                item.forEach(function(subItem) {
                    set.push(subItem)
                })
            } else {
                set.push(item)
            }
        }

        function addFlag(flagObj, flagKey) {
            if (flagObj[flagKey] === true) {
                throw "duplicate flag " + flagKey
            }

            flagObj[flagKey] = true
        }

        function ASSERT_EXISTS(obj) {
            // istanbul ignore next
            if (obj === undefined) {
                throw Error("Internal Error - Should never get here!")
            }
        }

        // istanbul ignore next
        function ASSERT_NEVER_REACH_HERE() {
            throw Error("Internal Error - Should never get here!")
        }

        var i
        var digitsCharCodes = []
        for (i = cc("0"); i <= cc("9"); i++) {
            digitsCharCodes.push(i)
        }

        var wordCharCodes = [cc("_")].concat(digitsCharCodes)
        for (i = cc("a"); i <= cc("z"); i++) {
            wordCharCodes.push(i)
        }

        for (i = cc("A"); i <= cc("Z"); i++) {
            wordCharCodes.push(i)
        }

        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes
        var whitespaceCodes = [
            cc(" "),
            cc("\f"),
            cc("\n"),
            cc("\r"),
            cc("\t"),
            cc("\v"),
            cc("\t"),
            cc("\u00a0"),
            cc("\u1680"),
            cc("\u2000"),
            cc("\u2001"),
            cc("\u2002"),
            cc("\u2003"),
            cc("\u2004"),
            cc("\u2005"),
            cc("\u2006"),
            cc("\u2007"),
            cc("\u2008"),
            cc("\u2009"),
            cc("\u200a"),
            cc("\u2028"),
            cc("\u2029"),
            cc("\u202f"),
            cc("\u205f"),
            cc("\u3000"),
            cc("\ufeff")
        ]

        function BaseRegExpVisitor() {}

        BaseRegExpVisitor.prototype.visitChildren = function(node) {
            for (var key in node) {
                var child = node[key]
                /* istanbul ignore else */
                if (node.hasOwnProperty(key)) {
                    if (child.type !== undefined) {
                        this.visit(child)
                    } else if (Array.isArray(child)) {
                        child.forEach(function(subChild) {
                            this.visit(subChild)
                        }, this)
                    }
                }
            }
        }

        BaseRegExpVisitor.prototype.visit = function(node) {
            switch (node.type) {
                case "Pattern":
                    this.visitPattern(node)
                    break
                case "Flags":
                    this.visitFlags(node)
                    break
                case "Disjunction":
                    this.visitDisjunction(node)
                    break
                case "Alternative":
                    this.visitAlternative(node)
                    break
                case "StartAnchor":
                    this.visitStartAnchor(node)
                    break
                case "EndAnchor":
                    this.visitEndAnchor(node)
                    break
                case "WordBoundary":
                    this.visitWordBoundary(node)
                    break
                case "NonWordBoundary":
                    this.visitNonWordBoundary(node)
                    break
                case "Lookahead":
                    this.visitLookahead(node)
                    break
                case "NegativeLookahead":
                    this.visitNegativeLookahead(node)
                    break
                case "Character":
                    this.visitCharacter(node)
                    break
                case "Set":
                    this.visitSet(node)
                    break
                case "Group":
                    this.visitGroup(node)
                    break
                case "GroupBackReference":
                    this.visitGroupBackReference(node)
                    break
                case "Quantifier":
                    this.visitQuantifier(node)
                    break
            }

            this.visitChildren(node)
        }

        BaseRegExpVisitor.prototype.visitPattern = function(node) {}

        BaseRegExpVisitor.prototype.visitFlags = function(node) {}

        BaseRegExpVisitor.prototype.visitDisjunction = function(node) {}

        BaseRegExpVisitor.prototype.visitAlternative = function(node) {}

        // Assertion
        BaseRegExpVisitor.prototype.visitStartAnchor = function(node) {}

        BaseRegExpVisitor.prototype.visitEndAnchor = function(node) {}

        BaseRegExpVisitor.prototype.visitWordBoundary = function(node) {}

        BaseRegExpVisitor.prototype.visitNonWordBoundary = function(node) {}

        BaseRegExpVisitor.prototype.visitLookahead = function(node) {}

        BaseRegExpVisitor.prototype.visitNegativeLookahead = function(node) {}

        // atoms
        BaseRegExpVisitor.prototype.visitCharacter = function(node) {}

        BaseRegExpVisitor.prototype.visitSet = function(node) {}

        BaseRegExpVisitor.prototype.visitGroup = function(node) {}

        BaseRegExpVisitor.prototype.visitGroupBackReference = function(node) {}

        BaseRegExpVisitor.prototype.visitQuantifier = function(node) {}

        return {
            RegExpParser: RegExpParser,
            BaseRegExpVisitor: BaseRegExpVisitor,
            VERSION: "0.4.0"
        }
    }
)


/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = getRegExpAst;
/* harmony export (immutable) */ __webpack_exports__["a"] = clearRegExpParserCache;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_regexp_to_ast__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_regexp_to_ast___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_regexp_to_ast__);

var regExpAstCache = {};
var regExpParser = new __WEBPACK_IMPORTED_MODULE_0_regexp_to_ast__["RegExpParser"]();
function getRegExpAst(regExp) {
    var regExpStr = regExp.toString();
    if (regExpAstCache.hasOwnProperty(regExpStr)) {
        return regExpAstCache[regExpStr];
    }
    else {
        var regExpAst = regExpParser.pattern(regExpStr);
        regExpAstCache[regExpStr] = regExpAst;
        return regExpAst;
    }
}
function clearRegExpParserCache() {
    regExpAstCache = {};
}
//# sourceMappingURL=reg_exp_parser.js.map

/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["f"] = setNodeLocationOnlyOffset;
/* harmony export (immutable) */ __webpack_exports__["e"] = setNodeLocationFull;
/* harmony export (immutable) */ __webpack_exports__["c"] = addTerminalToCst;
/* harmony export (immutable) */ __webpack_exports__["b"] = addNoneTerminalToCst;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NamedDSLMethodsCollectorVisitor; });
/* harmony export (immutable) */ __webpack_exports__["d"] = expandAllNestedRuleNames;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__grammar_keys__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__grammar_gast_gast_public__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__grammar_gast_gast_visitor_public__ = __webpack_require__(20);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




/**
 * This nodeLocation tracking is not efficient and should only be used
 * when error recovery is enabled or the Token Vector contains virtual Tokens
 * (e.g, Python Indent/Outdent)
 * As it executes the calculation for every single terminal/nonTerminal
 * and does not rely on the fact the token vector is **sorted**
 */
function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {
    // First (valid) update for this cst node
    if (isNaN(currNodeLocation.startOffset) === true) {
        // assumption1: Token location information is either NaN or a valid number
        // assumption2: Token location information is fully valid if it exist
        // (both start/end offsets exist and are numbers).
        currNodeLocation.startOffset = newLocationInfo.startOffset;
        currNodeLocation.endOffset = newLocationInfo.endOffset;
    }
    // Once the startOffset has been updated with a valid number it should never receive
    // any farther updates as the Token vector is sorted.
    // We still have to check this this condition for every new possible location info
    // because with error recovery enabled we may encounter invalid tokens (NaN location props)
    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
        currNodeLocation.endOffset = newLocationInfo.endOffset;
    }
}
/**
 * This nodeLocation tracking is not efficient and should only be used
 * when error recovery is enabled or the Token Vector contains virtual Tokens
 * (e.g, Python Indent/Outdent)
 * As it executes the calculation for every single terminal/nonTerminal
 * and does not rely on the fact the token vector is **sorted**
 */
function setNodeLocationFull(currNodeLocation, newLocationInfo) {
    // First (valid) update for this cst node
    if (isNaN(currNodeLocation.startOffset) === true) {
        // assumption1: Token location information is either NaN or a valid number
        // assumption2: Token location information is fully valid if it exist
        // (all start/end props exist and are numbers).
        currNodeLocation.startOffset = newLocationInfo.startOffset;
        currNodeLocation.startColumn = newLocationInfo.startColumn;
        currNodeLocation.startLine = newLocationInfo.startLine;
        currNodeLocation.endOffset = newLocationInfo.endOffset;
        currNodeLocation.endColumn = newLocationInfo.endColumn;
        currNodeLocation.endLine = newLocationInfo.endLine;
    }
    // Once the start props has been updated with a valid number it should never receive
    // any farther updates as the Token vector is sorted.
    // We still have to check this this condition for every new possible location info
    // because with error recovery enabled we may encounter invalid tokens (NaN location props)
    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
        currNodeLocation.endOffset = newLocationInfo.endOffset;
        currNodeLocation.endColumn = newLocationInfo.endColumn;
        currNodeLocation.endLine = newLocationInfo.endLine;
    }
}
function addTerminalToCst(node, token, tokenTypeName) {
    if (node.children[tokenTypeName] === undefined) {
        node.children[tokenTypeName] = [token];
    }
    else {
        node.children[tokenTypeName].push(token);
    }
}
function addNoneTerminalToCst(node, ruleName, ruleResult) {
    if (node.children[ruleName] === undefined) {
        node.children[ruleName] = [ruleResult];
    }
    else {
        node.children[ruleName].push(ruleResult);
    }
}
var NamedDSLMethodsCollectorVisitor = /** @class */ (function (_super) {
    __extends(NamedDSLMethodsCollectorVisitor, _super);
    function NamedDSLMethodsCollectorVisitor(ruleIdx) {
        var _this = _super.call(this) || this;
        _this.result = [];
        _this.ruleIdx = ruleIdx;
        return _this;
    }
    NamedDSLMethodsCollectorVisitor.prototype.collectNamedDSLMethod = function (node, newNodeConstructor, methodIdx) {
        // TODO: better hack to copy what we need here...
        if (!Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["F" /* isUndefined */])(node.name)) {
            // copy without name so this will indeed be processed later.
            var nameLessNode 
            /* istanbul ignore else */
            = void 0;
            /* istanbul ignore else */
            if (node instanceof __WEBPACK_IMPORTED_MODULE_2__grammar_gast_gast_public__["e" /* Option */] ||
                node instanceof __WEBPACK_IMPORTED_MODULE_2__grammar_gast_gast_public__["f" /* Repetition */] ||
                node instanceof __WEBPACK_IMPORTED_MODULE_2__grammar_gast_gast_public__["g" /* RepetitionMandatory */] ||
                node instanceof __WEBPACK_IMPORTED_MODULE_2__grammar_gast_gast_public__["b" /* Alternation */]) {
                nameLessNode = new newNodeConstructor({
                    definition: node.definition,
                    idx: node.idx
                });
            }
            else if (node instanceof __WEBPACK_IMPORTED_MODULE_2__grammar_gast_gast_public__["h" /* RepetitionMandatoryWithSeparator */] ||
                node instanceof __WEBPACK_IMPORTED_MODULE_2__grammar_gast_gast_public__["i" /* RepetitionWithSeparator */]) {
                nameLessNode = new newNodeConstructor({
                    definition: node.definition,
                    idx: node.idx,
                    separator: node.separator
                });
            }
            else {
                throw Error("non exhaustive match");
            }
            var def = [nameLessNode];
            var key = Object(__WEBPACK_IMPORTED_MODULE_1__grammar_keys__["j" /* getKeyForAutomaticLookahead */])(this.ruleIdx, methodIdx, node.idx);
            this.result.push({ def: def, key: key, name: node.name, orgProd: node });
        }
    };
    NamedDSLMethodsCollectorVisitor.prototype.visitOption = function (node) {
        this.collectNamedDSLMethod(node, __WEBPACK_IMPORTED_MODULE_2__grammar_gast_gast_public__["e" /* Option */], __WEBPACK_IMPORTED_MODULE_1__grammar_keys__["g" /* OPTION_IDX */]);
    };
    NamedDSLMethodsCollectorVisitor.prototype.visitRepetition = function (node) {
        this.collectNamedDSLMethod(node, __WEBPACK_IMPORTED_MODULE_2__grammar_gast_gast_public__["f" /* Repetition */], __WEBPACK_IMPORTED_MODULE_1__grammar_keys__["e" /* MANY_IDX */]);
    };
    NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionMandatory = function (node) {
        this.collectNamedDSLMethod(node, __WEBPACK_IMPORTED_MODULE_2__grammar_gast_gast_public__["g" /* RepetitionMandatory */], __WEBPACK_IMPORTED_MODULE_1__grammar_keys__["a" /* AT_LEAST_ONE_IDX */]);
    };
    NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {
        this.collectNamedDSLMethod(node, __WEBPACK_IMPORTED_MODULE_2__grammar_gast_gast_public__["h" /* RepetitionMandatoryWithSeparator */], __WEBPACK_IMPORTED_MODULE_1__grammar_keys__["b" /* AT_LEAST_ONE_SEP_IDX */]);
    };
    NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionWithSeparator = function (node) {
        this.collectNamedDSLMethod(node, __WEBPACK_IMPORTED_MODULE_2__grammar_gast_gast_public__["i" /* RepetitionWithSeparator */], __WEBPACK_IMPORTED_MODULE_1__grammar_keys__["f" /* MANY_SEP_IDX */]);
    };
    NamedDSLMethodsCollectorVisitor.prototype.visitAlternation = function (node) {
        var _this = this;
        this.collectNamedDSLMethod(node, __WEBPACK_IMPORTED_MODULE_2__grammar_gast_gast_public__["b" /* Alternation */], __WEBPACK_IMPORTED_MODULE_1__grammar_keys__["h" /* OR_IDX */]);
        var hasMoreThanOneAlternative = node.definition.length > 1;
        Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(node.definition, function (currFlatAlt, altIdx) {
            if (!Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["F" /* isUndefined */])(currFlatAlt.name)) {
                var def = currFlatAlt.definition;
                if (hasMoreThanOneAlternative) {
                    def = [new __WEBPACK_IMPORTED_MODULE_2__grammar_gast_gast_public__["e" /* Option */]({ definition: currFlatAlt.definition })];
                }
                else {
                    // mandatory
                    def = currFlatAlt.definition;
                }
                var key = Object(__WEBPACK_IMPORTED_MODULE_1__grammar_keys__["i" /* getKeyForAltIndex */])(_this.ruleIdx, __WEBPACK_IMPORTED_MODULE_1__grammar_keys__["h" /* OR_IDX */], node.idx, altIdx);
                _this.result.push({
                    def: def,
                    key: key,
                    name: currFlatAlt.name,
                    orgProd: currFlatAlt
                });
            }
        });
    };
    return NamedDSLMethodsCollectorVisitor;
}(__WEBPACK_IMPORTED_MODULE_3__grammar_gast_gast_visitor_public__["a" /* GAstVisitor */]));

function expandAllNestedRuleNames(topRules, fullToShortName) {
    var result = {
        allRuleNames: []
    };
    Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(topRules, function (currTopRule) {
        var currTopRuleShortName = fullToShortName[currTopRule.name];
        result.allRuleNames.push(currTopRule.name);
        var namedCollectorVisitor = new NamedDSLMethodsCollectorVisitor(currTopRuleShortName);
        currTopRule.accept(namedCollectorVisitor);
        Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(namedCollectorVisitor.result, function (_a) {
            var def = _a.def, key = _a.key, name = _a.name;
            result.allRuleNames.push(currTopRule.name + name);
        });
    });
    return result;
}
//# sourceMappingURL=cst.js.map

/***/ }),
/* 48 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export traverse */
/* harmony export (immutable) */ __webpack_exports__["b"] = reduceToSQL;
/* harmony export (immutable) */ __webpack_exports__["a"] = escapeQuotes;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var identity = function identity(a) {
  return a;
};


function traverse(node, iterator, xform, accum) {
  accum = xform(accum, iterator(node));
  var source = node.getState().source;
  return (typeof source === "undefined" ? "undefined" : _typeof(source)) === "object" && !Array.isArray(source) ? traverse(source, iterator, xform, accum) : accum;
}

function reduceToSQL(context, node) {
  var initialSQL = {
    select: [],
    from: "",
    where: [],
    groupby: [],
    having: [],
    orderby: [],
    limit: "",
    offset: "",
    unresolved: {}
  };

  function toSQL(accum, rightNode) {
    return context.parser.parseDataState(rightNode.getState(), accum);
  }

  return traverse(node, identity, toSQL, initialSQL);
}

function escapeQuotes(string) {
  if (typeof string === "string") {
    return string.replace(/'/gi, "''");
  } else {
    return string;
  }
}

/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseFilter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__create_parser__ = __webpack_require__(11);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };




function parseFilter(sql, transform) {
  var parser = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : __WEBPACK_IMPORTED_MODULE_0__create_parser__["b" /* default */];

  switch (transform.type) {
    case "filter":
      sql.where.push("(" + (_typeof(transform.expr) === "object" ? parser.parseExpression(transform.expr) : transform.expr) + ")");
    default:
      return sql;
  }
}

/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseSource;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__create_parser__ = __webpack_require__(11);


function joinRelation(type) {
  switch (type) {
    case "join.left":
      return "LEFT JOIN";
    case "join.right":
      return "RIGHT JOIN";
    case "join.inner":
      return "INNER JOIN";
    case "join":
    default:
      return "JOIN";
  }
}

function parseSource(transforms) {
  var parser = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : __WEBPACK_IMPORTED_MODULE_0__create_parser__["b" /* default */];

  return transforms.reduce(function (stmt, transform, index) {
    if (typeof transform.table === "string" && transform.type === "scan") {
      return stmt.concat(transform.table);
    } else if (transform.type === "join" || transform.type === "join.inner" || transform.type === "join.left" || transform.type === "join.right") {
      var right = stmt.pop();
      var left = stmt.pop();
      var joinType = typeof transform.type === "string" ? transform.type : "join";
      // $FlowFixMe
      var joinStmt = left + " " + joinRelation(joinType) + " " + right;
      var aliasStmt = typeof transform.as === "string" ? " AS " + transform.as : "";
      return stmt.concat(joinStmt + aliasStmt);
    } else if (transform.type === "data" || transform.type === "root") {
      // $FlowFixMe
      var subquery = parser.writeSQL(transform);
      return stmt.concat("(" + subquery + ")");
    } else {
      return stmt;
    }
  }, []).join();
}

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (false) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;


/***/ }),
/* 53 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var af = moment.defineLocale('af', {
        months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
        weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
        weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
        weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
        meridiemParse: /vm|nm/i,
        isPM : function (input) {
            return /^nm$/i.test(input);
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? 'vm' : 'VM';
            } else {
                return isLower ? 'nm' : 'NM';
            }
        },
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Vandag om] LT',
            nextDay : '[Mre om] LT',
            nextWeek : 'dddd [om] LT',
            lastDay : '[Gister om] LT',
            lastWeek : '[Laas] dddd [om] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'oor %s',
            past : '%s gelede',
            s : '\'n paar sekondes',
            ss : '%d sekondes',
            m : '\'n minuut',
            mm : '%d minute',
            h : '\'n uur',
            hh : '%d ure',
            d : '\'n dag',
            dd : '%d dae',
            M : '\'n maand',
            MM : '%d maande',
            y : '\'n jaar',
            yy : '%d jaar'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter
        },
        week : {
            dow : 1, // Maandag is die eerste dag van die week.
            doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
        }
    });

    return af;

})));


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    }, pluralForm = function (n) {
        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    }, plurals = {
        s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
    }, pluralize = function (u) {
        return function (number, withoutSuffix, string, isFuture) {
            var f = pluralForm(number),
                str = plurals[u][pluralForm(number)];
            if (f === 2) {
                str = str[withoutSuffix ? 0 : 1];
            }
            return str.replace(/%d/i, number);
        };
    }, months = [
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        ''
    ];

    var ar = moment.defineLocale('ar', {
        months : months,
        monthsShort : months,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'D/\u200FM/\u200FYYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM : function (input) {
            return '' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : pluralize('s'),
            ss : pluralize('s'),
            m : pluralize('m'),
            mm : pluralize('m'),
            h : pluralize('h'),
            hh : pluralize('h'),
            d : pluralize('d'),
            dd : pluralize('d'),
            M : pluralize('M'),
            MM : pluralize('M'),
            y : pluralize('y'),
            yy : pluralize('y')
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            }).replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '');
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 12th is the first week of the year.
        }
    });

    return ar;

})));


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var arDz = moment.defineLocale('ar-dz', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : '',
            ss : '%d ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return arDz;

})));


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var arKw = moment.defineLocale('ar-kw', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : '',
            ss : '%d ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 12  // The week that contains Jan 12th is the first week of the year.
        }
    });

    return arKw;

})));


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '1',
        '2': '2',
        '3': '3',
        '4': '4',
        '5': '5',
        '6': '6',
        '7': '7',
        '8': '8',
        '9': '9',
        '0': '0'
    }, pluralForm = function (n) {
        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    }, plurals = {
        s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
    }, pluralize = function (u) {
        return function (number, withoutSuffix, string, isFuture) {
            var f = pluralForm(number),
                str = plurals[u][pluralForm(number)];
            if (f === 2) {
                str = str[withoutSuffix ? 0 : 1];
            }
            return str.replace(/%d/i, number);
        };
    }, months = [
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        ''
    ];

    var arLy = moment.defineLocale('ar-ly', {
        months : months,
        monthsShort : months,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'D/\u200FM/\u200FYYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM : function (input) {
            return '' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : pluralize('s'),
            ss : pluralize('s'),
            m : pluralize('m'),
            mm : pluralize('m'),
            h : pluralize('h'),
            hh : pluralize('h'),
            d : pluralize('d'),
            dd : pluralize('d'),
            M : pluralize('M'),
            MM : pluralize('M'),
            y : pluralize('y'),
            yy : pluralize('y')
        },
        preparse: function (string) {
            return string.replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '');
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 12th is the first week of the year.
        }
    });

    return arLy;

})));


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var arMa = moment.defineLocale('ar-ma', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : '',
            ss : '%d ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 12th is the first week of the year.
        }
    });

    return arMa;

})));


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var arSa = moment.defineLocale('ar-sa', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM : function (input) {
            return '' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : '',
            ss : '%d ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            }).replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '');
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return arSa;

})));


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var arTn = moment.defineLocale('ar-tn', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s',
            past: ' %s',
            s: '',
            ss : '%d ',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return arTn;

})));


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var suffixes = {
        1: '-inci',
        5: '-inci',
        8: '-inci',
        70: '-inci',
        80: '-inci',
        2: '-nci',
        7: '-nci',
        20: '-nci',
        50: '-nci',
        3: '-nc',
        4: '-nc',
        100: '-nc',
        6: '-nc',
        9: '-uncu',
        10: '-uncu',
        30: '-uncu',
        60: '-nc',
        90: '-nc'
    };

    var az = moment.defineLocale('az', {
        months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
        monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
        weekdays : 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),
        weekdaysShort : 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),
        weekdaysMin : 'Bz_BE_A__CA_C_'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[bugn saat] LT',
            nextDay : '[sabah saat] LT',
            nextWeek : '[gln hft] dddd [saat] LT',
            lastDay : '[dnn] LT',
            lastWeek : '[ken hft] dddd [saat] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s sonra',
            past : '%s vvl',
            s : 'birne saniy',
            ss : '%d saniy',
            m : 'bir dqiq',
            mm : '%d dqiq',
            h : 'bir saat',
            hh : '%d saat',
            d : 'bir gn',
            dd : '%d gn',
            M : 'bir ay',
            MM : '%d ay',
            y : 'bir il',
            yy : '%d il'
        },
        meridiemParse: /gec|shr|gndz|axam/,
        isPM : function (input) {
            return /^(gndz|axam)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'gec';
            } else if (hour < 12) {
                return 'shr';
            } else if (hour < 17) {
                return 'gndz';
            } else {
                return 'axam';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
        ordinal : function (number) {
            if (number === 0) {  // special case for zero
                return number + '-nc';
            }
            var a = number % 10,
                b = number % 100 - a,
                c = number >= 100 ? 100 : null;
            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return az;

})));


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'ss': withoutSuffix ? '__' : '__',
            'mm': withoutSuffix ? '__' : '__',
            'hh': withoutSuffix ? '__' : '__',
            'dd': '__',
            'MM': '__',
            'yy': '__'
        };
        if (key === 'm') {
            return withoutSuffix ? '' : '';
        }
        else if (key === 'h') {
            return withoutSuffix ? '' : '';
        }
        else {
            return number + ' ' + plural(format[key], +number);
        }
    }

    var be = moment.defineLocale('be', {
        months : {
            format: '___________'.split('_'),
            standalone: '___________'.split('_')
        },
        monthsShort : '___________'.split('_'),
        weekdays : {
            format: '______'.split('_'),
            standalone: '______'.split('_'),
            isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/
        },
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY .',
            LLL : 'D MMMM YYYY ., HH:mm',
            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
        },
        calendar : {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            lastDay: '[ ] LT',
            nextWeek: function () {
                return '[] dddd [] LT';
            },
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 5:
                    case 6:
                        return '[ ] dddd [] LT';
                    case 1:
                    case 2:
                    case 4:
                        return '[ ] dddd [] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            m : relativeTimeWithPlural,
            mm : relativeTimeWithPlural,
            h : relativeTimeWithPlural,
            hh : relativeTimeWithPlural,
            d : '',
            dd : relativeTimeWithPlural,
            M : '',
            MM : relativeTimeWithPlural,
            y : '',
            yy : relativeTimeWithPlural
        },
        meridiemParse: /|||/,
        isPM : function (input) {
            return /^(|)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return '';
            } else {
                return '';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'M':
                case 'd':
                case 'DDD':
                case 'w':
                case 'W':
                    return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-' : number + '-';
                case 'D':
                    return number + '-';
                default:
                    return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return be;

})));


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var bg = moment.defineLocale('bg', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'D.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd, D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 6:
                        return '[ ] dddd [] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[ ] dddd [] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : ' ',
            ss : '%d ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
        ordinal : function (number) {
            var lastDigit = number % 10,
                last2Digits = number % 100;
            if (number === 0) {
                return number + '-';
            } else if (last2Digits === 0) {
                return number + '-';
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + '-';
            } else if (lastDigit === 1) {
                return number + '-';
            } else if (lastDigit === 2) {
                return number + '-';
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + '-';
            } else {
                return number + '-';
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return bg;

})));


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var bm = moment.defineLocale('bm', {
        months : 'Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mkalo_Zuwnkalo_Zuluyekalo_Utikalo_Stanburukalo_kutburukalo_Nowanburukalo_Desanburukalo'.split('_'),
        monthsShort : 'Zan_Few_Mar_Awi_M_Zuw_Zul_Uti_St_ku_Now_Des'.split('_'),
        weekdays : 'Kari_Ntnn_Tarata_Araba_Alamisa_Juma_Sibiri'.split('_'),
        weekdaysShort : 'Kar_Nt_Tar_Ara_Ala_Jum_Sib'.split('_'),
        weekdaysMin : 'Ka_Nt_Ta_Ar_Al_Ju_Si'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'MMMM [tile] D [san] YYYY',
            LLL : 'MMMM [tile] D [san] YYYY [lr] HH:mm',
            LLLL : 'dddd MMMM [tile] D [san] YYYY [lr] HH:mm'
        },
        calendar : {
            sameDay : '[Bi lr] LT',
            nextDay : '[Sini lr] LT',
            nextWeek : 'dddd [don lr] LT',
            lastDay : '[Kunu lr] LT',
            lastWeek : 'dddd [tmnen lr] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s kn',
            past : 'a b %s b',
            s : 'sanga dama dama',
            ss : 'sekondi %d',
            m : 'miniti kelen',
            mm : 'miniti %d',
            h : 'lr kelen',
            hh : 'lr %d',
            d : 'tile kelen',
            dd : 'tile %d',
            M : 'kalo kelen',
            MM : 'kalo %d',
            y : 'san kelen',
            yy : 'san %d'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return bm;

})));


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var bn = moment.defineLocale('bn', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm ',
            LTS : 'A h:mm:ss ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm '
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /||||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if ((meridiem === '' && hour >= 4) ||
                    (meridiem === '' && hour < 5) ||
                    meridiem === '') {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return bn;

})));


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var bo = moment.defineLocale('bo', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm',
            LTS : 'A h:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm',
            LLLL : 'dddd, D MMMM YYYY, A h:mm'
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : '[], LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : '',
            ss : '%d ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /||||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if ((meridiem === '' && hour >= 4) ||
                    (meridiem === '' && hour < 5) ||
                    meridiem === '') {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return bo;

})));


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function relativeTimeWithMutation(number, withoutSuffix, key) {
        var format = {
            'mm': 'munutenn',
            'MM': 'miz',
            'dd': 'devezh'
        };
        return number + ' ' + mutation(format[key], number);
    }
    function specialMutationForYears(number) {
        switch (lastNumber(number)) {
            case 1:
            case 3:
            case 4:
            case 5:
            case 9:
                return number + ' bloaz';
            default:
                return number + ' vloaz';
        }
    }
    function lastNumber(number) {
        if (number > 9) {
            return lastNumber(number % 10);
        }
        return number;
    }
    function mutation(text, number) {
        if (number === 2) {
            return softMutation(text);
        }
        return text;
    }
    function softMutation(text) {
        var mutationTable = {
            'm': 'v',
            'b': 'v',
            'd': 'z'
        };
        if (mutationTable[text.charAt(0)] === undefined) {
            return text;
        }
        return mutationTable[text.charAt(0)] + text.substring(1);
    }

    var br = moment.defineLocale('br', {
        months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
        monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
        weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
        weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
        weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'h[e]mm A',
            LTS : 'h[e]mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D [a viz] MMMM YYYY',
            LLL : 'D [a viz] MMMM YYYY h[e]mm A',
            LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'
        },
        calendar : {
            sameDay : '[Hiziv da] LT',
            nextDay : '[Warc\'hoazh da] LT',
            nextWeek : 'dddd [da] LT',
            lastDay : '[Dec\'h da] LT',
            lastWeek : 'dddd [paset da] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'a-benn %s',
            past : '%s \'zo',
            s : 'un nebeud segondenno',
            ss : '%d eilenn',
            m : 'ur vunutenn',
            mm : relativeTimeWithMutation,
            h : 'un eur',
            hh : '%d eur',
            d : 'un devezh',
            dd : relativeTimeWithMutation,
            M : 'ur miz',
            MM : relativeTimeWithMutation,
            y : 'ur bloaz',
            yy : specialMutationForYears
        },
        dayOfMonthOrdinalParse: /\d{1,2}(a|vet)/,
        ordinal : function (number) {
            var output = (number === 1) ? 'a' : 'vet';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return br;

})));


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
            case 'ss':
                if (number === 1) {
                    result += 'sekunda';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'sekunde';
                } else {
                    result += 'sekundi';
                }
                return result;
            case 'm':
                return withoutSuffix ? 'jedna minuta' : 'jedne minute';
            case 'mm':
                if (number === 1) {
                    result += 'minuta';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'minute';
                } else {
                    result += 'minuta';
                }
                return result;
            case 'h':
                return withoutSuffix ? 'jedan sat' : 'jednog sata';
            case 'hh':
                if (number === 1) {
                    result += 'sat';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'sata';
                } else {
                    result += 'sati';
                }
                return result;
            case 'dd':
                if (number === 1) {
                    result += 'dan';
                } else {
                    result += 'dana';
                }
                return result;
            case 'MM':
                if (number === 1) {
                    result += 'mjesec';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'mjeseca';
                } else {
                    result += 'mjeseci';
                }
                return result;
            case 'yy':
                if (number === 1) {
                    result += 'godina';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'godine';
                } else {
                    result += 'godina';
                }
                return result;
        }
    }

    var bs = moment.defineLocale('bs', {
        months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
        weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
        weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[danas u] LT',
            nextDay  : '[sutra u] LT',
            nextWeek : function () {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedjelju] [u] LT';
                    case 3:
                        return '[u] [srijedu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[juer u] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                        return '[prolu] dddd [u] LT';
                    case 6:
                        return '[prole] [subote] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[proli] dddd [u] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'par sekundi',
            ss     : translate,
            m      : translate,
            mm     : translate,
            h      : translate,
            hh     : translate,
            d      : 'dan',
            dd     : translate,
            M      : 'mjesec',
            MM     : translate,
            y      : 'godinu',
            yy     : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return bs;

})));


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var ca = moment.defineLocale('ca', {
        months : {
            standalone: 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
            format: 'de gener_de febrer_de mar_d\'abril_de maig_de juny_de juliol_d\'agost_de setembre_d\'octubre_de novembre_de desembre'.split('_'),
            isFormat: /D[oD]?(\s)+MMMM/
        },
        monthsShort : 'gen._febr._mar_abr._maig_juny_jul._ag._set._oct._nov._des.'.split('_'),
        monthsParseExact : true,
        weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
        weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
        weekdaysMin : 'dg_dl_dt_dc_dj_dv_ds'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM [de] YYYY',
            ll : 'D MMM YYYY',
            LLL : 'D MMMM [de] YYYY [a les] H:mm',
            lll : 'D MMM YYYY, H:mm',
            LLLL : 'dddd D MMMM [de] YYYY [a les] H:mm',
            llll : 'ddd D MMM YYYY, H:mm'
        },
        calendar : {
            sameDay : function () {
                return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            nextDay : function () {
                return '[dem a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            lastDay : function () {
                return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'd\'aqu %s',
            past : 'fa %s',
            s : 'uns segons',
            ss : '%d segons',
            m : 'un minut',
            mm : '%d minuts',
            h : 'una hora',
            hh : '%d hores',
            d : 'un dia',
            dd : '%d dies',
            M : 'un mes',
            MM : '%d mesos',
            y : 'un any',
            yy : '%d anys'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
        ordinal : function (number, period) {
            var output = (number === 1) ? 'r' :
                (number === 2) ? 'n' :
                (number === 3) ? 'r' :
                (number === 4) ? 't' : '';
            if (period === 'w' || period === 'W') {
                output = 'a';
            }
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return ca;

})));


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var months = 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_'),
        monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_');

    var monthsParse = [/^led/i, /^no/i, /^be/i, /^dub/i, /^kv/i, /^(vn|erven$|ervna)/i, /^(vc|ervenec|ervence)/i, /^srp/i, /^z/i, /^j/i, /^lis/i, /^pro/i];
    // NOTE: 'erven' is substring of 'ervenec'; therefore 'ervenec' must precede 'erven' in the regex to be fully matched.
    // Otherwise parser matches '1. ervenec' as '1. erven' + 'ec'.
    var monthsRegex = /^(leden|nor|bezen|duben|kvten|ervenec|ervence|erven|ervna|srpen|z|jen|listopad|prosinec|led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i;

    function plural(n) {
        return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's':  // a few seconds / in a few seconds / a few seconds ago
                return (withoutSuffix || isFuture) ? 'pr sekund' : 'pr sekundami';
            case 'ss': // 9 seconds / in 9 seconds / 9 seconds ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'sekundy' : 'sekund');
                } else {
                    return result + 'sekundami';
                }
                break;
            case 'm':  // a minute / in a minute / a minute ago
                return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
            case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'minuty' : 'minut');
                } else {
                    return result + 'minutami';
                }
                break;
            case 'h':  // an hour / in an hour / an hour ago
                return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
            case 'hh': // 9 hours / in 9 hours / 9 hours ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'hodiny' : 'hodin');
                } else {
                    return result + 'hodinami';
                }
                break;
            case 'd':  // a day / in a day / a day ago
                return (withoutSuffix || isFuture) ? 'den' : 'dnem';
            case 'dd': // 9 days / in 9 days / 9 days ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'dny' : 'dn');
                } else {
                    return result + 'dny';
                }
                break;
            case 'M':  // a month / in a month / a month ago
                return (withoutSuffix || isFuture) ? 'msc' : 'mscem';
            case 'MM': // 9 months / in 9 months / 9 months ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'msce' : 'msc');
                } else {
                    return result + 'msci';
                }
                break;
            case 'y':  // a year / in a year / a year ago
                return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
            case 'yy': // 9 years / in 9 years / 9 years ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'roky' : 'let');
                } else {
                    return result + 'lety';
                }
                break;
        }
    }

    var cs = moment.defineLocale('cs', {
        months : months,
        monthsShort : monthsShort,
        monthsRegex : monthsRegex,
        monthsShortRegex : monthsRegex,
        // NOTE: 'erven' is substring of 'ervenec'; therefore 'ervenec' must precede 'erven' in the regex to be fully matched.
        // Otherwise parser matches '1. ervenec' as '1. erven' + 'ec'.
        monthsStrictRegex : /^(leden|ledna|nora|nor|bezen|bezna|duben|dubna|kvten|kvtna|ervenec|ervence|erven|ervna|srpen|srpna|z|jen|jna|listopadu|listopad|prosinec|prosince)/i,
        monthsShortStrictRegex : /^(led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i,
        monthsParse : monthsParse,
        longMonthsParse : monthsParse,
        shortMonthsParse : monthsParse,
        weekdays : 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),
        weekdaysShort : 'ne_po_t_st_t_p_so'.split('_'),
        weekdaysMin : 'ne_po_t_st_t_p_so'.split('_'),
        longDateFormat : {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd D. MMMM YYYY H:mm',
            l : 'D. M. YYYY'
        },
        calendar : {
            sameDay: '[dnes v] LT',
            nextDay: '[ztra v] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[v nedli v] LT';
                    case 1:
                    case 2:
                        return '[v] dddd [v] LT';
                    case 3:
                        return '[ve stedu v] LT';
                    case 4:
                        return '[ve tvrtek v] LT';
                    case 5:
                        return '[v ptek v] LT';
                    case 6:
                        return '[v sobotu v] LT';
                }
            },
            lastDay: '[vera v] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[minulou nedli v] LT';
                    case 1:
                    case 2:
                        return '[minul] dddd [v] LT';
                    case 3:
                        return '[minulou stedu v] LT';
                    case 4:
                    case 5:
                        return '[minul] dddd [v] LT';
                    case 6:
                        return '[minulou sobotu v] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : 'ped %s',
            s : translate,
            ss : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        dayOfMonthOrdinalParse : /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return cs;

})));


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var cv = moment.defineLocale('cv', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'YYYY [] MMMM [] D[-]',
            LLL : 'YYYY [] MMMM [] D[-], HH:mm',
            LLLL : 'dddd, YYYY [] MMMM [] D[-], HH:mm'
        },
        calendar : {
            sameDay: '[] LT []',
            nextDay: '[] LT []',
            lastDay: '[] LT []',
            nextWeek: '[] dddd LT []',
            lastWeek: '[] dddd LT []',
            sameElse: 'L'
        },
        relativeTime : {
            future : function (output) {
                var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';
                return output + affix;
            },
            past : '%s ',
            s : '- ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        dayOfMonthOrdinalParse: /\d{1,2}-/,
        ordinal : '%d-',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return cv;

})));


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var cy = moment.defineLocale('cy', {
        months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
        monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
        weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
        weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
        weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
        weekdaysParseExact : true,
        // time formats are the same as en-gb
        longDateFormat: {
            LT: 'HH:mm',
            LTS : 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[Heddiw am] LT',
            nextDay: '[Yfory am] LT',
            nextWeek: 'dddd [am] LT',
            lastDay: '[Ddoe am] LT',
            lastWeek: 'dddd [diwethaf am] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'mewn %s',
            past: '%s yn l',
            s: 'ychydig eiliadau',
            ss: '%d eiliad',
            m: 'munud',
            mm: '%d munud',
            h: 'awr',
            hh: '%d awr',
            d: 'diwrnod',
            dd: '%d diwrnod',
            M: 'mis',
            MM: '%d mis',
            y: 'blwyddyn',
            yy: '%d flynedd'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
        // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
        ordinal: function (number) {
            var b = number,
                output = '',
                lookup = [
                    '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
                    'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
                ];
            if (b > 20) {
                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                    output = 'fed'; // not 30ain, 70ain or 90ain
                } else {
                    output = 'ain';
                }
            } else if (b > 0) {
                output = lookup[b];
            }
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return cy;

})));


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var da = moment.defineLocale('da', {
        months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
        weekdaysShort : 'sn_man_tir_ons_tor_fre_lr'.split('_'),
        weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY HH:mm',
            LLLL : 'dddd [d.] D. MMMM YYYY [kl.] HH:mm'
        },
        calendar : {
            sameDay : '[i dag kl.] LT',
            nextDay : '[i morgen kl.] LT',
            nextWeek : 'p dddd [kl.] LT',
            lastDay : '[i gr kl.] LT',
            lastWeek : '[i] dddd[s kl.] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : '%s siden',
            s : 'f sekunder',
            ss : '%d sekunder',
            m : 'et minut',
            mm : '%d minutter',
            h : 'en time',
            hh : '%d timer',
            d : 'en dag',
            dd : '%d dage',
            M : 'en mned',
            MM : '%d mneder',
            y : 'et r',
            yy : '%d r'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return da;

})));


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var de = moment.defineLocale('de', {
        months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort : 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
        monthsParseExact : true,
        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY HH:mm',
            LLLL : 'dddd, D. MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime : {
            future : 'in %s',
            past : 'vor %s',
            s : 'ein paar Sekunden',
            ss : '%d Sekunden',
            m : processRelativeTime,
            mm : '%d Minuten',
            h : processRelativeTime,
            hh : '%d Stunden',
            d : processRelativeTime,
            dd : processRelativeTime,
            M : processRelativeTime,
            MM : processRelativeTime,
            y : processRelativeTime,
            yy : processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return de;

})));


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var deAt = moment.defineLocale('de-at', {
        months : 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort : 'Jn._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
        monthsParseExact : true,
        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY HH:mm',
            LLLL : 'dddd, D. MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime : {
            future : 'in %s',
            past : 'vor %s',
            s : 'ein paar Sekunden',
            ss : '%d Sekunden',
            m : processRelativeTime,
            mm : '%d Minuten',
            h : processRelativeTime,
            hh : '%d Stunden',
            d : processRelativeTime,
            dd : processRelativeTime,
            M : processRelativeTime,
            MM : processRelativeTime,
            y : processRelativeTime,
            yy : processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return deAt;

})));


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var deCh = moment.defineLocale('de-ch', {
        months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort : 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
        monthsParseExact : true,
        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY HH:mm',
            LLLL : 'dddd, D. MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime : {
            future : 'in %s',
            past : 'vor %s',
            s : 'ein paar Sekunden',
            ss : '%d Sekunden',
            m : processRelativeTime,
            mm : '%d Minuten',
            h : processRelativeTime,
            hh : '%d Stunden',
            d : processRelativeTime,
            dd : processRelativeTime,
            M : processRelativeTime,
            MM : processRelativeTime,
            y : processRelativeTime,
            yy : processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return deCh;

})));


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var months = [
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        ''
    ], weekdays = [
        '',
        '',
        '',
        '',
        '',
        '',
        ''
    ];

    var dv = moment.defineLocale('dv', {
        months : months,
        monthsShort : months,
        weekdays : weekdays,
        weekdaysShort : weekdays,
        weekdaysMin : '______'.split('_'),
        longDateFormat : {

            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'D/M/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM : function (input) {
            return '' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : '',
            ss : 'd% ',
            m : '',
            mm : ' %d',
            h : '',
            hh : ' %d',
            d : '',
            dd : ' %d',
            M : '',
            MM : ' %d',
            y : '',
            yy : ' %d'
        },
        preparse: function (string) {
            return string.replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/,/g, '');
        },
        week : {
            dow : 7,  // Sunday is the first day of the week.
            doy : 12  // The week that contains Jan 12th is the first week of the year.
        }
    });

    return dv;

})));


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }


    var el = moment.defineLocale('el', {
        monthsNominativeEl : '___________'.split('_'),
        monthsGenitiveEl : '___________'.split('_'),
        months : function (momentToFormat, format) {
            if (!momentToFormat) {
                return this._monthsNominativeEl;
            } else if (typeof format === 'string' && /D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
                return this._monthsGenitiveEl[momentToFormat.month()];
            } else {
                return this._monthsNominativeEl[momentToFormat.month()];
            }
        },
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? '' : '';
            } else {
                return isLower ? '' : '';
            }
        },
        isPM : function (input) {
            return ((input + '').toLowerCase()[0] === '');
        },
        meridiemParse : /[]\.??\.?/i,
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendarEl : {
            sameDay : '[ {}] LT',
            nextDay : '[ {}] LT',
            nextWeek : 'dddd [{}] LT',
            lastDay : '[ {}] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 6:
                        return '[ ] dddd [{}] LT';
                    default:
                        return '[ ] dddd [{}] LT';
                }
            },
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendarEl[key],
                hours = mom && mom.hours();
            if (isFunction(output)) {
                output = output.apply(mom);
            }
            return output.replace('{}', (hours % 12 === 1 ? '' : ''));
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4st is the first week of the year.
        }
    });

    return el;

})));


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var enSG = moment.defineLocale('en-SG', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            ss : '%d seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return enSG;

})));


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var enAu = moment.defineLocale('en-au', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            ss : '%d seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return enAu;

})));


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var enCa = moment.defineLocale('en-ca', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'YYYY-MM-DD',
            LL : 'MMMM D, YYYY',
            LLL : 'MMMM D, YYYY h:mm A',
            LLLL : 'dddd, MMMM D, YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            ss : '%d seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    return enCa;

})));


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var enGb = moment.defineLocale('en-gb', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            ss : '%d seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return enGb;

})));


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var enIe = moment.defineLocale('en-ie', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            ss : '%d seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return enIe;

})));


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var enIl = moment.defineLocale('en-il', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    return enIl;

})));


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var enNz = moment.defineLocale('en-nz', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            ss : '%d seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return enNz;

})));


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var eo = moment.defineLocale('eo', {
        months : 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_ag_sep_okt_nov_dec'.split('_'),
        weekdays : 'dimano_lundo_mardo_merkredo_ado_vendredo_sabato'.split('_'),
        weekdaysShort : 'dim_lun_mard_merk_a_ven_sab'.split('_'),
        weekdaysMin : 'di_lu_ma_me_a_ve_sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'D[-a de] MMMM, YYYY',
            LLL : 'D[-a de] MMMM, YYYY HH:mm',
            LLLL : 'dddd, [la] D[-a de] MMMM, YYYY HH:mm'
        },
        meridiemParse: /[ap]\.t\.m/i,
        isPM: function (input) {
            return input.charAt(0).toLowerCase() === 'p';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'p.t.m.' : 'P.T.M.';
            } else {
                return isLower ? 'a.t.m.' : 'A.T.M.';
            }
        },
        calendar : {
            sameDay : '[Hodia je] LT',
            nextDay : '[Morga je] LT',
            nextWeek : 'dddd [je] LT',
            lastDay : '[Hiera je] LT',
            lastWeek : '[pasinta] dddd [je] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'post %s',
            past : 'anta %s',
            s : 'sekundoj',
            ss : '%d sekundoj',
            m : 'minuto',
            mm : '%d minutoj',
            h : 'horo',
            hh : '%d horoj',
            d : 'tago',//ne 'diurno', ar estas uzita por proksimumo
            dd : '%d tagoj',
            M : 'monato',
            MM : '%d monatoj',
            y : 'jaro',
            yy : '%d jaroj'
        },
        dayOfMonthOrdinalParse: /\d{1,2}a/,
        ordinal : '%da',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return eo;

})));


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

    var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
    var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

    var es = moment.defineLocale('es', {
        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
        monthsShort : function (m, format) {
            if (!m) {
                return monthsShortDot;
            } else if (/-MMM-/.test(format)) {
                return monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        monthsRegex : monthsRegex,
        monthsShortRegex : monthsRegex,
        monthsStrictRegex : /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex : /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse : monthsParse,
        longMonthsParse : monthsParse,
        shortMonthsParse : monthsParse,
        weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
        weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
        weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY H:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
        },
        calendar : {
            sameDay : function () {
                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextDay : function () {
                return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastDay : function () {
                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'en %s',
            past : 'hace %s',
            s : 'unos segundos',
            ss : '%d segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'una hora',
            hh : '%d horas',
            d : 'un da',
            dd : '%d das',
            M : 'un mes',
            MM : '%d meses',
            y : 'un ao',
            yy : '%d aos'
        },
        dayOfMonthOrdinalParse : /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return es;

})));


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

    var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
    var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

    var esDo = moment.defineLocale('es-do', {
        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
        monthsShort : function (m, format) {
            if (!m) {
                return monthsShortDot;
            } else if (/-MMM-/.test(format)) {
                return monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
        weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
        weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY h:mm A',
            LLLL : 'dddd, D [de] MMMM [de] YYYY h:mm A'
        },
        calendar : {
            sameDay : function () {
                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextDay : function () {
                return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastDay : function () {
                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'en %s',
            past : 'hace %s',
            s : 'unos segundos',
            ss : '%d segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'una hora',
            hh : '%d horas',
            d : 'un da',
            dd : '%d das',
            M : 'un mes',
            MM : '%d meses',
            y : 'un ao',
            yy : '%d aos'
        },
        dayOfMonthOrdinalParse : /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return esDo;

})));


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

    var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
    var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

    var esUs = moment.defineLocale('es-us', {
        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
        monthsShort : function (m, format) {
            if (!m) {
                return monthsShortDot;
            } else if (/-MMM-/.test(format)) {
                return monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
        weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
        weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'MM/DD/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY h:mm A',
            LLLL : 'dddd, D [de] MMMM [de] YYYY h:mm A'
        },
        calendar : {
            sameDay : function () {
                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextDay : function () {
                return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastDay : function () {
                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'en %s',
            past : 'hace %s',
            s : 'unos segundos',
            ss : '%d segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'una hora',
            hh : '%d horas',
            d : 'un da',
            dd : '%d das',
            M : 'un mes',
            MM : '%d meses',
            y : 'un ao',
            yy : '%d aos'
        },
        dayOfMonthOrdinalParse : /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return esUs;

})));


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            's' : ['mne sekundi', 'mni sekund', 'paar sekundit'],
            'ss': [number + 'sekundi', number + 'sekundit'],
            'm' : ['he minuti', 'ks minut'],
            'mm': [number + ' minuti', number + ' minutit'],
            'h' : ['he tunni', 'tund aega', 'ks tund'],
            'hh': [number + ' tunni', number + ' tundi'],
            'd' : ['he peva', 'ks pev'],
            'M' : ['kuu aja', 'kuu aega', 'ks kuu'],
            'MM': [number + ' kuu', number + ' kuud'],
            'y' : ['he aasta', 'aasta', 'ks aasta'],
            'yy': [number + ' aasta', number + ' aastat']
        };
        if (withoutSuffix) {
            return format[key][2] ? format[key][2] : format[key][1];
        }
        return isFuture ? format[key][0] : format[key][1];
    }

    var et = moment.defineLocale('et', {
        months        : 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
        monthsShort   : 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
        weekdays      : 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),
        weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
        weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
        longDateFormat : {
            LT   : 'H:mm',
            LTS : 'H:mm:ss',
            L    : 'DD.MM.YYYY',
            LL   : 'D. MMMM YYYY',
            LLL  : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[Tna,] LT',
            nextDay  : '[Homme,] LT',
            nextWeek : '[Jrgmine] dddd LT',
            lastDay  : '[Eile,] LT',
            lastWeek : '[Eelmine] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s prast',
            past   : '%s tagasi',
            s      : processRelativeTime,
            ss     : processRelativeTime,
            m      : processRelativeTime,
            mm     : processRelativeTime,
            h      : processRelativeTime,
            hh     : processRelativeTime,
            d      : processRelativeTime,
            dd     : '%d peva',
            M      : processRelativeTime,
            MM     : processRelativeTime,
            y      : processRelativeTime,
            yy     : processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return et;

})));


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var eu = moment.defineLocale('eu', {
        months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
        monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
        monthsParseExact : true,
        weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
        weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
        weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'YYYY[ko] MMMM[ren] D[a]',
            LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',
            LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
            l : 'YYYY-M-D',
            ll : 'YYYY[ko] MMM D[a]',
            lll : 'YYYY[ko] MMM D[a] HH:mm',
            llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'
        },
        calendar : {
            sameDay : '[gaur] LT[etan]',
            nextDay : '[bihar] LT[etan]',
            nextWeek : 'dddd LT[etan]',
            lastDay : '[atzo] LT[etan]',
            lastWeek : '[aurreko] dddd LT[etan]',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s barru',
            past : 'duela %s',
            s : 'segundo batzuk',
            ss : '%d segundo',
            m : 'minutu bat',
            mm : '%d minutu',
            h : 'ordu bat',
            hh : '%d ordu',
            d : 'egun bat',
            dd : '%d egun',
            M : 'hilabete bat',
            MM : '%d hilabete',
            y : 'urte bat',
            yy : '%d urte'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return eu;

})));


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var fa = moment.defineLocale('fa', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '\u200c__\u200c__\u200c__'.split('_'),
        weekdaysShort : '\u200c__\u200c__\u200c__'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        meridiemParse: /  |  /,
        isPM: function (input) {
            return /  /.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '  ';
            } else {
                return '  ';
            }
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ] LT',
            lastWeek : 'dddd [] [] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            ss : ' d%',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[-]/g, function (match) {
                return numberMap[match];
            }).replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '');
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12 // The week that contains Jan 12th is the first week of the year.
        }
    });

    return fa;

})));


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' '),
        numbersFuture = [
            'nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden',
            numbersPast[7], numbersPast[8], numbersPast[9]
        ];
    function translate(number, withoutSuffix, key, isFuture) {
        var result = '';
        switch (key) {
            case 's':
                return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
            case 'ss':
                return isFuture ? 'sekunnin' : 'sekuntia';
            case 'm':
                return isFuture ? 'minuutin' : 'minuutti';
            case 'mm':
                result = isFuture ? 'minuutin' : 'minuuttia';
                break;
            case 'h':
                return isFuture ? 'tunnin' : 'tunti';
            case 'hh':
                result = isFuture ? 'tunnin' : 'tuntia';
                break;
            case 'd':
                return isFuture ? 'pivn' : 'piv';
            case 'dd':
                result = isFuture ? 'pivn' : 'piv';
                break;
            case 'M':
                return isFuture ? 'kuukauden' : 'kuukausi';
            case 'MM':
                result = isFuture ? 'kuukauden' : 'kuukautta';
                break;
            case 'y':
                return isFuture ? 'vuoden' : 'vuosi';
            case 'yy':
                result = isFuture ? 'vuoden' : 'vuotta';
                break;
        }
        result = verbalNumber(number, isFuture) + ' ' + result;
        return result;
    }
    function verbalNumber(number, isFuture) {
        return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
    }

    var fi = moment.defineLocale('fi', {
        months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
        monthsShort : 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),
        weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
        weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
        weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD.MM.YYYY',
            LL : 'Do MMMM[ta] YYYY',
            LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',
            LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
            l : 'D.M.YYYY',
            ll : 'Do MMM YYYY',
            lll : 'Do MMM YYYY, [klo] HH.mm',
            llll : 'ddd, Do MMM YYYY, [klo] HH.mm'
        },
        calendar : {
            sameDay : '[tnn] [klo] LT',
            nextDay : '[huomenna] [klo] LT',
            nextWeek : 'dddd [klo] LT',
            lastDay : '[eilen] [klo] LT',
            lastWeek : '[viime] dddd[na] [klo] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s pst',
            past : '%s sitten',
            s : translate,
            ss : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fi;

})));


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var fo = moment.defineLocale('fo', {
        months : 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays : 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),
        weekdaysShort : 'sun_mn_ts_mik_hs_fr_ley'.split('_'),
        weekdaysMin : 'su_m_t_mi_h_fr_le'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D. MMMM, YYYY HH:mm'
        },
        calendar : {
            sameDay : '[ dag kl.] LT',
            nextDay : '[ morgin kl.] LT',
            nextWeek : 'dddd [kl.] LT',
            lastDay : '[ gjr kl.] LT',
            lastWeek : '[sstu] dddd [kl] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'um %s',
            past : '%s sani',
            s : 'f sekund',
            ss : '%d sekundir',
            m : 'ein minuttur',
            mm : '%d minuttir',
            h : 'ein tmi',
            hh : '%d tmar',
            d : 'ein dagur',
            dd : '%d dagar',
            M : 'ein mnaur',
            MM : '%d mnair',
            y : 'eitt r',
            yy : '%d r'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fo;

})));


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var fr = moment.defineLocale('fr', {
        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
        monthsParseExact : true,
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'di_lu_ma_me_je_ve_sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Aujourdhui ] LT',
            nextDay : '[Demain ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[Hier ] LT',
            lastWeek : 'dddd [dernier ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            ss : '%d secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
        ordinal : function (number, period) {
            switch (period) {
                // TODO: Return 'e' when day of month > 1. Move this case inside
                // block for masculine words below.
                // See https://github.com/moment/moment/issues/3375
                case 'D':
                    return number + (number === 1 ? 'er' : '');

                // Words with masculine grammatical gender: mois, trimestre, jour
                default:
                case 'M':
                case 'Q':
                case 'DDD':
                case 'd':
                    return number + (number === 1 ? 'er' : 'e');

                // Words with feminine grammatical gender: semaine
                case 'w':
                case 'W':
                    return number + (number === 1 ? 're' : 'e');
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fr;

})));


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var frCa = moment.defineLocale('fr-ca', {
        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
        monthsParseExact : true,
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'di_lu_ma_me_je_ve_sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Aujourdhui ] LT',
            nextDay : '[Demain ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[Hier ] LT',
            lastWeek : 'dddd [dernier ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            ss : '%d secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
        ordinal : function (number, period) {
            switch (period) {
                // Words with masculine grammatical gender: mois, trimestre, jour
                default:
                case 'M':
                case 'Q':
                case 'D':
                case 'DDD':
                case 'd':
                    return number + (number === 1 ? 'er' : 'e');

                // Words with feminine grammatical gender: semaine
                case 'w':
                case 'W':
                    return number + (number === 1 ? 're' : 'e');
            }
        }
    });

    return frCa;

})));


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var frCh = moment.defineLocale('fr-ch', {
        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
        monthsParseExact : true,
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'di_lu_ma_me_je_ve_sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Aujourdhui ] LT',
            nextDay : '[Demain ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[Hier ] LT',
            lastWeek : 'dddd [dernier ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            ss : '%d secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
        ordinal : function (number, period) {
            switch (period) {
                // Words with masculine grammatical gender: mois, trimestre, jour
                default:
                case 'M':
                case 'Q':
                case 'D':
                case 'DDD':
                case 'd':
                    return number + (number === 1 ? 'er' : 'e');

                // Words with feminine grammatical gender: semaine
                case 'w':
                case 'W':
                    return number + (number === 1 ? 're' : 'e');
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return frCh;

})));


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),
        monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');

    var fy = moment.defineLocale('fy', {
        months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
        monthsShort : function (m, format) {
            if (!m) {
                return monthsShortWithDots;
            } else if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots[m.month()];
            } else {
                return monthsShortWithDots[m.month()];
            }
        },
        monthsParseExact : true,
        weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
        weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
        weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[hjoed om] LT',
            nextDay: '[moarn om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[juster om] LT',
            lastWeek: '[frne] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'oer %s',
            past : '%s lyn',
            s : 'in pear sekonden',
            ss : '%d sekonden',
            m : 'ien mint',
            mm : '%d minuten',
            h : 'ien oere',
            hh : '%d oeren',
            d : 'ien dei',
            dd : '%d dagen',
            M : 'ien moanne',
            MM : '%d moannen',
            y : 'ien jier',
            yy : '%d jierren'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fy;

})));


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';



    var months = [
        'Eanir', 'Feabhra', 'Mrta', 'Aibren', 'Bealtaine', 'Mitheamh', 'Iil', 'Lnasa', 'Men Fmhair', 'Deaireadh Fmhair', 'Samhain', 'Nollaig'
    ];

    var monthsShort = ['Ean', 'Feab', 'Mrt', 'Aibr', 'Beal', 'Mit', 'Iil', 'Lna', 'Men', 'Deai', 'Samh', 'Noll'];

    var weekdays = ['D Domhnaigh', 'D Luain', 'D Mirt', 'D Cadaoin', 'Dardaoin', 'D hAoine', 'D Satharn'];

    var weekdaysShort = ['Dom', 'Lua', 'Mi', 'Ca', 'Da', 'hAo', 'Sat'];

    var weekdaysMin = ['Do', 'Lu', 'M', 'Ce', 'D', 'hA', 'Sa'];

    var ga = moment.defineLocale('ga', {
        months: months,
        monthsShort: monthsShort,
        monthsParseExact: true,
        weekdays: weekdays,
        weekdaysShort: weekdaysShort,
        weekdaysMin: weekdaysMin,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[Inniu ag] LT',
            nextDay: '[Amrach ag] LT',
            nextWeek: 'dddd [ag] LT',
            lastDay: '[Inn aig] LT',
            lastWeek: 'dddd [seo caite] [ag] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'i %s',
            past: '%s  shin',
            s: 'cpla soicind',
            ss: '%d soicind',
            m: 'nimad',
            mm: '%d nimad',
            h: 'uair an chloig',
            hh: '%d uair an chloig',
            d: 'l',
            dd: '%d l',
            M: 'm',
            MM: '%d m',
            y: 'bliain',
            yy: '%d bliain'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
        ordinal: function (number) {
            var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return ga;

})));


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var months = [
        'Am Faoilleach', 'An Gearran', 'Am Mrt', 'An Giblean', 'An Citean', 'An t-gmhios', 'An t-Iuchar', 'An Lnastal', 'An t-Sultain', 'An Dmhair', 'An t-Samhain', 'An Dbhlachd'
    ];

    var monthsShort = ['Faoi', 'Gear', 'Mrt', 'Gibl', 'Cit', 'gmh', 'Iuch', 'Ln', 'Sult', 'Dmh', 'Samh', 'Dbh'];

    var weekdays = ['Didmhnaich', 'Diluain', 'Dimirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];

    var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];

    var weekdaysMin = ['D', 'Lu', 'M', 'Ci', 'Ar', 'Ha', 'Sa'];

    var gd = moment.defineLocale('gd', {
        months : months,
        monthsShort : monthsShort,
        monthsParseExact : true,
        weekdays : weekdays,
        weekdaysShort : weekdaysShort,
        weekdaysMin : weekdaysMin,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[An-diugh aig] LT',
            nextDay : '[A-mireach aig] LT',
            nextWeek : 'dddd [aig] LT',
            lastDay : '[An-d aig] LT',
            lastWeek : 'dddd [seo chaidh] [aig] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'ann an %s',
            past : 'bho chionn %s',
            s : 'beagan diogan',
            ss : '%d diogan',
            m : 'mionaid',
            mm : '%d mionaidean',
            h : 'uair',
            hh : '%d uairean',
            d : 'latha',
            dd : '%d latha',
            M : 'mos',
            MM : '%d mosan',
            y : 'bliadhna',
            yy : '%d bliadhna'
        },
        dayOfMonthOrdinalParse : /\d{1,2}(d|na|mh)/,
        ordinal : function (number) {
            var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return gd;

})));


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var gl = moment.defineLocale('gl', {
        months : 'xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),
        monthsShort : 'xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays : 'domingo_luns_martes_mrcores_xoves_venres_sbado'.split('_'),
        weekdaysShort : 'dom._lun._mar._mr._xov._ven._sb.'.split('_'),
        weekdaysMin : 'do_lu_ma_m_xo_ve_s'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY H:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
        },
        calendar : {
            sameDay : function () {
                return '[hoxe ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextDay : function () {
                return '[ma ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
            },
            lastDay : function () {
                return '[onte ' + ((this.hours() !== 1) ? '' : 'a') + '] LT';
            },
            lastWeek : function () {
                return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : function (str) {
                if (str.indexOf('un') === 0) {
                    return 'n' + str;
                }
                return 'en ' + str;
            },
            past : 'hai %s',
            s : 'uns segundos',
            ss : '%d segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'unha hora',
            hh : '%d horas',
            d : 'un da',
            dd : '%d das',
            M : 'un mes',
            MM : '%d meses',
            y : 'un ano',
            yy : '%d anos'
        },
        dayOfMonthOrdinalParse : /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return gl;

})));


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            's': ['thodde secondanim', 'thodde second'],
            'ss': [number + ' secondanim', number + ' second'],
            'm': ['eka mintan', 'ek minute'],
            'mm': [number + ' mintanim', number + ' mintam'],
            'h': ['eka voran', 'ek vor'],
            'hh': [number + ' voranim', number + ' voram'],
            'd': ['eka disan', 'ek dis'],
            'dd': [number + ' disanim', number + ' dis'],
            'M': ['eka mhoinean', 'ek mhoino'],
            'MM': [number + ' mhoineanim', number + ' mhoine'],
            'y': ['eka vorsan', 'ek voros'],
            'yy': [number + ' vorsanim', number + ' vorsam']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var gomLatn = moment.defineLocale('gom-latn', {
        months : 'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split('_'),
        monthsShort : 'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split('_'),
        monthsParseExact : true,
        weekdays : 'Aitar_Somar_Mongllar_Budvar_Brestar_Sukrar_Son\'var'.split('_'),
        weekdaysShort : 'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),
        weekdaysMin : 'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'A h:mm [vazta]',
            LTS : 'A h:mm:ss [vazta]',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY A h:mm [vazta]',
            LLLL : 'dddd, MMMM[achea] Do, YYYY, A h:mm [vazta]',
            llll: 'ddd, D MMM YYYY, A h:mm [vazta]'
        },
        calendar : {
            sameDay: '[Aiz] LT',
            nextDay: '[Faleam] LT',
            nextWeek: '[Ieta to] dddd[,] LT',
            lastDay: '[Kal] LT',
            lastWeek: '[Fatlo] dddd[,] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s',
            past : '%s adim',
            s : processRelativeTime,
            ss : processRelativeTime,
            m : processRelativeTime,
            mm : processRelativeTime,
            h : processRelativeTime,
            hh : processRelativeTime,
            d : processRelativeTime,
            dd : processRelativeTime,
            M : processRelativeTime,
            MM : processRelativeTime,
            y : processRelativeTime,
            yy : processRelativeTime
        },
        dayOfMonthOrdinalParse : /\d{1,2}(er)/,
        ordinal : function (number, period) {
            switch (period) {
                // the ordinal 'er' only applies to day of the month
                case 'D':
                    return number + 'er';
                default:
                case 'M':
                case 'Q':
                case 'DDD':
                case 'd':
                case 'w':
                case 'W':
                    return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        },
        meridiemParse: /rati|sokalli|donparam|sanje/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'rati') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'sokalli') {
                return hour;
            } else if (meridiem === 'donparam') {
                return hour > 12 ? hour : hour + 12;
            } else if (meridiem === 'sanje') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'rati';
            } else if (hour < 12) {
                return 'sokalli';
            } else if (hour < 16) {
                return 'donparam';
            } else if (hour < 20) {
                return 'sanje';
            } else {
                return 'rati';
            }
        }
    });

    return gomLatn;

})));


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
            '1': '',
            '2': '',
            '3': '',
            '4': '',
            '5': '',
            '6': '',
            '7': '',
            '8': '',
            '9': '',
            '0': ''
        },
        numberMap = {
            '': '1',
            '': '2',
            '': '3',
            '': '4',
            '': '5',
            '': '6',
            '': '7',
            '': '8',
            '': '9',
            '': '0'
        };

    var gu = moment.defineLocale('gu', {
        months: '___________'.split('_'),
        monthsShort: '._.__.___._._._._._.'.split('_'),
        monthsParseExact: true,
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'A h:mm ',
            LTS: 'A h:mm:ss ',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm ',
            LLLL: 'dddd, D MMMM YYYY, A h:mm '
        },
        calendar: {
            sameDay: '[] LT',
            nextDay: '[] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[] LT',
            lastWeek: '[] dddd, LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s ',
            past: '%s ',
            s: ' ',
            ss: '%d ',
            m: ' ',
            mm: '%d ',
            h: ' ',
            hh: '%d ',
            d: ' ',
            dd: '%d ',
            M: ' ',
            MM: '%d ',
            y: ' ',
            yy: '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // Gujarati notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Gujarati.
        meridiemParse: /|||/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6 // The week that contains Jan 6th is the first week of the year.
        }
    });

    return gu;

})));


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var he = moment.defineLocale('he', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D []MMMM YYYY',
            LLL : 'D []MMMM YYYY HH:mm',
            LLLL : 'dddd, D []MMMM YYYY HH:mm',
            l : 'D/M/YYYY',
            ll : 'D MMM YYYY',
            lll : 'D MMM YYYY HH:mm',
            llll : 'ddd, D MMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[ ]LT',
            nextDay : '[ ]LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ]LT',
            lastWeek : '[] dddd [ ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : ' ',
            ss : '%d ',
            m : '',
            mm : '%d ',
            h : '',
            hh : function (number) {
                if (number === 2) {
                    return '';
                }
                return number + ' ';
            },
            d : '',
            dd : function (number) {
                if (number === 2) {
                    return '';
                }
                return number + ' ';
            },
            M : '',
            MM : function (number) {
                if (number === 2) {
                    return '';
                }
                return number + ' ';
            },
            y : '',
            yy : function (number) {
                if (number === 2) {
                    return '';
                } else if (number % 10 === 0 && number !== 10) {
                    return number + ' ';
                }
                return number + ' ';
            }
        },
        meridiemParse: /"|"| | | ||/i,
        isPM : function (input) {
            return /^("| |)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 5) {
                return ' ';
            } else if (hour < 10) {
                return '';
            } else if (hour < 12) {
                return isLower ? '"' : ' ';
            } else if (hour < 18) {
                return isLower ? '"' : ' ';
            } else {
                return '';
            }
        }
    });

    return he;

})));


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var hi = moment.defineLocale('hi', {
        months : '___________'.split('_'),
        monthsShort : '._.__.___._._._._._.'.split('_'),
        monthsParseExact: true,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm ',
            LTS : 'A h:mm:ss ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm '
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : '  ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // Hindi notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
        meridiemParse: /|||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return hi;

})));


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
            case 'ss':
                if (number === 1) {
                    result += 'sekunda';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'sekunde';
                } else {
                    result += 'sekundi';
                }
                return result;
            case 'm':
                return withoutSuffix ? 'jedna minuta' : 'jedne minute';
            case 'mm':
                if (number === 1) {
                    result += 'minuta';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'minute';
                } else {
                    result += 'minuta';
                }
                return result;
            case 'h':
                return withoutSuffix ? 'jedan sat' : 'jednog sata';
            case 'hh':
                if (number === 1) {
                    result += 'sat';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'sata';
                } else {
                    result += 'sati';
                }
                return result;
            case 'dd':
                if (number === 1) {
                    result += 'dan';
                } else {
                    result += 'dana';
                }
                return result;
            case 'MM':
                if (number === 1) {
                    result += 'mjesec';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'mjeseca';
                } else {
                    result += 'mjeseci';
                }
                return result;
            case 'yy':
                if (number === 1) {
                    result += 'godina';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'godine';
                } else {
                    result += 'godina';
                }
                return result;
        }
    }

    var hr = moment.defineLocale('hr', {
        months : {
            format: 'sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
            standalone: 'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
        },
        monthsShort : 'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
        monthsParseExact: true,
        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
        weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
        weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[danas u] LT',
            nextDay  : '[sutra u] LT',
            nextWeek : function () {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedjelju] [u] LT';
                    case 3:
                        return '[u] [srijedu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[juer u] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                        return '[prolu] dddd [u] LT';
                    case 6:
                        return '[prole] [subote] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[proli] dddd [u] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'par sekundi',
            ss     : translate,
            m      : translate,
            mm     : translate,
            h      : translate,
            hh     : translate,
            d      : 'dan',
            dd     : translate,
            M      : 'mjesec',
            MM     : translate,
            y      : 'godinu',
            yy     : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return hr;

})));


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');
    function translate(number, withoutSuffix, key, isFuture) {
        var num = number;
        switch (key) {
            case 's':
                return (isFuture || withoutSuffix) ? 'nhny msodperc' : 'nhny msodperce';
            case 'ss':
                return num + (isFuture || withoutSuffix) ? ' msodperc' : ' msodperce';
            case 'm':
                return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
            case 'mm':
                return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
            case 'h':
                return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');
            case 'hh':
                return num + (isFuture || withoutSuffix ? ' ra' : ' rja');
            case 'd':
                return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
            case 'dd':
                return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
            case 'M':
                return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
            case 'MM':
                return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
            case 'y':
                return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');
            case 'yy':
                return num + (isFuture || withoutSuffix ? ' v' : ' ve');
        }
        return '';
    }
    function week(isFuture) {
        return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
    }

    var hu = moment.defineLocale('hu', {
        months : 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),
        monthsShort : 'jan_feb_mrc_pr_mj_jn_jl_aug_szept_okt_nov_dec'.split('_'),
        weekdays : 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),
        weekdaysShort : 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),
        weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'YYYY.MM.DD.',
            LL : 'YYYY. MMMM D.',
            LLL : 'YYYY. MMMM D. H:mm',
            LLLL : 'YYYY. MMMM D., dddd H:mm'
        },
        meridiemParse: /de|du/i,
        isPM: function (input) {
            return input.charAt(1).toLowerCase() === 'u';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower === true ? 'de' : 'DE';
            } else {
                return isLower === true ? 'du' : 'DU';
            }
        },
        calendar : {
            sameDay : '[ma] LT[-kor]',
            nextDay : '[holnap] LT[-kor]',
            nextWeek : function () {
                return week.call(this, true);
            },
            lastDay : '[tegnap] LT[-kor]',
            lastWeek : function () {
                return week.call(this, false);
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s mlva',
            past : '%s',
            s : translate,
            ss : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return hu;

})));


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var hyAm = moment.defineLocale('hy-am', {
        months : {
            format: '___________'.split('_'),
            standalone: '___________'.split('_')
        },
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY .',
            LLL : 'D MMMM YYYY ., HH:mm',
            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
        },
        calendar : {
            sameDay: '[] LT',
            nextDay: '[] LT',
            lastDay: '[] LT',
            nextWeek: function () {
                return 'dddd [ ] LT';
            },
            lastWeek: function () {
                return '[] dddd [ ] LT';
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : '  ',
            ss : '%d ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        meridiemParse: /|||/,
        isPM: function (input) {
            return /^(|)$/.test(input);
        },
        meridiem : function (hour) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return '';
            } else {
                return '';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(|)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'DDD':
                case 'w':
                case 'W':
                case 'DDDo':
                    if (number === 1) {
                        return number + '-';
                    }
                    return number + '-';
                default:
                    return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return hyAm;

})));


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var id = moment.defineLocale('id', {
        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des'.split('_'),
        weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
        weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|siang|sore|malam/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'siang') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'sore' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'siang';
            } else if (hours < 19) {
                return 'sore';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Besok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kemarin pukul] LT',
            lastWeek : 'dddd [lalu pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lalu',
            s : 'beberapa detik',
            ss : '%d detik',
            m : 'semenit',
            mm : '%d menit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return id;

})));


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function plural(n) {
        if (n % 100 === 11) {
            return true;
        } else if (n % 10 === 1) {
            return false;
        }
        return true;
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's':
                return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';
            case 'ss':
                if (plural(number)) {
                    return result + (withoutSuffix || isFuture ? 'sekndur' : 'sekndum');
                }
                return result + 'seknda';
            case 'm':
                return withoutSuffix ? 'mnta' : 'mntu';
            case 'mm':
                if (plural(number)) {
                    return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');
                } else if (withoutSuffix) {
                    return result + 'mnta';
                }
                return result + 'mntu';
            case 'hh':
                if (plural(number)) {
                    return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
                }
                return result + 'klukkustund';
            case 'd':
                if (withoutSuffix) {
                    return 'dagur';
                }
                return isFuture ? 'dag' : 'degi';
            case 'dd':
                if (plural(number)) {
                    if (withoutSuffix) {
                        return result + 'dagar';
                    }
                    return result + (isFuture ? 'daga' : 'dgum');
                } else if (withoutSuffix) {
                    return result + 'dagur';
                }
                return result + (isFuture ? 'dag' : 'degi');
            case 'M':
                if (withoutSuffix) {
                    return 'mnuur';
                }
                return isFuture ? 'mnu' : 'mnui';
            case 'MM':
                if (plural(number)) {
                    if (withoutSuffix) {
                        return result + 'mnuir';
                    }
                    return result + (isFuture ? 'mnui' : 'mnuum');
                } else if (withoutSuffix) {
                    return result + 'mnuur';
                }
                return result + (isFuture ? 'mnu' : 'mnui');
            case 'y':
                return withoutSuffix || isFuture ? 'r' : 'ri';
            case 'yy':
                if (plural(number)) {
                    return result + (withoutSuffix || isFuture ? 'r' : 'rum');
                }
                return result + (withoutSuffix || isFuture ? 'r' : 'ri');
        }
    }

    var is = moment.defineLocale('is', {
        months : 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),
        weekdays : 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),
        weekdaysShort : 'sun_mn_ri_mi_fim_fs_lau'.split('_'),
        weekdaysMin : 'Su_M_r_Mi_Fi_F_La'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY [kl.] H:mm',
            LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'
        },
        calendar : {
            sameDay : '[ dag kl.] LT',
            nextDay : '[ morgun kl.] LT',
            nextWeek : 'dddd [kl.] LT',
            lastDay : '[ gr kl.] LT',
            lastWeek : '[sasta] dddd [kl.] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'eftir %s',
            past : 'fyrir %s san',
            s : translate,
            ss : translate,
            m : translate,
            mm : translate,
            h : 'klukkustund',
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return is;

})));


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var it = moment.defineLocale('it', {
        months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
        monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
        weekdays : 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'),
        weekdaysShort : 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
        weekdaysMin : 'do_lu_ma_me_gi_ve_sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Oggi alle] LT',
            nextDay: '[Domani alle] LT',
            nextWeek: 'dddd [alle] LT',
            lastDay: '[Ieri alle] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[la scorsa] dddd [alle] LT';
                    default:
                        return '[lo scorso] dddd [alle] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : function (s) {
                return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
            },
            past : '%s fa',
            s : 'alcuni secondi',
            ss : '%d secondi',
            m : 'un minuto',
            mm : '%d minuti',
            h : 'un\'ora',
            hh : '%d ore',
            d : 'un giorno',
            dd : '%d giorni',
            M : 'un mese',
            MM : '%d mesi',
            y : 'un anno',
            yy : '%d anni'
        },
        dayOfMonthOrdinalParse : /\d{1,2}/,
        ordinal: '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return it;

})));


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var itCh = moment.defineLocale('it-ch', {
        months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
        monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
        weekdays : 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'),
        weekdaysShort : 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
        weekdaysMin : 'do_lu_ma_me_gi_ve_sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Oggi alle] LT',
            nextDay: '[Domani alle] LT',
            nextWeek: 'dddd [alle] LT',
            lastDay: '[Ieri alle] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[la scorsa] dddd [alle] LT';
                    default:
                        return '[lo scorso] dddd [alle] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : function (s) {
                return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
            },
            past : '%s fa',
            s : 'alcuni secondi',
            ss : '%d secondi',
            m : 'un minuto',
            mm : '%d minuti',
            h : 'un\'ora',
            hh : '%d ore',
            d : 'un giorno',
            dd : '%d giorni',
            M : 'un mese',
            MM : '%d mesi',
            y : 'un anno',
            yy : '%d anni'
        },
        dayOfMonthOrdinalParse : /\d{1,2}/,
        ordinal: '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return itCh;

})));


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var ja = moment.defineLocale('ja', {
        months : '___________'.split('_'),
        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY/MM/DD',
            LL : 'YYYYMD',
            LLL : 'YYYYMD HH:mm',
            LLLL : 'YYYYMD dddd HH:mm',
            l : 'YYYY/MM/DD',
            ll : 'YYYYMD',
            lll : 'YYYYMD HH:mm',
            llll : 'YYYYMD(ddd) HH:mm'
        },
        meridiemParse: /|/i,
        isPM : function (input) {
            return input === '';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : function (now) {
                if (now.week() < this.week()) {
                    return '[]dddd LT';
                } else {
                    return 'dddd LT';
                }
            },
            lastDay : '[] LT',
            lastWeek : function (now) {
                if (this.week() < now.week()) {
                    return '[]dddd LT';
                } else {
                    return 'dddd LT';
                }
            },
            sameElse : 'L'
        },
        dayOfMonthOrdinalParse : /\d{1,2}/,
        ordinal : function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '';
                default:
                    return number;
            }
        },
        relativeTime : {
            future : '%s',
            past : '%s',
            s : '',
            ss : '%d',
            m : '1',
            mm : '%d',
            h : '1',
            hh : '%d',
            d : '1',
            dd : '%d',
            M : '1',
            MM : '%d',
            y : '1',
            yy : '%d'
        }
    });

    return ja;

})));


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var jv = moment.defineLocale('jv', {
        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
        weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
        weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /enjing|siyang|sonten|ndalu/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'enjing') {
                return hour;
            } else if (meridiem === 'siyang') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'enjing';
            } else if (hours < 15) {
                return 'siyang';
            } else if (hours < 19) {
                return 'sonten';
            } else {
                return 'ndalu';
            }
        },
        calendar : {
            sameDay : '[Dinten puniko pukul] LT',
            nextDay : '[Mbenjang pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kala wingi pukul] LT',
            lastWeek : 'dddd [kepengker pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'wonten ing %s',
            past : '%s ingkang kepengker',
            s : 'sawetawis detik',
            ss : '%d detik',
            m : 'setunggal menit',
            mm : '%d menit',
            h : 'setunggal jam',
            hh : '%d jam',
            d : 'sedinten',
            dd : '%d dinten',
            M : 'sewulan',
            MM : '%d wulan',
            y : 'setaun',
            yy : '%d taun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return jv;

})));


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var ka = moment.defineLocale('ka', {
        months : {
            standalone: '___________'.split('_'),
            format: '___________'.split('_')
        },
        monthsShort : '___________'.split('_'),
        weekdays : {
            standalone: '______'.split('_'),
            format: '______'.split('_'),
            isFormat: /(|)/
        },
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[] LT[-]',
            nextDay : '[] LT[-]',
            lastDay : '[] LT[-]',
            nextWeek : '[] dddd LT[-]',
            lastWeek : '[] dddd LT-',
            sameElse : 'L'
        },
        relativeTime : {
            future : function (s) {
                return (/(|||)/).test(s) ?
                    s.replace(/$/, '') :
                    s + '';
            },
            past : function (s) {
                if ((/(||||)/).test(s)) {
                    return s.replace(/(|)$/, ' ');
                }
                if ((//).test(s)) {
                    return s.replace(/$/, ' ');
                }
            },
            s : ' ',
            ss : '%d ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        dayOfMonthOrdinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
        ordinal : function (number) {
            if (number === 0) {
                return number;
            }
            if (number === 1) {
                return number + '-';
            }
            if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
                return '-' + number;
            }
            return number + '-';
        },
        week : {
            dow : 1,
            doy : 7
        }
    });

    return ka;

})));


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var suffixes = {
        0: '-',
        1: '-',
        2: '-',
        3: '-',
        4: '-',
        5: '-',
        6: '-',
        7: '-',
        8: '-',
        9: '-',
        10: '-',
        20: '-',
        30: '-',
        40: '-',
        50: '-',
        60: '-',
        70: '-',
        80: '-',
        90: '-',
        100: '-'
    };

    var kk = moment.defineLocale('kk', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ] LT',
            lastWeek : '[ ] dddd [] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
        ordinal : function (number) {
            var a = number % 10,
                b = number >= 100 ? 100 : null;
            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return kk;

})));


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var km = moment.defineLocale('km', {
        months: '___________'.split(
            '_'
        ),
        monthsShort: '___________'.split(
            '_'
        ),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM: function (input) {
            return input === '';
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar: {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[ ] LT',
            lastWeek: 'dddd [] [] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s',
            past: '%s',
            s: '',
            ss: '%d ',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        dayOfMonthOrdinalParse : /\d{1,2}/,
        ordinal : '%d',
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return km;

})));


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var kn = moment.defineLocale('kn', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        monthsParseExact: true,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm',
            LTS : 'A h:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm',
            LLLL : 'dddd, D MMMM YYYY, A h:mm'
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /|||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}()/,
        ordinal : function (number) {
            return number + '';
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return kn;

})));


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var ko = moment.defineLocale('ko', {
        months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm',
            LTS : 'A h:mm:ss',
            L : 'YYYY.MM.DD.',
            LL : 'YYYY MMMM D',
            LLL : 'YYYY MMMM D A h:mm',
            LLLL : 'YYYY MMMM D dddd A h:mm',
            l : 'YYYY.MM.DD.',
            ll : 'YYYY MMMM D',
            lll : 'YYYY MMMM D A h:mm',
            llll : 'YYYY MMMM D dddd A h:mm'
        },
        calendar : {
            sameDay : ' LT',
            nextDay : ' LT',
            nextWeek : 'dddd LT',
            lastDay : ' LT',
            lastWeek : ' dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            ss : '%d',
            m : '1',
            mm : '%d',
            h : ' ',
            hh : '%d',
            d : '',
            dd : '%d',
            M : ' ',
            MM : '%d',
            y : ' ',
            yy : '%d'
        },
        dayOfMonthOrdinalParse : /\d{1,2}(||)/,
        ordinal : function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '';
                case 'M':
                    return number + '';
                case 'w':
                case 'W':
                    return number + '';
                default:
                    return number;
            }
        },
        meridiemParse : /|/,
        isPM : function (token) {
            return token === '';
        },
        meridiem : function (hour, minute, isUpper) {
            return hour < 12 ? '' : '';
        }
    });

    return ko;

})));


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    },
    months = [
        ' ',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        ' ',
        ' ',
        ' '
    ];


    var ku = moment.defineLocale('ku', {
        months : months,
        monthsShort : months,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM: function (input) {
            return //.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ] LT',
            lastWeek : 'dddd [] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s',
            s : ' ',
            ss : ' %d',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            }).replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '');
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12 // The week that contains Jan 12th is the first week of the year.
        }
    });

    return ku;

})));


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var suffixes = {
        0: '-',
        1: '-',
        2: '-',
        3: '-',
        4: '-',
        5: '-',
        6: '-',
        7: '-',
        8: '-',
        9: '-',
        10: '-',
        20: '-',
        30: '-',
        40: '-',
        50: '-',
        60: '-',
        70: '-',
        80: '-',
        90: '-',
        100: '-'
    };

    var ky = moment.defineLocale('ky', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ] LT',
            lastWeek : '[ ] dddd [] [] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|||)/,
        ordinal : function (number) {
            var a = number % 10,
                b = number >= 100 ? 100 : null;
            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return ky;

})));


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eng Minutt', 'enger Minutt'],
            'h': ['eng Stonn', 'enger Stonn'],
            'd': ['een Dag', 'engem Dag'],
            'M': ['ee Mount', 'engem Mount'],
            'y': ['ee Joer', 'engem Joer']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }
    function processFutureTime(string) {
        var number = string.substr(0, string.indexOf(' '));
        if (eifelerRegelAppliesToNumber(number)) {
            return 'a ' + string;
        }
        return 'an ' + string;
    }
    function processPastTime(string) {
        var number = string.substr(0, string.indexOf(' '));
        if (eifelerRegelAppliesToNumber(number)) {
            return 'viru ' + string;
        }
        return 'virun ' + string;
    }
    /**
     * Returns true if the word before the given number loses the '-n' ending.
     * e.g. 'an 10 Deeg' but 'a 5 Deeg'
     *
     * @param number {integer}
     * @returns {boolean}
     */
    function eifelerRegelAppliesToNumber(number) {
        number = parseInt(number, 10);
        if (isNaN(number)) {
            return false;
        }
        if (number < 0) {
            // Negative Number --> always true
            return true;
        } else if (number < 10) {
            // Only 1 digit
            if (4 <= number && number <= 7) {
                return true;
            }
            return false;
        } else if (number < 100) {
            // 2 digits
            var lastDigit = number % 10, firstDigit = number / 10;
            if (lastDigit === 0) {
                return eifelerRegelAppliesToNumber(firstDigit);
            }
            return eifelerRegelAppliesToNumber(lastDigit);
        } else if (number < 10000) {
            // 3 or 4 digits --> recursively check first digit
            while (number >= 10) {
                number = number / 10;
            }
            return eifelerRegelAppliesToNumber(number);
        } else {
            // Anything larger than 4 digits: recursively check first n-3 digits
            number = number / 1000;
            return eifelerRegelAppliesToNumber(number);
        }
    }

    var lb = moment.defineLocale('lb', {
        months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        monthsParseExact : true,
        weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
        weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),
        weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'H:mm [Auer]',
            LTS: 'H:mm:ss [Auer]',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm [Auer]',
            LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
        },
        calendar: {
            sameDay: '[Haut um] LT',
            sameElse: 'L',
            nextDay: '[Muer um] LT',
            nextWeek: 'dddd [um] LT',
            lastDay: '[Gschter um] LT',
            lastWeek: function () {
                // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
                switch (this.day()) {
                    case 2:
                    case 4:
                        return '[Leschten] dddd [um] LT';
                    default:
                        return '[Leschte] dddd [um] LT';
                }
            }
        },
        relativeTime : {
            future : processFutureTime,
            past : processPastTime,
            s : 'e puer Sekonnen',
            ss : '%d Sekonnen',
            m : processRelativeTime,
            mm : '%d Minutten',
            h : processRelativeTime,
            hh : '%d Stonnen',
            d : processRelativeTime,
            dd : '%d Deeg',
            M : processRelativeTime,
            MM : '%d Mint',
            y : processRelativeTime,
            yy : '%d Joer'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return lb;

})));


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var lo = moment.defineLocale('lo', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM: function (input) {
            return input === '';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : '[]dddd[] LT',
            lastDay : '[] LT',
            lastWeek : '[]dddd[] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s',
            s : '',
            ss : '%d ' ,
            m : '1 ',
            mm : '%d ',
            h : '1 ',
            hh : '%d ',
            d : '1 ',
            dd : '%d ',
            M : '1 ',
            MM : '%d ',
            y : '1 ',
            yy : '%d '
        },
        dayOfMonthOrdinalParse: /()\d{1,2}/,
        ordinal : function (number) {
            return '' + number;
        }
    });

    return lo;

})));


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var units = {
        'ss' : 'sekund_sekundi_sekundes',
        'm' : 'minut_minuts_minut',
        'mm': 'minuts_minui_minutes',
        'h' : 'valanda_valandos_valand',
        'hh': 'valandos_valand_valandas',
        'd' : 'diena_dienos_dien',
        'dd': 'dienos_dien_dienas',
        'M' : 'mnuo_mnesio_mnes',
        'MM': 'mnesiai_mnesi_mnesius',
        'y' : 'metai_met_metus',
        'yy': 'metai_met_metus'
    };
    function translateSeconds(number, withoutSuffix, key, isFuture) {
        if (withoutSuffix) {
            return 'kelios sekunds';
        } else {
            return isFuture ? 'keli sekundi' : 'kelias sekundes';
        }
    }
    function translateSingular(number, withoutSuffix, key, isFuture) {
        return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
    }
    function special(number) {
        return number % 10 === 0 || (number > 10 && number < 20);
    }
    function forms(key) {
        return units[key].split('_');
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        if (number === 1) {
            return result + translateSingular(number, withoutSuffix, key[0], isFuture);
        } else if (withoutSuffix) {
            return result + (special(number) ? forms(key)[1] : forms(key)[0]);
        } else {
            if (isFuture) {
                return result + forms(key)[1];
            } else {
                return result + (special(number) ? forms(key)[1] : forms(key)[2]);
            }
        }
    }
    var lt = moment.defineLocale('lt', {
        months : {
            format: 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_'),
            standalone: 'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split('_'),
            isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
        },
        monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
        weekdays : {
            format: 'sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien'.split('_'),
            standalone: 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_'),
            isFormat: /dddd HH:mm/
        },
        weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),
        weekdaysMin : 'S_P_A_T_K_Pn_'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'YYYY [m.] MMMM D [d.]',
            LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
            LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
            l : 'YYYY-MM-DD',
            ll : 'YYYY [m.] MMMM D [d.]',
            lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
            llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
        },
        calendar : {
            sameDay : '[iandien] LT',
            nextDay : '[Rytoj] LT',
            nextWeek : 'dddd LT',
            lastDay : '[Vakar] LT',
            lastWeek : '[Prajus] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'po %s',
            past : 'prie %s',
            s : translateSeconds,
            ss : translate,
            m : translateSingular,
            mm : translate,
            h : translateSingular,
            hh : translate,
            d : translateSingular,
            dd : translate,
            M : translateSingular,
            MM : translate,
            y : translateSingular,
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}-oji/,
        ordinal : function (number) {
            return number + '-oji';
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return lt;

})));


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var units = {
        'ss': 'sekundes_sekundm_sekunde_sekundes'.split('_'),
        'm': 'mintes_mintm_minte_mintes'.split('_'),
        'mm': 'mintes_mintm_minte_mintes'.split('_'),
        'h': 'stundas_stundm_stunda_stundas'.split('_'),
        'hh': 'stundas_stundm_stunda_stundas'.split('_'),
        'd': 'dienas_dienm_diena_dienas'.split('_'),
        'dd': 'dienas_dienm_diena_dienas'.split('_'),
        'M': 'mnea_mneiem_mnesis_mnei'.split('_'),
        'MM': 'mnea_mneiem_mnesis_mnei'.split('_'),
        'y': 'gada_gadiem_gads_gadi'.split('_'),
        'yy': 'gada_gadiem_gads_gadi'.split('_')
    };
    /**
     * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
     */
    function format(forms, number, withoutSuffix) {
        if (withoutSuffix) {
            // E.g. "21 minte", "3 mintes".
            return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
        } else {
            // E.g. "21 mintes" as in "pc 21 mintes".
            // E.g. "3 mintm" as in "pc 3 mintm".
            return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
        }
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        return number + ' ' + format(units[key], number, withoutSuffix);
    }
    function relativeTimeWithSingular(number, withoutSuffix, key) {
        return format(units[key], number, withoutSuffix);
    }
    function relativeSeconds(number, withoutSuffix) {
        return withoutSuffix ? 'daas sekundes' : 'dam sekundm';
    }

    var lv = moment.defineLocale('lv', {
        months : 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),
        weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
        weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY.',
            LL : 'YYYY. [gada] D. MMMM',
            LLL : 'YYYY. [gada] D. MMMM, HH:mm',
            LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'
        },
        calendar : {
            sameDay : '[odien pulksten] LT',
            nextDay : '[Rt pulksten] LT',
            nextWeek : 'dddd [pulksten] LT',
            lastDay : '[Vakar pulksten] LT',
            lastWeek : '[Pagju] dddd [pulksten] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'pc %s',
            past : 'pirms %s',
            s : relativeSeconds,
            ss : relativeTimeWithPlural,
            m : relativeTimeWithSingular,
            mm : relativeTimeWithPlural,
            h : relativeTimeWithSingular,
            hh : relativeTimeWithPlural,
            d : relativeTimeWithSingular,
            dd : relativeTimeWithPlural,
            M : relativeTimeWithSingular,
            MM : relativeTimeWithPlural,
            y : relativeTimeWithSingular,
            yy : relativeTimeWithPlural
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return lv;

})));


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var translator = {
        words: { //Different grammatical cases
            ss: ['sekund', 'sekunda', 'sekundi'],
            m: ['jedan minut', 'jednog minuta'],
            mm: ['minut', 'minuta', 'minuta'],
            h: ['jedan sat', 'jednog sata'],
            hh: ['sat', 'sata', 'sati'],
            dd: ['dan', 'dana', 'dana'],
            MM: ['mjesec', 'mjeseca', 'mjeseci'],
            yy: ['godina', 'godine', 'godina']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var me = moment.defineLocale('me', {
        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
        monthsParseExact : true,
        weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
        weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sjutra u] LT',

            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedjelju] [u] LT';
                    case 3:
                        return '[u] [srijedu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[jue u] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[prole] [nedjelje] [u] LT',
                    '[prolog] [ponedjeljka] [u] LT',
                    '[prolog] [utorka] [u] LT',
                    '[prole] [srijede] [u] LT',
                    '[prolog] [etvrtka] [u] LT',
                    '[prolog] [petka] [u] LT',
                    '[prole] [subote] [u] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'nekoliko sekundi',
            ss     : translator.translate,
            m      : translator.translate,
            mm     : translator.translate,
            h      : translator.translate,
            hh     : translator.translate,
            d      : 'dan',
            dd     : translator.translate,
            M      : 'mjesec',
            MM     : translator.translate,
            y      : 'godinu',
            yy     : translator.translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return me;

})));


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var mi = moment.defineLocale('mi', {
        months: 'Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea'.split('_'),
        monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),
        monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
        weekdays: 'Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei'.split('_'),
        weekdaysShort: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
        weekdaysMin: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY [i] HH:mm',
            LLLL: 'dddd, D MMMM YYYY [i] HH:mm'
        },
        calendar: {
            sameDay: '[i teie mahana, i] LT',
            nextDay: '[apopo i] LT',
            nextWeek: 'dddd [i] LT',
            lastDay: '[inanahi i] LT',
            lastWeek: 'dddd [whakamutunga i] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'i roto i %s',
            past: '%s i mua',
            s: 'te hkona ruarua',
            ss: '%d hkona',
            m: 'he meneti',
            mm: '%d meneti',
            h: 'te haora',
            hh: '%d haora',
            d: 'he ra',
            dd: '%d ra',
            M: 'he marama',
            MM: '%d marama',
            y: 'he tau',
            yy: '%d tau'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return mi;

})));


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var mk = moment.defineLocale('mk', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : 'e_o_____a'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'D.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd, D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : '[] dddd [] LT',
            lastDay : '[ ] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 6:
                        return '[] dddd [] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[] dddd [] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : ' ',
            ss : '%d ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
        ordinal : function (number) {
            var lastDigit = number % 10,
                last2Digits = number % 100;
            if (number === 0) {
                return number + '-';
            } else if (last2Digits === 0) {
                return number + '-';
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + '-';
            } else if (lastDigit === 1) {
                return number + '-';
            } else if (lastDigit === 2) {
                return number + '-';
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + '-';
            } else {
                return number + '-';
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return mk;

})));


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var ml = moment.defineLocale('ml', {
        months : '___________'.split('_'),
        monthsShort : '._._._.___._._._._._.'.split('_'),
        monthsParseExact : true,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm -',
            LTS : 'A h:mm:ss -',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm -',
            LLLL : 'dddd, D MMMM YYYY, A h:mm -'
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        meridiemParse: /|| ||/i,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if ((meridiem === '' && hour >= 4) ||
                    meridiem === ' ' ||
                    meridiem === '') {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return ' ';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        }
    });

    return ml;

})));


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function translate(number, withoutSuffix, key, isFuture) {
        switch (key) {
            case 's':
                return withoutSuffix ? ' ' : ' ';
            case 'ss':
                return number + (withoutSuffix ? ' ' : ' ');
            case 'm':
            case 'mm':
                return number + (withoutSuffix ? ' ' : ' ');
            case 'h':
            case 'hh':
                return number + (withoutSuffix ? ' ' : ' ');
            case 'd':
            case 'dd':
                return number + (withoutSuffix ? ' ' : ' ');
            case 'M':
            case 'MM':
                return number + (withoutSuffix ? ' ' : ' ');
            case 'y':
            case 'yy':
                return number + (withoutSuffix ? ' ' : ' ');
            default:
                return number;
        }
    }

    var mn = moment.defineLocale('mn', {
        months : ' _ _ _ _ _ _ _ _ _ _  _  '.split('_'),
        monthsShort : '1 _2 _3 _4 _5 _6 _7 _8 _9 _10 _11 _12 '.split('_'),
        monthsParseExact : true,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'YYYY  MMMM D',
            LLL : 'YYYY  MMMM D HH:mm',
            LLLL : 'dddd, YYYY  MMMM D HH:mm'
        },
        meridiemParse: /|/i,
        isPM : function (input) {
            return input === '';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : '[] dddd LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : translate,
            ss : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2} /,
        ordinal : function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + ' ';
                default:
                    return number;
            }
        }
    });

    return mn;

})));


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    function relativeTimeMr(number, withoutSuffix, string, isFuture)
    {
        var output = '';
        if (withoutSuffix) {
            switch (string) {
                case 's': output = ' '; break;
                case 'ss': output = '%d '; break;
                case 'm': output = ' '; break;
                case 'mm': output = '%d '; break;
                case 'h': output = ' '; break;
                case 'hh': output = '%d '; break;
                case 'd': output = ' '; break;
                case 'dd': output = '%d '; break;
                case 'M': output = ' '; break;
                case 'MM': output = '%d '; break;
                case 'y': output = ' '; break;
                case 'yy': output = '%d '; break;
            }
        }
        else {
            switch (string) {
                case 's': output = ' '; break;
                case 'ss': output = '%d '; break;
                case 'm': output = ' '; break;
                case 'mm': output = '%d '; break;
                case 'h': output = ' '; break;
                case 'hh': output = '%d '; break;
                case 'd': output = ' '; break;
                case 'dd': output = '%d '; break;
                case 'M': output = ' '; break;
                case 'MM': output = '%d '; break;
                case 'y': output = ' '; break;
                case 'yy': output = '%d '; break;
            }
        }
        return output.replace(/%d/i, number);
    }

    var mr = moment.defineLocale('mr', {
        months : '___________'.split('_'),
        monthsShort: '._._._._._._._._._._._.'.split('_'),
        monthsParseExact : true,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm ',
            LTS : 'A h:mm:ss ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm '
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek: '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future: '%s',
            past: '%s',
            s: relativeTimeMr,
            ss: relativeTimeMr,
            m: relativeTimeMr,
            mm: relativeTimeMr,
            h: relativeTimeMr,
            hh: relativeTimeMr,
            d: relativeTimeMr,
            dd: relativeTimeMr,
            M: relativeTimeMr,
            MM: relativeTimeMr,
            y: relativeTimeMr,
            yy: relativeTimeMr
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /|||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return mr;

})));


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var ms = moment.defineLocale('ms', {
        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'tengahari') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'petang' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'tengahari';
            } else if (hours < 19) {
                return 'petang';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Esok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kelmarin pukul] LT',
            lastWeek : 'dddd [lepas pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lepas',
            s : 'beberapa saat',
            ss : '%d saat',
            m : 'seminit',
            mm : '%d minit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return ms;

})));


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var msMy = moment.defineLocale('ms-my', {
        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'tengahari') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'petang' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'tengahari';
            } else if (hours < 19) {
                return 'petang';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Esok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kelmarin pukul] LT',
            lastWeek : 'dddd [lepas pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lepas',
            s : 'beberapa saat',
            ss : '%d saat',
            m : 'seminit',
            mm : '%d minit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return msMy;

})));


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var mt = moment.defineLocale('mt', {
        months : 'Jannar_Frar_Marzu_April_Mejju_unju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diembru'.split('_'),
        monthsShort : 'Jan_Fra_Mar_Apr_Mej_un_Lul_Aww_Set_Ott_Nov_Di'.split('_'),
        weekdays : 'Il-add_It-Tnejn_It-Tlieta_L-Erbga_Il-amis_Il-imga_Is-Sibt'.split('_'),
        weekdaysShort : 'ad_Tne_Tli_Erb_am_im_Sib'.split('_'),
        weekdaysMin : 'a_Tn_Tl_Er_a_i_Si'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Illum fil-]LT',
            nextDay : '[Gada fil-]LT',
            nextWeek : 'dddd [fil-]LT',
            lastDay : '[Il-biera fil-]LT',
            lastWeek : 'dddd [li gadda] [fil-]LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'f %s',
            past : '%s ilu',
            s : 'ftit sekondi',
            ss : '%d sekondi',
            m : 'minuta',
            mm : '%d minuti',
            h : 'siega',
            hh : '%d siegat',
            d : 'urnata',
            dd : '%d ranet',
            M : 'xahar',
            MM : '%d xhur',
            y : 'sena',
            yy : '%d sni'
        },
        dayOfMonthOrdinalParse : /\d{1,2}/,
        ordinal: '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return mt;

})));


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var my = moment.defineLocale('my', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),

        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[.] LT []',
            nextDay: '[] LT []',
            nextWeek: 'dddd LT []',
            lastDay: '[.] LT []',
            lastWeek: '[] dddd LT []',
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s ',
            past: ' %s ',
            s: '.',
            ss : '%d ',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return my;

})));


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var nb = moment.defineLocale('nb', {
        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
        monthsParseExact : true,
        weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
        weekdaysShort : 's._ma._ti._on._to._fr._l.'.split('_'),
        weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY [kl.] HH:mm',
            LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
        },
        calendar : {
            sameDay: '[i dag kl.] LT',
            nextDay: '[i morgen kl.] LT',
            nextWeek: 'dddd [kl.] LT',
            lastDay: '[i gr kl.] LT',
            lastWeek: '[forrige] dddd [kl.] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : '%s siden',
            s : 'noen sekunder',
            ss : '%d sekunder',
            m : 'ett minutt',
            mm : '%d minutter',
            h : 'en time',
            hh : '%d timer',
            d : 'en dag',
            dd : '%d dager',
            M : 'en mned',
            MM : '%d mneder',
            y : 'ett r',
            yy : '%d r'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return nb;

})));


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var ne = moment.defineLocale('ne', {
        months : '___________'.split('_'),
        monthsShort : '._.__.___._._._._._.'.split('_'),
        monthsParseExact : true,
        weekdays : '______'.split('_'),
        weekdaysShort : '._._._._._._.'.split('_'),
        weekdaysMin : '._._._._._._.'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'A h:mm ',
            LTS : 'A h:mm:ss ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /|||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 3) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 16) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : '[] dddd[,] LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd[,] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s',
            past : '%s ',
            s : ' ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return ne;

})));


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

    var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
    var monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

    var nl = moment.defineLocale('nl', {
        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
        monthsShort : function (m, format) {
            if (!m) {
                return monthsShortWithDots;
            } else if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots[m.month()];
            } else {
                return monthsShortWithDots[m.month()];
            }
        },

        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

        monthsParse : monthsParse,
        longMonthsParse : monthsParse,
        shortMonthsParse : monthsParse,

        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
        weekdaysMin : 'zo_ma_di_wo_do_vr_za'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[vandaag om] LT',
            nextDay: '[morgen om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[gisteren om] LT',
            lastWeek: '[afgelopen] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'over %s',
            past : '%s geleden',
            s : 'een paar seconden',
            ss : '%d seconden',
            m : 'n minuut',
            mm : '%d minuten',
            h : 'n uur',
            hh : '%d uur',
            d : 'n dag',
            dd : '%d dagen',
            M : 'n maand',
            MM : '%d maanden',
            y : 'n jaar',
            yy : '%d jaar'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return nl;

})));


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

    var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
    var monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

    var nlBe = moment.defineLocale('nl-be', {
        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
        monthsShort : function (m, format) {
            if (!m) {
                return monthsShortWithDots;
            } else if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots[m.month()];
            } else {
                return monthsShortWithDots[m.month()];
            }
        },

        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

        monthsParse : monthsParse,
        longMonthsParse : monthsParse,
        shortMonthsParse : monthsParse,

        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
        weekdaysMin : 'zo_ma_di_wo_do_vr_za'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[vandaag om] LT',
            nextDay: '[morgen om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[gisteren om] LT',
            lastWeek: '[afgelopen] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'over %s',
            past : '%s geleden',
            s : 'een paar seconden',
            ss : '%d seconden',
            m : 'n minuut',
            mm : '%d minuten',
            h : 'n uur',
            hh : '%d uur',
            d : 'n dag',
            dd : '%d dagen',
            M : 'n maand',
            MM : '%d maanden',
            y : 'n jaar',
            yy : '%d jaar'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return nlBe;

})));


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var nn = moment.defineLocale('nn', {
        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays : 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
        weekdaysShort : 'sun_mn_tys_ons_tor_fre_lau'.split('_'),
        weekdaysMin : 'su_m_ty_on_to_fr_l'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY [kl.] H:mm',
            LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
        },
        calendar : {
            sameDay: '[I dag klokka] LT',
            nextDay: '[I morgon klokka] LT',
            nextWeek: 'dddd [klokka] LT',
            lastDay: '[I gr klokka] LT',
            lastWeek: '[Fregande] dddd [klokka] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : '%s sidan',
            s : 'nokre sekund',
            ss : '%d sekund',
            m : 'eit minutt',
            mm : '%d minutt',
            h : 'ein time',
            hh : '%d timar',
            d : 'ein dag',
            dd : '%d dagar',
            M : 'ein mnad',
            MM : '%d mnader',
            y : 'eit r',
            yy : '%d r'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return nn;

})));


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var paIn = moment.defineLocale('pa-in', {
        // There are months name as per Nanakshahi Calendar but they are not used as rigidly in modern Punjabi.
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm ',
            LTS : 'A h:mm:ss ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm '
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : '[] dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
        meridiemParse: /|||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return paIn;

})));


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_'),
        monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_');
    function plural(n) {
        return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
    }
    function translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
            case 'ss':
                return result + (plural(number) ? 'sekundy' : 'sekund');
            case 'm':
                return withoutSuffix ? 'minuta' : 'minut';
            case 'mm':
                return result + (plural(number) ? 'minuty' : 'minut');
            case 'h':
                return withoutSuffix  ? 'godzina'  : 'godzin';
            case 'hh':
                return result + (plural(number) ? 'godziny' : 'godzin');
            case 'MM':
                return result + (plural(number) ? 'miesice' : 'miesicy');
            case 'yy':
                return result + (plural(number) ? 'lata' : 'lat');
        }
    }

    var pl = moment.defineLocale('pl', {
        months : function (momentToFormat, format) {
            if (!momentToFormat) {
                return monthsNominative;
            } else if (format === '') {
                // Hack: if format empty we know this is used to generate
                // RegExp by moment. Give then back both valid forms of months
                // in RegExp ready format.
                return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
            } else if (/D MMMM/.test(format)) {
                return monthsSubjective[momentToFormat.month()];
            } else {
                return monthsNominative[momentToFormat.month()];
            }
        },
        monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),
        weekdays : 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),
        weekdaysShort : 'ndz_pon_wt_r_czw_pt_sob'.split('_'),
        weekdaysMin : 'Nd_Pn_Wt_r_Cz_Pt_So'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Dzi o] LT',
            nextDay: '[Jutro o] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[W niedziel o] LT';

                    case 2:
                        return '[We wtorek o] LT';

                    case 3:
                        return '[W rod o] LT';

                    case 6:
                        return '[W sobot o] LT';

                    default:
                        return '[W] dddd [o] LT';
                }
            },
            lastDay: '[Wczoraj o] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[W zesz niedziel o] LT';
                    case 3:
                        return '[W zesz rod o] LT';
                    case 6:
                        return '[W zesz sobot o] LT';
                    default:
                        return '[W zeszy] dddd [o] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : '%s temu',
            s : 'kilka sekund',
            ss : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : '1 dzie',
            dd : '%d dni',
            M : 'miesic',
            MM : translate,
            y : 'rok',
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return pl;

})));


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var pt = moment.defineLocale('pt', {
        months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays : 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
        weekdaysMin : 'Do_2_3_4_5_6_S'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY HH:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Hoje s] LT',
            nextDay: '[Amanh s] LT',
            nextWeek: 'dddd [s] LT',
            lastDay: '[Ontem s] LT',
            lastWeek: function () {
                return (this.day() === 0 || this.day() === 6) ?
                    '[ltimo] dddd [s] LT' : // Saturday + Sunday
                    '[ltima] dddd [s] LT'; // Monday - Friday
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'em %s',
            past : 'h %s',
            s : 'segundos',
            ss : '%d segundos',
            m : 'um minuto',
            mm : '%d minutos',
            h : 'uma hora',
            hh : '%d horas',
            d : 'um dia',
            dd : '%d dias',
            M : 'um ms',
            MM : '%d meses',
            y : 'um ano',
            yy : '%d anos'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return pt;

})));


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var ptBr = moment.defineLocale('pt-br', {
        months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays : 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
        weekdaysMin : 'Do_2_3_4_5_6_S'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY [s] HH:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY [s] HH:mm'
        },
        calendar : {
            sameDay: '[Hoje s] LT',
            nextDay: '[Amanh s] LT',
            nextWeek: 'dddd [s] LT',
            lastDay: '[Ontem s] LT',
            lastWeek: function () {
                return (this.day() === 0 || this.day() === 6) ?
                    '[ltimo] dddd [s] LT' : // Saturday + Sunday
                    '[ltima] dddd [s] LT'; // Monday - Friday
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'em %s',
            past : 'h %s',
            s : 'poucos segundos',
            ss : '%d segundos',
            m : 'um minuto',
            mm : '%d minutos',
            h : 'uma hora',
            hh : '%d horas',
            d : 'um dia',
            dd : '%d dias',
            M : 'um ms',
            MM : '%d meses',
            y : 'um ano',
            yy : '%d anos'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal : '%d'
    });

    return ptBr;

})));


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
                'ss': 'secunde',
                'mm': 'minute',
                'hh': 'ore',
                'dd': 'zile',
                'MM': 'luni',
                'yy': 'ani'
            },
            separator = ' ';
        if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
            separator = ' de ';
        }
        return number + separator + format[key];
    }

    var ro = moment.defineLocale('ro', {
        months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
        monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays : 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),
        weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),
        weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd, D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay: '[azi la] LT',
            nextDay: '[mine la] LT',
            nextWeek: 'dddd [la] LT',
            lastDay: '[ieri la] LT',
            lastWeek: '[fosta] dddd [la] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'peste %s',
            past : '%s n urm',
            s : 'cteva secunde',
            ss : relativeTimeWithPlural,
            m : 'un minut',
            mm : relativeTimeWithPlural,
            h : 'o or',
            hh : relativeTimeWithPlural,
            d : 'o zi',
            dd : relativeTimeWithPlural,
            M : 'o lun',
            MM : relativeTimeWithPlural,
            y : 'un an',
            yy : relativeTimeWithPlural
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return ro;

})));


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'ss': withoutSuffix ? '__' : '__',
            'mm': withoutSuffix ? '__' : '__',
            'hh': '__',
            'dd': '__',
            'MM': '__',
            'yy': '__'
        };
        if (key === 'm') {
            return withoutSuffix ? '' : '';
        }
        else {
            return number + ' ' + plural(format[key], +number);
        }
    }
    var monthsParse = [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i];

    // http://new.gramota.ru/spravka/rules/139-prop :  103
    //  : http://new.gramota.ru/spravka/buro/search-answer?s=242637
    // CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
    var ru = moment.defineLocale('ru', {
        months : {
            format: '___________'.split('_'),
            standalone: '___________'.split('_')
        },
        monthsShort : {
            //  CLDR  "."  ".",        ?
            format: '._._._.____._._._._.'.split('_'),
            standalone: '._.__.____._._._._.'.split('_')
        },
        weekdays : {
            standalone: '______'.split('_'),
            format: '______'.split('_'),
            isFormat: /\[ ?[] ?(?:||)? ?\] ?dddd/
        },
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        monthsParse : monthsParse,
        longMonthsParse : monthsParse,
        shortMonthsParse : monthsParse,

        //    ,   ,  ,  4 ,      
        monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,

        //  
        monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,

        //    
        monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,

        // ,     
        monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY .',
            LLL : 'D MMMM YYYY ., H:mm',
            LLLL : 'dddd, D MMMM YYYY ., H:mm'
        },
        calendar : {
            sameDay: '[, ] LT',
            nextDay: '[, ] LT',
            lastDay: '[, ] LT',
            nextWeek: function (now) {
                if (now.week() !== this.week()) {
                    switch (this.day()) {
                        case 0:
                            return '[ ] dddd, [] LT';
                        case 1:
                        case 2:
                        case 4:
                            return '[ ] dddd, [] LT';
                        case 3:
                        case 5:
                        case 6:
                            return '[ ] dddd, [] LT';
                    }
                } else {
                    if (this.day() === 2) {
                        return '[] dddd, [] LT';
                    } else {
                        return '[] dddd, [] LT';
                    }
                }
            },
            lastWeek: function (now) {
                if (now.week() !== this.week()) {
                    switch (this.day()) {
                        case 0:
                            return '[ ] dddd, [] LT';
                        case 1:
                        case 2:
                        case 4:
                            return '[ ] dddd, [] LT';
                        case 3:
                        case 5:
                        case 6:
                            return '[ ] dddd, [] LT';
                    }
                } else {
                    if (this.day() === 2) {
                        return '[] dddd, [] LT';
                    } else {
                        return '[] dddd, [] LT';
                    }
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            ss : relativeTimeWithPlural,
            m : relativeTimeWithPlural,
            mm : relativeTimeWithPlural,
            h : '',
            hh : relativeTimeWithPlural,
            d : '',
            dd : relativeTimeWithPlural,
            M : '',
            MM : relativeTimeWithPlural,
            y : '',
            yy : relativeTimeWithPlural
        },
        meridiemParse: /|||/i,
        isPM : function (input) {
            return /^(|)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return '';
            } else {
                return '';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'M':
                case 'd':
                case 'DDD':
                    return number + '-';
                case 'D':
                    return number + '-';
                case 'w':
                case 'W':
                    return number + '-';
                default:
                    return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return ru;

})));


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var months = [
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        ''
    ];
    var days = [
        '',
        '',
        '',
        '',
        '',
        '',
        ''
    ];

    var sd = moment.defineLocale('sd', {
        months : months,
        monthsShort : months,
        weekdays : days,
        weekdaysShort : days,
        weekdaysMin : days,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM : function (input) {
            return '' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            }
            return '';
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd [  ] LT',
            lastDay : '[] LT',
            lastWeek : '[ ] dddd [] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/,/g, '');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return sd;

})));


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var se = moment.defineLocale('se', {
        months : 'oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu'.split('_'),
        monthsShort : 'oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov'.split('_'),
        weekdays : 'sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat'.split('_'),
        weekdaysShort : 'sotn_vuos_ma_gask_duor_bear_lv'.split('_'),
        weekdaysMin : 's_v_m_g_d_b_L'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'MMMM D. [b.] YYYY',
            LLL : 'MMMM D. [b.] YYYY [ti.] HH:mm',
            LLLL : 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
        },
        calendar : {
            sameDay: '[otne ti] LT',
            nextDay: '[ihttin ti] LT',
            nextWeek: 'dddd [ti] LT',
            lastDay: '[ikte ti] LT',
            lastWeek: '[ovddit] dddd [ti] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s geaes',
            past : 'mait %s',
            s : 'moadde sekunddat',
            ss: '%d sekunddat',
            m : 'okta minuhta',
            mm : '%d minuhtat',
            h : 'okta diimmu',
            hh : '%d diimmut',
            d : 'okta beaivi',
            dd : '%d beaivvit',
            M : 'okta mnnu',
            MM : '%d mnut',
            y : 'okta jahki',
            yy : '%d jagit'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return se;

})));


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    /*jshint -W100*/
    var si = moment.defineLocale('si', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'a h:mm',
            LTS : 'a h:mm:ss',
            L : 'YYYY/MM/DD',
            LL : 'YYYY MMMM D',
            LLL : 'YYYY MMMM D, a h:mm',
            LLLL : 'YYYY MMMM D [] dddd, a h:mm:ss'
        },
        calendar : {
            sameDay : '[] LT[]',
            nextDay : '[] LT[]',
            nextWeek : 'dddd LT[]',
            lastDay : '[] LT[]',
            lastWeek : '[] dddd LT[]',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s',
            past : '%s ',
            s : ' ',
            ss : ' %d',
            m : '',
            mm : ' %d',
            h : '',
            hh : ' %d',
            d : '',
            dd : ' %d',
            M : '',
            MM : ' %d',
            y : '',
            yy : ' %d'
        },
        dayOfMonthOrdinalParse: /\d{1,2} /,
        ordinal : function (number) {
            return number + ' ';
        },
        meridiemParse : / | |.|../,
        isPM : function (input) {
            return input === '..' || input === ' ';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? '..' : ' ';
            } else {
                return isLower ? '..' : ' ';
            }
        }
    });

    return si;

})));


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var months = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_'),
        monthsShort = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');
    function plural(n) {
        return (n > 1) && (n < 5);
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's':  // a few seconds / in a few seconds / a few seconds ago
                return (withoutSuffix || isFuture) ? 'pr seknd' : 'pr sekundami';
            case 'ss': // 9 seconds / in 9 seconds / 9 seconds ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'sekundy' : 'seknd');
                } else {
                    return result + 'sekundami';
                }
                break;
            case 'm':  // a minute / in a minute / a minute ago
                return withoutSuffix ? 'minta' : (isFuture ? 'mintu' : 'mintou');
            case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'minty' : 'mint');
                } else {
                    return result + 'mintami';
                }
                break;
            case 'h':  // an hour / in an hour / an hour ago
                return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
            case 'hh': // 9 hours / in 9 hours / 9 hours ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'hodiny' : 'hodn');
                } else {
                    return result + 'hodinami';
                }
                break;
            case 'd':  // a day / in a day / a day ago
                return (withoutSuffix || isFuture) ? 'de' : 'dom';
            case 'dd': // 9 days / in 9 days / 9 days ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'dni' : 'dn');
                } else {
                    return result + 'dami';
                }
                break;
            case 'M':  // a month / in a month / a month ago
                return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
            case 'MM': // 9 months / in 9 months / 9 months ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'mesiace' : 'mesiacov');
                } else {
                    return result + 'mesiacmi';
                }
                break;
            case 'y':  // a year / in a year / a year ago
                return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
            case 'yy': // 9 years / in 9 years / 9 years ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'roky' : 'rokov');
                } else {
                    return result + 'rokmi';
                }
                break;
        }
    }

    var sk = moment.defineLocale('sk', {
        months : months,
        monthsShort : monthsShort,
        weekdays : 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),
        weekdaysShort : 'ne_po_ut_st_t_pi_so'.split('_'),
        weekdaysMin : 'ne_po_ut_st_t_pi_so'.split('_'),
        longDateFormat : {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay: '[dnes o] LT',
            nextDay: '[zajtra o] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[v nedeu o] LT';
                    case 1:
                    case 2:
                        return '[v] dddd [o] LT';
                    case 3:
                        return '[v stredu o] LT';
                    case 4:
                        return '[vo tvrtok o] LT';
                    case 5:
                        return '[v piatok o] LT';
                    case 6:
                        return '[v sobotu o] LT';
                }
            },
            lastDay: '[vera o] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[minul nedeu o] LT';
                    case 1:
                    case 2:
                        return '[minul] dddd [o] LT';
                    case 3:
                        return '[minul stredu o] LT';
                    case 4:
                    case 5:
                        return '[minul] dddd [o] LT';
                    case 6:
                        return '[minul sobotu o] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : 'pred %s',
            s : translate,
            ss : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return sk;

})));


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's':
                return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
            case 'ss':
                if (number === 1) {
                    result += withoutSuffix ? 'sekundo' : 'sekundi';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'sekundi' : 'sekundah';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'sekunde' : 'sekundah';
                } else {
                    result += 'sekund';
                }
                return result;
            case 'm':
                return withoutSuffix ? 'ena minuta' : 'eno minuto';
            case 'mm':
                if (number === 1) {
                    result += withoutSuffix ? 'minuta' : 'minuto';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'minute' : 'minutami';
                } else {
                    result += withoutSuffix || isFuture ? 'minut' : 'minutami';
                }
                return result;
            case 'h':
                return withoutSuffix ? 'ena ura' : 'eno uro';
            case 'hh':
                if (number === 1) {
                    result += withoutSuffix ? 'ura' : 'uro';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'uri' : 'urama';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'ure' : 'urami';
                } else {
                    result += withoutSuffix || isFuture ? 'ur' : 'urami';
                }
                return result;
            case 'd':
                return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
            case 'dd':
                if (number === 1) {
                    result += withoutSuffix || isFuture ? 'dan' : 'dnem';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
                } else {
                    result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
                }
                return result;
            case 'M':
                return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
            case 'MM':
                if (number === 1) {
                    result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
                } else {
                    result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
                }
                return result;
            case 'y':
                return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
            case 'yy':
                if (number === 1) {
                    result += withoutSuffix || isFuture ? 'leto' : 'letom';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'leti' : 'letoma';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'leta' : 'leti';
                } else {
                    result += withoutSuffix || isFuture ? 'let' : 'leti';
                }
                return result;
        }
    }

    var sl = moment.defineLocale('sl', {
        months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays : 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),
        weekdaysShort : 'ned._pon._tor._sre._et._pet._sob.'.split('_'),
        weekdaysMin : 'ne_po_to_sr_e_pe_so'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[danes ob] LT',
            nextDay  : '[jutri ob] LT',

            nextWeek : function () {
                switch (this.day()) {
                    case 0:
                        return '[v] [nedeljo] [ob] LT';
                    case 3:
                        return '[v] [sredo] [ob] LT';
                    case 6:
                        return '[v] [soboto] [ob] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[v] dddd [ob] LT';
                }
            },
            lastDay  : '[veraj ob] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 0:
                        return '[prejnjo] [nedeljo] [ob] LT';
                    case 3:
                        return '[prejnjo] [sredo] [ob] LT';
                    case 6:
                        return '[prejnjo] [soboto] [ob] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[prejnji] dddd [ob] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'ez %s',
            past   : 'pred %s',
            s      : processRelativeTime,
            ss     : processRelativeTime,
            m      : processRelativeTime,
            mm     : processRelativeTime,
            h      : processRelativeTime,
            hh     : processRelativeTime,
            d      : processRelativeTime,
            dd     : processRelativeTime,
            M      : processRelativeTime,
            MM     : processRelativeTime,
            y      : processRelativeTime,
            yy     : processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return sl;

})));


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var sq = moment.defineLocale('sq', {
        months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),
        monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),
        weekdays : 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),
        weekdaysShort : 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),
        weekdaysMin : 'D_H_Ma_M_E_P_Sh'.split('_'),
        weekdaysParseExact : true,
        meridiemParse: /PD|MD/,
        isPM: function (input) {
            return input.charAt(0) === 'M';
        },
        meridiem : function (hours, minutes, isLower) {
            return hours < 12 ? 'PD' : 'MD';
        },
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Sot n] LT',
            nextDay : '[Nesr n] LT',
            nextWeek : 'dddd [n] LT',
            lastDay : '[Dje n] LT',
            lastWeek : 'dddd [e kaluar n] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'n %s',
            past : '%s m par',
            s : 'disa sekonda',
            ss : '%d sekonda',
            m : 'nj minut',
            mm : '%d minuta',
            h : 'nj or',
            hh : '%d or',
            d : 'nj dit',
            dd : '%d dit',
            M : 'nj muaj',
            MM : '%d muaj',
            y : 'nj vit',
            yy : '%d vite'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return sq;

})));


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var translator = {
        words: { //Different grammatical cases
            ss: ['sekunda', 'sekunde', 'sekundi'],
            m: ['jedan minut', 'jedne minute'],
            mm: ['minut', 'minute', 'minuta'],
            h: ['jedan sat', 'jednog sata'],
            hh: ['sat', 'sata', 'sati'],
            dd: ['dan', 'dana', 'dana'],
            MM: ['mesec', 'meseca', 'meseci'],
            yy: ['godina', 'godine', 'godina']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var sr = moment.defineLocale('sr', {
        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays: 'nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota'.split('_'),
        weekdaysShort: 'ned._pon._uto._sre._et._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sutra u] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedelju] [u] LT';
                    case 3:
                        return '[u] [sredu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[jue u] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[prole] [nedelje] [u] LT',
                    '[prolog] [ponedeljka] [u] LT',
                    '[prolog] [utorka] [u] LT',
                    '[prole] [srede] [u] LT',
                    '[prolog] [etvrtka] [u] LT',
                    '[prolog] [petka] [u] LT',
                    '[prole] [subote] [u] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'pre %s',
            s      : 'nekoliko sekundi',
            ss     : translator.translate,
            m      : translator.translate,
            mm     : translator.translate,
            h      : translator.translate,
            hh     : translator.translate,
            d      : 'dan',
            dd     : translator.translate,
            M      : 'mesec',
            MM     : translator.translate,
            y      : 'godinu',
            yy     : translator.translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return sr;

})));


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var translator = {
        words: { //Different grammatical cases
            ss: ['', '', ''],
            m: [' ', ' '],
            mm: ['', '', ''],
            h: [' ', ' '],
            hh: ['', '', ''],
            dd: ['', '', ''],
            MM: ['', '', ''],
            yy: ['', '', '']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var srCyrl = moment.defineLocale('sr-cyrl', {
        months: '___________'.split('_'),
        monthsShort: '._._._.____._._._._.'.split('_'),
        monthsParseExact: true,
        weekdays: '______'.split('_'),
        weekdaysShort: '._._._._._._.'.split('_'),
        weekdaysMin: '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[] [] [] LT';
                    case 3:
                        return '[] [] [] LT';
                    case 6:
                        return '[] [] [] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[] dddd [] LT';
                }
            },
            lastDay  : '[ ] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past   : ' %s',
            s      : ' ',
            ss     : translator.translate,
            m      : translator.translate,
            mm     : translator.translate,
            h      : translator.translate,
            hh     : translator.translate,
            d      : '',
            dd     : translator.translate,
            M      : '',
            MM     : translator.translate,
            y      : '',
            yy     : translator.translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return srCyrl;

})));


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var ss = moment.defineLocale('ss', {
        months : "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
        monthsShort : 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
        weekdays : 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
        weekdaysShort : 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
        weekdaysMin : 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Namuhla nga] LT',
            nextDay : '[Kusasa nga] LT',
            nextWeek : 'dddd [nga] LT',
            lastDay : '[Itolo nga] LT',
            lastWeek : 'dddd [leliphelile] [nga] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'nga %s',
            past : 'wenteka nga %s',
            s : 'emizuzwana lomcane',
            ss : '%d mzuzwana',
            m : 'umzuzu',
            mm : '%d emizuzu',
            h : 'lihora',
            hh : '%d emahora',
            d : 'lilanga',
            dd : '%d emalanga',
            M : 'inyanga',
            MM : '%d tinyanga',
            y : 'umnyaka',
            yy : '%d iminyaka'
        },
        meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'ekuseni';
            } else if (hours < 15) {
                return 'emini';
            } else if (hours < 19) {
                return 'entsambama';
            } else {
                return 'ebusuku';
            }
        },
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'ekuseni') {
                return hour;
            } else if (meridiem === 'emini') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
                if (hour === 0) {
                    return 0;
                }
                return hour + 12;
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return ss;

})));


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var sv = moment.defineLocale('sv', {
        months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),
        weekdaysShort : 'sn_mn_tis_ons_tor_fre_lr'.split('_'),
        weekdaysMin : 's_m_ti_on_to_fr_l'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [kl.] HH:mm',
            LLLL : 'dddd D MMMM YYYY [kl.] HH:mm',
            lll : 'D MMM YYYY HH:mm',
            llll : 'ddd D MMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Idag] LT',
            nextDay: '[Imorgon] LT',
            lastDay: '[Igr] LT',
            nextWeek: '[P] dddd LT',
            lastWeek: '[I] dddd[s] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : 'fr %s sedan',
            s : 'ngra sekunder',
            ss : '%d sekunder',
            m : 'en minut',
            mm : '%d minuter',
            h : 'en timme',
            hh : '%d timmar',
            d : 'en dag',
            dd : '%d dagar',
            M : 'en mnad',
            MM : '%d mnader',
            y : 'ett r',
            yy : '%d r'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(e|a)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'e' :
                (b === 1) ? 'a' :
                (b === 2) ? 'a' :
                (b === 3) ? 'e' : 'e';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return sv;

})));


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var sw = moment.defineLocale('sw', {
        months : 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
        weekdays : 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
        weekdaysShort : 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
        weekdaysMin : 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[leo saa] LT',
            nextDay : '[kesho saa] LT',
            nextWeek : '[wiki ijayo] dddd [saat] LT',
            lastDay : '[jana] LT',
            lastWeek : '[wiki iliyopita] dddd [saat] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s baadaye',
            past : 'tokea %s',
            s : 'hivi punde',
            ss : 'sekunde %d',
            m : 'dakika moja',
            mm : 'dakika %d',
            h : 'saa limoja',
            hh : 'masaa %d',
            d : 'siku moja',
            dd : 'masiku %d',
            M : 'mwezi mmoja',
            MM : 'miezi %d',
            y : 'mwaka mmoja',
            yy : 'miaka %d'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return sw;

})));


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var ta = moment.defineLocale('ta', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, HH:mm',
            LLLL : 'dddd, D MMMM YYYY, HH:mm'
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[ ] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : '  ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : '  ',
            hh : '%d  ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal : function (number) {
            return number + '';
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // refer http://ta.wikipedia.org/s/1er1
        meridiemParse: /|||||/,
        meridiem : function (hour, minute, isLower) {
            if (hour < 2) {
                return ' ';
            } else if (hour < 6) {
                return ' ';  // 
            } else if (hour < 10) {
                return ' '; // 
            } else if (hour < 14) {
                return ' '; // 
            } else if (hour < 18) {
                return ' '; // 
            } else if (hour < 22) {
                return ' '; // 
            } else {
                return ' ';
            }
        },
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 2 ? hour : hour + 12;
            } else if (meridiem === '' || meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else {
                return hour + 12;
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return ta;

})));


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var te = moment.defineLocale('te', {
        months : '___________'.split('_'),
        monthsShort : '._.__.____._._._._.'.split('_'),
        monthsParseExact : true,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm',
            LTS : 'A h:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm',
            LLLL : 'dddd, D MMMM YYYY, A h:mm'
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        dayOfMonthOrdinalParse : /\d{1,2}/,
        ordinal : '%d',
        meridiemParse: /|||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return te;

})));


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var tet = moment.defineLocale('tet', {
        months : 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays : 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu'.split('_'),
        weekdaysShort : 'Dom_Seg_Ters_Kua_Kint_Sest_Sab'.split('_'),
        weekdaysMin : 'Do_Seg_Te_Ku_Ki_Ses_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Ohin iha] LT',
            nextDay: '[Aban iha] LT',
            nextWeek: 'dddd [iha] LT',
            lastDay: '[Horiseik iha] LT',
            lastWeek: 'dddd [semana kotuk] [iha] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'iha %s',
            past : '%s liuba',
            s : 'minutu balun',
            ss : 'minutu %d',
            m : 'minutu ida',
            mm : 'minutu %d',
            h : 'oras ida',
            hh : 'oras %d',
            d : 'loron ida',
            dd : 'loron %d',
            M : 'fulan ida',
            MM : 'fulan %d',
            y : 'tinan ida',
            yy : 'tinan %d'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return tet;

})));


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var suffixes = {
        0: '-',
        1: '-',
        2: '-',
        3: '-',
        4: '-',
        5: '-',
        6: '-',
        7: '-',
        8: '-',
        9: '-',
        10: '-',
        12: '-',
        13: '-',
        20: '-',
        30: '-',
        40: '-',
        50: '-',
        60: '-',
        70: '-',
        80: '-',
        90: '-',
        100: '-'
    };

    var tg = moment.defineLocale('tg', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            lastDay : '[ ] LT',
            nextWeek : 'dddd[] [  ] LT',
            lastWeek : 'dddd[] [  ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        meridiemParse: /|||/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 11) {
                return '';
            } else if (hour < 16) {
                return '';
            } else if (hour < 19) {
                return '';
            } else {
                return '';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
        ordinal: function (number) {
            var a = number % 10,
                b = number >= 100 ? 100 : null;
            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1th is the first week of the year.
        }
    });

    return tg;

})));


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var th = moment.defineLocale('th', {
        months : '___________'.split('_'),
        monthsShort : '.._.._.._.._.._.._.._.._.._.._.._..'.split('_'),
        monthsParseExact: true,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'), // yes, three characters difference
        weekdaysMin : '._._._._._._.'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY  H:mm',
            LLLL : 'dddd D MMMM YYYY  H:mm'
        },
        meridiemParse: /|/,
        isPM: function (input) {
            return input === '';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd[ ] LT',
            lastDay : '[ ] LT',
            lastWeek : '[]dddd[ ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s',
            s : '',
            ss : '%d ',
            m : '1 ',
            mm : '%d ',
            h : '1 ',
            hh : '%d ',
            d : '1 ',
            dd : '%d ',
            M : '1 ',
            MM : '%d ',
            y : '1 ',
            yy : '%d '
        }
    });

    return th;

})));


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var tlPh = moment.defineLocale('tl-ph', {
        months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
        monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
        weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
        weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
        weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'MM/D/YYYY',
            LL : 'MMMM D, YYYY',
            LLL : 'MMMM D, YYYY HH:mm',
            LLLL : 'dddd, MMMM DD, YYYY HH:mm'
        },
        calendar : {
            sameDay: 'LT [ngayong araw]',
            nextDay: '[Bukas ng] LT',
            nextWeek: 'LT [sa susunod na] dddd',
            lastDay: 'LT [kahapon]',
            lastWeek: 'LT [noong nakaraang] dddd',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'sa loob ng %s',
            past : '%s ang nakalipas',
            s : 'ilang segundo',
            ss : '%d segundo',
            m : 'isang minuto',
            mm : '%d minuto',
            h : 'isang oras',
            hh : '%d oras',
            d : 'isang araw',
            dd : '%d araw',
            M : 'isang buwan',
            MM : '%d buwan',
            y : 'isang taon',
            yy : '%d taon'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal : function (number) {
            return number;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return tlPh;

})));


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var numbersNouns = 'pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

    function translateFuture(output) {
        var time = output;
        time = (output.indexOf('jaj') !== -1) ?
        time.slice(0, -3) + 'leS' :
        (output.indexOf('jar') !== -1) ?
        time.slice(0, -3) + 'waQ' :
        (output.indexOf('DIS') !== -1) ?
        time.slice(0, -3) + 'nem' :
        time + ' pIq';
        return time;
    }

    function translatePast(output) {
        var time = output;
        time = (output.indexOf('jaj') !== -1) ?
        time.slice(0, -3) + 'Hu' :
        (output.indexOf('jar') !== -1) ?
        time.slice(0, -3) + 'wen' :
        (output.indexOf('DIS') !== -1) ?
        time.slice(0, -3) + 'ben' :
        time + ' ret';
        return time;
    }

    function translate(number, withoutSuffix, string, isFuture) {
        var numberNoun = numberAsNoun(number);
        switch (string) {
            case 'ss':
                return numberNoun + ' lup';
            case 'mm':
                return numberNoun + ' tup';
            case 'hh':
                return numberNoun + ' rep';
            case 'dd':
                return numberNoun + ' jaj';
            case 'MM':
                return numberNoun + ' jar';
            case 'yy':
                return numberNoun + ' DIS';
        }
    }

    function numberAsNoun(number) {
        var hundred = Math.floor((number % 1000) / 100),
        ten = Math.floor((number % 100) / 10),
        one = number % 10,
        word = '';
        if (hundred > 0) {
            word += numbersNouns[hundred] + 'vatlh';
        }
        if (ten > 0) {
            word += ((word !== '') ? ' ' : '') + numbersNouns[ten] + 'maH';
        }
        if (one > 0) {
            word += ((word !== '') ? ' ' : '') + numbersNouns[one];
        }
        return (word === '') ? 'pagh' : word;
    }

    var tlh = moment.defineLocale('tlh', {
        months : 'tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha'.split('_'),
        monthsShort : 'jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha'.split('_'),
        monthsParseExact : true,
        weekdays : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
        weekdaysShort : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
        weekdaysMin : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[DaHjaj] LT',
            nextDay: '[waleS] LT',
            nextWeek: 'LLL',
            lastDay: '[waHu] LT',
            lastWeek: 'LLL',
            sameElse: 'L'
        },
        relativeTime : {
            future : translateFuture,
            past : translatePast,
            s : 'puS lup',
            ss : translate,
            m : 'wa tup',
            mm : translate,
            h : 'wa rep',
            hh : translate,
            d : 'wa jaj',
            dd : translate,
            M : 'wa jar',
            MM : translate,
            y : 'wa DIS',
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return tlh;

})));


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {


;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';

    var suffixes = {
        1: '\'inci',
        5: '\'inci',
        8: '\'inci',
        70: '\'inci',
        80: '\'inci',
        2: '\'nci',
        7: '\'nci',
        20: '\'nci',
        50: '\'nci',
        3: '\'nc',
        4: '\'nc',
        100: '\'nc',
        6: '\'nc',
        9: '\'uncu',
        10: '\'uncu',
        30: '\'uncu',
        60: '\'nc',
        90: '\'nc'
    };

    var tr = moment.defineLocale('tr', {
        months : 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),
        monthsShort : 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),
        weekdays : 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),
        weekdaysShort : 'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),
        weekdaysMin : 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[bugn saat] LT',
            nextDay : '[yarn saat] LT',
            nextWeek : '[gelecek] dddd [saat] LT',
            lastDay : '[dn] LT',
            lastWeek : '[geen] dddd [saat] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s sonra',
            past : '%s nce',
            s : 'birka saniye',
            ss : '%d saniye',
            m : 'bir dakika',
            mm : '%d dakika',
            h : 'bir saat',
            hh : '%d saat',
            d : 'bir gn',
            dd : '%d gn',
            M : 'bir ay',
            MM : '%d ay',
            y : 'bir yl',
            yy : '%d yl'
        },
        ordinal: function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'Do':
                case 'DD':
                    return number;
                default:
                    if (number === 0) {  // special case for zero
                        return number + '\'nc';
                    }
                    var a = number % 10,
                        b = number % 100 - a,
                        c = number >= 100 ? 100 : null;
                    return number + (suffixes[a] || suffixes[b] || suffixes[c]);
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return tr;

})));


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    // After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
    // This is currently too difficult (maybe even impossible) to add.
    var tzl = moment.defineLocale('tzl', {
        months : 'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
        weekdays : 'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),
        weekdaysShort : 'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),
        weekdaysMin : 'S_L_Ma_M_Xh_Vi_S'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM [dallas] YYYY',
            LLL : 'D. MMMM [dallas] YYYY HH.mm',
            LLLL : 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
        },
        meridiemParse: /d\'o|d\'a/i,
        isPM : function (input) {
            return 'd\'o' === input.toLowerCase();
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'd\'o' : 'D\'O';
            } else {
                return isLower ? 'd\'a' : 'D\'A';
            }
        },
        calendar : {
            sameDay : '[oxhi ] LT',
            nextDay : '[dem ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ieiri ] LT',
            lastWeek : '[sr el] dddd [lasteu ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'osprei %s',
            past : 'ja%s',
            s : processRelativeTime,
            ss : processRelativeTime,
            m : processRelativeTime,
            mm : processRelativeTime,
            h : processRelativeTime,
            hh : processRelativeTime,
            d : processRelativeTime,
            dd : processRelativeTime,
            M : processRelativeTime,
            MM : processRelativeTime,
            y : processRelativeTime,
            yy : processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            's': ['viensas secunds', '\'iensas secunds'],
            'ss': [number + ' secunds', '' + number + ' secunds'],
            'm': ['\'n mut', '\'iens mut'],
            'mm': [number + ' muts', '' + number + ' muts'],
            'h': ['\'n ora', '\'iensa ora'],
            'hh': [number + ' oras', '' + number + ' oras'],
            'd': ['\'n ziua', '\'iensa ziua'],
            'dd': [number + ' ziuas', '' + number + ' ziuas'],
            'M': ['\'n mes', '\'iens mes'],
            'MM': [number + ' mesen', '' + number + ' mesen'],
            'y': ['\'n ar', '\'iens ar'],
            'yy': [number + ' ars', '' + number + ' ars']
        };
        return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);
    }

    return tzl;

})));


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var tzm = moment.defineLocale('tzm', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[ ] LT',
            lastWeek: 'dddd [] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : '   %s',
            past : ' %s',
            s : '',
            ss : '%d ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d o',
            M : 'o',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 12th is the first week of the year.
        }
    });

    return tzm;

})));


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var tzmLatn = moment.defineLocale('tzm-latn', {
        months : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
        monthsShort : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
        weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
        weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
        weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[asdkh g] LT',
            nextDay: '[aska g] LT',
            nextWeek: 'dddd [g] LT',
            lastDay: '[assant g] LT',
            lastWeek: 'dddd [g] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'dadkh s yan %s',
            past : 'yan %s',
            s : 'imik',
            ss : '%d imik',
            m : 'minu',
            mm : '%d minu',
            h : 'saa',
            hh : '%d tassain',
            d : 'ass',
            dd : '%d ossan',
            M : 'ayowr',
            MM : '%d iyyirn',
            y : 'asgas',
            yy : '%d isgasn'
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 12th is the first week of the year.
        }
    });

    return tzmLatn;

})));


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js language configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var ugCn = moment.defineLocale('ug-cn', {
        months: '___________'.split(
            '_'
        ),
        monthsShort: '___________'.split(
            '_'
        ),
        weekdays: '______'.split(
            '_'
        ),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY-MM-DD',
            LL: 'YYYY-M-D-',
            LLL: 'YYYY-M-D- HH:mm',
            LLLL: 'dddd YYYY-M-D- HH:mm'
        },
        meridiemParse: / || || |/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (
                meridiem === ' ' ||
                meridiem === '' ||
                meridiem === ' '
            ) {
                return hour;
            } else if (meridiem === ' ' || meridiem === '') {
                return hour + 12;
            } else {
                return hour >= 11 ? hour : hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return ' ';
            } else if (hm < 900) {
                return '';
            } else if (hm < 1130) {
                return ' ';
            } else if (hm < 1230) {
                return '';
            } else if (hm < 1800) {
                return ' ';
            } else {
                return '';
            }
        },
        calendar: {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: '[] dddd [] LT',
            lastDay: '[] LT',
            lastWeek: '[] dddd [] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s ',
            past: '%s ',
            s: ' ',
            ss: '%d ',
            m: ' ',
            mm: '%d ',
            h: ' ',
            hh: '%d ',
            d: ' ',
            dd: '%d ',
            M: ' ',
            MM: '%d ',
            y: ' ',
            yy: '%d '
        },

        dayOfMonthOrdinalParse: /\d{1,2}(-|-|-)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '-';
                case 'w':
                case 'W':
                    return number + '-';
                default:
                    return number;
            }
        },
        preparse: function (string) {
            return string.replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/,/g, '');
        },
        week: {
            // GB/T 7408-1994ISO 8601:1988
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ugCn;

})));


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'ss': withoutSuffix ? '__' : '__',
            'mm': withoutSuffix ? '__' : '__',
            'hh': withoutSuffix ? '__' : '__',
            'dd': '__',
            'MM': '__',
            'yy': '__'
        };
        if (key === 'm') {
            return withoutSuffix ? '' : '';
        }
        else if (key === 'h') {
            return withoutSuffix ? '' : '';
        }
        else {
            return number + ' ' + plural(format[key], +number);
        }
    }
    function weekdaysCaseReplace(m, format) {
        var weekdays = {
            'nominative': '______'.split('_'),
            'accusative': '______'.split('_'),
            'genitive': '______'.split('_')
        };

        if (m === true) {
            return weekdays['nominative'].slice(1, 7).concat(weekdays['nominative'].slice(0, 1));
        }
        if (!m) {
            return weekdays['nominative'];
        }

        var nounCase = (/(\[[]\]) ?dddd/).test(format) ?
            'accusative' :
            ((/\[?(?:|)? ?\] ?dddd/).test(format) ?
                'genitive' :
                'nominative');
        return weekdays[nounCase][m.day()];
    }
    function processHoursFunction(str) {
        return function () {
            return str + '' + (this.hours() === 11 ? '' : '') + '] LT';
        };
    }

    var uk = moment.defineLocale('uk', {
        months : {
            'format': '___________'.split('_'),
            'standalone': '___________'.split('_')
        },
        monthsShort : '___________'.split('_'),
        weekdays : weekdaysCaseReplace,
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY .',
            LLL : 'D MMMM YYYY ., HH:mm',
            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
        },
        calendar : {
            sameDay: processHoursFunction('[ '),
            nextDay: processHoursFunction('[ '),
            lastDay: processHoursFunction('[ '),
            nextWeek: processHoursFunction('[] dddd ['),
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 5:
                    case 6:
                        return processHoursFunction('[] dddd [').call(this);
                    case 1:
                    case 2:
                    case 4:
                        return processHoursFunction('[] dddd [').call(this);
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            ss : relativeTimeWithPlural,
            m : relativeTimeWithPlural,
            mm : relativeTimeWithPlural,
            h : '',
            hh : relativeTimeWithPlural,
            d : '',
            dd : relativeTimeWithPlural,
            M : '',
            MM : relativeTimeWithPlural,
            y : '',
            yy : relativeTimeWithPlural
        },
        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
        meridiemParse: /|||/,
        isPM: function (input) {
            return /^(|)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return '';
            } else {
                return '';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'M':
                case 'd':
                case 'DDD':
                case 'w':
                case 'W':
                    return number + '-';
                case 'D':
                    return number + '-';
                default:
                    return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return uk;

})));


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var months = [
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        ''
    ];
    var days = [
        '',
        '',
        '',
        '',
        '',
        '',
        ''
    ];

    var ur = moment.defineLocale('ur', {
        months : months,
        monthsShort : months,
        weekdays : days,
        weekdaysShort : days,
        weekdaysMin : days,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM : function (input) {
            return '' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            }
            return '';
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[  ] LT',
            lastWeek : '[] dddd [] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/,/g, '');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return ur;

})));


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var uz = moment.defineLocale('uz', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'D MMMM YYYY, dddd HH:mm'
        },
        calendar : {
            sameDay : '[ ] LT []',
            nextDay : '[] LT []',
            nextWeek : 'dddd [ ] LT []',
            lastDay : '[ ] LT []',
            lastWeek : '[] dddd [ ] LT []',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s ',
            past : '  %s ',
            s : '',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return uz;

})));


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var uzLatn = moment.defineLocale('uz-latn', {
        months : 'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split('_'),
        monthsShort : 'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),
        weekdays : 'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split('_'),
        weekdaysShort : 'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),
        weekdaysMin : 'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'D MMMM YYYY, dddd HH:mm'
        },
        calendar : {
            sameDay : '[Bugun soat] LT [da]',
            nextDay : '[Ertaga] LT [da]',
            nextWeek : 'dddd [kuni soat] LT [da]',
            lastDay : '[Kecha soat] LT [da]',
            lastWeek : '[O\'tgan] dddd [kuni soat] LT [da]',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'Yaqin %s ichida',
            past : 'Bir necha %s oldin',
            s : 'soniya',
            ss : '%d soniya',
            m : 'bir daqiqa',
            mm : '%d daqiqa',
            h : 'bir soat',
            hh : '%d soat',
            d : 'bir kun',
            dd : '%d kun',
            M : 'bir oy',
            MM : '%d oy',
            y : 'bir yil',
            yy : '%d yil'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return uzLatn;

})));


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var vi = moment.defineLocale('vi', {
        months : 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),
        monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
        monthsParseExact : true,
        weekdays : 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),
        weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysParseExact : true,
        meridiemParse: /sa|ch/i,
        isPM : function (input) {
            return /^ch$/i.test(input);
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? 'sa' : 'SA';
            } else {
                return isLower ? 'ch' : 'CH';
            }
        },
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM [nm] YYYY',
            LLL : 'D MMMM [nm] YYYY HH:mm',
            LLLL : 'dddd, D MMMM [nm] YYYY HH:mm',
            l : 'DD/M/YYYY',
            ll : 'D MMM YYYY',
            lll : 'D MMM YYYY HH:mm',
            llll : 'ddd, D MMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Hm nay lc] LT',
            nextDay: '[Ngy mai lc] LT',
            nextWeek: 'dddd [tun ti lc] LT',
            lastDay: '[Hm qua lc] LT',
            lastWeek: 'dddd [tun ri lc] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s ti',
            past : '%s trc',
            s : 'vi giy',
            ss : '%d giy' ,
            m : 'mt pht',
            mm : '%d pht',
            h : 'mt gi',
            hh : '%d gi',
            d : 'mt ngy',
            dd : '%d ngy',
            M : 'mt thng',
            MM : '%d thng',
            y : 'mt nm',
            yy : '%d nm'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal : function (number) {
            return number;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return vi;

})));


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var xPseudo = moment.defineLocale('x-pseudo', {
        months : 'J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr'.split('_'),
        monthsShort : 'J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc'.split('_'),
        monthsParseExact : true,
        weekdays : 'S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d'.split('_'),
        weekdaysShort : 'S~_~M_~T_~Wd_~Th_~Fr_~St'.split('_'),
        weekdaysMin : 'S~_M~_T_~W_T~h_Fr~_S'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[T~d~ t] LT',
            nextDay : '[T~m~rr~w t] LT',
            nextWeek : 'dddd [t] LT',
            lastDay : '[~st~rd~ t] LT',
            lastWeek : '[L~st] dddd [t] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '~ %s',
            past : '%s ~g',
            s : ' ~fw ~sc~ds',
            ss : '%d s~c~ds',
            m : ' ~m~t',
            mm : '%d m~~ts',
            h : '~ h~r',
            hh : '%d h~rs',
            d : ' ~d',
            dd : '%d d~s',
            M : ' ~m~th',
            MM : '%d m~t~hs',
            y : ' ~r',
            yy : '%d ~rs'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return xPseudo;

})));


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var yo = moment.defineLocale('yo', {
        months : 'Sr_Erele_rna_Igbe_Ebibi_Okudu_Agmo_Ogun_Owewe_wara_Belu_p'.split('_'),
        monthsShort : 'Sr_Erl_rn_Igb_Ebi_Oku_Ag_Ogu_Owe_wa_Bel_p'.split('_'),
        weekdays : 'Aiku_Aje_Isgun_jru_jb_ti_Abamta'.split('_'),
        weekdaysShort : 'Aik_Aje_Is_jr_jb_ti_Aba'.split('_'),
        weekdaysMin : 'Ai_Aj_Is_r_b_t_Ab'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Oni ni] LT',
            nextDay : '[la ni] LT',
            nextWeek : 'dddd [s ton\'b] [ni] LT',
            lastDay : '[Ana ni] LT',
            lastWeek : 'dddd [s tol] [ni] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'ni %s',
            past : '%s kja',
            s : 'isju aaya die',
            ss :'aaya %d',
            m : 'isju kan',
            mm : 'isju %d',
            h : 'wakati kan',
            hh : 'wakati %d',
            d : 'j kan',
            dd : 'j %d',
            M : 'osu kan',
            MM : 'osu %d',
            y : 'dun kan',
            yy : 'dun %d'
        },
        dayOfMonthOrdinalParse : /j\s\d{1,2}/,
        ordinal : 'j %d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return yo;

})));


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var zhCn = moment.defineLocale('zh-cn', {
        months : '___________'.split('_'),
        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY/MM/DD',
            LL : 'YYYYMD',
            LLL : 'YYYYMDAhmm',
            LLLL : 'YYYYMDddddAhmm',
            l : 'YYYY/M/D',
            ll : 'YYYYMD',
            lll : 'YYYYMD HH:mm',
            llll : 'YYYYMDdddd HH:mm'
        },
        meridiemParse: /|||||/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '' || meridiem === '' ||
                    meridiem === '') {
                return hour;
            } else if (meridiem === '' || meridiem === '') {
                return hour + 12;
            } else {
                // ''
                return hour >= 11 ? hour : hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '';
            } else if (hm < 900) {
                return '';
            } else if (hm < 1130) {
                return '';
            } else if (hm < 1230) {
                return '';
            } else if (hm < 1800) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[]LT',
            nextDay : '[]LT',
            nextWeek : '[]ddddLT',
            lastDay : '[]LT',
            lastWeek : '[]ddddLT',
            sameElse : 'L'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(||)/,
        ordinal : function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '';
                case 'M':
                    return number + '';
                case 'w':
                case 'W':
                    return number + '';
                default:
                    return number;
            }
        },
        relativeTime : {
            future : '%s',
            past : '%s',
            s : '',
            ss : '%d ',
            m : '1 ',
            mm : '%d ',
            h : '1 ',
            hh : '%d ',
            d : '1 ',
            dd : '%d ',
            M : '1 ',
            MM : '%d ',
            y : '1 ',
            yy : '%d '
        },
        week : {
            // GB/T 7408-1994ISO 8601:1988
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return zhCn;

})));


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var zhHk = moment.defineLocale('zh-hk', {
        months : '___________'.split('_'),
        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY/MM/DD',
            LL : 'YYYYMD',
            LLL : 'YYYYMD HH:mm',
            LLLL : 'YYYYMDdddd HH:mm',
            l : 'YYYY/M/D',
            ll : 'YYYYMD',
            lll : 'YYYYMD HH:mm',
            llll : 'YYYYMDdddd HH:mm'
        },
        meridiemParse: /|||||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '' || meridiem === '' || meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === '' || meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '';
            } else if (hm < 900) {
                return '';
            } else if (hm < 1130) {
                return '';
            } else if (hm < 1230) {
                return '';
            } else if (hm < 1800) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[]LT',
            nextDay : '[]LT',
            nextWeek : '[]ddddLT',
            lastDay : '[]LT',
            lastWeek : '[]ddddLT',
            sameElse : 'L'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(||)/,
        ordinal : function (number, period) {
            switch (period) {
                case 'd' :
                case 'D' :
                case 'DDD' :
                    return number + '';
                case 'M' :
                    return number + '';
                case 'w' :
                case 'W' :
                    return number + '';
                default :
                    return number;
            }
        },
        relativeTime : {
            future : '%s',
            past : '%s',
            s : '',
            ss : '%d ',
            m : '1 ',
            mm : '%d ',
            h : '1 ',
            hh : '%d ',
            d : '1 ',
            dd : '%d ',
            M : '1 ',
            MM : '%d ',
            y : '1 ',
            yy : '%d '
        }
    });

    return zhHk;

})));


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var zhTw = moment.defineLocale('zh-tw', {
        months : '___________'.split('_'),
        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY/MM/DD',
            LL : 'YYYYMD',
            LLL : 'YYYYMD HH:mm',
            LLLL : 'YYYYMDdddd HH:mm',
            l : 'YYYY/M/D',
            ll : 'YYYYMD',
            lll : 'YYYYMD HH:mm',
            llll : 'YYYYMDdddd HH:mm'
        },
        meridiemParse: /|||||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '' || meridiem === '' || meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === '' || meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '';
            } else if (hm < 900) {
                return '';
            } else if (hm < 1130) {
                return '';
            } else if (hm < 1230) {
                return '';
            } else if (hm < 1800) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : '[]dddd LT',
            lastDay : '[] LT',
            lastWeek : '[]dddd LT',
            sameElse : 'L'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(||)/,
        ordinal : function (number, period) {
            switch (period) {
                case 'd' :
                case 'D' :
                case 'DDD' :
                    return number + '';
                case 'M' :
                    return number + '';
                case 'w' :
                case 'W' :
                    return number + '';
                default :
                    return number;
            }
        },
        relativeTime : {
            future : '%s',
            past : '%s',
            s : '',
            ss : '%d ',
            m : '1 ',
            mm : '%d ',
            h : '1 ',
            hh : '%d ',
            d : '1 ',
            dd : '%d ',
            M : '1 ',
            MM : '%d ',
            y : '1 ',
            yy : '%d '
        }
    });

    return zhTw;

})));


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArray = Array.isArray;
var keyList = Object.keys;
var hasProp = Object.prototype.hasOwnProperty;

module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    var arrA = isArray(a)
      , arrB = isArray(b)
      , i
      , length
      , key;

    if (arrA && arrB) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }

    if (arrA != arrB) return false;

    var dateA = a instanceof Date
      , dateB = b instanceof Date;
    if (dateA != dateB) return false;
    if (dateA && dateB) return a.getTime() == b.getTime();

    var regexpA = a instanceof RegExp
      , regexpB = b instanceof RegExp;
    if (regexpA != regexpB) return false;
    if (regexpA && regexpB) return a.toString() == b.toString();

    var keys = keyList(a);
    length = keys.length;

    if (length !== keyList(b).length)
      return false;

    for (i = length; i-- !== 0;)
      if (!hasProp.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      key = keys[i];
      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  return a!==a && b!==b;
};


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = asyncMixin;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _coreAsync = __webpack_require__(5);

var _core = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NON_INDEX = -1;

function asyncMixin(_chart) {
  var events = ["dataFetch", "dataError"];
  var _listeners = _d2.default.dispatch.apply(_d2.default, events);
  var _on = _chart.on.bind(_chart);

  _chart.dataCache = null;
  _chart.queryId = 0;

  var _dataAsync = function _dataAsync(group, callback) {
    group.allAsync(callback);
  };

  _chart.on = function (event, listener) {
    var baseEvent = event.includes(".") ? event.slice(0, event.indexOf(".")) : event;
    if (events.indexOf(baseEvent) === NON_INDEX) {
      _on(event, listener);
    } else {
      _listeners.on(event, listener);
    }
    return _chart;
  };

  _chart._invokeDataFetchListener = function () {
    _listeners.dataFetch(_chart);
  };

  _chart._invokeDataErrorListener = function (error) {
    _listeners.dataError(_chart, error);
  };

  _chart.dataAsync = function (callback) {
    return _dataAsync.call(_chart, _chart.group(), callback);
  };

  _chart.getDataAsync = function () {
    return _dataAsync;
  };

  _chart.setDataAsync = function (callback) {
    _dataAsync = callback;
    _chart.expireCache();
    return _chart;
  };

  _chart.data(function (group) {
    if (_chart.dataCache !== null) {
      // eslint-disable-line no-negated-condition
      return _chart.dataCache;
    } else {
      console.log("Warning: Deprecate sync method .data()"); // eslint-disable-line no-console
      return group.all();
    }
  });

  _chart.renderAsync = function (queryGroupId, queryCount) {
    if ((0, _core.refreshDisabled)()) {
      return Promise.resolve();
    }

    if (_chart.hasOwnProperty("setSample")) {
      _chart.setSample();
    }
    var id = _chart.queryId++;

    return new Promise(function (resolve, reject) {
      var renderCallback = function renderCallback(error, data) {
        if (error) {
          reject(error);
        } else {
          resolve(data);
        }
      };

      var dataCallback = function dataCallback(error, data) {
        if (error) {
          _chart._invokeDataErrorListener(error);
          (0, _coreAsync.resetRenderStack)();
          reject(error);
        } else {
          _chart.render(id, queryGroupId, queryCount, data, renderCallback);
        }
      };
      _chart._invokeDataFetchListener();
      return _chart.dataAsync(dataCallback);
    });
  };

  var _chartRedrawEnabled = true;
  var chartRedrawEnabled = function chartRedrawEnabled() {
    return _chartRedrawEnabled;
  };

  _chart.enableChartRedraw = function () {
    _chartRedrawEnabled = true;
  };
  _chart.disableChartRedraw = function () {
    _chartRedrawEnabled = false;
  };

  _chart.redrawAsync = function (queryGroupId, queryCount) {
    if ((0, _core.refreshDisabled)() || !chartRedrawEnabled()) {
      return Promise.resolve();
    }

    if (_chart.hasOwnProperty("setSample")) {
      _chart.setSample();
    }
    var id = _chart.queryId++;

    return new Promise(function (resolve, reject) {
      var redrawCallback = function redrawCallback(error, data) {
        if (error) {
          reject(error);
        } else {
          resolve(data);
        }
      };

      var dataCallback = function dataCallback(error, data) {
        if (error) {
          _chart._invokeDataErrorListener(error);
          (0, _coreAsync.resetRedrawStack)();
          reject(error);
        } else {
          _chart.redraw(id, queryGroupId, queryCount, data, redrawCallback);
        }
      };
      _chart._invokeDataFetchListener();
      _chart.dataAsync(dataCallback);
    });
  };

  _chart.redrawGroup = function () {
    function logRedrawGroupError(e) {
      if ((0, _core.logging)()) {
        console.log("Redraw Group Error", e); // eslint-disable-line no-console
      }
    }

    if (_chart.commitHandler()) {
      _chart.commitHandler()(false, function (error) {
        if (error) {
          logRedrawGroupError(error);
        } else {
          (0, _coreAsync.redrawAllAsync)(_chart.chartGroup()).catch(function (e) {
            return logRedrawGroupError(e);
          });
        }
      });
    } else {
      (0, _coreAsync.redrawAllAsync)(_chart.chartGroup()).catch(function (e) {
        return logRedrawGroupError(e);
      });
    }
    return _chart;
  };

  return _chart;
}

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.multipleKeysAccessorForStack = exports.multipleKeysAccessorForCap = undefined;

var _formattingHelpers = __webpack_require__(10);

var INDEX_NONE = -1;
var identity = function identity(a) {
  return a;
};

function normalize(data) {
  if ((0, _formattingHelpers.isArrayOfObjects)(data)) {
    return data.map(function (d) {
      return d.value;
    });
  } else {
    return data;
  }
}

function getMinOfRange(d) {
  if (Array.isArray(d)) {
    return d[0];
  } else {
    return d;
  }
}

function createAccessor() {
  var transform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;

  return function multipleKeyAccessor(d) {
    var filteredKeys = [];
    for (var key in d) {
      if (d.hasOwnProperty(key) && key.indexOf("key") > INDEX_NONE) {
        filteredKeys.push(transform(normalize(d[key])));
      }
    }
    if (filteredKeys.length === 1) {
      filteredKeys = filteredKeys[0];
    }
    return filteredKeys;
  };
}

var multipleKeysAccessorForCap = exports.multipleKeysAccessorForCap = createAccessor();
var multipleKeysAccessorForStack = exports.multipleKeysAccessorForStack = createAccessor(getMinOfRange);

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = multipleKeysLabelMixin;

var _formattingHelpers = __webpack_require__(10);

var INDEX_NONE = -1;
var SHOULD_RENDER_LABELS = true;

function format(_value, _key, numberFormatter, dateFormatter) {
  var customFormatter = null;

  var key = _key;
  var value = _value;
  var isExtract = false;

  if (Array.isArray(_value) && _value[0]) {
    value = _value[0].value || _value[0];
    if (_value[0].isExtract) {
      key = null;
      isExtract = true;
    }
  }

  if (dateFormatter && value instanceof Date) {
    customFormatter = dateFormatter;
  } else if (numberFormatter && typeof value === "number") {
    customFormatter = numberFormatter;
  }

  return !isExtract && customFormatter && customFormatter(value, key) || (0, _formattingHelpers.formatDataValue)(_value);
}

function multipleKeysLabelMixin(_chart) {
  function label(d) {
    var numberFormatter = _chart && _chart.valueFormatter();
    var dateFormatter = _chart && _chart.dateFormatter();
    var dimensionNames = _chart.dimension().getDimensionName();

    if (dimensionNames.length === 1) {
      return format(d.key0, dimensionNames[0], numberFormatter, dateFormatter);
    }

    var keysStr = [];
    var i = 0;
    for (var key in d) {
      if (d.hasOwnProperty(key) && key.indexOf("key") > INDEX_NONE) {
        var formatted = format(d[key], dimensionNames[i], numberFormatter, dateFormatter);
        keysStr.push(formatted);
      }
      i++;
    }
    return keysStr.join(" / ");
  }

  _chart.label(label, SHOULD_RENDER_LABELS);
  return _chart;
}

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setCursorSpinner = exports.areAnySpinnersShowing = undefined;
exports.default = spinnerMixin;

var _core = __webpack_require__(3);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _dcConstants = __webpack_require__(249);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var areAnySpinnersShowing = exports.areAnySpinnersShowing = function areAnySpinnersShowing() {
  return _core.chartRegistry.list().some(function (chart) {
    return chart.isSpinnerShowing();
  });
};
var setCursorSpinner = exports.setCursorSpinner = function setCursorSpinner() {
  return _d2.default.select("body").classed("waiting", areAnySpinnersShowing());
};

function spinnerMixin(_chart) {
  var _spinnerDelay = _dcConstants.SPINNER_DELAY;
  var _spinnerTimeout = null;
  var _spinnerIsVisible = false;

  _chart.isSpinnerShowing = function () {
    return _spinnerIsVisible;
  };

  var _dataFetchRequestCallback = function _dataFetchRequestCallback() {
    var anchor = _chart.anchor();
    var selectedAnchor = _d2.default.select(anchor);

    selectedAnchor.classed("chart-loading-overlay", true);

    var loadingWidget = selectedAnchor.append("div").classed("loading-widget-dc", true);

    loadingWidget.append("div").classed("main-loading-icon", true);
  };

  var _dataFetchSuccessfulCallback = function _dataFetchSuccessfulCallback() {
    var anchor = _chart.anchor();

    var selectedAnchor = _d2.default.select(anchor);

    selectedAnchor.classed("chart-loading-overlay", false);

    selectedAnchor.selectAll(function () {
      return [].concat(_toConsumableArray(this.childNodes)).filter(function (node) {
        return node.className === "loading-widget-dc";
      });
    }).remove();

    _d2.default.select("body").classed("waiting", areAnySpinnersShowing());
  };

  _chart.spinnerDelay = function (delay) {
    if (!arguments.length) {
      return _spinnerDelay;
    }

    _spinnerDelay = delay;
    return _chart;
  };

  _chart.dataFetchSuccessfulCallback = function (func) {
    if (!arguments.length) {
      return _dataFetchSuccessfulCallback;
    }

    _dataFetchSuccessfulCallback = func;
    return _chart;
  };

  _chart.dataFetchRequestCallback = function (func) {
    if (!arguments.length) {
      return _dataFetchRequestCallback;
    }

    _dataFetchRequestCallback = func;
    return _chart;
  };

  function initSpinner() {
    if (_spinnerTimeout) {
      window.clearTimeout(_spinnerTimeout);
    }

    _spinnerTimeout = window.setTimeout(function () {
      _spinnerIsVisible = true;
      _dataFetchRequestCallback();
      setCursorSpinner();
    }, _spinnerDelay);
  }

  function tearDownSpinner() {
    if (_spinnerIsVisible) {
      _spinnerIsVisible = false;
      _dataFetchSuccessfulCallback();
      setCursorSpinner();
    }
    window.clearTimeout(_spinnerTimeout);
  }

  _chart.on("dataFetch.spinner", initSpinner);

  _chart.on("postRedraw.spinner", tearDownSpinner);
  _chart.on("postRender.spinner", tearDownSpinner);

  _chart.on("dataError.spinner", function () {
    console.log(_chart.__dcFlag__, ": error");

    tearDownSpinner();
  });

  return _chart;
}

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = elasticDimensionMixin;

var _ramda = __webpack_require__(251);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function elasticDimensionMixin(_chart) {
  var NON_INDEX = -1;
  var _binEvents = ["updateBinBounds"];
  var _listeners = _d2.default.dispatch.apply(_d2.default, _binEvents);
  var _on = _chart.on.bind(_chart);
  var _dataAsync = _chart.getDataAsync();

  _chart.on = function (event, listener) {
    var baseEvent = event.includes(".") ? event.slice(0, event.indexOf(".")) : event;
    if (_binEvents.indexOf(baseEvent) === NON_INDEX) {
      _on(event, listener);
    } else {
      _listeners.on(event, listener);
    }
    return _chart;
  };

  _chart._invokeBinBoundsListener = function (binBounds) {
    if (typeof binBounds !== "undefined") {
      _listeners.updateBinBounds(_chart, binBounds);
    }
  };

  function updateBinRange(group, callback) {
    if (!_chart.elasticX() || !_chart.binParams()[0] || _chart.rangeChart() && _chart.rangeChart().filter()) {
      return _dataAsync(group, callback);
    }

    group.getMinMaxWithFilters().then(function (bounds) {
      if (!bounds) {
        return _dataAsync(group, callback);
      }

      _chart.binParams((0, _ramda.adjust)((0, _ramda.set)((0, _ramda.lensProp)("binBounds"), [bounds.min_val, bounds.max_val]), 0, _chart.binParams()));

      if (_chart.focusChart() && _chart.filter()) {
        _chart.focusChart()._invokeBinBoundsListener([bounds.min_val, bounds.max_val]);
      } else {
        _chart._invokeBinBoundsListener([bounds.min_val, bounds.max_val]);
      }
      _dataAsync(group, callback);
    }).catch(function (err) {
      return callback(err);
    });
  }

  _chart.on("dataFetch.reBin", function () {
    if (_chart.elasticX() && _chart.getDataAsync() !== updateBinRange) {
      _dataAsync = _chart.getDataAsync();
      _chart.setDataAsync(updateBinRange);
    }
  });

  return _chart;
}

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.heatMapKeyAccessorNoFormat = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.heatMapKeyAccessor = heatMapKeyAccessor;
exports.heatMapValueAccesor = heatMapValueAccesor;
exports.heatMapValueAccesorNoFormat = heatMapValueAccesorNoFormat;
exports.heatMapRowsLabel = heatMapRowsLabel;
exports.heatMapColsLabel = heatMapColsLabel;
exports.yAxisDataIsNonNumerical = yAxisDataIsNonNumerical;
exports.xAxisDataIsNonNumerical = xAxisDataIsNonNumerical;
exports.default = heatMap;

var _formattingHelpers = __webpack_require__(10);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _colorMixin = __webpack_require__(12);

var _colorMixin2 = _interopRequireDefault(_colorMixin);

var _marginMixin = __webpack_require__(18);

var _marginMixin2 = _interopRequireDefault(_marginMixin);

var _events = __webpack_require__(15);

var _core = __webpack_require__(3);

var _utils = __webpack_require__(4);

var _filters = __webpack_require__(21);

var _coordinateGridMixin = __webpack_require__(14);

var _coordinateGridMixin2 = _interopRequireDefault(_coordinateGridMixin);

var _binningHelpers = __webpack_require__(22);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** ***************************************************************************
 * OVERRIDE: dc.heatMap                                                       *
 * ***************************************************************************/
/**
 * A heat map is matrix that represents the values of two dimensions of data using colors.
 * @name heatMap
 * @memberof dc
 * @mixes dc.colorMixin
 * @mixes dc.marginMixin
 * @mixes dc.baseMixin
 * @example
 * // create a heat map under #chart-container1 element using the default global chart group
 * var heatMap1 = dc.heatMap('#chart-container1');
 * // create a heat map under #chart-container2 element using chart group A
 * var heatMap2 = dc.heatMap('#chart-container2', 'chartGroupA');
 * @param {String|node|d3.selection} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector} specifying
 * a dom block element such as a div; or a dom element or d3 selection.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
 * Interaction with a chart will only trigger events and redraws within the chart's group.
 * @return {dc.heatMap}
 */

var MAX_LABEL_WIDTH = 72;
var CHAR_WIDTH = 5;
var MIN_AXIS_HEIGHT = 52;

function heatMapKeyAccessor(_ref) {
  var key0 = _ref.key0;

  if (Array.isArray(key0)) {
    var key0Val = (0, _formattingHelpers.isArrayOfObjects)(key0) ? key0[0].value : key0[0];
    var value = key0Val instanceof Date ? (0, _formattingHelpers.formatDataValue)(key0Val) : key0Val;
    this.colsMap.set(value, key0);
    return value;
  } else {
    return key0;
  }
}

// TODO - remove me. Trying to get TravisCI to work
var heatMapKeyAccessorNoFormat = exports.heatMapKeyAccessorNoFormat = function heatMapKeyAccessorNoFormat(_ref2) {
  var key0 = _ref2.key0;
  var forceMax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (Array.isArray(key0)) {
    var keyIndex = forceMax && key0[1] ? 1 : 0;
    var key0Val = (0, _formattingHelpers.isArrayOfObjects)(key0) ? key0[keyIndex].value : key0[keyIndex];
    this.colsMap.set(key0Val, key0);
    return key0Val;
  } else {
    return key0;
  }
};

function heatMapValueAccesor(_ref3) {
  var key1 = _ref3.key1;

  if (Array.isArray(key1)) {
    var key1Val = (0, _formattingHelpers.isArrayOfObjects)(key1) ? key1[0].value : key1[0];
    var value = key1Val instanceof Date ? (0, _formattingHelpers.formatDataValue)(key1Val) : key1Val;
    this.rowsMap.set(value, key1);
    return value;
  } else {
    return key1;
  }
}

function heatMapValueAccesorNoFormat(_ref4) {
  var key1 = _ref4.key1;
  var forceMax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (Array.isArray(key1)) {
    var valueIndex = forceMax && key1[1] ? 1 : 0;
    var key1Val = (0, _formattingHelpers.isArrayOfObjects)(key1) ? key1[valueIndex].value : key1[valueIndex];
    this.rowsMap.set(key1Val, key1);
    return key1Val;
  } else {
    return key1;
  }
}

function heatMapRowsLabel(key) {
  // If the data is binned, this will be an array
  var value = this.rowsMap.get(key) || key;

  var customDateFormatter = this.dateFormatter();

  // Possibly dead code, `key` should always be a string or number
  if (customDateFormatter && key && key instanceof Date) {
    if (Array.isArray(value) && value[0]) {
      value = value[0].value || value[0];
    }
  }

  // For binned data:
  // customDateFormatter is set to `autoFormatter` (mapd3), which processes raw values in an array
  // Whereas formatDataValue passes the data to `formatTimeBinValue`, which expects an array
  // of objects with additional information (like timeBin info)
  var rawValues = Array.isArray(value) ? value.map(function (v) {
    return v.value;
  }) : null;

  return customDateFormatter && customDateFormatter(rawValues || value, this.yAxisLabel()) || (0, _formattingHelpers.formatDataValue)(value);
}

function heatMapColsLabel(key) {
  // If the data is binned, this will be an array
  var value = this.colsMap.get(key) || key;

  var customDateFormatter = this.dateFormatter();

  // Possibly dead code, `key` should always be a string or number
  if (customDateFormatter && key && key instanceof Date) {
    if (Array.isArray(value) && value[0]) {
      value = value[0].value || value[0];
    }
  }

  // For binned data:
  // customDateFormatter is set to `autoFormatter` (mapd3), which processes raw values in an array
  // Whereas formatDataValue passes the data to `formatTimeBinValue`, which expects an array
  // of objects with additional information (like timeBin info)
  var rawValues = Array.isArray(value) ? value.map(function (v) {
    return v.value;
  }) : null;

  return customDateFormatter && customDateFormatter(rawValues || value, this.xAxisLabel()) || (0, _formattingHelpers.formatDataValue)(value);
}

function yAxisDataIsNonNumerical(datum) {
  var _ref5 = datum || {},
      key1 = _ref5.key1;

  var value = Array.isArray(key1) ? key1[0] : key1;
  return typeof value !== "number";
}

function xAxisDataIsNonNumerical(datum) {
  var _ref6 = datum || {},
      key0 = _ref6.key0;

  var value = Array.isArray(key0) ? key0[0] : key0;
  return typeof value !== "number";
}

function heatMap(parent, chartGroup) {
  var INTERVAL_LABELS = {
    // ISO DOW starts at 1, set null at 0 index
    DAY_OF_WEEK: [null, "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],

    // Months start at 1, set null at 0 index
    MONTH: [null, "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],

    HOUR_OF_DAY: ["12AM", "1AM", "2AM", "3AM", "4AM", "5AM", "6AM", "7AM", "8AM", "9AM", "10AM", "11AM", "12PM", "1PM", "2PM", "3PM", "4PM", "5PM", "6PM", "7PM", "8PM", "9PM", "10PM", "11PM"]
  };

  var DEFAULT_BORDER_RADIUS = 6.75;

  var _chartBody = void 0;

  var _cols = void 0;
  var _rows = void 0;

  var _colOrdering = _utils.utils.nullsFirst(_utils.utils.compareDates(_d2.default.ascending));
  var _rowOrdering = _utils.utils.nullsFirst(_utils.utils.compareDates(_d2.default.ascending));
  var _colScale = _d2.default.scale.ordinal();
  var _rowScale = _d2.default.scale.ordinal();

  var _xBorderRadius = DEFAULT_BORDER_RADIUS;
  var _yBorderRadius = DEFAULT_BORDER_RADIUS;

  /* OVERRIDE EXTEND ----------------------------------------------------------*/
  var _yLabel = void 0;
  var _xLabel = void 0;
  var _hasBeenRendered = false;
  var _minBoxSize = 16;
  var _scrollPos = { top: null, left: 0 };
  var _dockedAxes = void 0;
  var _dockedAxesSize = { left: 48, bottom: 56 };
  var xAxisInputs = void 0;
  var yAxisInputs = void 0;
  /* --------------------------------------------------------------------------*/

  var _xBorderRadius = DEFAULT_BORDER_RADIUS;
  var _yBorderRadius = DEFAULT_BORDER_RADIUS;

  var _chart = (0, _colorMixin2.default)((0, _marginMixin2.default)((0, _coordinateGridMixin2.default)({})));
  _chart.isHeatMap = true;
  _chart._mandatoryAttributes(["group"]);
  _chart.title(_chart.colorAccessor());

  var _colsLabel = function _colsLabel(d) {
    return d;
  };
  var _rowsLabel = function _rowsLabel(d) {
    return d;
  };

  _chart.dockedAxesSize = function (_) {
    if (!arguments.length) {
      return _dockedAxesSize;
    }
    _dockedAxesSize = _;
    return _chart;
  };

  /**
   * Set or get the column label function. The chart class uses this function to render
   * column labels on the X axis. It is passed the column name.
   * @name colsLabel
   * @memberof dc.heatMap
   * @instance
   * @example
   * // the default label function just returns the name
   * chart.colsLabel(function(d) { return d; });
   * @param  {Function} [labelFunction=function(d) { return d; }]
   * @return {Function}
   * @return {dc.heatMap}
   */
  _chart.colsLabel = function (labelFunction) {
    if (!arguments.length) {
      return _colsLabel;
    }
    _colsLabel = labelFunction;
    return _chart;
  };

  /**
   * Set or get the row label function. The chart class uses this function to render
   * row labels on the Y axis. It is passed the row name.
   * @name rowsLabel
   * @memberof dc.heatMap
   * @instance
   * @example
   * // the default label function just returns the name
   * chart.rowsLabel(function(d) { return d; });
   * @param  {Function} [labelFunction=function(d) { return d; }]
   * @return {Function}
   * @return {dc.heatMap}
   */
  _chart.rowsLabel = function (labelFunction) {
    if (!arguments.length) {
      return _rowsLabel;
    }
    _rowsLabel = labelFunction;
    return _chart;
  };

  /* OVERRIDE EXTEND ----------------------------------------------------------*/
  _chart.xAxisLabel = function (xLabel) {
    if (!arguments.length) {
      return _xLabel;
    }
    _xLabel = xLabel;
    return _chart;
  };

  _chart.yAxisLabel = function (yLabel) {
    if (!arguments.length) {
      return _yLabel;
    }
    _yLabel = yLabel;
    return _chart;
  };

  var _xAxisOnClick = function _xAxisOnClick(d) {
    filterAxis(0, d);
  };

  var _yAxisOnClick = function _yAxisOnClick(d) {
    filterAxis(1, d);
  };
  /* --------------------------------------------------------------------------*/

  var _boxOnClick = function _boxOnClick(d) {
    /* OVERRIDE -----------------------------------------------------------------*/
    var filter = [d.key0, d.key1];
    /* --------------------------------------------------------------------------*/
    _chart.handleFilterClick(_d2.default.event, filter);
  };

  var showInputs = function showInputs(inputs) {
    return function () {
      return inputs.style("opacity", 1);
    };
  };
  var hideInputs = function hideInputs(inputs) {
    return function () {
      return inputs.style("opacity", null);
    };
  };

  function filterAxis(axis, value) {
    var axisVal = value instanceof Date ? (0, _formattingHelpers.formatDataValue)(value) : value;
    var cellsOnAxis = _chart.selectAll(".box-group").filter(function (d) {
      return (
        /* OVERRIDE ---------------------------------------------------------------*/
        (axis === 1 ? _chart.valueAccessor()(d) : _chart.keyAccessor()(d)) === axisVal
      );
    }
    /* --------------------------------------------------------------------------*/
    );

    var unfilteredCellsOnAxis = cellsOnAxis.filter(function (d) {
      return (
        /* OVERRIDE -----------------------------------------------------------------*/
        !_chart.hasFilter([d.key0, d.key1])
      );
    }
    /* --------------------------------------------------------------------------*/
    );
    _events.events.trigger(function () {
      if (unfilteredCellsOnAxis.empty()) {
        cellsOnAxis.each(function (d) {
          /* OVERRIDE -----------------------------------------------------------------*/
          _chart.filter([d.key0, d.key1]);
          /* --------------------------------------------------------------------------*/
        });
      } else {
        unfilteredCellsOnAxis.each(function (d) {
          /* OVERRIDE -----------------------------------------------------------------*/
          _chart.filter([d.key0, d.key1]);
          /* --------------------------------------------------------------------------*/
        });
      }

      _chart.redrawGroup();
    });
  }
  _chart.filter = function (filter, isInverseFilter) {
    if (!arguments.length) {
      return _chart._filter();
    }

    return _chart._filter(_filters.filters.TwoDimensionalFilter(filter), isInverseFilter);
  };

  function uniq(d, i, a) {
    return !i || a[i - 1] !== d;
  }

  /**
   * Gets or sets the values used to create the rows of the heatmap, as an array. By default, all
   * the values will be fetched from the data using the value accessor, and they will be sorted in
   * ascending order.
   * @name rows
   * @memberof dc.heatMap
   * @instance
   * @param  {Array<String|Number>} [rows]
   * @return {Array<String|Number>}
   * @return {dc.heatMap}
   */
  _chart.rows = function (rows) {
    if (arguments.length) {
      _rows = rows;
      return _chart;
    }
    return _rows;
  };

  _chart.rowOrdering = function (_) {
    if (!arguments.length) {
      return _rowOrdering;
    }
    _rowOrdering = _;
    return _chart;
  };

  /**
   * Gets or sets the keys used to create the columns of the heatmap, as an array. By default, all
   * the values will be fetched from the data using the key accessor, and they will be sorted in
   * ascending order.
   * @name cols
   * @memberof dc.heatMap
   * @instance
   * @param  {Array<String|Number>} [cols]
   * @return {Array<String|Number>}
   * @return {dc.heatMap}
   */
  _chart.cols = function (cols) {
    if (arguments.length) {
      _cols = cols;
      return _chart;
    }
    return _cols;
  };

  _chart.colOrdering = function (_) {
    if (!arguments.length) {
      return _colOrdering;
    }
    _colOrdering = _;
    return _chart;
  };

  _chart._doRender = function () {
    _chart.resetSvg();

    _chart.margins(_extends({}, _chart.margins(), { top: 16, right: 16, bottom: 0 }));

    var parent = _chart.svg();
    var g = parent.append("g");
    _chartBody = g.attr("class", "heatmap").attr("transform", "translate(0, 16)");
    /* OVERRIDE -----------------------------------------------------------------*/_chartBody.append("g").attr("class", "box-wrapper");
    _chart._generateG(g, _chartBody);
    _hasBeenRendered = true;
    _dockedAxes = _chart.root().append("div").attr("class", "docked-axis-wrapper");
    /* --------------------------------------------------------------------------*/if (_chart.x()) {
      _chart._prepareXAxis(_chart.g(), true);
    }
    if (_chart.y()) {
      _chart._prepareYAxis(_chart.g());
    }
    return _chart._doRedraw();
  };
  _chart._doRedraw = function () {
    if (!_hasBeenRendered) {
      return _chart._doRender();
    }
    var data = _chart.data(),
        rows = _chart.rows() || data.map(_chart.valueAccessorNoFormat()),
        cols = _chart.cols() || data.map(_chart.keyAccessorNoFormat());

    if (_rowOrdering) {
      _rowOrdering = _chart.shouldSortYAxisDescending(data) ? _utils.utils.nullsLast(_d2.default.descending) : _utils.utils.nullsFirst(_d2.default.ascending);
      rows = rows.sort(_rowOrdering);
    }
    if (_colOrdering) {
      cols = cols.sort(_colOrdering);
    }

    // Apply manual min/max extents if their set.
    var filterMinMax = function filterMinMax(domain) {
      return function (d) {
        return typeof d === "string" || !domain || d >= domain[0] && d <= domain[1] || d === null && _chart.showNullDimensions();
      };
    };

    cols = cols.filter(filterMinMax(_chart.x() && _chart.x().domain())).map(function (d) {
      return d instanceof Date ? (0, _formattingHelpers.formatDataValue)(d) : d;
    });

    rows = rows.filter(filterMinMax(_chart.y() && _chart.y().domain())).map(function (d) {
      return d instanceof Date ? (0, _formattingHelpers.formatDataValue)(d) : d;
    });

    rows = _rowScale.domain(rows);
    cols = _colScale.domain(cols);
    _chart.dockedAxesSize(_chart.getAxisSizes(cols.domain(), rows.domain()));
    var rowCount = rows.domain().length,
        colCount = cols.domain().length,
        availWidth = _chart.width() - _dockedAxesSize.left,
        availHeight = _chart.height() - _dockedAxesSize.bottom,
        boxWidth = Math.max((availWidth - _chart.margins().right) / colCount, _minBoxSize),
        boxHeight = Math.max((availHeight - _chart.margins().top) / rowCount, _minBoxSize),
        svgWidth = boxWidth * colCount + _chart.margins().right,
        svgHeight = boxHeight * rowCount + _chart.margins().top;
    cols.rangeBands([0, boxWidth * colCount]);
    rows.rangeBands([boxHeight * rowCount, 0]);
    _chart.svg().attr("width", svgWidth).attr("height", svgHeight);
    var scrollNode = _chart.root().classed("heatmap-scroll", true).select(".svg-wrapper").style("width", _chart.width() - _dockedAxesSize.left + "px").style("height", _chart.height() - _dockedAxesSize.bottom + "px").style("left", _dockedAxesSize.left + "px").on("scroll", function () {
      _scrollPos = {
        top: _d2.default.select(this).node().scrollTop,
        left: _d2.default.select(this).node().scrollLeft
      };
      _chart.root().select(".docked-x-axis").style("left", -_scrollPos.left + "px");
      _chart.root().select(".docked-y-axis").style("top", -_scrollPos.top + "px");
    }).node();
    scrollNode.scrollLeft = _scrollPos.left;
    scrollNode.scrollTop = _scrollPos.top === null && _rowOrdering === _d2.default.ascending ? svgHeight : _scrollPos.top || 0;
    var boxes = _chartBody.select(".box-wrapper").selectAll("g.box-group").data(_chart.data(), function (d, i) {
      return _chart.keyAccessor()(d, i) + "\0" + _chart.valueAccessor()(d, i);
    });
    var gEnter = boxes.enter().append("g").attr("class", "box-group");
    gEnter.append("rect").attr("class", "heat-box").attr("fill", "white").on("mouseenter", showPopup).on("mousemove", positionPopup).on("mouseleave", hidePopup).on("click", _chart.boxOnClick());
    (0, _core.transition)(boxes.select("rect"), _chart.transitionDuration()).attr("x", function (d, i) {
      return cols(_chart.keyAccessor()(d, i));
    }).attr("y", function (d, i) {
      return rows(_chart.valueAccessor()(d, i));
    }).attr("rx", _xBorderRadius).attr("ry", _yBorderRadius).attr("fill", _chart.getColor).attr("width", boxWidth).attr("height", boxHeight);
    boxes.exit().remove();
    var XAxis = _dockedAxes.selectAll(".docked-x-axis");
    if (XAxis.empty()) {
      XAxis = _dockedAxes.append("div").attr("class", "docked-x-axis");
    }
    var colsText = XAxis.style("height", _dockedAxesSize.bottom + "px").html("").selectAll("div.text").data(cols.domain());
    colsText.enter().append("div").attr("class", function () {
      return "text " + (_dockedAxesSize.bottom > 52 ? "rotate-down" : "center");
    }).style("left", function (d) {
      return cols(d) + boxWidth / 2 + _dockedAxesSize.left + "px";
    }).on("click", _chart.xAxisOnClick()).append("span").html(_chart.colsLabel()).attr("title", function (d) {
      // detect if a value is null or has the string "null"
      var val = "" + _chart.colsLabel()(d);
      return val.match(/null/gi) ? "NULL" : val;
    });
    var YAxis = _dockedAxes.selectAll(".docked-y-axis");
    if (YAxis.empty()) {
      YAxis = _dockedAxes.append("div").attr("class", "docked-y-axis");
    }
    var rowsText = YAxis.style("width", _dockedAxesSize.left + "px").style("left", _dockedAxesSize.left + "px").html("").selectAll("div.text").data(rows.domain());
    rowsText.enter().append("div").attr("class", "text").style("top", function (d) {
      return rows(d) + boxHeight / 2 + _chart.margins().top + "px";
    }).on("click", _chart.yAxisOnClick()).html(_chart.rowsLabel()).attr("title", function (d) {
      // detect if a value is null or has the string "null"
      var val = "" + _chart.rowsLabel()(d);
      return val.match(/null/gi) ? "NULL" : val;
    });
    var axesMask = _dockedAxes.selectAll(".axes-mask");
    if (axesMask.empty()) {
      axesMask = _dockedAxes.append("div").attr("class", "axes-mask");
    }
    axesMask.style("width", _dockedAxesSize.left + "px").style("height", _dockedAxesSize.bottom + "px");
    if (_chart.hasFilter()) {
      _chart.selectAll("g.box-group").each(function (d) {
        if (_chart.isSelectedNode(d)) {
          _chart.highlightSelected(this);
        } else {
          _chart.fadeDeselected(this);
        }
      });
    } else {
      _chart.selectAll("g.box-group").each(function () {
        _chart.resetHighlight(this);
      });
    }
    _chart.renderAxisLabels();
    if (_chart.x()) {
      _chart._prepareXAxis(_chart.g(), true);
      xAxisInputs = _chart.root().selectAll(".axis-lock.type-x .axis-input");
    }
    if (_chart.y()) {
      _chart._prepareYAxis(_chart.g());
      yAxisInputs = _chart.root().selectAll(".axis-lock.type-y .axis-input");
    }
    XAxis.on("mouseover", showInputs(xAxisInputs));
    XAxis.on("mouseout", hideInputs(xAxisInputs));
    YAxis.on("mouseover", showInputs(yAxisInputs));
    YAxis.on("mouseout", hideInputs(yAxisInputs));
    return _chart;
  };
  /**
   * Gets or sets the handler that fires when an individual cell is clicked in the heatmap.
   * By default, filtering of the cell will be toggled.
   * @name boxOnClick
   * @memberof dc.heatMap
   * @instance
   * @example
   * // default box on click handler
   * chart.boxOnClick(function (d) {
   *     var filter = d.key;
   *     events.trigger(function () {
   *         _chart.filter(filter);
   *         _chart.redrawGroup();
   *     });
   * });
   * @param  {Function} [handler]
   * @return {Function}
   * @return {dc.heatMap}
   */_chart.boxOnClick = function (handler) {
    if (!arguments.length) {
      return _boxOnClick;
    }
    _boxOnClick = handler;
    return _chart;
  };
  /**
   * Gets or sets the handler that fires when a column tick is clicked in the x axis.
   * By default, if any cells in the column are unselected, the whole column will be selected,
   * otherwise the whole column will be unselected.
   * @name xAxisOnClick
   * @memberof dc.heatMap
   * @instance
   * @param  {Function} [handler]
   * @return {Function}
   * @return {dc.heatMap}
   */_chart.xAxisOnClick = function (handler) {
    if (!arguments.length) {
      return _xAxisOnClick;
    }
    _xAxisOnClick = handler;
    return _chart;
  };
  /**
   * Gets or sets the handler that fires when a row tick is clicked in the y axis.
   * By default, if any cells in the row are unselected, the whole row will be selected,
   * otherwise the whole row will be unselected.
   * @name yAxisOnClick
   * @memberof dc.heatMap
   * @instance
   * @param  {Function} [handler]
   * @return {Function}
   * @return {dc.heatMap}
   */_chart.yAxisOnClick = function (handler) {
    if (!arguments.length) {
      return _yAxisOnClick;
    }
    _yAxisOnClick = handler;
    return _chart;
  };
  /**
   * Gets or sets the X border radius.  Set to 0 to get full rectangles.
   * @name xBorderRadius
   * @memberof dc.heatMap
   * @instance
   * @param  {Number} [xBorderRadius=6.75]
   * @return {Number}
   * @return {dc.heatMap}
   */_chart.xBorderRadius = function (xBorderRadius) {
    if (!arguments.length) {
      return _xBorderRadius;
    }
    _xBorderRadius = xBorderRadius;
    return _chart;
  };
  /* OVERRIDE -----------------------------------------------------------------*/_chart.renderAxisLabels = function () {
    var root = _chart.root();
    var yLabel = root.selectAll(".y-axis-label");
    if (yLabel.empty()) {
      yLabel = root.append("div").attr("class", "y-axis-label").text(_yLabel);
    }
    yLabel.style("top", _chart.effectiveHeight() / 2 + _chart.margins().top + "px");
    _chart.prepareLabelEdit("y");
    var xLabel = root.selectAll(".x-axis-label");
    if (xLabel.empty()) {
      xLabel = root.append("div").attr("class", "x-axis-label").text(_xLabel);
    }
    xLabel.style("left", _chart.effectiveWidth() / 2 + _chart.margins().left + "px");
    _chart.prepareLabelEdit("x");
  }; /* --------------------------------------------------------------------------*/
  /**
   * Gets or sets the Y border radius.  Set to 0 to get full rectangles.
   * @name yBorderRadius
   * @memberof dc.heatMap
   * @instance
   * @param  {Number} [yBorderRadius=6.75]
   * @return {Number}
   * @return {dc.heatMap}
   */_chart.yBorderRadius = function (yBorderRadius) {
    if (!arguments.length) {
      return _yBorderRadius;
    }
    _yBorderRadius = yBorderRadius;
    return _chart;
  };
  _chart.isSelectedNode = function (d) {
    /* OVERRIDE -----------------------------------------------------------------*/return _chart.hasFilter([d.key0, d.key1]) ^ _chart.filtersInverse();
    /* --------------------------------------------------------------------------*/
  };
  /* OVERRIDE ---------------------------------------------------------------- */function showPopup(d, i) {
    var popup = _chart.popup();
    var popupBox = popup.select(".chart-popup-content").html("").classed("popup-list", true);
    popupBox.append("div").attr("class", "popup-header").html(function () {
      return _colsLabel(_chart.keyAccessor()(d, i)) + " x " + _rowsLabel(_chart.valueAccessor()(d, i));
    });
    var popupItem = popupBox.append("div").attr("class", "popup-item");
    popupItem.append("div").attr("class", "popup-legend").style("background-color", _chart.getColor(d, i));
    popupItem.append("div").attr("class", "popup-item-value").html(function () {
      var customFormatter = _chart.valueFormatter();
      return customFormatter && customFormatter(d.color) || _utils.utils.formatValue(d.color);
    });
    popup.classed("js-showPopup", true);
  }
  function hidePopup() {
    _chart.popup().classed("js-showPopup", false);
  }
  function positionPopup() {
    var coordinates = [0, 0];
    coordinates = _chart.popupCoordinates(_d2.default.mouse(this));
    var scrollNode = _chart.root().select(".svg-wrapper").node();
    var x = coordinates[0] + _dockedAxesSize.left - scrollNode.scrollLeft;
    var y = coordinates[1] + _chart.margins().top - scrollNode.scrollTop;
    var popup = _chart.popup().attr("style", function () {
      return "transform:translate(" + x + "px," + y + "px)";
    });
    popup.select(".chart-popup-box").classed("align-right", function () {
      return x + _d2.default.select(this).node().getBoundingClientRect().width > _chart.width();
    });
  }
  _chart.colsMap = new Map();
  _chart.rowsMap = new Map();
  _chart._axisPadding = { left: 36, bottom: 42 };
  var getMaxChars = function getMaxChars(domain, getLabel) {
    return domain.map(function (d) {
      return d === null ? "NULL" : d;
    }).map(function (d) {
      return getLabel(d) ? getLabel(d).toString().length : 0;
    }).reduce(function (prev, curr) {
      return Math.max(prev, curr);
    }, null);
  };
  _chart.getAxisSizes = function (colsDomain, rowsDomain) {
    return {
      left: Math.min(getMaxChars(rowsDomain, _chart.rowsLabel()) * CHAR_WIDTH, MAX_LABEL_WIDTH) + _chart._axisPadding.left,
      bottom: Math.max(Math.min(getMaxChars(colsDomain, _chart.colsLabel()) * CHAR_WIDTH, MAX_LABEL_WIDTH) + _chart._axisPadding.bottom, MIN_AXIS_HEIGHT)
    };
  };

  _chart.shouldSortYAxisDescending = function (data) {
    return data && data.length && yAxisDataIsNonNumerical((0, _binningHelpers.getFirstNonNullDatumForAxis)(data, "y"));
  };

  _chart.keyAccessor(heatMapKeyAccessor.bind(_chart)).valueAccessor(heatMapValueAccesor.bind(_chart)).colorAccessor(function (d) {
    return d.value;
  }).rowsLabel(heatMapRowsLabel.bind(_chart)).colsLabel(heatMapColsLabel.bind(_chart));
  var keyAccessorNoFormat = heatMapKeyAccessorNoFormat.bind(_chart);
  _chart.keyAccessorNoFormat = function () {
    var forceMax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return function (datum) {
      return keyAccessorNoFormat(datum, forceMax);
    };
  };
  var valueAccessorNoFormat = heatMapValueAccesorNoFormat.bind(_chart);
  _chart.valueAccessorNoFormat = function () {
    var forceMax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return function (datum) {
      return valueAccessorNoFormat(datum, forceMax);
    };
  };
  return _chart.anchor(parent, chartGroup);
}
/** ***************************************************************************
 * END OVERRIDE: dc.heatMap                                                   *
 * ***************************************************************************/

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = multiSeriesMixin;

var _core = __webpack_require__(3);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var LIMIT = 21;
var OFFSET = 0;
var TOP = 5;
var MULTI_DIMENSION_INDEX = 1;

function processMultiSeriesResults(results) {
  return results.reduce(function (accum, _ref) {
    var key1 = _ref.key1,
        key0 = _ref.key0,
        val = _ref.val;

    if (accum.keys[key1]) {
      accum.keys[key1] = accum.keys[key1];
    } else if (key1 === "other") {
      accum.keys[key1] = key1;
    } else {
      accum.keys[key1] = "series_" + (Object.keys(accum.keys).length + 1);
    }

    if (Array.isArray(key0)) {
      var isExtract = key0[0].isExtract;

      var rawMin = isExtract ? key0[0].value : key0[0].value || key0[0];
      var min = rawMin instanceof Date ? rawMin.toISOString() : rawMin;
      var alias = key0[0].alias instanceof Date ? key0[0].alias.toISOString() : key0[0].alias || min;

      if (typeof accum.ranges[alias] !== "number") {
        // eslint-disable-line no-negated-condition
        accum.data[accum.data.length] = _defineProperty({
          key0: key0
        }, accum.keys[key1], val);
        accum.ranges[alias] = accum.data.length - 1;
      } else {
        accum.data[accum.ranges[alias]][accum.keys[key1]] = val;
      }
    } else if (typeof accum.ranges[key0] !== "number") {
      // eslint-disable-line
      accum.data[accum.data.length] = _defineProperty({
        key0: key0
      }, accum.keys[key1], val);
      accum.ranges[key0] = accum.data.length - 1;
    } else {
      accum.data[accum.ranges[key0]][accum.keys[key1]] = val;
    }

    return accum;
  }, {
    keys: {},
    ranges: {},
    data: []
  });
}

function selectWithCase(dimension, values) {
  if (dimension.slice(0, 9) === "CASE when") {
    return dimension;
  } else {
    var set = values.map(function (val) {
      return "'" + val.replace(/'/, "''") + "'";
    }).join(",");
    return "CASE when " + dimension + " IN (" + set + ") then " + dimension + " ELSE 'other' END";
  }
}

function setDimensionsWithColumns(columns, selected) {
  return function setDimensions(crossfilterDimensionArray) {
    return [crossfilterDimensionArray[0], selectWithCase(columns[MULTI_DIMENSION_INDEX], selected)];
  };
}

function flipKeys(keys) {
  return Object.keys(keys).reduce(function (accum, val) {
    accum[keys[val]] = val;
    return accum;
  }, {});
}

function multiSeriesMixin(chart) {
  var columns = null;
  var showOther = false;

  var series = {
    group: null,
    values: null,
    selected: null,
    keys: null
  };

  var seriesApi = {
    group: seriesMethodWithKey("group"),
    values: seriesMethodWithKey("values"),
    selected: seriesMethodWithKey("selected"),
    keys: seriesMethodWithKey("keys")
  };

  function seriesMethodWithKey(key) {
    return function seriesMethod(value) {
      if (typeof value === "undefined") {
        return series[key];
      }
      series[key] = value;
      return seriesApi;
    };
  }

  (0, _core.override)(chart, "_doRedraw", function () {
    if (chart.isMulti()) {
      setUpMultiStack();
      var rendered = chart.__doRedraw();
      chart.generatePopup();
      return rendered;
    } else {
      return chart.__doRedraw();
    }
  });

  (0, _core.override)(chart, "dimension", function (dimension) {
    if (!dimension) {
      return chart._dimension();
    }

    columns = dimension.value().slice();
    return chart._dimension(dimension);
  });

  chart.series = function () {
    return seriesApi;
  };

  chart.isMulti = function () {
    return chart.dimension().value().length > MULTI_DIMENSION_INDEX;
  };

  chart.showOther = function (other) {
    if (typeof other === "boolean") {
      showOther = other;
      return chart;
    }
    return showOther;
  };

  function dataAsync(group, callback) {
    if (chart.isMulti()) {
      return chart.series().group().topAsync(LIMIT, OFFSET).then(function (topValues) {
        var currentSelected = chart.series().selected();
        var hasSelected = Boolean(currentSelected && currentSelected.length);

        chart.series().values(topValues.map(function (result) {
          return result.key0;
        })).selected(hasSelected ? currentSelected : chart.series().values().slice(0, TOP));

        chart.group().dimension().set(setDimensionsWithColumns(columns, chart.series().selected()));

        chart.group().dimension().multiDim(false);

        return chart.group().reduce(chart.group().reduce()).all(function (error, results) {
          if (error) {
            return callback(error);
          } else {
            var _processMultiSeriesRe = processMultiSeriesResults(results),
                data = _processMultiSeriesRe.data,
                keys = _processMultiSeriesRe.keys;

            chart.series().keys(flipKeys(keys));
            return callback(error, data);
          }
        });
      }).catch(function (e) {
        return callback(e);
      });
    } else {
      return group.all(callback);
    }
  }

  function emptyStackMutation() {
    while (chart.stack().length) {
      chart.stack().pop();
    }
  }

  function addValuesWithNoKeysToKeysMutation() {
    function valuesWithNoKeys() {
      var keys = chart.series().keys();
      var selected = chart.series().selected() || [];
      var values = selected.slice();
      var indexes = Object.keys(keys).reduce(function (accum, key) {
        return accum.concat(selected.indexOf(keys[key]));
      }, []);
      indexes.forEach(function (index) {
        return values.splice(index, 1);
      });
      return values;
    }

    valuesWithNoKeys().forEach(function (select) {
      var currentLength = Object.keys(chart.series().keys()).length;
      var key = "series_" + (currentLength + 1);
      chart.series().keys()[key] = select;
    });
  }

  function stackFromSelected() {
    var keys = chart.series().keys();
    chart.series().selected().forEach(function (value) {
      var seriesName = Object.keys(keys).reduce(function (accum, v) {
        return keys[v] === value ? v : accum;
      }, null);
      chart.stack(chart.group(), seriesName, function (d) {
        return d[seriesName];
      });
    });
  }

  function setUpMultiStack() {
    if (chart.isMulti()) {
      emptyStackMutation();
      stackFromSelected();
      if (Object.keys(chart.series().keys()).length !== chart.stack().length && !chart.series().keys().other) {
        addValuesWithNoKeysToKeysMutation();
      }
      if (chart.showOther()) {
        chart.stack(chart.group(), "other", function (d) {
          return d.other;
        });
      }
    }
  }

  chart.setDataAsync(dataAsync);
  chart.on("preRender", setUpMultiStack);

  return chart;
}

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rasterDrawMixin = rasterDrawMixin;

var _utilsLatlon = __webpack_require__(24);

var LatLonUtils = _interopRequireWildcard(_utilsLatlon);

var _lassoToolUi = __webpack_require__(259);

var _lassoToolUi2 = _interopRequireDefault(_lassoToolUi);

var _lodash = __webpack_require__(23);

var _ = _interopRequireWildcard(_lodash);

var _mapdDraw = __webpack_require__(13);

var MapdDraw = _interopRequireWildcard(_mapdDraw);

var _coreAsync = __webpack_require__(5);

var _LatLonCircle = __webpack_require__(190);

var _LatLonCircle2 = _interopRequireDefault(_LatLonCircle);

var _LatLonPoly = __webpack_require__(192);

var _LatLonPoly2 = _interopRequireDefault(_LatLonPoly);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/** Configure MapD Draw */
MapdDraw.Configure.setMatrixArrayType(Float64Array);

// set a very low epsilon to account for the large precision provided us
// with 64-bit floating pt. If we left this at the default, if you made a lasso
// shape at a tight zoom (i.e. a shape with that was 100 meters^2 in area),
// the shape wouldn't align right because the camera would not be considered dirty
// even tho the map was moving slightly in world space.
MapdDraw.Configure.setEpsilon(0.00000000000001);
/** Done configuring MapdDraw */

function chartUsesLonLat(chart) {
  return typeof chart.useLonLat === "function" && chart.useLonLat();
}

/* istanbul ignore next */
function createUnlikelyStmtFromShape(shape, xAttr, yAttr, useLonLat) {
  var aabox = shape.aabox;
  var xmin = aabox[MapdDraw.AABox2d.MINX];
  var xmax = aabox[MapdDraw.AABox2d.MAXX];
  var ymin = aabox[MapdDraw.AABox2d.MINY];
  var ymax = aabox[MapdDraw.AABox2d.MAXY];
  var cast = true;
  if (useLonLat) {
    xmin = LatLonUtils.conv900913To4326X(xmin);
    xmax = LatLonUtils.conv900913To4326X(xmax);
    ymin = LatLonUtils.conv900913To4326Y(ymin);
    ymax = LatLonUtils.conv900913To4326Y(ymax);
    cast = false;
  }

  if (cast) {
    return "UNLIKELY(CAST(" + xAttr + " AS FLOAT) >= " + xmin + " AND CAST(" + xAttr + " AS FLOAT) <= " + xmax + " AND CAST(" + yAttr + " AS FLOAT) >= " + ymin + " AND CAST(" + yAttr + " AS FLOAT) <= " + ymax + ")";
  } else {
    return "UNLIKELY(" + xAttr + " >= " + xmin + " AND " + xAttr + " <= " + xmax + " AND " + yAttr + " >= " + ymin + " AND " + yAttr + " <= " + ymax + ")";
  }
}

function createSTContainsStatementFromShape(px, py, shape, srid) {
  var first_point = MapdDraw.Point2d.create();
  var point = MapdDraw.Point2d.create();
  var verts = shape.vertsRef;
  var xform = shape.globalXform;

  var contains_str = "";
  if (verts.length) {
    var wkt_str = "POLYGON((";
    if (srid === 4326) {
      verts.forEach(function (vert, curr_idx) {
        MapdDraw.Point2d.transformMat2d(point, vert, xform);
        LatLonUtils.conv900913To4326(point, point);
        wkt_str += point[0] + " " + point[1] + ",";

        if (curr_idx === 0) {
          MapdDraw.Point2d.copy(first_point, point);
        }
      });
    } else {
      verts.forEach(function (vert, curr_idx) {
        MapdDraw.Point2d.transformMat2d(point, vert, xform);
        wkt_str += point[0] + " " + point[1] + ",";

        if (curr_idx === 0) {
          MapdDraw.Point2d.copy(first_point, point);
        }
      });
    }

    wkt_str += first_point[0] + " " + first_point[1] + "))";

    contains_str = "ST_Contains(ST_GeomFromText('" + wkt_str + "', " + srid + "), ST_SetSRID(ST_Point(" + px + ", " + py + "), " + srid + "))";
  }
  return contains_str;
}

/* istanbul ignore next */
function rasterDrawMixin(chart) {
  var drawEngine = null;
  var buttonController = null;
  var currXRange = null;
  var currYRange = null;
  var coordFilters = new Map();
  var origFilterFunc = null;
  var origFilterAll = null;
  var useLonLat = chartUsesLonLat(chart);

  var defaultStyle = {
    fillColor: "#22a7f0",
    fillOpacity: 0.1,
    strokeColor: "#22a7f0",
    strokeWidth: 1.5,
    dashPattern: []
  };

  var defaultSelectStyle = {
    fillColor: "#ef9b20",
    fillOpacity: 0.1,
    strokeColor: "#ef9b20",
    strokeWidth: 2,
    dashPattern: [8, 2]

    // given a layer of this chart, and a bonkers boolean flag, will return the
    // associated crossfilter object

  };function getCrossfilter(layer) {
    var layerTypeIsPointsOrHeatOrUndefined = isLayerTypePointsOrHeatOrUndefined(layer);

    var group = layer.group();

    if (group) {
      return group.getCrossfilter();
    } else {
      var dim = layerTypeIsPointsOrHeatOrUndefined ? layer.dimension() : layer.viewBoxDim();
      if (dim) {
        return layerTypeIsPointsOrHeatOrUndefined ? dim.getCrossfilter() : dim;
      } else {
        return layer.crossfilter();
      }
    }
  }

  // crossfilters and associated filter objects are stored in different places
  // depending upon the type of chart. So we have this very stupidly named
  // function that checks the magic conditions for one path vs the other.
  function isLayerTypePointsOrHeatOrUndefined(layer) {
    return !layer.layerType || typeof layer.layerType !== "function" || layer.layerType() === "points" || layer.layerType() === "heat";
  }

  // given a layer, returns the associated filter object for it. If no filterObj
  // exists yet, it'll create one.
  function getRasterFilterObj(layer) {
    var layerTypeIsPointsOrHeatOrUndefined = isLayerTypePointsOrHeatOrUndefined(layer);

    var crossFilter = getCrossfilter(layer);

    if (crossFilter === undefined) {
      return undefined;
    }

    var filterObj = coordFilters.get(crossFilter);

    if (filterObj) {
      return filterObj;
    } else if (layerTypeIsPointsOrHeatOrUndefined) {
      filterObj = {
        coordFilter: crossFilter.filter(),
        px: [],
        py: []
      };
      coordFilters.set(crossFilter, filterObj);
      filterObj.shapeFilters = [];
    } else {
      filterObj = {
        coordFilter: crossFilter
      };
      coordFilters.set(crossFilter, filterObj);
      filterObj.shapeFilters = [];
    }

    return filterObj;
  }

  chart.getRasterFilterObj = getRasterFilterObj;

  function applyFilter() {
    var shapes = drawEngine.sortedShapes;

    var layers = chart.getLayers && typeof chart.getLayers === "function" ? chart.getLayers() : [chart];
    layers.forEach(function (layer) {
      if (!layer.layerType || typeof layer.layerType !== "function" || layer.layerType() === "points" || layer.layerType() === "heat") {
        var crossFilter = null;
        var filterObj = null;
        var group = layer.group();

        if (group) {
          crossFilter = group.getCrossfilter();
        } else {
          var dim = layer.dimension();
          if (dim) {
            crossFilter = dim.getCrossfilter();
          } else {
            crossFilter = layer.crossfilter();
          }
        }
        if (crossFilter) {
          filterObj = coordFilters.get(crossFilter);
          if (!filterObj) {
            filterObj = {
              coordFilter: crossFilter.filter(),
              px: [],
              py: []
            };
            coordFilters.set(crossFilter, filterObj);
            filterObj.shapeFilters = [];
          }
          var xdim = layer.xDim();
          var ydim = layer.yDim();
          if (xdim && ydim) {
            var px = xdim.value()[0];
            var py = ydim.value()[0];
            filterObj.px.push(px);
            filterObj.py.push(py);
            shapes.forEach(function (shape) {
              if (shape instanceof _LatLonCircle2.default) {
                var pos = shape.getWorldPosition();
                // convert from mercator to lat-lon
                LatLonUtils.conv900913To4326(pos, pos);
                var meters = shape.radius * 1000;
                filterObj.shapeFilters.push("DISTANCE_IN_METERS(" + pos[0] + ", " + pos[1] + ", " + px + ", " + py + ") < " + meters);
              } else if (shape instanceof MapdDraw.Circle) {
                var radsqr = Math.pow(shape.radius, 2);
                var mat = MapdDraw.Mat2d.clone(shape.globalXform);
                MapdDraw.Mat2d.invert(mat, mat);
                filterObj.shapeFilters.push(createUnlikelyStmtFromShape(shape, px, py, useLonLat) + " AND (POWER(" + mat[0] + " * CAST(" + px + " AS FLOAT) + " + mat[2] + " * CAST(" + py + " AS FLOAT) + " + mat[4] + ", 2.0) + POWER(" + mat[1] + " * CAST(" + px + " AS FLOAT) + " + mat[3] + " * CAST(" + py + " AS FLOAT) + " + mat[5] + ", 2.0)) / " + radsqr + " <= 1.0");
              } else if (shape instanceof _LatLonPoly2.default || shape instanceof MapdDraw.Poly) {
                var srid = 0;
                if (shape instanceof _LatLonPoly2.default) {
                  console.assert(useLonLat);
                  srid = 4326;
                } else {
                  console.assert(!useLonLat);
                }
                var contains_str = createSTContainsStatementFromShape(px, py, shape, srid);
                if (contains_str.length) {
                  filterObj.shapeFilters.push(createUnlikelyStmtFromShape(shape, px, py, useLonLat) + " AND (" + contains_str + ")");
                }
              }
            });
          }
        }
      } else if (!layer.layerType || typeof layer.layerType !== "function" || layer.layerType() === "lines") {
        if (layer.getState().data.length < 2) {
          var _crossFilter = null;
          var _filterObj = null;
          var _group = layer.group();

          if (_group) {
            _crossFilter = _group.getCrossfilter();
          } else {
            var _dim = layer.viewBoxDim();
            if (_dim) {
              _crossFilter = _dim;
            } else {
              _crossFilter = layer.crossfilter();
            }
          }
          if (_crossFilter) {
            _filterObj = coordFilters.get(_crossFilter);
            if (!_filterObj) {
              _filterObj = {
                coordFilter: _crossFilter
              };
              coordFilters.set(_crossFilter, _filterObj);
              _filterObj.shapeFilters = [];
            }

            shapes.forEach(function (shape) {
              if (shape instanceof _LatLonCircle2.default) {
                var pos = shape.getWorldPosition();
                // convert from mercator to lat-lon
                LatLonUtils.conv900913To4326(pos, pos);
                var radiusInKm = shape.radius;
                var shapeFilter = {
                  spatialRelAndMeas: "filterST_Distance",
                  filters: { point: [pos[0], pos[1]], distanceInKm: radiusInKm }
                };

                if (!_.find(_filterObj.shapeFilters, shapeFilter)) {
                  _filterObj.shapeFilters.push(shapeFilter);
                }
              } else if (shape instanceof _LatLonPoly2.default || shape instanceof MapdDraw.Poly) {
                var p0 = MapdDraw.Point2d.create();
                var convertedVerts = [];

                var verts = shape.vertsRef;
                var xform = shape.globalXform;
                verts.forEach(function (vert) {
                  MapdDraw.Point2d.transformMat2d(p0, vert, xform);
                  if (useLonLat) {
                    LatLonUtils.conv900913To4326(p0, p0);
                  }
                  convertedVerts.push([p0[0], p0[1]]);
                });
                var _shapeFilter = {
                  spatialRelAndMeas: "filterST_Contains",
                  filters: convertedVerts
                };

                if (!_.find(_filterObj.shapeFilters, _shapeFilter)) {
                  _filterObj.shapeFilters.push(_shapeFilter);
                }
              }
            });
          }
        }
      }
    });

    coordFilters.forEach(function (filterObj) {
      if (filterObj.px && filterObj.py && filterObj.px.length && filterObj.py.length && filterObj.shapeFilters.length) {
        var shapeFilterStmt = filterObj.shapeFilters.join(" OR ");
        var filterStmt = filterObj.px.map(function (e, i) {
          return { px: e, py: filterObj.py[i] };
        }).reduce(function (acc, e) {
          return acc.some(function (e1) {
            return e1.px === e.px && e1.py === e.py;
          }) ? acc : [].concat(_toConsumableArray(acc), [e]);
        }, []).map(function (e, i) {
          return "(" + e.px + " IS NOT NULL AND " + e.py + " IS NOT NULL AND (" + shapeFilterStmt + "))";
        }).join(" AND ");
        filterObj.coordFilter.filter([filterStmt]);
        filterObj.px = [];
        filterObj.py = [];
        filterObj.shapeFilters = [];
      } else if (filterObj.coordFilter && filterObj.shapeFilters && filterObj.shapeFilters.length && filterObj.shapeFilters[0].spatialRelAndMeas) {
        filterObj.coordFilter.filterSpatial();
        filterObj.shapeFilters.forEach(function (sf) {
          filterObj.coordFilter.filterSpatial(sf.spatialRelAndMeas, sf.filters);
        });
        filterObj.shapeFilters = [];
      } else {
        filterObj.coordFilter.filter();
      }
    });

    return chart._invokeFilteredListener(chart.filters(), false);
  }

  function drawEventHandler() {
    applyFilter();
    setTimeout(function () {
      return (0, _coreAsync.redrawAllAsync)(chart.chartGroup());
    });
  }

  var debounceRedraw = chart.debounce(function () {
    drawEventHandler();
  }, 50);

  function updateDrawFromGeom() {
    debounceRedraw();
  }

  chart.addFilterShape = function (shape) {
    shape.on(["changed:geom", "changed:xform", "changed:visibility"], updateDrawFromGeom);
    updateDrawFromGeom();
  };

  chart.deleteFilterShape = function (shape) {
    shape.off(["changed"], updateDrawFromGeom);
    updateDrawFromGeom();
  };

  function filters() {
    var shapes = drawEngine.getShapesAsJSON();
    if (shapes[0]) {
      return chart.nonDrawFilters().concat(Array.from(shapes));
    }
    return chart.nonDrawFilters();
  }

  function filter(filterArg) {
    if (!arguments.length) {
      return drawEngine.getShapesAsJSON();
    }

    if (filterArg === null) {
      drawEngine.deleteAllShapes();
      applyFilter();
    } else if (typeof filterArg.type !== "undefined") {
      var newShape = null;
      if (filterArg.type === "Feature") {
        console.log("WARNING - trying to load an incompatible lasso dashboard. All filters will be cleared.");
        return;
      }
      var selectOpts = {};
      if (filterArg.type === "LatLonCircle") {
        newShape = new _LatLonCircle2.default(filterArg);
        selectOpts.uniformScaleOnly = true;
        selectOpts.centerScaleOnly = true;
        selectOpts.rotatable = false;
      } else if (filterArg.type === "LatLonPoly" || filterArg.type === "Poly") {
        var args = [];
        var PolyClass = null;
        if (useLonLat) {
          PolyClass = _LatLonPoly2.default;
          args.push(drawEngine);
        } else {
          PolyClass = MapdDraw.Poly;
        }
        args.push(filterArg);
        newShape = new (Function.prototype.bind.apply(PolyClass, [null].concat(args)))();
      } else if (typeof MapdDraw[filterArg.type] !== "undefined") {
        newShape = new MapdDraw[filterArg.type](filterArg);
      } else {
        origFilterFunc(filterArg);
      }

      if (newShape) {
        drawEngine.addShape(newShape, selectOpts);
        chart.addFilterShape(newShape);
        applyFilter();
      }
    } else {
      origFilterFunc(filterArg);
    }

    if (!buttonController || !buttonController.isActive()) {
      drawEngine.enableInteractions();
    }
  }

  chart.addDrawControl = function () {
    if (drawEngine) {
      return chart;
    }

    var parent = chart.root().node();

    var xscale = chart.x();
    var yscale = chart.y();
    if (!xscale || !yscale) {
      chart._updateXAndYScales(chart.getDataRenderBounds());
      xscale = chart.x();
      yscale = chart.y();
    }
    currXRange = xscale.domain();
    currYRange = yscale.domain();

    var projDims = [Math.abs(currXRange[1] - currXRange[0]), Math.abs(currYRange[1] - currYRange[0])];

    var engineOpts = {
      enableInteractions: true,
      projectionDimensions: projDims,
      cameraPosition: [currXRange[0] + 0.5 * projDims[0], Math.min(currYRange[0], currYRange[1]) + 0.5 * projDims[1]],
      flipY: true,
      selectStyle: defaultSelectStyle,
      xformStyle: {
        fillColor: "white",
        strokeColor: "#555555",
        strokeWidth: 1
      }
    };

    var margins = null;
    if (typeof chart.margins === "function") {
      margins = chart.margins();
      engineOpts.margins = margins;
    }

    drawEngine = new MapdDraw.ShapeBuilder(parent, engineOpts);
    buttonController = new _lassoToolUi2.default(parent, chart, drawEngine, defaultStyle, defaultSelectStyle);

    function updateDraw() {
      var bounds = chart.getDataRenderBounds();
      currXRange = [bounds[0][0], bounds[1][0]];
      currYRange = [bounds[0][1], bounds[2][1]];
      if (chartUsesLonLat(chart)) {
        currXRange[0] = LatLonUtils.conv4326To900913X(currXRange[0]);
        currXRange[1] = LatLonUtils.conv4326To900913X(currXRange[1]);
        currYRange[0] = LatLonUtils.conv4326To900913Y(currYRange[0]);
        currYRange[1] = LatLonUtils.conv4326To900913Y(currYRange[1]);
      }

      var newProjDims = [Math.abs(currXRange[1] - currXRange[0]), Math.abs(currYRange[1] - currYRange[0])];
      drawEngine.projectionDimensions = newProjDims;
      drawEngine.cameraPosition = [currXRange[0] + 0.5 * newProjDims[0], Math.min(currYRange[0], currYRange[1]) + 0.5 * newProjDims[1]];

      // debounceRedraw()
    }

    function updateDrawResize(eventObj) {
      // make sure all buttons and events are deactivated when resizing
      // so shape creation/modification events aren't unintentionally
      // triggered
      buttonController.deactivateButtons();

      // NOTE: in the scatterplot case, there's no guarantee that the parent div will have been properly
      // resized by the time we reach here. Getting the effectiveWidth of the chart is a safer
      // bet. That method should be defined on a scatterplot chart.
      // Do we need to be concerned with margins/padding on the div? I don't believe we
      // do since we're only setting the viewport here, which should cover the entire
      // width/height of the canvas.
      var widthToUse = typeof chart.effectiveWidth === "function" ? chart.effectiveWidth() : parent.offsetWidth;
      var heightToUse = typeof chart.effectiveHeight === "function" ? chart.effectiveHeight() : parent.offsetHeight;
      drawEngine.viewport = [0, 0, widthToUse, heightToUse];
      updateDraw();
    }

    chart.map().on("render", updateDraw);

    chart.map().on("resize", updateDrawResize);

    origFilterFunc = chart.filter;
    origFilterAll = chart.filterAll;
    chart.filter = filter;
    chart.nonDrawFilters = chart.filters;
    chart.filters = filters;

    chart.filterAll = function () {
      origFilterAll();
      chart.getLayerNames().forEach(function (layerName) {
        var layer = chart.getLayer(layerName);
        if (layer.hasOwnProperty("filterAll")) {
          layer.filterAll(chart);
        }
      });
      if (coordFilters) {
        coordFilters.forEach(function (filterObj) {
          if (filterObj.coordFilter && "spatialRelAndMeas" in filterObj.shapeFilters) {
            filterObj.coordFilter.filterSpatial();
            var bounds = chart.map().getBounds();
            filterObj.coordFilter.filterST_Min_ST_Max({
              lonMin: bounds._sw.lng,
              lonMax: bounds._ne.lng,
              latMin: bounds._sw.lat,
              latMax: bounds._ne.lat
            });
          } else {
            filterObj.coordFilter.filter();
          }
          filterObj.shapeFilters = [];
        });
      }
      var shapes = drawEngine.sortedShapes;
      drawEngine.deleteAllShapes();

      origFilterFunc(Symbol.for("clear"));

      shapes.forEach(function (shape) {
        chart.deleteFilterShape(shape);
      });

      if (typeof chart.useLonLat === "function") {
        // pointmap should preserve the zoom filter
        chart.setFilterBounds(chart.map().getBounds());
      }
      return chart;
    };

    return chart;
  };

  chart.coordFilter = function (filter) {
    // noop - for backwards compatibility
  };

  return chart;
}

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _utilsLatlon = __webpack_require__(24);

var LatLonUtils = _interopRequireWildcard(_utilsLatlon);

var _mapdDraw = __webpack_require__(13);

var MapdDraw = _interopRequireWildcard(_mapdDraw);

var _LatLonViewIntersectUtils = __webpack_require__(191);

var _LatLonViewIntersectUtils2 = _interopRequireDefault(_LatLonViewIntersectUtils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var AABox2d = MapdDraw.AABox2d,
    Mat2d = MapdDraw.Mat2d,
    Point2d = MapdDraw.Point2d,
    Vec2d = MapdDraw.Vec2d;

var MathExt = MapdDraw.Math;

/**
 * @typedef CircleDescriptor
 * An object describing various geometric/geographic states of a LatLonCircle that is a
 * simplified form of the LatLonCircle class that can be passed around to various static
 * methods
 *
 * @param {Point2d} center_mercator The center of the circle in web-mercator coordinates
 * @param {Point2d} center_lonlat The center of the circle in lon/lat WGS84 coordinates, in degrees
 * @param {Point2d} center_radians The same point as center_lonlat but in radians, not degrees
 * @param {number} radius_radians The radius of the circle in radians
 * @param {number} max_segment_pixel_distance The max distance in pixels of line segments representing
 *                                            the circle when drawing.
 * @param {number} degrees_between_points The angle difference in degrees between consecutive points of
 *                                        a LatLonCircle
 * @returns
 */

/**
 * Creates a descriptor of a LatLonCircle instance
 * @param {LatLonCircle} latlon_circle An instance of the LatLonCircle class to build a descriptor for.
 * @returns {CircleDescriptor}
 */
function createCircleDescriptor(latlon_circle) {
  var center_mercator = Point2d.create();
  Mat2d.svd(center_mercator, null, null, latlon_circle.globalXform);

  // the 'true' argument below indicates to include the lonlat point defined
  // in radians as well as degrees
  var point_data = _LatLonViewIntersectUtils2.default.buildProjectedPointData(true);
  _LatLonViewIntersectUtils2.default.projectPoint(center_mercator, point_data, null, null);

  // convert to a circle-centeric descriptor form
  return {
    center_mercator: point_data.merc_point,
    center_lonlat: point_data.lonlat_point,
    center_radians: point_data.radians_point,
    radius_radians: getDistanceInRadians(latlon_circle.radius),
    max_segment_pixel_distance: latlon_circle._max_segment_pixel_distance,
    degrees_between_points: latlon_circle._degrees_between_points
  };
}

/**
 * Creates a new 2d lat/lon point that lies on a LatLonCircle at a specific angle about
 * the center of the circle.
 * @param {CircleDescriptor} circle_descriptor An object describing the various geometric/geographic states of a lon/lat-defined circle.
 * @param {Point2d} output_point The coordinates of the new point will be stored in this object
 * @param {number} angle_radians The angle about the center point to position the new point in radians
 * @returns {Point2d} A new lon/lat point that is protruded a specific distance away from a center point at the specified angle
 */
function initializePointOnCircle(circle_descriptor, output_point, angle_radians) {
  // essentially the inverse of LatLonUtils.distance_in_meters
  var center_radians = circle_descriptor.center_radians,
      radius_radians = circle_descriptor.radius_radians;

  var cos_radius = Math.cos(radius_radians);
  var sin_radius = Math.sin(radius_radians);

  var _center_radians = _slicedToArray(center_radians, 2),
      center_lon_radians = _center_radians[0],
      center_lat_radians = _center_radians[1];

  var cos_lat = Math.cos(center_lat_radians);
  var sin_lat = Math.sin(center_lat_radians);

  var point_lat_radians = Math.asin(sin_lat * cos_radius + cos_lat * sin_radius * Math.cos(angle_radians));
  var point_lon_radians = center_lon_radians + Math.atan2(Math.sin(angle_radians) * sin_radius * cos_lat, cos_radius - sin_lat * Math.sin(point_lat_radians));

  // convert back to degrees
  Point2d.set(output_point, point_lon_radians, point_lat_radians);
  Vec2d.scale(output_point, output_point, MathExt.RAD_TO_DEG);
}

/**
 * Gets the angle of a specific point about the center of a circle.
 * @param {CircleDescriptor} circle_descriptor An object describing the various geometry/geography states of a LatLonCircle
 * @param {Point2d} point_lonlat The position of the point in lon/lat WGS84 coords in degrees
 * @param {Point2d} point_radians The position of the same point as point_lonlat but in radians instead of degrees
 * @returns {number} The angle of the point about the circle's center, in radians, in the range of [-PI, PI]
 */
function getAngleOfPointAboutCircle(circle_descriptor, point_lonlat, point_radians) {
  var center_lonlat = circle_descriptor.center_lonlat,
      center_radians = circle_descriptor.center_radians;

  // distance between the points in kilometers using haversine

  var distance = LatLonUtils.distance_in_meters(center_lonlat[0], center_lonlat[1], point_lonlat[0], point_lonlat[1]) / 1000.0;

  // get the distance between the points in radians
  var dist_radians = getDistanceInRadians(distance);

  // solve for the new angle in radians, which is the inverse of finding the latitude in
  // initializePointOnCircle() method
  var numerator = Math.sin(point_radians[1]) - Math.sin(center_radians[1]) * Math.cos(dist_radians);
  var denominator = Math.cos(center_radians[1]) * Math.sin(dist_radians);
  console.assert(denominator !== 0, center_lonlat + ", " + center_radians + ", " + point_lonlat + ", " + point_radians + ", " + distance);
  var divide = numerator / denominator;
  if (divide > 1) {
    // should never get a ratio > 1, but if we do, check that it is approximately 1
    // and clamp
    console.assert(MathExt.floatingPtEquals(divide, 1), center_lonlat + ", " + center_radians + ", " + point_lonlat + ", " + point_radians + ", " + distance);
    divide = 1;
  } else if (divide < -1) {
    // should never get a ratio < -1, but if we do, check that it is approximately -1
    // and clamp
    console.assert(MathExt.floatingPtEquals(divide, -1), center_lonlat + ", " + center_radians + ", " + point_lonlat + ", " + point_radians + ", " + distance);
    divide = -1;
  }

  // make sure to return in a range of [-PI, PI], to do that, just check which side of the
  // center point the point to check falls.
  var angle = Math.acos(divide);
  if (point_lonlat[0] - center_lonlat[0] >= 0) {
    return angle;
  }
  return MathExt.TWO_PI - angle;
}

/**
 * @typedef ClosestCirclePointData
 * Data describing the closest point on a LatLonCircle
 *
 * @property {number} angle_degrees The angle of the closest point on the circle arc
 *                                  about the center of the circle.
 * @property {ProjectedPointData} closest_point_data The various projection/conversion states of the
 *                                                   closest point on a LatLonCircle
 */

/**
 * Calculates the closest point on a circle's arc from a specific point in 2D space
 * @param {CircleDescriptor} circle_descriptor A descriptor of varions geometric/geographic properties of a LatLonCircle
 * @param {Point2d} point_lonlat A point in lon/lat WGS84 space to find the closest point to, in degrees
 * @param {Point2d} point_radians The same point as point_lonlat, but in radians rather than degrees
 * @param {Mat2d} world_to_screen_matrix Matrix describing the projection from web-mercator world space
 *                                       to screen space.
 * @returns {ClosestCirclePointData}
 */
function getClosestPointOnCircleArc(circle_descriptor, point_lonlat, point_radians, world_to_screen_matrix) {
  // get the angle from the center of the circle to the potential subdivide point
  var angle_radians = getAngleOfPointAboutCircle(circle_descriptor, point_lonlat, point_radians);
  var angle_degrees = angle_radians * MathExt.RAD_TO_DEG;

  // get the closest point on the circle's arc in lon/lat
  var closest_point_data = _LatLonViewIntersectUtils2.default.buildProjectedPointData();
  closest_point_data.angle_degrees = angle_degrees;
  initializePointOnCircle(circle_descriptor, closest_point_data.lonlat_point, angle_radians);

  // convert from lon/lat to mercator
  LatLonUtils.conv4326To900913(closest_point_data.merc_point, closest_point_data.lonlat_point);

  // get the point in screen space
  Point2d.transformMat2d(closest_point_data.screen_point, closest_point_data.merc_point, world_to_screen_matrix);

  return {
    angle_degrees: angle_degrees,
    closest_point_data: closest_point_data
  };
}

/**
 * Returns a given distance in kilometers in radians
 * @param {number} distance Distance in kilometers
 * @returns {number} the distance in radians around the globe
 */
function getDistanceInRadians(distance) {
  // radius is stored in kilometers, so convert kilometers to radians.
  // See: https://stackoverflow.com/questions/12180290/convert-kilometers-to-radians
  // for a discussion.
  // The 6372.79756 number is the earth's radius in kilometers and aligns with the
  // earth radius used in distance_in_meters in utils-latlon
  return distance / 6372.797560856;
}

/**
 * @typedef LatLonCircleSegmentEndpoints
 * Object describing the endpoints of a LatLonCircle line segment defining an
 * arc.
 * @param {number} start_angle Angle about the center of a LatLonCircle for the start point of the segment
 * @param {ProjectedPointData} start_point The start point of the LatLonCircle segment
 * @param {number} end_angle Angle about the center of a LatLonCircle for the end point of the segment
 * @param {ProjectedPointData} end_point The end point of the LatLonCircle segment
 */

/**
 * Callback to retrieve the two endpoints of a LonLatCircle segment.
 *
 * @callback GetEndpointsFunctor
 * @param {ClosestCirclePointData} closest_point_data The point on a LatLonCircle arc used to determine the segment
 *                                                    of the LatLonCircle that defines that arc.
 * @returns {LatLonCircleSegmentEndpoints}
 */

/**
 * Subdivides a line-segment of a LatLonCircle arc at the closest point on the circle to a
 * specific point in 2D space.
 * @param {CircleDescriptor} circle_descriptor Describes various geometric/geographic states of a LatLonCircle
 * @param {Point2d} point_lonlat Point in lon/lat WGS84 to drive the subdivision, in degrees.
 * @param {Point2d} point_radians The same point as point_lonlat, but in radians rather than degrees.
 * @param {AABox2d} shape_view_intersect_aabox Axis-aligned bounding box describing the
 *                                             intersection between the shape and the current view
 *                                             in WGS84 lat/lon coords
 * @param {Mat2d} world_to_screen_matrix 2D matrix describing the web-mercator to screen space transform.
 * @param {GetEndpointsFunctor} get_endpoints_functor
 * @returns
 */
function subdivideCircleArcAtPoint(circle_descriptor, point_lonlat, point_radians, shape_view_intersect_aabox, world_to_screen_matrix, get_endpoints_functor) {
  // Calculate the closest point on the circle arc to a point.
  // This will be used as a new line break.
  var _getClosestPointOnCir = getClosestPointOnCircleArc(circle_descriptor, point_lonlat, point_radians, world_to_screen_matrix),
      angle_degrees = _getClosestPointOnCir.angle_degrees,
      closest_point_data = _getClosestPointOnCir.closest_point_data;

  // Be sure that the view bounding box includes the closest point found on the circle.
  // But keep the original view bounding box untouched
  // NOTE: if zoomed in tight enough, the closest point on the circle here could end up off-screen,
  // and therefore cause the new bounds calculated here to not be fully contained by the original
  // view bounds.  Keep in mind that the 'shape_view_interseect_aabox' argument represents the
  // bounds intersection between the view bounds and the shape's bounding box. As a result this
  // may create unnecessary points that end up being drawn off-screen, but that's generally not
  // be a big deal as it should only generate a handful of points. And in fact, those extra points
  // may keep the circle arc protruded enough to prevent an unwanted jump in the render of the shape.
  // For example, if the closest point on the circle calculated here were off screen, the line segment
  // between this extra point and the original line segment points could still intersect the view, but
  // the arc of the circle may not. We want to prevent this. The potential extra points can prevent
  // this.


  var new_intersect_bounds = AABox2d.clone(shape_view_intersect_aabox);
  AABox2d.encapsulatePt(new_intersect_bounds, new_intersect_bounds, closest_point_data.lonlat_point);

  // get the endpoints and respective angles of the line segment we're subdividing

  var _get_endpoints_functo = get_endpoints_functor(angle_degrees, closest_point_data),
      start_angle = _get_endpoints_functo.start_angle,
      start_point = _get_endpoints_functo.start_point,
      end_angle = _get_endpoints_functo.end_angle,
      end_point = _get_endpoints_functo.end_point;

  // create the new subdivided points with the new point break


  var new_subdivided_points = [];
  subdivideArc(new_subdivided_points, circle_descriptor, start_point, closest_point_data, start_angle, angle_degrees - start_angle, new_intersect_bounds, world_to_screen_matrix, false);

  new_subdivided_points.push(Point2d.clone(closest_point_data.screen_point));

  subdivideArc(new_subdivided_points, circle_descriptor, closest_point_data, end_point, angle_degrees, end_angle - angle_degrees, new_intersect_bounds, world_to_screen_matrix, false);

  return new_subdivided_points;
}

/**
 * Determines whether a line segment that represents an arc of a circle defined
 * by a start/end point should be further subdivided for drawing.
 * If the segment should be subdivided, will append subdivided points representing
 * the subdivided arc into the array of screen-projected points for drawing.
 * @param {Point2d[]} subdivided_points_array Array to append the subdivided points to
 * @param {CircleDescriptor} circle_descriptor An object describing the various geometric/geographic properties and states
 *                                             of a LatLonCircle instance.
 * @param {ProjectedPointData} start_point_data Start point of the line segment
 * @param {ProjectedPointData} end_point_data End point of the line segment
 * @param {number} start_angle The angle about the center of the circle for the starting point of
 *                             this segment. In degrees.
 * @param {number} angle_diff The angle difference between the start point and the end point of this
 *                            segment. In degrees.
 * @param {AABox2d} shape_view_intersect_aabox Axis-aligned bounding box describing the
 *                                             intersection between the shape and the current view
 *                                             in WGS84 lat/lon coords
 * @param {Mat2d} world_to_screen_matrix Matrix defining world-to-screen transformation
 * @param {boolean} do_extra_subdivide If true, an extra subdivision point will be added to break up
 *                                     the original line segment in order to give enough extra detail
 *                                     to build out the circle arc with respect to the current view.
 *                                     This is used to differentiate between an outside call, and a recursive
 *                                     call. This should be true for an outside call and false for recursive.
 * @returns
 */
function subdivideArc(subdivided_points_array, circle_descriptor, start_point_data, end_point_data, start_angle, angle_diff, shape_view_intersect_aabox, world_to_screen_matrix) {
  var do_extra_subdivide = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : true;

  // get any intersection info for the intersection between a line segment defined by
  // start/end_point_data and the current view.
  var view_intersect_data = _LatLonViewIntersectUtils2.default.intersectViewBounds(start_point_data, end_point_data, shape_view_intersect_aabox, world_to_screen_matrix);

  if (!view_intersect_data.subdivide) {
    // early out. It is determined no subdivision is required.
    return;
  }

  console.assert(view_intersect_data.lonlat_pts.length === 2, "start_point: [" + start_point_data.lonlat_point[0] + ", " + start_point_data.lonlat_point[1] + "], end_point: [" + end_point_data.lonlat_point[0] + ", " + end_point_data.lonlat_point[1] + "], view_aabox: [" + shape_view_intersect_aabox[0] + ", " + shape_view_intersect_aabox[1] + ", " + shape_view_intersect_aabox[2] + ", " + shape_view_intersect_aabox[3] + "], worldToScreenMatrix: [" + world_to_screen_matrix[0] + ", " + world_to_screen_matrix[1] + ", " + world_to_screen_matrix[2] + ", " + world_to_screen_matrix[3] + ", " + world_to_screen_matrix[4] + ", " + world_to_screen_matrix[5] + "]");

  var _view_intersect_data$ = _slicedToArray(view_intersect_data.screen_pts, 2),
      start_screen_pt = _view_intersect_data$[0],
      end_screen_pt = _view_intersect_data$[1];

  var _view_intersect_data$2 = _slicedToArray(view_intersect_data.lonlat_pts, 2),
      start_lonlat_pt = _view_intersect_data$2[0],
      end_lonlat_pt = _view_intersect_data$2[1];

  var _view_intersect_data$3 = _slicedToArray(view_intersect_data.pts_t, 2),
      start_t = _view_intersect_data$3[0],
      end_t = _view_intersect_data$3[1];

  var distance = Point2d.distance(start_screen_pt, end_screen_pt);
  if (distance > circle_descriptor.max_segment_pixel_distance) {
    // This segment should be subdivided. But first check whether we should add a point
    // break to add more detail to this line segment before further subdivision. For example,
    // if at the right zoom, the endpoints of a line could be way off screen, but a small sliver
    // of the line could cross the view, but the arc of the circle represented by that line
    // segment could be quite a distance away in pixels and cover a larger area of screen.
    // Or, in other words, the pixel coverage for the line segment/view intersection may be small
    // compared to the arc that is represented, leading to an undersampling of points for the arc.
    // To fix this, subdivide the line segment at a point that is in/near the view bounds so we
    // get two new line segments that are more appropriately sampled, therefore not leading to
    // an undersampled arc.

    // TODO(croot); the 0.25 threshold is just an empirical "good enough" for the ratio
    // of the full line segment length and it's view-intersection length. A more clever
    // metric could be used
    if (do_extra_subdivide && !MathExt.floatingPtEquals(start_t, 0) && !MathExt.floatingPtEquals(end_t, 1) && end_t - start_t < 0.25) {
      // get the angle from the center of the circle to the potential subdivide point
      var tmp_point = Point2d.clone(start_lonlat_pt);
      var start_radians_pt = tmp_point;
      Vec2d.scale(start_radians_pt, start_radians_pt, MathExt.DEG_TO_RAD);

      var _getClosestPointOnCir2 = getClosestPointOnCircleArc(circle_descriptor, start_lonlat_pt, start_radians_pt, world_to_screen_matrix),
          closest_point_data = _getClosestPointOnCir2.closest_point_data;

      // If the distance between the line segment and the circle arc it represents
      // is greater than the set threshold, than add the new point break for better
      // sampling.


      if (Point2d.distance(start_screen_pt, closest_point_data.screen_point) > circle_descriptor.max_segment_pixel_distance) {
        // subdivde the line segment at the midpoint of the in-view line segment
        // TODO(croot): This seems to work 99.5% of the time but could see a jump in the rare case that
        // the line segment crosses very close to a corner.
        var line_center_lonlat = tmp_point;
        Point2d.lerp(line_center_lonlat, start_lonlat_pt, end_lonlat_pt, 0.5);
        var line_center_radians = Point2d.clone(line_center_lonlat);
        Vec2d.scale(line_center_radians, line_center_radians, MathExt.DEG_TO_RAD);

        var new_subdivided_points = subdivideCircleArcAtPoint(circle_descriptor, line_center_lonlat, line_center_radians, shape_view_intersect_aabox, world_to_screen_matrix, function (angle_degrees, new_point_data) {
          var start_angle = start_point_data.angle_degrees;
          var end_angle = start_angle + circle_descriptor.degrees_between_points;
          return {
            start_angle: start_angle,
            start_point: start_point_data,
            end_angle: end_angle,
            end_point: end_point_data
          };
        });

        subdivided_points_array.push.apply(subdivided_points_array, _toConsumableArray(new_subdivided_points));
        return;
      }
    }

    // number of subdivisions determined for this line segment.
    var num_subdivisions = Math.ceil(distance / circle_descriptor.max_segment_pixel_distance);

    // start iterating over the number of subdivided points,
    // and reprojecting each one

    var point_radians = Point2d.clone(start_lonlat_pt);
    Vec2d.scale(point_radians, point_radians, MathExt.DEG_TO_RAD);
    var _start_angle = getAngleOfPointAboutCircle(circle_descriptor, start_lonlat_pt, point_radians);
    Point2d.copy(point_radians, end_lonlat_pt);
    Vec2d.scale(point_radians, point_radians, MathExt.DEG_TO_RAD);
    var end_angle = getAngleOfPointAboutCircle(circle_descriptor, end_lonlat_pt, point_radians);
    var _angle_diff = (end_angle - _start_angle) / num_subdivisions;
    for (var current_angle = _start_angle; current_angle <= end_angle; current_angle += _angle_diff) {
      // create a new subdivided point rotated around the circle center using the radius distance in radians
      var new_point = Point2d.create();
      initializePointOnCircle(circle_descriptor, new_point, current_angle);

      // convert from lon/lat to mercator
      LatLonUtils.conv4326To900913(new_point, new_point);

      // now convert to screen space
      Point2d.transformMat2d(new_point, new_point, world_to_screen_matrix);
      subdivided_points_array.push(new_point);
    }
  }
}

/**
 * @typedef PointDistanceFromCircle
 * Describes a point in 2D WGS84 lon/lat degree coordinates with a distance from the
 * center of a LatLonCircle instance.
 * @param {number} distance Distance of this point to the center of a LatLonCircle instance.
 * @param {Point2d} point 2d point in WGS84 lon/lat degree coordinates.
 */

/**
 * @typedef BoundsDistanceFromCircle
 * @param {number} min_bounds_dist Minimum distance to the 4 corners of an axis-aligned bounding box
 *                                 from the center of a LatLonCircle.
 * @param {number} max_bounds_dist Maximum distance to the 4 cornders of an axis-aligned bounding box
 *                                 from the center of a LatLonCircle.
 * @param {PointDistanceFromCircle[]} bounds_distances Array of points & distances of the 4 corners of the
 *                                                     input bounding box. The distance is the distance to
 *                                                     the center of a LatLonCircle instance. The array is
 *                                                     sorted by distance in ascending order.
 */

/**
 * Returns a data structure object that represents a list of the corners
 * of a WGS84 lon/lat axis-aligned bounding box sorted by distance from
 * the center of a LatLonCircle.
 * @param {Point2d} center_lonlat The center of a LatLonCircle in WGS84 lon/lat degree coordinates.
 * @param {AABox2d} bounds_lonlat An axis-aligned bounding box in WGS84 lon/lat degree coordinates.
 * @returns {BoundsDistanceFromCircle}
 */
function getBoundsDistanceData(center_lonlat, bounds_lonlat) {
  var bounds_distances = new Array(4);
  for (var i = 0; i < 4; ++i) {
    var bounds_lon = i & 1 ? bounds_lonlat[AABox2d.MAXX] : bounds_lonlat[AABox2d.MINX];
    var bounds_lat = i > 1 ? bounds_lonlat[AABox2d.MAXY] : bounds_lonlat[AABox2d.MINY];
    var point = Point2d.create(bounds_lon, bounds_lat);
    // distance from center to corner of bounds in kilometers
    var distance = LatLonUtils.distance_in_meters(center_lonlat[0], center_lonlat[1], bounds_lon, bounds_lat) / 1000.0;
    bounds_distances[i] = {
      distance: distance,
      point: point
    };
  }

  bounds_distances.sort(function (a, b) {
    return a.distance - b.distance;
  });

  return {
    min_bounds_dist: bounds_distances[0].distance,
    max_bounds_dist: bounds_distances[3].distance,
    bounds_distances: bounds_distances
  };
}

var LatLonCircle = function (_MapdDraw$Circle) {
  _inherits(LatLonCircle, _MapdDraw$Circle);

  function LatLonCircle(draw_engine, opts) {
    _classCallCheck(this, LatLonCircle);

    if (opts.debug === undefined) {
      // if true, will activate the use of the _drawDebug method for drawing
      // extra debug info on top of the original shape draw.
      opts.debug = false;
    }

    var _this = _possibleConstructorReturn(this, (LatLonCircle.__proto__ || Object.getPrototypeOf(LatLonCircle)).call(this, opts));

    _this._draw_engine = draw_engine;

    _this._geomDirty = true;
    _this._viewDirty = true;

    var that = _this;
    _this._draw_engine.camera.on("changed", function (event) {
      that._viewDirty = true;
    });

    // maximum length of subdivided line segment in pixels
    _this._max_segment_pixel_distance = 40;

    _this._initial_radius = _this._radius;

    // degrees between successive points in the drawn
    // segmented circle
    _this._degrees_between_points = 6.0;

    // Now calculate a baseline axis-aligned bounding box area based on the
    // max segment distance for subdividing. This will be used to do quick
    // checks on whether subdivision is needed or not.

    // obviously this circumferences is just an estimate, but good enough
    var base_screen_space_circumference = 360.0 / _this._degrees_between_points * _this._max_segment_pixel_distance;

    var base_screen_space_diameter = base_screen_space_circumference / Math.PI;

    // w * h
    _this._base_screen_area = base_screen_space_diameter * base_screen_space_diameter;

    _this._segmented_circle_points = [];
    _this._subdivided_screen_points = [];

    var number_of_points = Math.floor(360 / _this._degrees_between_points);

    for (var i = 0; i < number_of_points; ++i) {
      _this._segmented_circle_points.push(_LatLonViewIntersectUtils2.default.buildProjectedPointData());
    }
    return _this;
  }

  _createClass(LatLonCircle, [{
    key: "setScale",
    value: function setScale(scale) {
      this.radius = this._initial_radius * Math.min(scale[0], scale[1]);
    }
  }, {
    key: "resetInitialRadius",
    value: function resetInitialRadius() {
      this._initial_radius = this.radius;
    }

    /**
     * Updates the static points initially approximating the full circle arc
     * @param {CircleDescriptor} [circle_descriptor] Optional circle descriptor for this LatLonCircle instance used
     *                                               as input for point-on-circle initialization routines
     */

  }, {
    key: "_updateGeom",
    value: function _updateGeom() {
      var circle_descriptor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (this._geomDirty || this._boundsOutOfDate) {
        if (circle_descriptor === null) {
          circle_descriptor = createCircleDescriptor(this);
        }

        AABox2d.initEmpty(this._aabox);

        for (var index = 0; index < this._segmented_circle_points.length; ++index) {
          var point_data = this._segmented_circle_points[index];
          var lonlat_point = point_data.lonlat_point,
              merc_point = point_data.merc_point;

          var angle_degrees = index * this._degrees_between_points;
          var angle_radians = angle_degrees * MathExt.DEG_TO_RAD;

          // store the angle for later validation
          point_data.angle_degrees = angle_degrees;

          // rotate the sample point around the circle center using the radius distance in radians
          initializePointOnCircle(circle_descriptor, lonlat_point, angle_radians);

          // convert from lon/lat to mercator
          LatLonUtils.conv4326To900913(merc_point, lonlat_point);

          // update the bounds
          AABox2d.encapsulatePt(this._aabox, this._aabox, merc_point);
        }

        // re-adjust the pivot as it's not necessarily right in the center of the bounds.
        var pivot = Point2d.create(0, 0);
        AABox2d.getCenter(pivot, this._aabox);
        Point2d.sub(pivot, pivot, circle_descriptor.center_mercator);
        this.pivot = pivot;

        this._geomDirty = false;
        this._boundsOutOfDate = false;
      }
    }

    /**
     * Updates the internal subdivided geometry representation of the circle for drawing.
     * This method will auto-subdivide the initial set of line segments approximating the
     * circle where appropriate.
     *
     * @param {Mat2d} world_to_screen_matrix web-mercator-to-pixel transformation matrix for the current view
     * @returns
     */

  }, {
    key: "_updateGeomForView",
    value: function _updateGeomForView(world_to_screen_matrix) {
      if (this._viewDirty || this._geomDirty || this._boundsOutOfDate) {
        var circle_descriptor = createCircleDescriptor(this);

        // update the initial set of line segments to start with
        this._updateGeom(circle_descriptor);

        this._subdivided_screen_points = [];
        if (this._segmented_circle_points.length === 0) {
          return;
        }

        // calculate the bounds intersection between the current view bounds
        // and the bounds of this shape
        var world_bounds = this._draw_engine.camera.worldViewBounds;
        var world_intersect_bounds = AABox2d.create();

        // NOTE: this._aabox would have already been updated in the above _updateGeom()
        // call, so can go directly to the _aabox member rather than throw the this.aabox
        // getter
        AABox2d.intersection(world_intersect_bounds, this._aabox, world_bounds);
        if (AABox2d.isEmpty(world_intersect_bounds)) {
          // Early out, can skip any subdivision checks if the circle is out-of-view.
          // This is guaranteed to work as long as the _degrees_between_points is a
          // a divisor of 90 degrees.
          return;
        }

        // calculate the screen area of the circle. If it's small in screen space, we
        // know we don't have to subdivide and can skip the more costly per-line-segment
        // subdivision checks.
        var screen_aabox = AABox2d.clone(this._aabox);
        AABox2d.transformMat2d(screen_aabox, screen_aabox, world_to_screen_matrix);
        var shape_screen_area = AABox2d.area(screen_aabox);
        var subdivide = shape_screen_area > this._base_screen_area;

        // convert our intersection bounds to WGS84 lon/lat
        _LatLonViewIntersectUtils2.default.boundsConv900913to4326(world_bounds, world_bounds);
        _LatLonViewIntersectUtils2.default.boundsConv900913to4326(world_intersect_bounds, world_intersect_bounds);

        var start_point_data = this._segmented_circle_points[0];
        var end_point_data = null;

        // update the screen-space projection of the point. Note: this is not done in _updateGeom.
        // Only the mercator/WGS84 coords are updated there.
        Point2d.transformMat2d(start_point_data.screen_point, start_point_data.merc_point, world_to_screen_matrix);

        this._subdivided_screen_points.push(Point2d.clone(start_point_data.screen_point));

        if (subdivide) {
          var initial_point_data = start_point_data;
          for (var i = 1; i < this._segmented_circle_points.length; i += 1) {
            end_point_data = this._segmented_circle_points[i];
            Point2d.transformMat2d(end_point_data.screen_point, end_point_data.merc_point, world_to_screen_matrix);

            // subdivide this line segment if necessary
            subdivideArc(this._subdivided_screen_points, circle_descriptor, start_point_data, end_point_data, start_point_data.angle_degrees, this._degrees_between_points, world_intersect_bounds, world_to_screen_matrix);
            this._subdivided_screen_points.push(Point2d.clone(end_point_data.screen_point));

            start_point_data = end_point_data;
          }

          end_point_data = initial_point_data;

          // subdivide the line segment that closes the circle loop
          subdivideArc(this._subdivided_screen_points, circle_descriptor, start_point_data, initial_point_data, start_point_data.angle_degrees, this._degrees_between_points, world_intersect_bounds, world_to_screen_matrix);

          if (this._subdivided_screen_points.length === this._segmented_circle_points.length) {
            // this means no subdivision was actually performed. We need to double check the edge case where you
            // are zoomed in far enough where there are no line segments for the circle that intersect the view bounds,
            // but its arc does

            // So first calculate real distances for each corner of the bounds.
            var _getBoundsDistanceDat = getBoundsDistanceData(circle_descriptor.center_lonlat, world_bounds),
                min_bounds_dist = _getBoundsDistanceDat.min_bounds_dist,
                max_bounds_dist = _getBoundsDistanceDat.max_bounds_dist,
                bounds_distances = _getBoundsDistanceDat.bounds_distances;

            if (this._radius >= min_bounds_dist && this._radius <= max_bounds_dist) {
              var _subdivided_screen_po;

              // The arc of the circle actually crosses the view. We need to add a new point to the original list of
              // segmented circle points to give more precision in the area we are zoomed in on. To do this we will
              // get the angle between the center of the circle and the center of the bounds. This will tell us which
              // two original segmented points are its neighbors, and then subdivide with the two new line segments.
              var bounds_center = Point2d.create();
              AABox2d.getCenter(bounds_center, world_bounds);
              var bounds_center_radians = Point2d.clone(bounds_center);
              Vec2d.scale(bounds_center_radians, bounds_center_radians, MathExt.DEG_TO_RAD);

              var that = this;
              var start_segment_idx = -1;
              var new_subdivided_points = subdivideCircleArcAtPoint(circle_descriptor, bounds_center, bounds_center_radians, world_bounds, world_to_screen_matrix, function (angle_degrees, new_point_data) {
                // we now know the angle to the center of the view bounds.
                // We can then easily determine which two original static
                // points would represent the circle arc that covers that
                // angle.
                start_segment_idx = Math.floor(angle_degrees / that._degrees_between_points);
                var start_point = that._segmented_circle_points[start_segment_idx];
                var start_angle = start_point.angle_degrees;
                var end_angle = start_angle + that._degrees_between_points;
                var end_segment_idx = start_segment_idx === that._segmented_circle_points.length - 1 ? 0 : start_segment_idx + 1;
                var end_point = that._segmented_circle_points[end_segment_idx];
                return { start_angle: start_angle, start_point: start_point, end_angle: end_angle, end_point: end_point };
              });

              // insert the new subdivided points in the appropriate place
              (_subdivided_screen_po = this._subdivided_screen_points).splice.apply(_subdivided_screen_po, [start_segment_idx + 1, 0].concat(_toConsumableArray(new_subdivided_points)));
            } else if (this._radius > max_bounds_dist) {
              // hit an edge case here where you zoomed in far enough that both the original circle line segment and its respective arc
              // are not visible in the view but end up on opposite sides of the view bounds. In other words,
              // the original line-segmented circle does not overlap the view but the real circle does. So you've zoomed in
              // far enough to be completely inside that gap. To handle this case, we just need to add new points
              // so that the view is fully covered.

              // the last element in the view_bounds_distance array will have the max distance
              var bounds_point_lonlat = bounds_distances[bounds_distances.length - 1].point;
              var bounds_point_radians = Point2d.clone(bounds_point_lonlat);
              Vec2d.scale(bounds_point_radians, bounds_point_radians, MathExt.DEG_TO_RAD);

              var _getClosestPointOnCir3 = getClosestPointOnCircleArc(circle_descriptor, bounds_point_lonlat, bounds_point_radians, world_to_screen_matrix),
                  angle_degrees = _getClosestPointOnCir3.angle_degrees,
                  closest_point_data = _getClosestPointOnCir3.closest_point_data;

              var _start_segment_idx = Math.floor(angle_degrees / this._degrees_between_points);

              this._subdivided_screen_points.splice(_start_segment_idx + 1, 0, closest_point_data.screen_point);
            }
          }
        } else {
          // no subdivision, so just carry on transforming the rest of the static points
          // to screen space.
          for (var _i = 1; _i < this._segmented_circle_points.length; _i += 1) {
            var point_data = this._segmented_circle_points[_i];
            Point2d.transformMat2d(point_data.screen_point, point_data.merc_point, world_to_screen_matrix);

            this._subdivided_screen_points.push(Point2d.clone(point_data.screen_point));
          }
        }

        // NOTE: we are not re-adding the first point as the draw call will close the loop

        console.assert(!this._geomDirty);
        // console.assert(!this._boundsOutOfDate)
        this._viewDirty = false;
      }
    }
  }, {
    key: "getDimensions",
    value: function getDimensions() {
      return [this.width, this.height];
    }
  }, {
    key: "_updateAABox",
    value: function _updateAABox() {
      this._updateGeom();
    }
  }, {
    key: "_draw",
    value: function _draw(ctx) {
      // separate the model-view-matrix (this._fullXform) into the model matrix (globalXform)
      // and the view-projection matrix for separable components and to minimize
      // the amount of math applied.

      // invert the model matrix
      var xform = Mat2d.clone(this.globalXform);
      Mat2d.invert(xform, xform);

      // and multiply w/ model-view-projection matrix resulting in just the
      // view-projection matrix, or, in other words, the world-space-to-screen-space
      // transformation matrix
      Mat2d.multiply(xform, this._fullXform, xform);

      ctx.setTransform(1, 0, 0, 1, 0, 0);

      this._updateGeomForView(xform);

      if (this._subdivided_screen_points.length) {
        ctx.moveTo(this._subdivided_screen_points[0][0], this._subdivided_screen_points[0][1]);
        for (var i = 1; i < this._subdivided_screen_points.length; i += 1) {
          ctx.lineTo(this._subdivided_screen_points[i][0], this._subdivided_screen_points[i][1]);
        }
        ctx.closePath();
      }
    }

    /**
     * Extra debug draw function to visualize the extra subdivided points and the original
     * line segments.
     * @param {CanvasRenderingContext2d} ctx
     */

  }, {
    key: "_drawDebug",
    value: function _drawDebug(ctx) {
      if (this._segmented_circle_points.length) {
        ctx.save();

        ctx.strokeStyle = "white";
        ctx.beginPath();
        var curr_pt = this._segmented_circle_points[0];
        ctx.moveTo(curr_pt.screen_point[0], curr_pt.screen_point[1]);
        for (var i = 1; i < this._segmented_circle_points.length; i += 1) {
          curr_pt = this._segmented_circle_points[i];
          ctx.lineTo(curr_pt.screen_point[0], curr_pt.screen_point[1]);
        }
        ctx.closePath();
        ctx.stroke();

        ctx.fillStyle = "orange";
        this._subdivided_screen_points.forEach(function (point) {
          ctx.beginPath();
          ctx.arc(point[0], point[1], 3, 0, MathExt.TWO_PI, false);
          ctx.fill();
        });

        ctx.fillStyle = "red";
        this._segmented_circle_points.forEach(function (point_data) {
          ctx.beginPath();
          ctx.arc(point_data.screen_point[0], point_data.screen_point[1], 5, 0, MathExt.TWO_PI, false);
          ctx.fill();
        });

        ctx.restore();
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return Object.assign(_get(LatLonCircle.prototype.__proto__ || Object.getPrototypeOf(LatLonCircle.prototype), "toJSON", this).call(this), {
        type: "LatLonCircle" // this must match the name of the class
      });
    }
  }, {
    key: "initialRadius",
    set: function set(radius) {
      this.radius = radius;
      this._initial_radius = radius;
    }
  }, {
    key: "width",
    get: function get() {
      this._updateAABox();
      return this._aabox[2] - this._aabox[0];
    }
  }, {
    key: "height",
    get: function get() {
      this._updateAABox();
      return this._aabox[3] - this._aabox[1];
    }
  }]);

  return LatLonCircle;
}(MapdDraw.Circle);

exports.default = LatLonCircle;

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utilsLatlon = __webpack_require__(24);

var LatLonUtils = _interopRequireWildcard(_utilsLatlon);

var _mapdDraw = __webpack_require__(13);

var MapdDraw = _interopRequireWildcard(_mapdDraw);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var AABox2d = MapdDraw.AABox2d,
    Mat2d = MapdDraw.Mat2d,
    Point2d = MapdDraw.Point2d,
    Vec2d = MapdDraw.Vec2d;

var MathExt = MapdDraw.Math;

/**
 * Does an initial check to see if two line segments might intersect. The numerator/denominator
 * arguments refer to the numerator/denominator of using a bezier form for describing the line intersection:
 * https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line_segment
 * This can check the numerator/denominator of the linear system of equations to determine if
 * they can intersect, avoiding the actual division. This is further detailed in "Chapter IV.6: Faster Line Segment Intersection"
 * of the book Graphics Gems III. Academic Press, Inc. pp. 199202.
 * @param {number} numerator Numerator of the linear system of equations for bezier-based line segment intersections
 * @param {number} denominator Denominator of the linear system of equations for basier-based line segment intersections
 * @returns {boolean}
 */
function canIntersect(numerator, denominator) {
  if (denominator > 0) {
    if (numerator >= 0 && (numerator < denominator || MathExt.floatingPtEquals(numerator, denominator))) {
      return true;
    }
  } else if (numerator <= 0 && (numerator > denominator || MathExt.floatingPtEquals(numerator, denominator))) {
    return true;
  }
  return false;
}

exports.default = {
  /**
   * @typedef {object} ProjectedPointData
   * Maintains the various projection states for a specific point
   *
   * @property {Point2d} merc_point 2D point defined in web-mercator projected space
   * @property {Point2d} screen_point 2D point defined in screen space
   * @property {Point2d} lonlat_point 2D point defined in lat/lon WGS84 space
   * @property {Point2d} [radians_point] Optional 2D point that is a copy of the lonlat_point,
   *                                     but defined in radians rather than degrees
   */

  /**
   * Initializes a structure that is meant to define a point/vertex projected
   * in 3-different spaces, lat/lon WGS84, web-mercator-projected, and screen-space
   * coordinates. This only builds struct. The point has not been defined or projected
   * yet.
   *
   * @returns {ProjectedPointData}
   */
  buildProjectedPointData: function buildProjectedPointData() {
    var include_radians = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var rtn_obj = {
      merc_point: Point2d.create(),
      screen_point: Point2d.create(),
      lonlat_point: Point2d.create()
    };
    if (include_radians) {
      rtn_obj.radians_point = Point2d.create();
    }
    return rtn_obj;
  },

  /**
   * Copies projected point data.
   * @param {ProjectedPointData} out_point_data The data to be copied to
   * @param {ProjectedPointData} in_point_data  The data to be copied from
   */
  copyProjectedPoint: function copyProjectedPoint(out_point_data, in_point_data) {
    Point2d.copy(out_point_data.merc_point, in_point_data.merc_point);
    Point2d.copy(out_point_data.screen_point, in_point_data.screen_point);
    Point2d.copy(out_point_data.lonlat_point, in_point_data.lonlat_point);
    if (in_point_data.include_radians !== undefined) {
      Point2d.copy(out_point_data.radians_point, in_point_data.radians_point);
    } else {
      delete out_point_data.radians_point;
    }
  },

  /**
   * Using a point defined in web-mercator space as input, initializes a ProjectedPointData struct
   * by transforming that merc point into lat/lon WGS84 (in degrees and optionally radians) and screen space.
   * @param {Point2d} initial_merc_point Initial web-mercator projected point to transform
   * @param {ProjectedPointData} out_point_data Struct to be initialized with the various projections of the input point
   * @param {Mat2d} model_matrix The affine transformation matrix of the parent of the initial mercator point
   * @param {Mat2d} world_to_screen_matrix The transformation matrix defining the world-to-screen space transformation
   * @returns {ProjectedPointData} returns the input out_point_data argument after it has been initialized
   */
  projectPoint: function projectPoint(initial_merc_point, out_point_data, model_matrix, world_to_screen_matrix) {
    if (model_matrix === null) {
      Point2d.copy(out_point_data.merc_point, initial_merc_point);
    } else {
      Point2d.transformMat2d(out_point_data.merc_point, initial_merc_point, model_matrix);
    }

    if (world_to_screen_matrix !== null) {
      Point2d.transformMat2d(out_point_data.screen_point, out_point_data.merc_point, world_to_screen_matrix);
    }

    LatLonUtils.conv900913To4326(out_point_data.lonlat_point, out_point_data.merc_point);

    if (out_point_data.radians_point !== undefined) {
      Vec2d.scale(out_point_data.radians_point, out_point_data.lonlat_point, MathExt.DEG_TO_RAD);
    }

    return out_point_data;
  },

  /**
   * @typedef {object} ViewBoundsIntersectData
   *
   * Describes intersection data defined by intersecting a specific line segment
   * against a view. This intersection data will include points that either
   * intersect or is contained by a view. The arrays of intersection points will
   * either be of size 2 (line segment intersects or is contained by a view) or
   * be size 0 (line segment does not intersect or is not contained by a view)
   *
   * @property {Point2d[]} lonlat_pts Array of points defined in WGS84 lat/lon space that either intersect or are contained by a view
   * @property {Point2d[]} screen_pts Array of points defined in screen space that either intersect or are contained by a view
   *                                           This is the same set of points as lonlat_pts above, but transformed into screen space.
   * @property {number[]} pts_t Array of real numbers between [0-1] indicating the normalized distance of the intersection pts relative to
   *                            the original line segment. For example, if t=0, the intersection point is the starting point of the line
   *                            segment. If t=1, it is the end point of the line segment, and if t=0.5, it is the midpoint of the
   *                            line segment. This will be in ascending sorted order.
   * @property {boolean} subdivide Set to true if the caller should subdivide the insection points found here.
   *                               For instance, We may not want to subdivide if the intersection line segment is completely horizontal or vertical
   */

  /**
   * Determines the intersect/contained points of a line segment
   * defined by a start/end point against the bounds of a view
   * Returns a struct describing any intersection points (will either be 2 or 0 points)
   * as well as a flag indicating whether the line segment defined by the intersection
   * points should be subdivided for draw.
   * @param {ProjectedPointData} start_point_data The start point of the line segment
   * @param {ProjectedPointData} end_point_data The end point of the line segment
   * @param {AABox2d} view_aabox Axis-aligned bounding box describing the
   *                                      intersection between the aabox of the current shape
   *                                      and the current view
   * @param {Mat2d} world_to_screen_matrix The world-to-screen transformation matrix
   * @returns {ViewBoundsIntersectData}
   */
  intersectViewBounds: function intersectViewBounds(start_point_data, end_point_data, view_aabox, world_to_screen_matrix) {
    var x1 = start_point_data.lonlat_point[0];
    var y1 = start_point_data.lonlat_point[1];
    var x2 = end_point_data.lonlat_point[0];
    var y2 = end_point_data.lonlat_point[1];

    var line_aabox = AABox2d.create();
    AABox2d.encapsulatePt(line_aabox, line_aabox, start_point_data.lonlat_point);
    AABox2d.encapsulatePt(line_aabox, line_aabox, end_point_data.lonlat_point);

    var intersect_aabox = AABox2d.create();
    AABox2d.intersection(intersect_aabox, view_aabox, line_aabox);

    // The current stored t value for bounds intersection points.
    // The max t for intersection points will be 1, so setting this to
    // 2 as an initial value. Reminder we will return with 2 points, and
    // those 2 points should be returned in t ascending order to be continuous
    // with the start-point/end-point arguments passed. So when the 2nd intersect
    // point has been found, the comparison of the t for that intersection and
    // current_t (which would be associated with the first interesection
    // point) will determine whether to insert the new intersection point to the
    // front or the back of the array
    var current_t = 2.0;

    /**
     * The returned object. It will either be empty (no interesections with the
     * view bounds) or it will have exactly 2 intersection points.
     */
    var rtn_obj = {
      /** intersect points in lat/lon space */
      lonlat_pts: [],

      /** intersect points in screen space */
      screen_pts: [],

      // the normalized distance of each intersection point relative to the original
      // line segment. This will be in ascending sorted order.
      pts_t: [],

      /** whether the caller should subdivide the line segments between the
       * intersection points found here */
      subdivide: false
    };

    if (AABox2d.isEmpty(intersect_aabox)) {
      // no intersection with the view bounds
      // return empty intersection object
      return rtn_obj;
    }

    var delta_x = x1 - x2;
    var delta_y = y1 - y2;

    if (delta_x === 0 || delta_y === 0) {
      // Early out:
      // The line segment lies on a line of latitude or longitude
      // Such lines do not need to be subdivided in web-mercator-projected
      // space because they will be vertical/horizontal when projected (i.e.
      // they will not exhibit any curvature)
      // Return empty object.
      // TODO(croot): support other projections?
      return rtn_obj;
    }

    if (AABox2d.equals(intersect_aabox, line_aabox)) {
      // Early out: the intersection bounding box equals the
      // line segment's bounding box, meaning the entire line
      // segment is in view. Add the start/end points as intersection
      // points and mark the segment as needing subdividing.
      rtn_obj.lonlat_pts.push(start_point_data.lonlat_point);
      rtn_obj.screen_pts.push(start_point_data.screen_point);
      rtn_obj.pts_t.push(0);
      rtn_obj.lonlat_pts.push(end_point_data.lonlat_point);
      rtn_obj.screen_pts.push(end_point_data.screen_point);
      rtn_obj.pts_t.push(1);
      rtn_obj.subdivide = true;
    } else {
      // need to do intersection checks against the side of the intersection bounds. There will be
      // exactly 2 intersections. The intersection check is a slightly simplified version of a
      // bezier-based line segment intersection formula:
      // https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line_segment
      // This formula can be slightly simplified due to the intersection bounds being axis-aligned.
      // Ultimately you can eliminate some operations knowing that coordinate differences will be 0

      if (intersect_aabox[AABox2d.MINX] === intersect_aabox[AABox2d.MAXX] || intersect_aabox[AABox2d.MINY] === intersect_aabox[AABox2d.MAXY]) {
        // early out: there's no intersection with the view bounds
        // if the intersection aabox has no size in either dimension
        // by the time we reach here. The case where the line is horizontal/vertical
        // or the line is fully contained by the view should already be handled.
        // return empty intersection object
        return rtn_obj;
      }

      var x3 = intersect_aabox[AABox2d.MINX];
      var x4 = intersect_aabox[AABox2d.MAXX];
      var y3 = intersect_aabox[AABox2d.MINY];
      var y4 = intersect_aabox[AABox2d.MAXY];

      var check_full_intersect = function check_full_intersect(numerator_t_functor, denominator_t_functor, numerator_u_functor, denominator_u_functor) {
        var denominator_t = denominator_t_functor();
        if (denominator_t === 0) {
          // colinear
          // TODO(croot): this needs filling out in the general case
          // NOTE: this should never be hit in the LonLatPoly case because of
          // the delta_x/delta_y === 0 check.
          console.assert(false, "Collinear intersection needs completing");
          return true;
        }
        var numerator_t = numerator_t_functor();
        if (canIntersect(numerator_t, denominator_t) && canIntersect(numerator_u_functor(), denominator_u_functor())) {
          // NOTE: denominator_t should never be zero. There's an early out for
          // that case.
          var t = numerator_t / denominator_t;

          if (MathExt.floatingPtEquals(t, current_t)) {
            // already found this specific interesection, so don't re-add
            // In this specific use case, since we're doing intersection tests
            // against each wall of an axis-aligned bounding box, the original
            // line-segment can intersect two walls that meet at a corner. In
            // that case one of the endpoitns of the original line defines the
            // bounds at that corner. That can result in recalculating the same
            // t at the corner for the two separate walls, so avoiding adding
            // a duplicate intersection point with this test.
            return false;
          }

          var lonlat_pt = null;
          var screen_pt = null;
          if (MathExt.floatingPtEquals(t, 0)) {
            // the intersection point is the start point of the original segment, so
            // just re-use the start coord
            lonlat_pt = start_point_data.lonlat_point;
            screen_pt = start_point_data.screen_point;
          } else if (MathExt.floatingPtEquals(t, 1)) {
            // the intersection point is the end point of the original segment, so
            // just re-use the end coord
            lonlat_pt = end_point_data.lonlat_point;
            screen_pt = end_point_data.screen_point;
          } else {
            // calculate the lon/lat and screen point for the
            // intersection point given t
            var new_lonlat_pt = Point2d.create(-delta_x * t, -delta_y * t);
            Point2d.addVec2(new_lonlat_pt, start_point_data.lonlat_point, new_lonlat_pt);
            lonlat_pt = new_lonlat_pt;

            var new_screen_pt = Point2d.clone(new_lonlat_pt);
            // conver the new segment point back to mercator for drawing
            LatLonUtils.conv4326To900913(new_screen_pt, new_screen_pt);

            // now convert to screen space
            Point2d.transformMat2d(new_screen_pt, new_screen_pt, world_to_screen_matrix);
            screen_pt = new_screen_pt;
          }
          rtn_obj.subdivide = true;

          // insersection points must be stored by t in ascending order.
          // There will be exactly 2 points in the end, so just need to check
          // whether to insert this new intersection point at the front or back
          // of the returned point array
          if (t < current_t) {
            rtn_obj.lonlat_pts.splice(0, 0, lonlat_pt);
            rtn_obj.screen_pts.splice(0, 0, screen_pt);
            rtn_obj.pts_t.splice(0, 0, t);
          } else {
            rtn_obj.lonlat_pts.push(lonlat_pt);
            rtn_obj.screen_pts.push(screen_pt);
            rtn_obj.pts_t.push(t);
          }
          current_t = t;
          return true;
        }
        return false;
      };

      // check left-edge of the bounds first, we know that delta_x = 0 for the points defining the left edge
      var delta_edge = x1 - x3;
      check_full_intersect(function () {
        return delta_edge;
      }, function () {
        return delta_x;
      }, function () {
        return -delta_x * (y1 - y3) - -delta_y * delta_edge;
      }, function () {
        return delta_x * (y3 - y4);
      });

      // bounds top-edge
      delta_edge = y1 - y3;
      check_full_intersect(function () {
        return -delta_edge;
      }, function () {
        return -delta_y;
      }, function () {
        return -delta_x * delta_edge - -delta_y * (x1 - x3);
      }, function () {
        return -delta_y * (x3 - x4);
      });

      if (rtn_obj.lonlat_pts.length < 2) {
        // bounds right-edge, we know that delta_x = 0 for the points defining the right edge
        delta_edge = x1 - x4;
        check_full_intersect(function () {
          return delta_edge;
        }, function () {
          return delta_x;
        }, function () {
          return -delta_x * (y1 - y3) - -delta_y * delta_edge;
        }, function () {
          return delta_x * (y3 - y4);
        });

        if (rtn_obj.lonlat_pts.length < 2) {
          // bounds top edge
          delta_edge = y1 - y4;
          check_full_intersect(function () {
            return -delta_edge;
          }, function () {
            return -delta_y;
          }, function () {
            return -delta_x * delta_edge - -delta_y * (x1 - x3);
          }, function () {
            return -delta_y * (x3 - x4);
          });
        }
      }
    }

    return rtn_obj;
  },

  /**
   * Converts an axis-aligned bounding box in web-mercator (srid 900913) coordinates
   * to WGS84 (srid: 4326) coordinates.
   * @param {AABox2d} output_bounds The bounds to store the results of the 900913->4326 conversion
   * @param {AABox2d} input_bounds The bounds in 900913 coordinate to convert to 4326
   * @returns {AABox2d} Returns output_bounds. The return can be useful for chaining.
   */
  boundsConv900913to4326: function boundsConv900913to4326(output_bounds, input_bounds) {
    output_bounds[AABox2d.MINX] = LatLonUtils.conv900913To4326X(input_bounds[AABox2d.MINX]);
    output_bounds[AABox2d.MAXX] = LatLonUtils.conv900913To4326X(input_bounds[AABox2d.MAXX]);
    output_bounds[AABox2d.MINY] = LatLonUtils.conv900913To4326Y(input_bounds[AABox2d.MINY]);
    output_bounds[AABox2d.MAXY] = LatLonUtils.conv900913To4326Y(input_bounds[AABox2d.MAXY]);

    return output_bounds;
  }
};

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _utilsLatlon = __webpack_require__(24);

var LatLonUtils = _interopRequireWildcard(_utilsLatlon);

var _mapdDraw = __webpack_require__(13);

var MapdDraw = _interopRequireWildcard(_mapdDraw);

var _LatLonViewIntersectUtils = __webpack_require__(191);

var _LatLonViewIntersectUtils2 = _interopRequireDefault(_LatLonViewIntersectUtils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AABox2d = MapdDraw.AABox2d,
    Mat2d = MapdDraw.Mat2d,
    Point2d = MapdDraw.Point2d;

var MathExt = MapdDraw.Math;

var LatLonPoly = function (_MapdDraw$Poly) {
  _inherits(LatLonPoly, _MapdDraw$Poly);

  function LatLonPoly(draw_engine, opts) {
    _classCallCheck(this, LatLonPoly);

    if (opts.debug === undefined) {
      // if true, will activate the use of the _drawDebug method for drawing
      // extra debug info on top of the original shape draw.
      opts.debug = true;
    }

    var _this = _possibleConstructorReturn(this, (LatLonPoly.__proto__ || Object.getPrototypeOf(LatLonPoly)).call(this, opts));

    _this._draw_engine = draw_engine;

    _this._screenPts = [];
    _this._geomDirty = true;
    _this._viewDirty = true;

    // set the viewDirty flag to force a rebuild of the drawn vertices when
    // the camera changes. This is required because we are doing a screen-space-based
    // line subdivision that is obviously dependent on the view.
    var that = _this;
    _this._draw_engine.camera.on("changed", function (event) {
      that._viewDirty = true;
    });

    // maximum length of subdivided line segment in pixels
    _this._max_segment_pixel_distance = 40;
    return _this;
  }

  /**
   * Determines whether a line segment defined by a start/end point
   * should be subdivided for drawing. If the segment should be subdivided,
   * will append subdivided points the array of screen-projected points
   * to draw.
   * @param {ProjectedPointData} start_point_data Start point of the line segment
   * @param {ProjectedPointData} end_point_data End point of the line segment
   * @param {AABox2d} view_aabox Axis-aligned bounding box describing the
   *                                      intersection between the shape and the current view
   *                                      in WGS84 lat/lon coords
   * @param {Mat2d} world_to_screen_matrix Matrix defining world-to-screen transformation
   * @returns
   */


  _createClass(LatLonPoly, [{
    key: "_subdivideLineSegment",
    value: function _subdivideLineSegment(start_point_data, end_point_data, view_aabox, world_to_screen_matrix) {
      var view_intersect_data = _LatLonViewIntersectUtils2.default.intersectViewBounds(start_point_data, end_point_data, view_aabox, world_to_screen_matrix);

      if (!view_intersect_data.subdivide) {
        return;
      }

      console.assert(view_intersect_data.lonlat_pts.length === 2);

      var _view_intersect_data$ = _slicedToArray(view_intersect_data.lonlat_pts, 2),
          start_lonlat_pt = _view_intersect_data$[0],
          end_lonlat_pt = _view_intersect_data$[1];

      var _view_intersect_data$2 = _slicedToArray(view_intersect_data.screen_pts, 2),
          start_screen_pt = _view_intersect_data$2[0],
          end_screen_pt = _view_intersect_data$2[1];

      var distance = Point2d.distance(start_screen_pt, end_screen_pt);
      if (distance > this._max_segment_pixel_distance) {
        // do subdivisions in a cartesian space using lon/lat
        // This is how ST_Contains behaves in the server right now
        var num_subdivisions = Math.ceil(distance / this._max_segment_pixel_distance);
        for (var i = 1; i < num_subdivisions; i += 1) {
          var new_segment_point = Point2d.create();
          Point2d.lerp(new_segment_point, start_lonlat_pt, end_lonlat_pt, i / num_subdivisions);
          // conver the new segment point back to mercator for drawing
          LatLonUtils.conv4326To900913(new_segment_point, new_segment_point);

          // now convert to screen space
          Point2d.transformMat2d(new_segment_point, new_segment_point, world_to_screen_matrix);
          this._screenPts.push(Point2d.clone(new_segment_point));
        }
      }
    }

    /**
     * Updates the internal geometry representation of the polygon for drawing.
     * This means auto-subdividing line segments that are in view and are larger
     * than the max screen-space distance threshold.
     * @param {Mat2d} world_to_screen_matrix web-mercator-to-pixel transformation matrix
     */

  }, {
    key: "_updateGeom",
    value: function _updateGeom(world_to_screen_matrix) {
      if (this._viewDirty || this._geomDirty || this._boundsOutOfDate) {
        this._screenPts = [];
        if (this._verts.length === 0) {
          return;
        }

        // calculate the bounds intersection between the current view bounds
        // and the bounds of this shape
        var world_bounds = this._draw_engine.camera.worldViewBounds;
        var aabox = this.aabox;
        AABox2d.intersection(world_bounds, aabox, world_bounds);
        if (AABox2d.isEmpty(aabox)) {
          // Early out. Shape is not in view
          return;
        }

        // convert our intersection bounds to WGS84 lon/lat
        _LatLonViewIntersectUtils2.default.boundsConv900913to4326(world_bounds, world_bounds);

        // Work on 2 points at a time, swapping as we interate.
        // Keep the first point around to close the polygon loop as the final iteration
        var first_point_data = _LatLonViewIntersectUtils2.default.buildProjectedPointData();
        var start_point_data = _LatLonViewIntersectUtils2.default.buildProjectedPointData();
        var end_point_data = _LatLonViewIntersectUtils2.default.buildProjectedPointData();

        var model_xform = this.globalXform;

        // projected point data for the first vert. The point data includes the point in
        // web-mercator, wgs84 lon/lat, and screen space coordinates
        _LatLonViewIntersectUtils2.default.projectPoint(this._verts[0], first_point_data, model_xform, world_to_screen_matrix);

        _LatLonViewIntersectUtils2.default.copyProjectedPoint(start_point_data, first_point_data);

        this._screenPts.push(Point2d.clone(start_point_data.screen_point));

        var swap_tmp = null;
        for (var i = 1; i < this._verts.length; i += 1) {
          _LatLonViewIntersectUtils2.default.projectPoint(this._verts[i], end_point_data, model_xform, world_to_screen_matrix);

          // check if this line segment needs subdividing
          this._subdivideLineSegment(start_point_data, end_point_data, world_bounds, world_to_screen_matrix);
          this._screenPts.push(Point2d.clone(end_point_data.screen_point));

          // now swap the endpoints
          swap_tmp = start_point_data;
          start_point_data = end_point_data;
          end_point_data = swap_tmp;
        }

        // check if the final line segment that closes the loop needs subdividing
        this._subdivideLineSegment(start_point_data, first_point_data, world_bounds, world_to_screen_matrix);

        // NOTE: we are not re-adding the first point as the draw call will close the loop

        this._geomDirty = false;
        this._boundsOutOfDate = false;
        this._viewDirty = false;
      }
    }
  }, {
    key: "_draw",
    value: function _draw(ctx) {
      // separate the model-view-matrix (this._fullXform) into the model matrix (globalXform)
      // and the view-projection matrix for separable components and to minimize
      // the amount of math applied.

      // invert the model matrix
      var xform = Mat2d.clone(this.globalXform);
      Mat2d.invert(xform, xform);

      // and multiply w/ model-view-projection matrix resulting in just the
      // view-projection matrix, or, in other words, the world-space-to-screen-space
      // transformation matrix
      Mat2d.multiply(xform, this._fullXform, xform);
      ctx.setTransform(1, 0, 0, 1, 0, 0);

      this._updateGeom(xform);

      if (this._screenPts.length) {
        ctx.moveTo(this._screenPts[0][0], this._screenPts[0][1]);
        for (var i = 1; i < this._screenPts.length; i += 1) {
          ctx.lineTo(this._screenPts[i][0], this._screenPts[i][1]);
        }
        ctx.closePath();
      }
    }

    /**
     * Debug draw routine that visualizes the subdivided verts that are auto-generated.
     * Only works if the 'debug' option is set to true in the constructor
     * @param {CanvasRenderingContext2D} ctx
     */

  }, {
    key: "_drawDebug",
    value: function _drawDebug(ctx) {
      if (this._screenPts.length) {
        ctx.save();

        ctx.fillStyle = "orange";
        this._screenPts.forEach(function (point) {
          ctx.beginPath();
          ctx.arc(point[0], point[1], 3, 0, MathExt.TWO_PI, false);
          ctx.fill();
        });

        ctx.restore();
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return Object.assign(_get(LatLonPoly.prototype.__proto__ || Object.getPrototypeOf(LatLonPoly.prototype), "toJSON", this).call(this), {
        type: "LatLonPoly" // this must match the name of the class
      });
    }
  }]);

  return LatLonPoly;
}(MapdDraw.Poly);

exports.default = LatLonPoly;

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = coordinateGridRasterMixin;

var _core = __webpack_require__(3);

var _baseMixin = __webpack_require__(7);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

var _coordinateGridRasterMixinUi = __webpack_require__(272);

var _coordinateGridRasterMixinUi2 = _interopRequireDefault(_coordinateGridRasterMixinUi);

var _colorMixin = __webpack_require__(12);

var _colorMixin2 = _interopRequireDefault(_colorMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _marginMixin = __webpack_require__(18);

var _marginMixin2 = _interopRequireDefault(_marginMixin);

var _axios = __webpack_require__(275);

var _axios2 = _interopRequireDefault(_axios);

var _lockAxisMixin = __webpack_require__(40);

var _lockAxisMixin2 = _interopRequireDefault(_lockAxisMixin);

var _errors = __webpack_require__(37);

var _utils = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Coordinate Grid Raster is an abstract base chart designed to support coordinate grid based
 * chart types when the data is backend rendered.
 * @name coordinateGridRasterMixin
 * @memberof dc
 * @mixin
 * @mixes dc.colorMixin
 * @mixes dc.marginMixin
 * @mixes dc.baseMixin
 * @param {Object} _chart
 * @return {dc.coordinateGridRasterMixin}
 */
function coordinateGridRasterMixin(_chart, _mapboxgl, browser) {
  var _mapboxgl = typeof mapboxgl === "undefined" ? _mapboxgl : mapboxgl;

  var GRID_LINE_CLASS = "grid-line";
  var HORIZONTAL_CLASS = "horizontal";
  var VERTICAL_CLASS = "vertical";
  var Y_AXIS_LABEL_CLASS = "y-axis-label";
  var X_AXIS_LABEL_CLASS = "x-axis-label";
  var DEFAULT_AXIS_LABEL_PADDING = 12;

  var _brush = _d2.default.svg.brush();
  var _hasBeenRendered = false;
  var _scale = [1, 1];
  var _offset = [0, 0];
  var _currDataBounds = [[0, 1], [0, 1]];
  var _queryId = null;
  var _filters = [];
  var _initialFilters = null;
  var _gridInitted = false;
  var _destroyed = false;

  var NO_CACHE = false;
  var cachedXTickFormat = NO_CACHE;
  var cachedYTickFormat = NO_CACHE;

  _chart = (0, _lockAxisMixin2.default)((0, _colorMixin2.default)((0, _marginMixin2.default)((0, _baseMixin2.default)(_chart))));
  _chart._mandatoryAttributes().push("x", "y");

  _chart.resetSvg = function () {
    _chart.root().selectAll("*:not(.legend)").remove();

    return _chart.generateSvg();
  };

  _chart.filters = function () {
    return _filters;
  };

  _chart.filter = function (filters) {
    if (typeof filters === "undefined" || filters === null || filters === Symbol.for("clear")) {
      _initialFilters = _initialFilters || [[]];
      filterChartDimensions(_initialFilters[0][0], _initialFilters[0][1], true);
    } else if (Array.isArray(filters) && filters.length === 2) {
      filterChartDimensions(filters[0], filters[1], false);
    } else {
      throw new Error("Invalid filter applied. Filter must be an array with two elements");
    }

    return _chart;
  };

  function filterChartDimensions(xrange, yrange, shouldReset) {
    if (!_initialFilters) {
      _initialFilters = [[xrange, yrange]];
    }

    var xdim = _chart.xDim();
    var ydim = _chart.yDim();

    if (xdim) {
      xdim.filter(xrange);
    }

    if (ydim) {
      ydim.filter(yrange);
    }

    if (typeof _chart.getLayers === "function") {
      _chart.getLayers().forEach(function (layer) {
        if (typeof layer.xDim === "function" && typeof layer.yDim === "function") {
          xdim = layer.xDim();
          ydim = layer.yDim();
          if (xdim !== null && ydim !== null) {
            xdim.filter(xrange);
            ydim.filter(yrange);
          }
        }
      });
    }

    _filters = shouldReset ? [] : [[xrange, yrange]];
    _chart._invokeFilteredListener(_filters, false);
    _chart.xRangeFilter(xrange);
    _chart.yRangeFilter(yrange);
  }

  var _parent = void 0;
  var _g = void 0;
  var _chartBody = void 0;
  var _gl = void 0;
  var _shaderProgram = void 0,
      _fragShader = void 0,
      _vertShader = void 0;
  var _vbo = void 0;
  var _tex = void 0;
  var _img = void 0;

  var _eventHandler = void 0;
  var _interactionsEnabled = false;

  var _xOriginalDomain = void 0;
  var _xAxis = _d2.default.svg.axis().orient("bottom");
  var _xUnits = _core.units.integers;
  var _xAxisPadding = 0;
  var _xElasticity = false;
  var _xAxisLabel = void 0;
  var _xAxisLabelPadding = 0;
  var _lastXDomain = void 0;

  var _yAxis = _d2.default.svg.axis().orient("left");
  var _yAxisPadding = 0;
  var _yElasticity = false;
  var _yAxisLabel = void 0;
  var _yAxisLabelPadding = 0;

  var _renderHorizontalGridLine = false;
  var _renderVerticalGridLine = false;

  var _resizing = false;

  var _unitCount = void 0;

  var _outerRangeBandPadding = 0.5;
  var _rangeBandPadding = 0;

  var _useRightYAxis = false;

  var _maxBounds = [[-Infinity, -Infinity], [Infinity, Infinity]];

  _chart._fitToMaxBounds = function (currBounds, resizeToScale) {
    var xmin = currBounds[0][0];
    var ymin = currBounds[0][1];
    var xmax = currBounds[1][0];
    var ymax = currBounds[1][1];
    var xdiff = xmax - xmin;
    var ydiff = ymax - ymin;

    var bounds_xmin = _maxBounds[0][0];
    var bounds_ymin = _maxBounds[0][1];
    var bounds_xmax = _maxBounds[1][0];
    var bounds_ymax = _maxBounds[1][1];

    var newbounds = [[Math.max(xmin, bounds_xmin), Math.max(ymin, bounds_ymin)], [Math.min(xmax, bounds_xmax), Math.min(ymax, bounds_ymax)]];

    if (resizeToScale) {
      var newxdiff = newbounds[1][0] - newbounds[0][0];
      var newydiff = newbounds[1][1] - newbounds[0][1];

      var deltax = xdiff - newxdiff;
      var deltay = ydiff - newydiff;

      // NOTE: deltax & deltay should be >= 0
      if (deltax !== 0) {
        if (newbounds[0][0] !== bounds_xmin) {
          newbounds[0][0] = Math.max(newbounds[0][0] - deltax, bounds_xmin);
        } else if (newbounds[1][0] !== bounds_xmax) {
          newbounds[1][0] = Math.min(newbounds[1][0] + deltax, bounds_xmax);
        }
      }

      if (deltay !== 0) {
        if (newbounds[0][1] !== bounds_ymin) {
          newbounds[0][1] = Math.max(newbounds[0][1] - deltay, bounds_ymin);
        } else if (newbounds[1][1] !== bounds_ymax) {
          newbounds[1][1] = Math.min(newbounds[1][1] + deltay, bounds_ymax);
        }
      }
    }

    return newbounds;
  };

  _chart.maxBounds = function (maxBounds) {
    if (!arguments.length) {
      return _maxBounds;
    }

    // TODO(croot): verify max bounds?
    if (!(maxBounds instanceof Array) || maxBounds.length !== 2 || !(maxBounds[0] instanceof Array) || maxBounds[0].length !== 2 || !(maxBounds[1] instanceof Array) || maxBounds[1].length !== 2) {
      throw new Error("Invalid bounds argument. A bounds object should be: [[xmin, ymin], [xmax, ymax]]");
    }

    _maxBounds = [[Math.min(maxBounds[0][0], maxBounds[1][0]), Math.min(maxBounds[0][1], maxBounds[1][1])], [Math.max(maxBounds[0][0], maxBounds[1][0]), Math.max(maxBounds[0][1], maxBounds[1][1])]];

    return _chart;
  };

  _chart.unproject = function (pt) {
    var xscale = _chart.x(),
        yscale = _chart.y();
    var x = xscale ? xscale.invert(pt.x) : 0;
    var y = yscale ? yscale.invert(pt.y) : 0;
    return new _mapboxgl.Point(x, y);
  };

  _chart.enableInteractions = function (enableInteractions) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!arguments.length) {
      return _interactionsEnabled;
    }

    _interactionsEnabled = Boolean(enableInteractions);
    if (_eventHandler) {
      var map = _chart.map();
      _eventHandler.getInteractionPropNames(_chart).forEach(function (prop) {
        if (map[prop]) {
          var enable = typeof opts[prop] === "undefined" ? _interactionsEnabled : Boolean(opts[prop]);
          if (enable) {
            map[prop].enable();
          } else {
            map[prop].disable();

            if (prop === "dragPan") {
              // force a clear of the current event state on the map
              // to fully disable pans
              map[prop].onMouseUp({
                button: 0
              });
            }
          }
        }
      });
    }

    return _chart;
  };

  /**
   * When changing the domain of the x or y scale, it is necessary to tell the chart to recalculate
   * and redraw the axes. (`.rescale()` is called automatically when the x or y scale is replaced
   * with {@link #dc.coordinateGridRasterMixin+x .x()} or {@link #dc.coordinateGridRasterMixin+y .y()}, and has
   * no effect on elastic scales.)
   * @name rescale
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.rescale = function () {
    _unitCount = undefined;
    _resizing = true;
    return _chart;
  };

  _chart.resizing = function () {
    return _resizing;
  };

  function initWebGL(canvas) {
    var webglAttrs = {
      alpha: true,
      antialias: true,
      // premultipliedAlpha: false,
      depth: false,
      stencil: false,
      failIfMajorPerformanceCaveat: false,
      preserveDrawingBuffer: false
    };
    _gl = canvas.getContext("webgl", webglAttrs) || canvas.getContext("experimental-webgl", webglAttrs);

    if (!_gl) {
      throw { name: "WebGL", message: 'WebGL Not Enabled' };
    }
    var vertShaderSrc = "" + "precision mediump float;\n" + "attribute vec2 a_pos;\n" + "attribute vec2 a_texCoords;\n" + "\n" + "varying vec2 v_texCoords;\n" + "uniform vec2 u_texCoordsScale;\n" + "uniform vec2 u_texCoordsOffset;\n" + "\n" + "void main(void) {\n" + "    gl_Position = vec4(a_pos, 0, 1);\n" + "\n" + "    v_texCoords = u_texCoordsScale * a_texCoords + u_texCoordsOffset;\n" +
    // NOTE: right now it seems that unpacking the base64 array via the
    // createImageBitmap() call puts pixel 0,0 in the upper left-hand
    // corner rather than the lower left-hand corner in the way that
    // webgl expects, so flipping the y texture coords below.
    // If another way of extracing the base64 image data is done
    // that doesn"t flip the image, then flip the y tex coords
    "    v_texCoords.y = (1.0 - v_texCoords.y);\n" + "}";

    var fragShaderSrc = "" + "precision mediump float;\n" + "\n" + "uniform sampler2D u_sampler;\n" + "\n" + "varying vec2 v_texCoords;\n" + "\n" + "void main() {\n" + "    if (v_texCoords[0] >= 0.0 && v_texCoords[0] <= 1.0 &&\n" + "        v_texCoords[1] >= 0.0 && v_texCoords[1] <= 1.0) {\n" + "        gl_FragColor = texture2D(u_sampler, v_texCoords);\n" + "    }\n" + "}";

    var gl = _gl;

    var program = _shaderProgram = gl.createProgram();

    var fragShader = _fragShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragShader, fragShaderSrc);
    gl.compileShader(fragShader);
    if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
      throw new Error("Error compiling fragment shader: " + gl.getShaderInfoLog(fragShader));
    }
    gl.attachShader(program, fragShader);

    var vertShader = _vertShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertShader, vertShaderSrc);
    gl.compileShader(vertShader);
    if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
      throw new Error("Error compiling vertex shader: " + gl.getShaderInfoLog(vertShader));
    }
    gl.attachShader(program, vertShader);

    gl.linkProgram(program);
    gl.validateProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      throw new Error("Error linking shader program: " + gl.getProgramInfoLog(program));
    }

    program.a_pos = gl.getAttribLocation(program, "a_pos");
    program.a_texCoords = gl.getAttribLocation(program, "a_texCoords");
    gl.enableVertexAttribArray(program.a_pos);
    gl.enableVertexAttribArray(program.a_texCoords);

    program.u_texCoordsScale = gl.getUniformLocation(program, "u_texCoordsScale");
    program.u_texCoordsOffset = gl.getUniformLocation(program, "u_texCoordsOffset");
    program.u_sampler = gl.getUniformLocation(program, "u_sampler");

    gl.useProgram(program);

    var vbo = _vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);

    var vertData = [-1, -1, 0, 0, 1, -1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1]; // unflipped

    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertData), gl.STATIC_DRAW);
    gl.vertexAttribPointer(_shaderProgram.a_pos, 2, gl.FLOAT, false, 16, 0);
    gl.vertexAttribPointer(_shaderProgram.a_texCoords, 2, gl.FLOAT, false, 16, 8);

    createGLTexture();
  }

  function destroy() {
    _destroyed = true;

    destroyWebGL();

    if (_eventHandler) {
      _eventHandler.destroy();
    }
    _eventHandler = null;

    if (_chartBody && _chartBody.parentNode) {
      _chartBody.parentNode.removeChild(node);
    }

    _chartBody = null;
  }

  function destroyWebGL() {
    var gl = _gl;
    if ((typeof _shaderProgram === "undefined" ? "undefined" : _typeof(_shaderProgram)) !== "object") {
      return;
    }
    gl.deleteProgram(_shaderProgram);
    if (_fragShader) {
      gl.deleteShader(_fragShader);
    }
    if (_vertShader) {
      gl.deleteShader(_vertShader);
    }
    if (_vbo) {
      gl.deleteBuffer(_vbo);
    }

    _shaderProgram = _fragShader = _vertShader = _vbo = 0;

    removeGLTexture();
  }

  function createGLTexture() {
    if (!_tex) {
      var gl = _gl;

      // use cyan as the default color.
      var initialColor = new Uint8Array([0, 0, 0, 0]);

      // make a texture with 1x1 pixels so we can use the texture immediately
      // while we wait for the image to load
      var tex = _tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, initialColor);
    }
  }

  function removeGLTexture() {
    if (_tex) {
      _gl.deleteTexture(_tex);
      _tex = 0;
    }

    // destroy our image cache
    _img = null;
  }

  _chart._removeOverlay = function () {
    removeGLTexture();
  };

  _chart._generateG = function (parent) {
    if (parent === undefined) {
      parent = _chart.svg();
    }

    var reset = parent !== _parent;
    _parent = parent;

    if (!_g || reset) {
      _g = _parent.append("g");
    }

    if (!_chartBody) {
      var root = _chart.root();

      _chartBody = root.append("canvas").attr("class", "webgl-canvas").style("position", "absolute");

      var containerNode = root.node();
      var chartNode = _chartBody.node();

      initWebGL(chartNode);
      _eventHandler = (0, _coordinateGridRasterMixinUi2.default)(_chart, containerNode, _currDataBounds, _scale, _offset, filterChartDimensions, doChartRedraw, browser, _mapboxgl, _interactionsEnabled);
    } else if (reset) {
      var root = _chart.root().node();
      var _node = _chartBody.node();
      root.appendChild(_node);
    }

    return _g;
  };

  /**
   * Get or set the root g element. This method is usually used to retrieve the g element in order to
   * overlay custom svg drawing programatically. **Caution**: The root g element is usually generated
   * by dc.js internals, and resetting it might produce unpredictable result.
   * @name g
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @param {SVGElement} [gElement]
   * @return {SVGElement}
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.g = function (gElement) {
    if (!arguments.length) {
      return _g;
    }
    _g = gElement;
    return _chart;
  };

  /**
   * Retrieve the canvas for the chart body.
   * @param {SVGElement} [chartBody]
   * @return {SVGElement}
   */
  _chart.chartBody = function (chartBody) {
    return _chartBody;
  };

  _chart.xOriginalDomain = function () {
    return _xOriginalDomain;
  };

  /**
   * Set or get the xUnits function. The coordinate grid chart uses the xUnits function to calculate
   * the number of data projections on x axis such as the number of bars for a bar chart or the
   * number of dots for a line chart. This function is expected to return a Javascript array of all
   * data points on x axis, or the number of points on the axis. [d3 time range functions
   * d3.time.days, d3.time.months, and
   * d3.time.years](https://github.com/mbostock/d3/wiki/Time-Intervals#aliases) are all valid xUnits
   * function. dc.js also provides a few units function, see the {@link #utilities Utilities} section for
   * a list of built-in units functions. The default xUnits function is units.integers.
   * @name xUnits
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @todo Add docs for utilities
   * @example
   * // set x units to count days
   * chart.xUnits(d3.time.days)
   * // set x units to count months
   * chart.xUnits(d3.time.months)
   *
   * // A custom xUnits function can be used as long as it follows the following interface:
   * // units in integer
   * function(start, end, xDomain) {
   *      // simply calculates how many integers in the domain
   *      return Math.abs(end - start)
   * }
   *
   * // fixed units
   * function(start, end, xDomain) {
   *      // be aware using fixed units will disable the focus/zoom ability on the chart
   *      return 1000
   * }
   * @param {Function} [xUnits]
   * @return {Function}
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.xUnits = function (xUnits) {
    if (!arguments.length) {
      return _xUnits;
    }
    _xUnits = xUnits;
    return _chart;
  };

  /**
   * Set or get the x axis used by a particular coordinate grid chart instance. This function is most
   * useful when x axis customization is required. The x axis in dc.js is an instance of a [d3
   * axis object](https://github.com/mbostock/d3/wiki/SVG-Axes#wiki-axis); therefore it supports any
   * valid d3 axis manipulation. **Caution**: The x axis is usually generated internally by dc
   * resetting it may cause unexpected results.
   * @name xAxis
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @see {@link http://github.com/mbostock/d3/wiki/SVG-Axes d3.svg.axis}
   * @example
   * // customize x axis tick format
   * chart.xAxis().tickFormat(function(v) {return v + "%";})
   * // customize x axis tick values
   * chart.xAxis().tickValues([0, 100, 200, 300])
   * @param {d3.svg.axis} [xAxis=d3.svg.axis().orient("bottom")]
   * @return {d3.svg.axis}
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.xAxis = function (xAxis) {
    if (!arguments.length) {
      return _xAxis;
    }
    _xAxis = xAxis;
    return _chart;
  };

  /**
   * Turn on/off elastic x axis behavior. If x axis elasticity is turned on, then the grid chart will
   * attempt to recalculate the x axis range whenever a redraw event is triggered.
   * @name elasticX
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @param {Boolean} [elasticX=false]
   * @return {Boolean}
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.elasticX = function (elasticX) {
    if (!arguments.length) {
      return _xElasticity;
    }
    _xElasticity = elasticX;
    return _chart;
  };

  /**
   * Set or get x axis padding for the elastic x axis. The padding will be added to both end of the x
   * axis if elasticX is turned on; otherwise it is ignored.
   *
   * padding can be an integer or percentage in string (e.g. "10%"). Padding can be applied to
   * number or date x axes.  When padding a date axis, an integer represents number of days being padded
   * and a percentage string will be treated the same as an integer.
   * @name xAxisPadding
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @param {Number|String} [padding=0]
   * @return {Number|String}
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.xAxisPadding = function (padding) {
    if (!arguments.length) {
      return _xAxisPadding;
    }
    _xAxisPadding = padding;
    return _chart;
  };

  /**
   * Returns the number of units displayed on the x axis using the unit measure configured by
   * .xUnits.
   * @name xUnitCount
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @return {Number}
   */
  _chart.xUnitCount = function () {
    if (_unitCount === undefined) {
      var _units = _chart.xUnits()(_chart.x().domain()[0], _chart.x().domain()[1], _chart.x().domain());

      if (_units instanceof Array) {
        _unitCount = _units.length;
      } else {
        _unitCount = _units;
      }
    }

    return _unitCount;
  };

  /**
   * Gets or sets whether the chart should be drawn with a right axis instead of a left axis. When
   * used with a chart in a composite chart, allows both left and right Y axes to be shown on a
   * chart.
   * @name useRightYAxis
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @param {Boolean} [useRightYAxis=false]
   * @return {Boolean}
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.useRightYAxis = function (useRightYAxis) {
    if (!arguments.length) {
      return _useRightYAxis;
    }
    _useRightYAxis = useRightYAxis;
    return _chart;
  };

  /**
   * Returns true if the chart is using ordinal xUnits ({@link #units.ordinal units.ordinal}, or false
   * otherwise. Most charts behave differently with ordinal data and use the result of this method to
   * trigger the appropriate logic.
   * @name isOrdinal
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @return {Boolean}
   */
  _chart.isOrdinal = function () {
    return _chart.xUnits() === _core.units.ordinal;
  };

  _chart._useOuterPadding = function () {
    return true;
  };

  function compareDomains(d1, d2) {
    return !d1 || !d2 || d1.length !== d2.length || d1.some(function (elem, i) {
      return elem && d2[i] ? elem.toString() !== d2[i].toString() : elem === d2[i];
    });
  }

  function prepareChartBody() {
    if (_destroyed) {
      return;
    }

    var width = _chart.effectiveWidth();
    var height = _chart.effectiveHeight();
    var margins = _chart.margins();
    var left = margins.left;
    var right = margins.right;
    var top = margins.top;
    var bottom = margins.bottom;
    var pixelRatio = window.devicePixelRatio || 1;

    var prevWidth = _chartBody.style("width");
    var prevHeight = _chartBody.style("height");

    // set the actual canvas size, taking pixel ratio into account
    _chartBody.style("width", width + "px").style("height", height + "px").style("left", left + "px").style("top", top + "px").attr("width", width * pixelRatio).attr("height", height * pixelRatio);

    _parent.style("width", width + (right + left) + "px").style("height", height + (top + bottom) + "px").attr("width", (width + (right + left)) * pixelRatio).attr("height", (height + (top + bottom)) * pixelRatio);

    if (prevWidth !== _chartBody.style("width") || prevHeight !== _chartBody.style("height")) {
      // TODO(croot): What about when the margins change?
      // That's not truly a resize event
      _chart.map().fire("resize", {
        width: width,
        height: height,
        top: top,
        left: left
      });
    }
  }

  var TRANSPARENT_PNG_URL = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=';

  function renderChart(imgUrl, renderBounds, queryId) {
    var gl = _gl;

    var onImageLoad = function onImageLoad(err, img) {
      if (_destroyed) {
        return;
      }

      if (err) {
        throw err;
      }

      if (queryId === _queryId) {
        var xdom = _chart.x().domain();
        var ydom = _chart.y().domain();

        if (xdom[0] === renderBounds[0][0] && xdom[1] === renderBounds[1][0] && ydom[0] === renderBounds[2][1] && ydom[1] === renderBounds[0][1]) {

          if (!_tex) {
            createGLTexture();
          }

          if (!_img || img.width != _img.width || img.height != _img.height) {
            // Image was updated and dimensions changed.
            gl.bindTexture(gl.TEXTURE_2D, _tex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);

            if (!_img) {
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            }
          } else {
            // Image was updated but dimensions unchanged.
            gl.bindTexture(gl.TEXTURE_2D, _tex);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, img);
          }
          _img = img;

          _scale[0] = 1;
          _scale[1] = 1;
          _offset[0] = 0;
          _offset[1] = 0;
          var xrange = _chart.xRange();
          var yrange = _chart.yRange();
          _currDataBounds[0][0] = xrange[0];
          _currDataBounds[0][1] = xrange[1];
          _currDataBounds[1][0] = yrange[0];
          _currDataBounds[1][1] = yrange[1];

          renderChart();
        }
      }
    };

    if (imgUrl && imgUrl !== _chart.lastImgUrl || !_utils.utils.deepEquals(renderBounds, _chart.lastRenderBounds)) {
      _chart.lastImgUrl = imgUrl;
      _chart.lastRenderBounds = renderBounds;
      _axios2.default.get(imgUrl, {
        responseType: 'arraybuffer'
      }).then(function (_ref) {
        var data = _ref.data;

        var img = new window.Image();
        var URL = window.URL || window.webkitURL;
        img.onload = function () {
          onImageLoad(null, img);
          URL.revokeObjectURL(img.src);
        };
        img.onerror = function () {
          return onImageLoad(new Error('Could not load scatterplot image'));
        };
        var blob = new window.Blob([new Uint8Array(data)], { type: 'image/png' });
        img.src = data.byteLength ? URL.createObjectURL(blob) : TRANSPARENT_PNG_URL;
      });
    }

    if (queryId !== null && queryId !== undefined) {
      _queryId = queryId;
    }

    var pixelRatio = window.devicePixelRatio || 1;
    gl.viewport(0, 0, _chart.effectiveWidth() * pixelRatio, _chart.effectiveHeight() * pixelRatio);

    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.enable(gl.BLEND);

    gl.useProgram(_shaderProgram);
    gl.bindBuffer(gl.ARRAY_BUFFER, _vbo);

    gl.uniform2fv(_shaderProgram.u_texCoordsScale, _scale);
    gl.uniform2fv(_shaderProgram.u_texCoordsOffset, _offset);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, _tex);
    gl.uniform1i(_shaderProgram.u_sampler, 0);

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }

  var customTimeFormat = _d2.default.time.format.utc.multi([[".%L", function (d) {
    return d.getUTCMilliseconds();
  }], [":%S", function (d) {
    return d.getUTCSeconds();
  }], ["%I:%M", function (d) {
    return d.getUTCMinutes();
  }], ["%I %p", function (d) {
    return d.getUTCHours();
  }], ["%a %d", function (d) {
    return d.getUTCDay() && d.getUTCDate() != 1;
  }], ["%b %d", function (d) {
    return d.getUTCDate() != 1;
  }], ["%b", function (d) {
    return d.getUTCMonth();
  }], ["%Y", function () {
    return true;
  }]]);

  function setXTickFormat(tickFormat, options) {
    if (options.toCache && cachedXTickFormat === NO_CACHE) {
      cachedXTickFormat = _xAxis.tickFormat();
    }

    _xAxis.tickFormat(tickFormat);

    if (options.fromCache) {
      cachedXTickFormat = NO_CACHE;
    }
  }

  function setXAxisFormat(needsDateFormat) {
    var dateFormatter = _chart.dateFormatter();
    var numberFormatter = _chart.valueFormatter();
    var dateFormatExistsForThisKey = Boolean(dateFormatter && dateFormatter(new Date(), _chart.xAxisLabel()));
    var numberFormatExistsForThisKey = Boolean(numberFormatter && numberFormatter(null, _chart.xAxisLabel()));

    if (needsDateFormat && dateFormatExistsForThisKey) {
      setXTickFormat(function (d) {
        return dateFormatter(d, _chart.xAxisLabel());
      }, { toCache: true });
    } else if (needsDateFormat) {
      setXTickFormat(customTimeFormat);
    } else if (numberFormatExistsForThisKey) {
      setXTickFormat(function (d) {
        return numberFormatter(d, _chart.xAxisLabel());
      }, { toCache: true });
    } else if (cachedXTickFormat !== NO_CACHE) {
      setXTickFormat(cachedXTickFormat, { fromCache: true });
    }
  }

  function prepareXAxis(g, x, render, transitionDuration) {
    // has the domain changed?
    var xdom = x.domain();
    if (render || compareDomains(_lastXDomain, xdom)) {
      _chart.rescale();
    }
    _lastXDomain = xdom;

    // TODO(croot): support ordinal scales?
    // If BE supports ordinal scales for X axis, use
    // rangeBands here: i.e. x.rangeBands([0, _chart.xAxisLength()], ...)

    // currently only supports quantitative scal
    x.range([0, Math.round(_chart.xAxisLength())]);

    _xAxis = _xAxis.scale(x);

    var needsDateFormat = xdom[0] instanceof Date;
    setXAxisFormat(needsDateFormat);

    _xAxis.ticks(_chart.effectiveWidth() / _xAxis.scale().ticks().length < 64 ? Math.ceil(_chart.effectiveWidth() / 64) : 10);

    _chart.prepareLabelEdit("x");
    _chart.prepareLockAxis("x");

    renderVerticalGridLines(g, x, transitionDuration);
  }

  _chart.renderXAxis = function (g, transitionDuration) {
    var axisXG = g.selectAll("g.x");

    if (axisXG.empty()) {
      axisXG = g.append("g").attr("class", "axis x").attr("transform", "translate(" + _chart.margins().left + "," + _chart._xAxisY() + ")");
    }

    var root = _chart.root();
    var xLabel = root.selectAll(".x-axis-label");

    if (xLabel.empty()) {
      xLabel = root.append("div").attr("class", "x-axis-label");
    }

    xLabel.style("left", _chart.effectiveWidth() / 2 + _chart.margins().left + "px").text(_chart.xAxisLabel());

    if (transitionDuration === undefined) {
      transitionDuration = _chart.transitionDuration();
    }
    (0, _core.transition)(axisXG, transitionDuration).attr("transform", "translate(" + _chart.margins().left + "," + _chart._xAxisY() + ")").call(_xAxis);
  };

  function renderVerticalGridLines(g, x, transitionDuration) {
    var gridLineG = g.selectAll("g." + VERTICAL_CLASS);

    if (_renderVerticalGridLine) {
      if (gridLineG.empty()) {
        gridLineG = g.insert("g", ":first-child").attr("class", GRID_LINE_CLASS + " " + VERTICAL_CLASS).attr("transform", "translate(" + _chart.margins().left + "," + _chart.margins().top + ")");
      }

      var ticks = _xAxis.tickValues() ? _xAxis.tickValues() : typeof x.ticks === "function" ? x.ticks(_xAxis.ticks()[0]) : x.domain();

      var lines = gridLineG.selectAll("line").data(ticks);

      // enter
      var linesGEnter = lines.enter().append("line").attr("x1", function (d) {
        return x(d);
      }).attr("y1", _chart._xAxisY() - _chart.margins().top).attr("x2", function (d) {
        return x(d);
      }).attr("y2", 0).attr("opacity", 0);

      if (transitionDuration === undefined) {
        transitionDuration = _chart.transitionDuration();
      }

      (0, _core.transition)(linesGEnter, transitionDuration).attr("opacity", 1);

      // update
      (0, _core.transition)(lines, transitionDuration).attr("x1", function (d) {
        return x(d);
      }).attr("y1", _chart._xAxisY() - _chart.margins().top).attr("x2", function (d) {
        return x(d);
      }).attr("y2", 0);

      // exit
      lines.exit().remove();
    } else {
      gridLineG.selectAll("line").remove();
    }
  }

  _chart._xAxisY = function () {
    return _chart.height() - _chart.margins().bottom;
  };

  _chart.xAxisLength = function () {
    return _chart.effectiveWidth();
  };

  /**
   * Set or get the x axis label. If setting the label, you may optionally include additional padding to
   * the margin to make room for the label. By default the padded is set to 12 to accomodate the text height.
   * @name xAxisLabel
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @param {String} [labelText]
   * @param {Number} [padding=12]
   * @return {String}
   */
  _chart.xAxisLabel = function (labelText, padding) {
    if (!arguments.length) {
      return _xAxisLabel;
    }
    _xAxisLabel = labelText;
    _chart.margins().bottom -= _xAxisLabelPadding;
    _xAxisLabelPadding = padding === undefined ? DEFAULT_AXIS_LABEL_PADDING : padding;
    _chart.margins().bottom += _xAxisLabelPadding;
    return _chart;
  };

  function setYTickFormat(tickFormat, options) {
    if (options.toCache && cachedYTickFormat === NO_CACHE) {
      cachedYTickFormat = _yAxis.tickFormat();
    }

    _yAxis.tickFormat(tickFormat);

    if (options.fromCache) {
      cachedYTickFormat = NO_CACHE;
    }
  }

  function setYAxisFormat(needsDateFormat) {
    var dateFormatter = _chart.dateFormatter();
    var numberFormatter = _chart.valueFormatter();
    var dateFormatExistsForThisKey = Boolean(dateFormatter && dateFormatter(new Date(), _chart.yAxisLabel()));
    var numberFormatExistsForThisKey = Boolean(numberFormatter && numberFormatter(null, _chart.yAxisLabel()));

    if (needsDateFormat && dateFormatExistsForThisKey) {
      setYTickFormat(function (d) {
        return dateFormatter(d, _chart.yAxisLabel());
      }, { toCache: true });
    } else if (needsDateFormat) {
      setYTickFormat(customTimeFormat);
    } else if (!needsDateFormat && numberFormatExistsForThisKey) {
      setYTickFormat(function (d) {
        return numberFormatter(d, _chart.yAxisLabel());
      }, { toCache: true });
    } else if (cachedYTickFormat !== NO_CACHE) {
      setYTickFormat(cachedYTickFormat, { fromCache: true });
    }
  }

  _chart._prepareYAxis = function (g, y, transitionDuration) {
    y.range([Math.round(_chart.yAxisHeight()), 0]);

    _yAxis = _yAxis.scale(y);

    _yAxis.ticks(_chart.effectiveHeight() / _yAxis.scale().ticks().length < 16 ? Math.ceil(_chart.effectiveHeight() / 16) : 10);

    if (_useRightYAxis) {
      _yAxis.orient("right");
    }

    setYAxisFormat();

    _chart._renderHorizontalGridLinesForAxis(g, y, _yAxis, transitionDuration);
    _chart.prepareLabelEdit("y");
    _chart.prepareLockAxis("y");
  };

  _chart.renderYAxisLabel = function (axisClass, text, rotation, labelXPosition) {
    var root = _chart.root();

    var yLabel = root.selectAll(".y-axis-label");

    if (yLabel.empty()) {
      yLabel = root.append("div").attr("class", "y-axis-label");
    }

    if (text !== "") {
      // TODO(croot): should add the rotation and labelXPosition here
      // As of now (09/02/2016) the chart.css is breaking this.

      yLabel.style("top", _chart.effectiveHeight() / 2 + _chart.margins().top + "px").text(text);
    }
  };

  _chart.renderYAxisAt = function (axisClass, axis, position, transitionDuration) {
    var axisYG = _chart.g().selectAll("g." + axisClass);
    if (axisYG.empty()) {
      axisYG = _chart.g().append("g").attr("class", "axis " + axisClass).attr("transform", "translate(" + position + "," + _chart.margins().top + ")");
    }

    if (transitionDuration === undefined) {
      transitionDuration = _chart.transitionDuration();
    }

    (0, _core.transition)(axisYG, transitionDuration).attr("transform", "translate(" + position + "," + _chart.margins().top + ")").call(axis);
  };

  _chart.renderYAxis = function (g, transitionDuration) {
    var axisPosition = _useRightYAxis ? _chart.width() - _chart.margins().right : _chart._yAxisX();
    _chart.renderYAxisAt("y", _yAxis, axisPosition, transitionDuration);
    var labelPosition = _useRightYAxis ? _chart.width() - _yAxisLabelPadding : _yAxisLabelPadding;
    var rotation = _useRightYAxis ? 90 : -90;
    _chart.renderYAxisLabel("y", _chart.yAxisLabel(), rotation, labelPosition);
  };

  _chart._renderHorizontalGridLinesForAxis = function (g, scale, axis, transitionDuration) {
    var gridLineG = g.selectAll("g." + HORIZONTAL_CLASS);

    if (_renderHorizontalGridLine) {
      var ticks = axis.tickValues() ? axis.tickValues() : scale.ticks(axis.ticks()[0]);

      if (gridLineG.empty()) {
        gridLineG = g.insert("g", ":first-child").attr("class", GRID_LINE_CLASS + " " + HORIZONTAL_CLASS).attr("transform", "translate(" + _chart.margins().left + "," + _chart.margins().top + ")");
      }

      var lines = gridLineG.selectAll("line").data(ticks);

      // enter
      var linesGEnter = lines.enter().append("line").attr("x1", 1).attr("y1", function (d) {
        return scale(d);
      }).attr("x2", _chart.xAxisLength()).attr("y2", function (d) {
        return scale(d);
      }).attr("opacity", 0);

      if (transitionDuration === undefined) {
        transitionDuration = _chart.transitionDuration();
      }

      (0, _core.transition)(linesGEnter, transitionDuration).attr("opacity", 1);

      // update
      (0, _core.transition)(lines, transitionDuration).attr("x1", 1).attr("y1", function (d) {
        return scale(d);
      }).attr("x2", _chart.xAxisLength()).attr("y2", function (d) {
        return scale(d);
      });

      // exit
      lines.exit().remove();
    } else {
      gridLineG.selectAll("line").remove();
    }
  };

  _chart._yAxisX = function () {
    return _chart.useRightYAxis() ? _chart.width() - _chart.margins().right : _chart.margins().left;
  };

  /**
   * Set or get the y axis label. If setting the label, you may optionally include additional padding
   * to the margin to make room for the label. By default the padded is set to 12 to accomodate the
   * text height.
   * @name yAxisLabel
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @param {String} [labelText]
   * @param {Number} [padding=12]
   * @return {String}
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.yAxisLabel = function (labelText, padding) {
    if (!arguments.length) {
      return _yAxisLabel;
    }
    _yAxisLabel = labelText;
    _chart.margins().left -= _yAxisLabelPadding;
    _yAxisLabelPadding = padding === undefined ? DEFAULT_AXIS_LABEL_PADDING : padding;
    _chart.margins().left += _yAxisLabelPadding;
    return _chart;
  };

  /**
   * Set or get the y axis used by the coordinate grid chart instance. This function is most useful
   * when y axis customization is required. The y axis in dc.js is simply an instance of a [d3 axis
   * object](https://github.com/mbostock/d3/wiki/SVG-Axes#wiki-_axis); therefore it supports any
   * valid d3 axis manipulation. **Caution**: The y axis is usually generated internally by dc
   * resetting it may cause unexpected results.
   * @name yAxis
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @see {@link http://github.com/mbostock/d3/wiki/SVG-Axes d3.svg.axis}
   * @example
   * // customize y axis tick format
   * chart.yAxis().tickFormat(function(v) {return v + "%";})
   * // customize y axis tick values
   * chart.yAxis().tickValues([0, 100, 200, 300])
   * @param {d3.svg.axis} [yAxis=d3.svg.axis().orient("left")]
   * @return {d3.svg.axis}
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.yAxis = function (yAxis) {
    if (!arguments.length) {
      return _yAxis;
    }
    _yAxis = yAxis;
    return _chart;
  };

  /**
   * Turn on/off elastic y axis behavior. If y axis elasticity is turned on, then the grid chart will
   * attempt to recalculate the y axis range whenever a redraw event is triggered.
   * @name elasticY
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @param {Boolean} [elasticY=false]
   * @return {Boolean}
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.elasticY = function (elasticY) {
    if (!arguments.length) {
      return _yElasticity;
    }
    _yElasticity = elasticY;
    return _chart;
  };

  /**
   * Turn on/off horizontal grid lines.
   * @name renderHorizontalGridLines
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @param {Boolean} [renderHorizontalGridLines=false]
   * @return {Boolean}
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.renderHorizontalGridLines = function (renderHorizontalGridLines) {
    if (!arguments.length) {
      return _renderHorizontalGridLine;
    }
    _renderHorizontalGridLine = renderHorizontalGridLines;
    return _chart;
  };

  /**
   * Turn on/off vertical grid lines.
   * @name renderVerticalGridLines
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @param {Boolean} [renderVerticalGridLines=false]
   * @return {Boolean}
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.renderVerticalGridLines = function (renderVerticalGridLines) {
    if (!arguments.length) {
      return _renderVerticalGridLine;
    }
    _renderVerticalGridLine = renderVerticalGridLines;
    return _chart;
  };

  /**
   * Set or get y axis padding for the elastic y axis. The padding will be added to the top of the y
   * axis if elasticY is turned on; otherwise it is ignored.
   *
   * padding can be an integer or percentage in string (e.g. "10%"). Padding can be applied to
   * number or date axes. When padding a date axis, an integer represents number of days being padded
   * and a percentage string will be treated the same as an integer.
   * @name yAxisPadding
   * @memberof dc.coordinateGridRasterMixin
   * @instance
   * @param {Number|String} [padding=0]
   * @return {Number}
   * @return {dc.coordinateGridRasterMixin}
   */
  _chart.yAxisPadding = function (padding) {
    if (!arguments.length) {
      return _yAxisPadding;
    }
    _yAxisPadding = padding;
    return _chart;
  };

  _chart.yAxisHeight = function () {
    return _chart.effectiveHeight();
  };

  _chart._rangeBandPadding = function (_) {
    if (!arguments.length) {
      return _rangeBandPadding;
    }
    _rangeBandPadding = _;
    return _chart;
  };

  _chart._outerRangeBandPadding = function (_) {
    if (!arguments.length) {
      return _outerRangeBandPadding;
    }
    _outerRangeBandPadding = _;
    return _chart;
  };

  (0, _core.override)(_chart, "filter", function (filter, isInverseFilter) {
    if (!arguments.length) {
      return _chart._filter();
    }

    _chart._filter(filter, isInverseFilter);

    if (filter) {
      _chart.brush().extent(filter);
    } else {
      _chart.brush().clear();
    }

    return _chart;
  });

  _chart.brush = function (_) {
    if (!arguments.length) {
      return _brush;
    }
    _brush = _;
    return _chart;
  };

  _chart.isBrushing = function (_) {
    if (!arguments.length) {
      return _isBrushing;
    }
    _isBrushing = _;
    return _chart;
  };

  function brushHeight() {
    return _chart._xAxisY() - _chart.margins().top;
  }

  _chart.fadeDeselectedArea = function () {}
  // do nothing, sub-chart should override this function


  // borrowed from Crossfilter example
  ;_chart.resizeHandlePath = function (d) {
    var e = Number(d === "e"),
        x = e ? 1 : -1,
        y = brushHeight() / 3;
    return "M" + 0.5 * x + "," + y + "A6,6 0 0 " + e + " " + 6.5 * x + "," + (y + 6) + "V" + (2 * y - 6) + "A6,6 0 0 " + e + " " + 0.5 * x + "," + 2 * y + "Z" + "M" + 2.5 * x + "," + (y + 8) + "V" + (2 * y - 8) + "M" + 4.5 * x + "," + (y + 8) + "V" + (2 * y - 8);
  };

  function getClipPathId() {
    return _chart.anchorName().replace(/[ .#=\[\]]/g, "-") + "-clip";
  }

  _chart._preprocessData = function () {};

  function initGrid() {
    if (_gridInitted) {
      return;
    }
    _chart.resetSvg();
    _chart.svg().style("position", "absolute");
    _chart._generateG();
    _gridInitted = true;
  }

  function doChartRender(imgUrl, renderBounds, queryId) {
    if (_destroyed) {
      throw new _errors.DestroyedChartError();
    }
    initGrid();
    _chart._preprocessData();
    drawChart(true, imgUrl, renderBounds, queryId);
    _hasBeenRendered = true;
    return _chart;
  }

  _chart._doRender = function () {
    doChartRender();
  };

  function doChartRedraw(imgUrl, renderBounds, queryId) {
    if (_destroyed) {
      throw new _errors.DestroyedChartError();
    }

    if (!_hasBeenRendered) // guard to prevent a redraw before a render
      {
        return doChartRender(imgUrl, renderBounds, queryId);
      }

    _chart._preprocessData();

    drawChart(false, imgUrl, renderBounds, queryId);

    return _chart;
  }

  _chart._doRedraw = function () {
    doChartRedraw();
  };

  _chart._drawScatterPlot = function (doFullRender, imgUrl, renderBounds, queryId) {
    if (doFullRender) {
      doChartRender(imgUrl, renderBounds, queryId);
    } else {
      doChartRedraw(imgUrl, renderBounds, queryId);
    }
  };

  _chart._destroyScatterPlot = function () {
    destroy();
  };

  function drawChart(render, imgUrl, renderBounds, queryId) {
    // prepare and render the chart first so the grid lines/axes
    // are drawn on top
    prepareChartBody();
    renderChart(imgUrl, renderBounds, queryId);

    var transitionDuration = render ? _chart.transitionDuration() : 10;

    prepareXAxis(_chart.g(), _chart.x(), render, transitionDuration);
    _chart._prepareYAxis(_chart.g(), _chart.y(), transitionDuration);

    if (_chart.elasticX() || _resizing || render) {
      _chart.renderXAxis(_chart.g(), transitionDuration);
    }

    if (_chart.elasticY() || _resizing || render) {
      _chart.renderYAxis(_chart.g(), transitionDuration);
    }

    _chart.fadeDeselectedArea();
    _resizing = false;
    _chart.map().fire("render", {});
  }

  _chart.init = function () {
    initGrid();
    return new Promise(function (resolve, reject) {
      resolve(_chart);
    });
  };

  return _chart;
}

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(8);

function encode(val) {
  return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(8);
var normalizeHeaderName = __webpack_require__(283);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  // Only Node.JS has a process variable that is of [[Class]] process
  if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(198);
  } else if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(198);
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(282)))

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(8);
var settle = __webpack_require__(284);
var buildURL = __webpack_require__(195);
var parseHeaders = __webpack_require__(286);
var isURLSameOrigin = __webpack_require__(287);
var createError = __webpack_require__(199);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__(288);

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(285);

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(8);

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  utils.forEach(['url', 'method', 'params', 'data'], function valueFromConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    }
  });

  utils.forEach(['headers', 'auth', 'proxy'], function mergeDeepProperties(prop) {
    if (utils.isObject(config2[prop])) {
      config[prop] = utils.deepMerge(config1[prop], config2[prop]);
    } else if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (utils.isObject(config1[prop])) {
      config[prop] = utils.deepMerge(config1[prop]);
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });

  utils.forEach([
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'maxContentLength',
    'validateStatus', 'maxRedirects', 'httpAgent', 'httpsAgent', 'cancelToken',
    'socketPath'
  ], function defaultToConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });

  return config;
};


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = scatterMixin;

var _utils = __webpack_require__(4);

var _rasterDrawMixin = __webpack_require__(189);

function extend(destination, source) {
  for (var k in source) {
    if (source.hasOwnProperty(k)) {
      destination[k] = source[k];
    }
  }
  return destination;
}

function scatterMixin(_chart, _mapboxgl) {
  var mixinDraw = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

  var _mapboxgl = typeof mapboxgl === "undefined" ? _mapboxgl : mapboxgl;

  _chart._xDimName = null;
  _chart._yDimName = null;
  var _xDim = null;
  var _yDim = null;

  var _xRange = null;
  var _yRange = null;

  var _map = {
    remove: function remove() {
      _chart._destroyScatterPlot();
    },
    resize: function resize() {
      // noop
      // TODO(croot): send any events to notify the user of a change?
    }
  };

  // add event functionality to our dummy _map object
  extend(_map, _mapboxgl.Evented.prototype);

  _chart.map = function () {
    // just a getter - don't let user set map
    // this is to appease bubbleRasterChart
    // which was initially only setup to
    // do renders with mapbox (hence the name 'map')
    return _map;
  };

  function addDimAndRange(dim, dims, ranges) {
    if (dim) {
      dims.push(dim);
      var range = dim.getFilter();
      if (range !== null) {
        range.forEach(function (rangesArray) {
          ranges.push(rangesArray);
        });
      }
    }
  }

  function initializeXYDimsAndRanges(chart) {
    var xDims = [];
    var yDims = [];
    var xRanges = [];
    var yRanges = [];

    addDimAndRange(chart.xDim(), xDims, xRanges);
    addDimAndRange(chart.yDim(), yDims, yRanges);

    if (typeof chart.getLayers === "function") {
      _chart.getLayers().forEach(function (layer) {
        if (typeof layer.xDim === "function") {
          addDimAndRange(layer.xDim(), xDims, xRanges);
        }

        if (typeof layer.yDim === "function") {
          addDimAndRange(layer.yDim(), yDims, yRanges);
        }
      });
    }

    var yDomain = chart.y && chart.y() && chart.y().domain();
    var xDomain = chart.x && chart.x() && chart.x().domain();

    var actualYRanges = chart.elasticY() && yRanges.length ? yRanges : yDomain && yDomain.length && !yDomain.some(function (v) {
      return v === null;
    }) ? [yDomain] : yRanges;

    var actualXRanges = chart.elasticX() && xRanges.length ? xRanges : xDomain && xDomain.length && !xDomain.some(function (v) {
      return v === null;
    }) ? [xDomain] : xRanges;

    return {
      xDims: xDims,
      yDims: yDims,
      xRanges: actualXRanges,
      yRanges: actualYRanges
    };
  }

  _chart.getDataRenderBounds = function () {
    var dimRangeData = initializeXYDimsAndRanges(_chart);
    var xRanges = dimRangeData.xRanges;
    var yRanges = dimRangeData.yRanges;

    if (!xRanges.length) {
      // default to a 0-1 range
      _xRange = [0, 1];

      // TODO(croot): automatically determine the min/max of the x dimension
      // If we do this, we should cache the x scale and only
      // do this if the scale or dimension has changed
    } else {
      _xRange = xRanges.reduce(function (prevVal, currVal) {
        return [Math.min(prevVal[0], currVal[0]), Math.max(prevVal[1], currVal[1])];
      }, [Number.MAX_VALUE, -Number.MAX_VALUE]);

      if (_chart.elasticX()) {
        var xPadding = _chart.xAxisPadding();
        _xRange[0] = _utils.utils.subtract(_xRange[0], xPadding) || 0;
        _xRange[1] = _utils.utils.add(_xRange[1], xPadding) || 0;
      }
    }

    if (!yRanges.length) {
      // default to a 0-1 range
      _yRange = [0, 1];

      // TODO: automatically determine the min/max of the y dimension?
      // If we do this, we should cache the y scale and only
      // do this if the scale or dimension has changed
    } else {
      _yRange = yRanges.reduce(function (prevVal, currVal) {
        return [Math.min(prevVal[0], currVal[0]), Math.max(prevVal[1], currVal[1])];
      }, [Number.MAX_VALUE, -Number.MAX_VALUE]);

      if (_chart.elasticY()) {
        var yPadding = _chart.yAxisPadding();
        _yRange[0] = _utils.utils.subtract(_yRange[0], yPadding) || 0;
        _yRange[1] = _utils.utils.add(_yRange[1], yPadding) || 0;
      }
    }

    var bounds = _chart._fitToMaxBounds([[_xRange[0], _yRange[0]], [_xRange[1], _yRange[1]]]);
    _xRange[0] = bounds[0][0];
    _xRange[1] = bounds[1][0];
    _yRange[0] = bounds[0][1];
    _yRange[1] = bounds[1][1];

    var renderBounds = [[_xRange[0], _yRange[1]], // top left
    [_xRange[1], _yRange[1]], // top right
    [_xRange[1], _yRange[0]], // bottom right
    [_xRange[0], _yRange[0]]]; // bottom left

    return renderBounds;
  };

  _chart.xRange = function () {
    return _xRange;
  };

  _chart.yRange = function () {
    return _yRange;
  };

  _chart.xDim = function (xDim) {
    if (!arguments.length) {
      return _xDim;
    }
    _xDim = xDim;
    if (_xDim) {
      _chart._xDimName = _xDim.value()[0];
    }

    // force a refresh of the render bounds,
    // this currently doesn't improve anything.
    // We'd want to do this if we do a min/max
    // query during the getDataRenderBounds()
    // function
    _xRange = null;
    return _chart;
  };

  _chart.yDim = function (yDim) {
    if (!arguments.length) {
      return _yDim;
    }
    _yDim = yDim;
    if (_yDim) {
      _chart._yDimName = _yDim.value()[0];
    }

    // force a refresh of the render bounds
    // this currently doesn't improve anything.
    // We'd want to do this if we do a min/max
    // query during the getDataRenderBounds()
    // function
    _yRange = null;
    return _chart;
  };

  _chart._setOverlay = function (_ref) {
    var data = _ref.data,
        bounds = _ref.bounds,
        nonce = _ref.nonce,
        browser = _ref.browser,
        redraw = _ref.redraw;

    if (bounds === undefined) {
      return;
    }

    var blob = null;

    if (data) {
      if (browser.isSafari || browser.isIE || browser.isEdge) {
        blob = _utils.utils.b64toBlob(data, "image/png");
        var blobUrl = URL.createObjectURL(blob);
      } else {
        var blobUrl = "data:image/png;base64," + data;
      }
    }

    _chart._drawScatterPlot(!redraw, blobUrl, bounds, nonce);
  };

  _chart.isLoaded = function () {
    return _xRange && _yRange;
  };

  if (mixinDraw) {
    _chart = (0, _rasterDrawMixin.rasterDrawMixin)(_chart);
  }

  return _chart;
}

/***/ }),
/* 203 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = vnode;
function vnode(sel, data, children, text, elm) {
    var key = data === undefined ? undefined : data.key;
    return { sel: sel, data: data, children: children,
        text: text, elm: elm, key: key };
}
/* harmony default export */ __webpack_exports__["a"] = (vnode);
//# sourceMappingURL=vnode.js.map

/***/ }),
/* 204 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return array; });
/* harmony export (immutable) */ __webpack_exports__["b"] = primitive;
var array = Array.isArray;
function primitive(s) {
    return typeof s === 'string' || typeof s === 'number';
}
//# sourceMappingURL=is.js.map

/***/ }),
/* 205 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = h;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vnode__ = __webpack_require__(203);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__is__ = __webpack_require__(204);


function addNS(data, children, sel) {
    data.ns = 'http://www.w3.org/2000/svg';
    if (sel !== 'foreignObject' && children !== undefined) {
        for (var i = 0; i < children.length; ++i) {
            var childData = children[i].data;
            if (childData !== undefined) {
                addNS(childData, children[i].children, children[i].sel);
            }
        }
    }
}
function h(sel, b, c) {
    var data = {}, children, text, i;
    if (c !== undefined) {
        data = b;
        if (__WEBPACK_IMPORTED_MODULE_1__is__["a" /* array */](c)) {
            children = c;
        }
        else if (__WEBPACK_IMPORTED_MODULE_1__is__["b" /* primitive */](c)) {
            text = c;
        }
        else if (c && c.sel) {
            children = [c];
        }
    }
    else if (b !== undefined) {
        if (__WEBPACK_IMPORTED_MODULE_1__is__["a" /* array */](b)) {
            children = b;
        }
        else if (__WEBPACK_IMPORTED_MODULE_1__is__["b" /* primitive */](b)) {
            text = b;
        }
        else if (b && b.sel) {
            children = [b];
        }
        else {
            data = b;
        }
    }
    if (children !== undefined) {
        for (i = 0; i < children.length; ++i) {
            if (__WEBPACK_IMPORTED_MODULE_1__is__["b" /* primitive */](children[i]))
                children[i] = Object(__WEBPACK_IMPORTED_MODULE_0__vnode__["b" /* vnode */])(undefined, undefined, undefined, children[i], undefined);
        }
    }
    if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g' &&
        (sel.length === 3 || sel[3] === '.' || sel[3] === '#')) {
        addNS(data, children, sel);
    }
    return Object(__WEBPACK_IMPORTED_MODULE_0__vnode__["b" /* vnode */])(sel, data, children, text, undefined);
}
;
/* unused harmony default export */ var _unused_webpack_default_export = (h);
//# sourceMappingURL=h.js.map

/***/ }),
/* 206 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__exponent__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__formatGroup__ = __webpack_require__(311);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__formatNumerals__ = __webpack_require__(312);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__formatSpecifier__ = __webpack_require__(207);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__formatTrim__ = __webpack_require__(313);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__formatTypes__ = __webpack_require__(314);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__formatPrefixAuto__ = __webpack_require__(208);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__identity__ = __webpack_require__(316);









var prefixes = ["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ __webpack_exports__["a"] = (function(locale) {
  var group = locale.grouping && locale.thousands ? Object(__WEBPACK_IMPORTED_MODULE_1__formatGroup__["a" /* default */])(locale.grouping, locale.thousands) : __WEBPACK_IMPORTED_MODULE_7__identity__["a" /* default */],
      currency = locale.currency,
      decimal = locale.decimal,
      numerals = locale.numerals ? Object(__WEBPACK_IMPORTED_MODULE_2__formatNumerals__["a" /* default */])(locale.numerals) : __WEBPACK_IMPORTED_MODULE_7__identity__["a" /* default */],
      percent = locale.percent || "%";

  function newFormat(specifier) {
    specifier = Object(__WEBPACK_IMPORTED_MODULE_3__formatSpecifier__["a" /* default */])(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!__WEBPACK_IMPORTED_MODULE_5__formatTypes__["a" /* default */][type]) precision == null && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = __WEBPACK_IMPORTED_MODULE_5__formatTypes__["a" /* default */][type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision == null ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Perform the initial formatting.
        var valueNegative = value < 0;
        value = formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = Object(__WEBPACK_IMPORTED_MODULE_4__formatTrim__["a" /* default */])(value);

        // If a negative value rounds to zero during formatting, treat as positive.
        if (valueNegative && +value === 0) valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + __WEBPACK_IMPORTED_MODULE_6__formatPrefixAuto__["b" /* prefixExponent */] / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer value part that can be
        // grouped, and fractional or exponential suffix part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = Object(__WEBPACK_IMPORTED_MODULE_3__formatSpecifier__["a" /* default */])(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(Object(__WEBPACK_IMPORTED_MODULE_0__exponent__["a" /* default */])(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
});


/***/ }),
/* 207 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = formatSpecifier;
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  return new FormatSpecifier(specifier);
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  this.fill = match[1] || " ";
  this.align = match[2] || ">";
  this.sign = match[3] || "-";
  this.symbol = match[4] || "";
  this.zero = !!match[5];
  this.width = match[6] && +match[6];
  this.comma = !!match[7];
  this.precision = match[8] && +match[8].slice(1);
  this.trim = !!match[9];
  this.type = match[10] || "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width == null ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};


/***/ }),
/* 208 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return prefixExponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__formatDecimal__ = __webpack_require__(43);


var prefixExponent;

/* harmony default export */ __webpack_exports__["a"] = (function(x, p) {
  var d = Object(__WEBPACK_IMPORTED_MODULE_0__formatDecimal__["a" /* default */])(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + Object(__WEBPACK_IMPORTED_MODULE_0__formatDecimal__["a" /* default */])(x, Math.max(0, p + i - 1))[0]; // less than 1y!
});


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rasterLayerHeatmapMixin;

var _utilsVega = __webpack_require__(19);

var _utils = __webpack_require__(4);

var MIN_AREA_IN_METERS = 30;
var EARTH_DIAMETER = 40075000;

function getPixelSize(neLat, width, zoom) {
  return Math.max(MIN_AREA_IN_METERS / (EARTH_DIAMETER * Math.cos(neLat * Math.PI / 180) / (width * Math.pow(2, zoom))), 1.0);
}

function getMarkHeight(type, width) {
  switch (type) {
    case "hex":
      return 2 * width / Math.sqrt(3.0);
    default:
      return width;
  }
}

function getMarkType(type) {
  switch (type) {
    case "hex":
      return "hexagon-horiz";
    default:
      return type;
  }
}

function rasterLayerHeatmapMixin(_layer) {
  var state = {};

  _layer.type = "heatmap";
  _layer.crossfilter = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);
  _layer.xDim = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);
  _layer.yDim = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);
  _layer.dynamicSize = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);
  _layer.dynamicBinning = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);
  _layer.colorDomain = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);
  _layer._mandatoryAttributes([]);

  _layer.setState = function (setterOrState) {
    if (typeof setterOrState === "function") {
      state = setterOrState(state);
    } else {
      state = setterOrState;
    }
  };

  _layer.getState = function () {
    return JSON.parse(JSON.stringify(state));
  };

  function getMarkSize(_ref) {
    var width = _ref.width,
        neLat = _ref.neLat,
        zoom = _ref.zoom;

    var pixelSize = state.encoding.size.type === "manual" ? state.encoding.size.value : getPixelSize(neLat, width, zoom);
    var numBinsX = Math.round(width / pixelSize);
    var markWidth = width / numBinsX;
    var markHeight = getMarkHeight(state.mark, markWidth);
    return {
      markWidth: markWidth,
      markHeight: markHeight
    };
  }

  _layer.genSQL = function (_ref2) {
    var table = _ref2.table,
        width = _ref2.width,
        height = _ref2.height,
        min = _ref2.min,
        max = _ref2.max,
        filter = _ref2.filter,
        globalFilter = _ref2.globalFilter,
        neLat = _ref2.neLat,
        zoom = _ref2.zoom;

    var _getMarkSize = getMarkSize({
      width: width,
      neLat: neLat,
      zoom: zoom
    }),
        markWidth = _getMarkSize.markWidth,
        markHeight = _getMarkSize.markHeight;

    var transforms = [];

    if (typeof filter === "string" && filter.length) {
      transforms.push({
        type: "filter",
        expr: filter
      });
    }

    if (typeof globalFilter === "string" && globalFilter.length) {
      transforms.push({
        type: "filter",
        expr: globalFilter
      });
    }

    return _utils.parser.writeSQL({
      type: "root",
      source: table,
      transform: [].concat(transforms, [{
        type: "pixel_bin",
        width: width,
        height: height,
        mark: {
          shape: state.mark,
          width: markWidth,
          height: markHeight
        },
        x: {
          field: "conv_4326_900913_x(" + state.encoding.x.field + ")",
          domain: [min[0], max[0]]
        },
        y: {
          field: "conv_4326_900913_y(" + state.encoding.y.field + ")",
          domain: [min[1], max[1]]
        },
        aggregate: state.encoding.color.aggregate
      }])
    });
  };

  function getColorScaleName(layerName) {
    return "heat_color" + layerName;
  }

  function usesAutoColors() {
    return state.encoding.color.scale.domain === "auto";
  }

  _layer._updateFromMetadata = function (metadata) {
    var layerName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

    if (usesAutoColors() && Array.isArray(metadata.scales)) {
      var colorScaleName = getColorScaleName(layerName);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = metadata.scales[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var scale = _step.value;

          if (scale.name === colorScaleName) {
            _layer.colorDomain(scale.domain);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  };

  _layer._genVega = function (_ref3) {
    var table = _ref3.table,
        width = _ref3.width,
        height = _ref3.height,
        min = _ref3.min,
        max = _ref3.max,
        filter = _ref3.filter,
        globalFilter = _ref3.globalFilter,
        neLat = _ref3.neLat,
        zoom = _ref3.zoom,
        _ref3$layerName = _ref3.layerName,
        layerName = _ref3$layerName === undefined ? "" : _ref3$layerName;

    var _getMarkSize2 = getMarkSize({
      width: width,
      neLat: neLat,
      zoom: zoom
    }),
        markWidth = _getMarkSize2.markWidth,
        markHeight = _getMarkSize2.markHeight;

    var datalayerName = "heatmap_query" + layerName;

    var autocolors = usesAutoColors();
    var getStatsLayerName = function getStatsLayerName() {
      return datalayerName + "_stats";
    };

    var vega = {
      width: width,
      height: height
    };

    vega.data = [{
      name: datalayerName,
      sql: _layer.genSQL({
        table: table,
        width: width,
        height: height,
        min: min,
        max: max,
        filter: filter,
        globalFilter: globalFilter,
        neLat: neLat,
        zoom: zoom
      })
    }];

    if (autocolors) {
      vega.data.push({
        name: getStatsLayerName(),
        source: datalayerName,
        transform: [{
          type: "aggregate",
          fields: ["color", "color", "color", "color"],
          ops: ["min", "max", "avg", "stddev"],
          as: ["minimum", "maximum", "mean", "deviation"]
        }, {
          type: "formula",
          expr: "max(minimum, mean-2*deviation)",
          as: "mincolor"
        }, {
          type: "formula",
          expr: "min(maximum, mean+2*deviation)",
          as: "maxcolor"
        }]
      });
    }

    var colorScaleName = getColorScaleName(layerName);
    vega.scales = [{
      name: colorScaleName,
      type: state.encoding.color.type,
      domain: autocolors ? { data: getStatsLayerName(), fields: ["mincolor", "maxcolor"] } : state.encoding.color.scale.domain,
      range: state.encoding.color.scale.range.map(function (c) {
        return (0, _utilsVega.adjustOpacity)(c, state.encoding.color.scale.opacity);
      }),
      default: (0, _utilsVega.adjustOpacity)(state.encoding.color.scale.default, state.encoding.color.scale.opacity),
      nullValue: (0, _utilsVega.adjustOpacity)(state.encoding.color.scale.nullValue, state.encoding.color.scale.opacity)
    }];

    vega.marks = [{
      type: "symbol",
      from: {
        data: datalayerName
      },
      properties: {
        shape: getMarkType(state.mark),
        xc: {
          field: "xy"
        },
        yc: {
          field: "xy"
        },
        width: markWidth,
        height: markHeight,
        fillColor: {
          scale: colorScaleName,
          field: "color"
        }
      }
    }];

    return vega;
  };

  _layer._destroyLayer = function () {
    var xDim = _layer.xDim();
    if (xDim) {
      xDim.dispose();
    }

    var yDim = _layer.yDim();
    if (yDim) {
      yDim.dispose();
    }
  };

  return _layer;
}

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = rasterLayerPointMixin;

var _coreAsync = __webpack_require__(5);

var _utilsVega = __webpack_require__(19);

var _utils = __webpack_require__(4);

var _d = __webpack_require__(1);

var d3 = _interopRequireWildcard(_d);

var _mapdDraw = __webpack_require__(13);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var AUTOSIZE_DOMAIN_DEFAULTS = [100000, 0];
var AUTOSIZE_RANGE_DEFAULTS = [2.0, 5.0];
var AUTOSIZE_RANGE_MININUM = [1, 1];
var SIZING_THRESHOLD_FOR_AUTOSIZE_RANGE_MININUM = 1500000;
var ANGLE_SHAPE_SIZE_MULTIPLIER = 2.5;

var AGGREGATES = {
  average: "AVG",
  count: "COUNT",
  min: "MIN",
  max: "MAX",
  sum: "SUM"
};

function validSymbol(type) {
  switch (type) {
    case "circle":
    case "cross":
    case "diamond":
    case "hexagon":
    case "square":
    case "triangle-down":
    case "triangle-left":
    case "triangle-right":
    case "triangle-up":
    case "hexagon-vert":
    case "hexagon-horiz":
    case "wedge":
    case "arrow":
    case "airplane":
      return true;
    default:
      return false;
  }
}

function getMarkType() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { point: {} };

  if (validSymbol(config.point.shape)) {
    return config.point.shape;
  } else {
    return "circle";
  }
}

function getSizing(sizeAttr, cap) {
  var lastFilteredSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : cap;
  var pixelRatio = arguments[3];
  var layerName = arguments[4];
  var markType = arguments[5];

  if (typeof sizeAttr === "number") {
    return markType === "wedge" || markType === "arrow" ? sizeAttr * ANGLE_SHAPE_SIZE_MULTIPLIER : sizeAttr;
  } else if ((typeof sizeAttr === "undefined" ? "undefined" : _typeof(sizeAttr)) === "object" && sizeAttr.type === "quantitative") {
    return {
      scale: (0, _utilsVega.getSizeScaleName)(layerName),
      field: "size"
    };
  } else if (sizeAttr === "auto") {
    var size = Math.min(lastFilteredSize, cap);
    var dynamicRScale = d3.scale.sqrt().domain(AUTOSIZE_DOMAIN_DEFAULTS).range(size > SIZING_THRESHOLD_FOR_AUTOSIZE_RANGE_MININUM ? AUTOSIZE_RANGE_MININUM : AUTOSIZE_RANGE_DEFAULTS).clamp(true);
    var sizeRounded = Math.round(dynamicRScale(size) * pixelRatio);
    return markType === "wedge" || markType === "arrow" ? sizeRounded * ANGLE_SHAPE_SIZE_MULTIPLIER : sizeRounded;
  } else {
    return null;
  }
}

function getColor(color, layerName) {
  if ((typeof color === "undefined" ? "undefined" : _typeof(color)) === "object" && color.type === "density") {
    return {
      scale: (0, _utilsVega.getColorScaleName)(layerName),
      value: 0
    };
  } else if ((typeof color === "undefined" ? "undefined" : _typeof(color)) === "object" && (color.type === "ordinal" || color.type === "quantitative")) {
    return {
      scale: (0, _utilsVega.getColorScaleName)(layerName),
      field: "color"
    };
  } else if ((typeof color === "undefined" ? "undefined" : _typeof(color)) === "object") {
    return (0, _utilsVega.adjustOpacity)(color.value, color.opacity);
  } else {
    return color;
  }
}

function getOrientation(orientation, layerName) {
  if ((typeof orientation === "undefined" ? "undefined" : _typeof(orientation)) === "object" && orientation.type === "quantitative") {
    return {
      scale: layerName + "_symbolAngle",
      field: "orientation"
    };
  } else {
    return {
      scale: "x",
      field: "orientation"
    };
  }
}

function isValidPostFilter(postFilter) {
  var operator = postFilter.operator,
      min = postFilter.min,
      max = postFilter.max,
      aggType = postFilter.aggType,
      value = postFilter.value,
      custom = postFilter.custom;


  if (value && (aggType || custom)) {
    if ((operator === "not between" || operator === "between") && typeof min === "number" && !isNaN(min) && typeof max === "number" && !isNaN(max)) {
      return true;
    } else if ((operator === "equals" || operator === "not equals" || operator === "greater than or equals") && typeof min === "number" && !isNaN(min)) {
      return true;
    } else if (operator === "less than or equals" && typeof max === "number" && !isNaN(max)) {
      return true;
    } else if (operator === "null" || operator === "not null") {
      return true;
    } else {
      return false;
    }
  } else {
    return false;
  }
}

function rasterLayerPointMixin(_layer) {
  var state = null;
  _layer.colorDomain = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);
  _layer.sizeDomain = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);

  _layer.setState = function (setter) {
    if (typeof setter === "function") {
      state = setter(state);
    } else {
      state = setter;
    }

    if (!state.hasOwnProperty("transform")) {
      state.transform = {};
    }

    return _layer;
  };

  _layer.getState = function () {
    return state;
  };

  _layer.getTransforms = function (table, filter, globalFilter, _ref, lastFilteredSize, isDataExport) {
    var transform = _ref.transform,
        _ref$encoding = _ref.encoding,
        x = _ref$encoding.x,
        y = _ref$encoding.y,
        size = _ref$encoding.size,
        color = _ref$encoding.color,
        orientation = _ref$encoding.orientation,
        postFilters = _ref.postFilters;

    var transforms = [];

    if ((typeof transform === "undefined" ? "undefined" : _typeof(transform)) === "object" && _typeof(transform.groupby) === "object" && transform.groupby.length) {
      var fields = isDataExport ? [] : [x.field, y.field];
      var alias = isDataExport ? [] : ["x", "y"];
      var ops = isDataExport ? [] : [x.aggregate, y.aggregate];

      if ((typeof size === "undefined" ? "undefined" : _typeof(size)) === "object" && size.type === "quantitative") {
        fields.push(size.field);
        alias.push("size");
        ops.push(size.aggregate);
      }

      if ((typeof color === "undefined" ? "undefined" : _typeof(color)) === "object" && (color.type === "quantitative" || color.type === "ordinal")) {
        fields.push(color.field);
        alias.push("color");
        ops.push(color.aggregate);
      }

      if (orientation) {
        fields.push(orientation.field);
        alias.push("orientation");
        ops.push(orientation.aggregate);
      }

      // Since we use ST_POINT for pointmap data export, we need to include /*+ cpu_mode */ in pointmap chart data export queries.
      // The reason is ST_Point projections need buffer allocation to hold the coords and thus require cpu execution
      transforms.push({
        type: "aggregate",
        fields: fields,
        ops: ops,
        as: alias,
        groupby: transform.groupby.map(function (g, i) {
          return {
            type: "project",
            expr: "" + (isDataExport && i === 0 ? "/*+ cpu_mode */ " : "") + g,
            as: "key" + i
          };
        })
      });
      if (isDataExport) {
        transforms.push({
          type: "project",
          expr: "ST_SetSRID(ST_Point(" + AGGREGATES[x.aggregate] + "(" + x.field + "), " + AGGREGATES[y.aggregate] + "(" + y.field + ")), 4326)"
        });
      }
    } else {
      if (isDataExport) {
        transforms.push({
          type: "project",
          expr: "/*+ cpu_mode */ ST_SetSRID(ST_Point(" + x.field + ", " + y.field + "), 4326)"
        });
      } else {
        transforms.push({
          type: "project",
          expr: x.field,
          as: "x"
        });
        transforms.push({
          type: "project",
          expr: y.field,
          as: "y"
        });
      }

      if (typeof transform.limit === "number") {
        transforms.push({
          type: "limit",
          row: transform.limit
        });
        if (transform.sample) {
          transforms.push({
            type: "sample",
            method: "multiplicative",
            size: lastFilteredSize || transform.tableSize,
            limit: transform.limit,
            sampleTable: table
          });
        }
      }

      if ((typeof size === "undefined" ? "undefined" : _typeof(size)) === "object" && size.type === "quantitative") {
        transforms.push({
          type: "project",
          expr: size.field,
          as: "size"
        });
      }

      if ((typeof color === "undefined" ? "undefined" : _typeof(color)) === "object" && (color.type === "quantitative" || color.type === "ordinal")) {
        transforms.push({
          type: "project",
          expr: color.field,
          as: "color"
        });
      }

      if (orientation) {
        transforms.push({
          type: "project",
          expr: orientation.field,
          as: "orientation"
        });
      }
    }

    if (typeof filter === "string" && filter.length) {
      transforms.push({
        type: "filter",
        expr: filter
      });
    }

    var postFilter = postFilters ? postFilters[0] : null; // may change to map when we have more than one postFilter
    if (postFilter && isValidPostFilter(postFilter)) {
      transforms.push({
        type: "postFilter",
        table: postFilter.table || null,
        aggType: postFilter.aggType,
        custom: postFilter.custom,
        fields: [postFilter.value],
        ops: postFilter.operator,
        min: postFilter.min,
        max: postFilter.max
      });
    }

    if (typeof globalFilter === "string" && globalFilter.length) {
      transforms.push({
        type: "filter",
        expr: globalFilter
      });
    }

    return transforms;
  };

  _layer.getProjections = function () {
    return _layer.getTransforms("", "", "", state, (0, _coreAsync.lastFilteredSize)(_layer.crossfilter().getId())).filter(function (transform) {
      return transform.type === "project" && transform.hasOwnProperty("as");
    }).map(function (projection) {
      return _utils.parser.parseTransform({ select: [] }, projection);
    }).map(function (sql) {
      return sql.select[0];
    });
  };

  function usesAutoColors() {
    return state.encoding.color.domain === "auto";
  }

  function usesAutoSize() {
    return state.encoding.size.domain === "auto";
  }

  function getAutoColorVegaTransforms(aggregateNode) {
    var rtnobj = { transforms: [], fields: [] };
    if (state.encoding.color.type === "quantitative") {
      var minoutput = "mincolor",
          maxoutput = "maxcolor";
      aggregateNode.fields = aggregateNode.fields.concat(["color", "color", "color", "color"]);
      aggregateNode.ops = aggregateNode.ops.concat(["min", "max", "avg", "stddev"]);
      aggregateNode.as = aggregateNode.as.concat(["mincol", "maxcol", "avgcol", "stdcol"]);
      rtnobj.transforms.push({
        type: "formula",
        expr: "max(mincol, avgcol-2*stdcol)",
        as: minoutput
      }, {
        type: "formula",
        expr: "min(maxcol, avgcol+2*stdcol)",
        as: maxoutput
      });
      rtnobj.fields = [minoutput, maxoutput];
    } else if (state.encoding.color.type === "ordinal") {
      var output = "distinctcolor";
      aggregateNode.fields.push("color");
      aggregateNode.ops.push("distinct");
      aggregateNode.as.push(output);
      rtnobj.fields.push(output);
    }
    return rtnobj;
  }

  function getAutoSizeVegaTransforms(aggregateNode) {
    var minoutput = "minsize",
        maxoutput = "maxsize";
    aggregateNode.fields.push("size", "size", "size", "size");
    aggregateNode.ops.push("min", "max", "avg", "stddev");
    aggregateNode.as.push("minsz", "maxsz", "avgsz", "stdsz");
    return {
      transforms: [{
        type: "formula",
        expr: "max(minsz, avgsz-2*stdsz)",
        as: minoutput
      }, {
        type: "formula",
        expr: "min(maxsz, avgsz+2*stdsz)",
        as: maxoutput
      }],
      fields: [minoutput, maxoutput]
    };
  }

  _layer._updateFromMetadata = function (metadata) {
    var layerName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

    var autoColors = usesAutoColors();
    var autoSize = usesAutoSize();
    if ((autoColors || autoSize) && Array.isArray(metadata.scales)) {
      var colorScaleName = (0, _utilsVega.getColorScaleName)(layerName);
      var sizeScaleName = (0, _utilsVega.getSizeScaleName)(layerName);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = metadata.scales[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var scale = _step.value;

          if (autoColors && scale.name === colorScaleName) {
            _layer.colorDomain(scale.domain);
          } else if (autoSize && scale.name === sizeScaleName) {
            _layer.sizeDomain(scale.domain);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  };

  _layer.__genVega = function (_ref2) {
    var table = _ref2.table,
        filter = _ref2.filter,
        lastFilteredSize = _ref2.lastFilteredSize,
        globalFilter = _ref2.globalFilter,
        pixelRatio = _ref2.pixelRatio,
        layerName = _ref2.layerName;

    var autocolors = usesAutoColors();
    var autosize = usesAutoSize();
    var getStatsLayerName = function getStatsLayerName() {
      return layerName + "_stats";
    };

    var markType = getMarkType(state.config);

    var size = getSizing(state.encoding.size, state.transform && state.transform.limit, lastFilteredSize, pixelRatio, layerName, markType);

    var data = [];

    if (state.encoding.color.prioritizedColor && state.encoding.color.prioritizedColor.length > 0 && layerName !== "backendScatter") {
      for (var i = 0; i < state.encoding.color.prioritizedColor.length; i++) {
        if (layerName.includes("_z" + i * 2)) {
          data = [{
            name: layerName,
            sql: _utils.parser.writeSQL({
              type: "root",
              source: table,
              transform: _layer.getTransforms(table, filter + (" AND " + state.encoding.color.field + " != '" + state.encoding.color.prioritizedColor[i].value + "'"), globalFilter, state, lastFilteredSize)
            }),
            enableHitTesting: state.enableHitTesting
          }];
        } else if (layerName.includes("_z" + (i * 2 + 1))) {
          data = [{
            name: layerName,
            sql: _utils.parser.writeSQL({
              type: "root",
              source: table,
              transform: _layer.getTransforms(table, filter + (" AND " + state.encoding.color.field + " = '" + state.encoding.color.prioritizedColor[i].value + "'"), globalFilter, state, lastFilteredSize)
            }),
            enableHitTesting: state.enableHitTesting
          }];
        }
      }
    } else {
      data = [{
        name: layerName,
        sql: _utils.parser.writeSQL({
          type: "root",
          source: table,
          transform: _layer.getTransforms(table, filter, globalFilter, state, lastFilteredSize)
        }),
        enableHitTesting: state.enableHitTesting
      }];
    }

    var scaledomainfields = {};
    if (autocolors || autosize) {
      var aggregateNode = {
        type: "aggregate",
        fields: [],
        ops: [],
        as: []
      };
      var transforms = [aggregateNode];
      if (autocolors) {
        var xformdata = getAutoColorVegaTransforms(aggregateNode);
        scaledomainfields.color = xformdata.fields;
        transforms = transforms.concat(xformdata.transforms);
      }
      if (autosize) {
        var _xformdata = getAutoSizeVegaTransforms(aggregateNode);
        scaledomainfields.size = _xformdata.fields;
        transforms = transforms.concat(_xformdata.transforms);
      }
      data.push({
        name: getStatsLayerName(),
        source: layerName,
        transform: transforms
      });
    }

    var scales = (0, _utilsVega.getScales)(state.encoding, layerName, scaledomainfields, getStatsLayerName());

    var marks = [{
      type: markType === "airplane" ? "legacysymbol" : "symbol",
      from: {
        data: layerName
      },
      properties: Object.assign({}, {
        xc: {
          scale: "x",
          field: "x"
        },
        yc: {
          scale: "y",
          field: "y"
        },
        fillColor: getColor(state.encoding.color, layerName)
      }, _extends({
        shape: markType
      }, state.encoding.orientation && {
        angle: getOrientation(state.encoding.orientation, layerName)
      }, {
        width: size,
        height: size
      }))
    }];

    return {
      data: data,
      scales: scales,
      marks: marks
    };
  };

  _layer.xDim = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);
  _layer.yDim = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);

  // NOTE: builds _layer.defaultSize(), _layer.nullSize(),
  //              _layer.sizeScale(), & _layer.sizeAttr()
  (0, _utilsVega.createVegaAttrMixin)(_layer, "size", 3, 1, true);

  _layer.dynamicSize = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);

  _layer.xAttr = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);
  _layer.yAttr = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);

  var _point_wrap_class = "map-point-wrap";
  var _point_class = "map-point-new";
  var _point_gfx_class = "map-point-gfx";

  var _vega = null;
  var _scaledPopups = {};
  var _minMaxCache = {};
  var _cf = null;

  _layer.crossfilter = function (cf) {
    if (!arguments.length) {
      return _cf;
    }
    _cf = cf;
    return _layer;
  };

  _layer._requiresCap = function () {
    return false;
  };

  _layer.xRangeFilter = function (range) {
    if (!_layer.xDim()) {
      throw new Error("Must set layer's xDim before invoking xRange");
    }

    var xValue = _layer.xDim().value()[0];

    if (!arguments.length) {
      return _minMaxCache[xValue];
    }

    _minMaxCache[xValue] = range;
    return _layer;
  };

  _layer.yRangeFilter = function (range) {
    if (!_layer.yDim()) {
      throw new Error("Must set layer's yDim before invoking yRange");
    }

    var yValue = _layer.yDim().value()[0];

    if (!arguments.length) {
      return _minMaxCache[yValue];
    }

    _minMaxCache[yValue] = range;
    return _layer;
  };

  _layer._genVega = function (chart, layerName, group, query) {
    // Pointmap prioritized color hack. Need to use the real layer name for crossfilter
    var realLayerName = layerName;
    if (layerName && layerName !== "backendScatter" && layerName.includes("_z")) {
      var idx = layerName.indexOf("_z");
      realLayerName = layerName.substring(0, idx);
    }

    // needed to set LastFilteredSize when point map first initialized
    if (_layer.yDim()) {
      _layer.yDim().groupAll().valueAsync(false, false, false, realLayerName).then(function (value) {
        (0, _coreAsync.setLastFilteredSize)(_layer.crossfilter().getId(), value);
      });
    }

    _vega = _layer.__genVega({
      layerName: layerName,
      table: _layer.crossfilter().getTable()[0],
      filter: _layer.crossfilter().getFilterString(realLayerName),
      globalFilter: _layer.crossfilter().getGlobalFilterString(),
      lastFilteredSize: (0, _coreAsync.lastFilteredSize)(_layer.crossfilter().getId()),
      pixelRatio: chart._getPixelRatio()
    });

    return _vega;
  };

  var renderAttributes = ["xc", "yc", "width", "height", "fillColor", "angle"];

  _layer._addRenderAttrsToPopupColumnSet = function (chart, popupColumnsSet) {
    if (_vega && Array.isArray(_vega.marks) && _vega.marks.length > 0 && _vega.marks[0].properties) {
      renderAttributes.forEach(function (prop) {
        _layer._addQueryDrivenRenderPropToSet(popupColumnsSet, _vega.marks[0].properties, prop);
      });
    }
  };

  _layer._areResultsValidForPopup = function (results) {
    if (typeof results.x === "undefined" || typeof results.y === "undefined") {
      return false;
    } else {
      return true;
    }
  };

  _layer._displayPopup = function (svgProps) {
    var chart = svgProps.chart,
        parentElem = svgProps.parentElem,
        data = svgProps.data,
        height = svgProps.height,
        margins = svgProps.margins,
        xscale = svgProps.xscale,
        yscale = svgProps.yscale,
        minPopupArea = svgProps.minPopupArea,
        animate = svgProps.animate;


    var rndrProps = {};
    if (_vega && Array.isArray(_vega.marks) && _vega.marks.length > 0 && _vega.marks[0].properties) {
      var propObj = _vega.marks[0].properties;
      renderAttributes.forEach(function (prop) {
        if (_typeof(propObj[prop]) === "object" && propObj[prop].field && typeof propObj[prop].field === "string") {
          rndrProps[prop] = propObj[prop].field;
        }
      });
    }

    var pixel = _mapdDraw.Point2d.create(xscale(data[rndrProps.xc || rndrProps.x]) + margins.left, height - yscale(data[rndrProps.yc || rndrProps.y]) + margins.top);

    var sizeFromData = data[rndrProps.size || rndrProps.width || rndrProps.height];
    sizeFromData = Math.max(sizeFromData, 1); // size must be > 0 (#164)
    var dotSize = _layer.getSizeVal(sizeFromData);

    var scale = 1;
    var scaleRatio = minPopupArea / (dotSize * dotSize);
    var isScaled = scaleRatio > 1;
    if (isScaled) {
      scale = Math.sqrt(scaleRatio);
      dotSize = dotSize * scale;
    }

    var popupStyle = _layer.popupStyle();
    var bgColor = _layer.getFillColorVal(data[rndrProps.fillColor]);
    var strokeColor = void 0,
        strokeWidth = void 0;
    if ((typeof popupStyle === "undefined" ? "undefined" : _typeof(popupStyle)) === "object" && !isScaled) {
      bgColor = popupStyle.fillColor || bgColor;
      strokeColor = popupStyle.strokeColor;
      strokeWidth = popupStyle.strokeWidth;
    }

    var wrapDiv = parentElem.append("div").attr("class", _point_wrap_class);

    var pointDiv = wrapDiv.append("div").attr("class", _point_class).style({ left: pixel[0] + "px", top: pixel[1] + "px" });

    if (animate) {
      if (isScaled) {
        pointDiv.classed("popupPoint", true);
      } else {
        pointDiv.classed("fadeInPoint", true);
      }
    }

    _scaledPopups[chart] = isScaled;

    var gfxDiv = pointDiv.append("div").attr("class", _point_gfx_class).style("background", bgColor).style("width", dotSize + "px").style("height", dotSize + "px");

    if (strokeColor) {
      gfxDiv.style("border-color", strokeColor);
    }

    if (typeof strokeWidth === "number") {
      gfxDiv.style("border-width", strokeWidth);
    }

    return _mapdDraw.AABox2d.initCenterExtents(_mapdDraw.AABox2d.create(), pixel, [dotSize / 2, dotSize / 2]);
  };

  _layer._hidePopup = function (chart, hideCallback) {
    var mapPoint = chart.select("." + _point_class);
    if (mapPoint) {
      if (_scaledPopups[chart]) {
        mapPoint.classed("removePoint", true);
      } else {
        mapPoint.classed("fadeOutPoint", true);
      }

      if (hideCallback) {
        mapPoint.on("animationend", function () {
          hideCallback(chart);
        });
      }

      delete _scaledPopups[chart];
    }
  };

  _layer._destroyLayer = function (chart) {
    var xDim = _layer.xDim();
    if (xDim) {
      xDim.dispose();
    }

    var yDim = _layer.yDim();
    if (yDim) {
      yDim.dispose();
    }
  };

  _layer.setZIndexedLayers = function (chart, prioritizedColors) {
    var layers = chart.getLayers();
    var layerNames = chart.getLayerNames();
    if (layers.length === 1 && layerNames[0] === "pointmap" && prioritizedColors.length) {
      chart.popLayer();
      chart.pushLayer("pointmap", _layer);
    }
  };

  _layer.removeZIndexedLayers = function (chart) {
    var layers = chart.getLayers();
    var layerNames = chart.getLayerNames();
    if (layers.length === 2 && layerNames[0].includes("_z") && layerNames[1].includes("_z")) {
      chart.popAllLayers();
      chart.pushLayer("pointmap", _layer);
    }
  };

  _layer.getLayerNames = function (chart) {
    return chart.getLayerNames();
  };
  return _layer;
}

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = rasterLayerPolyMixin;

var _utilsVega = __webpack_require__(19);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _events = __webpack_require__(15);

var _utils = __webpack_require__(4);

var _coreAsync = __webpack_require__(5);

var _customSqlParser = __webpack_require__(212);

var _customSqlParser2 = _interopRequireDefault(_customSqlParser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var polyDefaultScaleColor = "#d6d7d6";
var polyNullScaleColor = "#d6d7d6";

var vegaLineJoinOptions = ["miter", "round", "bevel"];
var polyTableGeomColumns = {
  // NOTE: the verts are interleaved x,y, so verts[0] = vert0.x, verts[1] = vert0.y, verts[2] = vert1.x, verts[3] = vert1.y, etc.
  // NOTE: legacy columns can be removed once pre-geo rendering is no longer used
  verts_LEGACY: "mapd_geo_coords",
  indices_LEGACY: "mapd_geo_indices",
  linedrawinfo_LEGACY: "mapd_geo_linedrawinfo",
  polydrawinfo_LEGACY: "mapd_geo_polydrawinfo"
};

function validateLineJoin(newLineJoin, currLineJoin) {
  if (typeof newLineJoin !== "string") {
    throw new Error("Line join must be a string and must be one of " + vegaLineJoinOptions.join(", "));
  }
  var lowCase = newLineJoin.toLowerCase();
  if (vegaLineJoinOptions.indexOf(lowCase) < 0) {
    throw new Error("Line join must be a string and must be one of " + vegaLineJoinOptions.join(", "));
  }
  return lowCase;
}

function validateMiterLimit(newMiterLimit, currMiterLimit) {
  if (typeof newMiterLimit !== "number") {
    throw new Error("Miter limit must be a number.");
  } else if (newMiterLimit < 0) {
    throw new Error("Miter limit must be >= 0");
  }
}

function rasterLayerPolyMixin(_layer) {
  _layer.crossfilter = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);
  _layer.filtersInverse = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, false);
  _layer.colorDomain = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);
  var withAlias = "colors"; // aliasing WITH clause for geo joined Choropleth

  (0, _utilsVega.createVegaAttrMixin)(_layer, "lineJoin", vegaLineJoinOptions[0], vegaLineJoinOptions[0], false, {
    preDefault: validateLineJoin,
    preNull: validateLineJoin
  });

  (0, _utilsVega.createVegaAttrMixin)(_layer, "miterLimit", 10, 10, false, {
    preDefault: validateMiterLimit,
    preNull: validateMiterLimit
  });

  var state = null;
  var _vega = null;
  var _cf = null;

  var _scaledPopups = {};

  _layer.setState = function (setter) {
    if (typeof setter === "function") {
      state = setter(state);
    } else {
      state = setter;
    }

    if (!state.hasOwnProperty("transform")) {
      state.transform = {};
    }

    return _layer;
  };

  _layer.getState = function () {
    return state;
  };

  _layer.getProjections = function () {
    return _layer.getTransforms({
      bboxFilter: "",
      filter: "",
      globalFilter: "",
      layerFilter: _layer.filters(),
      filtersInverse: _layer.filtersInverse(),
      state: state,
      lastFilteredSize: _layer.filters().length ? _layer.getState().bboxCount : (0, _coreAsync.lastFilteredSize)(_layer.crossfilter().getId())
    }).filter(function (transform) {
      return transform.type === "project" && transform.hasOwnProperty("as") && transform.as !== "key0";
    }).map(function (projection) {
      return _utils.parser.parseTransform({ select: [] }, projection);
    }).map(function (sql) {
      return sql.select[0];
    });
  };

  function doJoin() {
    return state.data.length > 1;
  }

  _layer.getTransforms = function (_ref) {
    var bboxFilter = _ref.bboxFilter,
        filter = _ref.filter,
        globalFilter = _ref.globalFilter,
        layerFilter = _ref.layerFilter,
        filtersInverse = _ref.filtersInverse,
        state = _ref.state,
        lastFilteredSize = _ref.lastFilteredSize,
        isDataExport = _ref.isDataExport;
    var _state$encoding = state.encoding,
        color = _state$encoding.color,
        geocol = _state$encoding.geocol,
        geoTable = _state$encoding.geoTable;


    var transforms = [];

    // Adds *+ cpu_mode */ in data export query since we are limiting to some number of rows.
    transforms.push({
      type: "project",
      expr: "" + (isDataExport && !doJoin() ? "/*+ cpu_mode */ " : "") + geoTable + "." + geocol,
      as: geocol
    });

    if (doJoin()) {
      var colorProjection = [color.type === "quantitative" ? _utils.parser.parseExpression(color.aggregate) : "SAMPLE(" + color.field + ")"];
      var colorProjectionAs = ["color"];
      var colorField = withAlias + ".color";
      if (typeof color.aggregate === "string") {
        // Custom SQL may include references to both the base table and the
        // geo-join table. The custom SQL is parsed to move references to the
        // base table into the WITH clause, and everything else outside in the
        // parent SELECT.
        // eslint-disable-next-line no-extra-semi
        ;
        var _parseFactsFromCustom = (0, _customSqlParser2.default)(state.data[0].table, withAlias, color.aggregate);

        colorProjection = _parseFactsFromCustom.factProjections;
        colorProjectionAs = _parseFactsFromCustom.factAliases;
        colorField = _parseFactsFromCustom.expression;
      }

      var withClauseTransforms = [];

      var groupby = {
        type: "project",
        expr: state.data[0].table + "." + state.data[0].attr,
        as: "key0"
      };

      transforms.push({
        type: "filter",
        expr: state.data[1].table + "." + state.data[1].attr + " = " + withAlias + ".key0"
      }, { type: "project", expr: withAlias + ".key0", as: "key0" });
      if (typeof bboxFilter === "string" && bboxFilter.length) {
        transforms.push({
          type: "filter",
          expr: bboxFilter
        });
      }

      if (color.type !== "solid") {
        withClauseTransforms.push({
          type: "aggregate",
          fields: colorProjection,
          ops: [null],
          as: colorProjectionAs,
          groupby: groupby
        });

        if (!layerFilter.length) {
          transforms.push({
            type: "project",
            expr: colorField,
            as: "color"
          });
        }
      } else {
        withClauseTransforms.push({
          type: "aggregate",
          fields: [],
          ops: [null],
          as: [],
          groupby: groupby
        });
      }

      if (layerFilter.length && !isDataExport) {
        transforms.push({
          type: "aggregate",
          fields: [_utils.parser.parseExpression({
            type: "case",
            cond: [[{
              type: filtersInverse ? "not in" : "in",
              expr: withAlias + ".key0",
              set: layerFilter
            }, color.type === "solid" ? 1 : colorField]],
            else: null
          })],
          ops: [null],
          as: ["color"],
          groupby: {}
        });
      } else if (layerFilter.length && isDataExport) {
        transforms.push({
          type: "filter",
          expr: _utils.parser.parseExpression({
            type: filtersInverse ? "not in" : "in",
            expr: withAlias + ".key0",
            set: layerFilter
          })
        });
      }
      if (typeof filter === "string" && filter.length) {
        withClauseTransforms.push({
          type: "filter",
          expr: filter
        });
      }
      if (typeof globalFilter === "string" && globalFilter.length) {
        withClauseTransforms.push({
          type: "filter",
          expr: globalFilter
        });
      }
      transforms.push({
        type: "with",
        expr: "" + withAlias,
        fields: {
          source: "" + state.data[0].table,
          type: "root",
          transform: withClauseTransforms
        }
      });
    } else {
      var _colorField = color.type === "quantitative" && typeof color.aggregate === "string" ? color.aggregate : color.field;

      if (color.type !== "solid" && !layerFilter.length) {
        transforms.push({
          type: "project",
          expr: _colorField,
          as: "color"
        });
      }
      if (layerFilter.length && !isDataExport) {
        transforms.push({
          type: "project",
          expr: _utils.parser.parseExpression({
            type: "case",
            cond: [[{
              type: filtersInverse ? "not in" : "in",
              expr: "rowid",
              set: layerFilter
            },
            // Note: When not performing a join, there is no dimension,
            // and color measures do not have aggregates. Just grab the
            // field.
            color.type === "solid" ? 1 : _colorField]],
            else: null
          }),
          as: "color"
        });
      } else if (layerFilter.length && isDataExport) {
        // For Choropleth Data Export, if we have poly selection filter, we don't need to gray out unfiltered polygons
        // Thus, no CASE statement necessary, and we need to include the selected rowid in WHERE clause
        transforms.push({
          type: "filter",
          expr: _utils.parser.parseExpression({
            type: filtersInverse ? "not in" : "in",
            expr: "rowid",
            set: layerFilter
          })
        });
      }
      if (typeof filter === "string") {
        transforms.push({
          type: "filter",
          expr: filter !== "" ? bboxFilter + " AND " + filter : bboxFilter
        });
      }

      if (typeof globalFilter === "string" && globalFilter.length) {
        transforms.push({
          type: "filter",
          expr: globalFilter
        });
      }
    }

    if (typeof state.transform.limit === "number") {
      var doSample = state.transform.sample;
      var doRowid = layerFilter.length;

      if (doSample && doRowid) {
        transforms.push({
          type: "sample",
          method: "multiplicativeRowid",
          expr: layerFilter,
          field: doJoin() ? withAlias + ".key0" : state.data[0].table + "." + state.data[0].attr,
          size: lastFilteredSize || state.transform.tableSize,
          limit: state.transform.limit,
          sampleTable: geoTable
        });
      } else if (doSample) {
        transforms.push({
          type: "sample",
          method: "multiplicative",
          expr: layerFilter,
          size: lastFilteredSize || state.transform.tableSize,
          limit: state.transform.limit,
          sampleTable: geoTable
        });
      }
    }

    return transforms;
  };

  function getColorScaleName(layerName) {
    return layerName + "_fillColor";
  }

  function usesAutoColors() {
    return state.encoding.color.domain === "auto";
  }

  _layer._updateFromMetadata = function (metadata) {
    var layerName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

    if (usesAutoColors() && Array.isArray(metadata.scales)) {
      var colorScaleName = getColorScaleName(layerName);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = metadata.scales[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var scale = _step.value;

          if (scale.name === colorScaleName) {
            _layer.colorDomain(scale.domain);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  };

  _layer.__genVega = function (_ref2) {
    var bboxFilter = _ref2.bboxFilter,
        filter = _ref2.filter,
        globalFilter = _ref2.globalFilter,
        _ref2$layerFilter = _ref2.layerFilter,
        layerFilter = _ref2$layerFilter === undefined ? [] : _ref2$layerFilter,
        lastFilteredSize = _ref2.lastFilteredSize,
        filtersInverse = _ref2.filtersInverse,
        layerName = _ref2.layerName,
        useProjection = _ref2.useProjection;

    var autocolors = usesAutoColors();
    var getStatsLayerName = function getStatsLayerName() {
      return layerName + "_stats";
    };

    var data = [{
      name: layerName,
      format: "polys",
      sql: _utils.parser.writeSQL({
        type: "root",
        source: doJoin() ? state.data[1].table + ", " + withAlias : "" + state.data[0].table,
        transform: _layer.getTransforms({
          bboxFilter: bboxFilter,
          filter: filter,
          globalFilter: globalFilter,
          layerFilter: layerFilter,
          filtersInverse: filtersInverse,
          state: state,
          lastFilteredSize: lastFilteredSize
        })
      }),
      enableHitTesting: true // poly enableHitTesting will be always true to support 1. Hittesting 2. poly selection filter
    }];

    if (autocolors) {
      data.push({
        name: getStatsLayerName(),
        source: layerName,
        transform: [{
          type: "aggregate",
          fields: ["color", "color", "color", "color"],
          ops: ["min", "max", "avg", "stddev"],
          as: ["mincol", "maxcol", "avgcol", "stdcol"]
        }, {
          type: "formula",
          expr: "max(mincol, avgcol-2*stdcol)",
          as: "mincolor"
        }, {
          type: "formula",
          expr: "min(maxcol, avgcol+2*stdcol)",
          as: "maxcolor"
        }]
      });
    }

    var scales = [];
    var fillColor = {};

    var useColorScale = !(state.encoding.color.type === "solid");
    if (layerFilter.length && !useColorScale) {
      var colorScaleName = getColorScaleName(layerName);
      scales.push({
        name: colorScaleName,
        type: "ordinal",
        domain: [1],
        range: [(0, _utilsVega.adjustOpacity)(state.encoding.color.value, state.encoding.color.opacity)],
        nullValue: (0, _utilsVega.adjustOpacity)(polyNullScaleColor, state.encoding.color.opacity || 0.65),
        default: (0, _utilsVega.adjustOpacity)(polyDefaultScaleColor, state.encoding.color.hasOwnProperty("showOther") && state.encoding.color.showOther === false ? 0 : state.encoding.color.opacity ? state.encoding.color.opacity : 0.65)
      });
      fillColor = {
        scale: colorScaleName,
        field: "color"
      };
    } else if (useColorScale) {
      var colorRange = state.encoding.color.range.map(function (c) {
        return (0, _utilsVega.adjustOpacity)(c, state.encoding.color.opacity);
      });
      var _colorScaleName = getColorScaleName(layerName);
      if (state.encoding.color.type === "quantitative") {
        scales.push({
          name: _colorScaleName,
          type: "quantize",
          domain: autocolors ? { data: getStatsLayerName(), fields: ["mincolor", "maxcolor"] } : state.encoding.color.domain,
          range: colorRange,
          nullValue: (0, _utilsVega.adjustOpacity)(polyNullScaleColor, state.encoding.color.opacity || 0.65),
          default: (0, _utilsVega.adjustOpacity)(polyDefaultScaleColor, state.encoding.color.opacity || 0.65)
        });
      } else {
        scales.push({
          name: _colorScaleName,
          type: "ordinal",
          domain: state.encoding.color.domain,
          range: colorRange,
          nullValue: (0, _utilsVega.adjustOpacity)(polyNullScaleColor, state.encoding.color.opacity || 0.65),
          default: (0, _utilsVega.adjustOpacity)(state.encoding.color.defaultOtherRange || state.encoding.color.default, state.encoding.color.hasOwnProperty("showOther") && state.encoding.color.showOther === false ? 0 // When Other is toggled OFF, we make the Other category transparent
          : state.encoding.color.opacity ? state.encoding.color.opacity : 0.65)
        });
      }

      fillColor = {
        scale: _colorScaleName,
        field: "color"
      };
    } else {
      fillColor = {
        value: (0, _utilsVega.adjustOpacity)(state.encoding.color.value, state.encoding.color.opacity)
      };
    }

    var defaultMarkOptions = {
      strokeColor: "white",
      lineJoin: "miter",
      miterLimit: 10,
      strokeWidth: 0
    };
    var mark = _typeof(state.mark) === "object" ? state.mark : defaultMarkOptions;

    var marks = [{
      type: "polys",
      from: {
        data: layerName
      },
      properties: {
        x: {
          field: "x"
        },
        y: {
          field: "y"
        },
        fillColor: fillColor,
        /*
          "fillColor" is a special keyword to set strokeColor the same as fillColor
          otherwise it will be strokeColor or white
        */
        strokeColor: mark.strokeColor === "fillColor" ? fillColor : mark.strokeColor,
        strokeWidth: mark.strokeWidth,
        lineJoin: mark.lineJoin,
        miterLimit: mark.miterLimit
      }
    }];

    if (useProjection) {
      marks[0].transform = {
        projection: "mercator_map_projection"
      };
    } else {
      marks[0].properties.x.scale = "x";
      marks[0].properties.y.scale = "y";
    }

    return {
      data: data,
      scales: scales,
      marks: marks
    };
  };

  _layer._requiresCap = function () {
    // polys don't require a cap
    return false;
  };

  _layer.viewBoxDim = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);

  _layer._genVega = function (chart, layerName, group) {
    var mapBounds = chart.map().getBounds();

    var columnExpr = _layer.getState().encoding.geoTable + "." + _layer.getState().encoding.geocol;

    var bboxFilter = "ST_XMax(" + columnExpr + ") >= " + mapBounds._sw.lng + " AND ST_XMin(" + columnExpr + ") <= " + mapBounds._ne.lng + " AND ST_YMax(" + columnExpr + ") >= " + mapBounds._sw.lat + " AND ST_YMin(" + columnExpr + ") <= " + mapBounds._ne.lat;

    var allFilters = _layer.crossfilter().getFilter(layerName);
    var otherChartFilters = allFilters.filter(function (f, i) {
      return i !== _layer.dimension().getDimensionIndex() && f !== "" && f != null;
    });

    var polyFilterString = "";
    var firstElem = true;

    otherChartFilters.forEach(function (value) {
      if (!firstElem) {
        polyFilterString += " AND ";
      }
      firstElem = false;
      polyFilterString += value;
    });

    _vega = _layer.__genVega({
      layerName: layerName,
      bboxFilter: bboxFilter,
      filter: polyFilterString,
      globalFilter: _layer.crossfilter().getGlobalFilterString(),
      layerFilter: _layer.filters(),
      lastFilteredSize: _layer.getState().bboxCount,
      filtersInverse: _layer.filtersInverse(),
      useProjection: chart._useGeoTypes
    });
    return _vega;
  };

  _layer._addRenderAttrsToPopupColumnSet = function (chart, popupColsSet) {
    // add the poly geometry to the query

    if (chart._useGeoTypes) {
      if (state.encoding.geocol) {
        popupColsSet.add(state.encoding.geocol);
      }
    } else {
      popupColsSet.add(polyTableGeomColumns.verts_LEGACY);
      popupColsSet.add(polyTableGeomColumns.linedrawinfo_LEGACY);
    }

    if (_vega && Array.isArray(_vega.marks) && _vega.marks.length > 0 && _vega.marks[0].properties) {
      _utilsVega.renderAttributes.forEach(function (rndrProp) {
        if (rndrProp !== "x" && rndrProp !== "y") {
          _layer._addQueryDrivenRenderPropToSet(popupColsSet, _vega.marks[0].properties, rndrProp);
        }
      });
    }
  };

  _layer._areResultsValidForPopup = function (results) {
    if (state.encoding.geocol && results[state.encoding.geocol] || results[polyTableGeomColumns.verts_LEGACY] && results[polyTableGeomColumns.linedrawinfo_LEGACY]) {
      return true;
    }
    return false;
  };

  var _filtersArray = [];
  var _isInverseFilter = false;
  var polyLayerEvents = ["filtered"];
  var _listeners = _d2.default.dispatch.apply(_d2.default, polyLayerEvents);

  _layer.filter = function (key, isInverseFilter, filterCol, chart) {
    if (isInverseFilter !== _layer.filtersInverse()) {
      _layer.filterAll(chart);
      _layer.filtersInverse(isInverseFilter);
    }
    if (_filtersArray.includes(key)) {
      _filtersArray = _filtersArray.filter(function (v) {
        return v !== key;
      });
    } else {
      _filtersArray = [].concat(_toConsumableArray(_filtersArray), [key]);
    }

    if (filterCol === "key0" && _layer.getState().data.length > 1) {
      // groupby col is always fact table column
      filterCol = _layer.getState().data[0].table + "." + _layer.getState().data[0].attr;
    }

    if (_filtersArray.length === 1 && filterCol) {
      _layer.dimension().set(function () {
        return [filterCol];
      });
      _layer.viewBoxDim(null);
    }

    _filtersArray.length && filterCol ? _layer.dimension().filterMulti(_filtersArray, undefined, isInverseFilter) : _layer.filterAll(chart);
  };

  _layer.filters = function () {
    return _filtersArray;
  };

  _layer.filterAll = function (chart) {
    _filtersArray = [];
    _layer.dimension().filterAll();
    var geoCol = _layer.getState().encoding.geoTable + "." + _layer.getState().encoding.geocol;

    // when poly selection filter cleared, we reapply the bbox filter for the NON geo joined poly
    // For geo joined poly, we don't run crossfilter
    if (_layer && _layer.getState().data && _layer.getState().data.length < 2) {
      var viewboxdim = _layer.dimension().set(function () {
        return [geoCol];
      });
      var mapBounds = chart.map().getBounds();
      _layer.viewBoxDim(viewboxdim);
      _layer.viewBoxDim().filterST_Min_ST_Max({
        lonMin: mapBounds._sw.lng,
        lonMax: mapBounds._ne.lng,
        latMin: mapBounds._sw.lat,
        latMax: mapBounds._ne.lat
      });
    }

    _listeners.filtered(_layer, _filtersArray);
  };

  _layer.on = function (event, listener) {
    _listeners.on(event, listener);
    return _layer;
  };

  _layer._displayPopup = function (svgProps) {
    return (0, _utilsVega.__displayPopup)(_extends({}, svgProps, { _vega: _vega, _layer: _layer, state: state }));
  };

  // We disabled polygon selection filter from Master layer if the chart has more than one poly layer in 4.7 release, FE-8685.
  // Since we run rowid filter on poly selection filter, it is not correct to run same rowid filter for all overlapping poly layers.
  // We need better UI/UX design for this
  function chartHasMoreThanOnePolyLayers(chart) {
    var polyLayers = chart && chart.getAllLayers().length ? chart.getAllLayers().filter(function (layer) {
      return layer.layerType() === "polys";
    }) : [];
    return polyLayers.length > 1;
  }

  _layer.onClick = function (chart, data, event) {
    if (!data) {
      return;
    } else if (_layer.getState().currentLayer === "master" && chartHasMoreThanOnePolyLayers(chart)) {
      // don't filter from Master, FE-8685
      return;
    }
    var isInverseFilter = Boolean(event && (event.metaKey || event.ctrlKey));

    var filterKey = Object.keys(data).find(function (k) {
      return k === "rowid" || k === "key0";
    });

    chart.hidePopup();
    _events.events.trigger(function () {
      new Promise(function (resolve) {
        _layer.filter(data[filterKey], isInverseFilter, filterKey, chart);
        _listeners.filtered(_layer, _filtersArray);
        chart.filter(data[filterKey], isInverseFilter);
        resolve("filtered");
      }).then(function () {
        chart.redrawGroup();
      });
    });
  };

  _layer._hidePopup = function (chart, hideCallback) {
    var mapPoly = chart.select(".map-poly");
    if (mapPoly) {
      if (_scaledPopups[chart]) {
        mapPoly.classed("removePoly", true);
      } else {
        mapPoly.classed("fadeOutPoly", true);
        // mapPoly.attr('transform', 'scale(0, 0)');
      }

      if (hideCallback) {
        mapPoly.on("animationend", function () {
          hideCallback(chart);
        });
      }

      delete _scaledPopups[chart];
    }
  };

  _layer._destroyLayer = function (chart) {
    _layer.on("filtered", null);
    var viewBoxDim = _layer.viewBoxDim();
    var dim = _layer.dimension();
    if (viewBoxDim) {
      viewBoxDim.dispose();
    }
    if (dim) {
      dim.dispose();
    }
    // deleteCanvas(chart)
  };

  return _layer;
}

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = parseFactsFromCustomSQL;

var _chevrotain = __webpack_require__(213);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // This implements a simple parser for custom SQL expressions. It's mostly
// based on the postgres documentation with notes about the bits that were
// skipped. I'm not sure how much of the postgres spec core implements; it's
// possible some of the skipped bits aren't even implemented in core anyway.
// I've made an attempt to implement all of the SQL standard stuff.


var Whitespace = (0, _chevrotain.createToken)({
  name: "Whitespace",
  pattern: /\s+/,
  group: _chevrotain.Lexer.SKIPPED
});

// We need to define the Identifier here, to use as a "longer_alt" for all
// keywords. But it'll appear after keywords in the tokenizer.
//
// XXX:
// support for non-latin characters?
// U&"..." identifiers?
// U&"..." UESCAPE '?' identifiers?
var Identifier = (0, _chevrotain.createToken)({ name: "Identifier", pattern: _chevrotain.Lexer.NA });
var UnquotedIdentifier = (0, _chevrotain.createToken)({
  name: "UnquotedIdentifier",
  pattern: /[a-zA-Z_]\w*/,
  categories: [Identifier]
});
var QuotedIdentifier = (0, _chevrotain.createToken)({
  name: "QuotedIdentifier",
  pattern: /"(?:[^"]|"")+"/,
  categories: [Identifier]
});

// XXX:
// Window functions (OVER, PARTITION BY, USING, NULLS, FIRST, LAST, etc)
// Type casts (CAST ... AS ...)
// COLLATE
// Sub-queries (SELECT, et al)
// ARRAY
// ROW
var Keyword = (0, _chevrotain.createToken)({ name: "Keyword", pattern: _chevrotain.Lexer.NA });
var All = (0, _chevrotain.createToken)({
  name: "All",
  pattern: /all/i,
  categories: [Keyword],
  longer_alt: UnquotedIdentifier
});
var Distinct = (0, _chevrotain.createToken)({
  name: "Distinct",
  pattern: /distinct/i,
  categories: [Keyword],
  longer_alt: UnquotedIdentifier
});
var OrderBy = (0, _chevrotain.createToken)({
  name: "OrderBy",
  pattern: /order by/i,
  categories: [Keyword]
});
var Asc = (0, _chevrotain.createToken)({
  name: "Ascending",
  pattern: /asc/i,
  categories: [Keyword],
  longer_alt: UnquotedIdentifier
});
var Desc = (0, _chevrotain.createToken)({
  name: "Descending",
  pattern: /desc/i,
  categories: [Keyword],
  longer_alt: UnquotedIdentifier
});
var Cast = (0, _chevrotain.createToken)({
  name: "Cast",
  pattern: /cast/i,
  categories: [Keyword],
  longer_alt: UnquotedIdentifier
});
var As = (0, _chevrotain.createToken)({
  name: "As",
  pattern: /as/i,
  categories: [Keyword],
  longer_alt: UnquotedIdentifier
});
var Case = (0, _chevrotain.createToken)({
  name: "Case",
  pattern: /case/i,
  categories: [Keyword],
  longer_alt: UnquotedIdentifier
});
var When = (0, _chevrotain.createToken)({
  name: "When",
  pattern: /when/i,
  categories: [Keyword],
  longer_alt: UnquotedIdentifier
});
var Then = (0, _chevrotain.createToken)({
  name: "Then",
  pattern: /then/i,
  categories: [Keyword],
  longer_alt: UnquotedIdentifier
});
var Else = (0, _chevrotain.createToken)({
  name: "Else",
  pattern: /else/i,
  categories: [Keyword],
  longer_alt: UnquotedIdentifier
});
var End = (0, _chevrotain.createToken)({
  name: "End",
  pattern: /end/i,
  categories: [Keyword],
  longer_alt: UnquotedIdentifier
});

// XXX:
// E'...' string constants?
// U&'...' string constants?
// U&'...' UESCAPE '?' string constants?
// $$...$$ string constants?
// bit constants?
var Constant = (0, _chevrotain.createToken)({ name: "Constant", pattern: _chevrotain.Lexer.NA });
var StringConstant = (0, _chevrotain.createToken)({
  name: "StringConstant",
  pattern: /'(?:[^']|'')*'(?:\s*\n\s*'(?:[^']|'')*')*/,
  categories: [Constant],
  line_breaks: true
});
var NumericConstant = (0, _chevrotain.createToken)({
  name: "NumericConstant",
  pattern: /(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?/,
  categories: [Constant]
});
var BooleanConstant = (0, _chevrotain.createToken)({
  name: "BooleanConstant",
  pattern: /(?:true|false)/i,
  categories: [Constant]
});

// XXX:
// OVERLAPS
// SIMILAR
// BETWEEN SYMMETRIC
// DISTINCT FROM
// ISNULL
// NOTNULL
// IS UNKNOWN
var Operator = (0, _chevrotain.createToken)({ name: "Operator", pattern: _chevrotain.Lexer.NA });

var AllColumns = (0, _chevrotain.createToken)({ name: "AllColumns", pattern: _chevrotain.Lexer.NA });
var PrefixOperator = (0, _chevrotain.createToken)({
  name: "PrefixOperator",
  pattern: _chevrotain.Lexer.NA,
  categories: [Operator]
});
var BinaryOperator = (0, _chevrotain.createToken)({
  name: "BinaryOperator",
  pattern: _chevrotain.Lexer.NA,
  categories: [Operator]
});

var ExponentiationOperator = (0, _chevrotain.createToken)({
  name: "ExponentOperator",
  pattern: /\^/,
  categories: [BinaryOperator]
});

var MultiplicativeOperator = (0, _chevrotain.createToken)({
  name: "MultiplicativeOperator",
  pattern: _chevrotain.Lexer.NA,
  categories: [BinaryOperator]
});
var MultiplicationOperator = (0, _chevrotain.createToken)({
  name: "MultiplicationOperator",
  pattern: /\*/,
  categories: [MultiplicativeOperator, AllColumns]
});
var DivisionOperator = (0, _chevrotain.createToken)({
  name: "DivisionOperator",
  pattern: /\//,
  categories: [MultiplicativeOperator]
});
var ModuloOperator = (0, _chevrotain.createToken)({
  name: "ModuloOperator",
  pattern: /%/,
  categories: [MultiplicativeOperator]
});

var AdditiveOperator = (0, _chevrotain.createToken)({
  name: "AdditiveOperator",
  pattern: _chevrotain.Lexer.NA,
  categories: [BinaryOperator, PrefixOperator]
});
var AdditionOperator = (0, _chevrotain.createToken)({
  name: "AdditionOperator",
  pattern: /\+/,
  categories: [AdditiveOperator]
});
var SubtractionOperator = (0, _chevrotain.createToken)({
  name: "SubtractionOperator",
  pattern: /-/,
  categories: [AdditiveOperator]
});

var MembershipOperator = (0, _chevrotain.createToken)({
  name: "MembershipOperator",
  pattern: _chevrotain.Lexer.NA,
  categories: [BinaryOperator]
});
var BetweenOperator = (0, _chevrotain.createToken)({
  name: "BetweenOperator",
  pattern: /between/i,
  categories: [MembershipOperator],
  longer_alt: UnquotedIdentifier
});
var InOperator = (0, _chevrotain.createToken)({
  name: "InOperator",
  pattern: /in/i,
  categories: [MembershipOperator],
  longer_alt: UnquotedIdentifier
});
var LikeOperator = (0, _chevrotain.createToken)({
  name: "LikeOperator",
  pattern: /i?like/i,
  categories: [MembershipOperator],
  longer_alt: UnquotedIdentifier
});

var ComparisonOperator = (0, _chevrotain.createToken)({
  name: "ComparisonOperator",
  pattern: _chevrotain.Lexer.NA,
  categories: [BinaryOperator]
});
var EqualityOperator = (0, _chevrotain.createToken)({
  name: "EqualityOperator",
  pattern: "=",
  categories: [ComparisonOperator]
});
var InequalityOperator = (0, _chevrotain.createToken)({
  name: "InequalityOperator",
  pattern: /(?:<>|!=)/,
  categories: [ComparisonOperator]
});
var LessThanOperator = (0, _chevrotain.createToken)({
  name: "LessThanOperator",
  pattern: "<",
  categories: [ComparisonOperator]
});
var LessThanEqualOperator = (0, _chevrotain.createToken)({
  name: "LessThanEqualOperator",
  pattern: "<=",
  categories: [ComparisonOperator]
});
var GreaterThanOperator = (0, _chevrotain.createToken)({
  name: "GreaterThanOperator",
  pattern: ">",
  categories: [ComparisonOperator]
});
var GreaterThanEqualOperator = (0, _chevrotain.createToken)({
  name: "GreaterThanEqualOperator",
  pattern: ">=",
  categories: [ComparisonOperator]
});

var IsOperator = (0, _chevrotain.createToken)({
  name: "IsOperator",
  pattern: /is/i,
  categories: [BinaryOperator],
  longer_alt: UnquotedIdentifier
});
var IsPredicate = (0, _chevrotain.createToken)({
  name: "IsPredicate",
  pattern: _chevrotain.Lexer.NA
});

var Not = (0, _chevrotain.createToken)({
  name: "Not",
  pattern: /not/i,
  categories: [PrefixOperator, Keyword],
  longer_alt: UnquotedIdentifier
});
var Null = (0, _chevrotain.createToken)({
  name: "Null",
  pattern: /null/i,
  categories: [IsPredicate, Keyword],
  longer_alt: UnquotedIdentifier
});
var True = (0, _chevrotain.createToken)({
  name: "True",
  pattern: /true/i,
  categories: [IsPredicate, Keyword],
  longer_alt: UnquotedIdentifier
});
var False = (0, _chevrotain.createToken)({
  name: "False",
  pattern: /false/i,
  categories: [IsPredicate, Keyword],
  longer_alt: UnquotedIdentifier
});
var And = (0, _chevrotain.createToken)({
  name: "And",
  pattern: /and/i,
  categories: [BinaryOperator, Keyword],
  longer_alt: UnquotedIdentifier
});
var Or = (0, _chevrotain.createToken)({
  name: "Or",
  pattern: /or/i,
  categories: [BinaryOperator, Keyword],
  longer_alt: UnquotedIdentifier
});

// XXX:
// Array elements with brackets ([])
// Array slices with :
// Type cast with ::
var Punctuation = (0, _chevrotain.createToken)({ name: "Punctuation", pattern: _chevrotain.Lexer.NA });
var OpenParen = (0, _chevrotain.createToken)({
  name: "OpenParenthesis",
  pattern: /\(/,
  categories: [Punctuation]
});
var CloseParen = (0, _chevrotain.createToken)({
  name: "CloseParenthesis",
  pattern: /\)/,
  categories: [Punctuation]
});
var Comma = (0, _chevrotain.createToken)({
  name: "Comma",
  pattern: /,/,
  categories: [Punctuation]
});
var Dot = (0, _chevrotain.createToken)({
  name: "Dot",
  pattern: /\./,
  categories: [Punctuation]
});

var allTokens = [Whitespace,

// keywords must come before Identifiers
All, Distinct, OrderBy, Asc, Desc, Cast, As, Case, When, Then, Else, End, MembershipOperator, BetweenOperator, InOperator, LikeOperator, IsOperator, IsPredicate, Not, Null, True, False, And, Or,

// Identifiers must come after any keywords because UnquotedIdentifier would
// match them, but before any symbols because a QuotedIdentifier can
// technically contain anything
Identifier, UnquotedIdentifier, QuotedIdentifier, Constant, StringConstant, NumericConstant, BooleanConstant, Operator, PrefixOperator, BinaryOperator, ExponentiationOperator, MultiplicativeOperator, MultiplicationOperator, DivisionOperator, ModuloOperator, AdditiveOperator, AdditionOperator, SubtractionOperator, ComparisonOperator, EqualityOperator, InequalityOperator, LessThanOperator, LessThanEqualOperator, GreaterThanOperator, GreaterThanEqualOperator, OpenParen, CloseParen, Comma, Dot];

var sqlLexer = new _chevrotain.Lexer(allTokens);

var SQLParser = function (_CstParser) {
  _inherits(SQLParser, _CstParser);

  function SQLParser() {
    _classCallCheck(this, SQLParser);

    var _this = _possibleConstructorReturn(this, (SQLParser.__proto__ || Object.getPrototypeOf(SQLParser)).call(this, allTokens));

    _this.RULE("expression", function () {
      _this.SUBRULE(_this.disjunctiveExpression);
    });

    _this.RULE("disjunctiveExpression", function () {
      _this.SUBRULE(_this.conjunctiveExpression, { LABEL: "lhs" });
      _this.MANY(function () {
        _this.CONSUME(Or, { LABEL: "operator" });
        _this.SUBRULE2(_this.conjunctiveExpression, { LABEL: "rhs" });
      });
    });

    _this.RULE("conjunctiveExpression", function () {
      _this.SUBRULE(_this.negationExpression, { LABEL: "lhs" });
      _this.MANY(function () {
        _this.CONSUME(And, { LABEL: "operator" });
        _this.SUBRULE2(_this.negationExpression, { LABEL: "rhs" });
      });
    });

    _this.RULE("negationExpression", function () {
      _this.OPTION(function () {
        return _this.CONSUME(Not);
      });
      _this.SUBRULE(_this.isExpression);
    });

    _this.RULE("isExpression", function () {
      _this.SUBRULE(_this.comparisonExpression, { LABEL: "expression" });
      _this.OPTION(function () {
        _this.CONSUME(IsOperator);
        _this.OPTION2(function () {
          return _this.CONSUME(Not);
        });
        _this.CONSUME(IsPredicate);
      });
    });

    _this.RULE("comparisonExpression", function () {
      _this.SUBRULE(_this.membershipExpression, { LABEL: "lhs" });
      _this.OPTION(function () {
        _this.CONSUME(ComparisonOperator, { LABEL: "operator" });
        _this.SUBRULE2(_this.membershipExpression, { LABEL: "rhs" });
      });
    });

    _this.RULE("membershipExpression", function () {
      _this.SUBRULE(_this.additiveExpression, { LABEL: "lhs" });
      _this.OPTION(function () {
        _this.OPTION2(function () {
          return _this.CONSUME(Not);
        });
        _this.OR([{
          ALT: function ALT() {
            _this.CONSUME(BetweenOperator, { LABEL: "betweenOperator" });
            _this.SUBRULE2(_this.additiveExpression, { LABEL: "lowerBound" });
            _this.CONSUME(And);
            _this.SUBRULE3(_this.additiveExpression, { LABEL: "upperBound" });
          }
        }, {
          ALT: function ALT() {
            _this.CONSUME(InOperator, { LABEL: "inOperator" });
            _this.CONSUME(OpenParen);
            _this.AT_LEAST_ONE_SEP({
              SEP: Comma,
              DEF: function DEF() {
                return _this.SUBRULE(_this.expression, { LABEL: "set" });
              }
            });
            _this.CONSUME(CloseParen);
          }
        }, {
          ALT: function ALT() {
            _this.CONSUME(LikeOperator, { LABEL: "likeOperator" });
            _this.SUBRULE4(_this.additiveExpression, { LABEL: "rhs" });
          }
        }]);
      });
    });

    _this.RULE("additiveExpression", function () {
      _this.SUBRULE(_this.multiplicativeExpression, { LABEL: "lhs" });
      _this.MANY(function () {
        _this.CONSUME(AdditiveOperator, { LABEL: "operator" });
        _this.SUBRULE2(_this.multiplicativeExpression, { LABEL: "rhs" });
      });
    });

    _this.RULE("multiplicativeExpression", function () {
      _this.SUBRULE(_this.exponentiationExpression, { LABEL: "lhs" });
      _this.MANY(function () {
        _this.CONSUME(MultiplicativeOperator, { LABEL: "operator" });
        _this.SUBRULE2(_this.exponentiationExpression, { LABEL: "rhs" });
      });
    });

    _this.RULE("exponentiationExpression", function () {
      _this.SUBRULE(_this.atomicExpression, { LABEL: "lhs" });
      _this.MANY(function () {
        _this.CONSUME(ExponentiationOperator, { LABEL: "operator" });
        _this.SUBRULE2(_this.atomicExpression, { LABEL: "rhs" });
      });
    });

    _this.RULE("atomicExpression", function () {
      _this.OR([{ ALT: function ALT() {
          return _this.SUBRULE(_this.parenthesesExpression);
        } }, { ALT: function ALT() {
          return _this.SUBRULE(_this.caseExpression);
        } }, { ALT: function ALT() {
          return _this.SUBRULE(_this.castExpression);
        } }, { ALT: function ALT() {
          return _this.SUBRULE(_this.functionExpression);
        } }, { ALT: function ALT() {
          return _this.SUBRULE(_this.prefixExpression);
        } }, { ALT: function ALT() {
          return _this.SUBRULE(_this.columnExpression);
        } }, { ALT: function ALT() {
          return _this.CONSUME(Constant);
        } }]);
    });

    _this.RULE("parenthesesExpression", function () {
      _this.CONSUME(OpenParen);
      _this.SUBRULE(_this.expression);
      _this.CONSUME(CloseParen);
    });

    _this.RULE("caseExpression", function () {
      _this.CONSUME(Case);
      _this.OPTION(function () {
        return _this.SUBRULE(_this.expression);
      });
      _this.AT_LEAST_ONE(function () {
        _this.CONSUME(When);
        _this.SUBRULE2(_this.expression, { LABEL: "condition" });
        _this.CONSUME(Then);
        _this.SUBRULE3(_this.expression, { LABEL: "result" });
      });
      _this.OPTION2(function () {
        _this.CONSUME(Else);
        _this.SUBRULE4(_this.expression, { LABEL: "else" });
      });
      _this.CONSUME(End);
    });

    _this.RULE("castExpression", function () {
      _this.CONSUME(Cast);
      _this.CONSUME(OpenParen);
      _this.SUBRULE(_this.expression);
      _this.CONSUME(As);
      _this.CONSUME(UnquotedIdentifier, { LABEL: "castTo" });
      _this.CONSUME(CloseParen);
    });

    _this.RULE("orderByExpression", function () {
      _this.SUBRULE(_this.expression);
      _this.OPTION(function () {
        _this.OR([{ ALT: function ALT() {
            return _this.CONSUME(Asc, { LABEL: "asc" });
          } }, { ALT: function ALT() {
            return _this.CONSUME(Desc, { LABEL: "desc" });
          } }]);
      });
    });

    _this.RULE("orderBy", function () {
      _this.CONSUME(OrderBy);
      _this.AT_LEAST_ONE_SEP({
        SEP: Comma,
        DEF: function DEF() {
          _this.SUBRULE(_this.orderByExpression);
        }
      });
    });

    _this.RULE("functionExpression", function () {
      _this.CONSUME(UnquotedIdentifier, { LABEL: "function" });
      _this.CONSUME(OpenParen);
      _this.OR1([{ ALT: function ALT() {
          return _this.CONSUME(AllColumns);
        } }, {
        ALT: function ALT() {
          _this.OPTION1(function () {
            _this.OR2([{ ALT: function ALT() {
                return _this.CONSUME(All);
              } }, { ALT: function ALT() {
                return _this.CONSUME(Distinct);
              } }]);
          });
          _this.AT_LEAST_ONE_SEP({
            SEP: Comma,
            DEF: function DEF() {
              _this.SUBRULE(_this.expression);
            }
          });
          _this.OPTION2(function () {
            _this.SUBRULE(_this.orderBy);
          });
        }
      }]);
      _this.CONSUME(CloseParen);
    });

    _this.RULE("prefixExpression", function () {
      _this.CONSUME(PrefixOperator, { LABEL: "operator" });
      _this.SUBRULE(_this.expression);
    });

    _this.RULE("columnExpression", function () {
      _this.OPTION(function () {
        _this.CONSUME1(Identifier, { LABEL: "table" });
        _this.CONSUME(Dot);
      });
      _this.CONSUME2(Identifier, { LABEL: "column" });
    });

    _this.performSelfAnalysis();
    return _this;
  }

  return SQLParser;
}(_chevrotain.CstParser);

var sqlParser = new SQLParser();

var SQLVisitor = function (_sqlParser$getBaseCst) {
  _inherits(SQLVisitor, _sqlParser$getBaseCst);

  function SQLVisitor() {
    _classCallCheck(this, SQLVisitor);

    var _this2 = _possibleConstructorReturn(this, (SQLVisitor.__proto__ || Object.getPrototypeOf(SQLVisitor)).call(this));

    _this2.validateVisitor();
    return _this2;
  }

  _createClass(SQLVisitor, [{
    key: "expression",
    value: function expression(ctx) {
      return this.visit(ctx.disjunctiveExpression);
    }
  }, {
    key: "disjunctiveExpression",
    value: function disjunctiveExpression(ctx) {
      var _this3 = this;

      var result = this.visit(ctx.lhs);
      if (ctx.rhs) {
        ctx.rhs.forEach(function (operand, idx) {
          var rhs = _this3.visit(operand);
          result = {
            type: "BinaryExpression",
            operator: ctx.operator[idx].image,
            lhs: result,
            rhs: rhs,
            start: result.start,
            end: rhs.end
          };
        });
      }
      return result;
    }
  }, {
    key: "conjunctiveExpression",
    value: function conjunctiveExpression(ctx) {
      var _this4 = this;

      var result = this.visit(ctx.lhs);
      if (ctx.rhs) {
        ctx.rhs.forEach(function (operand, idx) {
          var rhs = _this4.visit(operand);
          result = {
            type: "BinaryExpression",
            operator: ctx.operator[idx].image,
            lhs: result,
            rhs: rhs,
            start: result.start,
            end: rhs.end
          };
        });
      }
      return result;
    }
  }, {
    key: "negationExpression",
    value: function negationExpression(ctx) {
      var result = this.visit(ctx.isExpression);
      if (ctx.Not) {
        result = _extends({}, result, {
          negated: !result.negated,
          start: ctx.Not[0].startOffset
        });
      }
      return result;
    }
  }, {
    key: "isExpression",
    value: function isExpression(ctx) {
      var result = this.visit(ctx.expression);
      if (ctx.IsOperator) {
        result = {
          type: "IsExpression",
          expression: result,
          negated: Boolean(ctx.Not),
          is: ctx.IsPredicate[0].image,
          start: result.start,
          end: ctx.IsPredicate[0].endOffset
        };
      }
      return result;
    }
  }, {
    key: "comparisonExpression",
    value: function comparisonExpression(ctx) {
      var result = this.visit(ctx.lhs);
      if (ctx.rhs) {
        var rhs = this.visit(ctx.rhs);
        result = {
          type: "BinaryExpression",
          operator: ctx.operator[0].image,
          lhs: result,
          rhs: rhs,
          start: result.start,
          end: rhs.end
        };
      }
      return result;
    }
  }, {
    key: "membershipExpression",
    value: function membershipExpression(ctx) {
      var _this5 = this;

      var result = this.visit(ctx.lhs);
      var negated = Boolean(ctx.Not);
      if (ctx.betweenOperator) {
        var lowerBound = this.visit(ctx.lowerBound);
        var upperBound = this.visit(ctx.upperBound);
        result = {
          type: "BetweenExpression",
          lhs: result,
          lowerBound: lowerBound,
          upperBound: upperBound,
          negated: negated,
          start: result.start,
          end: upperBound.end
        };
      } else if (ctx.inOperator) {
        result = {
          type: "InExpression",
          lhs: result,
          in: ctx.set.map(function (expression) {
            return _this5.visit(expression);
          }),
          negated: negated,
          start: result.start,
          end: ctx.CloseParen[0].endOffset
        };
      } else if (ctx.likeOperator) {
        var rhs = this.visit(ctx.rhs);
        result = {
          type: "BinaryExpression",
          lhs: result,
          rhs: rhs,
          negated: negated,
          start: result.start,
          end: rhs.end
        };
      }
      return result;
    }
  }, {
    key: "additiveExpression",
    value: function additiveExpression(ctx) {
      var _this6 = this;

      var result = this.visit(ctx.lhs);
      if (ctx.rhs) {
        ctx.rhs.forEach(function (operand, idx) {
          var rhs = _this6.visit(operand);
          result = {
            type: "BinaryExpression",
            operator: ctx.operator[idx].image,
            lhs: result,
            rhs: rhs,
            start: result.start,
            end: rhs.end
          };
        });
      }
      return result;
    }
  }, {
    key: "multiplicativeExpression",
    value: function multiplicativeExpression(ctx) {
      var _this7 = this;

      var result = this.visit(ctx.lhs);
      if (ctx.rhs) {
        ctx.rhs.forEach(function (operand, idx) {
          var rhs = _this7.visit(operand);
          result = {
            type: "BinaryExpression",
            operator: ctx.operator[idx].image,
            lhs: result,
            rhs: rhs,
            start: result.start,
            end: rhs.end
          };
        });
      }
      return result;
    }
  }, {
    key: "exponentiationExpression",
    value: function exponentiationExpression(ctx) {
      var _this8 = this;

      var result = this.visit(ctx.lhs);
      if (ctx.rhs) {
        ctx.rhs.forEach(function (operand, idx) {
          var rhs = _this8.visit(operand);
          result = {
            type: "BinaryExpression",
            operator: ctx.operator[idx].image,
            lhs: result,
            rhs: rhs,
            start: result.start,
            end: rhs.end
          };
        });
      }
      return result;
    }
  }, {
    key: "atomicExpression",
    value: function atomicExpression(ctx) {
      if (ctx.parenthesesExpression) {
        return this.visit(ctx.parenthesesExpression);
      } else if (ctx.caseExpression) {
        return this.visit(ctx.caseExpression);
      } else if (ctx.castExpression) {
        return this.visit(ctx.castExpression);
      } else if (ctx.functionExpression) {
        return this.visit(ctx.functionExpression);
      } else if (ctx.prefixExpression) {
        return this.visit(ctx.prefixExpression);
      } else if (ctx.columnExpression) {
        return this.visit(ctx.columnExpression);
      }

      return {
        type: "ConstantExpression",
        value: ctx.Constant[0].image,
        start: ctx.Constant[0].startOffset,
        end: ctx.Constant[0].endOffset
      };
    }
  }, {
    key: "parenthesesExpression",
    value: function parenthesesExpression(ctx) {
      return {
        type: "ParenthesesExpression",
        expression: this.visit(ctx.expression),
        start: ctx.OpenParenthesis[0].startOffset,
        end: ctx.CloseParenthesis[0].endOffset
      };
    }
  }, {
    key: "caseExpression",
    value: function caseExpression(ctx) {
      var _this9 = this;

      return {
        type: "CaseExpression",
        expression: ctx.expression && this.visit(ctx.expression) || null,
        branches: ctx.condition.map(function (condition, idx) {
          return {
            condition: _this9.visit(condition),
            result: _this9.visit(ctx.result[idx])
          };
        }),
        else: ctx.else && this.visit(ctx.else) || null,
        start: ctx.Case[0].startOffset,
        end: ctx.End[0].endOffset
      };
    }
  }, {
    key: "castExpression",
    value: function castExpression(ctx) {
      return {
        type: "CastExpression",
        expression: this.visit(ctx.expression),
        castTo: ctx.castTo[0].image,
        start: ctx.Cast[0].startOffset,
        end: ctx.CloseParenthesis[0].endOffset
      };
    }
  }, {
    key: "orderByExpression",
    value: function orderByExpression(ctx) {
      var expression = this.visit(ctx.expression[0]);

      // eslint-disable-next-line no-nested-ternary
      var end = ctx.asc ? ctx.asc[0].endOffset : ctx.desc ? ctx.desc[0].endOffset : expression.end;

      return {
        type: "OrderByExpression",
        expression: expression,
        desc: Boolean(ctx.desc),
        start: expression.start,
        end: end
      };
    }
  }, {
    key: "orderBy",
    value: function orderBy(ctx) {
      var _this10 = this;

      var expressions = ctx.orderByExpression.map(function (e) {
        return _this10.visit(e);
      });
      return {
        type: "OrderBy",
        expressions: expressions,
        start: ctx.OrderBy[0].startOffset,
        end: expressions[expressions.length - 1].end
      };
    }
  }, {
    key: "functionExpression",
    value: function functionExpression(ctx) {
      var _this11 = this;

      var result = {
        type: "FunctionExpression",
        function: ctx.function[0].image,
        start: ctx.function[0].startOffset,
        end: ctx.CloseParenthesis[0].endOffset
      };

      if (ctx.AllColumns) {
        result.star = true;
      } else {
        if (ctx.All) {
          result.all = true;
        } else if (ctx.Distinct) {
          result.distinct = true;
        }
        result.params = ctx.expression.map(function (e) {
          return _this11.visit(e);
        });
        if (ctx.orderBy) {
          result.orderBy = this.visit(ctx.orderBy);
        }
      }

      return result;
    }
  }, {
    key: "prefixExpression",
    value: function prefixExpression(ctx) {
      var expression = this.visit(ctx.expression);
      return {
        type: "PrefixExpression",
        operator: ctx.operator[0].image,
        expression: expression,
        start: ctx.operator[0].startOffset,
        end: expression.end
      };
    }
  }, {
    key: "columnExpression",
    value: function columnExpression(ctx) {
      return {
        type: "ColumnExpression",
        table: ctx.table && ctx.table[0].image || null,
        column: ctx.column[0].image,
        start: ctx.table ? ctx.table[0].startOffset : ctx.column[0].startOffset,
        end: ctx.column[0].endOffset
      };
    }
  }]);

  return SQLVisitor;
}(sqlParser.getBaseCstVisitorConstructor());

var sqlVisitor = new SQLVisitor();

// Run the parser to build an AST
function buildAst(sql) {
  var lexResult = sqlLexer.tokenize(sql);
  sqlParser.input = lexResult.tokens;

  var cst = sqlParser.expression();
  if (sqlParser.errors.length === 0) {
    return sqlVisitor.visit(cst);
  }
  return null;
}

var SAFE = "safe";
var UNSAFE = "unsafe";
var NEUTRAL = "neutral";

// "Paint" nodes of the AST as being safe to move into the fact query, or
// unsafe. To be safe, the node and all children must be safe (ie, have no
// references to other tables).
// eslint-disable-next-line complexity
function paintAst(factTable, node) {
  var paint = NEUTRAL;
  switch (node.type) {
    case "BinaryExpression":
      var lhsPaint = paintAst(factTable, node.lhs);
      var rhsPaint = paintAst(factTable, node.rhs);
      if (lhsPaint === UNSAFE || rhsPaint === UNSAFE) {
        paint = UNSAFE;
      } else if (lhsPaint === SAFE || rhsPaint === SAFE) {
        paint = SAFE;
      }
      break;

    case "ColumnExpression":
      paint = node.table === null || node.table.toLowerCase() === factTable.toLowerCase() || node.table.toLowerCase() === "\"" + factTable.toLowerCase() + "\"" ? SAFE : UNSAFE;
      break;

    case "OrderBy":
      paint = node.expressions.reduce(function (acc, expression) {
        var childPaint = paintAst(factTable, expression);
        if (childPaint === UNSAFE) {
          return UNSAFE;
        } else if (childPaint === SAFE && acc === NEUTRAL) {
          return SAFE;
        }
        return acc;
      }, NEUTRAL);
      break;

    case "FunctionExpression":
      paint = node.params.reduce(function (acc, expression) {
        var childPaint = paintAst(factTable, expression);
        if (childPaint === UNSAFE) {
          return UNSAFE;
        } else if (childPaint === SAFE && acc === NEUTRAL) {
          return SAFE;
        }
        return acc;
      }, NEUTRAL);
      break;

    case "CaseExpression":
      var expressionPaint = node.expression ? paintAst(factTable, node.expression) : NEUTRAL;
      var branchesPaint = node.branches.reduce(function (acc, _ref) {
        var condition = _ref.condition,
            result = _ref.result;

        var conditionPaint = paintAst(factTable, condition);
        var resultPaint = paintAst(factTable, result);
        if (conditionPaint === UNSAFE || resultPaint === UNSAFE) {
          return UNSAFE;
        } else if (acc === NEUTRAL && (conditionPaint === SAFE || resultPaint === SAFE)) {
          return SAFE;
        }
        return acc;
      }, NEUTRAL);
      var elsePaint = node.else ? paintAst(factTable, node.else) : NEUTRAL;
      if (expressionPaint === UNSAFE || branchesPaint === UNSAFE || elsePaint === UNSAFE) {
        paint = UNSAFE;
      } else if (expressionPaint === SAFE || branchesPaint === SAFE || elsePaint === SAFE) {
        paint = SAFE;
      }
      break;

    case "BetweenExpression":
      var lhs = paintAst(factTable, node.lhs);
      var lowerBound = paintAst(factTable, node.lowerBound);
      var upperBound = paintAst(factTable, node.upperBound);
      if (lhs === UNSAFE || lowerBound === UNSAFE || upperBound === UNSAFE) {
        paint = UNSAFE;
      } else if (lhs === SAFE || lowerBound === SAFE || upperBound === SAFE) {
        paint = SAFE;
      }
      break;

    case "InExpression":
      paint = node.in.reduce(function (acc, expression) {
        var childPaint = paintAst(factTable, expression);
        if (childPaint === UNSAFE) {
          return UNSAFE;
        } else if (childPaint === SAFE && acc === NEUTRAL) {
          return SAFE;
        }
        return acc;
      }, paintAst(factTable, node.expression));
      break;

    case "IsExpression":
    case "CastExpression":
    case "OrderByExpression":
    case "PrefixExpression":
    case "ParenthesesExpression":
      // these nodes have an "expression" child
      paint = paintAst(factTable, node.expression);
      break;

    default:
  }

  node.paint = paint;
  return paint;
}

// Any nodes painted "SAFE" are extracted from the original SQL to be used in
// the fact query. The "extraction" works by copying the substring from the
// original SQL into a projection and giving it an alias. This function also
// adds details about the replacement in the "replacements" variable which can
// be used to strip it out of the originl sql and replace it with a reference
// to the fact table projection.
function extractFacts(node, projections, aliases, replacements, sql) {
  if (node.paint === SAFE) {
    // end + 1 because "end" is an inclusive offset,
    // but substring excludes the end index
    var alias = "color" + projections.length;
    var start = node.start;
    var end = node.end + 1;
    projections.push(sql.substring(start, end));
    aliases.push(alias);
    replacements.push({
      alias: alias,
      start: start,
      end: end
    });
    return;
  }

  switch (node.type) {
    case "BinaryExpression":
      extractFacts(node.lhs, projections, aliases, replacements, sql);
      extractFacts(node.rhs, projections, aliases, replacements, sql);
      break;

    case "OrderBy":
      node.expressions.forEach(function (expression) {
        return extractFacts(expression, projections, aliases, replacements, sql);
      });
      break;

    case "FunctionExpression":
      node.params.forEach(function (expression) {
        return extractFacts(expression, projections, aliases, replacements, sql);
      });
      break;

    case "CaseExpression":
      if (node.expression) {
        extractFacts(node.expression, projections, aliases, replacements, sql);
      }
      node.branches.forEach(function (_ref2) {
        var condition = _ref2.condition,
            result = _ref2.result;

        extractFacts(condition, projections, aliases, replacements, sql);
        extractFacts(result, projections, aliases, replacements, sql);
      });
      if (node.else) {
        extractFacts(node.else, projections, aliases, replacements, sql);
      }
      break;

    case "BetweenExpression":
      extractFacts(node.lhs, projections, aliases, replacements, sql);
      extractFacts(node.lowerBound, projections, aliases, replacements, sql);
      extractFacts(node.upperBound, projections, aliases, replacements, sql);
      break;

    case "InExpression":
      extractFacts(node.expression, projections, aliases, replacements, sql);
      node.in.forEach(function (expression) {
        return extractFacts(expression, projections, aliases, replacements, sql);
      });
      break;

    case "IsExpression":
    case "CastExpression":
    case "OrderByExpression":
    case "PrefixExpression":
    case "ParenthesesExpression":
      extractFacts(node.expression, projections, aliases, replacements, sql);
      break;

    default:
  }
}

// Applies the replacements from extractFacts to the original SQL
function applyReplacements(sql, withAlias, replacements) {
  // apply replacements starting at the end of the string so the indexes will
  // line up correctly.
  replacements.sort(function (a, b) {
    return b.start - a.start;
  }).forEach(function (replacement) {
    sql = "" + sql.substring(0, replacement.start) + withAlias + "." + replacement.alias + sql.substring(replacement.end);
  });
  return sql;
}

function parseFactsFromCustomSQL(factTable, withAlias, sql) {
  var factProjections = [];
  var factAliases = [];
  var expression = sql;

  var ast = buildAst(sql);
  if (ast) {
    paintAst(factTable, ast);

    var replacements = [];
    extractFacts(ast, factProjections, factAliases, replacements, sql);
    expression = applyReplacements(sql, withAlias, replacements);
  }

  return {
    factProjections: factProjections,
    factAliases: factAliases,
    expression: expression
  };
}

/***/ }),
/* 213 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["clearCache"] = clearCache;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__version__ = __webpack_require__(214);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return __WEBPACK_IMPORTED_MODULE_0__version__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse_parser_parser__ = __webpack_require__(9);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Parser", function() { return __WEBPACK_IMPORTED_MODULE_1__parse_parser_parser__["g"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "CstParser", function() { return __WEBPACK_IMPORTED_MODULE_1__parse_parser_parser__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "EmbeddedActionsParser", function() { return __WEBPACK_IMPORTED_MODULE_1__parse_parser_parser__["f"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ParserDefinitionErrorType", function() { return __WEBPACK_IMPORTED_MODULE_1__parse_parser_parser__["h"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "EMPTY_ALT", function() { return __WEBPACK_IMPORTED_MODULE_1__parse_parser_parser__["d"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__scan_lexer_public__ = __webpack_require__(31);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Lexer", function() { return __WEBPACK_IMPORTED_MODULE_2__scan_lexer_public__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "LexerDefinitionErrorType", function() { return __WEBPACK_IMPORTED_MODULE_2__scan_lexer_public__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__scan_tokens_public__ = __webpack_require__(17);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "createToken", function() { return __WEBPACK_IMPORTED_MODULE_3__scan_tokens_public__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "createTokenInstance", function() { return __WEBPACK_IMPORTED_MODULE_3__scan_tokens_public__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "EOF", function() { return __WEBPACK_IMPORTED_MODULE_3__scan_tokens_public__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "tokenLabel", function() { return __WEBPACK_IMPORTED_MODULE_3__scan_tokens_public__["e"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "tokenMatcher", function() { return __WEBPACK_IMPORTED_MODULE_3__scan_tokens_public__["f"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "tokenName", function() { return __WEBPACK_IMPORTED_MODULE_3__scan_tokens_public__["g"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__parse_errors_public__ = __webpack_require__(32);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "defaultGrammarResolverErrorProvider", function() { return __WEBPACK_IMPORTED_MODULE_4__parse_errors_public__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "defaultGrammarValidatorErrorProvider", function() { return __WEBPACK_IMPORTED_MODULE_4__parse_errors_public__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "defaultParserErrorProvider", function() { return __WEBPACK_IMPORTED_MODULE_4__parse_errors_public__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__parse_exceptions_public__ = __webpack_require__(28);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "EarlyExitException", function() { return __WEBPACK_IMPORTED_MODULE_5__parse_exceptions_public__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "isRecognitionException", function() { return __WEBPACK_IMPORTED_MODULE_5__parse_exceptions_public__["e"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MismatchedTokenException", function() { return __WEBPACK_IMPORTED_MODULE_5__parse_exceptions_public__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "NotAllInputParsedException", function() { return __WEBPACK_IMPORTED_MODULE_5__parse_exceptions_public__["d"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "NoViableAltException", function() { return __WEBPACK_IMPORTED_MODULE_5__parse_exceptions_public__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__scan_lexer_errors_public__ = __webpack_require__(216);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "defaultLexerErrorProvider", function() { return __WEBPACK_IMPORTED_MODULE_6__scan_lexer_errors_public__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__parse_grammar_gast_gast_public__ = __webpack_require__(6);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Alternation", function() { return __WEBPACK_IMPORTED_MODULE_7__parse_grammar_gast_gast_public__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Flat", function() { return __WEBPACK_IMPORTED_MODULE_7__parse_grammar_gast_gast_public__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "NonTerminal", function() { return __WEBPACK_IMPORTED_MODULE_7__parse_grammar_gast_gast_public__["d"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Option", function() { return __WEBPACK_IMPORTED_MODULE_7__parse_grammar_gast_gast_public__["e"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Repetition", function() { return __WEBPACK_IMPORTED_MODULE_7__parse_grammar_gast_gast_public__["f"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "RepetitionMandatory", function() { return __WEBPACK_IMPORTED_MODULE_7__parse_grammar_gast_gast_public__["g"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "RepetitionMandatoryWithSeparator", function() { return __WEBPACK_IMPORTED_MODULE_7__parse_grammar_gast_gast_public__["h"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "RepetitionWithSeparator", function() { return __WEBPACK_IMPORTED_MODULE_7__parse_grammar_gast_gast_public__["i"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Rule", function() { return __WEBPACK_IMPORTED_MODULE_7__parse_grammar_gast_gast_public__["j"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Terminal", function() { return __WEBPACK_IMPORTED_MODULE_7__parse_grammar_gast_gast_public__["k"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "serializeGrammar", function() { return __WEBPACK_IMPORTED_MODULE_7__parse_grammar_gast_gast_public__["l"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "serializeProduction", function() { return __WEBPACK_IMPORTED_MODULE_7__parse_grammar_gast_gast_public__["m"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__parse_grammar_gast_gast_visitor_public__ = __webpack_require__(20);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "GAstVisitor", function() { return __WEBPACK_IMPORTED_MODULE_8__parse_grammar_gast_gast_visitor_public__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__parse_grammar_gast_gast_resolver_public__ = __webpack_require__(219);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "assignOccurrenceIndices", function() { return __WEBPACK_IMPORTED_MODULE_9__parse_grammar_gast_gast_resolver_public__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "resolveGrammar", function() { return __WEBPACK_IMPORTED_MODULE_9__parse_grammar_gast_gast_resolver_public__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "validateGrammar", function() { return __WEBPACK_IMPORTED_MODULE_9__parse_grammar_gast_gast_resolver_public__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__diagrams_render_public__ = __webpack_require__(338);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "createSyntaxDiagramsCode", function() { return __WEBPACK_IMPORTED_MODULE_10__diagrams_render_public__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__generate_generate_public__ = __webpack_require__(339);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "generateParserFactory", function() { return __WEBPACK_IMPORTED_MODULE_11__generate_generate_public__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "generateParserModule", function() { return __WEBPACK_IMPORTED_MODULE_11__generate_generate_public__["b"]; });
// semantic version



// Tokens utilities

// Other Utilities



// grammar reflection API

// GAST Utilities



/* istanbul ignore next */
function clearCache() {
    console.warn("The clearCache function was 'soft' removed from the Chevrotain API." +
        "\n\t It performs no action other than printing this message." +
        "\n\t Please avoid using it as it will be completely removed in the future");
}


//# sourceMappingURL=api.js.map

/***/ }),
/* 214 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return VERSION; });
// needs a separate module as this is required inside chevrotain productive code
// and also in the entry point for webpack(api.ts).
// A separate file avoids cyclic dependencies and webpack errors.
var VERSION = "6.5.0";
//# sourceMappingURL=version.js.map

/***/ }),
/* 215 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DEFAULT_MODE; });
/* unused harmony export MODES */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return SUPPORT_STICKY; });
/* unused harmony export disableSticky */
/* unused harmony export enableSticky */
/* harmony export (immutable) */ __webpack_exports__["d"] = analyzeTokenTypes;
/* harmony export (immutable) */ __webpack_exports__["j"] = validatePatterns;
/* unused harmony export findMissingPatterns */
/* unused harmony export findInvalidPatterns */
/* unused harmony export findEndOfInputAnchor */
/* unused harmony export findEmptyMatchRegExps */
/* unused harmony export findStartOfInputAnchor */
/* unused harmony export findUnsupportedFlags */
/* unused harmony export findDuplicatePatterns */
/* unused harmony export findInvalidGroupType */
/* unused harmony export findModesThatDoNotExist */
/* unused harmony export findUnreachablePatterns */
/* unused harmony export addStartOfInput */
/* unused harmony export addStickyFlag */
/* harmony export (immutable) */ __webpack_exports__["h"] = performRuntimeChecks;
/* harmony export (immutable) */ __webpack_exports__["i"] = performWarningRuntimeChecks;
/* harmony export (immutable) */ __webpack_exports__["f"] = cloneEmptyGroups;
/* unused harmony export isCustomPattern */
/* unused harmony export isShortPattern */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return LineTerminatorOptimizedTester; });
/* unused harmony export buildLineBreakIssueMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return minOptimizationVal; });
/* harmony export (immutable) */ __webpack_exports__["e"] = charCodeToOptimizedIndex;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_regexp_to_ast__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_regexp_to_ast___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_regexp_to_ast__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lexer_public__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__reg_exp__ = __webpack_require__(326);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__reg_exp_parser__ = __webpack_require__(46);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();





var PATTERN = "PATTERN";
var DEFAULT_MODE = "defaultMode";
var MODES = "modes";
var SUPPORT_STICKY = typeof new RegExp("(?:)").sticky === "boolean";
function disableSticky() {
    SUPPORT_STICKY = false;
}
function enableSticky() {
    SUPPORT_STICKY = true;
}
function analyzeTokenTypes(tokenTypes, options) {
    options = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["k" /* defaults */])(options, {
        useSticky: SUPPORT_STICKY,
        debug: false,
        safeMode: false,
        positionTracking: "full",
        lineTerminatorCharacters: ["\r", "\n"],
        tracer: function (msg, action) { return action(); }
    });
    var tracer = options.tracer;
    tracer("initCharCodeToOptimizedIndexMap", function () {
        initCharCodeToOptimizedIndexMap();
    });
    var onlyRelevantTypes;
    tracer("Reject Lexer.NA", function () {
        onlyRelevantTypes = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["P" /* reject */])(tokenTypes, function (currType) {
            return currType[PATTERN] === __WEBPACK_IMPORTED_MODULE_1__lexer_public__["a" /* Lexer */].NA;
        });
    });
    var hasCustom = false;
    var allTransformedPatterns;
    tracer("Transform Patterns", function () {
        hasCustom = false;
        allTransformedPatterns = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["I" /* map */])(onlyRelevantTypes, function (currType) {
            var currPattern = currType[PATTERN];
            /* istanbul ignore else */
            if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["D" /* isRegExp */])(currPattern)) {
                var regExpSource = currPattern.source;
                if (regExpSource.length === 1 &&
                    // only these regExp meta characters which can appear in a length one regExp
                    regExpSource !== "^" &&
                    regExpSource !== "$" &&
                    regExpSource !== ".") {
                    return regExpSource;
                }
                else if (regExpSource.length === 2 &&
                    regExpSource[0] === "\\" &&
                    // not a meta character
                    !Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["j" /* contains */])([
                        "d",
                        "D",
                        "s",
                        "S",
                        "t",
                        "r",
                        "n",
                        "t",
                        "0",
                        "c",
                        "b",
                        "B",
                        "f",
                        "v",
                        "w",
                        "W"
                    ], regExpSource[1])) {
                    // escaped meta Characters: /\+/ /\[/
                    // or redundant escaping: /\a/
                    // without the escaping "\"
                    return regExpSource[1];
                }
                else {
                    return options.useSticky
                        ? addStickyFlag(currPattern)
                        : addStartOfInput(currPattern);
                }
            }
            else if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["B" /* isFunction */])(currPattern)) {
                hasCustom = true;
                // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object
                return { exec: currPattern };
            }
            else if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["w" /* has */])(currPattern, "exec")) {
                hasCustom = true;
                // ICustomPattern
                return currPattern;
            }
            else if (typeof currPattern === "string") {
                if (currPattern.length === 1) {
                    return currPattern;
                }
                else {
                    var escapedRegExpString = currPattern.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
                    var wrappedRegExp = new RegExp(escapedRegExpString);
                    return options.useSticky
                        ? addStickyFlag(wrappedRegExp)
                        : addStartOfInput(wrappedRegExp);
                }
            }
            else {
                throw Error("non exhaustive match");
            }
        });
    });
    var patternIdxToType;
    var patternIdxToGroup;
    var patternIdxToLongerAltIdx;
    var patternIdxToPushMode;
    var patternIdxToPopMode;
    tracer("misc mapping", function () {
        patternIdxToType = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["I" /* map */])(onlyRelevantTypes, function (currType) { return currType.tokenTypeIdx; });
        patternIdxToGroup = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["I" /* map */])(onlyRelevantTypes, function (clazz) {
            var groupName = clazz.GROUP;
            /* istanbul ignore next */
            if (groupName === __WEBPACK_IMPORTED_MODULE_1__lexer_public__["a" /* Lexer */].SKIPPED) {
                return undefined;
            }
            else if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["E" /* isString */])(groupName)) {
                return groupName;
            }
            else if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["F" /* isUndefined */])(groupName)) {
                return false;
            }
            else {
                throw Error("non exhaustive match");
            }
        });
        patternIdxToLongerAltIdx = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["I" /* map */])(onlyRelevantTypes, function (clazz) {
            var longerAltType = clazz.LONGER_ALT;
            if (longerAltType) {
                var longerAltIdx = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["x" /* indexOf */])(onlyRelevantTypes, longerAltType);
                return longerAltIdx;
            }
        });
        patternIdxToPushMode = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["I" /* map */])(onlyRelevantTypes, function (clazz) { return clazz.PUSH_MODE; });
        patternIdxToPopMode = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["I" /* map */])(onlyRelevantTypes, function (clazz) {
            return Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["w" /* has */])(clazz, "POP_MODE");
        });
    });
    var patternIdxToCanLineTerminator;
    tracer("Line Terminator Handling", function () {
        var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);
        patternIdxToCanLineTerminator = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["I" /* map */])(onlyRelevantTypes, function (tokType) { return false; });
        if (options.positionTracking !== "onlyOffset") {
            patternIdxToCanLineTerminator = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["I" /* map */])(onlyRelevantTypes, function (tokType) {
                if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["w" /* has */])(tokType, "LINE_BREAKS")) {
                    return tokType.LINE_BREAKS;
                }
                else {
                    if (checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false) {
                        return Object(__WEBPACK_IMPORTED_MODULE_3__reg_exp__["a" /* canMatchCharCode */])(lineTerminatorCharCodes, tokType.PATTERN);
                    }
                }
            });
        }
    });
    var patternIdxToIsCustom;
    var patternIdxToShort;
    var emptyGroups;
    var patternIdxToConfig;
    tracer("Misc Mapping #2", function () {
        patternIdxToIsCustom = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["I" /* map */])(onlyRelevantTypes, isCustomPattern);
        patternIdxToShort = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["I" /* map */])(allTransformedPatterns, isShortPattern);
        emptyGroups = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["O" /* reduce */])(onlyRelevantTypes, function (acc, clazz) {
            var groupName = clazz.GROUP;
            if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["E" /* isString */])(groupName) && !(groupName === __WEBPACK_IMPORTED_MODULE_1__lexer_public__["a" /* Lexer */].SKIPPED)) {
                acc[groupName] = [];
            }
            return acc;
        }, {});
        patternIdxToConfig = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["I" /* map */])(allTransformedPatterns, function (x, idx) {
            return {
                pattern: allTransformedPatterns[idx],
                longerAlt: patternIdxToLongerAltIdx[idx],
                canLineTerminator: patternIdxToCanLineTerminator[idx],
                isCustom: patternIdxToIsCustom[idx],
                short: patternIdxToShort[idx],
                group: patternIdxToGroup[idx],
                push: patternIdxToPushMode[idx],
                pop: patternIdxToPopMode[idx],
                tokenTypeIdx: patternIdxToType[idx],
                tokenType: onlyRelevantTypes[idx]
            };
        });
    });
    var canBeOptimized = true;
    var charCodeToPatternIdxToConfig = [];
    if (!options.safeMode) {
        tracer("First Char Optimization", function () {
            charCodeToPatternIdxToConfig = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["O" /* reduce */])(onlyRelevantTypes, function (result, currTokType, idx) {
                if (typeof currTokType.PATTERN === "string") {
                    var charCode = currTokType.PATTERN.charCodeAt(0);
                    var optimizedIdx = charCodeToOptimizedIndex(charCode);
                    addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);
                }
                else if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["y" /* isArray */])(currTokType.START_CHARS_HINT)) {
                    var lastOptimizedIdx_1;
                    Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["u" /* forEach */])(currTokType.START_CHARS_HINT, function (charOrInt) {
                        var charCode = typeof charOrInt === "string"
                            ? charOrInt.charCodeAt(0)
                            : charOrInt;
                        var currOptimizedIdx = charCodeToOptimizedIndex(charCode);
                        // Avoid adding the config multiple times
                        if (lastOptimizedIdx_1 !== currOptimizedIdx) {
                            lastOptimizedIdx_1 = currOptimizedIdx;
                            addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);
                        }
                    });
                }
                else if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["D" /* isRegExp */])(currTokType.PATTERN)) {
                    if (currTokType.PATTERN.unicode) {
                        canBeOptimized = false;
                        if (options.ensureOptimizations) {
                            Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["c" /* PRINT_ERROR */])("" + __WEBPACK_IMPORTED_MODULE_3__reg_exp__["b" /* failedOptimizationPrefixMsg */] +
                                ("\tUnable to analyze < " + currTokType.PATTERN.toString() + " > pattern.\n") +
                                "\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\n" +
                                "\tThis will disable the lexer's first char optimizations.\n" +
                                "\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE");
                        }
                    }
                    else {
                        var optimizedCodes = Object(__WEBPACK_IMPORTED_MODULE_3__reg_exp__["c" /* getOptimizedStartCodesIndices */])(currTokType.PATTERN, options.ensureOptimizations);
                        /* istanbul ignore if */
                        // start code will only be empty given an empty regExp or failure of regexp-to-ast library
                        // the first should be a different validation and the second cannot be tested.
                        if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["A" /* isEmpty */])(optimizedCodes)) {
                            // we cannot understand what codes may start possible matches
                            // The optimization correctness requires knowing start codes for ALL patterns.
                            // Not actually sure this is an error, no debug message
                            canBeOptimized = false;
                        }
                        Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["u" /* forEach */])(optimizedCodes, function (code) {
                            addToMapOfArrays(result, code, patternIdxToConfig[idx]);
                        });
                    }
                }
                else {
                    if (options.ensureOptimizations) {
                        Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["c" /* PRINT_ERROR */])("" + __WEBPACK_IMPORTED_MODULE_3__reg_exp__["b" /* failedOptimizationPrefixMsg */] +
                            ("\tTokenType: <" + currTokType.name + "> is using a custom token pattern without providing <start_chars_hint> parameter.\n") +
                            "\tThis will disable the lexer's first char optimizations.\n" +
                            "\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE");
                    }
                    canBeOptimized = false;
                }
                return result;
            }, []);
        });
    }
    tracer("ArrayPacking", function () {
        charCodeToPatternIdxToConfig = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["L" /* packArray */])(charCodeToPatternIdxToConfig);
    });
    return {
        emptyGroups: emptyGroups,
        patternIdxToConfig: patternIdxToConfig,
        charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,
        hasCustom: hasCustom,
        canBeOptimized: canBeOptimized
    };
}
function validatePatterns(tokenTypes, validModesNames) {
    var errors = [];
    var missingResult = findMissingPatterns(tokenTypes);
    errors = errors.concat(missingResult.errors);
    var invalidResult = findInvalidPatterns(missingResult.valid);
    var validTokenTypes = invalidResult.valid;
    errors = errors.concat(invalidResult.errors);
    errors = errors.concat(validateRegExpPattern(validTokenTypes));
    errors = errors.concat(findInvalidGroupType(validTokenTypes));
    errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));
    errors = errors.concat(findUnreachablePatterns(validTokenTypes));
    return errors;
}
function validateRegExpPattern(tokenTypes) {
    var errors = [];
    var withRegExpPatterns = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["p" /* filter */])(tokenTypes, function (currTokType) {
        return Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["D" /* isRegExp */])(currTokType[PATTERN]);
    });
    errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));
    errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));
    errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));
    errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));
    errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));
    return errors;
}
function findMissingPatterns(tokenTypes) {
    var tokenTypesWithMissingPattern = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["p" /* filter */])(tokenTypes, function (currType) {
        return !Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["w" /* has */])(currType, PATTERN);
    });
    var errors = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["I" /* map */])(tokenTypesWithMissingPattern, function (currType) {
        return {
            message: "Token Type: ->" +
                currType.name +
                "<- missing static 'PATTERN' property",
            type: __WEBPACK_IMPORTED_MODULE_1__lexer_public__["b" /* LexerDefinitionErrorType */].MISSING_PATTERN,
            tokenTypes: [currType]
        };
    });
    var valid = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["l" /* difference */])(tokenTypes, tokenTypesWithMissingPattern);
    return { errors: errors, valid: valid };
}
function findInvalidPatterns(tokenTypes) {
    var tokenTypesWithInvalidPattern = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["p" /* filter */])(tokenTypes, function (currType) {
        var pattern = currType[PATTERN];
        return (!Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["D" /* isRegExp */])(pattern) &&
            !Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["B" /* isFunction */])(pattern) &&
            !Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["w" /* has */])(pattern, "exec") &&
            !Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["E" /* isString */])(pattern));
    });
    var errors = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["I" /* map */])(tokenTypesWithInvalidPattern, function (currType) {
        return {
            message: "Token Type: ->" +
                currType.name +
                "<- static 'PATTERN' can only be a RegExp, a" +
                " Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
            type: __WEBPACK_IMPORTED_MODULE_1__lexer_public__["b" /* LexerDefinitionErrorType */].INVALID_PATTERN,
            tokenTypes: [currType]
        };
    });
    var valid = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["l" /* difference */])(tokenTypes, tokenTypesWithInvalidPattern);
    return { errors: errors, valid: valid };
}
var end_of_input = /[^\\][\$]/;
function findEndOfInputAnchor(tokenTypes) {
    var EndAnchorFinder = /** @class */ (function (_super) {
        __extends(EndAnchorFinder, _super);
        function EndAnchorFinder() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.found = false;
            return _this;
        }
        EndAnchorFinder.prototype.visitEndAnchor = function (node) {
            this.found = true;
        };
        return EndAnchorFinder;
    }(__WEBPACK_IMPORTED_MODULE_0_regexp_to_ast__["BaseRegExpVisitor"]));
    var invalidRegex = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["p" /* filter */])(tokenTypes, function (currType) {
        var pattern = currType[PATTERN];
        try {
            var regexpAst = Object(__WEBPACK_IMPORTED_MODULE_4__reg_exp_parser__["b" /* getRegExpAst */])(pattern);
            var endAnchorVisitor = new EndAnchorFinder();
            endAnchorVisitor.visit(regexpAst);
            return endAnchorVisitor.found;
        }
        catch (e) {
            // old behavior in case of runtime exceptions with regexp-to-ast.
            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/
            return end_of_input.test(pattern.source);
        }
    });
    var errors = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["I" /* map */])(invalidRegex, function (currType) {
        return {
            message: "Unexpected RegExp Anchor Error:\n" +
                "\tToken Type: ->" +
                currType.name +
                "<- static 'PATTERN' cannot contain end of input anchor '$'\n" +
                "\tSee sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS" +
                "\tfor details.",
            type: __WEBPACK_IMPORTED_MODULE_1__lexer_public__["b" /* LexerDefinitionErrorType */].EOI_ANCHOR_FOUND,
            tokenTypes: [currType]
        };
    });
    return errors;
}
function findEmptyMatchRegExps(tokenTypes) {
    var matchesEmptyString = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["p" /* filter */])(tokenTypes, function (currType) {
        var pattern = currType[PATTERN];
        return pattern.test("");
    });
    var errors = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["I" /* map */])(matchesEmptyString, function (currType) {
        return {
            message: "Token Type: ->" +
                currType.name +
                "<- static 'PATTERN' must not match an empty string",
            type: __WEBPACK_IMPORTED_MODULE_1__lexer_public__["b" /* LexerDefinitionErrorType */].EMPTY_MATCH_PATTERN,
            tokenTypes: [currType]
        };
    });
    return errors;
}
var start_of_input = /[^\\[][\^]|^\^/;
function findStartOfInputAnchor(tokenTypes) {
    var StartAnchorFinder = /** @class */ (function (_super) {
        __extends(StartAnchorFinder, _super);
        function StartAnchorFinder() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.found = false;
            return _this;
        }
        StartAnchorFinder.prototype.visitStartAnchor = function (node) {
            this.found = true;
        };
        return StartAnchorFinder;
    }(__WEBPACK_IMPORTED_MODULE_0_regexp_to_ast__["BaseRegExpVisitor"]));
    var invalidRegex = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["p" /* filter */])(tokenTypes, function (currType) {
        var pattern = currType[PATTERN];
        try {
            var regexpAst = Object(__WEBPACK_IMPORTED_MODULE_4__reg_exp_parser__["b" /* getRegExpAst */])(pattern);
            var startAnchorVisitor = new StartAnchorFinder();
            startAnchorVisitor.visit(regexpAst);
            return startAnchorVisitor.found;
        }
        catch (e) {
            // old behavior in case of runtime exceptions with regexp-to-ast.
            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/
            return start_of_input.test(pattern.source);
        }
    });
    var errors = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["I" /* map */])(invalidRegex, function (currType) {
        return {
            message: "Unexpected RegExp Anchor Error:\n" +
                "\tToken Type: ->" +
                currType.name +
                "<- static 'PATTERN' cannot contain start of input anchor '^'\n" +
                "\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS" +
                "\tfor details.",
            type: __WEBPACK_IMPORTED_MODULE_1__lexer_public__["b" /* LexerDefinitionErrorType */].SOI_ANCHOR_FOUND,
            tokenTypes: [currType]
        };
    });
    return errors;
}
function findUnsupportedFlags(tokenTypes) {
    var invalidFlags = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["p" /* filter */])(tokenTypes, function (currType) {
        var pattern = currType[PATTERN];
        return (pattern instanceof RegExp && (pattern.multiline || pattern.global));
    });
    var errors = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["I" /* map */])(invalidFlags, function (currType) {
        return {
            message: "Token Type: ->" +
                currType.name +
                "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
            type: __WEBPACK_IMPORTED_MODULE_1__lexer_public__["b" /* LexerDefinitionErrorType */].UNSUPPORTED_FLAGS_FOUND,
            tokenTypes: [currType]
        };
    });
    return errors;
}
// This can only test for identical duplicate RegExps, not semantically equivalent ones.
function findDuplicatePatterns(tokenTypes) {
    var found = [];
    var identicalPatterns = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["I" /* map */])(tokenTypes, function (outerType) {
        return Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["O" /* reduce */])(tokenTypes, function (result, innerType) {
            if (outerType.PATTERN.source === innerType.PATTERN.source &&
                !Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["j" /* contains */])(found, innerType) &&
                innerType.PATTERN !== __WEBPACK_IMPORTED_MODULE_1__lexer_public__["a" /* Lexer */].NA) {
                // this avoids duplicates in the result, each Token Type may only appear in one "set"
                // in essence we are creating Equivalence classes on equality relation.
                found.push(innerType);
                result.push(innerType);
                return result;
            }
            return result;
        }, []);
    });
    identicalPatterns = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["i" /* compact */])(identicalPatterns);
    var duplicatePatterns = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["p" /* filter */])(identicalPatterns, function (currIdenticalSet) {
        return currIdenticalSet.length > 1;
    });
    var errors = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["I" /* map */])(duplicatePatterns, function (setOfIdentical) {
        var tokenTypeNames = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["I" /* map */])(setOfIdentical, function (currType) {
            return currType.name;
        });
        var dupPatternSrc = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["s" /* first */])(setOfIdentical).PATTERN;
        return {
            message: "The same RegExp pattern ->" + dupPatternSrc + "<-" +
                ("has been used in all of the following Token Types: " + tokenTypeNames.join(", ") + " <-"),
            type: __WEBPACK_IMPORTED_MODULE_1__lexer_public__["b" /* LexerDefinitionErrorType */].DUPLICATE_PATTERNS_FOUND,
            tokenTypes: setOfIdentical
        };
    });
    return errors;
}
function findInvalidGroupType(tokenTypes) {
    var invalidTypes = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["p" /* filter */])(tokenTypes, function (clazz) {
        if (!Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["w" /* has */])(clazz, "GROUP")) {
            return false;
        }
        var group = clazz.GROUP;
        return group !== __WEBPACK_IMPORTED_MODULE_1__lexer_public__["a" /* Lexer */].SKIPPED && group !== __WEBPACK_IMPORTED_MODULE_1__lexer_public__["a" /* Lexer */].NA && !Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["E" /* isString */])(group);
    });
    var errors = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["I" /* map */])(invalidTypes, function (currType) {
        return {
            message: "Token Type: ->" +
                currType.name +
                "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
            type: __WEBPACK_IMPORTED_MODULE_1__lexer_public__["b" /* LexerDefinitionErrorType */].INVALID_GROUP_TYPE_FOUND,
            tokenTypes: [currType]
        };
    });
    return errors;
}
function findModesThatDoNotExist(tokenTypes, validModes) {
    var invalidModes = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["p" /* filter */])(tokenTypes, function (clazz) {
        return (clazz.PUSH_MODE !== undefined &&
            !Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["j" /* contains */])(validModes, clazz.PUSH_MODE));
    });
    var errors = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["I" /* map */])(invalidModes, function (tokType) {
        var msg = "Token Type: ->" + tokType.name + "<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->" + tokType.PUSH_MODE + "<-" +
            "which does not exist";
        return {
            message: msg,
            type: __WEBPACK_IMPORTED_MODULE_1__lexer_public__["b" /* LexerDefinitionErrorType */].PUSH_MODE_DOES_NOT_EXIST,
            tokenTypes: [tokType]
        };
    });
    return errors;
}
function findUnreachablePatterns(tokenTypes) {
    var errors = [];
    var canBeTested = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["O" /* reduce */])(tokenTypes, function (result, tokType, idx) {
        var pattern = tokType.PATTERN;
        if (pattern === __WEBPACK_IMPORTED_MODULE_1__lexer_public__["a" /* Lexer */].NA) {
            return result;
        }
        // a more comprehensive validation for all forms of regExps would require
        // deeper regExp analysis capabilities
        if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["E" /* isString */])(pattern)) {
            result.push({ str: pattern, idx: idx, tokenType: tokType });
        }
        else if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["D" /* isRegExp */])(pattern) && noMetaChar(pattern)) {
            result.push({ str: pattern.source, idx: idx, tokenType: tokType });
        }
        return result;
    }, []);
    Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["u" /* forEach */])(tokenTypes, function (tokType, testIdx) {
        Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["u" /* forEach */])(canBeTested, function (_a) {
            var str = _a.str, idx = _a.idx, tokenType = _a.tokenType;
            if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {
                var msg = "Token: ->" + tokenType.name + "<- can never be matched.\n" +
                    ("Because it appears AFTER the Token Type ->" + tokType.name + "<-") +
                    "in the lexer's definition.\n" +
                    "See https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNREACHABLE";
                errors.push({
                    message: msg,
                    type: __WEBPACK_IMPORTED_MODULE_1__lexer_public__["b" /* LexerDefinitionErrorType */].UNREACHABLE_PATTERN,
                    tokenTypes: [tokType, tokenType]
                });
            }
        });
    });
    return errors;
}
function testTokenType(str, pattern) {
    /* istanbul ignore else */
    if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["D" /* isRegExp */])(pattern)) {
        var regExpArray = pattern.exec(str);
        return regExpArray !== null && regExpArray.index === 0;
    }
    else if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["B" /* isFunction */])(pattern)) {
        // maintain the API of custom patterns
        return pattern(str, 0, [], {});
    }
    else if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["w" /* has */])(pattern, "exec")) {
        // maintain the API of custom patterns
        return pattern.exec(str, 0, [], {});
    }
    else if (typeof pattern === "string") {
        return pattern === str;
    }
    else {
        throw Error("non exhaustive match");
    }
}
function noMetaChar(regExp) {
    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp
    var metaChars = [
        ".",
        "\\",
        "[",
        "]",
        "|",
        "^",
        "$",
        "(",
        ")",
        "?",
        "*",
        "+",
        "{"
    ];
    return (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["q" /* find */])(metaChars, function (char) { return regExp.source.indexOf(char) !== -1; }) ===
        undefined);
}
function addStartOfInput(pattern) {
    var flags = pattern.ignoreCase ? "i" : "";
    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.
    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)
    return new RegExp("^(?:" + pattern.source + ")", flags);
}
function addStickyFlag(pattern) {
    var flags = pattern.ignoreCase ? "iy" : "y";
    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.
    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)
    return new RegExp("" + pattern.source, flags);
}
function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
    var errors = [];
    // some run time checks to help the end users.
    if (!Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["w" /* has */])(lexerDefinition, DEFAULT_MODE)) {
        errors.push({
            message: "A MultiMode Lexer cannot be initialized without a <" +
                DEFAULT_MODE +
                "> property in its definition\n",
            type: __WEBPACK_IMPORTED_MODULE_1__lexer_public__["b" /* LexerDefinitionErrorType */].MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE
        });
    }
    if (!Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["w" /* has */])(lexerDefinition, MODES)) {
        errors.push({
            message: "A MultiMode Lexer cannot be initialized without a <" +
                MODES +
                "> property in its definition\n",
            type: __WEBPACK_IMPORTED_MODULE_1__lexer_public__["b" /* LexerDefinitionErrorType */].MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY
        });
    }
    if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["w" /* has */])(lexerDefinition, MODES) &&
        Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["w" /* has */])(lexerDefinition, DEFAULT_MODE) &&
        !Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["w" /* has */])(lexerDefinition.modes, lexerDefinition.defaultMode)) {
        errors.push({
            message: "A MultiMode Lexer cannot be initialized with a " + DEFAULT_MODE + ": <" + lexerDefinition.defaultMode + ">" +
                "which does not exist\n",
            type: __WEBPACK_IMPORTED_MODULE_1__lexer_public__["b" /* LexerDefinitionErrorType */].MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST
        });
    }
    if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["w" /* has */])(lexerDefinition, MODES)) {
        Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["u" /* forEach */])(lexerDefinition.modes, function (currModeValue, currModeName) {
            Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["u" /* forEach */])(currModeValue, function (currTokType, currIdx) {
                if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["F" /* isUndefined */])(currTokType)) {
                    errors.push({
                        message: "A Lexer cannot be initialized using an undefined Token Type. Mode:" +
                            ("<" + currModeName + "> at index: <" + currIdx + ">\n"),
                        type: __WEBPACK_IMPORTED_MODULE_1__lexer_public__["b" /* LexerDefinitionErrorType */].LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED
                    });
                }
            });
        });
    }
    return errors;
}
function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
    var warnings = [];
    var hasAnyLineBreak = false;
    var allTokenTypes = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["i" /* compact */])(Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["t" /* flatten */])(Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["J" /* mapValues */])(lexerDefinition.modes, function (tokTypes) { return tokTypes; })));
    var concreteTokenTypes = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["P" /* reject */])(allTokenTypes, function (currType) { return currType[PATTERN] === __WEBPACK_IMPORTED_MODULE_1__lexer_public__["a" /* Lexer */].NA; });
    var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);
    if (trackLines) {
        Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["u" /* forEach */])(concreteTokenTypes, function (tokType) {
            var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);
            if (currIssue !== false) {
                var message = buildLineBreakIssueMessage(tokType, currIssue);
                var warningDescriptor = {
                    message: message,
                    type: currIssue.issue,
                    tokenType: tokType
                };
                warnings.push(warningDescriptor);
            }
            else {
                // we don't want to attempt to scan if the user explicitly specified the line_breaks option.
                if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["w" /* has */])(tokType, "LINE_BREAKS")) {
                    if (tokType.LINE_BREAKS === true) {
                        hasAnyLineBreak = true;
                    }
                }
                else {
                    if (Object(__WEBPACK_IMPORTED_MODULE_3__reg_exp__["a" /* canMatchCharCode */])(terminatorCharCodes, tokType.PATTERN)) {
                        hasAnyLineBreak = true;
                    }
                }
            }
        });
    }
    if (trackLines && !hasAnyLineBreak) {
        warnings.push({
            message: "Warning: No LINE_BREAKS Found.\n" +
                "\tThis Lexer has been defined to track line and column information,\n" +
                "\tBut none of the Token Types can be identified as matching a line terminator.\n" +
                "\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \n" +
                "\tfor details.",
            type: __WEBPACK_IMPORTED_MODULE_1__lexer_public__["b" /* LexerDefinitionErrorType */].NO_LINE_BREAKS_FLAGS
        });
    }
    return warnings;
}
function cloneEmptyGroups(emptyGroups) {
    var clonedResult = {};
    var groupKeys = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["G" /* keys */])(emptyGroups);
    Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["u" /* forEach */])(groupKeys, function (currKey) {
        var currGroupValue = emptyGroups[currKey];
        /* istanbul ignore else */
        if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["y" /* isArray */])(currGroupValue)) {
            clonedResult[currKey] = [];
        }
        else {
            throw Error("non exhaustive match");
        }
    });
    return clonedResult;
}
// TODO: refactor to avoid duplication
function isCustomPattern(tokenType) {
    var pattern = tokenType.PATTERN;
    /* istanbul ignore else */
    if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["D" /* isRegExp */])(pattern)) {
        return false;
    }
    else if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["B" /* isFunction */])(pattern)) {
        // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object
        return true;
    }
    else if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["w" /* has */])(pattern, "exec")) {
        // ICustomPattern
        return true;
    }
    else if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["E" /* isString */])(pattern)) {
        return false;
    }
    else {
        throw Error("non exhaustive match");
    }
}
function isShortPattern(pattern) {
    if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["E" /* isString */])(pattern) && pattern.length === 1) {
        return pattern.charCodeAt(0);
    }
    else {
        return false;
    }
}
/**
 * Faster than using a RegExp for default newline detection during lexing.
 */
var LineTerminatorOptimizedTester = {
    // implements /\n|\r\n?/g.test
    test: function (text) {
        var len = text.length;
        for (var i = this.lastIndex; i < len; i++) {
            var c = text.charCodeAt(i);
            if (c === 10) {
                this.lastIndex = i + 1;
                return true;
            }
            else if (c === 13) {
                if (text.charCodeAt(i + 1) === 10) {
                    this.lastIndex = i + 2;
                }
                else {
                    this.lastIndex = i + 1;
                }
                return true;
            }
        }
        return false;
    },
    lastIndex: 0
};
function checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {
    if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["w" /* has */])(tokType, "LINE_BREAKS")) {
        // if the user explicitly declared the line_breaks option we will respect their choice
        // and assume it is correct.
        return false;
    }
    else {
        /* istanbul ignore else */
        if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["D" /* isRegExp */])(tokType.PATTERN)) {
            try {
                Object(__WEBPACK_IMPORTED_MODULE_3__reg_exp__["a" /* canMatchCharCode */])(lineTerminatorCharCodes, tokType.PATTERN);
            }
            catch (e) {
                /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */
                return {
                    issue: __WEBPACK_IMPORTED_MODULE_1__lexer_public__["b" /* LexerDefinitionErrorType */].IDENTIFY_TERMINATOR,
                    errMsg: e.message
                };
            }
            return false;
        }
        else if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["E" /* isString */])(tokType.PATTERN)) {
            // string literal patterns can always be analyzed to detect line terminator usage
            return false;
        }
        else if (isCustomPattern(tokType)) {
            // custom token types
            return { issue: __WEBPACK_IMPORTED_MODULE_1__lexer_public__["b" /* LexerDefinitionErrorType */].CUSTOM_LINE_BREAK };
        }
        else {
            throw Error("non exhaustive match");
        }
    }
}
function buildLineBreakIssueMessage(tokType, details) {
    /* istanbul ignore else */
    if (details.issue === __WEBPACK_IMPORTED_MODULE_1__lexer_public__["b" /* LexerDefinitionErrorType */].IDENTIFY_TERMINATOR) {
        return ("Warning: unable to identify line terminator usage in pattern.\n" +
            ("\tThe problem is in the <" + tokType.name + "> Token Type\n") +
            ("\t Root cause: " + details.errMsg + ".\n") +
            "\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR");
    }
    else if (details.issue === __WEBPACK_IMPORTED_MODULE_1__lexer_public__["b" /* LexerDefinitionErrorType */].CUSTOM_LINE_BREAK) {
        return ("Warning: A Custom Token Pattern should specify the <line_breaks> option.\n" +
            ("\tThe problem is in the <" + tokType.name + "> Token Type\n") +
            "\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK");
    }
    else {
        throw Error("non exhaustive match");
    }
}
function getCharCodes(charsOrCodes) {
    var charCodes = Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["I" /* map */])(charsOrCodes, function (numOrString) {
        if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["E" /* isString */])(numOrString) && numOrString.length > 0) {
            return numOrString.charCodeAt(0);
        }
        else {
            return numOrString;
        }
    });
    return charCodes;
}
function addToMapOfArrays(map, key, value) {
    if (map[key] === undefined) {
        map[key] = [value];
    }
    else {
        map[key].push(value);
    }
}
var minOptimizationVal = 256;
/**
 * We ae mapping charCode above ASCI (256) into buckets each in the size of 256.
 * This is because ASCI are the most common start chars so each one of those will get its own
 * possible token configs vector.
 *
 * Tokens starting with charCodes "above" ASCI are uncommon, so we can "afford"
 * to place these into buckets of possible token configs, What we gain from
 * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'
 * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).
 * Our 'charCodeToPatternIdxToConfig' max size will now be:
 * 256 + (2^16 / 2^8) - 1 === 511
 *
 * note the hack for fast division integer part extraction
 * See: https://stackoverflow.com/a/4228528
 */
function charCodeToOptimizedIndex(charCode) {
    return charCode < minOptimizationVal
        ? charCode
        : charCodeToOptimizedIdxMap[charCode];
}
/**
 * This is a compromise between cold start / hot running performance
 * Creating this array takes ~3ms on a modern machine,
 * But if we perform the computation at runtime as needed the CSS Lexer benchmark
 * performance degrades by ~10%
 *
 * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.
 */
var charCodeToOptimizedIdxMap = [];
function initCharCodeToOptimizedIndexMap() {
    if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["A" /* isEmpty */])(charCodeToOptimizedIdxMap)) {
        charCodeToOptimizedIdxMap = new Array(65536);
        for (var i = 0; i < 65536; i++) {
            /* tslint:disable */
            charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;
            /* tslint:enable */
        }
    }
}
//# sourceMappingURL=lexer.js.map

/***/ }),
/* 216 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return defaultLexerErrorProvider; });
var defaultLexerErrorProvider = {
    buildUnableToPopLexerModeMessage: function (token) {
        return "Unable to pop Lexer Mode after encountering Token ->" + token.image + "<- The Mode Stack is empty";
    },
    buildUnexpectedCharactersMessage: function (fullText, startOffset, length, line, column) {
        return ("unexpected character: ->" + fullText.charAt(startOffset) + "<- at offset: " + startOffset + "," + (" skipped " + length + " characters."));
    }
};
//# sourceMappingURL=lexer_errors_public.js.map

/***/ }),
/* 217 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = first;
/* unused harmony export firstForSequence */
/* unused harmony export firstForBranching */
/* unused harmony export firstForTerminal */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__gast_gast_public__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__gast_gast__ = __webpack_require__(26);



function first(prod) {
    /* istanbul ignore else */
    if (prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_gast_public__["d" /* NonTerminal */]) {
        // this could in theory cause infinite loops if
        // (1) prod A refs prod B.
        // (2) prod B refs prod A
        // (3) AB can match the empty set
        // in other words a cycle where everything is optional so the first will keep
        // looking ahead for the next optional part and will never exit
        // currently there is no safeguard for this unique edge case because
        // (1) not sure a grammar in which this can happen is useful for anything (productive)
        return first(prod.referencedRule);
    }
    else if (prod instanceof __WEBPACK_IMPORTED_MODULE_1__gast_gast_public__["k" /* Terminal */]) {
        return firstForTerminal(prod);
    }
    else if (Object(__WEBPACK_IMPORTED_MODULE_2__gast_gast__["f" /* isSequenceProd */])(prod)) {
        return firstForSequence(prod);
    }
    else if (Object(__WEBPACK_IMPORTED_MODULE_2__gast_gast__["d" /* isBranchingProd */])(prod)) {
        return firstForBranching(prod);
    }
    else {
        throw Error("non exhaustive match");
    }
}
function firstForSequence(prod) {
    var firstSet = [];
    var seq = prod.definition;
    var nextSubProdIdx = 0;
    var hasInnerProdsRemaining = seq.length > nextSubProdIdx;
    var currSubProd;
    // so we enter the loop at least once (if the definition is not empty
    var isLastInnerProdOptional = true;
    // scan a sequence until it's end or until we have found a NONE optional production in it
    while (hasInnerProdsRemaining && isLastInnerProdOptional) {
        currSubProd = seq[nextSubProdIdx];
        isLastInnerProdOptional = Object(__WEBPACK_IMPORTED_MODULE_2__gast_gast__["e" /* isOptionalProd */])(currSubProd);
        firstSet = firstSet.concat(first(currSubProd));
        nextSubProdIdx = nextSubProdIdx + 1;
        hasInnerProdsRemaining = seq.length > nextSubProdIdx;
    }
    return Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["T" /* uniq */])(firstSet);
}
function firstForBranching(prod) {
    var allAlternativesFirsts = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */])(prod.definition, function (innerProd) {
        return first(innerProd);
    });
    return Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["T" /* uniq */])(Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["t" /* flatten */])(allAlternativesFirsts));
}
function firstForTerminal(terminal) {
    return [terminal.terminalType];
}
//# sourceMappingURL=first.js.map

/***/ }),
/* 218 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return IN; });
// TODO: can this be removed? where is it used?
var IN = "_~IN~_";
//# sourceMappingURL=constants.js.map

/***/ }),
/* 219 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = resolveGrammar;
/* harmony export (immutable) */ __webpack_exports__["c"] = validateGrammar;
/* harmony export (immutable) */ __webpack_exports__["a"] = assignOccurrenceIndices;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__resolver__ = __webpack_require__(327);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__checks__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__errors_public__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__gast__ = __webpack_require__(26);





function resolveGrammar(options) {
    options = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["k" /* defaults */])(options, {
        errMsgProvider: __WEBPACK_IMPORTED_MODULE_3__errors_public__["a" /* defaultGrammarResolverErrorProvider */]
    });
    var topRulesTable = {};
    Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(options.rules, function (rule) {
        topRulesTable[rule.name] = rule;
    });
    return Object(__WEBPACK_IMPORTED_MODULE_1__resolver__["a" /* resolveGrammar */])(topRulesTable, options.errMsgProvider);
}
function validateGrammar(options) {
    options = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["k" /* defaults */])(options, {
        errMsgProvider: __WEBPACK_IMPORTED_MODULE_3__errors_public__["b" /* defaultGrammarValidatorErrorProvider */],
        ignoredIssues: {}
    });
    return Object(__WEBPACK_IMPORTED_MODULE_2__checks__["c" /* validateGrammar */])(options.rules, options.maxLookahead, options.tokenTypes, options.ignoredIssues, options.errMsgProvider, options.grammarName);
}
function assignOccurrenceIndices(options) {
    Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(options.rules, function (currRule) {
        var methodsCollector = new __WEBPACK_IMPORTED_MODULE_4__gast__["a" /* DslMethodsCollectorVisitor */]();
        currRule.accept(methodsCollector);
        Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(methodsCollector.dslMethods, function (methods) {
            Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(methods, function (currMethod, arrIdx) {
                currMethod.idx = arrIdx + 1;
            });
        });
    });
}
//# sourceMappingURL=gast_resolver_public.js.map

/***/ }),
/* 220 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export EOF_FOLLOW_KEY */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return IN_RULE_RECOVERY_EXCEPTION; });
/* unused harmony export InRuleRecoveryException */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Recoverable; });
/* unused harmony export attemptInRepetitionRecovery */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__scan_tokens_public__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__exceptions_public__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__constants__ = __webpack_require__(218);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__parser__ = __webpack_require__(9);





var EOF_FOLLOW_KEY = {};
var IN_RULE_RECOVERY_EXCEPTION = "InRuleRecoveryException";
function InRuleRecoveryException(message) {
    this.name = IN_RULE_RECOVERY_EXCEPTION;
    this.message = message;
}
InRuleRecoveryException.prototype = Error.prototype;
/**
 * This trait is responsible for the error recovery and fault tolerant logic
 */
var Recoverable = /** @class */ (function () {
    function Recoverable() {
    }
    Recoverable.prototype.initRecoverable = function (config) {
        this.firstAfterRepMap = {};
        this.resyncFollows = {};
        this.recoveryEnabled = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["w" /* has */])(config, "recoveryEnabled")
            ? config.recoveryEnabled
            : __WEBPACK_IMPORTED_MODULE_4__parser__["b" /* DEFAULT_PARSER_CONFIG */].recoveryEnabled;
        // performance optimization, NOOP will be inlined which
        // effectively means that this optional feature does not exist
        // when not used.
        if (this.recoveryEnabled) {
            this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;
        }
    };
    Recoverable.prototype.getTokenToInsert = function (tokType) {
        var tokToInsert = Object(__WEBPACK_IMPORTED_MODULE_0__scan_tokens_public__["c" /* createTokenInstance */])(tokType, "", NaN, NaN, NaN, NaN, NaN, NaN);
        tokToInsert.isInsertedInRecovery = true;
        return tokToInsert;
    };
    Recoverable.prototype.canTokenTypeBeInsertedInRecovery = function (tokType) {
        return true;
    };
    Recoverable.prototype.tryInRepetitionRecovery = function (grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {
        var _this = this;
        // TODO: can the resyncTokenType be cached?
        var reSyncTokType = this.findReSyncTokenType();
        var savedLexerState = this.exportLexerState();
        var resyncedTokens = [];
        var passedResyncPoint = false;
        var nextTokenWithoutResync = this.LA(1);
        var currToken = this.LA(1);
        var generateErrorMessage = function () {
            var previousToken = _this.LA(0);
            // we are preemptively re-syncing before an error has been detected, therefor we must reproduce
            // the error that would have been thrown
            var msg = _this.errorMessageProvider.buildMismatchTokenMessage({
                expected: expectedTokType,
                actual: nextTokenWithoutResync,
                previous: previousToken,
                ruleName: _this.getCurrRuleFullName()
            });
            var error = new __WEBPACK_IMPORTED_MODULE_2__exceptions_public__["b" /* MismatchedTokenException */](msg, nextTokenWithoutResync, _this.LA(0));
            // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.
            error.resyncedTokens = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["n" /* dropRight */])(resyncedTokens);
            _this.SAVE_ERROR(error);
        };
        while (!passedResyncPoint) {
            // re-synced to a point where we can safely exit the repetition/
            if (this.tokenMatcher(currToken, expectedTokType)) {
                generateErrorMessage();
                return; // must return here to avoid reverting the inputIdx
            }
            else if (lookAheadFunc.call(this)) {
                // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule
                generateErrorMessage();
                // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule
                grammarRule.apply(this, grammarRuleArgs);
                return; // must return here to avoid reverting the inputIdx
            }
            else if (this.tokenMatcher(currToken, reSyncTokType)) {
                passedResyncPoint = true;
            }
            else {
                currToken = this.SKIP_TOKEN();
                this.addToResyncTokens(currToken, resyncedTokens);
            }
        }
        // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.
        // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by
        // "between rules" resync recovery later in the flow.
        this.importLexerState(savedLexerState);
    };
    Recoverable.prototype.shouldInRepetitionRecoveryBeTried = function (expectTokAfterLastMatch, nextTokIdx, notStuck) {
        // Edge case of arriving from a MANY repetition which is stuck
        // Attempting recovery in this case could cause an infinite loop
        if (notStuck === false) {
            return false;
        }
        // arguments to try and perform resync into the next iteration of the many are missing
        if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {
            return false;
        }
        // no need to recover, next token is what we expect...
        if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {
            return false;
        }
        // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path
        // and prefer some backtracking path that includes recovered errors.
        if (this.isBackTracking()) {
            return false;
        }
        // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm
        // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)
        //noinspection RedundantIfStatementJS
        if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {
            return false;
        }
        return true;
    };
    // Error Recovery functionality
    Recoverable.prototype.getFollowsForInRuleRecovery = function (tokType, tokIdxInRule) {
        var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);
        var follows = this.getNextPossibleTokenTypes(grammarPath);
        return follows;
    };
    Recoverable.prototype.tryInRuleRecovery = function (expectedTokType, follows) {
        if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {
            var tokToInsert = this.getTokenToInsert(expectedTokType);
            return tokToInsert;
        }
        if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {
            var nextTok = this.SKIP_TOKEN();
            this.consumeToken();
            return nextTok;
        }
        throw new InRuleRecoveryException("sad sad panda");
    };
    Recoverable.prototype.canPerformInRuleRecovery = function (expectedToken, follows) {
        return (this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||
            this.canRecoverWithSingleTokenDeletion(expectedToken));
    };
    Recoverable.prototype.canRecoverWithSingleTokenInsertion = function (expectedTokType, follows) {
        var _this = this;
        if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {
            return false;
        }
        // must know the possible following tokens to perform single token insertion
        if (Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["A" /* isEmpty */])(follows)) {
            return false;
        }
        var mismatchedTok = this.LA(1);
        var isMisMatchedTokInFollows = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["q" /* find */])(follows, function (possibleFollowsTokType) {
            return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);
        }) !== undefined;
        return isMisMatchedTokInFollows;
    };
    Recoverable.prototype.canRecoverWithSingleTokenDeletion = function (expectedTokType) {
        var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);
        return isNextTokenWhatIsExpected;
    };
    Recoverable.prototype.isInCurrentRuleReSyncSet = function (tokenTypeIdx) {
        var followKey = this.getCurrFollowKey();
        var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);
        return Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["j" /* contains */])(currentRuleReSyncSet, tokenTypeIdx);
    };
    Recoverable.prototype.findReSyncTokenType = function () {
        var allPossibleReSyncTokTypes = this.flattenFollowSet();
        // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input
        var nextToken = this.LA(1);
        var k = 2;
        while (true) {
            var nextTokenType = nextToken.tokenType;
            if (Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["j" /* contains */])(allPossibleReSyncTokTypes, nextTokenType)) {
                return nextTokenType;
            }
            nextToken = this.LA(k);
            k++;
        }
    };
    Recoverable.prototype.getCurrFollowKey = function () {
        // the length is at least one as we always add the ruleName to the stack before invoking the rule.
        if (this.RULE_STACK.length === 1) {
            return EOF_FOLLOW_KEY;
        }
        var currRuleShortName = this.getLastExplicitRuleShortName();
        var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();
        var prevRuleShortName = this.getPreviousExplicitRuleShortName();
        return {
            ruleName: this.shortRuleNameToFullName(currRuleShortName),
            idxInCallingRule: currRuleIdx,
            inRule: this.shortRuleNameToFullName(prevRuleShortName)
        };
    };
    Recoverable.prototype.buildFullFollowKeyStack = function () {
        var _this = this;
        var explicitRuleStack = this.RULE_STACK;
        var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;
        if (!Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["A" /* isEmpty */])(this.LAST_EXPLICIT_RULE_STACK)) {
            explicitRuleStack = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["I" /* map */])(this.LAST_EXPLICIT_RULE_STACK, function (idx) { return _this.RULE_STACK[idx]; });
            explicitOccurrenceStack = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["I" /* map */])(this.LAST_EXPLICIT_RULE_STACK, function (idx) { return _this.RULE_OCCURRENCE_STACK[idx]; });
        }
        // TODO: only iterate over explicit rules here
        return Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["I" /* map */])(explicitRuleStack, function (ruleName, idx) {
            if (idx === 0) {
                return EOF_FOLLOW_KEY;
            }
            return {
                ruleName: _this.shortRuleNameToFullName(ruleName),
                idxInCallingRule: explicitOccurrenceStack[idx],
                inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])
            };
        });
    };
    Recoverable.prototype.flattenFollowSet = function () {
        var _this = this;
        var followStack = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["I" /* map */])(this.buildFullFollowKeyStack(), function (currKey) {
            return _this.getFollowSetFromFollowKey(currKey);
        });
        return Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["t" /* flatten */])(followStack);
    };
    Recoverable.prototype.getFollowSetFromFollowKey = function (followKey) {
        if (followKey === EOF_FOLLOW_KEY) {
            return [__WEBPACK_IMPORTED_MODULE_0__scan_tokens_public__["a" /* EOF */]];
        }
        var followName = followKey.ruleName +
            followKey.idxInCallingRule +
            __WEBPACK_IMPORTED_MODULE_3__constants__["a" /* IN */] +
            followKey.inRule;
        return this.resyncFollows[followName];
    };
    // It does not make any sense to include a virtual EOF token in the list of resynced tokens
    // as EOF does not really exist and thus does not contain any useful information (line/column numbers)
    Recoverable.prototype.addToResyncTokens = function (token, resyncTokens) {
        if (!this.tokenMatcher(token, __WEBPACK_IMPORTED_MODULE_0__scan_tokens_public__["a" /* EOF */])) {
            resyncTokens.push(token);
        }
        return resyncTokens;
    };
    Recoverable.prototype.reSyncTo = function (tokType) {
        var resyncedTokens = [];
        var nextTok = this.LA(1);
        while (this.tokenMatcher(nextTok, tokType) === false) {
            nextTok = this.SKIP_TOKEN();
            this.addToResyncTokens(nextTok, resyncedTokens);
        }
        // the last token is not part of the error.
        return Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["n" /* dropRight */])(resyncedTokens);
    };
    Recoverable.prototype.attemptInRepetitionRecovery = function (prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
        // by default this is a NO-OP
        // The actual implementation is with the function(not method) below
    };
    Recoverable.prototype.getCurrentGrammarPath = function (tokType, tokIdxInRule) {
        var pathRuleStack = this.getHumanReadableRuleStack();
        var pathOccurrenceStack = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["g" /* cloneArr */])(this.RULE_OCCURRENCE_STACK);
        var grammarPath = {
            ruleStack: pathRuleStack,
            occurrenceStack: pathOccurrenceStack,
            lastTok: tokType,
            lastTokOccurrence: tokIdxInRule
        };
        return grammarPath;
    };
    Recoverable.prototype.getHumanReadableRuleStack = function () {
        var _this = this;
        if (!Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["A" /* isEmpty */])(this.LAST_EXPLICIT_RULE_STACK)) {
            return Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["I" /* map */])(this.LAST_EXPLICIT_RULE_STACK, function (currIdx) {
                return _this.shortRuleNameToFullName(_this.RULE_STACK[currIdx]);
            });
        }
        else {
            return Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["I" /* map */])(this.RULE_STACK, function (currShortName) {
                return _this.shortRuleNameToFullName(currShortName);
            });
        }
    };
    return Recoverable;
}());

function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
    var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);
    var firstAfterRepInfo = this.firstAfterRepMap[key];
    if (firstAfterRepInfo === undefined) {
        var currRuleName = this.getCurrRuleFullName();
        var ruleGrammar = this.getGAstProductions()[currRuleName];
        var walker = new nextToksWalker(ruleGrammar, prodOccurrence);
        firstAfterRepInfo = walker.startWalking();
        this.firstAfterRepMap[key] = firstAfterRepInfo;
    }
    var expectTokAfterLastMatch = firstAfterRepInfo.token;
    var nextTokIdx = firstAfterRepInfo.occurrence;
    var isEndOfRule = firstAfterRepInfo.isEndOfRule;
    // special edge case of a TOP most repetition after which the input should END.
    // this will force an attempt for inRule recovery in that scenario.
    if (this.RULE_STACK.length === 1 &&
        isEndOfRule &&
        expectTokAfterLastMatch === undefined) {
        expectTokAfterLastMatch = __WEBPACK_IMPORTED_MODULE_0__scan_tokens_public__["a" /* EOF */];
        nextTokIdx = 1;
    }
    if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {
        // TODO: performance optimization: instead of passing the original args here, we modify
        // the args param (or create a new one) and make sure the lookahead func is explicitly provided
        // to avoid searching the cache for it once more.
        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);
    }
}
//# sourceMappingURL=recoverable.js.map

/***/ }),
/* 221 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = classNameFromInstance;
/* harmony export (immutable) */ __webpack_exports__["c"] = functionName;
/* harmony export (immutable) */ __webpack_exports__["b"] = defineNameProp;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);

function classNameFromInstance(instance) {
    return functionName(instance.constructor);
}
var FUNC_NAME_REGEXP = /^\s*function\s*(\S*)\s*\(/;
var NAME = "name";
/* istanbul ignore next too many hacks for IE/old versions of node.js here*/
function functionName(func) {
    // Engines that support Function.prototype.name OR the nth (n>1) time after
    // the name has been computed in the following else block.
    var existingNameProp = func.name;
    if (existingNameProp) {
        return existingNameProp;
    }
    // hack for IE and engines that do not support Object.defineProperty on function.name (Node.js 0.10 && 0.12)
    var computedName = func.toString().match(FUNC_NAME_REGEXP)[1];
    return computedName;
}
/**
 * @returns {boolean} - has the property been successfully defined
 */
function defineNameProp(obj, nameValue) {
    var namePropDescriptor = Object.getOwnPropertyDescriptor(obj, NAME);
    /* istanbul ignore else -> will only run in old versions of node.js */
    if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["F" /* isUndefined */])(namePropDescriptor) || namePropDescriptor.configurable) {
        Object.defineProperty(obj, NAME, {
            enumerable: false,
            configurable: true,
            writable: false,
            value: nameValue
        });
        return true;
    }
    /* istanbul ignore next -> will only run in old versions of node.js */
    return false;
}
//# sourceMappingURL=lang_extensions.js.map

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(223);

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["dc"] = __webpack_require__(224);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(48)))

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseFactsFromCustomSQL = exports.legendCont = exports.legend = exports.legendContinuous = exports.spinnerMixin = exports.scatterMixin = exports.rasterMixin = exports.rasterLayer = exports.rasterLayerPolyMixin = exports.rasterLayerPointMixin = exports.rasterLayerHeatmapMixin = exports.mapMixin = exports.marginMixin = exports.stackMixin = exports.coordinateGridRasterMixin = exports.coordinateGridMixin = exports.colorMixin = exports.capMixin = exports.bubbleMixin = exports.baseMixin = exports.asyncMixin = exports.countWidget = exports.boxPlot = exports.mapdTable = exports.scatterPlot = exports.rowChart = exports.rasterChart = exports.numberChart = exports.lineChart = exports.pieChart = exports.heatMap = exports.geoChoroplethChart = exports.dataGrid = exports.dataCount = exports.compositeChart = exports.cloudChart = exports.bubbleChart = exports.barChart = exports.bubbleOverlay = exports.errors = exports.d3 = undefined;

var _core = __webpack_require__(3);

Object.keys(_core).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _core[key];
    }
  });
});

var _coreAsync = __webpack_require__(5);

Object.keys(_coreAsync).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _coreAsync[key];
    }
  });
});

var _events = __webpack_require__(15);

Object.keys(_events).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _events[key];
    }
  });
});

var _filters = __webpack_require__(21);

Object.keys(_filters).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _filters[key];
    }
  });
});

var _utils = __webpack_require__(4);

Object.keys(_utils).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _utils[key];
    }
  });
});

var _logger = __webpack_require__(36);

Object.keys(_logger).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _logger[key];
    }
  });
});

var _bubbleOverlay = __webpack_require__(245);

Object.defineProperty(exports, "bubbleOverlay", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_bubbleOverlay).default;
  }
});

var _barChart = __webpack_require__(250);

Object.defineProperty(exports, "barChart", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_barChart).default;
  }
});

var _bubbleChart = __webpack_require__(253);

Object.defineProperty(exports, "bubbleChart", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_bubbleChart).default;
  }
});

var _cloudChart = __webpack_require__(254);

Object.defineProperty(exports, "cloudChart", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_cloudChart).default;
  }
});

var _compositeChart = __webpack_require__(255);

Object.defineProperty(exports, "compositeChart", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_compositeChart).default;
  }
});

var _dataCount = __webpack_require__(256);

Object.defineProperty(exports, "dataCount", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_dataCount).default;
  }
});

var _dataGrid = __webpack_require__(257);

Object.defineProperty(exports, "dataGrid", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_dataGrid).default;
  }
});

var _geoChoroplethChart = __webpack_require__(258);

Object.defineProperty(exports, "geoChoroplethChart", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_geoChoroplethChart).default;
  }
});

var _heatmap = __webpack_require__(187);

Object.defineProperty(exports, "heatMap", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_heatmap).default;
  }
});

var _pieChart = __webpack_require__(266);

Object.defineProperty(exports, "pieChart", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_pieChart).default;
  }
});

var _lineChart = __webpack_require__(267);

Object.defineProperty(exports, "lineChart", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_lineChart).default;
  }
});

var _numberChart = __webpack_require__(268);

Object.defineProperty(exports, "numberChart", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_numberChart).default;
  }
});

var _rasterChart = __webpack_require__(269);

Object.defineProperty(exports, "rasterChart", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_rasterChart).default;
  }
});

var _rowChart = __webpack_require__(320);

Object.defineProperty(exports, "rowChart", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_rowChart).default;
  }
});

var _scatterPlot = __webpack_require__(321);

Object.defineProperty(exports, "scatterPlot", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_scatterPlot).default;
  }
});

var _mapdTable = __webpack_require__(322);

Object.defineProperty(exports, "mapdTable", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_mapdTable).default;
  }
});

var _boxPlot = __webpack_require__(323);

Object.defineProperty(exports, "boxPlot", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_boxPlot).default;
  }
});

var _countWidget = __webpack_require__(324);

Object.defineProperty(exports, "countWidget", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_countWidget).default;
  }
});

var _asyncMixin = __webpack_require__(182);

Object.defineProperty(exports, "asyncMixin", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_asyncMixin).default;
  }
});

var _baseMixin = __webpack_require__(7);

Object.defineProperty(exports, "baseMixin", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_baseMixin).default;
  }
});

var _bubbleMixin = __webpack_require__(38);

Object.defineProperty(exports, "bubbleMixin", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_bubbleMixin).default;
  }
});

var _capMixin = __webpack_require__(16);

Object.defineProperty(exports, "capMixin", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_capMixin).default;
  }
});

var _colorMixin = __webpack_require__(12);

Object.defineProperty(exports, "colorMixin", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_colorMixin).default;
  }
});

var _coordinateGridMixin = __webpack_require__(14);

Object.defineProperty(exports, "coordinateGridMixin", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_coordinateGridMixin).default;
  }
});

var _coordinateGridRasterMixin = __webpack_require__(193);

Object.defineProperty(exports, "coordinateGridRasterMixin", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_coordinateGridRasterMixin).default;
  }
});

var _stackMixin = __webpack_require__(39);

Object.defineProperty(exports, "stackMixin", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_stackMixin).default;
  }
});

var _marginMixin = __webpack_require__(18);

Object.defineProperty(exports, "marginMixin", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_marginMixin).default;
  }
});

var _mapMixin = __webpack_require__(41);

Object.defineProperty(exports, "mapMixin", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_mapMixin).default;
  }
});

var _rasterLayerHeatmapMixin = __webpack_require__(209);

Object.defineProperty(exports, "rasterLayerHeatmapMixin", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_rasterLayerHeatmapMixin).default;
  }
});

var _rasterLayerPointMixin = __webpack_require__(210);

Object.defineProperty(exports, "rasterLayerPointMixin", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_rasterLayerPointMixin).default;
  }
});

var _rasterLayerPolyMixin = __webpack_require__(211);

Object.defineProperty(exports, "rasterLayerPolyMixin", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_rasterLayerPolyMixin).default;
  }
});

var _rasterLayer = __webpack_require__(341);

Object.defineProperty(exports, "rasterLayer", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_rasterLayer).default;
  }
});

var _rasterMixin = __webpack_require__(343);

Object.defineProperty(exports, "rasterMixin", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_rasterMixin).default;
  }
});

var _scatterMixin = __webpack_require__(202);

Object.defineProperty(exports, "scatterMixin", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_scatterMixin).default;
  }
});

var _spinnerMixin = __webpack_require__(185);

Object.defineProperty(exports, "spinnerMixin", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_spinnerMixin).default;
  }
});

var _legendContinuous = __webpack_require__(344);

Object.defineProperty(exports, "legendContinuous", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_legendContinuous).default;
  }
});

var _legend = __webpack_require__(345);

Object.defineProperty(exports, "legend", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_legend).default;
  }
});

var _dcLegendCont = __webpack_require__(347);

Object.defineProperty(exports, "legendCont", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_dcLegendCont).default;
  }
});

var _customSqlParser = __webpack_require__(212);

Object.defineProperty(exports, "parseFactsFromCustomSQL", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_customSqlParser).default;
  }
});

var _d2 = __webpack_require__(1);

var _d = _interopRequireWildcard(_d2);

var _errors = __webpack_require__(37);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

__webpack_require__(348);
__webpack_require__(349);
__webpack_require__(350);
__webpack_require__(351);
__webpack_require__(352);

if (Object({"NODE_ENV":"production"}).BABEL_ENV !== "test") {
  window.mapboxgl = __webpack_require__(353);
}

exports.d3 = _d; // eslint-disable-line

var errors = exports.errors = {
  Exception: _errors.Exception,
  InvalidStateException: _errors.InvalidStateException,
  BadArgumentException: _errors.BadArgumentException
};

/***/ }),
/* 225 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__parser_create_parser__ = __webpack_require__(11);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "createParser", function() { return __WEBPACK_IMPORTED_MODULE_0__parser_create_parser__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__create_data_graph__ = __webpack_require__(240);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "createDataGraph", function() { return __WEBPACK_IMPORTED_MODULE_1__create_data_graph__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__helpers_expression_builders__ = __webpack_require__(242);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "expr", function() { return __WEBPACK_IMPORTED_MODULE_2__helpers_expression_builders__; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__helpers_transform_builders__ = __webpack_require__(243);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "rel", function() { return __WEBPACK_IMPORTED_MODULE_3__helpers_transform_builders__; });
/**
 * The exported `mapd-data-layer` module. Consists of a graph constructor and
 * helper functions to build expressions and transforms and to parse them
 * @namespace API
 */









/***/ }),
/* 226 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseExpression;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__create_parser__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(49);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };




function parseExpression(expression) {
  var parser = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : __WEBPACK_IMPORTED_MODULE_0__create_parser__["b" /* default */];

  if (typeof expression === "string" || !(typeof expression === "undefined" ? "undefined" : _typeof(expression)) === "object") {
    return expression;
  }

  switch (expression.type) {
    case "=":
    case "<>":
    case "<":
    case ">":
    case "<=":
    case ">=":
      return expression.left + " " + expression.type + " " + (typeof expression.right === "string" ? "'" + expression.right + "'" : expression.right);
    case "between":
    case "not between":
      return expression.field + " " + expression.type.toUpperCase() + " " + expression.left + " AND " + expression.right;
    case "is null":
    case "is not null":
      return expression.field + " " + expression.type.toUpperCase();
    case "ilike":
    case "like":
    case "not like":
      return expression.left + " " + expression.type.toUpperCase() + " " + ("'%" + expression.right + "%'");
    case "coalesce":
      return "COALESCE(" + expression.values.map(function (field) {
        return "'" + field + "'";
      }).join(", ") + ")";
    case "in":
    case "not in":
      if (Array.isArray(expression.set)) {
        return expression.expr + " " + expression.type.toUpperCase() + " (" + expression.set.map(function (field) {
          return typeof field === "number" ? field : "'" + Object(__WEBPACK_IMPORTED_MODULE_1__utils__["a" /* escapeQuotes */])(field) + "'";
        }).join(", ") + ")";
      } else if (_typeof(expression.set) === "object" && (expression.set.type === "data" || expression.set.type === "root")) {
        return expression.expr + " " + expression.type.toUpperCase() + " (" + parser.writeSQL(expression.set) + ")";
      } else {
        return expression;
      }
    case "not":
      return "NOT(" + parseExpression(expression.expr) + ")";
    case "and":
    case "or":
      return "(" + parseExpression(expression.left) + " " + expression.type.toUpperCase() + " " + parseExpression(expression.right) + ")";
    case "case":
      var elseCase = expression.else === null ? "NULL" : "'" + expression.else + "'";
      return "CASE WHEN " + expression.cond.map(function (cond) {
        return parseExpression(cond[0]) + " THEN " + cond[1];
      }).join(" ") + (typeof expression.else !== "undefined" ? " ELSE " + elseCase : "") + " END";
    case "date_trunc":
      return "date_trunc(" + expression.unit + ", " + expression.field + ")";
    case "extract":
      return "extract(" + expression.unit + " from " + expression.field + ")";
    case "root":
      return "(" + parser.writeSQL(expression) + ")";
    case "count":
      if (expression.distinct && expression.approx) {
        return "approx_count_distinct(" + expression.field + ")";
      } else if (expression.distinct) {
        return "count(distinct " + expression.field + " )";
      } else {
        return "count(" + expression.field + ")";
      }
    case "median":
      return "approx_median(" + expression.x + ")";
    case "stddev":
    case "stddev_pop":
    case "stddev_samp":
    case "var_pop":
    case "var_samp":
      return expression.type + "(" + expression.x + ")";
    case "corr":
    case "covar_pop":
    case "covar_samp":
      return expression.type + "(" + expression.x + ", " + expression.y + ")";
    case "min":
    case "max":
    case "sum":
    case "sample":
      return expression.type + "(" + expression.field + ")";
    case "average":
      return "avg(" + expression.field + ")";
    default:
      return expression;
  }
}

/***/ }),
/* 227 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseDataState;


function parseDataState(state, parser) {
  var initialSQL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    select: [],
    from: "",
    where: [],
    groupby: [],
    having: [],
    orderby: [],
    limit: "",
    offset: "",
    unresolved: {},
    with: []
  };

  return state.transform.reduce(function (sql, t) {
    return parser.parseTransform(sql, t);
  }, {
    select: initialSQL.select,
    from: state.type === "root" ? typeof state.source === "string" ? state.source : parser.parseSource(state.source) : initialSQL.from,
    where: initialSQL.where,
    groupby: initialSQL.groupby,
    having: initialSQL.having,
    orderby: initialSQL.orderby,
    limit: initialSQL.limit,
    offset: initialSQL.offset,
    unresolved: initialSQL.unresolved,
    with: initialSQL.with
  });
}

/***/ }),
/* 228 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseTransform;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__parse_aggregate__ = __webpack_require__(229);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse_bin__ = __webpack_require__(230);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__parse_crossfilter__ = __webpack_require__(231);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__parse_sort__ = __webpack_require__(232);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__parse_limit__ = __webpack_require__(233);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__parse_filter__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__parse_postFilter__ = __webpack_require__(234);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__parse_project__ = __webpack_require__(235);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__parse_resolvefilter__ = __webpack_require__(236);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__parse_sample__ = __webpack_require__(237);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__parse_source__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__parse_with__ = __webpack_require__(238);













function parseTransform(sql, t, parser) {
  switch (t.type) {
    case "aggregate":
      return Object(__WEBPACK_IMPORTED_MODULE_0__parse_aggregate__["a" /* default */])(sql, t, parser);
    case "bin":
      return Object(__WEBPACK_IMPORTED_MODULE_1__parse_bin__["a" /* default */])(sql, t);
    case "sort":
      return Object(__WEBPACK_IMPORTED_MODULE_3__parse_sort__["a" /* default */])(sql, t);
    case "limit":
      return Object(__WEBPACK_IMPORTED_MODULE_4__parse_limit__["a" /* default */])(sql, t);
    case "filter":
      return Object(__WEBPACK_IMPORTED_MODULE_5__parse_filter__["a" /* default */])(sql, t, parser);
    case "postFilter":
      return Object(__WEBPACK_IMPORTED_MODULE_6__parse_postFilter__["a" /* default */])(sql, t, parser);
    case "project":
      return Object(__WEBPACK_IMPORTED_MODULE_7__parse_project__["a" /* default */])(sql, t, parser);
    case "sample":
      return Object(__WEBPACK_IMPORTED_MODULE_9__parse_sample__["a" /* default */])(sql, t);
    case "resolvefilter":
      return Object(__WEBPACK_IMPORTED_MODULE_8__parse_resolvefilter__["a" /* default */])(sql, t);
    case "crossfilter":
      return Object(__WEBPACK_IMPORTED_MODULE_2__parse_crossfilter__["a" /* default */])(sql, t);
    case "with":
      return Object(__WEBPACK_IMPORTED_MODULE_11__parse_with__["a" /* default */])(sql, t, parser);
    /* istanbul ignore next */
    default:
      return sql;
  }
}

/***/ }),
/* 229 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseAggregate;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__create_parser__ = __webpack_require__(11);


var AGGREGATES = {
  average: "AVG",
  count: "COUNT",
  min: "MIN",
  max: "MAX",
  sum: "SUM"
};

function parseAggregate(sql, transform) {
  var parser = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : __WEBPACK_IMPORTED_MODULE_0__create_parser__["b" /* default */];

  if (Array.isArray(transform.groupby)) {
    transform.groupby.forEach(function (group) {
      sql = parseGroupBy(sql, group, parser);
    });
  } else {
    sql = parseGroupBy(sql, transform.groupby, parser);
  }

  transform.fields.forEach(function (field, index) {
    var as = transform.as[index];
    sql.select.push(aggregateField(transform.ops[index], field, as));
  });

  return sql;
}

function aggregateField(op, field, as) {
  var str = "";
  if (op === null) {
    str += field;
  } else if (AGGREGATES[op]) {
    str += AGGREGATES[op] + "(" + field + ")";
  } else {
    str += op + "(" + field + ")";
  }

  return str + ("" + (as ? " AS " + as : ""));
}

function parseGroupBy(sql, groupby, parser) {
  if (typeof groupby === "string") {
    sql.select.push(groupby);
    sql.groupby.push(groupby);
  } else if (groupby.type === "bin") {
    sql = parser.parseTransform(sql, groupby);
    sql.groupby.push(groupby.as);
  } else if (groupby.type === "project") {
    sql.select.push(parser.parseExpression(groupby.expr) + (groupby.as ? " AS " + groupby.as : ""));
    if (groupby.as) {
      sql.groupby.push(groupby.as);
    }
  }
  return sql;
}

/***/ }),
/* 230 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseBin;


function parseBin(sql, _ref) {
  var field = _ref.field,
      as = _ref.as,
      extent = _ref.extent,
      maxbins = _ref.maxbins;


  // numBins is used conditionally in our query building below.
  // first of all, if we're going to fall into the overflow bin AND we have
  // 0 bins, then we should land in bin 0. Otherwise, we should land in the last
  // bin.
  //
  // later, we calculate the binning magic number based on numBins - dividing either
  // by it or 1 if it doesn't exist, to prevent a divide by zero / infinity error.
  //
  // The logic used by mapd-crossfilter's getBinnedDimExpression is completely different.
  var numBins = extent[1] - extent[0];

  sql.select.push("case when\n      " + field + " >= " + extent[1] + "\n    then\n      " + (numBins === 0 ? 0 : maxbins - 1) + "\n    else\n      cast((cast(" + field + " as float) - " + extent[0] + ") * " + maxbins / (numBins || 1) + " as int)\n    end\n    AS " + as);
  sql.where.push("((" + field + " >= " + extent[0] + " AND " + field + " <= " + extent[1] + ") OR (" + field + " IS NULL))");
  sql.having.push("(" + as + " >= 0 AND " + as + " < " + maxbins + " OR " + as + " IS NULL)");
  return sql;
}

/***/ }),
/* 231 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseCrossfilter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__create_parser__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse_filter__ = __webpack_require__(50);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };




function parseCrossfilter(sql, transform) {
  var parser = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : __WEBPACK_IMPORTED_MODULE_0__create_parser__["b" /* default */];

  switch (transform.type) {
    case "crossfilter":
      if (_typeof(sql.unresolved) === "object") {
        if (sql.unresolved.hasOwnProperty(transform.signal)) {
          Object.keys(transform.filter).forEach(function (key) {
            var filter = transform.filter[key];
            if (sql.unresolved) {
              var ignore = sql.unresolved[transform.signal].ignore;

              if (Array.isArray(ignore) ? ignore.indexOf(key) === -1 : key !== ignore) {
                Object(__WEBPACK_IMPORTED_MODULE_1__parse_filter__["a" /* default */])(sql, filter, parser);
              }
            }
          });
        }
      }
    default:
      return sql;
  }
}

/***/ }),
/* 232 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseSort;


var ORDERINGS = {
  ascending: "ASC",
  descending: "DESC"
};


function parseSort(sql, transform) {
  transform.field.forEach(function (field, index) {
    sql.orderby.push(field + (Array.isArray(transform.order) ? " " + ORDERINGS[transform.order[index]] : ""));
  });
  return sql;
}

/***/ }),
/* 233 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseLimit;


function parseLimit(sql, transform) {
  sql.limit += transform.row;
  sql.offset += transform.offset || sql.offset;
  return sql;
}

/***/ }),
/* 234 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parsePostFilter;


var operator = {
  "greater than or equals": ">=",
  "less than or equals": "<=",
  "equals": "=",
  "not equals": "<>"
};

function comparisonOperator(ops, min, max) {
  switch (ops) {
    case ">=":
    case "=":
    case "<>":
      return ops + " " + min;
    case "<=":
      return ops + " " + max;
    default:
      return "";
  }
}

function parsePostFilter(sql, transform) {
  switch (transform.type) {
    case "postFilter":
      var operatorExpr = void 0;
      if (transform.ops === "between" || transform.ops === "not between") {
        operatorExpr = transform.ops + " " + transform.min + " AND " + transform.max;
      } else if (transform.ops === "null" || transform.ops === "not null") {
        operatorExpr = "is " + transform.ops;
      } else if (transform.aggType === "AVG" && (transform.ops === "equals" || transform.ops === "not equals")) {
        operatorExpr = operator[transform.ops] + " cast(" + transform.min + " as DOUBLE)";
      } else {
        operatorExpr = comparisonOperator(operator[transform.ops], transform.min, transform.max, transform.aggType);
      }
      var expr = transform.custom ? transform.fields[0] + " " + operatorExpr : transform.aggType + "(" + transform.fields[0] + ") " + operatorExpr;
      sql.having.push(expr);
    default:
      return sql;
  }
}

/***/ }),
/* 235 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseProject;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__create_parser__ = __webpack_require__(11);



function parseProject(sql, transform) {
  var parser = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : __WEBPACK_IMPORTED_MODULE_0__create_parser__["b" /* default */];

  sql.select.push(parser.parseExpression(transform.expr) + (transform.as ? " AS " + transform.as : ""));
  return sql;
}

/***/ }),
/* 236 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseResolvefilter;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function parseResolvefilter(sql, transform) {
  switch (transform.type) {
    case "resolvefilter":
      if (_typeof(sql.unresolved) === "object") {
        sql.unresolved[transform.filter.signal] = transform;
      } else {
        sql.unresolved = _defineProperty({}, transform.filter.signal, transform);
      }
    default:
      return sql;
  }
}

/***/ }),
/* 237 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = sample;


function sample(sql, transform) {
  var size = transform.size,
      limit = transform.limit;

  var ratio = Math.min(limit / size, 1.0);

  if (transform.method === "multiplicativeRowid" && ratio < 1) {
    sql.where.push("(SAMPLE_RATIO(" + ratio + ") OR (" + transform.field + " IN (" + transform.expr.map(function (e) {
      return typeof e === "string" ? "'" + e + "'" : "" + e;
    }).join(", ") + ")))");
  } else if (transform.method === "multiplicative" && ratio < 1) {
    // We are using simple modulo arithmetic expression conversion, 
    // (A * B) mod C = (A mod C * B mod C) mod C, 
    // to optimize the filter here. This helps  the overflow on the backend.
    // We don't have the full modulo expression for golden ratio since 
    // that is a constant expression and we can avoid that execution
    sql.where.push("SAMPLE_RATIO(" + ratio + ")");
  }

  return sql;
}

/***/ }),
/* 238 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseWith;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__create_parser__ = __webpack_require__(11);




function parseWith(sql, transform) {
  var parser = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : __WEBPACK_IMPORTED_MODULE_0__create_parser__["b" /* default */];

  var subQuery = parser.write(parser.parseDataState(transform.fields));
  // need to pass the name for the subquery from mapd-charting, so including with clause in the sql as an object
  sql.with.push(subQuery ? { temp: transform.expr, subQuery: subQuery } : "");
  return sql;
}

/***/ }),
/* 239 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = writeSQL;
/* harmony export (immutable) */ __webpack_exports__["b"] = write;


function writeSQL(state, parser) {
  return write(parser.parseDataState(state));
}


function write(sql) {
  return writeWith(sql.with) + writeSelect(sql.select) + writeFrom(sql.from) + writeWhere(sql.where) + writeGroupby(sql.groupby) + writeHaving(sql.having) + writeOrderBy(sql.orderby) + writeLimit(sql.limit) + writeOffset(sql.offset);
}

function writeSelect(select) {
  return select.length ? "SELECT " + select.join(", ") : "SELECT *";
}

function writeFrom(from) {
  return " FROM " + from;
}

function writeWhere(where) {
  return where.length ? " WHERE " + where.join(" AND ") : "";
}

function writeGroupby(groupby) {
  return groupby.length ? " GROUP BY " + groupby.join(", ") : "";
}

function writeHaving(having) {
  return having.length ? " HAVING " + having.join(" AND ") : "";
}

function writeOrderBy(orderby) {
  return orderby.length ? " ORDER BY " + orderby.join(", ") : "";
}

function writeLimit(limit) {
  return limit.length ? " LIMIT " + limit : "";
}

function writeOffset(offset) {
  return offset.length ? " OFFSET " + offset : "";
}

function writeWith(With) {
  // with clause will get passed as obj in an array. Not expecting more than one WITH clause as of FE-8036
  return With && With.length ? "WITH " + With[0].temp + " AS (" + With[0].subQuery + ") " : "";
}

/***/ }),
/* 240 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = createDataGraph;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__create_data_node__ = __webpack_require__(241);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parser_create_parser__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_invariant__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_invariant__);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };





/**
 * Creates a data graph instance. Must pass in a connector object that implements a query method.
 * @see {@link Graph} for further information.
 * @memberof API
 */
function createDataGraph(connector) {
  __WEBPACK_IMPORTED_MODULE_2_invariant___default()(typeof connector.query === "function", "invalid connector");

  var context = {
    connector: connector,
    parser: Object(__WEBPACK_IMPORTED_MODULE_1__parser_create_parser__["a" /* createParser */])()
  };

  var childNodes = [];

  /**
   * An instance of a data graph. A data graph is basically a tree, where each
   * node represents a
   * @namespace Graph
   */
  var graphAPI = {
    registerParser: registerParser,
    children: children,
    data: data
  };

  /**
   * Registers a custom expression or transform parser. The `typeDef` argument
   * must be a valid type definition and the `typeParser` argument must be a
   * function that matches the type of an ExpressionParser or TransformParser
   * @see {@link https://github.com/mapd/mapd-data-layer/tree/master/src/parser/createParser.js|createParser.js}
   * @memberof Graph
   * @inner
   */
  function registerParser(typeDef, typeParser) {
    context.parser.registerParser(typeDef, typeParser);
  }

  /**
   * Returns all child data node instances of the graph.
   * @memberof Graph
   * @inner
   */
  function children() {
    return childNodes;
  }

  /**
   * Creates a root data node instance. The source must be specific in the
   * initial state. An example of a source, is a string pointing to a tables
   * or an array of source transformations.
   * @memberof Graph
   * @inner
   */
  function data(state) {
    var dataNode = Object(__WEBPACK_IMPORTED_MODULE_0__create_data_node__["a" /* default */])(context, typeof state === "string" || Array.isArray(state) ? { source: state, type: "root" } : _extends({}, state, { type: "root" }));
    childNodes.push(dataNode);
    return dataNode;
  }

  return graphAPI;
}

/***/ }),
/* 241 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = createDataNode;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_invariant__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(49);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };




function createDataNode(context) {
  var initialState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var state = {
    type: initialState.type || "data",
    source: initialState.source,
    transform: initialState.transform || [],
    children: initialState.children || []
  };

  /**
   * A node in the graph that represents a set of data transformations.
   * @namespace Data
   * @see {@link https://github.com/mapd/mapd-data-layer/tree/master/src/create-data-node.js|create-data-node.js}
   */
  var dataNodeAPI = {
    getState: getState,
    transform: transform,
    toSQL: toSQL,
    values: values,
    data: data
  };

  /**
   * Returns the state of the data node.
   * @memberof Data
   * @inner
   */
  function getState() {
    return state;
  }

  /**
   * Sets the transform state of the data node. Either takes in an array of
   * transforms or a function that takes and returns an array of transforms
   * @memberof Data
   * @inner
   */
  function transform(setter) {
    state.transform = typeof setter === "function" ? setter(state.transform) : setter;
    return dataNodeAPI;
  }

  /**
   * Returns the SQL string representation of the set of transforms from
   * the node instance to its source root in the graph
   * @memberof Data
   * @inner
   */
  function toSQL() {
    return context.parser.write(Object(__WEBPACK_IMPORTED_MODULE_1__utils__["b" /* reduceToSQL */])(context, dataNodeAPI));
  }

  /**
   * Uses the `connector` in the graph context to execute data node's
   * SQL query representation and returns queried data as a promise.
   * @memberof Data
   * @inner
   */
  function values() {
    return context.connector.query(context.parser.write(Object(__WEBPACK_IMPORTED_MODULE_1__utils__["b" /* reduceToSQL */])(context, dataNodeAPI)));
  }

  /**
   * Creates a data node instance and sets it as a child of the parent.
   * @memberof Data
   * @inner
   */
  function data(childState) {
    var dataNode = createDataNode(context, _extends({}, childState, {
      source: dataNodeAPI
    }));
    state.children.push(dataNode);
    return dataNode;
  }

  return dataNodeAPI;
}

/***/ }),
/* 242 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["alias"] = alias;
/* harmony export (immutable) */ __webpack_exports__["avg"] = avg;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["sum"] = sum;
/* harmony export (immutable) */ __webpack_exports__["count"] = count;
/* harmony export (immutable) */ __webpack_exports__["approxCount"] = approxCount;
/* harmony export (immutable) */ __webpack_exports__["countStar"] = countStar;
/* harmony export (immutable) */ __webpack_exports__["extract"] = extract;
/* harmony export (immutable) */ __webpack_exports__["dateTrunc"] = dateTrunc;
/* harmony export (immutable) */ __webpack_exports__["inExpr"] = inExpr;
/* harmony export (immutable) */ __webpack_exports__["not"] = not;
/* harmony export (immutable) */ __webpack_exports__["caseExpr"] = caseExpr;
/* harmony export (immutable) */ __webpack_exports__["between"] = between;


/**
 * Creates an alias expression
 * @memberof Expression
 */
function alias(as, expr) {
  return {
    expr: expr,
    as: as
  };
}

/**
 * Creates an average expression
 * @memberof Expression
 */

/**
 * Expression builders. These are helper functions to create expression objects
 * @name expr
 * @memberof API
 * @see {@link Expression}
 */

/**
 * Expression builder module.
 * @name Expression
 * @see {@link https://github.com/mapd/mapd-data-layer/tree/master/src/types/expression-type.js|Expression Types}
 */
function avg(alias, field) {
  return {
    type: "average",
    field: field,
    as: alias
  };
}

/**
 * creates a min expression
 * @memberof Expression
 */
function min(alias, field) {
  return {
    type: "min",
    field: field,
    as: alias
  };
}

/**
 * creates a max expression
 * @memberof Expression
 */
function max(alias, field) {
  return {
    type: "max",
    field: field,
    as: alias
  };
}

/**
 * creates a sum expression
 * @memberof Expression
 */
function sum(alias, field) {
  return {
    type: "sum",
    field: field,
    as: alias
  };
}

/**
 * creates a count expression
 * @memberof Expression
 */
function count(distinct, alias, field) {
  return {
    type: "count",
    distinct: distinct,
    approx: false,
    field: field,
    as: alias
  };
}

/**
 * creates an approx count expression
 * @memberof Expression
 */
function approxCount(distinct, alias, field) {
  return {
    type: "count",
    distinct: distinct,
    approx: true,
    field: field,
    as: alias
  };
}

/**
 * creates a count star expression
 * @memberof Expression
 */
function countStar(alias) {
  return {
    type: "count",
    distinct: false,
    approx: false,
    field: "*",
    as: alias
  };
}

/**
 * creates an extract function expression
 * @memberof Expression
 */
function extract(unit, field) {
  return {
    type: "extract",
    unit: unit,
    field: field
  };
}

/**
 * creates a date_trunc function expression
 * @memberof Expression
 */
function dateTrunc(unit, field) {
  return {
    type: "date_trunc",
    unit: unit,
    field: field
  };
}

/**
 * creates an in expression
 * @memberof Expression
 */
function inExpr(expr, set) {
  return {
    type: "in",
    expr: expr,
    set: set
  };
}

/**
 * Creates a not expression
 * @memberof Expression
 */
function not(expr) {
  return {
    type: "not",
    expr: expr
  };
}

/**
 * Creates a case expression
 * @memberof Expression
 */
function caseExpr(cond, end) {
  return {
    type: "case",
    cond: cond,
    else: end
  };
}

/**
 * Creates a between expression
 * @memberof Expression
 */
function between(field, range) {
  return {
    type: "between",
    field: field,
    left: range[0],
    right: range[1]
  };
}

/***/ }),
/* 243 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["project"] = project;
/* harmony export (immutable) */ __webpack_exports__["aggregate"] = aggregate;
/* harmony export (immutable) */ __webpack_exports__["filter"] = filter;
/* harmony export (immutable) */ __webpack_exports__["filterRange"] = filterRange;
/* harmony export (immutable) */ __webpack_exports__["filterIn"] = filterIn;
/* harmony export (immutable) */ __webpack_exports__["bin"] = bin;
/* harmony export (immutable) */ __webpack_exports__["limit"] = limit;
/* harmony export (immutable) */ __webpack_exports__["sort"] = sort;
/* harmony export (immutable) */ __webpack_exports__["top"] = top;
/* harmony export (immutable) */ __webpack_exports__["bottom"] = bottom;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Creates a Project transform
 * @memberof Transform
 */
function project(expr) {
  // $FlowFixMe
  return {
    type: "project",
    expr: typeof expr === "string" ? expr : expr.expr,
    as: typeof expr === "string" ? null : expr.as
  };
}
/**
 * Transform builders. These are helpers function to create transform objects.
 * @name rel
 * @memberof API
 * @see {@link #transform-1|Transform}
 */

/**
 * Transsform builder module.
 * @name Transform
 * @see {@link https://github.com/mapd/mapd-data-layer/tree/master/src/types/transform-type.js|Transform Types}
 */


function getAggs(agg) {
  if (Array.isArray(agg)) {
    return {
      fields: agg.map(function (a) {
        return a.field;
      }),
      ops: agg.map(function (a) {
        return a.type;
      }),
      // $FlowFixMe
      as: agg.map(function (a) {
        return a.as;
      })
    };
  } else {
    return {
      fields: [agg.field],
      ops: [agg.type],
      as: [agg.as || ""]
    };
  }
}

function getGroupBy(groupby) {
  if (Array.isArray(groupby)) {
    return groupby.map(function (group) {
      if ((typeof group === "undefined" ? "undefined" : _typeof(group)) === "object") {
        return {
          type: "project",
          expr: group.expr,
          as: group.as
        };
      } else {
        return group;
      }
    });
  } else if ((typeof groupby === "undefined" ? "undefined" : _typeof(groupby)) === "object") {
    return {
      type: "project",
      expr: groupby.expr,
      as: groupby.as
    };
  } else {
    return groupby;
  }
}

/**
 * Creates an Aggregate transform
 * @memberof Transform
 */
function aggregate(groupby, agg) {
  var aggs = getAggs(agg);
  var group = getGroupBy(groupby);
  return {
    type: "aggregate",
    fields: aggs.fields,
    ops: aggs.ops,
    as: aggs.as,
    groupby: group
  };
}

/**
 * Creates an Filter transform
 * @memberof Transform
 */
function filter(expr) {
  var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

  return {
    type: "filter",
    id: id,
    expr: expr
  };
}

/**
 * Creates an Filter transform that uses a between expression
 * @memberof Transform
 */
function filterRange(field, range) {
  var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

  return {
    type: "filter",
    id: id,
    expr: {
      type: "between",
      field: field,
      left: range[0],
      right: range[1]
    }
  };
}

/**
 * Creates an Filter transform that uses an in expression
 * @memberof Transform
 */
function filterIn(field, set) {
  var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

  return {
    type: "filter",
    id: id,
    expr: {
      type: "in",
      expr: field,
      set: set
    }
  };
}

/**
 * Creates a Bin tranform
 * @memberof Transform
 */
function bin(alias, field, extent, maxbins) {
  return {
    type: "bin",
    field: field,
    extent: extent,
    maxbins: maxbins,
    as: alias
  };
}

/**
 * Creates a Limit transform
 * @memberof Transform
 */
function limit(row, offset) {
  return {
    type: "limit",
    row: row,
    offset: offset
  };
}

/**
 * Creates a Sort transform
 * @memberof Transform
 */
function sort(field, order) {
  return {
    type: "sort",
    field: typeof field === "string" ? [field] : field,
    order: typeof order === "string" ? [order] : order
  };
}

/**
 * Creates a Sort transform ordered by descending and a Limit transform
 * @memberof Transform
 */
function top(field, limit, offset) {
  return [{
    type: "sort",
    field: [field],
    order: ["descending"]
  }, {
    type: "limit",
    row: limit,
    offset: offset
  }];
}

/**
* Creates a Sort transform ordered by ascending and a Limit transform
 * @memberof Transform
 */
function bottom(field, limit, offset) {
  return [{
    type: "sort",
    field: [field],
    order: ["ascending"]
  }, {
    type: "limit",
    row: limit,
    offset: offset
  }];
}

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./af": 54,
	"./af.js": 54,
	"./ar": 55,
	"./ar-dz": 56,
	"./ar-dz.js": 56,
	"./ar-kw": 57,
	"./ar-kw.js": 57,
	"./ar-ly": 58,
	"./ar-ly.js": 58,
	"./ar-ma": 59,
	"./ar-ma.js": 59,
	"./ar-sa": 60,
	"./ar-sa.js": 60,
	"./ar-tn": 61,
	"./ar-tn.js": 61,
	"./ar.js": 55,
	"./az": 62,
	"./az.js": 62,
	"./be": 63,
	"./be.js": 63,
	"./bg": 64,
	"./bg.js": 64,
	"./bm": 65,
	"./bm.js": 65,
	"./bn": 66,
	"./bn.js": 66,
	"./bo": 67,
	"./bo.js": 67,
	"./br": 68,
	"./br.js": 68,
	"./bs": 69,
	"./bs.js": 69,
	"./ca": 70,
	"./ca.js": 70,
	"./cs": 71,
	"./cs.js": 71,
	"./cv": 72,
	"./cv.js": 72,
	"./cy": 73,
	"./cy.js": 73,
	"./da": 74,
	"./da.js": 74,
	"./de": 75,
	"./de-at": 76,
	"./de-at.js": 76,
	"./de-ch": 77,
	"./de-ch.js": 77,
	"./de.js": 75,
	"./dv": 78,
	"./dv.js": 78,
	"./el": 79,
	"./el.js": 79,
	"./en-SG": 80,
	"./en-SG.js": 80,
	"./en-au": 81,
	"./en-au.js": 81,
	"./en-ca": 82,
	"./en-ca.js": 82,
	"./en-gb": 83,
	"./en-gb.js": 83,
	"./en-ie": 84,
	"./en-ie.js": 84,
	"./en-il": 85,
	"./en-il.js": 85,
	"./en-nz": 86,
	"./en-nz.js": 86,
	"./eo": 87,
	"./eo.js": 87,
	"./es": 88,
	"./es-do": 89,
	"./es-do.js": 89,
	"./es-us": 90,
	"./es-us.js": 90,
	"./es.js": 88,
	"./et": 91,
	"./et.js": 91,
	"./eu": 92,
	"./eu.js": 92,
	"./fa": 93,
	"./fa.js": 93,
	"./fi": 94,
	"./fi.js": 94,
	"./fo": 95,
	"./fo.js": 95,
	"./fr": 96,
	"./fr-ca": 97,
	"./fr-ca.js": 97,
	"./fr-ch": 98,
	"./fr-ch.js": 98,
	"./fr.js": 96,
	"./fy": 99,
	"./fy.js": 99,
	"./ga": 100,
	"./ga.js": 100,
	"./gd": 101,
	"./gd.js": 101,
	"./gl": 102,
	"./gl.js": 102,
	"./gom-latn": 103,
	"./gom-latn.js": 103,
	"./gu": 104,
	"./gu.js": 104,
	"./he": 105,
	"./he.js": 105,
	"./hi": 106,
	"./hi.js": 106,
	"./hr": 107,
	"./hr.js": 107,
	"./hu": 108,
	"./hu.js": 108,
	"./hy-am": 109,
	"./hy-am.js": 109,
	"./id": 110,
	"./id.js": 110,
	"./is": 111,
	"./is.js": 111,
	"./it": 112,
	"./it-ch": 113,
	"./it-ch.js": 113,
	"./it.js": 112,
	"./ja": 114,
	"./ja.js": 114,
	"./jv": 115,
	"./jv.js": 115,
	"./ka": 116,
	"./ka.js": 116,
	"./kk": 117,
	"./kk.js": 117,
	"./km": 118,
	"./km.js": 118,
	"./kn": 119,
	"./kn.js": 119,
	"./ko": 120,
	"./ko.js": 120,
	"./ku": 121,
	"./ku.js": 121,
	"./ky": 122,
	"./ky.js": 122,
	"./lb": 123,
	"./lb.js": 123,
	"./lo": 124,
	"./lo.js": 124,
	"./lt": 125,
	"./lt.js": 125,
	"./lv": 126,
	"./lv.js": 126,
	"./me": 127,
	"./me.js": 127,
	"./mi": 128,
	"./mi.js": 128,
	"./mk": 129,
	"./mk.js": 129,
	"./ml": 130,
	"./ml.js": 130,
	"./mn": 131,
	"./mn.js": 131,
	"./mr": 132,
	"./mr.js": 132,
	"./ms": 133,
	"./ms-my": 134,
	"./ms-my.js": 134,
	"./ms.js": 133,
	"./mt": 135,
	"./mt.js": 135,
	"./my": 136,
	"./my.js": 136,
	"./nb": 137,
	"./nb.js": 137,
	"./ne": 138,
	"./ne.js": 138,
	"./nl": 139,
	"./nl-be": 140,
	"./nl-be.js": 140,
	"./nl.js": 139,
	"./nn": 141,
	"./nn.js": 141,
	"./pa-in": 142,
	"./pa-in.js": 142,
	"./pl": 143,
	"./pl.js": 143,
	"./pt": 144,
	"./pt-br": 145,
	"./pt-br.js": 145,
	"./pt.js": 144,
	"./ro": 146,
	"./ro.js": 146,
	"./ru": 147,
	"./ru.js": 147,
	"./sd": 148,
	"./sd.js": 148,
	"./se": 149,
	"./se.js": 149,
	"./si": 150,
	"./si.js": 150,
	"./sk": 151,
	"./sk.js": 151,
	"./sl": 152,
	"./sl.js": 152,
	"./sq": 153,
	"./sq.js": 153,
	"./sr": 154,
	"./sr-cyrl": 155,
	"./sr-cyrl.js": 155,
	"./sr.js": 154,
	"./ss": 156,
	"./ss.js": 156,
	"./sv": 157,
	"./sv.js": 157,
	"./sw": 158,
	"./sw.js": 158,
	"./ta": 159,
	"./ta.js": 159,
	"./te": 160,
	"./te.js": 160,
	"./tet": 161,
	"./tet.js": 161,
	"./tg": 162,
	"./tg.js": 162,
	"./th": 163,
	"./th.js": 163,
	"./tl-ph": 164,
	"./tl-ph.js": 164,
	"./tlh": 165,
	"./tlh.js": 165,
	"./tr": 166,
	"./tr.js": 166,
	"./tzl": 167,
	"./tzl.js": 167,
	"./tzm": 168,
	"./tzm-latn": 169,
	"./tzm-latn.js": 169,
	"./tzm.js": 168,
	"./ug-cn": 170,
	"./ug-cn.js": 170,
	"./uk": 171,
	"./uk.js": 171,
	"./ur": 172,
	"./ur.js": 172,
	"./uz": 173,
	"./uz-latn": 174,
	"./uz-latn.js": 174,
	"./uz.js": 173,
	"./vi": 175,
	"./vi.js": 175,
	"./x-pseudo": 176,
	"./x-pseudo.js": 176,
	"./yo": 177,
	"./yo.js": 177,
	"./zh-cn": 178,
	"./zh-cn.js": 178,
	"./zh-hk": 179,
	"./zh-hk.js": 179,
	"./zh-tw": 180,
	"./zh-tw.js": 180
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 244;

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = bubbleOverlay;

var _core = __webpack_require__(3);

var _coreAsync = __webpack_require__(5);

var _baseMixin = __webpack_require__(7);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

var _bubbleMixin = __webpack_require__(38);

var _bubbleMixin2 = _interopRequireDefault(_bubbleMixin);

var _capMixin = __webpack_require__(16);

var _capMixin2 = _interopRequireDefault(_capMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _utils = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The bubble overlay chart is quite different from the typical bubble chart. With the bubble overlay
 * chart you can arbitrarily place bubbles on an existing svg or bitmap image, thus changing the
 * typical x and y positioning while retaining the capability to visualize data using bubble radius
 * and coloring.
 *
 * @name bubbleOverlay
 * @memberof dc
 * @mixes dc.bubbleMixin
 * @mixes dc.baseMixin
 * @example
 * // create a bubble overlay chart on top of the '#chart-container1 svg' element using the default global chart group
 * var bubbleChart1 = dc.bubbleOverlayChart('#chart-container1').svg(d3.select('#chart-container1 svg'));
 * // create a bubble overlay chart on top of the '#chart-container2 svg' element using chart group A
 * var bubbleChart2 = dc.compositeChart('#chart-container2', 'chartGroupA').svg(d3.select('#chart-container2 svg'));
 * @param {String|node|d3.selection} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector} specifying
 * a dom block element such as a div; or a dom element or d3 selection.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
 * Interaction with a chart will only trigger events and redraws within the chart's group.
 * @return {dc.bubbleOverlay}
 */
function bubbleOverlay(parent, chartGroup) {
  var BUBBLE_OVERLAY_CLASS = "bubble-overlay";

  /* OVERRIDE -----------------------------------------------------------------*/
  var BUBBLE_POPUP_CLASS = "bubble-popup";
  /* --------------------------------------------------------------------------*/

  var BUBBLE_NODE_CLASS = "node";
  var BUBBLE_CLASS = "bubble";

  /**
   * **mandatory**
   *
   * Set the underlying svg image element. Unlike other dc charts this chart will not generate a svg
   * element; therefore the bubble overlay chart will not work if this function is not invoked. If the
   * underlying image is a bitmap, then an empty svg will need to be created on top of the image.
   * @name svg
   * @memberof dc.bubbleOverlay
   * @instance
   * @example
   * // set up underlying svg element
   * chart.svg(d3.select('#chart svg'));
   * @param {SVGElement|d3.selection} [imageElement]
   * @return {dc.bubbleOverlay}
   */

  /* OVERRIDE -----------------------------------------------------------------*/
  var _chart = (0, _bubbleMixin2.default)((0, _capMixin2.default)((0, _baseMixin2.default)({})));
  /* --------------------------------------------------------------------------*/

  var _g = void 0;
  var _points = [];

  /* OVERRIDE EXTEND ----------------------------------------------------------*/
  var _colorCountUpdateCallback = null;
  var _clickCallbackFunc = null;
  var _sampling = false;

  _chart.MIN_RADIUS = 2;
  _chart.MAX_RADIUS = 10;

  _chart.scaleRadius = false;

  _chart.colorCountDictionary = {};

  _chart.clickCallback = function (_) {
    if (!arguments.length) {
      return _clickCallbackFunc;
    }
    _clickCallbackFunc = _;
    return _chart;
  };

  _chart.transitionDuration(0);
  /* --------------------------------------------------------------------------*/

  _chart.radiusValueAccessor(function (d) {
    return d.value;
  });

  /* OVERRIDE EXTEND ----------------------------------------------------------*/
  _chart.r(_d2.default.scale.sqrt());

  _chart.bounds = null;
  _chart.savedData = [];
  _chart.onColorCountUpdate = function (f) {
    if (!arguments.length) {
      return _colorCountUpdateCallback;
    }
    _colorCountUpdateCallback = f;
    return _chart;
  };

  _chart.sampling = function (setting) {
    // setting should be true or false
    if (!arguments.length) {
      return _sampling;
    }

    if (setting && !_sampling) {
      // if wasn't sampling
      (0, _core.incrementSampledCount)();
    } else if (!setting && _sampling) {
      (0, _core.decrementSampledCount)();
    }
    _sampling = setting;
    if (_sampling == false) {
      _chart.dimension().samplingRatio(null);
    } // unset sampling
    return _chart;
  };

  _chart.setSample = function () {
    if (_sampling) {
      var id = _chart.dimension().getCrossfilterId();
      var filterSize = (0, _coreAsync.lastFilteredSize)(id);
      if (filterSize === undefined) {
        _chart.dimension().samplingRatio(null);
      } else {
        _chart.dimension().samplingRatio(Math.min(_chart.cap() / filterSize, 1.0));
      }
    }
  };

  _chart.onClick = function (d) {
    if (_chart.bounds == null) {
      return;
    }
    var xPixelScale = 1.0 / (_chart.bounds[1][0] - _chart.bounds[0][0]) * _chart.width();
    var yPixelScale = 1.0 / (_chart.bounds[1][1] - _chart.bounds[0][1]) * _chart.height();
    var mapCoords = conv4326To900913([d.x, d.y]);
    var pixelPos = {
      x: (mapCoords[0] - _chart.bounds[0][0]) * xPixelScale,
      y: _chart.height() - (mapCoords[1] - _chart.bounds[0][1]) * yPixelScale
    };

    if (_clickCallbackFunc != null) {
      _clickCallbackFunc(d);
    }
  };
  /* --------------------------------------------------------------------------*/

  /**
   * **mandatory**
   *
   * Set up a data point on the overlay. The name of a data point should match a specific 'key' among
   * data groups generated using keyAccessor.  If a match is found (point name <-> data group key)
   * then a bubble will be generated at the position specified by the function. x and y
   * value specified here are relative to the underlying svg.
   * @name point
   * @memberof dc.bubbleOverlay
   * @instance
   * @param {String} name
   * @param {Number} x
   * @param {Number} y
   * @return {dc.bubbleOverlay}
   */
  _chart.point = function (name, x, y) {
    _points.push({ name: name, x: x, y: y });
    return _chart;
  };

  /* OVERRIDE EXTEND ----------------------------------------------------------*/
  function conv4326To900913(coord) {
    var transCoord = [0.0, 0.0];
    transCoord[0] = coord[0] * 111319.49077777777778;
    transCoord[1] = Math.log(Math.tan((90.0 + coord[1]) * 0.00872664625997)) * 6378136.99911215736947;
    return transCoord;
  }

  _chart.setBounds = function (bounds) {
    // need to convert to 900913 from 4326
    _chart.bounds = [[0.0, 0.0], [0.0, 0.0]];
    _chart.bounds[0] = conv4326To900913(bounds[0]);
    _chart.bounds[1] = conv4326To900913(bounds[1]);
  };
  /* --------------------------------------------------------------------------*/

  _chart._doRender = function () {
    _g = initOverlayG();

    /* OVERRIDE -----------------------------------------------------------------*/
    _g.selectAll("g").remove();
    _chart.plotData();
    /* --------------------------------------------------------------------------*/

    _chart.fadeDeselectedArea();

    return _chart;
  };

  function initOverlayG() {
    _g = _chart.select("g." + BUBBLE_OVERLAY_CLASS);
    if (_g.empty()) {
      _g = _chart.svg().append("g").attr("class", BUBBLE_OVERLAY_CLASS);
    }
    return _g;
  }

  /* OVERRIDE EXTEND ----------------------------------------------------------*/
  function mapDataToPoints(data) {
    if (_chart.bounds == null) {
      return;
    }
    var xPixelScale = 1.0 / (_chart.bounds[1][0] - _chart.bounds[0][0]) * _chart.width();
    var yPixelScale = 1.0 / (_chart.bounds[1][1] - _chart.bounds[0][1]) * _chart.height();
    var numPoints = data.length;
    for (var i = 0; i < numPoints; i++) {
      var coordTrans = conv4326To900913([data[i].x, data[i].y]);
      var xPixel = (coordTrans[0] - _chart.bounds[0][0]) * xPixelScale;
      var yPixel = _chart.height() - (coordTrans[1] - _chart.bounds[0][1]) * yPixelScale;
      data[i].xPixel = xPixel;
      data[i].yPixel = yPixel;
      data[i].xCoord = coordTrans[0];
      data[i].yCoord = coordTrans[1];
    }
  }

  _chart.remapPoints = function () {
    if (_chart.bounds == null) {
      return;
    }
    var xPixelScale = 1.0 / (_chart.bounds[1][0] - _chart.bounds[0][0]) * _chart.width();
    var yPixelScale = 1.0 / (_chart.bounds[1][1] - _chart.bounds[0][1]) * _chart.height();
    var numPoints = _chart.savedData.length;
    for (var p = 0; p < numPoints; p++) {
      _chart.savedData[p].xPixel = (_chart.savedData[p].xCoord - _chart.bounds[0][0]) * xPixelScale;
      _chart.savedData[p].yPixel = _chart.height() - (_chart.savedData[p].yCoord - _chart.bounds[0][1]) * yPixelScale;
    }
    updateBubbles();
  };

  _chart.plotData = function () {
    getData();
    var startTime = new Date();
    mapDataToPoints(_chart.savedData);
    if (_chart.scaleRadius) {
      _chart.r().domain([_chart.rMin(), _chart.rMax()]);

      _chart.r().range([_chart.MIN_RADIUS, _chart.MAX_RADIUS]);
    }
    if (!_g) {
      initOverlayG();
    }
    var bubbleG = _g.selectAll("g." + BUBBLE_NODE_CLASS).data(_chart.savedData, function (d) {
      return d.key;
    });

    bubbleG.enter().append("g").attr("class", function (d) {
      return BUBBLE_NODE_CLASS + " " + _utils.utils.nameToId(d.key);
    }).attr("transform", function (d) {
      return "translate(" + d.xPixel + "," + d.yPixel + ")";
    }).append("circle").attr("class", _chart.BUBBLE_CLASS).attr("r", function (d) {
      return _chart.scaleRadius ? _chart.bubbleR(d) : _chart.radiusValueAccessor()(d);
    }).attr("fill", _chart.getColor).on("click", _chart.onClick);

    bubbleG.attr("transform", function (d) {
      return "translate(" + d.xPixel + "," + d.yPixel + ")";
    }).attr("r", function (d) {
      return _chart.scaleRadius ? _chart.bubbleR(d) : _chart.radiusValueAccessor()(d);
    });

    bubbleG.exit().remove();
    var stopTime = new Date();
    var diff = stopTime - startTime;
  };

  function getData() {
    _chart.colorCountDictionary = {};
    _chart.savedData = _chart.data();
    _chart.savedData.forEach(function (datum) {
      if (datum.color in _chart.colorCountDictionary) {
        _chart.colorCountDictionary[datum.color]++;
      } else {
        _chart.colorCountDictionary[datum.color] = 1;
      }
      datum.key = _chart.keyAccessor()(datum);
    });
    if (_colorCountUpdateCallback != null) {
      _colorCountUpdateCallback(_chart.colorCountDictionary);
    }

    return _chart.savedData;
  }
  /* --------------------------------------------------------------------------*/

  function initializeBubbles() {
    var data = mapData();

    _points.forEach(function (point) {
      var nodeG = getNodeG(point, data);

      var circle = nodeG.select("circle." + BUBBLE_CLASS);

      if (circle.empty()) {
        circle = nodeG.append("circle").attr("class", BUBBLE_CLASS).attr("r", 0).attr("fill", _chart.getColor).on("click", _chart.onClick);
      }

      (0, _core.transition)(circle, _chart.transitionDuration()).attr("r", function (d) {
        return _chart.bubbleR(d);
      });

      _chart._doRenderLabel(nodeG);

      _chart._doRenderTitles(nodeG);
    });
  }

  function mapData() {
    var data = {};
    _chart.data().forEach(function (datum) {
      data[_chart.keyAccessor()(datum)] = datum;
    });
    return data;
  }

  function getNodeG(point, data) {
    var bubbleNodeClass = BUBBLE_NODE_CLASS + " " + _utils.utils.nameToId(point.name);

    var nodeG = _g.select("g." + _utils.utils.nameToId(point.name));

    if (nodeG.empty()) {
      nodeG = _g.append("g").attr("class", bubbleNodeClass).attr("transform", "translate(" + point.x + "," + point.y + ")");
    }

    nodeG.datum(data[point.name]);

    return nodeG;
  }

  _chart._doRedraw = function () {
    /* OVERRIDE -----------------------------------------------------------------*/
    _chart.plotData();
    /* --------------------------------------------------------------------------*/

    _chart.fadeDeselectedArea();
    return _chart;
  };

  function updateBubbles() {
    /* OVERRIDE -----------------------------------------------------------------*/
    if (!_g) {
      return;
    }

    var bubbleG = _g.selectAll("g." + BUBBLE_NODE_CLASS).data(_chart.savedData, function (d) {
      return d.key0;
    });

    bubbleG.attr("transform", function (d) {
      return "translate(" + d.xPixel + "," + d.yPixel + ")";
    });
    /* --------------------------------------------------------------------------*/
  }

  _chart.debug = function (flag) {
    if (flag) {
      var debugG = _chart.select("g." + _core.constants.DEBUG_GROUP_CLASS);

      if (debugG.empty()) {
        debugG = _chart.svg().append("g").attr("class", _core.constants.DEBUG_GROUP_CLASS);
      }

      var debugText = debugG.append("text").attr("x", 10).attr("y", 20);

      debugG.append("rect").attr("width", _chart.width()).attr("height", _chart.height()).on("mousemove", function () {
        var position = _d2.default.mouse(debugG.node());
        var msg = position[0] + ", " + position[1];
        debugText.text(msg);
      });
    } else {
      _chart.selectAll(".debug").remove();
    }

    return _chart;
  };

  _chart.anchor(parent, chartGroup);

  return _chart;
}
/** ***************************************************************************
 * END OVERRIDE: dc.bubbleOverlay                                             *
 * ***************************************************************************/

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = legendMixin;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _core = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PERCENTAGE = 100.0;
var LOWER_THAN_START_RANGE = 1000;

function defaultFormatter(value) {
  var commafy = _d2.default.format(",");
  var formattedValue = parseFloat(value).toFixed(2);
  if (value >= LOWER_THAN_START_RANGE) {
    formattedValue = Math.round(value);
  }

  return commafy(formattedValue);
}

// Finds the name of the color measure, so we can use it when finding the format of the color legend
function getColorMeasureName(chart) {
  var groups = chart.group();
  if (!(groups && groups.reduce)) {
    return null;
  }
  var measures = chart.group().reduce();
  if (!Array.isArray(measures)) {
    return null;
  }

  var colorMeasure = measures.filter(function (x) {
    return x.name === "color";
  });
  // This function should always return either a string or null, never "undefined", since an
  // "undefined" key to the valueFormatter sends us down a weird code path.
  return colorMeasure.length > 0 && typeof colorMeasure[0].measureName !== "undefined" ? colorMeasure[0].measureName : null;
}

function legendMixin(chart) {
  chart.legendablesContinuous = function () {
    var legends = [];
    var colorDomain = chart.colors().domain();

    var colorDomainSize = colorDomain[1] - colorDomain[0];
    var colorRange = chart.colors().range();
    var numColors = colorRange.length;
    var colorMeasureName = getColorMeasureName(chart);

    for (var c = 0; c < numColors; c++) {
      var startRange = c / (numColors - 1) * colorDomainSize + colorDomain[0];
      if (chart.isTargeting()) {
        startRange = "%" + (parseFloat(startRange) * PERCENTAGE).toFixed(2);
      } else if (chart.colorByExpr() === "count(*)") {
        startRange = parseInt(startRange); // eslint-disable-line radix
      } else {
        startRange = parseFloat(startRange);
      }

      var color = null;

      if (colorDomainSize === 0) {
        color = colorRange[Math.floor(numColors / 2)];
      } else {
        color = colorRange[c];
      }

      var valueFormatter = chart.valueFormatter();
      var value = startRange;
      if (!isNaN(value)) {
        value = valueFormatter && valueFormatter(value, colorMeasureName) || defaultFormatter(value);
      }

      legends.push({
        color: color,
        value: value
      });
    }

    return legends;
  };

  var legend_events = ["clearCustomContLegend", "setCustomContLegend"];

  var legend_listeners = _d2.default.dispatch.apply(_d2.default, legend_events);

  (0, _core.override)(chart, "on", function (event, listener) {
    var NON_INDEX = -1;
    if (legend_events.indexOf(event) === NON_INDEX) {
      chart._on(event, listener);
    } else {
      legend_listeners.on(event, listener);
    }

    return chart;
  });

  chart._invokeClearCustomContLegendListener = function () {
    legend_listeners.clearCustomContLegend(chart);
  };

  chart._invokeSetCustomContLegendListener = function (f) {
    legend_listeners.setCustomContLegend(chart, f);
  };

  return chart;
}

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.addFilterHandler = addFilterHandler;
exports.hasFilterHandler = hasFilterHandler;
exports.filterHandlerWithChartContext = filterHandlerWithChartContext;
exports.default = filterMixin;

var _lodash = __webpack_require__(23);

var _formattingHelpers = __webpack_require__(10);

var _events = __webpack_require__(15);

var noop = function noop() {}; // eslint-disable-line no-empty-function

function addFilterHandler(filters, filter) {
  if ((0, _formattingHelpers.isArrayOfObjects)(filter)) {
    filters.push(filter.map(function (f) {
      return f === null ? null : f.value;
    }));
  } else {
    filters.push(filter);
  }
  return filters;
}

var convertAllDatesToISOString = function convertAllDatesToISOString(a) {
  if (Array.isArray(a)) {
    return a.map(convertAllDatesToISOString);
  }
  if (a instanceof Date) {
    return a.toISOString();
  }
  return a;
};

/**
 * hasFilterHandler
 * - if testValue is undefined, checks to see if the chart has any active filters
 * - if testValue is defined, checks to see if that testValue passes the active filter
 *
 * @param {*} filters - the chart's current filter
 * @param {*} testValue - a value being tested to see if it passes the filter
 *
 *  - If chart values are not binned:
 *      - Params will most likely both be an array of values
 *      - e.g. [4,22,100] - and values 4, 22, and 100 will be selected in table chart
 *        with all other values deselected
 *  - If chart values are binned, params will most likely both be an array of arrays
 *      - Inner arrays will represent a range of values
 *      - e.g. [[19,27]] - the bin with values from 19 to 27 will be selected, with
 *        all others being deselected
 */
function hasFilterHandler(filters, testValue) {
  if (typeof testValue === "undefined") {
    return filters.length > 0;
  }
  testValue = Array.isArray(testValue) ? testValue.map(_formattingHelpers.normalizeArrayByValue) : testValue;
  var filtersWithIsoDates = convertAllDatesToISOString(filters);
  var testValueWithISODates = convertAllDatesToISOString(testValue);
  return filtersWithIsoDates.some(function (f) {
    if (Array.isArray(f)) {
      // testValueWithISODates can be array of arrays, so in that case, use loose equality comparison in line 74
      if (Array.isArray(testValueWithISODates) && !Array.isArray(testValueWithISODates[0])) {
        return (0, _lodash.isEqual)(f, testValueWithISODates);
      } else if (!Array.isArray(testValueWithISODates)) {
        return f.length === 1 && f[0] === testValueWithISODates;
      }
    } else if (Array.isArray(testValueWithISODates)) {
      return testValueWithISODates.every(function (f2) {
        return f2 === f;
      });
    }

    // since below comparison is using loose equality comparisons, 9 <= [9] would be true
    return (typeof f === "undefined" ? "undefined" : _typeof(f)) === (typeof testValueWithISODates === "undefined" ? "undefined" : _typeof(testValueWithISODates)) && testValueWithISODates <= f && testValueWithISODates >= f;
  });
}

function filterHandlerWithChartContext(_chart) {
  return function filterHandler(dimension, filters) {
    if (dimension.type === "crossfilter") {
      return filters;
    }

    if (filters.length === 0) {
      dimension.filterAll(_chart.softFilterClear());
      if (_chart.clearTableFilter) {
        _chart.clearTableFilter(); // global filter also will clear all the columns filters on the table
      }
    } else if (_chart.getFilteredColumns && Object.keys(_chart.getFilteredColumns()).length > 0) {
      // case for column filtering on measures
      return filters;
    }
    return filters;
  };
}

function filterMixin(_chart) {
  var _filters = [];
  var softFilterClear = false;
  var areFiltersInverse = false;
  var _hasFilterHandler = noop;

  _chart.filters = function () {
    return _filters;
  };

  _chart.replaceFilter = function (_) {
    _filters = [];
    _chart.filter(_);
  };

  _chart.softFilterClear = function (val) {
    if (!arguments.length) {
      return softFilterClear;
    }
    softFilterClear = val;
    return _chart;
  };

  _chart.filtersInverse = function (isInverse) {
    if (!arguments.length) {
      return areFiltersInverse;
    }
    areFiltersInverse = isInverse;
    return _chart;
  };

  /**
   * Clear all filters associated with this chart
   *
   * The same can be achieved by calling {@link #dc.baseMixin+filter chart.filter(Symbol.for("clear"))}.
   * @name filterAll
   * @memberof dc.baseMixin
   * @instance
   * @return {dc.baseMixin}
   */
  _chart.filterAll = function (_softFilterClear) {
    if (_softFilterClear) {
      _chart.softFilterClear(true);
    } else {
      _chart.softFilterClear(false);
    }
    return _chart.filter(Symbol.for("clear"));
  };

  _chart.filterHandler(filterHandlerWithChartContext(_chart));

  _chart.addFilterHandler(addFilterHandler);

  _chart.hasFilter = function (filter) {
    return _hasFilterHandler(_filters, filter);
  };

  _chart.hasFilterHandler = function (handler) {
    if (!arguments.length) {
      return _hasFilterHandler;
    }
    _hasFilterHandler = handler;
    return _chart;
  };

  _chart.hasFilterHandler(hasFilterHandler);

  function applyFilters() {
    if (_chart.dimension() && _chart.dimension().filter) {
      var fs = _chart.filterHandler()(_chart.dimension(), _filters);
      _filters = fs ? fs : _filters;
    }
  }

  _chart.filter = function (filter) {
    var isFilterInverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (!arguments.length) {
      return _filters.length > 0 ? _filters[0] : null;
    }

    if (Array.isArray(filter) && filter.length === 1) {
      filter = filter[0];
    } else if (Array.isArray(filter)) {
      filter = filter.map(function (filter) {
        return (
          // eslint-disable-line no-shadow, arrow-body-style
          Array.isArray(filter) && filter.length === 1 ? filter[0] : filter
        );
      });
    }

    if (isFilterInverse !== _chart.filtersInverse()) {
      _filters = _chart.resetFilterHandler()(_filters);
      _chart.filtersInverse(isFilterInverse);
    }

    if (filter === Symbol.for("clear") || Array.isArray(filter) && filter.length === 0) {
      _filters = _chart.resetFilterHandler()(_filters);
    } else if (_chart.hasFilter(filter)) {
      _chart.removeFilterHandler()(_filters, filter);
    } else {
      _chart.addFilterHandler()(_filters, filter);
    }

    applyFilters();
    _chart._invokeFilteredListener(filter, isFilterInverse);

    if (_chart.root() !== null && _chart.hasFilter()) {
      _chart.turnOnControls();
    } else {
      _chart.turnOffControls();
    }

    return _chart;
  };

  /**
   * Filters chart on click. Determines if filter is inverse and passes
   * that information to _chart.filter. Calls _chart.redrawGroup at the end.
   * @name handleFilterClick
   * @memberof dc.baseMixin
   * @instance
   * @example
   * chart.handleFilterClick(d3.event, filter);
   * @param {d3.event} event
   * @param {dc filter} filter
   * @return {dc.baseMixin}
   */
  _chart.handleFilterClick = function (event, filter) {
    if (event.defaultPrevented) {
      return;
    }
    var isInverseFilter = event.metaKey || event.ctrlKey;
    _events.events.trigger(function () {
      _chart.filter(filter, isInverseFilter);
      // _chart.redrawGroup()
    });
  };

  return _chart;
}

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = labelMixin;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NON_INDEX = -1;
var LEGEND_WIDTH = 180;
var LABEL_WIDTH_MULTIPLIER = 0.9;

function labelMixin(chart) {
  var events = ["xLabel", "yLabel"];
  var _listeners = _d2.default.dispatch.apply(_d2.default, events);
  var _on = chart.on.bind(chart);
  var _measureLabelsOn = false;

  chart.measureLabelsOn = function (val) {
    if (!arguments.length) {
      return _measureLabelsOn;
    }
    _measureLabelsOn = val;
    return chart;
  };

  chart.on = function (event, listener) {
    var baseEvent = event.includes(".") ? event.slice(0, event.indexOf(".")) : event;
    if (events.indexOf(baseEvent) === NON_INDEX) {
      _on(event, listener);
    } else {
      _listeners.on(event, listener);
    }
    return chart;
  };

  chart._invokeLabelYListener = function (val) {
    _listeners.yLabel(chart, val);
  };

  chart._invokeLabelXListener = function (val) {
    _listeners.xLabel(chart, val);
  };

  function rangeChart() {
    return typeof chart.rangeChart === "function" && chart.rangeChart();
  }

  function focusChart() {
    return typeof chart.focusChart === "function" && chart.focusChart();
  }

  function isIE11() {
    return Boolean(window.MSInputMethodContext) && Boolean(document.documentMode);
  }

  function getMaxLabelWidth(type, hasLegend) {
    if (type === "y") {
      var height = chart.height() + (rangeChart() ? chart.rangeChart().height() : 0);
      return (height - Math.max(chart.margins().top + chart.margins().bottom, 64)) * LABEL_WIDTH_MULTIPLIER;
    }

    return (hasLegend ? chart.width() - LEGEND_WIDTH : chart.effectiveWidth()) * LABEL_WIDTH_MULTIPLIER;
  }

  function getXaxisLeftPosition(hasLegend) {
    return hasLegend ? chart.getAxisLabelContainerWidth("x", hasLegend) / 2 + 32 : chart.effectiveWidth() / 2 + chart.margins().left;
  }

  function getYaxisTopPosition() {
    var yOffset = rangeChart() ? chart.rangeChart().height() - chart.rangeChart().margins().bottom + chart.margins().bottom : 0;
    return (chart.height() - Math.max(chart.margins().top + chart.margins().bottom, 64) + yOffset) / 2 + chart.margins().top;
  }

  chart.getAxisLabelContainerWidth = function (type, hasLegend) {
    var width = type === "x" ? chart.effectiveWidth() : chart.effectiveHeight();
    var adjustForLegend = type === "x" && hasLegend ? 32 : 0;
    return width - adjustForLegend;
  };

  function setLabel(type, val) {
    chart[type + "AxisLabel"](val);
    if (focusChart()) {
      chart.focusChart()["_invokeLabel" + type.toUpperCase() + "Listener"](val);
      if (type === "x") {
        chart.xAxisLabel(val);
        chart.redrawAsync();
      }
      return;
    }
    chart["_invokeLabel" + type.toUpperCase() + "Listener"](val);
    chart.redrawAsync();
  }

  chart.prepareLabelEdit = function () {
    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "y";

    if (rangeChart() && type === "x" || focusChart() && type === "y") {
      return;
    }
    var hasLegend = type === "x" && chart.legend() && chart.legend().legendType && chart.legend().legendType() === "quantitative";

    var iconPosition = {
      left: type === "y" ? "" : getXaxisLeftPosition(hasLegend) + "px",
      top: type === "y" ? getYaxisTopPosition() + "px" : ""
    };

    chart.root().selectAll(".axis-label-edit.type-" + type).remove();

    chart.root().selectAll(".y-axis-label, .x-axis-label").style("display", "none");

    var editorWrapper = chart.root().append("div").attr("class", "axis-label-edit type-" + type).style("width", chart.getAxisLabelContainerWidth(type, hasLegend) + "px").classed("has-legend", hasLegend).style("top", iconPosition.top).style("left", iconPosition.left).append("div").attr("class", "input-wrapper").style("max-width", getMaxLabelWidth(type, hasLegend) + "px").style("width", isIE11() ? getMaxLabelWidth(type, hasLegend) + "px" : "auto");

    editorWrapper.append("span").text(chart[type + "AxisLabel"]());

    editorWrapper.append("input").attr("value", chart[type + "AxisLabel"]()).attr("title", chart[type + "AxisLabel"]()).on("focus", function () {
      this.select();
    }).on("keyup", function () {
      _d2.default.select(this.parentNode).select("span").text(this.value);
      if (_d2.default.event.keyCode === 13) {
        this.blur();
      }
    }).on("mouseup", function () {
      _d2.default.event.preventDefault();
    }).on("change", function () {
      this.blur();
    }).on("blur", function () {
      setLabel(type, this.value);
    });
  };

  return chart;
}

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var SPINNER_DELAY = exports.SPINNER_DELAY = 1000;

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = barChart;

var _core = __webpack_require__(3);

var _utils = __webpack_require__(4);

var _datesAndTimes = __webpack_require__(29);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _stackMixin = __webpack_require__(39);

var _stackMixin2 = _interopRequireDefault(_stackMixin);

var _elasticDimensionMixin = __webpack_require__(186);

var _elasticDimensionMixin2 = _interopRequireDefault(_elasticDimensionMixin);

var _coordinateGridMixin = __webpack_require__(14);

var _coordinateGridMixin2 = _interopRequireDefault(_coordinateGridMixin);

var _multiSeriesMixin = __webpack_require__(188);

var _multiSeriesMixin2 = _interopRequireDefault(_multiSeriesMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MILLISECONDS_IN_SECOND = 1000;

var EXTRACT_UNIT_NUM_BUCKETS = {
  day: 31,
  isodom: 31,
  isodow: 7,
  month: 12,
  quarter: 4,
  hour: 24,
  minute: 60

  /**
   * Concrete bar chart/histogram implementation.
   *
   * @class barChart
   * @memberof dc
   * @mixes dc.stackMixin
   * @mixes dc.coordinateGridMixin
   * @example
   * // create a bar chart under #chart-container1 element using the default global chart group
   * var chart1 = dc.barChart('#chart-container1');
   * // create a bar chart under #chart-container2 element using chart group A
   * var chart2 = dc.barChart('#chart-container2', 'chartGroupA');
   * // create a sub-chart under a composite parent chart
   * var chart3 = dc.barChart(compositeChart);
   * @param {String|node|d3.selection|dc.compositeChart} parent - Any valid
   * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector}
   * specifying a dom block element such as a div; or a dom element or d3 selection.  If the bar
   * chart is a sub-chart in a {@link dc.compositeChart Composite Chart} then pass in the parent
   * composite chart instance instead.
   * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
   * Interaction with a chart will only trigger events and redraws within the chart's group.
   * @returns {dc.barChart}
   */
};function barChart(parent, chartGroup) {
  var MIN_BAR_WIDTH = 1;
  var DEFAULT_GAP_BETWEEN_BARS = 4;
  var LABEL_PADDING = 3;

  var _chart = (0, _elasticDimensionMixin2.default)((0, _stackMixin2.default)((0, _coordinateGridMixin2.default)({})));

  var _gap = DEFAULT_GAP_BETWEEN_BARS;
  var _centerBar = false;
  var _alwaysUseRounding = false;

  var _numBars = void 0;
  var _parent = parent;

  _chart._numberOfBars = null;
  var _barWidth = void 0;

  (0, _core.override)(_chart, "rescale", function () {
    _chart._rescale();
    _barWidth = undefined;

    return _chart;
  });

  _chart.label(function (d) {
    return _utils.utils.printSingleValue(d.y0 + d.y);
  }, false);

  _chart.measureValue = function (value) {
    var customFormatter = _chart.valueFormatter();
    return customFormatter && customFormatter(value) || _utils.utils.formatValue(value);
  };

  _chart.plotData = function () {
    var layers = _chart.chartBodyG().selectAll("g.stack").data(_chart.data());

    calculateBarWidth();

    layers.enter().append("g").attr("class", function (d, i) {
      return "stack " + "_" + i;
    });

    var last = layers.size() - 1;
    layers.each(function (d, i) {
      var layer = _d2.default.select(this);

      renderBars(layer, i, d);
      if (_chart.renderLabel() && last === i) {
        renderLabels(layer, i, d);
      }
    });

    if (_chart.brushOn()) {
      hoverOverBrush();
    }
  };

  function hoverOverBrush() {
    var g = _chart.g().on("mouseout", function () {
      dehighlightBars();
    }).on("mousemove", function () {
      if (_chart.isBrushing()) {
        hidePopup();
      } else {
        highlightBars(g, this);
      }
    });
  }

  function highlightBars(g, e) {
    var coordinates = [0, 0];
    coordinates = _chart.popupCoordinates(_d2.default.mouse(e));
    var x = coordinates[0];
    var y = coordinates[1];
    var xAdjusted = x - _chart.margins().left;
    var yAdjusted = y - _chart.margins().top;

    var popupRows = [];

    var toolTips = g.selectAll(".stack").each(function () {
      var hoverBar = null;

      var bars = _d2.default.select(this).selectAll(".bar").style("fill-opacity", 1);

      bars[0].sort(function (a, b) {
        return _d2.default.select(a).attr("x") - _d2.default.select(b).attr("x");
      });

      bars[0].some(function (obj, i) {
        var elm = _d2.default.select(obj);

        if (xAdjusted < elm.attr("x")) {
          return true;
        }

        hoverBar = { elm: elm, datum: elm.datum(), i: i };
      });

      if (hoverBar && Math.abs(hoverBar.elm.attr("x") - xAdjusted) < _barWidth) {
        hoverBar.elm.style("fill-opacity", 0.8);
        popupRows.push(hoverBar);
      }
    });

    if (popupRows.length > 0) {
      showPopup(popupRows.reverse(), x, y);
    } else {
      hidePopup();
    }
  }

  function dehighlightBars() {
    _chart.g().selectAll(".bar").style("fill-opacity", 1);
    hidePopup();
  }

  function showPopup(arr, x, y) {
    if (!_chart.popupIsEnabled()) {
      hidePopup();
      return false;
    }
    var popup = _chart.popup().classed("hide-delay", true);

    var popupBox = popup.select(".chart-popup-content").html("").classed("popup-list", true);

    popupBox.append("div").attr("class", "popup-header").text(_chart.popupTextAccessor(arr));

    var popupItems = popupBox.selectAll(".popup-item").data(arr).enter().append("div").attr("class", "popup-item");

    popupItems.append("div").attr("class", "popup-legend").style("background-color", function (d) {
      return _chart.getColor(d.datum, d.i);
    });

    if (_chart.series().keys()) {
      popupItems.append("div").attr("class", "popup-item-key").text(function (d) {
        return _chart.colorDomain()[d.datum.idx];
      });
    }

    popupItems.append("div").attr("class", "popup-item-value").text(function (d) {
      return _chart.measureValue(d.datum.y);
    });

    positionPopup(x, y);
    popup.classed("js-showPopup", true);
  }

  function hidePopup() {
    _chart.popup().classed("js-showPopup", false);
  }

  function positionPopup(x, y) {
    var popup = _chart.popup().attr("style", function () {
      return "transform:translate(" + x + "px," + y + "px)";
    });

    popup.select(".chart-popup-box").classed("align-left-center", true).classed("align-right-center", function () {
      return x + (_d2.default.select(this).node().getBoundingClientRect().width + 32) > _chart.width();
    });
  }

  function barHeight(d) {
    return _utils.utils.safeNumber(Math.abs(_chart.y()(d.y + d.y0) - _chart.y()(d.y0)));
  }

  function renderLabels(layer, layerIndex, d) {
    var labels = layer.selectAll("text.barLabel").data(d.values, (0, _utils.pluck)("x"));

    labels.enter().append("text").attr("class", "barLabel").attr("text-anchor", "middle");

    if (_chart.isOrdinal()) {
      labels.on("click", _chart.onClick);
      labels.attr("cursor", "pointer");
    }

    (0, _core.transition)(labels, _chart.transitionDuration()).attr("x", function (d) {
      var x = _chart.x()(d.x);
      if (!_centerBar) {
        x = x + _barWidth / 2;
      }
      return _utils.utils.safeNumber(x);
    }).attr("y", function (d) {
      var y = _chart.y()(d.y + d.y0);

      if (d.y < 0) {
        y = y - barHeight(d);
      }

      return _utils.utils.safeNumber(y - LABEL_PADDING);
    }).text(function (d) {
      return _chart.label()(d);
    });

    (0, _core.transition)(labels.exit(), _chart.transitionDuration()).attr("height", 0).remove();
  }

  function renderBars(layer, layerIndex, d) {
    /* OVERRIDE ---------------------------------------------------------------- */
    _numBars = d.values.length;
    /* ------------------------------------------------------------------------- */
    function colors(d, i) {
      if (d.name) {
        d.layer = d.name;
        return _chart.getColor(d, i);
      } else {
        return _chart.getColor(d, i);
      }
    }

    var bars = layer.selectAll("rect.bar").data(d.values, function (d) {
      return d.x instanceof Date ? d.x.getTime() : d.x;
    });

    var enter = bars.enter().append("rect").attr("class", "bar").attr("fill", colors).attr("y", _chart.yAxisHeight()).attr("height", 0);

    if (_chart.renderTitle()) {
      enter.append("title").text((0, _utils.pluck)("data", _chart.title(d.name)));
    }

    if (_chart.isOrdinal()) {
      bars.on("click", _chart.onClick);
    }

    (0, _core.transition)(bars, _chart.transitionDuration()).attr("x", function (d) {
      var x = _chart.x()(d.x);
      if (_centerBar) {
        x = x - _barWidth / 2;
      }
      if (_chart.isOrdinal() && _gap !== undefined) {
        x = x + _gap / 2;
      }
      return _utils.utils.safeNumber(x);
    }).attr("y", function (d) {
      var y = _chart.y()(d.y + d.y0);

      if (d.y < 0) {
        y = y - barHeight(d);
      }

      return _utils.utils.safeNumber(y);
    }).attr("width", _barWidth).attr("height", function (d) {
      return barHeight(d);
    }).attr("fill", colors).select("title").text((0, _utils.pluck)("data", _chart.title(d.name)));

    (0, _core.transition)(bars.exit(), _chart.transitionDuration()).attr("height", 0).remove();
  }

  function calculateBarWidth() {
    var numberOfBars = void 0;
    var binParams = _chart.group().binParams()[0];

    if (binParams) {
      numberOfBars = binParams.timeBin ? _chart.getTimeBinSize(binParams) : binParams.numBins;
    } else {
      var allValues = _chart.data()[0].values.map(function (val) {
        return val.x;
      });
      var maxVal = Math.max.apply(null, allValues);
      var minVal = Math.min.apply(null, allValues);

      numberOfBars = maxVal - minVal;
    }

    if (_chart.isOrdinal() && _gap === undefined) {
      _barWidth = Math.floor(_chart.x().rangeBand());
    } else if (_gap) {
      _barWidth = Math.floor((_chart.xAxisLength() - (numberOfBars - 1) * _gap) / numberOfBars);
    } else {
      _barWidth = Math.floor(_chart.xAxisLength() / (1 + _chart.barPadding()) / numberOfBars);
    }

    if (_barWidth === Infinity || isNaN(_barWidth) || _barWidth < MIN_BAR_WIDTH) {
      _barWidth = MIN_BAR_WIDTH;
    }
  }

  _chart.fadeDeselectedArea = function () {
    var bars = _chart.chartBodyG().selectAll("rect.bar");
    var extent = _chart.brush().extent();

    if (_chart.isOrdinal()) {
      if (_chart.hasFilter()) {
        bars.classed(_core.constants.SELECTED_CLASS, function (d) {
          return _chart.hasFilter(d.x);
        });
        bars.classed(_core.constants.DESELECTED_CLASS, function (d) {
          return !_chart.hasFilter(d.x);
        });
      } else {
        bars.classed(_core.constants.SELECTED_CLASS, false);
        bars.classed(_core.constants.DESELECTED_CLASS, false);
      }
    } else if (!_chart.brushIsEmpty(extent)) {
      var start = extent[0];
      var end = extent[1];

      bars.classed(_core.constants.DESELECTED_CLASS, function (d) {
        return d.x < start || d.x >= end;
      });
    } else {
      bars.classed(_core.constants.DESELECTED_CLASS, false);
    }
  };

  /**
   * Whether the bar chart will render each bar centered around the data position on the x-axis.
   * @name centerBar
   * @memberof dc.barChart
   * @instance
   * @param {Boolean} [centerBar=false]
   * @return {Boolean}
   * @return {dc.barChart}
   */
  _chart.centerBar = function (centerBar) {
    if (!arguments.length) {
      return _centerBar;
    }
    _centerBar = centerBar;
    return _chart;
  };

  (0, _core.override)(_chart, "onClick", function (d) {
    _chart._onClick(d.data);
  });

  /**
   * Get or set the spacing between bars as a fraction of bar size. Valid values are between 0-1.
   * Setting this value will also remove any previously set {@link #dc.barChart+gap gap}. See the
   * {@link https://github.com/mbostock/d3/wiki/Ordinal-Scales#wiki-ordinal_rangeBands d3 docs}
   * for a visual description of how the padding is applied.
   * @name barPadding
   * @memberof dc.barChart
   * @instance
   * @param {Number} [barPadding=0]
   * @return {Number}
   * @return {dc.barChart}
   */
  _chart.barPadding = function (barPadding) {
    if (!arguments.length) {
      return _chart._rangeBandPadding();
    }
    _chart._rangeBandPadding(barPadding);
    _gap = undefined;
    return _chart;
  };

  _chart._useOuterPadding = function () {
    return _gap === undefined;
  };

  /**
   * Get or set the outer padding on an ordinal bar chart. This setting has no effect on non-ordinal charts.
   * Will pad the width by `padding * barWidth` on each side of the chart.
   * @name outerPadding
   * @memberof dc.barChart
   * @instance
   * @param {Number} [padding=0.5]
   * @return {Number}
   * @return {dc.barChart}
   */
  _chart.outerPadding = _chart._outerRangeBandPadding;

  /**
   * Manually set fixed gap (in px) between bars instead of relying on the default auto-generated
   * gap.  By default the bar chart implementation will calculate and set the gap automatically
   * based on the number of data points and the length of the x axis.
   * @name gap
   * @memberof dc.barChart
   * @instance
   * @param {Number} [gap=2]
   * @return {Number}
   * @return {dc.barChart}
   */
  _chart.gap = function (gap) {
    if (!arguments.length) {
      return _gap;
    }
    _gap = gap;
    return _chart;
  };

  _chart.extendBrush = function () {
    var extent = _chart.brush().extent();
    if (_chart.round() && (!_centerBar || _alwaysUseRounding)) {
      extent[0] = extent.map(_chart.round())[0];
      extent[1] = extent.map(_chart.round())[1];

      _chart.chartBodyG().select(".brush").call(_chart.brush().extent(extent));
    }

    return extent;
  };

  /**
   * Set or get whether rounding is enabled when bars are centered. If false, using
   * rounding with centered bars will result in a warning and rounding will be ignored.  This flag
   * has no effect if bars are not {@link #dc.barChart+centerBar centered}.
   * When using standard d3.js rounding methods, the brush often doesn't align correctly with
   * centered bars since the bars are offset.  The rounding function must add an offset to
   * compensate, such as in the following example.
   * @name alwaysUseRounding
   * @memberof dc.barChart
   * @instance
   * @example
   * chart.round(function(n) { return Math.floor(n) + 0.5; });
   * @param {Boolean} [alwaysUseRounding=false]
   * @return {Boolean}
   * @return {dc.barChart}
   */
  _chart.alwaysUseRounding = function (alwaysUseRounding) {
    if (!arguments.length) {
      return _alwaysUseRounding;
    }
    _alwaysUseRounding = alwaysUseRounding;
    return _chart;
  };

  function colorFilter(color, inv) {
    return function () {
      var item = _d2.default.select(this);
      var match = item.attr("fill") === color;
      return inv ? !match : match;
    };
  }

  _chart.legendHighlight = function (d) {
    if (!_chart.isLegendableHidden(d)) {
      _chart.g().selectAll("rect.bar").classed("highlight", colorFilter(d.color)).classed("fadeout", colorFilter(d.color, true));
    }
  };

  _chart.legendReset = function () {
    _chart.g().selectAll("rect.bar").classed("highlight", false).classed("fadeout", false);
  };

  (0, _core.override)(_chart, "xAxisMax", function () {
    var max = this._xAxisMax();
    if ("resolution" in _chart.xUnits()) {
      var res = _chart.xUnits().resolution;
      max = max + res;
    }
    return max;
  });

  var getConservativeDateTruncBucket = function getConservativeDateTruncBucket(binUnit) {
    return _datesAndTimes.TIME_LABEL_TO_SECONDS[binUnit] * MILLISECONDS_IN_SECOND;
  };

  var getDateExtractBucket = function getDateExtractBucket(binUnit) {
    return EXTRACT_UNIT_NUM_BUCKETS[binUnit];
  };

  _chart.getTimeBinSize = function (binParams) {
    if (binParams.extract && binParams.timeBin !== "year") {
      return getDateExtractBucket(binParams.timeBin);
    }
    return Math.ceil((_chart.xAxisMax() - _chart.xAxisMin()) / getConservativeDateTruncBucket(binParams.timeBin));
  };

  _chart.renderLabel(false);

  _chart = (0, _multiSeriesMixin2.default)(_chart);

  _chart.destroyChart = function () {
    (0, _core.deregisterChart)(_chart, _chart.chartGroup());
    _chart.on("filtered", null);
    _chart.filterAll();
    _chart.resetSvg();
    _chart.root().attr("style", "").attr("class", "").html("");
    _chart._doRender = function () {
      return _chart;
    };
  };

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

//  Ramda v0.21.0
//  https://github.com/ramda/ramda
//  (c) 2013-2016 Scott Sauyet, Michael Hurley, and David Chambers
//  Ramda may be freely distributed under the MIT license.

;(function() {

  'use strict';

  /**
     * A special placeholder value used to specify "gaps" within curried functions,
     * allowing partial application of any combination of arguments, regardless of
     * their positions.
     *
     * If `g` is a curried ternary function and `_` is `R.__`, the following are
     * equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2, _)(1, 3)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @constant
     * @memberOf R
     * @since v0.6.0
     * @category Function
     * @example
     *
     *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');
     *      greet('Alice'); //=> 'Hello, Alice!'
     */
    var __ = { '@@functional/placeholder': true };

    /* eslint-disable no-unused-vars */
    var _arity = function _arity(n, fn) {
        /* eslint-disable no-unused-vars */
        switch (n) {
        case 0:
            return function () {
                return fn.apply(this, arguments);
            };
        case 1:
            return function (a0) {
                return fn.apply(this, arguments);
            };
        case 2:
            return function (a0, a1) {
                return fn.apply(this, arguments);
            };
        case 3:
            return function (a0, a1, a2) {
                return fn.apply(this, arguments);
            };
        case 4:
            return function (a0, a1, a2, a3) {
                return fn.apply(this, arguments);
            };
        case 5:
            return function (a0, a1, a2, a3, a4) {
                return fn.apply(this, arguments);
            };
        case 6:
            return function (a0, a1, a2, a3, a4, a5) {
                return fn.apply(this, arguments);
            };
        case 7:
            return function (a0, a1, a2, a3, a4, a5, a6) {
                return fn.apply(this, arguments);
            };
        case 8:
            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
                return fn.apply(this, arguments);
            };
        case 9:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
                return fn.apply(this, arguments);
            };
        case 10:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                return fn.apply(this, arguments);
            };
        default:
            throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
        }
    };

    var _arrayFromIterator = function _arrayFromIterator(iter) {
        var list = [];
        var next;
        while (!(next = iter.next()).done) {
            list.push(next.value);
        }
        return list;
    };

    var _arrayOf = function _arrayOf() {
        return Array.prototype.slice.call(arguments);
    };

    var _cloneRegExp = function _cloneRegExp(pattern) {
        return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
    };

    var _complement = function _complement(f) {
        return function () {
            return !f.apply(this, arguments);
        };
    };

    /**
     * Private `concat` function to merge two array-like objects.
     *
     * @private
     * @param {Array|Arguments} [set1=[]] An array-like object.
     * @param {Array|Arguments} [set2=[]] An array-like object.
     * @return {Array} A new, merged array.
     * @example
     *
     *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
     */
    var _concat = function _concat(set1, set2) {
        set1 = set1 || [];
        set2 = set2 || [];
        var idx;
        var len1 = set1.length;
        var len2 = set2.length;
        var result = [];
        idx = 0;
        while (idx < len1) {
            result[result.length] = set1[idx];
            idx += 1;
        }
        idx = 0;
        while (idx < len2) {
            result[result.length] = set2[idx];
            idx += 1;
        }
        return result;
    };

    var _containsWith = function _containsWith(pred, x, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            if (pred(x, list[idx])) {
                return true;
            }
            idx += 1;
        }
        return false;
    };

    var _filter = function _filter(fn, list) {
        var idx = 0;
        var len = list.length;
        var result = [];
        while (idx < len) {
            if (fn(list[idx])) {
                result[result.length] = list[idx];
            }
            idx += 1;
        }
        return result;
    };

    var _forceReduced = function _forceReduced(x) {
        return {
            '@@transducer/value': x,
            '@@transducer/reduced': true
        };
    };

    // String(x => x) evaluates to "x => x", so the pattern may not match.
    var _functionName = function _functionName(f) {
        // String(x => x) evaluates to "x => x", so the pattern may not match.
        var match = String(f).match(/^function (\w*)/);
        return match == null ? '' : match[1];
    };

    var _has = function _has(prop, obj) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
    };

    var _identity = function _identity(x) {
        return x;
    };

    var _isArguments = function () {
        var toString = Object.prototype.toString;
        return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
            return toString.call(x) === '[object Arguments]';
        } : function _isArguments(x) {
            return _has('callee', x);
        };
    }();

    /**
     * Tests whether or not an object is an array.
     *
     * @private
     * @param {*} val The object to test.
     * @return {Boolean} `true` if `val` is an array, `false` otherwise.
     * @example
     *
     *      _isArray([]); //=> true
     *      _isArray(null); //=> false
     *      _isArray({}); //=> false
     */
    var _isArray = Array.isArray || function _isArray(val) {
        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
    };

    var _isFunction = function _isNumber(x) {
        return Object.prototype.toString.call(x) === '[object Function]';
    };

    /**
     * Determine if the passed argument is an integer.
     *
     * @private
     * @param {*} n
     * @category Type
     * @return {Boolean}
     */
    var _isInteger = Number.isInteger || function _isInteger(n) {
        return n << 0 === n;
    };

    var _isNumber = function _isNumber(x) {
        return Object.prototype.toString.call(x) === '[object Number]';
    };

    var _isObject = function _isObject(x) {
        return Object.prototype.toString.call(x) === '[object Object]';
    };

    var _isPlaceholder = function _isPlaceholder(a) {
        return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
    };

    var _isRegExp = function _isRegExp(x) {
        return Object.prototype.toString.call(x) === '[object RegExp]';
    };

    var _isString = function _isString(x) {
        return Object.prototype.toString.call(x) === '[object String]';
    };

    var _isTransformer = function _isTransformer(obj) {
        return typeof obj['@@transducer/step'] === 'function';
    };

    var _map = function _map(fn, functor) {
        var idx = 0;
        var len = functor.length;
        var result = Array(len);
        while (idx < len) {
            result[idx] = fn(functor[idx]);
            idx += 1;
        }
        return result;
    };

    // Based on https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
    var _objectAssign = function _objectAssign(target) {
        if (target == null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }
        var output = Object(target);
        var idx = 1;
        var length = arguments.length;
        while (idx < length) {
            var source = arguments[idx];
            if (source != null) {
                for (var nextKey in source) {
                    if (_has(nextKey, source)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
            idx += 1;
        }
        return output;
    };

    var _of = function _of(x) {
        return [x];
    };

    var _pipe = function _pipe(f, g) {
        return function () {
            return g.call(this, f.apply(this, arguments));
        };
    };

    var _pipeP = function _pipeP(f, g) {
        return function () {
            var ctx = this;
            return f.apply(ctx, arguments).then(function (x) {
                return g.call(ctx, x);
            });
        };
    };

    // \b matches word boundary; [\b] matches backspace
    var _quote = function _quote(s) {
        var escaped = s.replace(/\\/g, '\\\\').replace(/[\b]/g, '\\b')    // \b matches word boundary; [\b] matches backspace
    .replace(/\f/g, '\\f').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t').replace(/\v/g, '\\v').replace(/\0/g, '\\0');
        return '"' + escaped.replace(/"/g, '\\"') + '"';
    };

    var _reduced = function _reduced(x) {
        return x && x['@@transducer/reduced'] ? x : {
            '@@transducer/value': x,
            '@@transducer/reduced': true
        };
    };

    /**
     * An optimized, private array `slice` implementation.
     *
     * @private
     * @param {Arguments|Array} args The array or arguments object to consider.
     * @param {Number} [from=0] The array index to slice from, inclusive.
     * @param {Number} [to=args.length] The array index to slice to, exclusive.
     * @return {Array} A new, sliced array.
     * @example
     *
     *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]
     *
     *      var firstThreeArgs = function(a, b, c, d) {
     *        return _slice(arguments, 0, 3);
     *      };
     *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]
     */
    var _slice = function _slice(args, from, to) {
        switch (arguments.length) {
        case 1:
            return _slice(args, 0, args.length);
        case 2:
            return _slice(args, from, args.length);
        default:
            var list = [];
            var idx = 0;
            var len = Math.max(0, Math.min(args.length, to) - from);
            while (idx < len) {
                list[idx] = args[from + idx];
                idx += 1;
            }
            return list;
        }
    };

    /**
     * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
     */
    var _toISOString = function () {
        var pad = function pad(n) {
            return (n < 10 ? '0' : '') + n;
        };
        return typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
            return d.toISOString();
        } : function _toISOString(d) {
            return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
        };
    }();

    var _xfBase = {
        init: function () {
            return this.xf['@@transducer/init']();
        },
        result: function (result) {
            return this.xf['@@transducer/result'](result);
        }
    };

    var _xwrap = function () {
        function XWrap(fn) {
            this.f = fn;
        }
        XWrap.prototype['@@transducer/init'] = function () {
            throw new Error('init not implemented on XWrap');
        };
        XWrap.prototype['@@transducer/result'] = function (acc) {
            return acc;
        };
        XWrap.prototype['@@transducer/step'] = function (acc, x) {
            return this.f(acc, x);
        };
        return function _xwrap(fn) {
            return new XWrap(fn);
        };
    }();

    var _aperture = function _aperture(n, list) {
        var idx = 0;
        var limit = list.length - (n - 1);
        var acc = new Array(limit >= 0 ? limit : 0);
        while (idx < limit) {
            acc[idx] = _slice(list, idx, idx + n);
            idx += 1;
        }
        return acc;
    };

    var _assign = typeof Object.assign === 'function' ? Object.assign : _objectAssign;

    /**
     * Similar to hasMethod, this checks whether a function has a [methodname]
     * function. If it isn't an array it will execute that function otherwise it
     * will default to the ramda implementation.
     *
     * @private
     * @param {Function} fn ramda implemtation
     * @param {String} methodname property to check for a custom implementation
     * @return {Object} Whatever the return value of the method is.
     */
    var _checkForMethod = function _checkForMethod(methodname, fn) {
        return function () {
            var length = arguments.length;
            if (length === 0) {
                return fn();
            }
            var obj = arguments[length - 1];
            return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, _slice(arguments, 0, length - 1));
        };
    };

    /**
     * Optimized internal one-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curry1 = function _curry1(fn) {
        return function f1(a) {
            if (arguments.length === 0 || _isPlaceholder(a)) {
                return f1;
            } else {
                return fn.apply(this, arguments);
            }
        };
    };

    /**
     * Optimized internal two-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curry2 = function _curry2(fn) {
        return function f2(a, b) {
            switch (arguments.length) {
            case 0:
                return f2;
            case 1:
                return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
                    return fn(a, _b);
                });
            default:
                return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
                    return fn(_a, b);
                }) : _isPlaceholder(b) ? _curry1(function (_b) {
                    return fn(a, _b);
                }) : fn(a, b);
            }
        };
    };

    /**
     * Optimized internal three-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curry3 = function _curry3(fn) {
        return function f3(a, b, c) {
            switch (arguments.length) {
            case 0:
                return f3;
            case 1:
                return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
                    return fn(a, _b, _c);
                });
            case 2:
                return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
                    return fn(_a, b, _c);
                }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
                    return fn(a, _b, _c);
                }) : _curry1(function (_c) {
                    return fn(a, b, _c);
                });
            default:
                return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
                    return fn(_a, _b, c);
                }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
                    return fn(_a, b, _c);
                }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
                    return fn(a, _b, _c);
                }) : _isPlaceholder(a) ? _curry1(function (_a) {
                    return fn(_a, b, c);
                }) : _isPlaceholder(b) ? _curry1(function (_b) {
                    return fn(a, _b, c);
                }) : _isPlaceholder(c) ? _curry1(function (_c) {
                    return fn(a, b, _c);
                }) : fn(a, b, c);
            }
        };
    };

    /**
     * Internal curryN function.
     *
     * @private
     * @category Function
     * @param {Number} length The arity of the curried function.
     * @param {Array} received An array of arguments received thus far.
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curryN = function _curryN(length, received, fn) {
        return function () {
            var combined = [];
            var argsIdx = 0;
            var left = length;
            var combinedIdx = 0;
            while (combinedIdx < received.length || argsIdx < arguments.length) {
                var result;
                if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
                    result = received[combinedIdx];
                } else {
                    result = arguments[argsIdx];
                    argsIdx += 1;
                }
                combined[combinedIdx] = result;
                if (!_isPlaceholder(result)) {
                    left -= 1;
                }
                combinedIdx += 1;
            }
            return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
        };
    };

    /**
     * Returns a function that dispatches with different strategies based on the
     * object in list position (last argument). If it is an array, executes [fn].
     * Otherwise, if it has a function with [methodname], it will execute that
     * function (functor case). Otherwise, if it is a transformer, uses transducer
     * [xf] to return a new transformer (transducer case). Otherwise, it will
     * default to executing [fn].
     *
     * @private
     * @param {String} methodname property to check for a custom implementation
     * @param {Function} xf transducer to initialize if object is transformer
     * @param {Function} fn default ramda implementation
     * @return {Function} A function that dispatches on object in list position
     */
    var _dispatchable = function _dispatchable(methodname, xf, fn) {
        return function () {
            var length = arguments.length;
            if (length === 0) {
                return fn();
            }
            var obj = arguments[length - 1];
            if (!_isArray(obj)) {
                var args = _slice(arguments, 0, length - 1);
                if (typeof obj[methodname] === 'function') {
                    return obj[methodname].apply(obj, args);
                }
                if (_isTransformer(obj)) {
                    var transducer = xf.apply(null, args);
                    return transducer(obj);
                }
            }
            return fn.apply(this, arguments);
        };
    };

    var _dropLastWhile = function dropLastWhile(pred, list) {
        var idx = list.length - 1;
        while (idx >= 0 && pred(list[idx])) {
            idx -= 1;
        }
        return _slice(list, 0, idx + 1);
    };

    var _xall = function () {
        function XAll(f, xf) {
            this.xf = xf;
            this.f = f;
            this.all = true;
        }
        XAll.prototype['@@transducer/init'] = _xfBase.init;
        XAll.prototype['@@transducer/result'] = function (result) {
            if (this.all) {
                result = this.xf['@@transducer/step'](result, true);
            }
            return this.xf['@@transducer/result'](result);
        };
        XAll.prototype['@@transducer/step'] = function (result, input) {
            if (!this.f(input)) {
                this.all = false;
                result = _reduced(this.xf['@@transducer/step'](result, false));
            }
            return result;
        };
        return _curry2(function _xall(f, xf) {
            return new XAll(f, xf);
        });
    }();

    var _xany = function () {
        function XAny(f, xf) {
            this.xf = xf;
            this.f = f;
            this.any = false;
        }
        XAny.prototype['@@transducer/init'] = _xfBase.init;
        XAny.prototype['@@transducer/result'] = function (result) {
            if (!this.any) {
                result = this.xf['@@transducer/step'](result, false);
            }
            return this.xf['@@transducer/result'](result);
        };
        XAny.prototype['@@transducer/step'] = function (result, input) {
            if (this.f(input)) {
                this.any = true;
                result = _reduced(this.xf['@@transducer/step'](result, true));
            }
            return result;
        };
        return _curry2(function _xany(f, xf) {
            return new XAny(f, xf);
        });
    }();

    var _xaperture = function () {
        function XAperture(n, xf) {
            this.xf = xf;
            this.pos = 0;
            this.full = false;
            this.acc = new Array(n);
        }
        XAperture.prototype['@@transducer/init'] = _xfBase.init;
        XAperture.prototype['@@transducer/result'] = function (result) {
            this.acc = null;
            return this.xf['@@transducer/result'](result);
        };
        XAperture.prototype['@@transducer/step'] = function (result, input) {
            this.store(input);
            return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;
        };
        XAperture.prototype.store = function (input) {
            this.acc[this.pos] = input;
            this.pos += 1;
            if (this.pos === this.acc.length) {
                this.pos = 0;
                this.full = true;
            }
        };
        XAperture.prototype.getCopy = function () {
            return _concat(_slice(this.acc, this.pos), _slice(this.acc, 0, this.pos));
        };
        return _curry2(function _xaperture(n, xf) {
            return new XAperture(n, xf);
        });
    }();

    var _xdrop = function () {
        function XDrop(n, xf) {
            this.xf = xf;
            this.n = n;
        }
        XDrop.prototype['@@transducer/init'] = _xfBase.init;
        XDrop.prototype['@@transducer/result'] = _xfBase.result;
        XDrop.prototype['@@transducer/step'] = function (result, input) {
            if (this.n > 0) {
                this.n -= 1;
                return result;
            }
            return this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdrop(n, xf) {
            return new XDrop(n, xf);
        });
    }();

    var _xdropLast = function () {
        function XDropLast(n, xf) {
            this.xf = xf;
            this.pos = 0;
            this.full = false;
            this.acc = new Array(n);
        }
        XDropLast.prototype['@@transducer/init'] = _xfBase.init;
        XDropLast.prototype['@@transducer/result'] = function (result) {
            this.acc = null;
            return this.xf['@@transducer/result'](result);
        };
        XDropLast.prototype['@@transducer/step'] = function (result, input) {
            if (this.full) {
                result = this.xf['@@transducer/step'](result, this.acc[this.pos]);
            }
            this.store(input);
            return result;
        };
        XDropLast.prototype.store = function (input) {
            this.acc[this.pos] = input;
            this.pos += 1;
            if (this.pos === this.acc.length) {
                this.pos = 0;
                this.full = true;
            }
        };
        return _curry2(function _xdropLast(n, xf) {
            return new XDropLast(n, xf);
        });
    }();

    var _xdropRepeatsWith = function () {
        function XDropRepeatsWith(pred, xf) {
            this.xf = xf;
            this.pred = pred;
            this.lastValue = undefined;
            this.seenFirstValue = false;
        }
        XDropRepeatsWith.prototype['@@transducer/init'] = function () {
            return this.xf['@@transducer/init']();
        };
        XDropRepeatsWith.prototype['@@transducer/result'] = function (result) {
            return this.xf['@@transducer/result'](result);
        };
        XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
            var sameAsLast = false;
            if (!this.seenFirstValue) {
                this.seenFirstValue = true;
            } else if (this.pred(this.lastValue, input)) {
                sameAsLast = true;
            }
            this.lastValue = input;
            return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdropRepeatsWith(pred, xf) {
            return new XDropRepeatsWith(pred, xf);
        });
    }();

    var _xdropWhile = function () {
        function XDropWhile(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
        XDropWhile.prototype['@@transducer/result'] = _xfBase.result;
        XDropWhile.prototype['@@transducer/step'] = function (result, input) {
            if (this.f) {
                if (this.f(input)) {
                    return result;
                }
                this.f = null;
            }
            return this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdropWhile(f, xf) {
            return new XDropWhile(f, xf);
        });
    }();

    var _xfilter = function () {
        function XFilter(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XFilter.prototype['@@transducer/init'] = _xfBase.init;
        XFilter.prototype['@@transducer/result'] = _xfBase.result;
        XFilter.prototype['@@transducer/step'] = function (result, input) {
            return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
        };
        return _curry2(function _xfilter(f, xf) {
            return new XFilter(f, xf);
        });
    }();

    var _xfind = function () {
        function XFind(f, xf) {
            this.xf = xf;
            this.f = f;
            this.found = false;
        }
        XFind.prototype['@@transducer/init'] = _xfBase.init;
        XFind.prototype['@@transducer/result'] = function (result) {
            if (!this.found) {
                result = this.xf['@@transducer/step'](result, void 0);
            }
            return this.xf['@@transducer/result'](result);
        };
        XFind.prototype['@@transducer/step'] = function (result, input) {
            if (this.f(input)) {
                this.found = true;
                result = _reduced(this.xf['@@transducer/step'](result, input));
            }
            return result;
        };
        return _curry2(function _xfind(f, xf) {
            return new XFind(f, xf);
        });
    }();

    var _xfindIndex = function () {
        function XFindIndex(f, xf) {
            this.xf = xf;
            this.f = f;
            this.idx = -1;
            this.found = false;
        }
        XFindIndex.prototype['@@transducer/init'] = _xfBase.init;
        XFindIndex.prototype['@@transducer/result'] = function (result) {
            if (!this.found) {
                result = this.xf['@@transducer/step'](result, -1);
            }
            return this.xf['@@transducer/result'](result);
        };
        XFindIndex.prototype['@@transducer/step'] = function (result, input) {
            this.idx += 1;
            if (this.f(input)) {
                this.found = true;
                result = _reduced(this.xf['@@transducer/step'](result, this.idx));
            }
            return result;
        };
        return _curry2(function _xfindIndex(f, xf) {
            return new XFindIndex(f, xf);
        });
    }();

    var _xfindLast = function () {
        function XFindLast(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XFindLast.prototype['@@transducer/init'] = _xfBase.init;
        XFindLast.prototype['@@transducer/result'] = function (result) {
            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
        };
        XFindLast.prototype['@@transducer/step'] = function (result, input) {
            if (this.f(input)) {
                this.last = input;
            }
            return result;
        };
        return _curry2(function _xfindLast(f, xf) {
            return new XFindLast(f, xf);
        });
    }();

    var _xfindLastIndex = function () {
        function XFindLastIndex(f, xf) {
            this.xf = xf;
            this.f = f;
            this.idx = -1;
            this.lastIdx = -1;
        }
        XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;
        XFindLastIndex.prototype['@@transducer/result'] = function (result) {
            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
        };
        XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
            this.idx += 1;
            if (this.f(input)) {
                this.lastIdx = this.idx;
            }
            return result;
        };
        return _curry2(function _xfindLastIndex(f, xf) {
            return new XFindLastIndex(f, xf);
        });
    }();

    var _xmap = function () {
        function XMap(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XMap.prototype['@@transducer/init'] = _xfBase.init;
        XMap.prototype['@@transducer/result'] = _xfBase.result;
        XMap.prototype['@@transducer/step'] = function (result, input) {
            return this.xf['@@transducer/step'](result, this.f(input));
        };
        return _curry2(function _xmap(f, xf) {
            return new XMap(f, xf);
        });
    }();

    var _xtake = function () {
        function XTake(n, xf) {
            this.xf = xf;
            this.n = n;
        }
        XTake.prototype['@@transducer/init'] = _xfBase.init;
        XTake.prototype['@@transducer/result'] = _xfBase.result;
        XTake.prototype['@@transducer/step'] = function (result, input) {
            if (this.n === 0) {
                return _reduced(result);
            } else {
                this.n -= 1;
                return this.xf['@@transducer/step'](result, input);
            }
        };
        return _curry2(function _xtake(n, xf) {
            return new XTake(n, xf);
        });
    }();

    var _xtakeWhile = function () {
        function XTakeWhile(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
        XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;
        XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
            return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
        };
        return _curry2(function _xtakeWhile(f, xf) {
            return new XTakeWhile(f, xf);
        });
    }();

    /**
     * Adds two values.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a
     * @param {Number} b
     * @return {Number}
     * @see R.subtract
     * @example
     *
     *      R.add(2, 3);       //=>  5
     *      R.add(7)(10);      //=> 17
     */
    var add = _curry2(function add(a, b) {
        return Number(a) + Number(b);
    });

    /**
     * Applies a function to the value at the given index of an array, returning a
     * new copy of the array with the element at the given index replaced with the
     * result of the function application.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig (a -> a) -> Number -> [a] -> [a]
     * @param {Function} fn The function to apply.
     * @param {Number} idx The index.
     * @param {Array|Arguments} list An array-like object whose value
     *        at the supplied index will be replaced.
     * @return {Array} A copy of the supplied array-like object with
     *         the element at index `idx` replaced with the value
     *         returned by applying `fn` to the existing element.
     * @see R.update
     * @example
     *
     *      R.adjust(R.add(10), 1, [0, 1, 2]);     //=> [0, 11, 2]
     *      R.adjust(R.add(10))(1)([0, 1, 2]);     //=> [0, 11, 2]
     */
    var adjust = _curry3(function adjust(fn, idx, list) {
        if (idx >= list.length || idx < -list.length) {
            return list;
        }
        var start = idx < 0 ? list.length : 0;
        var _idx = start + idx;
        var _list = _concat(list);
        _list[_idx] = fn(list[_idx]);
        return _list;
    });

    /**
     * Returns `true` if all elements of the list match the predicate, `false` if
     * there are any that don't.
     *
     * Dispatches to the `all` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> Boolean
     * @param {Function} fn The predicate function.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
     *         otherwise.
     * @see R.any, R.none, R.transduce
     * @example
     *
     *      var lessThan2 = R.flip(R.lt)(2);
     *      var lessThan3 = R.flip(R.lt)(3);
     *      R.all(lessThan2)([1, 2]); //=> false
     *      R.all(lessThan3)([1, 2]); //=> true
     */
    var all = _curry2(_dispatchable('all', _xall, function all(fn, list) {
        var idx = 0;
        while (idx < list.length) {
            if (!fn(list[idx])) {
                return false;
            }
            idx += 1;
        }
        return true;
    }));

    /**
     * Returns a function that always returns the given value. Note that for
     * non-primitives the value returned is a reference to the original value.
     *
     * This function is known as `const`, `constant`, or `K` (for K combinator) in
     * other languages and libraries.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig a -> (* -> a)
     * @param {*} val The value to wrap in a function
     * @return {Function} A Function :: * -> val.
     * @example
     *
     *      var t = R.always('Tee');
     *      t(); //=> 'Tee'
     */
    var always = _curry1(function always(val) {
        return function () {
            return val;
        };
    });

    /**
     * Returns `true` if both arguments are `true`; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Logic
     * @sig * -> * -> *
     * @param {Boolean} a A boolean value
     * @param {Boolean} b A boolean value
     * @return {Boolean} `true` if both arguments are `true`, `false` otherwise
     * @see R.both
     * @example
     *
     *      R.and(true, true); //=> true
     *      R.and(true, false); //=> false
     *      R.and(false, true); //=> false
     *      R.and(false, false); //=> false
     */
    var and = _curry2(function and(a, b) {
        return a && b;
    });

    /**
     * Returns `true` if at least one of elements of the list match the predicate,
     * `false` otherwise.
     *
     * Dispatches to the `any` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> Boolean
     * @param {Function} fn The predicate function.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
     *         otherwise.
     * @see R.all, R.none, R.transduce
     * @example
     *
     *      var lessThan0 = R.flip(R.lt)(0);
     *      var lessThan2 = R.flip(R.lt)(2);
     *      R.any(lessThan0)([1, 2]); //=> false
     *      R.any(lessThan2)([1, 2]); //=> true
     */
    var any = _curry2(_dispatchable('any', _xany, function any(fn, list) {
        var idx = 0;
        while (idx < list.length) {
            if (fn(list[idx])) {
                return true;
            }
            idx += 1;
        }
        return false;
    }));

    /**
     * Returns a new list, composed of n-tuples of consecutive elements If `n` is
     * greater than the length of the list, an empty list is returned.
     *
     * Dispatches to the `aperture` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category List
     * @sig Number -> [a] -> [[a]]
     * @param {Number} n The size of the tuples to create
     * @param {Array} list The list to split into `n`-tuples
     * @return {Array} The new list.
     * @see R.transduce
     * @example
     *
     *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
     *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
     *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
     */
    var aperture = _curry2(_dispatchable('aperture', _xaperture, _aperture));

    /**
     * Returns a new list containing the contents of the given list, followed by
     * the given element.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> [a]
     * @param {*} el The element to add to the end of the new list.
     * @param {Array} list The list whose contents will be added to the beginning of the output
     *        list.
     * @return {Array} A new list containing the contents of the old list followed by `el`.
     * @see R.prepend
     * @example
     *
     *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
     *      R.append('tests', []); //=> ['tests']
     *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
     */
    var append = _curry2(function append(el, list) {
        return _concat(list, [el]);
    });

    /**
     * Applies function `fn` to the argument list `args`. This is useful for
     * creating a fixed-arity function from a variadic function. `fn` should be a
     * bound function if context is significant.
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Function
     * @sig (*... -> a) -> [*] -> a
     * @param {Function} fn
     * @param {Array} args
     * @return {*}
     * @see R.call, R.unapply
     * @example
     *
     *      var nums = [1, 2, 3, -99, 42, 6, 7];
     *      R.apply(Math.max, nums); //=> 42
     */
    var apply = _curry2(function apply(fn, args) {
        return fn.apply(this, args);
    });

    /**
     * Makes a shallow clone of an object, setting or overriding the specified
     * property with the given value. Note that this copies and flattens prototype
     * properties onto the new object as well. All non-primitive properties are
     * copied by reference.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @sig String -> a -> {k: v} -> {k: v}
     * @param {String} prop the property name to set
     * @param {*} val the new value
     * @param {Object} obj the object to clone
     * @return {Object} a new object similar to the original except for the specified property.
     * @see R.dissoc
     * @example
     *
     *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
     */
    var assoc = _curry3(function assoc(prop, val, obj) {
        var result = {};
        for (var p in obj) {
            result[p] = obj[p];
        }
        result[prop] = val;
        return result;
    });

    /**
     * Makes a shallow clone of an object, setting or overriding the nodes required
     * to create the given path, and placing the specific value at the tail end of
     * that path. Note that this copies and flattens prototype properties onto the
     * new object as well. All non-primitive properties are copied by reference.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @sig [String] -> a -> {k: v} -> {k: v}
     * @param {Array} path the path to set
     * @param {*} val the new value
     * @param {Object} obj the object to clone
     * @return {Object} a new object similar to the original except along the specified path.
     * @see R.dissocPath
     * @example
     *
     *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
     */
    var assocPath = _curry3(function assocPath(path, val, obj) {
        switch (path.length) {
        case 0:
            return val;
        case 1:
            return assoc(path[0], val, obj);
        default:
            return assoc(path[0], assocPath(_slice(path, 1), val, Object(obj[path[0]])), obj);
        }
    });

    /**
     * Creates a function that is bound to a context.
     * Note: `R.bind` does not provide the additional argument-binding capabilities of
     * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category Function
     * @category Object
     * @sig (* -> *) -> {*} -> (* -> *)
     * @param {Function} fn The function to bind to context
     * @param {Object} thisObj The context to bind `fn` to
     * @return {Function} A function that will execute in the context of `thisObj`.
     * @see R.partial
     */
    var bind = _curry2(function bind(fn, thisObj) {
        return _arity(fn.length, function () {
            return fn.apply(thisObj, arguments);
        });
    });

    /**
     * Restricts a number to be within a range.
     *
     * Also works for other ordered types such as Strings and Dates.
     *
     * @func
     * @memberOf R
     * @since v0.20.0
     * @category Relation
     * @sig Ord a => a -> a -> a -> a
     * @param {Number} minimum number
     * @param {Number} maximum number
     * @param {Number} value to be clamped
     * @return {Number} Returns the clamped value
     * @example
     *
     *      R.clamp(1, 10, -1) // => 1
     *      R.clamp(1, 10, 11) // => 10
     *      R.clamp(1, 10, 4)  // => 4
     */
    var clamp = _curry3(function clamp(min, max, value) {
        if (min > max) {
            throw new Error('min must not be greater than max in clamp(min, max, value)');
        }
        return value < min ? min : value > max ? max : value;
    });

    /**
     * Makes a comparator function out of a function that reports whether the first
     * element is less than the second.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a, b -> Boolean) -> (a, b -> Number)
     * @param {Function} pred A predicate function of arity two.
     * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`.
     * @example
     *
     *      var cmp = R.comparator((a, b) => a.age < b.age);
     *      var people = [
     *        // ...
     *      ];
     *      R.sort(cmp, people);
     */
    var comparator = _curry1(function comparator(pred) {
        return function (a, b) {
            return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
        };
    });

    /**
     * Returns a curried equivalent of the provided function, with the specified
     * arity. The curried function has two unusual capabilities. First, its
     * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
     * following are equivalent:
     *
     *   - `g(1)(2)(3)`
     *   - `g(1)(2, 3)`
     *   - `g(1, 2)(3)`
     *   - `g(1, 2, 3)`
     *
     * Secondly, the special placeholder value `R.__` may be used to specify
     * "gaps", allowing partial application of any combination of arguments,
     * regardless of their positions. If `g` is as above and `_` is `R.__`, the
     * following are equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @func
     * @memberOf R
     * @since v0.5.0
     * @category Function
     * @sig Number -> (* -> a) -> (* -> a)
     * @param {Number} length The arity for the returned function.
     * @param {Function} fn The function to curry.
     * @return {Function} A new, curried function.
     * @see R.curry
     * @example
     *
     *      var sumArgs = (...args) => R.sum(args);
     *
     *      var curriedAddFourNumbers = R.curryN(4, sumArgs);
     *      var f = curriedAddFourNumbers(1, 2);
     *      var g = f(3);
     *      g(4); //=> 10
     */
    var curryN = _curry2(function curryN(length, fn) {
        if (length === 1) {
            return _curry1(fn);
        }
        return _arity(length, _curryN(length, [], fn));
    });

    /**
     * Decrements its argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Math
     * @sig Number -> Number
     * @param {Number} n
     * @return {Number}
     * @see R.inc
     * @example
     *
     *      R.dec(42); //=> 41
     */
    var dec = add(-1);

    /**
     * Returns the second argument if it is not `null`, `undefined` or `NaN`
     * otherwise the first argument is returned.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Logic
     * @sig a -> b -> a | b
     * @param {a} val The default value.
     * @param {b} val The value to return if it is not null or undefined
     * @return {*} The the second value or the default value
     * @example
     *
     *      var defaultTo42 = R.defaultTo(42);
     *
     *      defaultTo42(null);  //=> 42
     *      defaultTo42(undefined);  //=> 42
     *      defaultTo42('Ramda');  //=> 'Ramda'
     *      defaultTo42(parseInt('string')); //=> 42
     */
    var defaultTo = _curry2(function defaultTo(d, v) {
        return v == null || v !== v ? d : v;
    });

    /**
     * Finds the set (i.e. no duplicates) of all elements in the first list not
     * contained in the second list. Duplication is determined according to the
     * value returned by applying the supplied predicate to two list elements.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The elements in `list1` that are not in `list2`.
     * @see R.difference
     * @example
     *
     *      var cmp = (x, y) => x.a === y.a;
     *      var l1 = [{a: 1}, {a: 2}, {a: 3}];
     *      var l2 = [{a: 3}, {a: 4}];
     *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
     */
    var differenceWith = _curry3(function differenceWith(pred, first, second) {
        var out = [];
        var idx = 0;
        var firstLen = first.length;
        while (idx < firstLen) {
            if (!_containsWith(pred, first[idx], second) && !_containsWith(pred, first[idx], out)) {
                out.push(first[idx]);
            }
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a new object that does not contain a `prop` property.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Object
     * @sig String -> {k: v} -> {k: v}
     * @param {String} prop the name of the property to dissociate
     * @param {Object} obj the object to clone
     * @return {Object} a new object similar to the original but without the specified property
     * @see R.assoc
     * @example
     *
     *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
     */
    var dissoc = _curry2(function dissoc(prop, obj) {
        var result = {};
        for (var p in obj) {
            if (p !== prop) {
                result[p] = obj[p];
            }
        }
        return result;
    });

    /**
     * Makes a shallow clone of an object, omitting the property at the given path.
     * Note that this copies and flattens prototype properties onto the new object
     * as well. All non-primitive properties are copied by reference.
     *
     * @func
     * @memberOf R
     * @since v0.11.0
     * @category Object
     * @sig [String] -> {k: v} -> {k: v}
     * @param {Array} path the path to set
     * @param {Object} obj the object to clone
     * @return {Object} a new object without the property at path
     * @see R.assocPath
     * @example
     *
     *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
     */
    var dissocPath = _curry2(function dissocPath(path, obj) {
        switch (path.length) {
        case 0:
            return obj;
        case 1:
            return dissoc(path[0], obj);
        default:
            var head = path[0];
            var tail = _slice(path, 1);
            return obj[head] == null ? obj : assoc(head, dissocPath(tail, obj[head]), obj);
        }
    });

    /**
     * Divides two numbers. Equivalent to `a / b`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The first value.
     * @param {Number} b The second value.
     * @return {Number} The result of `a / b`.
     * @see R.multiply
     * @example
     *
     *      R.divide(71, 100); //=> 0.71
     *
     *      var half = R.divide(R.__, 2);
     *      half(42); //=> 21
     *
     *      var reciprocal = R.divide(1);
     *      reciprocal(4);   //=> 0.25
     */
    var divide = _curry2(function divide(a, b) {
        return a / b;
    });

    /**
     * Returns a new list containing the last `n` elements of a given list, passing
     * each value to the supplied predicate function, skipping elements while the
     * predicate function returns `true`. The predicate function is passed one
     * argument: *(value)*.
     *
     * Dispatches to the `dropWhile` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.takeWhile, R.transduce, R.addIndex
     * @example
     *
     *      var lteTwo = x => x <= 2;
     *
     *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
     */
    var dropWhile = _curry2(_dispatchable('dropWhile', _xdropWhile, function dropWhile(pred, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len && pred(list[idx])) {
            idx += 1;
        }
        return _slice(list, idx);
    }));

    /**
     * Returns the empty value of its argument's type. Ramda defines the empty
     * value of Array (`[]`), Object (`{}`), String (`''`), and Arguments. Other
     * types are supported if they define `<Type>.empty` and/or
     * `<Type>.prototype.empty`.
     *
     * Dispatches to the `empty` method of the first argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Function
     * @sig a -> a
     * @param {*} x
     * @return {*}
     * @example
     *
     *      R.empty(Just(42));      //=> Nothing()
     *      R.empty([1, 2, 3]);     //=> []
     *      R.empty('unicorns');    //=> ''
     *      R.empty({x: 1, y: 2});  //=> {}
     */
    // else
    var empty = _curry1(function empty(x) {
        return x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? '' : _isObject(x) ? {} : _isArguments(x) ? function () {
            return arguments;
        }() : // else
        void 0;
    });

    /**
     * Creates a new object by recursively evolving a shallow copy of `object`,
     * according to the `transformation` functions. All non-primitive properties
     * are copied by reference.
     *
     * A `transformation` function will not be invoked if its corresponding key
     * does not exist in the evolved object.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Object
     * @sig {k: (v -> v)} -> {k: v} -> {k: v}
     * @param {Object} transformations The object specifying transformation functions to apply
     *        to the object.
     * @param {Object} object The object to be transformed.
     * @return {Object} The transformed object.
     * @example
     *
     *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
     *      var transformations = {
     *        firstName: R.trim,
     *        lastName: R.trim, // Will not get invoked.
     *        data: {elapsed: R.add(1), remaining: R.add(-1)}
     *      };
     *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
     */
    var evolve = _curry2(function evolve(transformations, object) {
        var result = {};
        var transformation, key, type;
        for (key in object) {
            transformation = transformations[key];
            type = typeof transformation;
            result[key] = type === 'function' ? transformation(object[key]) : type === 'object' ? evolve(transformations[key], object[key]) : object[key];
        }
        return result;
    });

    /**
     * Returns the first element of the list which matches the predicate, or
     * `undefined` if no element matches.
     *
     * Dispatches to the `find` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> a | undefined
     * @param {Function} fn The predicate function used to determine if the element is the
     *        desired one.
     * @param {Array} list The array to consider.
     * @return {Object} The element found, or `undefined`.
     * @see R.transduce
     * @example
     *
     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
     *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
     *      R.find(R.propEq('a', 4))(xs); //=> undefined
     */
    var find = _curry2(_dispatchable('find', _xfind, function find(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            if (fn(list[idx])) {
                return list[idx];
            }
            idx += 1;
        }
    }));

    /**
     * Returns the index of the first element of the list which matches the
     * predicate, or `-1` if no element matches.
     *
     * Dispatches to the `findIndex` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> Boolean) -> [a] -> Number
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Number} The index of the element found, or `-1`.
     * @see R.transduce
     * @example
     *
     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
     *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
     *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
     */
    var findIndex = _curry2(_dispatchable('findIndex', _xfindIndex, function findIndex(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            if (fn(list[idx])) {
                return idx;
            }
            idx += 1;
        }
        return -1;
    }));

    /**
     * Returns the last element of the list which matches the predicate, or
     * `undefined` if no element matches.
     *
     * Dispatches to the `findLast` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> Boolean) -> [a] -> a | undefined
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Object} The element found, or `undefined`.
     * @see R.transduce
     * @example
     *
     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
     *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
     *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
     */
    var findLast = _curry2(_dispatchable('findLast', _xfindLast, function findLast(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
            if (fn(list[idx])) {
                return list[idx];
            }
            idx -= 1;
        }
    }));

    /**
     * Returns the index of the last element of the list which matches the
     * predicate, or `-1` if no element matches.
     *
     * Dispatches to the `findLastIndex` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> Boolean) -> [a] -> Number
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Number} The index of the element found, or `-1`.
     * @see R.transduce
     * @example
     *
     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
     *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
     *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
     */
    var findLastIndex = _curry2(_dispatchable('findLastIndex', _xfindLastIndex, function findLastIndex(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
            if (fn(list[idx])) {
                return idx;
            }
            idx -= 1;
        }
        return -1;
    }));

    /**
     * Iterate over an input `list`, calling a provided function `fn` for each
     * element in the list.
     *
     * `fn` receives one argument: *(value)*.
     *
     * Note: `R.forEach` does not skip deleted or unassigned indices (sparse
     * arrays), unlike the native `Array.prototype.forEach` method. For more
     * details on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
     *
     * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns
     * the original array. In some libraries this function is named `each`.
     *
     * Dispatches to the `forEach` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> *) -> [a] -> [a]
     * @param {Function} fn The function to invoke. Receives one argument, `value`.
     * @param {Array} list The list to iterate over.
     * @return {Array} The original list.
     * @see R.addIndex
     * @example
     *
     *      var printXPlusFive = x => console.log(x + 5);
     *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
     *      //-> 6
     *      //-> 7
     *      //-> 8
     */
    var forEach = _curry2(_checkForMethod('forEach', function forEach(fn, list) {
        var len = list.length;
        var idx = 0;
        while (idx < len) {
            fn(list[idx]);
            idx += 1;
        }
        return list;
    }));

    /**
     * Creates a new object out of a list key-value pairs.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig [[k,v]] -> {k: v}
     * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
     * @return {Object} The object made by pairing up `keys` and `values`.
     * @see R.toPairs, R.pair
     * @example
     *
     *      R.fromPairs([['a', 1], ['b', 2],  ['c', 3]]); //=> {a: 1, b: 2, c: 3}
     */
    var fromPairs = _curry1(function fromPairs(pairs) {
        var idx = 0;
        var len = pairs.length;
        var out = {};
        while (idx < len) {
            if (_isArray(pairs[idx]) && pairs[idx].length) {
                out[pairs[idx][0]] = pairs[idx][1];
            }
            idx += 1;
        }
        return out;
    });

    /**
     * Takes a list and returns a list of lists where each sublist's elements are
     * all "equal" according to the provided equality function.
     *
     * @func
     * @memberOf R
     * @since v0.21.0
     * @category List
     * @sig (a, a -> Boolean) -> [a] -> [[a]]
     * @param {Function} fn Function for determining whether two given (adjacent)
     *        elements should be in the same group
     * @param {Array} list The array to group. Also accepts a string, which will be
     *        treated as a list of characters.
     * @return {List} A list that contains sublists of equal elements,
     *         whose concatenations is equal to the original list.
     * @example
     *
     *    groupWith(R.equals, [0, 1, 1, 2, 3, 5, 8, 13, 21])
     *    // [[0], [1, 1], [2, 3, 5, 8, 13, 21]]
     *
     *    groupWith((a, b) => a % 2 === b % 2, [0, 1, 1, 2, 3, 5, 8, 13, 21])
     *    // [[0], [1, 1], [2], [3, 5], [8], [13, 21]]
     *
     *    R.groupWith(R.eqBy(isVowel), 'aestiou')
     *    // ['ae', 'st', 'iou']
     */
    var groupWith = _curry2(function (fn, list) {
        var res = [];
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            var nextidx = idx + 1;
            while (nextidx < len && fn(list[idx], list[nextidx])) {
                nextidx += 1;
            }
            res.push(list.slice(idx, nextidx));
            idx = nextidx;
        }
        return res;
    });

    /**
     * Returns `true` if the first argument is greater than the second; `false`
     * otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @see R.lt
     * @example
     *
     *      R.gt(2, 1); //=> true
     *      R.gt(2, 2); //=> false
     *      R.gt(2, 3); //=> false
     *      R.gt('a', 'z'); //=> false
     *      R.gt('z', 'a'); //=> true
     */
    var gt = _curry2(function gt(a, b) {
        return a > b;
    });

    /**
     * Returns `true` if the first argument is greater than or equal to the second;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {Number} a
     * @param {Number} b
     * @return {Boolean}
     * @see R.lte
     * @example
     *
     *      R.gte(2, 1); //=> true
     *      R.gte(2, 2); //=> true
     *      R.gte(2, 3); //=> false
     *      R.gte('a', 'z'); //=> false
     *      R.gte('z', 'a'); //=> true
     */
    var gte = _curry2(function gte(a, b) {
        return a >= b;
    });

    /**
     * Returns whether or not an object has an own property with the specified name
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Object
     * @sig s -> {s: x} -> Boolean
     * @param {String} prop The name of the property to check for.
     * @param {Object} obj The object to query.
     * @return {Boolean} Whether the property exists.
     * @example
     *
     *      var hasName = R.has('name');
     *      hasName({name: 'alice'});   //=> true
     *      hasName({name: 'bob'});     //=> true
     *      hasName({});                //=> false
     *
     *      var point = {x: 0, y: 0};
     *      var pointHas = R.has(R.__, point);
     *      pointHas('x');  //=> true
     *      pointHas('y');  //=> true
     *      pointHas('z');  //=> false
     */
    var has = _curry2(_has);

    /**
     * Returns whether or not an object or its prototype chain has a property with
     * the specified name
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Object
     * @sig s -> {s: x} -> Boolean
     * @param {String} prop The name of the property to check for.
     * @param {Object} obj The object to query.
     * @return {Boolean} Whether the property exists.
     * @example
     *
     *      function Rectangle(width, height) {
     *        this.width = width;
     *        this.height = height;
     *      }
     *      Rectangle.prototype.area = function() {
     *        return this.width * this.height;
     *      };
     *
     *      var square = new Rectangle(2, 2);
     *      R.hasIn('width', square);  //=> true
     *      R.hasIn('area', square);  //=> true
     */
    var hasIn = _curry2(function hasIn(prop, obj) {
        return prop in obj;
    });

    /**
     * Returns true if its arguments are identical, false otherwise. Values are
     * identical if they reference the same memory. `NaN` is identical to `NaN`;
     * `0` and `-0` are not identical.
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category Relation
     * @sig a -> a -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @example
     *
     *      var o = {};
     *      R.identical(o, o); //=> true
     *      R.identical(1, 1); //=> true
     *      R.identical(1, '1'); //=> false
     *      R.identical([], []); //=> false
     *      R.identical(0, -0); //=> false
     *      R.identical(NaN, NaN); //=> true
     */
    // SameValue algorithm
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Step 6.a: NaN == NaN
    var identical = _curry2(function identical(a, b) {
        // SameValue algorithm
        if (a === b) {
            // Steps 1-5, 7-10
            // Steps 6.b-6.e: +0 != -0
            return a !== 0 || 1 / a === 1 / b;
        } else {
            // Step 6.a: NaN == NaN
            return a !== a && b !== b;
        }
    });

    /**
     * A function that does nothing but return the parameter supplied to it. Good
     * as a default or placeholder function.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig a -> a
     * @param {*} x The value to return.
     * @return {*} The input value, `x`.
     * @example
     *
     *      R.identity(1); //=> 1
     *
     *      var obj = {};
     *      R.identity(obj) === obj; //=> true
     */
    var identity = _curry1(_identity);

    /**
     * Creates a function that will process either the `onTrue` or the `onFalse`
     * function depending upon the result of the `condition` predicate.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Logic
     * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
     * @param {Function} condition A predicate function
     * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
     * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
     * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`
     *                    function depending upon the result of the `condition` predicate.
     * @see R.unless, R.when
     * @example
     *
     *      var incCount = R.ifElse(
     *        R.has('count'),
     *        R.over(R.lensProp('count'), R.inc),
     *        R.assoc('count', 1)
     *      );
     *      incCount({});           //=> { count: 1 }
     *      incCount({ count: 1 }); //=> { count: 2 }
     */
    var ifElse = _curry3(function ifElse(condition, onTrue, onFalse) {
        return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
            return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
        });
    });

    /**
     * Increments its argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Math
     * @sig Number -> Number
     * @param {Number} n
     * @return {Number}
     * @see R.dec
     * @example
     *
     *      R.inc(42); //=> 43
     */
    var inc = add(1);

    /**
     * Inserts the supplied element into the list, at index `index`. _Note that
     * this is not destructive_: it returns a copy of the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @since v0.2.2
     * @category List
     * @sig Number -> a -> [a] -> [a]
     * @param {Number} index The position to insert the element
     * @param {*} elt The element to insert into the Array
     * @param {Array} list The list to insert into
     * @return {Array} A new Array with `elt` inserted at `index`.
     * @example
     *
     *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
     */
    var insert = _curry3(function insert(idx, elt, list) {
        idx = idx < list.length && idx >= 0 ? idx : list.length;
        var result = _slice(list);
        result.splice(idx, 0, elt);
        return result;
    });

    /**
     * Inserts the sub-list into the list, at index `index`. _Note that this is not
     * destructive_: it returns a copy of the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category List
     * @sig Number -> [a] -> [a] -> [a]
     * @param {Number} index The position to insert the sub-list
     * @param {Array} elts The sub-list to insert into the Array
     * @param {Array} list The list to insert the sub-list into
     * @return {Array} A new Array with `elts` inserted starting at `index`.
     * @example
     *
     *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
     */
    var insertAll = _curry3(function insertAll(idx, elts, list) {
        idx = idx < list.length && idx >= 0 ? idx : list.length;
        return _concat(_concat(_slice(list, 0, idx), elts), _slice(list, idx));
    });

    /**
     * Creates a new list with the separator interposed between elements.
     *
     * Dispatches to the `intersperse` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig a -> [a] -> [a]
     * @param {*} separator The element to add to the list.
     * @param {Array} list The list to be interposed.
     * @return {Array} The new list.
     * @example
     *
     *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']
     */
    var intersperse = _curry2(_checkForMethod('intersperse', function intersperse(separator, list) {
        var out = [];
        var idx = 0;
        var length = list.length;
        while (idx < length) {
            if (idx === length - 1) {
                out.push(list[idx]);
            } else {
                out.push(list[idx], separator);
            }
            idx += 1;
        }
        return out;
    }));

    /**
     * See if an object (`val`) is an instance of the supplied constructor. This
     * function will check up the inheritance chain, if any.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Type
     * @sig (* -> {*}) -> a -> Boolean
     * @param {Object} ctor A constructor
     * @param {*} val The value to test
     * @return {Boolean}
     * @example
     *
     *      R.is(Object, {}); //=> true
     *      R.is(Number, 1); //=> true
     *      R.is(Object, 1); //=> false
     *      R.is(String, 's'); //=> true
     *      R.is(String, new String('')); //=> true
     *      R.is(Object, new String('')); //=> true
     *      R.is(Object, 's'); //=> false
     *      R.is(Number, {}); //=> false
     */
    var is = _curry2(function is(Ctor, val) {
        return val != null && val.constructor === Ctor || val instanceof Ctor;
    });

    /**
     * Tests whether or not an object is similar to an array.
     *
     * @func
     * @memberOf R
     * @since v0.5.0
     * @category Type
     * @category List
     * @sig * -> Boolean
     * @param {*} x The object to test.
     * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
     * @example
     *
     *      R.isArrayLike([]); //=> true
     *      R.isArrayLike(true); //=> false
     *      R.isArrayLike({}); //=> false
     *      R.isArrayLike({length: 10}); //=> false
     *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
     */
    var isArrayLike = _curry1(function isArrayLike(x) {
        if (_isArray(x)) {
            return true;
        }
        if (!x) {
            return false;
        }
        if (typeof x !== 'object') {
            return false;
        }
        if (x instanceof String) {
            return false;
        }
        if (x.nodeType === 1) {
            return !!x.length;
        }
        if (x.length === 0) {
            return true;
        }
        if (x.length > 0) {
            return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
        }
        return false;
    });

    /**
     * Checks if the input value is `null` or `undefined`.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Type
     * @sig * -> Boolean
     * @param {*} x The value to test.
     * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
     * @example
     *
     *      R.isNil(null); //=> true
     *      R.isNil(undefined); //=> true
     *      R.isNil(0); //=> false
     *      R.isNil([]); //=> false
     */
    var isNil = _curry1(function isNil(x) {
        return x == null;
    });

    /**
     * Returns a list containing the names of all the enumerable own properties of
     * the supplied object.
     * Note that the order of the output array is not guaranteed to be consistent
     * across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {k: v} -> [k]
     * @param {Object} obj The object to extract properties from
     * @return {Array} An array of the object's own properties.
     * @example
     *
     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
     */
    // cover IE < 9 keys issues
    // Safari bug
    var keys = function () {
        // cover IE < 9 keys issues
        var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
        var nonEnumerableProps = [
            'constructor',
            'valueOf',
            'isPrototypeOf',
            'toString',
            'propertyIsEnumerable',
            'hasOwnProperty',
            'toLocaleString'
        ];
        // Safari bug
        var hasArgsEnumBug = function () {
            'use strict';
            return arguments.propertyIsEnumerable('length');
        }();
        var contains = function contains(list, item) {
            var idx = 0;
            while (idx < list.length) {
                if (list[idx] === item) {
                    return true;
                }
                idx += 1;
            }
            return false;
        };
        return typeof Object.keys === 'function' && !hasArgsEnumBug ? _curry1(function keys(obj) {
            return Object(obj) !== obj ? [] : Object.keys(obj);
        }) : _curry1(function keys(obj) {
            if (Object(obj) !== obj) {
                return [];
            }
            var prop, nIdx;
            var ks = [];
            var checkArgsLength = hasArgsEnumBug && _isArguments(obj);
            for (prop in obj) {
                if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
                    ks[ks.length] = prop;
                }
            }
            if (hasEnumBug) {
                nIdx = nonEnumerableProps.length - 1;
                while (nIdx >= 0) {
                    prop = nonEnumerableProps[nIdx];
                    if (_has(prop, obj) && !contains(ks, prop)) {
                        ks[ks.length] = prop;
                    }
                    nIdx -= 1;
                }
            }
            return ks;
        });
    }();

    /**
     * Returns a list containing the names of all the properties of the supplied
     * object, including prototype properties.
     * Note that the order of the output array is not guaranteed to be consistent
     * across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Object
     * @sig {k: v} -> [k]
     * @param {Object} obj The object to extract properties from
     * @return {Array} An array of the object's own and prototype properties.
     * @example
     *
     *      var F = function() { this.x = 'X'; };
     *      F.prototype.y = 'Y';
     *      var f = new F();
     *      R.keysIn(f); //=> ['x', 'y']
     */
    var keysIn = _curry1(function keysIn(obj) {
        var prop;
        var ks = [];
        for (prop in obj) {
            ks[ks.length] = prop;
        }
        return ks;
    });

    /**
     * Returns the number of elements in the array by returning `list.length`.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig [a] -> Number
     * @param {Array} list The array to inspect.
     * @return {Number} The length of the array.
     * @example
     *
     *      R.length([]); //=> 0
     *      R.length([1, 2, 3]); //=> 3
     */
    var length = _curry1(function length(list) {
        return list != null && is(Number, list.length) ? list.length : NaN;
    });

    /**
     * Returns `true` if the first argument is less than the second; `false`
     * otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @see R.gt
     * @example
     *
     *      R.lt(2, 1); //=> false
     *      R.lt(2, 2); //=> false
     *      R.lt(2, 3); //=> true
     *      R.lt('a', 'z'); //=> true
     *      R.lt('z', 'a'); //=> false
     */
    var lt = _curry2(function lt(a, b) {
        return a < b;
    });

    /**
     * Returns `true` if the first argument is less than or equal to the second;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {Number} a
     * @param {Number} b
     * @return {Boolean}
     * @see R.gte
     * @example
     *
     *      R.lte(2, 1); //=> false
     *      R.lte(2, 2); //=> true
     *      R.lte(2, 3); //=> true
     *      R.lte('a', 'z'); //=> true
     *      R.lte('z', 'a'); //=> false
     */
    var lte = _curry2(function lte(a, b) {
        return a <= b;
    });

    /**
     * The mapAccum function behaves like a combination of map and reduce; it
     * applies a function to each element of a list, passing an accumulating
     * parameter from left to right, and returning a final value of this
     * accumulator together with the new list.
     *
     * The iterator function receives two arguments, *acc* and *value*, and should
     * return a tuple *[acc, value]*.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
     * @param {Function} fn The function to be called on every element of the input `list`.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.addIndex
     * @example
     *
     *      var digits = ['1', '2', '3', '4'];
     *      var appender = (a, b) => [a + b, a + b];
     *
     *      R.mapAccum(appender, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
     */
    var mapAccum = _curry3(function mapAccum(fn, acc, list) {
        var idx = 0;
        var len = list.length;
        var result = [];
        var tuple = [acc];
        while (idx < len) {
            tuple = fn(tuple[0], list[idx]);
            result[idx] = tuple[1];
            idx += 1;
        }
        return [
            tuple[0],
            result
        ];
    });

    /**
     * The mapAccumRight function behaves like a combination of map and reduce; it
     * applies a function to each element of a list, passing an accumulating
     * parameter from right to left, and returning a final value of this
     * accumulator together with the new list.
     *
     * Similar to `mapAccum`, except moves through the input list from the right to
     * the left.
     *
     * The iterator function receives two arguments, *acc* and *value*, and should
     * return a tuple *[acc, value]*.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
     * @param {Function} fn The function to be called on every element of the input `list`.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.addIndex
     * @example
     *
     *      var digits = ['1', '2', '3', '4'];
     *      var append = (a, b) => [a + b, a + b];
     *
     *      R.mapAccumRight(append, 0, digits); //=> ['04321', ['04321', '0432', '043', '04']]
     */
    var mapAccumRight = _curry3(function mapAccumRight(fn, acc, list) {
        var idx = list.length - 1;
        var result = [];
        var tuple = [acc];
        while (idx >= 0) {
            tuple = fn(tuple[0], list[idx]);
            result[idx] = tuple[1];
            idx -= 1;
        }
        return [
            tuple[0],
            result
        ];
    });

    /**
     * Tests a regular expression against a String. Note that this function will
     * return an empty array when there are no matches. This differs from
     * [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
     * which returns `null` when there are no matches.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category String
     * @sig RegExp -> String -> [String | Undefined]
     * @param {RegExp} rx A regular expression.
     * @param {String} str The string to match against
     * @return {Array} The list of matches or empty array.
     * @see R.test
     * @example
     *
     *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
     *      R.match(/a/, 'b'); //=> []
     *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
     */
    var match = _curry2(function match(rx, str) {
        return str.match(rx) || [];
    });

    /**
     * mathMod behaves like the modulo operator should mathematically, unlike the
     * `%` operator (and by extension, R.modulo). So while "-17 % 5" is -2,
     * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN
     * when the modulus is zero or negative.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} m The dividend.
     * @param {Number} p the modulus.
     * @return {Number} The result of `b mod a`.
     * @example
     *
     *      R.mathMod(-17, 5);  //=> 3
     *      R.mathMod(17, 5);   //=> 2
     *      R.mathMod(17, -5);  //=> NaN
     *      R.mathMod(17, 0);   //=> NaN
     *      R.mathMod(17.2, 5); //=> NaN
     *      R.mathMod(17, 5.3); //=> NaN
     *
     *      var clock = R.mathMod(R.__, 12);
     *      clock(15); //=> 3
     *      clock(24); //=> 0
     *
     *      var seventeenMod = R.mathMod(17);
     *      seventeenMod(3);  //=> 2
     *      seventeenMod(4);  //=> 1
     *      seventeenMod(10); //=> 7
     */
    var mathMod = _curry2(function mathMod(m, p) {
        if (!_isInteger(m)) {
            return NaN;
        }
        if (!_isInteger(p) || p < 1) {
            return NaN;
        }
        return (m % p + p) % p;
    });

    /**
     * Returns the larger of its two arguments.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> a
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.maxBy, R.min
     * @example
     *
     *      R.max(789, 123); //=> 789
     *      R.max('a', 'b'); //=> 'b'
     */
    var max = _curry2(function max(a, b) {
        return b > a ? b : a;
    });

    /**
     * Takes a function and two values, and returns whichever value produces the
     * larger result when passed to the provided function.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Relation
     * @sig Ord b => (a -> b) -> a -> a -> a
     * @param {Function} f
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.max, R.minBy
     * @example
     *
     *      //  square :: Number -> Number
     *      var square = n => n * n;
     *
     *      R.maxBy(square, -3, 2); //=> -3
     *
     *      R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); //=> -5
     *      R.reduce(R.maxBy(square), 0, []); //=> 0
     */
    var maxBy = _curry3(function maxBy(f, a, b) {
        return f(b) > f(a) ? b : a;
    });

    /**
     * Create a new object with the own properties of the first object merged with
     * the own properties of the second object. If a key exists in both objects,
     * the value from the second object will be used.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {k: v} -> {k: v} -> {k: v}
     * @param {Object} l
     * @param {Object} r
     * @return {Object}
     * @see R.mergeWith, R.mergeWithKey
     * @example
     *
     *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
     *      //=> { 'name': 'fred', 'age': 40 }
     *
     *      var resetToDefault = R.merge(R.__, {x: 0});
     *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
     */
    var merge = _curry2(function merge(l, r) {
        return _assign({}, l, r);
    });

    /**
     * Merges a list of objects together into one object.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig [{k: v}] -> {k: v}
     * @param {Array} list An array of objects
     * @return {Object} A merged object.
     * @see R.reduce
     * @example
     *
     *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
     *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
     */
    var mergeAll = _curry1(function mergeAll(list) {
        return _assign.apply(null, [{}].concat(list));
    });

    /**
     * Creates a new object with the own properties of the two provided objects. If
     * a key exists in both objects, the provided function is applied to the key
     * and the values associated with the key in each object, with the result being
     * used as the value associated with the key in the returned object. The key
     * will be excluded from the returned object if the resulting value is
     * `undefined`.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Object
     * @sig (String -> a -> a -> a) -> {a} -> {a} -> {a}
     * @param {Function} fn
     * @param {Object} l
     * @param {Object} r
     * @return {Object}
     * @see R.merge, R.mergeWith
     * @example
     *
     *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
     *      R.mergeWithKey(concatValues,
     *                     { a: true, thing: 'foo', values: [10, 20] },
     *                     { b: true, thing: 'bar', values: [15, 35] });
     *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }
     */
    var mergeWithKey = _curry3(function mergeWithKey(fn, l, r) {
        var result = {};
        var k;
        for (k in l) {
            if (_has(k, l)) {
                result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
            }
        }
        for (k in r) {
            if (_has(k, r) && !_has(k, result)) {
                result[k] = r[k];
            }
        }
        return result;
    });

    /**
     * Returns the smaller of its two arguments.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> a
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.minBy, R.max
     * @example
     *
     *      R.min(789, 123); //=> 123
     *      R.min('a', 'b'); //=> 'a'
     */
    var min = _curry2(function min(a, b) {
        return b < a ? b : a;
    });

    /**
     * Takes a function and two values, and returns whichever value produces the
     * smaller result when passed to the provided function.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Relation
     * @sig Ord b => (a -> b) -> a -> a -> a
     * @param {Function} f
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.min, R.maxBy
     * @example
     *
     *      //  square :: Number -> Number
     *      var square = n => n * n;
     *
     *      R.minBy(square, -3, 2); //=> 2
     *
     *      R.reduce(R.minBy(square), Infinity, [3, -5, 4, 1, -2]); //=> 1
     *      R.reduce(R.minBy(square), Infinity, []); //=> Infinity
     */
    var minBy = _curry3(function minBy(f, a, b) {
        return f(b) < f(a) ? b : a;
    });

    /**
     * Divides the second parameter by the first and returns the remainder. Note
     * that this function preserves the JavaScript-style behavior for modulo. For
     * mathematical modulo see `mathMod`.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The value to the divide.
     * @param {Number} b The pseudo-modulus
     * @return {Number} The result of `b % a`.
     * @see R.mathMod
     * @example
     *
     *      R.modulo(17, 3); //=> 2
     *      // JS behavior:
     *      R.modulo(-17, 3); //=> -2
     *      R.modulo(17, -3); //=> 2
     *
     *      var isOdd = R.modulo(R.__, 2);
     *      isOdd(42); //=> 0
     *      isOdd(21); //=> 1
     */
    var modulo = _curry2(function modulo(a, b) {
        return a % b;
    });

    /**
     * Multiplies two numbers. Equivalent to `a * b` but curried.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The first value.
     * @param {Number} b The second value.
     * @return {Number} The result of `a * b`.
     * @see R.divide
     * @example
     *
     *      var double = R.multiply(2);
     *      var triple = R.multiply(3);
     *      double(3);       //=>  6
     *      triple(4);       //=> 12
     *      R.multiply(2, 5);  //=> 10
     */
    var multiply = _curry2(function multiply(a, b) {
        return a * b;
    });

    /**
     * Wraps a function of any arity (including nullary) in a function that accepts
     * exactly `n` parameters. Any extraneous parameters will not be passed to the
     * supplied function.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig Number -> (* -> a) -> (* -> a)
     * @param {Number} n The desired arity of the new function.
     * @param {Function} fn The function to wrap.
     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
     *         arity `n`.
     * @example
     *
     *      var takesTwoArgs = (a, b) => [a, b];
     *
     *      takesTwoArgs.length; //=> 2
     *      takesTwoArgs(1, 2); //=> [1, 2]
     *
     *      var takesOneArg = R.nAry(1, takesTwoArgs);
     *      takesOneArg.length; //=> 1
     *      // Only `n` arguments are passed to the wrapped function
     *      takesOneArg(1, 2); //=> [1, undefined]
     */
    var nAry = _curry2(function nAry(n, fn) {
        switch (n) {
        case 0:
            return function () {
                return fn.call(this);
            };
        case 1:
            return function (a0) {
                return fn.call(this, a0);
            };
        case 2:
            return function (a0, a1) {
                return fn.call(this, a0, a1);
            };
        case 3:
            return function (a0, a1, a2) {
                return fn.call(this, a0, a1, a2);
            };
        case 4:
            return function (a0, a1, a2, a3) {
                return fn.call(this, a0, a1, a2, a3);
            };
        case 5:
            return function (a0, a1, a2, a3, a4) {
                return fn.call(this, a0, a1, a2, a3, a4);
            };
        case 6:
            return function (a0, a1, a2, a3, a4, a5) {
                return fn.call(this, a0, a1, a2, a3, a4, a5);
            };
        case 7:
            return function (a0, a1, a2, a3, a4, a5, a6) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
            };
        case 8:
            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
            };
        case 9:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
            };
        case 10:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            };
        default:
            throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
        }
    });

    /**
     * Negates its argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Math
     * @sig Number -> Number
     * @param {Number} n
     * @return {Number}
     * @example
     *
     *      R.negate(42); //=> -42
     */
    var negate = _curry1(function negate(n) {
        return -n;
    });

    /**
     * Returns `true` if no elements of the list match the predicate, `false`
     * otherwise.
     *
     * Dispatches to the `any` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> Boolean
     * @param {Function} fn The predicate function.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
     * @see R.all, R.any
     * @example
     *
     *      var isEven = n => n % 2 === 0;
     *
     *      R.none(isEven, [1, 3, 5, 7, 9, 11]); //=> true
     *      R.none(isEven, [1, 3, 5, 7, 8, 11]); //=> false
     */
    var none = _curry2(_complement(_dispatchable('any', _xany, any)));

    /**
     * A function that returns the `!` of its argument. It will return `true` when
     * passed false-y value, and `false` when passed a truth-y one.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Logic
     * @sig * -> Boolean
     * @param {*} a any value
     * @return {Boolean} the logical inverse of passed argument.
     * @see R.complement
     * @example
     *
     *      R.not(true); //=> false
     *      R.not(false); //=> true
     *      R.not(0); => true
     *      R.not(1); => false
     */
    var not = _curry1(function not(a) {
        return !a;
    });

    /**
     * Returns the nth element of the given list or string. If n is negative the
     * element at index length + n is returned.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Number -> [a] -> a | Undefined
     * @sig Number -> String -> String
     * @param {Number} offset
     * @param {*} list
     * @return {*}
     * @example
     *
     *      var list = ['foo', 'bar', 'baz', 'quux'];
     *      R.nth(1, list); //=> 'bar'
     *      R.nth(-1, list); //=> 'quux'
     *      R.nth(-99, list); //=> undefined
     *
     *      R.nth(2, 'abc'); //=> 'c'
     *      R.nth(3, 'abc'); //=> ''
     */
    var nth = _curry2(function nth(offset, list) {
        var idx = offset < 0 ? list.length + offset : offset;
        return _isString(list) ? list.charAt(idx) : list[idx];
    });

    /**
     * Returns a function which returns its nth argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Function
     * @sig Number -> *... -> *
     * @param {Number} n
     * @return {Function}
     * @example
     *
     *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
     *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
     */
    var nthArg = _curry1(function nthArg(n) {
        return function () {
            return nth(n, arguments);
        };
    });

    /**
     * Creates an object containing a single key:value pair.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Object
     * @sig String -> a -> {String:a}
     * @param {String} key
     * @param {*} val
     * @return {Object}
     * @see R.pair
     * @example
     *
     *      var matchPhrases = R.compose(
     *        R.objOf('must'),
     *        R.map(R.objOf('match_phrase'))
     *      );
     *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
     */
    var objOf = _curry2(function objOf(key, val) {
        var obj = {};
        obj[key] = val;
        return obj;
    });

    /**
     * Returns a singleton array containing the value provided.
     *
     * Note this `of` is different from the ES6 `of`; See
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Function
     * @sig a -> [a]
     * @param {*} x any value
     * @return {Array} An array wrapping `x`.
     * @example
     *
     *      R.of(null); //=> [null]
     *      R.of([42]); //=> [[42]]
     */
    var of = _curry1(_of);

    /**
     * Accepts a function `fn` and returns a function that guards invocation of
     * `fn` such that `fn` can only ever be called once, no matter how many times
     * the returned function is invoked. The first value calculated is returned in
     * subsequent invocations.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a... -> b) -> (a... -> b)
     * @param {Function} fn The function to wrap in a call-only-once wrapper.
     * @return {Function} The wrapped function.
     * @example
     *
     *      var addOneOnce = R.once(x => x + 1);
     *      addOneOnce(10); //=> 11
     *      addOneOnce(addOneOnce(50)); //=> 11
     */
    var once = _curry1(function once(fn) {
        var called = false;
        var result;
        return _arity(fn.length, function () {
            if (called) {
                return result;
            }
            called = true;
            result = fn.apply(this, arguments);
            return result;
        });
    });

    /**
     * Returns `true` if one or both of its arguments are `true`. Returns `false`
     * if both arguments are `false`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Logic
     * @sig * -> * -> *
     * @param {Boolean} a A boolean value
     * @param {Boolean} b A boolean value
     * @return {Boolean} `true` if one or both arguments are `true`, `false` otherwise
     * @see R.either
     * @example
     *
     *      R.or(true, true); //=> true
     *      R.or(true, false); //=> true
     *      R.or(false, true); //=> true
     *      R.or(false, false); //=> false
     */
    var or = _curry2(function or(a, b) {
        return a || b;
    });

    /**
     * Returns the result of "setting" the portion of the given data structure
     * focused by the given lens to the result of applying the given function to
     * the focused value.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Lens s a -> (a -> a) -> s -> s
     * @param {Lens} lens
     * @param {*} v
     * @param {*} x
     * @return {*}
     * @see R.prop, R.lensIndex, R.lensProp
     * @example
     *
     *      var headLens = R.lensIndex(0);
     *
     *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
     */
    // `Identity` is a functor that holds a single value, where `map` simply
    // transforms the held value with the provided function.
    // The value returned by the getter function is first transformed with `f`,
    // then set as the value of an `Identity`. This is then mapped over with the
    // setter function of the lens.
    var over = function () {
        // `Identity` is a functor that holds a single value, where `map` simply
        // transforms the held value with the provided function.
        var Identity = function (x) {
            return {
                value: x,
                map: function (f) {
                    return Identity(f(x));
                }
            };
        };
        return _curry3(function over(lens, f, x) {
            // The value returned by the getter function is first transformed with `f`,
            // then set as the value of an `Identity`. This is then mapped over with the
            // setter function of the lens.
            return lens(function (y) {
                return Identity(f(y));
            })(x).value;
        });
    }();

    /**
     * Takes two arguments, `fst` and `snd`, and returns `[fst, snd]`.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category List
     * @sig a -> b -> (a,b)
     * @param {*} fst
     * @param {*} snd
     * @return {Array}
     * @see R.objOf, R.of
     * @example
     *
     *      R.pair('foo', 'bar'); //=> ['foo', 'bar']
     */
    var pair = _curry2(function pair(fst, snd) {
        return [
            fst,
            snd
        ];
    });

    /**
     * Retrieve the value at a given path.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Object
     * @sig [String] -> {k: v} -> v | Undefined
     * @param {Array} path The path to use.
     * @param {Object} obj The object to retrieve the nested property from.
     * @return {*} The data at `path`.
     * @example
     *
     *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
     *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
     */
    var path = _curry2(function path(paths, obj) {
        var val = obj;
        var idx = 0;
        while (idx < paths.length) {
            if (val == null) {
                return;
            }
            val = val[paths[idx]];
            idx += 1;
        }
        return val;
    });

    /**
     * If the given, non-null object has a value at the given path, returns the
     * value at that path. Otherwise returns the provided default value.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Object
     * @sig a -> [String] -> Object -> a
     * @param {*} d The default value.
     * @param {Array} p The path to use.
     * @param {Object} obj The object to retrieve the nested property from.
     * @return {*} The data at `path` of the supplied object or the default value.
     * @example
     *
     *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2
     *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> "N/A"
     */
    var pathOr = _curry3(function pathOr(d, p, obj) {
        return defaultTo(d, path(p, obj));
    });

    /**
     * Returns `true` if the specified object property at given path satisfies the
     * given predicate; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Logic
     * @sig (a -> Boolean) -> [String] -> Object -> Boolean
     * @param {Function} pred
     * @param {Array} propPath
     * @param {*} obj
     * @return {Boolean}
     * @see R.propSatisfies, R.path
     * @example
     *
     *      R.pathSatisfies(y => y > 0, ['x', 'y'], {x: {y: 2}}); //=> true
     */
    var pathSatisfies = _curry3(function pathSatisfies(pred, propPath, obj) {
        return propPath.length > 0 && pred(path(propPath, obj));
    });

    /**
     * Returns a partial copy of an object containing only the keys specified. If
     * the key does not exist, the property is ignored.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [k] -> {k: v} -> {k: v}
     * @param {Array} names an array of String property names to copy onto a new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with only properties from `names` on it.
     * @see R.omit, R.props
     * @example
     *
     *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
     *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
     */
    var pick = _curry2(function pick(names, obj) {
        var result = {};
        var idx = 0;
        while (idx < names.length) {
            if (names[idx] in obj) {
                result[names[idx]] = obj[names[idx]];
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Similar to `pick` except that this one includes a `key: undefined` pair for
     * properties that don't exist.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [k] -> {k: v} -> {k: v}
     * @param {Array} names an array of String property names to copy onto a new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with only properties from `names` on it.
     * @see R.pick
     * @example
     *
     *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
     *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
     */
    var pickAll = _curry2(function pickAll(names, obj) {
        var result = {};
        var idx = 0;
        var len = names.length;
        while (idx < len) {
            var name = names[idx];
            result[name] = obj[name];
            idx += 1;
        }
        return result;
    });

    /**
     * Returns a partial copy of an object containing only the keys that satisfy
     * the supplied predicate.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @sig (v, k -> Boolean) -> {k: v} -> {k: v}
     * @param {Function} pred A predicate to determine whether or not a key
     *        should be included on the output object.
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with only properties that satisfy `pred`
     *         on it.
     * @see R.pick, R.filter
     * @example
     *
     *      var isUpperCase = (val, key) => key.toUpperCase() === key;
     *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
     */
    var pickBy = _curry2(function pickBy(test, obj) {
        var result = {};
        for (var prop in obj) {
            if (test(obj[prop], prop, obj)) {
                result[prop] = obj[prop];
            }
        }
        return result;
    });

    /**
     * Returns a new list with the given element at the front, followed by the
     * contents of the list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> [a]
     * @param {*} el The item to add to the head of the output list.
     * @param {Array} list The array to add to the tail of the output list.
     * @return {Array} A new array.
     * @see R.append
     * @example
     *
     *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
     */
    var prepend = _curry2(function prepend(el, list) {
        return _concat([el], list);
    });

    /**
     * Returns a function that when supplied an object returns the indicated
     * property of that object, if it exists.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig s -> {s: a} -> a | Undefined
     * @param {String} p The property name
     * @param {Object} obj The object to query
     * @return {*} The value at `obj.p`.
     * @example
     *
     *      R.prop('x', {x: 100}); //=> 100
     *      R.prop('x', {}); //=> undefined
     */
    var prop = _curry2(function prop(p, obj) {
        return obj[p];
    });

    /**
     * If the given, non-null object has an own property with the specified name,
     * returns the value of that property. Otherwise returns the provided default
     * value.
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category Object
     * @sig a -> String -> Object -> a
     * @param {*} val The default value.
     * @param {String} p The name of the property to return.
     * @param {Object} obj The object to query.
     * @return {*} The value of given property of the supplied object or the default value.
     * @example
     *
     *      var alice = {
     *        name: 'ALICE',
     *        age: 101
     *      };
     *      var favorite = R.prop('favoriteLibrary');
     *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
     *
     *      favorite(alice);  //=> undefined
     *      favoriteWithDefault(alice);  //=> 'Ramda'
     */
    var propOr = _curry3(function propOr(val, p, obj) {
        return obj != null && _has(p, obj) ? obj[p] : val;
    });

    /**
     * Returns `true` if the specified object property satisfies the given
     * predicate; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Logic
     * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
     * @param {Function} pred
     * @param {String} name
     * @param {*} obj
     * @return {Boolean}
     * @see R.propEq, R.propIs
     * @example
     *
     *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
     */
    var propSatisfies = _curry3(function propSatisfies(pred, name, obj) {
        return pred(obj[name]);
    });

    /**
     * Acts as multiple `prop`: array of keys in, array of values out. Preserves
     * order.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [k] -> {k: v} -> [v]
     * @param {Array} ps The property names to fetch
     * @param {Object} obj The object to query
     * @return {Array} The corresponding values or partially applied function.
     * @example
     *
     *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
     *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
     *
     *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));
     *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
     */
    var props = _curry2(function props(ps, obj) {
        var len = ps.length;
        var out = [];
        var idx = 0;
        while (idx < len) {
            out[idx] = obj[ps[idx]];
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Number -> Number -> [Number]
     * @param {Number} from The first number in the list.
     * @param {Number} to One more than the last number in the list.
     * @return {Array} The list of numbers in tthe set `[a, b)`.
     * @example
     *
     *      R.range(1, 5);    //=> [1, 2, 3, 4]
     *      R.range(50, 53);  //=> [50, 51, 52]
     */
    var range = _curry2(function range(from, to) {
        if (!(_isNumber(from) && _isNumber(to))) {
            throw new TypeError('Both arguments to range must be numbers');
        }
        var result = [];
        var n = from;
        while (n < to) {
            result.push(n);
            n += 1;
        }
        return result;
    });

    /**
     * Returns a single item by iterating through the list, successively calling
     * the iterator function and passing it an accumulator value and the current
     * value from the array, and then passing the result to the next call.
     *
     * Similar to `reduce`, except moves through the input list from the right to
     * the left.
     *
     * The iterator function receives two values: *(acc, value)*
     *
     * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse
     * arrays), unlike the native `Array.prototype.reduce` method. For more details
     * on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a,b -> a) -> a -> [b] -> a
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.addIndex
     * @example
     *
     *      var pairs = [ ['a', 1], ['b', 2], ['c', 3] ];
     *      var flattenPairs = (acc, pair) => acc.concat(pair);
     *
     *      R.reduceRight(flattenPairs, [], pairs); //=> [ 'c', 3, 'b', 2, 'a', 1 ]
     */
    var reduceRight = _curry3(function reduceRight(fn, acc, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
            acc = fn(acc, list[idx]);
            idx -= 1;
        }
        return acc;
    });

    /**
     * Returns a value wrapped to indicate that it is the final value of the reduce
     * and transduce functions. The returned value should be considered a black
     * box: the internal structure is not guaranteed to be stable.
     *
     * Note: this optimization is unavailable to functions not explicitly listed
     * above. For instance, it is not currently supported by reduceRight.
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category List
     * @sig a -> *
     * @param {*} x The final value of the reduce.
     * @return {*} The wrapped value.
     * @see R.reduce, R.transduce
     * @example
     *
     *      R.reduce(
     *        R.pipe(R.add, R.when(R.gte(R.__, 10), R.reduced)),
     *        0,
     *        [1, 2, 3, 4, 5]) // 10
     */
    var reduced = _curry1(_reduced);

    /**
     * Removes the sub-list of `list` starting at index `start` and containing
     * `count` elements. _Note that this is not destructive_: it returns a copy of
     * the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @since v0.2.2
     * @category List
     * @sig Number -> Number -> [a] -> [a]
     * @param {Number} start The position to start removing elements
     * @param {Number} count The number of elements to remove
     * @param {Array} list The list to remove from
     * @return {Array} A new Array with `count` elements from `start` removed.
     * @example
     *
     *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
     */
    var remove = _curry3(function remove(start, count, list) {
        return _concat(_slice(list, 0, Math.min(start, list.length)), _slice(list, Math.min(list.length, start + count)));
    });

    /**
     * Replace a substring or regex match in a string with a replacement.
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category String
     * @sig RegExp|String -> String -> String -> String
     * @param {RegExp|String} pattern A regular expression or a substring to match.
     * @param {String} replacement The string to replace the matches with.
     * @param {String} str The String to do the search and replacement in.
     * @return {String} The result.
     * @example
     *
     *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
     *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
     *
     *      // Use the "g" (global) flag to replace all occurrences:
     *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
     */
    var replace = _curry3(function replace(regex, replacement, str) {
        return str.replace(regex, replacement);
    });

    /**
     * Returns a new list or string with the elements or characters in reverse
     * order.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a]
     * @sig String -> String
     * @param {Array|String} list
     * @return {Array|String}
     * @example
     *
     *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
     *      R.reverse([1, 2]);     //=> [2, 1]
     *      R.reverse([1]);        //=> [1]
     *      R.reverse([]);         //=> []
     *
     *      R.reverse('abc');      //=> 'cba'
     *      R.reverse('ab');       //=> 'ba'
     *      R.reverse('a');        //=> 'a'
     *      R.reverse('');         //=> ''
     */
    var reverse = _curry1(function reverse(list) {
        return _isString(list) ? list.split('').reverse().join('') : _slice(list).reverse();
    });

    /**
     * Scan is similar to reduce, but returns a list of successively reduced values
     * from the left
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig (a,b -> a) -> a -> [b] -> [a]
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {Array} A list of all intermediately reduced values.
     * @example
     *
     *      var numbers = [1, 2, 3, 4];
     *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
     */
    var scan = _curry3(function scan(fn, acc, list) {
        var idx = 0;
        var len = list.length;
        var result = [acc];
        while (idx < len) {
            acc = fn(acc, list[idx]);
            result[idx + 1] = acc;
            idx += 1;
        }
        return result;
    });

    /**
     * Returns the result of "setting" the portion of the given data structure
     * focused by the given lens to the given value.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Lens s a -> a -> s -> s
     * @param {Lens} lens
     * @param {*} v
     * @param {*} x
     * @return {*}
     * @see R.prop, R.lensIndex, R.lensProp
     * @example
     *
     *      var xLens = R.lensProp('x');
     *
     *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
     *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
     */
    var set = _curry3(function set(lens, v, x) {
        return over(lens, always(v), x);
    });

    /**
     * Returns the elements of the given list or string (or object with a `slice`
     * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
     *
     * Dispatches to the `slice` method of the third argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.4
     * @category List
     * @sig Number -> Number -> [a] -> [a]
     * @sig Number -> Number -> String -> String
     * @param {Number} fromIndex The start index (inclusive).
     * @param {Number} toIndex The end index (exclusive).
     * @param {*} list
     * @return {*}
     * @example
     *
     *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
     *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
     *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
     *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
     *      R.slice(0, 3, 'ramda');                     //=> 'ram'
     */
    var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
        return Array.prototype.slice.call(list, fromIndex, toIndex);
    }));

    /**
     * Returns a copy of the list, sorted according to the comparator function,
     * which should accept two values at a time and return a negative number if the
     * first value is smaller, a positive number if it's larger, and zero if they
     * are equal. Please note that this is a **copy** of the list. It does not
     * modify the original.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a,a -> Number) -> [a] -> [a]
     * @param {Function} comparator A sorting function :: a -> b -> Int
     * @param {Array} list The list to sort
     * @return {Array} a new array with its elements sorted by the comparator function.
     * @example
     *
     *      var diff = function(a, b) { return a - b; };
     *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
     */
    var sort = _curry2(function sort(comparator, list) {
        return _slice(list).sort(comparator);
    });

    /**
     * Sorts the list according to the supplied function.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord b => (a -> b) -> [a] -> [a]
     * @param {Function} fn
     * @param {Array} list The list to sort.
     * @return {Array} A new list sorted by the keys generated by `fn`.
     * @example
     *
     *      var sortByFirstItem = R.sortBy(R.prop(0));
     *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
     *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];
     *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
     *      var alice = {
     *        name: 'ALICE',
     *        age: 101
     *      };
     *      var bob = {
     *        name: 'Bob',
     *        age: -10
     *      };
     *      var clara = {
     *        name: 'clara',
     *        age: 314.159
     *      };
     *      var people = [clara, bob, alice];
     *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
     */
    var sortBy = _curry2(function sortBy(fn, list) {
        return _slice(list).sort(function (a, b) {
            var aa = fn(a);
            var bb = fn(b);
            return aa < bb ? -1 : aa > bb ? 1 : 0;
        });
    });

    /**
     * Splits a given list or string at a given index.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig Number -> [a] -> [[a], [a]]
     * @sig Number -> String -> [String, String]
     * @param {Number} index The index where the array/string is split.
     * @param {Array|String} array The array/string to be split.
     * @return {Array}
     * @example
     *
     *      R.splitAt(1, [1, 2, 3]);          //=> [[1], [2, 3]]
     *      R.splitAt(5, 'hello world');      //=> ['hello', ' world']
     *      R.splitAt(-1, 'foobar');          //=> ['fooba', 'r']
     */
    var splitAt = _curry2(function splitAt(index, array) {
        return [
            slice(0, index, array),
            slice(index, length(array), array)
        ];
    });

    /**
     * Splits a collection into slices of the specified length.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig Number -> [a] -> [[a]]
     * @sig Number -> String -> [String]
     * @param {Number} n
     * @param {Array} list
     * @return {Array}
     * @example
     *
     *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
     *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
     */
    var splitEvery = _curry2(function splitEvery(n, list) {
        if (n <= 0) {
            throw new Error('First argument to splitEvery must be a positive integer');
        }
        var result = [];
        var idx = 0;
        while (idx < list.length) {
            result.push(slice(idx, idx += n, list));
        }
        return result;
    });

    /**
     * Takes a list and a predicate and returns a pair of lists with the following properties:
     *
     *  - the result of concatenating the two output lists is equivalent to the input list;
     *  - none of the elements of the first output list satisfies the predicate; and
     *  - if the second output list is non-empty, its first element satisfies the predicate.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [[a], [a]]
     * @param {Function} pred The predicate that determines where the array is split.
     * @param {Array} list The array to be split.
     * @return {Array}
     * @example
     *
     *      R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=> [[1], [2, 3, 1, 2, 3]]
     */
    var splitWhen = _curry2(function splitWhen(pred, list) {
        var idx = 0;
        var len = list.length;
        var prefix = [];
        while (idx < len && !pred(list[idx])) {
            prefix.push(list[idx]);
            idx += 1;
        }
        return [
            prefix,
            _slice(list, idx)
        ];
    });

    /**
     * Subtracts its second argument from its first argument.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The first value.
     * @param {Number} b The second value.
     * @return {Number} The result of `a - b`.
     * @see R.add
     * @example
     *
     *      R.subtract(10, 8); //=> 2
     *
     *      var minus5 = R.subtract(R.__, 5);
     *      minus5(17); //=> 12
     *
     *      var complementaryAngle = R.subtract(90);
     *      complementaryAngle(30); //=> 60
     *      complementaryAngle(72); //=> 18
     */
    var subtract = _curry2(function subtract(a, b) {
        return Number(a) - Number(b);
    });

    /**
     * Returns all but the first element of the given list or string (or object
     * with a `tail` method).
     *
     * Dispatches to the `slice` method of the first argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a]
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @see R.head, R.init, R.last
     * @example
     *
     *      R.tail([1, 2, 3]);  //=> [2, 3]
     *      R.tail([1, 2]);     //=> [2]
     *      R.tail([1]);        //=> []
     *      R.tail([]);         //=> []
     *
     *      R.tail('abc');  //=> 'bc'
     *      R.tail('ab');   //=> 'b'
     *      R.tail('a');    //=> ''
     *      R.tail('');     //=> ''
     */
    var tail = _checkForMethod('tail', slice(1, Infinity));

    /**
     * Returns the first `n` elements of the given list, string, or
     * transducer/transformer (or object with a `take` method).
     *
     * Dispatches to the `take` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n
     * @param {*} list
     * @return {*}
     * @see R.drop
     * @example
     *
     *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
     *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
     *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.take(3, 'ramda');               //=> 'ram'
     *
     *      var personnel = [
     *        'Dave Brubeck',
     *        'Paul Desmond',
     *        'Eugene Wright',
     *        'Joe Morello',
     *        'Gerry Mulligan',
     *        'Bob Bates',
     *        'Joe Dodge',
     *        'Ron Crotty'
     *      ];
     *
     *      var takeFive = R.take(5);
     *      takeFive(personnel);
     *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
     */
    var take = _curry2(_dispatchable('take', _xtake, function take(n, xs) {
        return slice(0, n < 0 ? Infinity : n, xs);
    }));

    /**
     * Returns a new list containing the last `n` elements of a given list, passing
     * each value to the supplied predicate function, and terminating when the
     * predicate function returns `false`. Excludes the element that caused the
     * predicate function to fail. The predicate function is passed one argument:
     * *(value)*.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.dropLastWhile, R.addIndex
     * @example
     *
     *      var isNotOne = x => x !== 1;
     *
     *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
     */
    var takeLastWhile = _curry2(function takeLastWhile(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0 && fn(list[idx])) {
            idx -= 1;
        }
        return _slice(list, idx + 1, Infinity);
    });

    /**
     * Returns a new list containing the first `n` elements of a given list,
     * passing each value to the supplied predicate function, and terminating when
     * the predicate function returns `false`. Excludes the element that caused the
     * predicate function to fail. The predicate function is passed one argument:
     * *(value)*.
     *
     * Dispatches to the `takeWhile` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.dropWhile, R.transduce, R.addIndex
     * @example
     *
     *      var isNotFour = x => x !== 4;
     *
     *      R.takeWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3]
     */
    var takeWhile = _curry2(_dispatchable('takeWhile', _xtakeWhile, function takeWhile(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len && fn(list[idx])) {
            idx += 1;
        }
        return _slice(list, 0, idx);
    }));

    /**
     * Runs the given function with the supplied object, then returns the object.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a -> *) -> a -> a
     * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
     * @param {*} x
     * @return {*} `x`.
     * @example
     *
     *      var sayX = x => console.log('x is ' + x);
     *      R.tap(sayX, 100); //=> 100
     *      //-> 'x is 100'
     */
    var tap = _curry2(function tap(fn, x) {
        fn(x);
        return x;
    });

    /**
     * Calls an input function `n` times, returning an array containing the results
     * of those function calls.
     *
     * `fn` is passed one argument: The current value of `n`, which begins at `0`
     * and is gradually incremented to `n - 1`.
     *
     * @func
     * @memberOf R
     * @since v0.2.3
     * @category List
     * @sig (Number -> a) -> Number -> [a]
     * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
     * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
     * @return {Array} An array containing the return values of all calls to `fn`.
     * @example
     *
     *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
     */
    var times = _curry2(function times(fn, n) {
        var len = Number(n);
        var idx = 0;
        var list;
        if (len < 0 || isNaN(len)) {
            throw new RangeError('n must be a non-negative number');
        }
        list = new Array(len);
        while (idx < len) {
            list[idx] = fn(idx);
            idx += 1;
        }
        return list;
    });

    /**
     * Converts an object into an array of key, value arrays. Only the object's
     * own properties are used.
     * Note that the order of the output array is not guaranteed to be consistent
     * across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.4.0
     * @category Object
     * @sig {String: *} -> [[String,*]]
     * @param {Object} obj The object to extract from
     * @return {Array} An array of key, value arrays from the object's own properties.
     * @see R.fromPairs
     * @example
     *
     *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
     */
    var toPairs = _curry1(function toPairs(obj) {
        var pairs = [];
        for (var prop in obj) {
            if (_has(prop, obj)) {
                pairs[pairs.length] = [
                    prop,
                    obj[prop]
                ];
            }
        }
        return pairs;
    });

    /**
     * Converts an object into an array of key, value arrays. The object's own
     * properties and prototype properties are used. Note that the order of the
     * output array is not guaranteed to be consistent across different JS
     * platforms.
     *
     * @func
     * @memberOf R
     * @since v0.4.0
     * @category Object
     * @sig {String: *} -> [[String,*]]
     * @param {Object} obj The object to extract from
     * @return {Array} An array of key, value arrays from the object's own
     *         and prototype properties.
     * @example
     *
     *      var F = function() { this.x = 'X'; };
     *      F.prototype.y = 'Y';
     *      var f = new F();
     *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
     */
    var toPairsIn = _curry1(function toPairsIn(obj) {
        var pairs = [];
        for (var prop in obj) {
            pairs[pairs.length] = [
                prop,
                obj[prop]
            ];
        }
        return pairs;
    });

    /**
     * Transposes the rows and columns of a 2D list.
     * When passed a list of `n` lists of length `x`,
     * returns a list of `x` lists of length `n`.
     *
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig [[a]] -> [[a]]
     * @param {Array} list A 2D list
     * @return {Array} A 2D list
     * @example
     *
     *      R.transpose([[1, 'a'], [2, 'b'], [3, 'c']]) //=> [[1, 2, 3], ['a', 'b', 'c']]
     *      R.transpose([[1, 2, 3], ['a', 'b', 'c']]) //=> [[1, 'a'], [2, 'b'], [3, 'c']]
     *
     * If some of the rows are shorter than the following rows, their elements are skipped:
     *
     *      R.transpose([[10, 11], [20], [], [30, 31, 32]]) //=> [[10, 20, 30], [11, 31], [32]]
     */
    var transpose = _curry1(function transpose(outerlist) {
        var i = 0;
        var result = [];
        while (i < outerlist.length) {
            var innerlist = outerlist[i];
            var j = 0;
            while (j < innerlist.length) {
                if (typeof result[j] === 'undefined') {
                    result[j] = [];
                }
                result[j].push(innerlist[j]);
                j += 1;
            }
            i += 1;
        }
        return result;
    });

    /**
     * Removes (strips) whitespace from both ends of the string.
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category String
     * @sig String -> String
     * @param {String} str The string to trim.
     * @return {String} Trimmed version of `str`.
     * @example
     *
     *      R.trim('   xyz  '); //=> 'xyz'
     *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
     */
    var trim = function () {
        var ws = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
        var zeroWidth = '\u200B';
        var hasProtoTrim = typeof String.prototype.trim === 'function';
        if (!hasProtoTrim || (ws.trim() || !zeroWidth.trim())) {
            return _curry1(function trim(str) {
                var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
                var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
                return str.replace(beginRx, '').replace(endRx, '');
            });
        } else {
            return _curry1(function trim(str) {
                return str.trim();
            });
        }
    }();

    /**
     * `tryCatch` takes two functions, a `tryer` and a `catcher`. The returned
     * function evaluates the `tryer`; if it does not throw, it simply returns the
     * result. If the `tryer` *does* throw, the returned function evaluates the
     * `catcher` function and returns its result. Note that for effective
     * composition with this function, both the `tryer` and `catcher` functions
     * must return the same type of results.
     *
     * @func
     * @memberOf R
     * @since v0.20.0
     * @category Function
     * @sig (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
     * @param {Function} tryer The function that may throw.
     * @param {Function} catcher The function that will be evaluated if `tryer` throws.
     * @return {Function} A new function that will catch exceptions and send then to the catcher.
     * @example
     *
     *      R.tryCatch(R.prop('x'), R.F, {x: true}); //=> true
     *      R.tryCatch(R.prop('x'), R.F, null);      //=> false
     */
    var tryCatch = _curry2(function _tryCatch(tryer, catcher) {
        return _arity(tryer.length, function () {
            try {
                return tryer.apply(this, arguments);
            } catch (e) {
                return catcher.apply(this, _concat([e], arguments));
            }
        });
    });

    /**
     * Gives a single-word string description of the (native) type of a value,
     * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
     * attempt to distinguish user Object types any further, reporting them all as
     * 'Object'.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Type
     * @sig (* -> {*}) -> String
     * @param {*} val The value to test
     * @return {String}
     * @example
     *
     *      R.type({}); //=> "Object"
     *      R.type(1); //=> "Number"
     *      R.type(false); //=> "Boolean"
     *      R.type('s'); //=> "String"
     *      R.type(null); //=> "Null"
     *      R.type([]); //=> "Array"
     *      R.type(/[A-z]/); //=> "RegExp"
     */
    var type = _curry1(function type(val) {
        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
    });

    /**
     * Takes a function `fn`, which takes a single array argument, and returns a
     * function which:
     *
     *   - takes any number of positional arguments;
     *   - passes these arguments to `fn` as an array; and
     *   - returns the result.
     *
     * In other words, R.unapply derives a variadic function from a function which
     * takes an array. R.unapply is the inverse of R.apply.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Function
     * @sig ([*...] -> a) -> (*... -> a)
     * @param {Function} fn
     * @return {Function}
     * @see R.apply
     * @example
     *
     *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
     */
    var unapply = _curry1(function unapply(fn) {
        return function () {
            return fn(_slice(arguments));
        };
    });

    /**
     * Wraps a function of any arity (including nullary) in a function that accepts
     * exactly 1 parameter. Any extraneous parameters will not be passed to the
     * supplied function.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Function
     * @sig (* -> b) -> (a -> b)
     * @param {Function} fn The function to wrap.
     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
     *         arity 1.
     * @example
     *
     *      var takesTwoArgs = function(a, b) {
     *        return [a, b];
     *      };
     *      takesTwoArgs.length; //=> 2
     *      takesTwoArgs(1, 2); //=> [1, 2]
     *
     *      var takesOneArg = R.unary(takesTwoArgs);
     *      takesOneArg.length; //=> 1
     *      // Only 1 argument is passed to the wrapped function
     *      takesOneArg(1, 2); //=> [1, undefined]
     */
    var unary = _curry1(function unary(fn) {
        return nAry(1, fn);
    });

    /**
     * Returns a function of arity `n` from a (manually) curried function.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Function
     * @sig Number -> (a -> b) -> (a -> c)
     * @param {Number} length The arity for the returned function.
     * @param {Function} fn The function to uncurry.
     * @return {Function} A new function.
     * @see R.curry
     * @example
     *
     *      var addFour = a => b => c => d => a + b + c + d;
     *
     *      var uncurriedAddFour = R.uncurryN(4, addFour);
     *      uncurriedAddFour(1, 2, 3, 4); //=> 10
     */
    var uncurryN = _curry2(function uncurryN(depth, fn) {
        return curryN(depth, function () {
            var currentDepth = 1;
            var value = fn;
            var idx = 0;
            var endIdx;
            while (currentDepth <= depth && typeof value === 'function') {
                endIdx = currentDepth === depth ? arguments.length : idx + value.length;
                value = value.apply(this, _slice(arguments, idx, endIdx));
                currentDepth += 1;
                idx = endIdx;
            }
            return value;
        });
    });

    /**
     * Builds a list from a seed value. Accepts an iterator function, which returns
     * either false to stop iteration or an array of length 2 containing the value
     * to add to the resulting list and the seed to be used in the next call to the
     * iterator function.
     *
     * The iterator function receives one argument: *(seed)*.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig (a -> [b]) -> * -> [b]
     * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
     *        either false to quit iteration or an array of length two to proceed. The element
     *        at index 0 of this array will be added to the resulting array, and the element
     *        at index 1 will be passed to the next call to `fn`.
     * @param {*} seed The seed value.
     * @return {Array} The final list.
     * @example
     *
     *      var f = n => n > 50 ? false : [-n, n + 10];
     *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
     */
    var unfold = _curry2(function unfold(fn, seed) {
        var pair = fn(seed);
        var result = [];
        while (pair && pair.length) {
            result[result.length] = pair[0];
            pair = fn(pair[1]);
        }
        return result;
    });

    /**
     * Returns a new list containing only one copy of each element in the original
     * list, based upon the value returned by applying the supplied predicate to
     * two list elements. Prefers the first item if two items compare equal based
     * on the predicate.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category List
     * @sig (a, a -> Boolean) -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      var strEq = R.eqBy(String);
     *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
     *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
     *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
     *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
     */
    var uniqWith = _curry2(function uniqWith(pred, list) {
        var idx = 0;
        var len = list.length;
        var result = [];
        var item;
        while (idx < len) {
            item = list[idx];
            if (!_containsWith(pred, item, result)) {
                result[result.length] = item;
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Tests the final argument by passing it to the given predicate function. If
     * the predicate is not satisfied, the function will return the result of
     * calling the `whenFalseFn` function with the same argument. If the predicate
     * is satisfied, the argument is returned as is.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Logic
     * @sig (a -> Boolean) -> (a -> a) -> a -> a
     * @param {Function} pred        A predicate function
     * @param {Function} whenFalseFn A function to invoke when the `pred` evaluates
     *                               to a falsy value.
     * @param {*}        x           An object to test with the `pred` function and
     *                               pass to `whenFalseFn` if necessary.
     * @return {*} Either `x` or the result of applying `x` to `whenFalseFn`.
     * @see R.ifElse, R.when
     * @example
     *
     *      // coerceArray :: (a|[a]) -> [a]
     *      var coerceArray = R.unless(R.isArrayLike, R.of);
     *      coerceArray([1, 2, 3]); //=> [1, 2, 3]
     *      coerceArray(1);         //=> [1]
     */
    var unless = _curry3(function unless(pred, whenFalseFn, x) {
        return pred(x) ? x : whenFalseFn(x);
    });

    /**
     * Takes a predicate, a transformation function, and an initial value,
     * and returns a value of the same type as the initial value.
     * It does so by applying the transformation until the predicate is satisfied,
     * at which point it returns the satisfactory value.
     *
     * @func
     * @memberOf R
     * @since v0.20.0
     * @category Logic
     * @sig (a -> Boolean) -> (a -> a) -> a -> a
     * @param {Function} pred A predicate function
     * @param {Function} fn The iterator function
     * @param {*} init Initial value
     * @return {*} Final value that satisfies predicate
     * @example
     *
     *      R.until(R.gt(R.__, 100), R.multiply(2))(1) // => 128
     */
    var until = _curry3(function until(pred, fn, init) {
        var val = init;
        while (!pred(val)) {
            val = fn(val);
        }
        return val;
    });

    /**
     * Returns a new copy of the array with the element at the provided index
     * replaced with the given value.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig Number -> a -> [a] -> [a]
     * @param {Number} idx The index to update.
     * @param {*} x The value to exist at the given index of the returned array.
     * @param {Array|Arguments} list The source array-like object to be updated.
     * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
     * @see R.adjust
     * @example
     *
     *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]
     *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]
     */
    var update = _curry3(function update(idx, x, list) {
        return adjust(always(x), idx, list);
    });

    /**
     * Accepts a function `fn` and a list of transformer functions and returns a
     * new curried function. When the new function is invoked, it calls the
     * function `fn` with parameters consisting of the result of calling each
     * supplied handler on successive arguments to the new function.
     *
     * If more arguments are passed to the returned function than transformer
     * functions, those arguments are passed directly to `fn` as additional
     * parameters. If you expect additional arguments that don't need to be
     * transformed, although you can ignore them, it's best to pass an identity
     * function so that the new function reports the correct arity.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (x1 -> x2 -> ... -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)
     * @param {Function} fn The function to wrap.
     * @param {Array} transformers A list of transformer functions
     * @return {Function} The wrapped function.
     * @example
     *
     *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81
     *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81
     *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32
     *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32
     */
    var useWith = _curry2(function useWith(fn, transformers) {
        return curryN(transformers.length, function () {
            var args = [];
            var idx = 0;
            while (idx < transformers.length) {
                args.push(transformers[idx].call(this, arguments[idx]));
                idx += 1;
            }
            return fn.apply(this, args.concat(_slice(arguments, transformers.length)));
        });
    });

    /**
     * Returns a list of all the enumerable own properties of the supplied object.
     * Note that the order of the output array is not guaranteed across different
     * JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {k: v} -> [v]
     * @param {Object} obj The object to extract values from
     * @return {Array} An array of the values of the object's own properties.
     * @example
     *
     *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
     */
    var values = _curry1(function values(obj) {
        var props = keys(obj);
        var len = props.length;
        var vals = [];
        var idx = 0;
        while (idx < len) {
            vals[idx] = obj[props[idx]];
            idx += 1;
        }
        return vals;
    });

    /**
     * Returns a list of all the properties, including prototype properties, of the
     * supplied object.
     * Note that the order of the output array is not guaranteed to be consistent
     * across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Object
     * @sig {k: v} -> [v]
     * @param {Object} obj The object to extract values from
     * @return {Array} An array of the values of the object's own and prototype properties.
     * @example
     *
     *      var F = function() { this.x = 'X'; };
     *      F.prototype.y = 'Y';
     *      var f = new F();
     *      R.valuesIn(f); //=> ['X', 'Y']
     */
    var valuesIn = _curry1(function valuesIn(obj) {
        var prop;
        var vs = [];
        for (prop in obj) {
            vs[vs.length] = obj[prop];
        }
        return vs;
    });

    /**
     * Returns a "view" of the given data structure, determined by the given lens.
     * The lens's focus determines which portion of the data structure is visible.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Lens s a -> s -> a
     * @param {Lens} lens
     * @param {*} x
     * @return {*}
     * @see R.prop, R.lensIndex, R.lensProp
     * @example
     *
     *      var xLens = R.lensProp('x');
     *
     *      R.view(xLens, {x: 1, y: 2});  //=> 1
     *      R.view(xLens, {x: 4, y: 2});  //=> 4
     */
    // `Const` is a functor that effectively ignores the function given to `map`.
    // Using `Const` effectively ignores the setter function of the `lens`,
    // leaving the value returned by the getter function unmodified.
    var view = function () {
        // `Const` is a functor that effectively ignores the function given to `map`.
        var Const = function (x) {
            return {
                value: x,
                map: function () {
                    return this;
                }
            };
        };
        return _curry2(function view(lens, x) {
            // Using `Const` effectively ignores the setter function of the `lens`,
            // leaving the value returned by the getter function unmodified.
            return lens(Const)(x).value;
        });
    }();

    /**
     * Tests the final argument by passing it to the given predicate function. If
     * the predicate is satisfied, the function will return the result of calling
     * the `whenTrueFn` function with the same argument. If the predicate is not
     * satisfied, the argument is returned as is.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Logic
     * @sig (a -> Boolean) -> (a -> a) -> a -> a
     * @param {Function} pred       A predicate function
     * @param {Function} whenTrueFn A function to invoke when the `condition`
     *                              evaluates to a truthy value.
     * @param {*}        x          An object to test with the `pred` function and
     *                              pass to `whenTrueFn` if necessary.
     * @return {*} Either `x` or the result of applying `x` to `whenTrueFn`.
     * @see R.ifElse, R.unless
     * @example
     *
     *      // truncate :: String -> String
     *      var truncate = R.when(
     *        R.propSatisfies(R.gt(R.__, 10), 'length'),
     *        R.pipe(R.take(10), R.append(''), R.join(''))
     *      );
     *      truncate('12345');         //=> '12345'
     *      truncate('0123456789ABC'); //=> '0123456789'
     */
    var when = _curry3(function when(pred, whenTrueFn, x) {
        return pred(x) ? whenTrueFn(x) : x;
    });

    /**
     * Takes a spec object and a test object; returns true if the test satisfies
     * the spec. Each of the spec's own properties must be a predicate function.
     * Each predicate is applied to the value of the corresponding property of the
     * test object. `where` returns true if all the predicates return true, false
     * otherwise.
     *
     * `where` is well suited to declaratively expressing constraints for other
     * functions such as `filter` and `find`.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category Object
     * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
     * @param {Object} spec
     * @param {Object} testObj
     * @return {Boolean}
     * @example
     *
     *      // pred :: Object -> Boolean
     *      var pred = R.where({
     *        a: R.equals('foo'),
     *        b: R.complement(R.equals('bar')),
     *        x: R.gt(_, 10),
     *        y: R.lt(_, 20)
     *      });
     *
     *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
     *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
     *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
     *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
     *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
     */
    var where = _curry2(function where(spec, testObj) {
        for (var prop in spec) {
            if (_has(prop, spec) && !spec[prop](testObj[prop])) {
                return false;
            }
        }
        return true;
    });

    /**
     * Wrap a function inside another to allow you to make adjustments to the
     * parameters, or do other processing either before the internal function is
     * called or with its results.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a... -> b) -> ((a... -> b) -> a... -> c) -> (a... -> c)
     * @param {Function} fn The function to wrap.
     * @param {Function} wrapper The wrapper function.
     * @return {Function} The wrapped function.
     * @example
     *
     *      var greet = name => 'Hello ' + name;
     *
     *      var shoutedGreet = R.wrap(greet, (gr, name) => gr(name).toUpperCase());
     *
     *      shoutedGreet("Kathy"); //=> "HELLO KATHY"
     *
     *      var shortenedGreet = R.wrap(greet, function(gr, name) {
     *        return gr(name.substring(0, 3));
     *      });
     *      shortenedGreet("Robert"); //=> "Hello Rob"
     */
    var wrap = _curry2(function wrap(fn, wrapper) {
        return curryN(fn.length, function () {
            return wrapper.apply(this, _concat([fn], arguments));
        });
    });

    /**
     * Creates a new list out of the two supplied by creating each possible pair
     * from the lists.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [b] -> [[a,b]]
     * @param {Array} as The first list.
     * @param {Array} bs The second list.
     * @return {Array} The list made by combining each possible pair from
     *         `as` and `bs` into pairs (`[a, b]`).
     * @example
     *
     *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
     */
    // = xprodWith(prepend); (takes about 3 times as long...)
    var xprod = _curry2(function xprod(a, b) {
        // = xprodWith(prepend); (takes about 3 times as long...)
        var idx = 0;
        var ilen = a.length;
        var j;
        var jlen = b.length;
        var result = [];
        while (idx < ilen) {
            j = 0;
            while (j < jlen) {
                result[result.length] = [
                    a[idx],
                    b[j]
                ];
                j += 1;
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Creates a new list out of the two supplied by pairing up equally-positioned
     * items from both lists. The returned list is truncated to the length of the
     * shorter of the two input lists.
     * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [b] -> [[a,b]]
     * @param {Array} list1 The first array to consider.
     * @param {Array} list2 The second array to consider.
     * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
     * @example
     *
     *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
     */
    var zip = _curry2(function zip(a, b) {
        var rv = [];
        var idx = 0;
        var len = Math.min(a.length, b.length);
        while (idx < len) {
            rv[idx] = [
                a[idx],
                b[idx]
            ];
            idx += 1;
        }
        return rv;
    });

    /**
     * Creates a new object out of a list of keys and a list of values.
     * Key/value pairing is truncated to the length of the shorter of the two lists.
     * Note: `zipObj` is equivalent to `pipe(zipWith(pair), fromPairs)`.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig [String] -> [*] -> {String: *}
     * @param {Array} keys The array that will be properties on the output object.
     * @param {Array} values The list of values on the output object.
     * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
     * @example
     *
     *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
     */
    var zipObj = _curry2(function zipObj(keys, values) {
        var idx = 0;
        var len = Math.min(keys.length, values.length);
        var out = {};
        while (idx < len) {
            out[keys[idx]] = values[idx];
            idx += 1;
        }
        return out;
    });

    /**
     * Creates a new list out of the two supplied by applying the function to each
     * equally-positioned pair in the lists. The returned list is truncated to the
     * length of the shorter of the two input lists.
     *
     * @function
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a,b -> c) -> [a] -> [b] -> [c]
     * @param {Function} fn The function used to combine the two elements into one value.
     * @param {Array} list1 The first array to consider.
     * @param {Array} list2 The second array to consider.
     * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
     *         using `fn`.
     * @example
     *
     *      var f = (x, y) => {
     *        // ...
     *      };
     *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
     *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
     */
    var zipWith = _curry3(function zipWith(fn, a, b) {
        var rv = [];
        var idx = 0;
        var len = Math.min(a.length, b.length);
        while (idx < len) {
            rv[idx] = fn(a[idx], b[idx]);
            idx += 1;
        }
        return rv;
    });

    /**
     * A function that always returns `false`. Any passed in parameters are ignored.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Function
     * @sig * -> Boolean
     * @param {*}
     * @return {Boolean}
     * @see R.always, R.T
     * @example
     *
     *      R.F(); //=> false
     */
    var F = always(false);

    /**
     * A function that always returns `true`. Any passed in parameters are ignored.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Function
     * @sig * -> Boolean
     * @param {*}
     * @return {Boolean}
     * @see R.always, R.F
     * @example
     *
     *      R.T(); //=> true
     */
    var T = always(true);

    /**
     * Copies an object.
     *
     * @private
     * @param {*} value The value to be copied
     * @param {Array} refFrom Array containing the source references
     * @param {Array} refTo Array containing the copied source references
     * @param {Boolean} deep Whether or not to perform deep cloning.
     * @return {*} The copied value.
     */
    var _clone = function _clone(value, refFrom, refTo, deep) {
        var copy = function copy(copiedValue) {
            var len = refFrom.length;
            var idx = 0;
            while (idx < len) {
                if (value === refFrom[idx]) {
                    return refTo[idx];
                }
                idx += 1;
            }
            refFrom[idx + 1] = value;
            refTo[idx + 1] = copiedValue;
            for (var key in value) {
                copiedValue[key] = deep ? _clone(value[key], refFrom, refTo, true) : value[key];
            }
            return copiedValue;
        };
        switch (type(value)) {
        case 'Object':
            return copy({});
        case 'Array':
            return copy([]);
        case 'Date':
            return new Date(value.valueOf());
        case 'RegExp':
            return _cloneRegExp(value);
        default:
            return value;
        }
    };

    var _createPartialApplicator = function _createPartialApplicator(concat) {
        return _curry2(function (fn, args) {
            return _arity(Math.max(0, fn.length - args.length), function () {
                return fn.apply(this, concat(args, arguments));
            });
        });
    };

    var _dropLast = function dropLast(n, xs) {
        return take(n < xs.length ? xs.length - n : 0, xs);
    };

    // Values of other types are only equal if identical.
    var _equals = function _equals(a, b, stackA, stackB) {
        if (identical(a, b)) {
            return true;
        }
        if (type(a) !== type(b)) {
            return false;
        }
        if (a == null || b == null) {
            return false;
        }
        if (typeof a.equals === 'function' || typeof b.equals === 'function') {
            return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
        }
        switch (type(a)) {
        case 'Arguments':
        case 'Array':
        case 'Object':
            if (typeof a.constructor === 'function' && _functionName(a.constructor) === 'Promise') {
                return a === b;
            }
            break;
        case 'Boolean':
        case 'Number':
        case 'String':
            if (!(typeof a === typeof b && identical(a.valueOf(), b.valueOf()))) {
                return false;
            }
            break;
        case 'Date':
            if (!identical(a.valueOf(), b.valueOf())) {
                return false;
            }
            break;
        case 'Error':
            return a.name === b.name && a.message === b.message;
        case 'RegExp':
            if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
                return false;
            }
            break;
        case 'Map':
        case 'Set':
            if (!_equals(_arrayFromIterator(a.entries()), _arrayFromIterator(b.entries()), stackA, stackB)) {
                return false;
            }
            break;
        case 'Int8Array':
        case 'Uint8Array':
        case 'Uint8ClampedArray':
        case 'Int16Array':
        case 'Uint16Array':
        case 'Int32Array':
        case 'Uint32Array':
        case 'Float32Array':
        case 'Float64Array':
            break;
        case 'ArrayBuffer':
            break;
        default:
            // Values of other types are only equal if identical.
            return false;
        }
        var keysA = keys(a);
        if (keysA.length !== keys(b).length) {
            return false;
        }
        var idx = stackA.length - 1;
        while (idx >= 0) {
            if (stackA[idx] === a) {
                return stackB[idx] === b;
            }
            idx -= 1;
        }
        stackA.push(a);
        stackB.push(b);
        idx = keysA.length - 1;
        while (idx >= 0) {
            var key = keysA[idx];
            if (!(_has(key, b) && _equals(b[key], a[key], stackA, stackB))) {
                return false;
            }
            idx -= 1;
        }
        stackA.pop();
        stackB.pop();
        return true;
    };

    /**
     * `_makeFlat` is a helper function that returns a one-level or fully recursive
     * function based on the flag passed in.
     *
     * @private
     */
    var _makeFlat = function _makeFlat(recursive) {
        return function flatt(list) {
            var value, jlen, j;
            var result = [];
            var idx = 0;
            var ilen = list.length;
            while (idx < ilen) {
                if (isArrayLike(list[idx])) {
                    value = recursive ? flatt(list[idx]) : list[idx];
                    j = 0;
                    jlen = value.length;
                    while (j < jlen) {
                        result[result.length] = value[j];
                        j += 1;
                    }
                } else {
                    result[result.length] = list[idx];
                }
                idx += 1;
            }
            return result;
        };
    };

    var _reduce = function () {
        function _arrayReduce(xf, acc, list) {
            var idx = 0;
            var len = list.length;
            while (idx < len) {
                acc = xf['@@transducer/step'](acc, list[idx]);
                if (acc && acc['@@transducer/reduced']) {
                    acc = acc['@@transducer/value'];
                    break;
                }
                idx += 1;
            }
            return xf['@@transducer/result'](acc);
        }
        function _iterableReduce(xf, acc, iter) {
            var step = iter.next();
            while (!step.done) {
                acc = xf['@@transducer/step'](acc, step.value);
                if (acc && acc['@@transducer/reduced']) {
                    acc = acc['@@transducer/value'];
                    break;
                }
                step = iter.next();
            }
            return xf['@@transducer/result'](acc);
        }
        function _methodReduce(xf, acc, obj) {
            return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));
        }
        var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
        return function _reduce(fn, acc, list) {
            if (typeof fn === 'function') {
                fn = _xwrap(fn);
            }
            if (isArrayLike(list)) {
                return _arrayReduce(fn, acc, list);
            }
            if (typeof list.reduce === 'function') {
                return _methodReduce(fn, acc, list);
            }
            if (list[symIterator] != null) {
                return _iterableReduce(fn, acc, list[symIterator]());
            }
            if (typeof list.next === 'function') {
                return _iterableReduce(fn, acc, list);
            }
            throw new TypeError('reduce: list must be array or iterable');
        };
    }();

    var _stepCat = function () {
        var _stepCatArray = {
            '@@transducer/init': Array,
            '@@transducer/step': function (xs, x) {
                xs.push(x);
                return xs;
            },
            '@@transducer/result': _identity
        };
        var _stepCatString = {
            '@@transducer/init': String,
            '@@transducer/step': function (a, b) {
                return a + b;
            },
            '@@transducer/result': _identity
        };
        var _stepCatObject = {
            '@@transducer/init': Object,
            '@@transducer/step': function (result, input) {
                return _assign(result, isArrayLike(input) ? objOf(input[0], input[1]) : input);
            },
            '@@transducer/result': _identity
        };
        return function _stepCat(obj) {
            if (_isTransformer(obj)) {
                return obj;
            }
            if (isArrayLike(obj)) {
                return _stepCatArray;
            }
            if (typeof obj === 'string') {
                return _stepCatString;
            }
            if (typeof obj === 'object') {
                return _stepCatObject;
            }
            throw new Error('Cannot create transformer for ' + obj);
        };
    }();

    var _xdropLastWhile = function () {
        function XDropLastWhile(fn, xf) {
            this.f = fn;
            this.retained = [];
            this.xf = xf;
        }
        XDropLastWhile.prototype['@@transducer/init'] = _xfBase.init;
        XDropLastWhile.prototype['@@transducer/result'] = function (result) {
            this.retained = null;
            return this.xf['@@transducer/result'](result);
        };
        XDropLastWhile.prototype['@@transducer/step'] = function (result, input) {
            return this.f(input) ? this.retain(result, input) : this.flush(result, input);
        };
        XDropLastWhile.prototype.flush = function (result, input) {
            result = _reduce(this.xf['@@transducer/step'], result, this.retained);
            this.retained = [];
            return this.xf['@@transducer/step'](result, input);
        };
        XDropLastWhile.prototype.retain = function (result, input) {
            this.retained.push(input);
            return result;
        };
        return _curry2(function _xdropLastWhile(fn, xf) {
            return new XDropLastWhile(fn, xf);
        });
    }();

    var _xgroupBy = function () {
        function XGroupBy(f, xf) {
            this.xf = xf;
            this.f = f;
            this.inputs = {};
        }
        XGroupBy.prototype['@@transducer/init'] = _xfBase.init;
        XGroupBy.prototype['@@transducer/result'] = function (result) {
            var key;
            for (key in this.inputs) {
                if (_has(key, this.inputs)) {
                    result = this.xf['@@transducer/step'](result, this.inputs[key]);
                    if (result['@@transducer/reduced']) {
                        result = result['@@transducer/value'];
                        break;
                    }
                }
            }
            this.inputs = null;
            return this.xf['@@transducer/result'](result);
        };
        XGroupBy.prototype['@@transducer/step'] = function (result, input) {
            var key = this.f(input);
            this.inputs[key] = this.inputs[key] || [
                key,
                []
            ];
            this.inputs[key][1] = append(input, this.inputs[key][1]);
            return result;
        };
        return _curry2(function _xgroupBy(f, xf) {
            return new XGroupBy(f, xf);
        });
    }();

    /**
     * Creates a new list iteration function from an existing one by adding two new
     * parameters to its callback function: the current index, and the entire list.
     *
     * This would turn, for instance, Ramda's simple `map` function into one that
     * more closely resembles `Array.prototype.map`. Note that this will only work
     * for functions in which the iteration callback function is the first
     * parameter, and where the list is the last parameter. (This latter might be
     * unimportant if the list parameter is not used.)
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category Function
     * @category List
     * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
     * @param {Function} fn A list iteration function that does not pass index or list to its callback
     * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
     * @example
     *
     *      var mapIndexed = R.addIndex(R.map);
     *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
     *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
     */
    var addIndex = _curry1(function addIndex(fn) {
        return curryN(fn.length, function () {
            var idx = 0;
            var origFn = arguments[0];
            var list = arguments[arguments.length - 1];
            var args = _slice(arguments);
            args[0] = function () {
                var result = origFn.apply(this, _concat(arguments, [
                    idx,
                    list
                ]));
                idx += 1;
                return result;
            };
            return fn.apply(this, args);
        });
    });

    /**
     * Wraps a function of any arity (including nullary) in a function that accepts
     * exactly 2 parameters. Any extraneous parameters will not be passed to the
     * supplied function.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Function
     * @sig (* -> c) -> (a, b -> c)
     * @param {Function} fn The function to wrap.
     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
     *         arity 2.
     * @example
     *
     *      var takesThreeArgs = function(a, b, c) {
     *        return [a, b, c];
     *      };
     *      takesThreeArgs.length; //=> 3
     *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
     *
     *      var takesTwoArgs = R.binary(takesThreeArgs);
     *      takesTwoArgs.length; //=> 2
     *      // Only 2 arguments are passed to the wrapped function
     *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
     */
    var binary = _curry1(function binary(fn) {
        return nAry(2, fn);
    });

    /**
     * Creates a deep copy of the value which may contain (nested) `Array`s and
     * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are not
     * copied, but assigned by their reference.
     *
     * Dispatches to a `clone` method if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {*} -> {*}
     * @param {*} value The object or array to clone
     * @return {*} A new object or array.
     * @example
     *
     *      var objects = [{}, {}, {}];
     *      var objectsClone = R.clone(objects);
     *      objects[0] === objectsClone[0]; //=> false
     */
    var clone = _curry1(function clone(value) {
        return value != null && typeof value.clone === 'function' ? value.clone() : _clone(value, [], [], true);
    });

    /**
     * Returns a curried equivalent of the provided function. The curried function
     * has two unusual capabilities. First, its arguments needn't be provided one
     * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
     * following are equivalent:
     *
     *   - `g(1)(2)(3)`
     *   - `g(1)(2, 3)`
     *   - `g(1, 2)(3)`
     *   - `g(1, 2, 3)`
     *
     * Secondly, the special placeholder value `R.__` may be used to specify
     * "gaps", allowing partial application of any combination of arguments,
     * regardless of their positions. If `g` is as above and `_` is `R.__`, the
     * following are equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (* -> a) -> (* -> a)
     * @param {Function} fn The function to curry.
     * @return {Function} A new, curried function.
     * @see R.curryN
     * @example
     *
     *      var addFourNumbers = (a, b, c, d) => a + b + c + d;
     *
     *      var curriedAddFourNumbers = R.curry(addFourNumbers);
     *      var f = curriedAddFourNumbers(1, 2);
     *      var g = f(3);
     *      g(4); //=> 10
     */
    var curry = _curry1(function curry(fn) {
        return curryN(fn.length, fn);
    });

    /**
     * Returns all but the first `n` elements of the given list, string, or
     * transducer/transformer (or object with a `drop` method).
     *
     * Dispatches to the `drop` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n
     * @param {*} list
     * @return {*}
     * @see R.take, R.transduce
     * @example
     *
     *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
     *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
     *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
     *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
     *      R.drop(3, 'ramda');               //=> 'da'
     */
    var drop = _curry2(_dispatchable('drop', _xdrop, function drop(n, xs) {
        return slice(Math.max(0, n), Infinity, xs);
    }));

    /**
     * Returns a list containing all but the last `n` elements of the given `list`.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n The number of elements of `xs` to skip.
     * @param {Array} xs The collection to consider.
     * @return {Array}
     * @see R.takeLast
     * @example
     *
     *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
     *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
     *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
     *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
     *      R.dropLast(3, 'ramda');               //=> 'ra'
     */
    var dropLast = _curry2(_dispatchable('dropLast', _xdropLast, _dropLast));

    /**
     * Returns a new list containing all but last the`n` elements of a given list,
     * passing each value from the right to the supplied predicate function,
     * skipping elements while the predicate function returns `true`. The predicate
     * function is passed one argument: (value)*.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.takeLastWhile, R.addIndex
     * @example
     *
     *      var lteThree = x => x <= 3;
     *
     *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]
     */
    var dropLastWhile = _curry2(_dispatchable('dropLastWhile', _xdropLastWhile, _dropLastWhile));

    /**
     * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
     * cyclical data structures.
     *
     * Dispatches symmetrically to the `equals` methods of both arguments, if
     * present.
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category Relation
     * @sig a -> b -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @example
     *
     *      R.equals(1, 1); //=> true
     *      R.equals(1, '1'); //=> false
     *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
     *
     *      var a = {}; a.v = a;
     *      var b = {}; b.v = b;
     *      R.equals(a, b); //=> true
     */
    var equals = _curry2(function equals(a, b) {
        return _equals(a, b, [], []);
    });

    /**
     * Takes a predicate and a "filterable", and returns a new filterable of the
     * same type containing the members of the given filterable which satisfy the
     * given predicate.
     *
     * Dispatches to the `filter` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Filterable f => (a -> Boolean) -> f a -> f a
     * @param {Function} pred
     * @param {Array} filterable
     * @return {Array}
     * @see R.reject, R.transduce, R.addIndex
     * @example
     *
     *      var isEven = n => n % 2 === 0;
     *
     *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
     *
     *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
     */
    // else
    var filter = _curry2(_dispatchable('filter', _xfilter, function (pred, filterable) {
        return _isObject(filterable) ? _reduce(function (acc, key) {
            if (pred(filterable[key])) {
                acc[key] = filterable[key];
            }
            return acc;
        }, {}, keys(filterable)) : // else
        _filter(pred, filterable);
    }));

    /**
     * Returns a new list by pulling every item out of it (and all its sub-arrays)
     * and putting them in a new array, depth-first.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [b]
     * @param {Array} list The array to consider.
     * @return {Array} The flattened list.
     * @see R.unnest
     * @example
     *
     *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
     *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
     */
    var flatten = _curry1(_makeFlat(true));

    /**
     * Returns a new function much like the supplied one, except that the first two
     * arguments' order is reversed.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z)
     * @param {Function} fn The function to invoke with its first two parameters reversed.
     * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
     * @example
     *
     *      var mergeThree = (a, b, c) => [].concat(a, b, c);
     *
     *      mergeThree(1, 2, 3); //=> [1, 2, 3]
     *
     *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
     */
    var flip = _curry1(function flip(fn) {
        return curry(function (a, b) {
            var args = _slice(arguments);
            args[0] = b;
            args[1] = a;
            return fn.apply(this, args);
        });
    });

    /**
     * Returns the first element of the given list or string. In some libraries
     * this function is named `first`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> a | Undefined
     * @sig String -> String
     * @param {Array|String} list
     * @return {*}
     * @see R.tail, R.init, R.last
     * @example
     *
     *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
     *      R.head([]); //=> undefined
     *
     *      R.head('abc'); //=> 'a'
     *      R.head(''); //=> ''
     */
    var head = nth(0);

    /**
     * Returns all but the last element of the given list or string.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category List
     * @sig [a] -> [a]
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @see R.last, R.head, R.tail
     * @example
     *
     *      R.init([1, 2, 3]);  //=> [1, 2]
     *      R.init([1, 2]);     //=> [1]
     *      R.init([1]);        //=> []
     *      R.init([]);         //=> []
     *
     *      R.init('abc');  //=> 'ab'
     *      R.init('ab');   //=> 'a'
     *      R.init('a');    //=> ''
     *      R.init('');     //=> ''
     */
    var init = slice(0, -1);

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of those
     * elements common to both lists. Duplication is determined according to the
     * value returned by applying the supplied predicate to two list elements.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
     * @param {Function} pred A predicate function that determines whether
     *        the two supplied elements are equal.
     * @param {Array} list1 One list of items to compare
     * @param {Array} list2 A second list of items to compare
     * @return {Array} A new list containing those elements common to both lists.
     * @see R.intersection
     * @example
     *
     *      var buffaloSpringfield = [
     *        {id: 824, name: 'Richie Furay'},
     *        {id: 956, name: 'Dewey Martin'},
     *        {id: 313, name: 'Bruce Palmer'},
     *        {id: 456, name: 'Stephen Stills'},
     *        {id: 177, name: 'Neil Young'}
     *      ];
     *      var csny = [
     *        {id: 204, name: 'David Crosby'},
     *        {id: 456, name: 'Stephen Stills'},
     *        {id: 539, name: 'Graham Nash'},
     *        {id: 177, name: 'Neil Young'}
     *      ];
     *
     *      R.intersectionWith(R.eqBy(R.prop('id')), buffaloSpringfield, csny);
     *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
     */
    var intersectionWith = _curry3(function intersectionWith(pred, list1, list2) {
        var lookupList, filteredList;
        if (list1.length > list2.length) {
            lookupList = list1;
            filteredList = list2;
        } else {
            lookupList = list2;
            filteredList = list1;
        }
        var results = [];
        var idx = 0;
        while (idx < filteredList.length) {
            if (_containsWith(pred, filteredList[idx], lookupList)) {
                results[results.length] = filteredList[idx];
            }
            idx += 1;
        }
        return uniqWith(pred, results);
    });

    /**
     * Transforms the items of the list with the transducer and appends the
     * transformed items to the accumulator using an appropriate iterator function
     * based on the accumulator type.
     *
     * The accumulator can be an array, string, object or a transformer. Iterated
     * items will be appended to arrays and concatenated to strings. Objects will
     * be merged directly or 2-item arrays will be merged as key, value pairs.
     *
     * The accumulator can also be a transformer object that provides a 2-arity
     * reducing iterator function, step, 0-arity initial value function, init, and
     * 1-arity result extraction function result. The step function is used as the
     * iterator function in reduce. The result function is used to convert the
     * final accumulator into the return type and in most cases is R.identity. The
     * init function is used to provide the initial accumulator.
     *
     * The iteration is performed with R.reduce after initializing the transducer.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category List
     * @sig a -> (b -> b) -> [c] -> a
     * @param {*} acc The initial accumulator value.
     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @example
     *
     *      var numbers = [1, 2, 3, 4];
     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
     *
     *      R.into([], transducer, numbers); //=> [2, 3]
     *
     *      var intoArray = R.into([]);
     *      intoArray(transducer, numbers); //=> [2, 3]
     */
    var into = _curry3(function into(acc, xf, list) {
        return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), _clone(acc, [], [], false), list);
    });

    /**
     * Same as R.invertObj, however this accounts for objects with duplicate values
     * by putting the values into an array.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Object
     * @sig {s: x} -> {x: [ s, ... ]}
     * @param {Object} obj The object or array to invert
     * @return {Object} out A new object with keys
     * in an array.
     * @example
     *
     *      var raceResultsByFirstName = {
     *        first: 'alice',
     *        second: 'jake',
     *        third: 'alice',
     *      };
     *      R.invert(raceResultsByFirstName);
     *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
     */
    var invert = _curry1(function invert(obj) {
        var props = keys(obj);
        var len = props.length;
        var idx = 0;
        var out = {};
        while (idx < len) {
            var key = props[idx];
            var val = obj[key];
            var list = _has(val, out) ? out[val] : out[val] = [];
            list[list.length] = key;
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a new object with the keys of the given object as values, and the
     * values of the given object, which are coerced to strings, as keys. Note
     * that the last key found is preferred when handling the same value.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Object
     * @sig {s: x} -> {x: s}
     * @param {Object} obj The object or array to invert
     * @return {Object} out A new object
     * @example
     *
     *      var raceResults = {
     *        first: 'alice',
     *        second: 'jake'
     *      };
     *      R.invertObj(raceResults);
     *      //=> { 'alice': 'first', 'jake':'second' }
     *
     *      // Alternatively:
     *      var raceResults = ['alice', 'jake'];
     *      R.invertObj(raceResults);
     *      //=> { 'alice': '0', 'jake':'1' }
     */
    var invertObj = _curry1(function invertObj(obj) {
        var props = keys(obj);
        var len = props.length;
        var idx = 0;
        var out = {};
        while (idx < len) {
            var key = props[idx];
            out[obj[key]] = key;
            idx += 1;
        }
        return out;
    });

    /**
     * Returns `true` if the given value is its type's empty value; `false`
     * otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Logic
     * @sig a -> Boolean
     * @param {*} x
     * @return {Boolean}
     * @see R.empty
     * @example
     *
     *      R.isEmpty([1, 2, 3]);   //=> false
     *      R.isEmpty([]);          //=> true
     *      R.isEmpty('');          //=> true
     *      R.isEmpty(null);        //=> false
     *      R.isEmpty({});          //=> true
     *      R.isEmpty({length: 0}); //=> false
     */
    var isEmpty = _curry1(function isEmpty(x) {
        return x != null && equals(x, empty(x));
    });

    /**
     * Returns the last element of the given list or string.
     *
     * @func
     * @memberOf R
     * @since v0.1.4
     * @category List
     * @sig [a] -> a | Undefined
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @see R.init, R.head, R.tail
     * @example
     *
     *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
     *      R.last([]); //=> undefined
     *
     *      R.last('abc'); //=> 'c'
     *      R.last(''); //=> ''
     */
    var last = nth(-1);

    /**
     * Returns the position of the last occurrence of an item in an array, or -1 if
     * the item is not included in the array. `R.equals` is used to determine
     * equality.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> Number
     * @param {*} target The item to find.
     * @param {Array} xs The array to search in.
     * @return {Number} the index of the target, or -1 if the target is not found.
     * @see R.indexOf
     * @example
     *
     *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
     *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
     */
    var lastIndexOf = _curry2(function lastIndexOf(target, xs) {
        if (typeof xs.lastIndexOf === 'function' && !_isArray(xs)) {
            return xs.lastIndexOf(target);
        } else {
            var idx = xs.length - 1;
            while (idx >= 0) {
                if (equals(xs[idx], target)) {
                    return idx;
                }
                idx -= 1;
            }
            return -1;
        }
    });

    /**
     * Takes a function and
     * a [functor](https://github.com/fantasyland/fantasy-land#functor),
     * applies the function to each of the functor's values, and returns
     * a functor of the same shape.
     *
     * Ramda provides suitable `map` implementations for `Array` and `Object`,
     * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
     *
     * Dispatches to the `map` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * Also treats functions as functors and will compose them together.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Functor f => (a -> b) -> f a -> f b
     * @param {Function} fn The function to be called on every element of the input `list`.
     * @param {Array} list The list to be iterated over.
     * @return {Array} The new list.
     * @see R.transduce, R.addIndex
     * @example
     *
     *      var double = x => x * 2;
     *
     *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
     *
     *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
     */
    var map = _curry2(_dispatchable('map', _xmap, function map(fn, functor) {
        switch (Object.prototype.toString.call(functor)) {
        case '[object Function]':
            return curryN(functor.length, function () {
                return fn.call(this, functor.apply(this, arguments));
            });
        case '[object Object]':
            return _reduce(function (acc, key) {
                acc[key] = fn(functor[key]);
                return acc;
            }, {}, keys(functor));
        default:
            return _map(fn, functor);
        }
    }));

    /**
     * An Object-specific version of `map`. The function is applied to three
     * arguments: *(value, key, obj)*. If only the value is significant, use
     * `map` instead.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Object
     * @sig ((*, String, Object) -> *) -> Object -> Object
     * @param {Function} fn
     * @param {Object} obj
     * @return {Object}
     * @see R.map
     * @example
     *
     *      var values = { x: 1, y: 2, z: 3 };
     *      var prependKeyAndDouble = (num, key, obj) => key + (num * 2);
     *
     *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }
     */
    var mapObjIndexed = _curry2(function mapObjIndexed(fn, obj) {
        return _reduce(function (acc, key) {
            acc[key] = fn(obj[key], key, obj);
            return acc;
        }, {}, keys(obj));
    });

    /**
     * Creates a new object with the own properties of the two provided objects. If
     * a key exists in both objects, the provided function is applied to the values
     * associated with the key in each object, with the result being used as the
     * value associated with the key in the returned object. The key will be
     * excluded from the returned object if the resulting value is `undefined`.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Object
     * @sig (a -> a -> a) -> {a} -> {a} -> {a}
     * @param {Function} fn
     * @param {Object} l
     * @param {Object} r
     * @return {Object}
     * @see R.merge, R.mergeWithKey
     * @example
     *
     *      R.mergeWith(R.concat,
     *                  { a: true, values: [10, 20] },
     *                  { b: true, values: [15, 35] });
     *      //=> { a: true, b: true, values: [10, 20, 15, 35] }
     */
    var mergeWith = _curry3(function mergeWith(fn, l, r) {
        return mergeWithKey(function (_, _l, _r) {
            return fn(_l, _r);
        }, l, r);
    });

    /**
     * Takes a function `f` and a list of arguments, and returns a function `g`.
     * When applied, `g` returns the result of applying `f` to the arguments
     * provided initially followed by the arguments provided to `g`.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Function
     * @sig ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x)
     * @param {Function} f
     * @param {Array} args
     * @return {Function}
     * @see R.partialRight
     * @example
     *
     *      var multiply = (a, b) => a * b;
     *      var double = R.partial(multiply, [2]);
     *      double(2); //=> 4
     *
     *      var greet = (salutation, title, firstName, lastName) =>
     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
     *
     *      var sayHello = R.partial(greet, ['Hello']);
     *      var sayHelloToMs = R.partial(sayHello, ['Ms.']);
     *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
     */
    var partial = _createPartialApplicator(_concat);

    /**
     * Takes a function `f` and a list of arguments, and returns a function `g`.
     * When applied, `g` returns the result of applying `f` to the arguments
     * provided to `g` followed by the arguments provided initially.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Function
     * @sig ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)
     * @param {Function} f
     * @param {Array} args
     * @return {Function}
     * @see R.partial
     * @example
     *
     *      var greet = (salutation, title, firstName, lastName) =>
     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
     *
     *      var greetMsJaneJones = R.partialRight(greet, ['Ms.', 'Jane', 'Jones']);
     *
     *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
     */
    var partialRight = _createPartialApplicator(flip(_concat));

    /**
     * Determines whether a nested path on an object has a specific value, in
     * `R.equals` terms. Most likely used to filter a list.
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Relation
     * @sig [String] -> * -> {String: *} -> Boolean
     * @param {Array} path The path of the nested property to use
     * @param {*} val The value to compare the nested property with
     * @param {Object} obj The object to check the nested property in
     * @return {Boolean} `true` if the value equals the nested object property,
     *         `false` otherwise.
     * @example
     *
     *      var user1 = { address: { zipCode: 90210 } };
     *      var user2 = { address: { zipCode: 55555 } };
     *      var user3 = { name: 'Bob' };
     *      var users = [ user1, user2, user3 ];
     *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);
     *      R.filter(isFamous, users); //=> [ user1 ]
     */
    var pathEq = _curry3(function pathEq(_path, val, obj) {
        return equals(path(_path, obj), val);
    });

    /**
     * Returns a new list by plucking the same named property off all objects in
     * the list supplied.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig k -> [{k: v}] -> [v]
     * @param {Number|String} key The key name to pluck off of each object.
     * @param {Array} list The array to consider.
     * @return {Array} The list of values for the given key.
     * @see R.props
     * @example
     *
     *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
     *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
     */
    var pluck = _curry2(function pluck(p, list) {
        return map(prop(p), list);
    });

    /**
     * Reasonable analog to SQL `select` statement.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @category Relation
     * @sig [k] -> [{k: v}] -> [{k: v}]
     * @param {Array} props The property names to project
     * @param {Array} objs The objects to query
     * @return {Array} An array of objects with just the `props` properties.
     * @example
     *
     *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
     *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
     *      var kids = [abby, fred];
     *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
     */
    // passing `identity` gives correct arity
    var project = useWith(_map, [
        pickAll,
        identity
    ]);

    /**
     * Returns `true` if the specified object property is equal, in `R.equals`
     * terms, to the given value; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig String -> a -> Object -> Boolean
     * @param {String} name
     * @param {*} val
     * @param {*} obj
     * @return {Boolean}
     * @see R.equals, R.propSatisfies
     * @example
     *
     *      var abby = {name: 'Abby', age: 7, hair: 'blond'};
     *      var fred = {name: 'Fred', age: 12, hair: 'brown'};
     *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};
     *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};
     *      var kids = [abby, fred, rusty, alois];
     *      var hasBrownHair = R.propEq('hair', 'brown');
     *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
     */
    var propEq = _curry3(function propEq(name, val, obj) {
        return propSatisfies(equals(val), name, obj);
    });

    /**
     * Returns `true` if the specified object property is of the given type;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Type
     * @sig Type -> String -> Object -> Boolean
     * @param {Function} type
     * @param {String} name
     * @param {*} obj
     * @return {Boolean}
     * @see R.is, R.propSatisfies
     * @example
     *
     *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
     *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
     *      R.propIs(Number, 'x', {});            //=> false
     */
    var propIs = _curry3(function propIs(type, name, obj) {
        return propSatisfies(is(type), name, obj);
    });

    /**
     * Returns a single item by iterating through the list, successively calling
     * the iterator function and passing it an accumulator value and the current
     * value from the array, and then passing the result to the next call.
     *
     * The iterator function receives two values: *(acc, value)*. It may use
     * `R.reduced` to shortcut the iteration.
     *
     * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
     * arrays), unlike the native `Array.prototype.reduce` method. For more details
     * on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
     *
     * Dispatches to the `reduce` method of the third argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig ((a, b) -> a) -> a -> [b] -> a
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.reduced, R.addIndex
     * @example
     *
     *      var numbers = [1, 2, 3];
     *      var add = (a, b) => a + b;
     *
     *      R.reduce(add, 10, numbers); //=> 16
     */
    var reduce = _curry3(_reduce);

    /**
     * Groups the elements of the list according to the result of calling
     * the String-returning function `keyFn` on each element and reduces the elements
     * of each group to a single value via the reducer function `valueFn`.
     *
     * This function is basically a more general `groupBy` function.
     *
     * @func
     * @memberOf R
     * @since v0.20.0
     * @category List
     * @sig ((a, b) -> a) -> a -> (b -> String) -> [b] -> {String: a}
     * @param {Function} valueFn The function that reduces the elements of each group to a single
     *        value. Receives two values, accumulator for a particular group and the current element.
     * @param {*} acc The (initial) accumulator value for each group.
     * @param {Function} keyFn The function that maps the list's element into a key.
     * @param {Array} list The array to group.
     * @return {Object} An object with the output of `keyFn` for keys, mapped to the output of
     *         `valueFn` for elements which produced that key when passed to `keyFn`.
     * @see R.groupBy, R.reduce
     * @example
     *
     *      var reduceToNamesBy = R.reduceBy((acc, student) => acc.concat(student.name), []);
     *      var namesByGrade = reduceToNamesBy(function(student) {
     *        var score = student.score;
     *        return score < 65 ? 'F' :
     *               score < 70 ? 'D' :
     *               score < 80 ? 'C' :
     *               score < 90 ? 'B' : 'A';
     *      });
     *      var students = [{name: 'Lucy', score: 92},
     *                      {name: 'Drew', score: 85},
     *                      // ...
     *                      {name: 'Bart', score: 62}];
     *      namesByGrade(students);
     *      // {
     *      //   'A': ['Lucy'],
     *      //   'B': ['Drew']
     *      //   // ...,
     *      //   'F': ['Bart']
     *      // }
     */
    var reduceBy = _curryN(4, [], function reduceBy(valueFn, valueAcc, keyFn, list) {
        return _reduce(function (acc, elt) {
            var key = keyFn(elt);
            acc[key] = valueFn(_has(key, acc) ? acc[key] : valueAcc, elt);
            return acc;
        }, {}, list);
    });

    /**
     * The complement of `filter`.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Filterable f => (a -> Boolean) -> f a -> f a
     * @param {Function} pred
     * @param {Array} filterable
     * @return {Array}
     * @see R.filter, R.transduce, R.addIndex
     * @example
     *
     *      var isOdd = (n) => n % 2 === 1;
     *
     *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
     *
     *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
     */
    var reject = _curry2(function reject(pred, filterable) {
        return filter(_complement(pred), filterable);
    });

    /**
     * Returns a fixed list of size `n` containing a specified identical value.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig a -> n -> [a]
     * @param {*} value The value to repeat.
     * @param {Number} n The desired size of the output list.
     * @return {Array} A new array containing `n` `value`s.
     * @example
     *
     *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
     *
     *      var obj = {};
     *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
     *      repeatedObjs[0] === repeatedObjs[1]; //=> true
     */
    var repeat = _curry2(function repeat(value, n) {
        return times(always(value), n);
    });

    /**
     * Adds together all the elements of a list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list An array of numbers
     * @return {Number} The sum of all the numbers in the list.
     * @see R.reduce
     * @example
     *
     *      R.sum([2,4,6,8,100,1]); //=> 121
     */
    var sum = reduce(add, 0);

    /**
     * Returns a new list containing the last `n` elements of the given list.
     * If `n > list.length`, returns a list of `list.length` elements.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n The number of elements to return.
     * @param {Array} xs The collection to consider.
     * @return {Array}
     * @see R.dropLast
     * @example
     *
     *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
     *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
     *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.takeLast(3, 'ramda');               //=> 'mda'
     */
    var takeLast = _curry2(function takeLast(n, xs) {
        return drop(n >= 0 ? xs.length - n : 0, xs);
    });

    /**
     * Initializes a transducer using supplied iterator function. Returns a single
     * item by iterating through the list, successively calling the transformed
     * iterator function and passing it an accumulator value and the current value
     * from the array, and then passing the result to the next call.
     *
     * The iterator function receives two values: *(acc, value)*. It will be
     * wrapped as a transformer to initialize the transducer. A transformer can be
     * passed directly in place of an iterator function. In both cases, iteration
     * may be stopped early with the `R.reduced` function.
     *
     * A transducer is a function that accepts a transformer and returns a
     * transformer and can be composed directly.
     *
     * A transformer is an an object that provides a 2-arity reducing iterator
     * function, step, 0-arity initial value function, init, and 1-arity result
     * extraction function, result. The step function is used as the iterator
     * function in reduce. The result function is used to convert the final
     * accumulator into the return type and in most cases is R.identity. The init
     * function can be used to provide an initial accumulator, but is ignored by
     * transduce.
     *
     * The iteration is performed with R.reduce after initializing the transducer.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category List
     * @sig (c -> c) -> (a,b -> a) -> a -> [b] -> a
     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array. Wrapped as transformer, if necessary, and used to
     *        initialize the transducer
     * @param {*} acc The initial accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.reduce, R.reduced, R.into
     * @example
     *
     *      var numbers = [1, 2, 3, 4];
     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
     *
     *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
     */
    var transduce = curryN(4, function transduce(xf, fn, acc, list) {
        return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
    });

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of the elements
     * of each list. Duplication is determined according to the value returned by
     * applying the supplied predicate to two list elements.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The first and second lists concatenated, with
     *         duplicates removed.
     * @see R.union
     * @example
     *
     *      var l1 = [{a: 1}, {a: 2}];
     *      var l2 = [{a: 1}, {a: 4}];
     *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
     */
    var unionWith = _curry3(function unionWith(pred, list1, list2) {
        return uniqWith(pred, _concat(list1, list2));
    });

    /**
     * Takes a spec object and a test object; returns true if the test satisfies
     * the spec, false otherwise. An object satisfies the spec if, for each of the
     * spec's own properties, accessing that property of the object gives the same
     * value (in `R.equals` terms) as accessing that property of the spec.
     *
     * `whereEq` is a specialization of [`where`](#where).
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Object
     * @sig {String: *} -> {String: *} -> Boolean
     * @param {Object} spec
     * @param {Object} testObj
     * @return {Boolean}
     * @see R.where
     * @example
     *
     *      // pred :: Object -> Boolean
     *      var pred = R.whereEq({a: 1, b: 2});
     *
     *      pred({a: 1});              //=> false
     *      pred({a: 1, b: 2});        //=> true
     *      pred({a: 1, b: 2, c: 3});  //=> true
     *      pred({a: 1, b: 1});        //=> false
     */
    var whereEq = _curry2(function whereEq(spec, testObj) {
        return where(map(equals, spec), testObj);
    });

    var _flatCat = function () {
        var preservingReduced = function (xf) {
            return {
                '@@transducer/init': _xfBase.init,
                '@@transducer/result': function (result) {
                    return xf['@@transducer/result'](result);
                },
                '@@transducer/step': function (result, input) {
                    var ret = xf['@@transducer/step'](result, input);
                    return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
                }
            };
        };
        return function _xcat(xf) {
            var rxf = preservingReduced(xf);
            return {
                '@@transducer/init': _xfBase.init,
                '@@transducer/result': function (result) {
                    return rxf['@@transducer/result'](result);
                },
                '@@transducer/step': function (result, input) {
                    return !isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
                }
            };
        };
    }();

    // Array.prototype.indexOf doesn't exist below IE9
    // manually crawl the list to distinguish between +0 and -0
    // NaN
    // non-zero numbers can utilise Set
    // all these types can utilise Set
    // null can utilise Set
    // anything else not covered above, defer to R.equals
    var _indexOf = function _indexOf(list, a, idx) {
        var inf, item;
        // Array.prototype.indexOf doesn't exist below IE9
        if (typeof list.indexOf === 'function') {
            switch (typeof a) {
            case 'number':
                if (a === 0) {
                    // manually crawl the list to distinguish between +0 and -0
                    inf = 1 / a;
                    while (idx < list.length) {
                        item = list[idx];
                        if (item === 0 && 1 / item === inf) {
                            return idx;
                        }
                        idx += 1;
                    }
                    return -1;
                } else if (a !== a) {
                    // NaN
                    while (idx < list.length) {
                        item = list[idx];
                        if (typeof item === 'number' && item !== item) {
                            return idx;
                        }
                        idx += 1;
                    }
                    return -1;
                }
                // non-zero numbers can utilise Set
                return list.indexOf(a, idx);
            // all these types can utilise Set
            case 'string':
            case 'boolean':
            case 'function':
            case 'undefined':
                return list.indexOf(a, idx);
            case 'object':
                if (a === null) {
                    // null can utilise Set
                    return list.indexOf(a, idx);
                }
            }
        }
        // anything else not covered above, defer to R.equals
        while (idx < list.length) {
            if (equals(list[idx], a)) {
                return idx;
            }
            idx += 1;
        }
        return -1;
    };

    var _xchain = _curry2(function _xchain(f, xf) {
        return map(f, _flatCat(xf));
    });

    /**
     * Takes a list of predicates and returns a predicate that returns true for a
     * given list of arguments if every one of the provided predicates is satisfied
     * by those arguments.
     *
     * The function returned is a curried function whose arity matches that of the
     * highest-arity predicate.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Logic
     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
     * @param {Array} preds
     * @return {Function}
     * @see R.anyPass
     * @example
     *
     *      var isQueen = R.propEq('rank', 'Q');
     *      var isSpade = R.propEq('suit', '');
     *      var isQueenOfSpades = R.allPass([isQueen, isSpade]);
     *
     *      isQueenOfSpades({rank: 'Q', suit: ''}); //=> false
     *      isQueenOfSpades({rank: 'Q', suit: ''}); //=> true
     */
    var allPass = _curry1(function allPass(preds) {
        return curryN(reduce(max, 0, pluck('length', preds)), function () {
            var idx = 0;
            var len = preds.length;
            while (idx < len) {
                if (!preds[idx].apply(this, arguments)) {
                    return false;
                }
                idx += 1;
            }
            return true;
        });
    });

    /**
     * Returns `true` if all elements are unique, in `R.equals` terms, otherwise
     * `false`.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category List
     * @sig [a] -> Boolean
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if all elements are unique, else `false`.
     * @deprecated since v0.20.0
     * @example
     *
     *      R.allUniq(['1', 1]); //=> true
     *      R.allUniq([1, 1]);   //=> false
     *      R.allUniq([[42], [42]]); //=> false
     */
    var allUniq = _curry1(function allUniq(list) {
        var len = list.length;
        var idx = 0;
        while (idx < len) {
            if (_indexOf(list, list[idx], idx + 1) >= 0) {
                return false;
            }
            idx += 1;
        }
        return true;
    });

    /**
     * Takes a list of predicates and returns a predicate that returns true for a
     * given list of arguments if at least one of the provided predicates is
     * satisfied by those arguments.
     *
     * The function returned is a curried function whose arity matches that of the
     * highest-arity predicate.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Logic
     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
     * @param {Array} preds
     * @return {Function}
     * @see R.allPass
     * @example
     *
     *      var gte = R.anyPass([R.gt, R.equals]);
     *
     *      gte(3, 2); //=> true
     *      gte(2, 2); //=> true
     *      gte(2, 3); //=> false
     */
    var anyPass = _curry1(function anyPass(preds) {
        return curryN(reduce(max, 0, pluck('length', preds)), function () {
            var idx = 0;
            var len = preds.length;
            while (idx < len) {
                if (preds[idx].apply(this, arguments)) {
                    return true;
                }
                idx += 1;
            }
            return false;
        });
    });

    /**
     * ap applies a list of functions to a list of values.
     *
     * Dispatches to the `ap` method of the second argument, if present. Also
     * treats functions as applicatives.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Function
     * @sig [f] -> [a] -> [f a]
     * @param {Array} fns An array of functions
     * @param {Array} vs An array of values
     * @return {Array} An array of results of applying each of `fns` to all of `vs` in turn.
     * @example
     *
     *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
     */
    // else
    var ap = _curry2(function ap(applicative, fn) {
        return typeof applicative.ap === 'function' ? applicative.ap(fn) : typeof applicative === 'function' ? curryN(Math.max(applicative.length, fn.length), function () {
            return applicative.apply(this, arguments)(fn.apply(this, arguments));
        }) : // else
        _reduce(function (acc, f) {
            return _concat(acc, map(f, fn));
        }, [], applicative);
    });

    /**
     * Given a spec object recursively mapping properties to functions, creates a
     * function producing an object of the same structure, by mapping each property
     * to the result of calling its associated function with the supplied arguments.
     *
     * @func
     * @memberOf R
     * @since v0.20.0
     * @category Function
     * @sig {k: ((a, b, ..., m) -> v)} -> ((a, b, ..., m) -> {k: v})
     * @param {Object} spec an object recursively mapping properties to functions for
     *        producing the values for these properties.
     * @return {Function} A function that returns an object of the same structure
     * as `spec', with each property set to the value returned by calling its
     * associated function with the supplied arguments.
     * @see R.juxt
     * @example
     *
     *      var getMetrics = R.applySpec({
     *                                      sum: R.add,
     *                                      nested: { mul: R.multiply }
     *                                   });
     *      getMetrics(2, 4); // => { sum: 6, nested: { mul: 8 } }
     */
    var applySpec = _curry1(function applySpec(spec) {
        spec = map(function (v) {
            return typeof v == 'function' ? v : applySpec(v);
        }, spec);
        return curryN(reduce(max, 0, pluck('length', values(spec))), function () {
            var args = arguments;
            return map(function (f) {
                return apply(f, args);
            }, spec);
        });
    });

    /**
     * Returns the result of calling its first argument with the remaining
     * arguments. This is occasionally useful as a converging function for
     * `R.converge`: the left branch can produce a function while the right branch
     * produces a value to be passed to that function as an argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Function
     * @sig (*... -> a),*... -> a
     * @param {Function} fn The function to apply to the remaining arguments.
     * @param {...*} args Any number of positional arguments.
     * @return {*}
     * @see R.apply
     * @example
     *
     *      var indentN = R.pipe(R.times(R.always(' ')),
     *                           R.join(''),
     *                           R.replace(/^(?!$)/gm));
     *
     *      var format = R.converge(R.call, [
     *                                  R.pipe(R.prop('indent'), indentN),
     *                                  R.prop('value')
     *                              ]);
     *
     *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
     */
    var call = curry(function call(fn) {
        return fn.apply(this, _slice(arguments, 1));
    });

    /**
     * `chain` maps a function over a list and concatenates the results. `chain`
     * is also known as `flatMap` in some libraries
     *
     * Dispatches to the `chain` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig (a -> [b]) -> [a] -> [b]
     * @param {Function} fn
     * @param {Array} list
     * @return {Array}
     * @example
     *
     *      var duplicate = n => [n, n];
     *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
     */
    var chain = _curry2(_dispatchable('chain', _xchain, function chain(fn, monad) {
        if (typeof monad === 'function') {
            return function () {
                return monad.call(this, fn.apply(this, arguments)).apply(this, arguments);
            };
        }
        return _makeFlat(false)(map(fn, monad));
    }));

    /**
     * Returns a function, `fn`, which encapsulates if/else-if/else logic.
     * `R.cond` takes a list of [predicate, transform] pairs. All of the arguments
     * to `fn` are applied to each of the predicates in turn until one returns a
     * "truthy" value, at which point `fn` returns the result of applying its
     * arguments to the corresponding transformer. If none of the predicates
     * matches, `fn` returns undefined.
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category Logic
     * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
     * @param {Array} pairs
     * @return {Function}
     * @example
     *
     *      var fn = R.cond([
     *        [R.equals(0),   R.always('water freezes at 0C')],
     *        [R.equals(100), R.always('water boils at 100C')],
     *        [R.T,           temp => 'nothing special happens at ' + temp + 'C']
     *      ]);
     *      fn(0); //=> 'water freezes at 0C'
     *      fn(50); //=> 'nothing special happens at 50C'
     *      fn(100); //=> 'water boils at 100C'
     */
    var cond = _curry1(function cond(pairs) {
        var arity = reduce(max, 0, map(function (pair) {
            return pair[0].length;
        }, pairs));
        return _arity(arity, function () {
            var idx = 0;
            while (idx < pairs.length) {
                if (pairs[idx][0].apply(this, arguments)) {
                    return pairs[idx][1].apply(this, arguments);
                }
                idx += 1;
            }
        });
    });

    /**
     * Wraps a constructor function inside a curried function that can be called
     * with the same arguments and returns the same type. The arity of the function
     * returned is specified to allow using variadic constructor functions.
     *
     * @func
     * @memberOf R
     * @since v0.4.0
     * @category Function
     * @sig Number -> (* -> {*}) -> (* -> {*})
     * @param {Number} n The arity of the constructor function.
     * @param {Function} Fn The constructor function to wrap.
     * @return {Function} A wrapped, curried constructor function.
     * @example
     *
     *      // Variadic constructor function
     *      var Widget = () => {
     *        this.children = Array.prototype.slice.call(arguments);
     *        // ...
     *      };
     *      Widget.prototype = {
     *        // ...
     *      };
     *      var allConfigs = [
     *        // ...
     *      ];
     *      R.map(R.constructN(1, Widget), allConfigs); // a list of Widgets
     */
    var constructN = _curry2(function constructN(n, Fn) {
        if (n > 10) {
            throw new Error('Constructor with greater than ten arguments');
        }
        if (n === 0) {
            return function () {
                return new Fn();
            };
        }
        return curry(nAry(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
            switch (arguments.length) {
            case 1:
                return new Fn($0);
            case 2:
                return new Fn($0, $1);
            case 3:
                return new Fn($0, $1, $2);
            case 4:
                return new Fn($0, $1, $2, $3);
            case 5:
                return new Fn($0, $1, $2, $3, $4);
            case 6:
                return new Fn($0, $1, $2, $3, $4, $5);
            case 7:
                return new Fn($0, $1, $2, $3, $4, $5, $6);
            case 8:
                return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
            case 9:
                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
            case 10:
                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
            }
        }));
    });

    /**
     * Accepts a converging function and a list of branching functions and returns
     * a new function. When invoked, this new function is applied to some
     * arguments, each branching function is applied to those same arguments. The
     * results of each branching function are passed as arguments to the converging
     * function to produce the return value.
     *
     * @func
     * @memberOf R
     * @since v0.4.2
     * @category Function
     * @sig (x1 -> x2 -> ... -> z) -> [(a -> b -> ... -> x1), (a -> b -> ... -> x2), ...] -> (a -> b -> ... -> z)
     * @param {Function} after A function. `after` will be invoked with the return values of
     *        `fn1` and `fn2` as its arguments.
     * @param {Array} functions A list of functions.
     * @return {Function} A new function.
     * @example
     *
     *      var add = (a, b) => a + b;
     *      var multiply = (a, b) => a * b;
     *      var subtract = (a, b) => a - b;
     *
     *      // multiply( add(1, 2), subtract(1, 2) );
     *      R.converge(multiply, [add, subtract])(1, 2); //=> -3
     *
     *      var add3 = (a, b, c) => a + b + c;
     *      R.converge(add3, [multiply, add, subtract])(1, 2); //=> 4
     */
    var converge = _curry2(function converge(after, fns) {
        return curryN(reduce(max, 0, pluck('length', fns)), function () {
            var args = arguments;
            var context = this;
            return after.apply(context, _map(function (fn) {
                return fn.apply(context, args);
            }, fns));
        });
    });

    /**
     * Counts the elements of a list according to how many match each value of a
     * key generated by the supplied function. Returns an object mapping the keys
     * produced by `fn` to the number of occurrences in the list. Note that all
     * keys are coerced to strings because of how JavaScript objects work.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig (a -> String) -> [a] -> {*}
     * @param {Function} fn The function used to map values to keys.
     * @param {Array} list The list to count elements from.
     * @return {Object} An object mapping keys to number of occurrences in the list.
     * @example
     *
     *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
     *      var letters = R.split('', 'abcABCaaaBBc');
     *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
     *      R.countBy(R.toLower)(letters);   //=> {'a': 5, 'b': 4, 'c': 3}
     */
    var countBy = reduceBy(function (acc, elem) {
        return acc + 1;
    }, 0);

    /**
     * Returns a new list without any consecutively repeating elements. Equality is
     * determined by applying the supplied predicate two consecutive elements. The
     * first element in a series of equal element is the one being preserved.
     *
     * Dispatches to the `dropRepeatsWith` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig (a, a -> Boolean) -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list The array to consider.
     * @return {Array} `list` without repeating elements.
     * @see R.transduce
     * @example
     *
     *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
     *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]
     */
    var dropRepeatsWith = _curry2(_dispatchable('dropRepeatsWith', _xdropRepeatsWith, function dropRepeatsWith(pred, list) {
        var result = [];
        var idx = 1;
        var len = list.length;
        if (len !== 0) {
            result[0] = list[0];
            while (idx < len) {
                if (!pred(last(result), list[idx])) {
                    result[result.length] = list[idx];
                }
                idx += 1;
            }
        }
        return result;
    }));

    /**
     * Takes a function and two values in its domain and returns `true` if the
     * values map to the same value in the codomain; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Relation
     * @sig (a -> b) -> a -> a -> Boolean
     * @param {Function} f
     * @param {*} x
     * @param {*} y
     * @return {Boolean}
     * @example
     *
     *      R.eqBy(Math.abs, 5, -5); //=> true
     */
    var eqBy = _curry3(function eqBy(f, x, y) {
        return equals(f(x), f(y));
    });

    /**
     * Reports whether two objects have the same value, in `R.equals` terms, for
     * the specified property. Useful as a curried predicate.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig k -> {k: v} -> {k: v} -> Boolean
     * @param {String} prop The name of the property to compare
     * @param {Object} obj1
     * @param {Object} obj2
     * @return {Boolean}
     *
     * @example
     *
     *      var o1 = { a: 1, b: 2, c: 3, d: 4 };
     *      var o2 = { a: 10, b: 20, c: 3, d: 40 };
     *      R.eqProps('a', o1, o2); //=> false
     *      R.eqProps('c', o1, o2); //=> true
     */
    var eqProps = _curry3(function eqProps(prop, obj1, obj2) {
        return equals(obj1[prop], obj2[prop]);
    });

    /**
     * Splits a list into sub-lists stored in an object, based on the result of
     * calling a String-returning function on each element, and grouping the
     * results according to values returned.
     *
     * Dispatches to the `groupBy` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> String) -> [a] -> {String: [a]}
     * @param {Function} fn Function :: a -> String
     * @param {Array} list The array to group
     * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
     *         that produced that key when passed to `fn`.
     * @see R.transduce
     * @example
     *
     *      var byGrade = R.groupBy(function(student) {
     *        var score = student.score;
     *        return score < 65 ? 'F' :
     *               score < 70 ? 'D' :
     *               score < 80 ? 'C' :
     *               score < 90 ? 'B' : 'A';
     *      });
     *      var students = [{name: 'Abby', score: 84},
     *                      {name: 'Eddy', score: 58},
     *                      // ...
     *                      {name: 'Jack', score: 69}];
     *      byGrade(students);
     *      // {
     *      //   'A': [{name: 'Dianne', score: 99}],
     *      //   'B': [{name: 'Abby', score: 84}]
     *      //   // ...,
     *      //   'F': [{name: 'Eddy', score: 58}]
     *      // }
     */
    var groupBy = _curry2(_dispatchable('groupBy', _xgroupBy, reduceBy(function (acc, item) {
        if (acc == null) {
            acc = [];
        }
        acc.push(item);
        return acc;
    }, null)));

    /**
     * Given a function that generates a key, turns a list of objects into an
     * object indexing the objects by the given key. Note that if multiple
     * objects generate the same value for the indexing key only the last value
     * will be included in the generated object.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig (a -> String) -> [{k: v}] -> {k: {k: v}}
     * @param {Function} fn Function :: a -> String
     * @param {Array} array The array of objects to index
     * @return {Object} An object indexing each array element by the given property.
     * @example
     *
     *      var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];
     *      R.indexBy(R.prop('id'), list);
     *      //=> {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}}
     */
    var indexBy = reduceBy(function (acc, elem) {
        return elem;
    }, null);

    /**
     * Returns the position of the first occurrence of an item in an array, or -1
     * if the item is not included in the array. `R.equals` is used to determine
     * equality.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> Number
     * @param {*} target The item to find.
     * @param {Array} xs The array to search in.
     * @return {Number} the index of the target, or -1 if the target is not found.
     * @see R.lastIndexOf
     * @example
     *
     *      R.indexOf(3, [1,2,3,4]); //=> 2
     *      R.indexOf(10, [1,2,3,4]); //=> -1
     */
    var indexOf = _curry2(function indexOf(target, xs) {
        return typeof xs.indexOf === 'function' && !_isArray(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
    });

    /**
     * juxt applies a list of functions to a list of values.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Function
     * @sig [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])
     * @param {Array} fns An array of functions
     * @return {Function} A function that returns a list of values after applying each of the original `fns` to its parameters.
     * @see R.applySpec
     * @example
     *
     *      var range = R.juxt([Math.min, Math.max]);
     *      range(3, 4, 9, -3); //=> [-3, 9]
     */
    var juxt = _curry1(function juxt(fns) {
        return converge(_arrayOf, fns);
    });

    /**
     * Returns a lens for the given getter and setter functions. The getter "gets"
     * the value of the focus; the setter "sets" the value of the focus. The setter
     * should not mutate the data structure.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
     * @param {Function} getter
     * @param {Function} setter
     * @return {Lens}
     * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
     * @example
     *
     *      var xLens = R.lens(R.prop('x'), R.assoc('x'));
     *
     *      R.view(xLens, {x: 1, y: 2});            //=> 1
     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
     */
    var lens = _curry2(function lens(getter, setter) {
        return function (toFunctorFn) {
            return function (target) {
                return map(function (focus) {
                    return setter(focus, target);
                }, toFunctorFn(getter(target)));
            };
        };
    });

    /**
     * Returns a lens whose focus is the specified index.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Number -> Lens s a
     * @param {Number} n
     * @return {Lens}
     * @see R.view, R.set, R.over
     * @example
     *
     *      var headLens = R.lensIndex(0);
     *
     *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
     *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
     *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
     */
    var lensIndex = _curry1(function lensIndex(n) {
        return lens(nth(n), update(n));
    });

    /**
     * Returns a lens whose focus is the specified path.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig [String] -> Lens s a
     * @param {Array} path The path to use.
     * @return {Lens}
     * @see R.view, R.set, R.over
     * @example
     *
     *      var xyLens = R.lensPath(['x', 'y']);
     *
     *      R.view(xyLens, {x: {y: 2, z: 3}});            //=> 2
     *      R.set(xyLens, 4, {x: {y: 2, z: 3}});          //=> {x: {y: 4, z: 3}}
     *      R.over(xyLens, R.negate, {x: {y: 2, z: 3}});  //=> {x: {y: -2, z: 3}}
     */
    var lensPath = _curry1(function lensPath(p) {
        return lens(path(p), assocPath(p));
    });

    /**
     * Returns a lens whose focus is the specified property.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig String -> Lens s a
     * @param {String} k
     * @return {Lens}
     * @see R.view, R.set, R.over
     * @example
     *
     *      var xLens = R.lensProp('x');
     *
     *      R.view(xLens, {x: 1, y: 2});            //=> 1
     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
     */
    var lensProp = _curry1(function lensProp(k) {
        return lens(prop(k), assoc(k));
    });

    /**
     * "lifts" a function to be the specified arity, so that it may "map over" that
     * many lists, Functions or other objects that satisfy the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Function
     * @sig Number -> (*... -> *) -> ([*]... -> [*])
     * @param {Function} fn The function to lift into higher context
     * @return {Function} The lifted function.
     * @see R.lift, R.ap
     * @example
     *
     *      var madd3 = R.liftN(3, R.curryN(3, (...args) => R.sum(args)));
     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
     */
    var liftN = _curry2(function liftN(arity, fn) {
        var lifted = curryN(arity, fn);
        return curryN(arity, function () {
            return _reduce(ap, map(lifted, arguments[0]), _slice(arguments, 1));
        });
    });

    /**
     * Returns the mean of the given list of numbers.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list
     * @return {Number}
     * @example
     *
     *      R.mean([2, 7, 9]); //=> 6
     *      R.mean([]); //=> NaN
     */
    var mean = _curry1(function mean(list) {
        return sum(list) / list.length;
    });

    /**
     * Returns the median of the given list of numbers.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list
     * @return {Number}
     * @example
     *
     *      R.median([2, 9, 7]); //=> 7
     *      R.median([7, 2, 10, 9]); //=> 8
     *      R.median([]); //=> NaN
     */
    var median = _curry1(function median(list) {
        var len = list.length;
        if (len === 0) {
            return NaN;
        }
        var width = 2 - len % 2;
        var idx = (len - width) / 2;
        return mean(_slice(list).sort(function (a, b) {
            return a < b ? -1 : a > b ? 1 : 0;
        }).slice(idx, idx + width));
    });

    /**
     * Takes a predicate and a list or other "filterable" object and returns the
     * pair of filterable objects of the same type of elements which do and do not
     * satisfy, the predicate, respectively.
     *
     * @func
     * @memberOf R
     * @since v0.1.4
     * @category List
     * @sig Filterable f => (a -> Boolean) -> f a -> [f a, f a]
     * @param {Function} pred A predicate to determine which side the element belongs to.
     * @param {Array} filterable the list (or other filterable) to partition.
     * @return {Array} An array, containing first the subset of elements that satisfy the
     *         predicate, and second the subset of elements that do not satisfy.
     * @see R.filter, R.reject
     * @example
     *
     *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);
     *      // => [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
     *
     *      R.partition(R.contains('s'), { a: 'sss', b: 'ttt', foo: 'bars' });
     *      // => [ { a: 'sss', foo: 'bars' }, { b: 'ttt' }  ]
     */
    var partition = juxt([
        filter,
        reject
    ]);

    /**
     * Performs left-to-right function composition. The leftmost function may have
     * any arity; the remaining functions must be unary.
     *
     * In some libraries this function is named `sequence`.
     *
     * **Note:** The result of pipe is not automatically curried.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.compose
     * @example
     *
     *      var f = R.pipe(Math.pow, R.negate, R.inc);
     *
     *      f(3, 4); // -(3^4) + 1
     */
    var pipe = function pipe() {
        if (arguments.length === 0) {
            throw new Error('pipe requires at least one argument');
        }
        return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
    };

    /**
     * Performs left-to-right composition of one or more Promise-returning
     * functions. The leftmost function may have any arity; the remaining functions
     * must be unary.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Function
     * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.composeP
     * @example
     *
     *      //  followersForUser :: String -> Promise [User]
     *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
     */
    var pipeP = function pipeP() {
        if (arguments.length === 0) {
            throw new Error('pipeP requires at least one argument');
        }
        return _arity(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));
    };

    /**
     * Multiplies together all the elements of a list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list An array of numbers
     * @return {Number} The product of all the numbers in the list.
     * @see R.reduce
     * @example
     *
     *      R.product([2,4,6,8,100,1]); //=> 38400
     */
    var product = reduce(multiply, 1);

    /**
     * Transforms a [Traversable](https://github.com/fantasyland/fantasy-land#traversable)
     * of [Applicative](https://github.com/fantasyland/fantasy-land#applicative) into an
     * Applicative of Traversable.
     *
     * Dispatches to the `sequence` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig (Applicative f, Traversable t) => (a -> f a) -> t (f a) -> f (t a)
     * @param {Function} of
     * @param {*} traversable
     * @return {*}
     * @see R.traverse
     * @example
     *
     *      R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
     *      R.sequence(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
     *
     *      R.sequence(R.of, Just([1, 2, 3])); //=> [Just(1), Just(2), Just(3)]
     *      R.sequence(R.of, Nothing());       //=> [Nothing()]
     */
    var sequence = _curry2(function sequence(of, traversable) {
        return typeof traversable.sequence === 'function' ? traversable.sequence(of) : reduceRight(function (acc, x) {
            return ap(map(prepend, x), acc);
        }, of([]), traversable);
    });

    /**
     * Maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning
     * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),
     * then uses [`sequence`](#sequence) to transform the resulting Traversable of Applicative
     * into an Applicative of Traversable.
     *
     * Dispatches to the `sequence` method of the third argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig (Applicative f, Traversable t) => (a -> f a) -> (a -> f b) -> t a -> f (t b)
     * @param {Function} of
     * @param {Function} f
     * @param {*} traversable
     * @return {*}
     * @see R.sequence
     * @example
     *
     *      // Returns `Nothing` if the given divisor is `0`
     *      safeDiv = n => d => d === 0 ? Nothing() : Just(n / d)
     *
     *      R.traverse(Maybe.of, safeDiv(10), [2, 4, 5]); //=> Just([5, 2.5, 2])
     *      R.traverse(Maybe.of, safeDiv(10), [2, 0, 5]); //=> Nothing
     */
    var traverse = _curry3(function traverse(of, f, traversable) {
        return sequence(of, map(f, traversable));
    });

    /**
     * Shorthand for `R.chain(R.identity)`, which removes one level of nesting from
     * any [Chain](https://github.com/fantasyland/fantasy-land#chain).
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig Chain c => c (c a) -> c a
     * @param {*} list
     * @return {*}
     * @see R.flatten, R.chain
     * @example
     *
     *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
     *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
     */
    var unnest = chain(_identity);

    var _contains = function _contains(a, list) {
        return _indexOf(list, a, 0) >= 0;
    };

    //  mapPairs :: (Object, [String]) -> [String]
    var _toString = function _toString(x, seen) {
        var recur = function recur(y) {
            var xs = seen.concat([x]);
            return _contains(y, xs) ? '<Circular>' : _toString(y, xs);
        };
        //  mapPairs :: (Object, [String]) -> [String]
        var mapPairs = function (obj, keys) {
            return _map(function (k) {
                return _quote(k) + ': ' + recur(obj[k]);
            }, keys.slice().sort());
        };
        switch (Object.prototype.toString.call(x)) {
        case '[object Arguments]':
            return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';
        case '[object Array]':
            return '[' + _map(recur, x).concat(mapPairs(x, reject(function (k) {
                return /^\d+$/.test(k);
            }, keys(x)))).join(', ') + ']';
        case '[object Boolean]':
            return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
        case '[object Date]':
            return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString(x))) + ')';
        case '[object Null]':
            return 'null';
        case '[object Number]':
            return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
        case '[object String]':
            return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);
        case '[object Undefined]':
            return 'undefined';
        default:
            if (typeof x.toString === 'function') {
                var repr = x.toString();
                if (repr !== '[object Object]') {
                    return repr;
                }
            }
            return '{' + mapPairs(x, keys(x)).join(', ') + '}';
        }
    };

    /**
     * Performs right-to-left function composition. The rightmost function may have
     * any arity; the remaining functions must be unary.
     *
     * **Note:** The result of compose is not automatically curried.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.pipe
     * @example
     *
     *      var f = R.compose(R.inc, R.negate, Math.pow);
     *
     *      f(3, 4); // -(3^4) + 1
     */
    var compose = function compose() {
        if (arguments.length === 0) {
            throw new Error('compose requires at least one argument');
        }
        return pipe.apply(this, reverse(arguments));
    };

    /**
     * Returns the right-to-left Kleisli composition of the provided functions,
     * each of which must return a value of a type supported by [`chain`](#chain).
     *
     * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), R.chain(f))`.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Function
     * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (m a -> m z)
     * @param {...Function}
     * @return {Function}
     * @see R.pipeK
     * @example
     *
     *      //  parseJson :: String -> Maybe *
     *      //  get :: String -> Object -> Maybe *
     *
     *      //  getStateCode :: Maybe String -> Maybe String
     *      var getStateCode = R.composeK(
     *        R.compose(Maybe.of, R.toUpper),
     *        get('state'),
     *        get('address'),
     *        get('user'),
     *        parseJson
     *      );
     *
     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
     *      //=> Just('NY')
     *      getStateCode(Maybe.of('[Invalid JSON]'));
     *      //=> Nothing()
     */
    var composeK = function composeK() {
        return compose.apply(this, prepend(identity, map(chain, arguments)));
    };

    /**
     * Performs right-to-left composition of one or more Promise-returning
     * functions. The rightmost function may have any arity; the remaining
     * functions must be unary.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Function
     * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.pipeP
     * @example
     *
     *      //  followersForUser :: String -> Promise [User]
     *      var followersForUser = R.composeP(db.getFollowers, db.getUserById);
     */
    var composeP = function composeP() {
        if (arguments.length === 0) {
            throw new Error('composeP requires at least one argument');
        }
        return pipeP.apply(this, reverse(arguments));
    };

    /**
     * Wraps a constructor function inside a curried function that can be called
     * with the same arguments and returns the same type.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (* -> {*}) -> (* -> {*})
     * @param {Function} Fn The constructor function to wrap.
     * @return {Function} A wrapped, curried constructor function.
     * @example
     *
     *      // Constructor function
     *      var Widget = config => {
     *        // ...
     *      };
     *      Widget.prototype = {
     *        // ...
     *      };
     *      var allConfigs = [
     *        // ...
     *      ];
     *      R.map(R.construct(Widget), allConfigs); // a list of Widgets
     */
    var construct = _curry1(function construct(Fn) {
        return constructN(Fn.length, Fn);
    });

    /**
     * Returns `true` if the specified value is equal, in `R.equals` terms, to at
     * least one element of the given list; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> Boolean
     * @param {Object} a The item to compare against.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the item is in the list, `false` otherwise.
     * @see R.any
     * @example
     *
     *      R.contains(3, [1, 2, 3]); //=> true
     *      R.contains(4, [1, 2, 3]); //=> false
     *      R.contains([42], [[42]]); //=> true
     */
    var contains = _curry2(_contains);

    /**
     * Finds the set (i.e. no duplicates) of all elements in the first list not
     * contained in the second list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig [*] -> [*] -> [*]
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The elements in `list1` that are not in `list2`.
     * @see R.differenceWith
     * @example
     *
     *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
     *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
     */
    var difference = _curry2(function difference(first, second) {
        var out = [];
        var idx = 0;
        var firstLen = first.length;
        while (idx < firstLen) {
            if (!_contains(first[idx], second) && !_contains(first[idx], out)) {
                out[out.length] = first[idx];
            }
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a new list without any consecutively repeating elements. `R.equals`
     * is used to determine equality.
     *
     * Dispatches to the `dropRepeats` method of the first argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig [a] -> [a]
     * @param {Array} list The array to consider.
     * @return {Array} `list` without repeating elements.
     * @see R.transduce
     * @example
     *
     *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
     */
    var dropRepeats = _curry1(_dispatchable('dropRepeats', _xdropRepeatsWith(equals), dropRepeatsWith(equals)));

    /**
     * "lifts" a function of arity > 1 so that it may "map over" a list, Function or other
     * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Function
     * @sig (*... -> *) -> ([*]... -> [*])
     * @param {Function} fn The function to lift into higher context
     * @return {Function} The lifted function.
     * @see R.liftN
     * @example
     *
     *      var madd3 = R.lift(R.curry((a, b, c) => a + b + c));
     *
     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
     *
     *      var madd5 = R.lift(R.curry((a, b, c, d, e) => a + b + c + d + e));
     *
     *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]
     */
    var lift = _curry1(function lift(fn) {
        return liftN(fn.length, fn);
    });

    /**
     * Returns a partial copy of an object omitting the keys specified.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [String] -> {String: *} -> {String: *}
     * @param {Array} names an array of String property names to omit from the new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with properties from `names` not on it.
     * @see R.pick
     * @example
     *
     *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
     */
    var omit = _curry2(function omit(names, obj) {
        var result = {};
        for (var prop in obj) {
            if (!_contains(prop, names)) {
                result[prop] = obj[prop];
            }
        }
        return result;
    });

    /**
     * Returns the left-to-right Kleisli composition of the provided functions,
     * each of which must return a value of a type supported by [`chain`](#chain).
     *
     * `R.pipeK(f, g, h)` is equivalent to `R.pipe(R.chain(f), R.chain(g), R.chain(h))`.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Function
     * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (m a -> m z)
     * @param {...Function}
     * @return {Function}
     * @see R.composeK
     * @example
     *
     *      //  parseJson :: String -> Maybe *
     *      //  get :: String -> Object -> Maybe *
     *
     *      //  getStateCode :: Maybe String -> Maybe String
     *      var getStateCode = R.pipeK(
     *        parseJson,
     *        get('user'),
     *        get('address'),
     *        get('state'),
     *        R.compose(Maybe.of, R.toUpper)
     *      );
     *
     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
     *      //=> Just('NY')
     *      getStateCode(Maybe.of('[Invalid JSON]'));
     *      //=> Nothing()
     */
    var pipeK = function pipeK() {
        return composeK.apply(this, reverse(arguments));
    };

    /**
     * Returns the string representation of the given value. `eval`'ing the output
     * should result in a value equivalent to the input value. Many of the built-in
     * `toString` methods do not satisfy this requirement.
     *
     * If the given value is an `[object Object]` with a `toString` method other
     * than `Object.prototype.toString`, this method is invoked with no arguments
     * to produce the return value. This means user-defined constructor functions
     * can provide a suitable `toString` method. For example:
     *
     *     function Point(x, y) {
     *       this.x = x;
     *       this.y = y;
     *     }
     *
     *     Point.prototype.toString = function() {
     *       return 'new Point(' + this.x + ', ' + this.y + ')';
     *     };
     *
     *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category String
     * @sig * -> String
     * @param {*} val
     * @return {String}
     * @example
     *
     *      R.toString(42); //=> '42'
     *      R.toString('abc'); //=> '"abc"'
     *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
     *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
     *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
     */
    var toString = _curry1(function toString(val) {
        return _toString(val, []);
    });

    /**
     * Returns a new list without values in the first argument.
     * `R.equals` is used to determine equality.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig [a] -> [a] -> [a]
     * @param {Array} list1 The values to be removed from `list2`.
     * @param {Array} list2 The array to remove values from.
     * @return {Array} The new array without values in `list1`.
     * @see R.transduce
     * @example
     *
     *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]
     */
    var without = _curry2(function (xs, list) {
        return reject(flip(_contains)(xs), list);
    });

    // A simple Set type that honours R.equals semantics
    /* globals Set */
    /**
       * Combines the logic for checking whether an item is a member of the set and
       * for adding a new item to the set.
       *
       * @param item       The item to check or add to the Set instance.
       * @param shouldAdd  If true, the item will be added to the set if it doesn't
       *                   already exist.
       * @param set        The set instance to check or add to.
       * @return {boolean} When shouldAdd is true, this will return true when a new
       *                   item was added otherwise false. When shouldAdd is false,
       *                   this will return true if the item already exists, otherwise
       *                   false.
       */
    // distinguish between +0 and -0
    // these types can all utilise Set
    // set._items['boolean'] holds a two element array
    // representing [ falseExists, trueExists ]
    // compare functions for reference equality
    /* falls through */
    // reduce the search size of heterogeneous sets by creating buckets
    // for each type.
    // scan through all previously applied items
    var _Set = function () {
        function _Set() {
            /* globals Set */
            this._nativeSet = typeof Set === 'function' ? new Set() : null;
            this._items = {};
        }
        _Set.prototype.add = function (item) {
            return hasOrAdd(item, true, this);
        };
        _Set.prototype.has = function (item) {
            return hasOrAdd(item, false, this);
        };
        /**
       * Combines the logic for checking whether an item is a member of the set and
       * for adding a new item to the set.
       *
       * @param item       The item to check or add to the Set instance.
       * @param shouldAdd  If true, the item will be added to the set if it doesn't
       *                   already exist.
       * @param set        The set instance to check or add to.
       * @return {boolean} When shouldAdd is true, this will return true when a new
       *                   item was added otherwise false. When shouldAdd is false,
       *                   this will return true if the item already exists, otherwise
       *                   false.
       */
        function hasOrAdd(item, shouldAdd, set) {
            var type = typeof item;
            var prevSize, newSize;
            switch (type) {
            case 'string':
            case 'number':
                // distinguish between +0 and -0
                if (item === 0 && !set._items['-0'] && 1 / item === -Infinity) {
                    if (shouldAdd) {
                        set._items['-0'] = true;
                    }
                    return shouldAdd;
                }
                // these types can all utilise Set
                if (set._nativeSet !== null) {
                    if (shouldAdd) {
                        prevSize = set._nativeSet.size;
                        set._nativeSet.add(item);
                        newSize = set._nativeSet.size;
                        return newSize > prevSize;
                    } else {
                        return set._nativeSet.has(item);
                    }
                } else {
                    if (!(type in set._items)) {
                        if (shouldAdd) {
                            set._items[type] = {};
                            set._items[type][item] = true;
                        }
                        return shouldAdd;
                    } else if (item in set._items[type]) {
                        return !shouldAdd;
                    } else {
                        if (shouldAdd) {
                            set._items[type][item] = true;
                        }
                        return shouldAdd;
                    }
                }
            case 'boolean':
                // set._items['boolean'] holds a two element array
                // representing [ falseExists, trueExists ]
                if (type in set._items) {
                    var bIdx = item ? 1 : 0;
                    if (set._items[type][bIdx]) {
                        return !shouldAdd;
                    } else {
                        if (shouldAdd) {
                            set._items[type][bIdx] = true;
                        }
                        return shouldAdd;
                    }
                } else {
                    if (shouldAdd) {
                        set._items[type] = item ? [
                            false,
                            true
                        ] : [
                            true,
                            false
                        ];
                    }
                    return shouldAdd;
                }
            case 'function':
                // compare functions for reference equality
                if (set._nativeSet !== null) {
                    if (shouldAdd) {
                        prevSize = set._nativeSet.size;
                        set._nativeSet.add(item);
                        newSize = set._nativeSet.size;
                        return newSize > prevSize;
                    } else {
                        return set._nativeSet.has(item);
                    }
                } else {
                    if (!(type in set._items)) {
                        if (shouldAdd) {
                            set._items[type] = [item];
                        }
                        return shouldAdd;
                    }
                    if (!_contains(item, set._items[type])) {
                        if (shouldAdd) {
                            set._items[type].push(item);
                        }
                        return shouldAdd;
                    }
                }
                return !shouldAdd;
            case 'undefined':
                if (set._items[type]) {
                    return !shouldAdd;
                } else {
                    if (shouldAdd) {
                        set._items[type] = true;
                    }
                    return shouldAdd;
                }
            case 'object':
                if (item === null) {
                    if (!set._items['null']) {
                        if (shouldAdd) {
                            set._items['null'] = true;
                        }
                        return shouldAdd;
                    }
                    return !shouldAdd;
                }
            /* falls through */
            default:
                // reduce the search size of heterogeneous sets by creating buckets
                // for each type.
                type = Object.prototype.toString.call(item);
                if (!(type in set._items)) {
                    if (shouldAdd) {
                        set._items[type] = [item];
                    }
                    return shouldAdd;
                }
                // scan through all previously applied items
                if (!_contains(item, set._items[type])) {
                    if (shouldAdd) {
                        set._items[type].push(item);
                    }
                    return shouldAdd;
                }
                return !shouldAdd;
            }
        }
        return _Set;
    }();

    /**
     * A function wrapping calls to the two functions in an `&&` operation,
     * returning the result of the first function if it is false-y and the result
     * of the second function otherwise. Note that this is short-circuited,
     * meaning that the second function will not be invoked if the first returns a
     * false-y value.
     *
     * In addition to functions, `R.both` also accepts any fantasy-land compatible
     * applicative functor.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category Logic
     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
     * @param {Function} f a predicate
     * @param {Function} g another predicate
     * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
     * @see R.and
     * @example
     *
     *      var gt10 = x => x > 10;
     *      var even = x => x % 2 === 0;
     *      var f = R.both(gt10, even);
     *      f(100); //=> true
     *      f(101); //=> false
     */
    var both = _curry2(function both(f, g) {
        return _isFunction(f) ? function _both() {
            return f.apply(this, arguments) && g.apply(this, arguments);
        } : lift(and)(f, g);
    });

    /**
     * Takes a function `f` and returns a function `g` such that:
     *
     *   - applying `g` to zero or more arguments will give __true__ if applying
     *     the same arguments to `f` gives a logical __false__ value; and
     *
     *   - applying `g` to zero or more arguments will give __false__ if applying
     *     the same arguments to `f` gives a logical __true__ value.
     *
     * `R.complement` will work on all other functors as well.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category Logic
     * @sig (*... -> *) -> (*... -> Boolean)
     * @param {Function} f
     * @return {Function}
     * @see R.not
     * @example
     *
     *      var isEven = n => n % 2 === 0;
     *      var isOdd = R.complement(isEven);
     *      isOdd(21); //=> true
     *      isOdd(42); //=> false
     */
    var complement = lift(not);

    /**
     * A function wrapping calls to the two functions in an `||` operation,
     * returning the result of the first function if it is truth-y and the result
     * of the second function otherwise. Note that this is short-circuited,
     * meaning that the second function will not be invoked if the first returns a
     * truth-y value.
     *
     * In addition to functions, `R.either` also accepts any fantasy-land compatible
     * applicative functor.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category Logic
     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
     * @param {Function} f a predicate
     * @param {Function} g another predicate
     * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
     * @see R.or
     * @example
     *
     *      var gt10 = x => x > 10;
     *      var even = x => x % 2 === 0;
     *      var f = R.either(gt10, even);
     *      f(101); //=> true
     *      f(8); //=> true
     */
    var either = _curry2(function either(f, g) {
        return _isFunction(f) ? function _either() {
            return f.apply(this, arguments) || g.apply(this, arguments);
        } : lift(or)(f, g);
    });

    /**
     * Turns a named method with a specified arity into a function that can be
     * called directly supplied with arguments and a target object.
     *
     * The returned function is curried and accepts `arity + 1` parameters where
     * the final parameter is the target object.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
     * @param {Number} arity Number of arguments the returned function should take
     *        before the target object.
     * @param {String} method Name of the method to call.
     * @return {Function} A new curried function.
     * @example
     *
     *      var sliceFrom = R.invoker(1, 'slice');
     *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
     *      var sliceFrom6 = R.invoker(2, 'slice')(6);
     *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
     */
    var invoker = _curry2(function invoker(arity, method) {
        return curryN(arity + 1, function () {
            var target = arguments[arity];
            if (target != null && is(Function, target[method])) {
                return target[method].apply(target, _slice(arguments, 0, arity));
            }
            throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
        });
    });

    /**
     * Returns a string made by inserting the `separator` between each element and
     * concatenating all the elements into a single string.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig String -> [a] -> String
     * @param {Number|String} separator The string used to separate the elements.
     * @param {Array} xs The elements to join into a string.
     * @return {String} str The string made by concatenating `xs` with `separator`.
     * @see R.split
     * @example
     *
     *      var spacer = R.join(' ');
     *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
     *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
     */
    var join = invoker(1, 'join');

    /**
     * Creates a new function that, when invoked, caches the result of calling `fn`
     * for a given argument set and returns the result. Subsequent calls to the
     * memoized `fn` with the same argument set will not result in an additional
     * call to `fn`; instead, the cached result for that set of arguments will be
     * returned.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (*... -> a) -> (*... -> a)
     * @param {Function} fn The function to memoize.
     * @return {Function} Memoized version of `fn`.
     * @example
     *
     *      var count = 0;
     *      var factorial = R.memoize(n => {
     *        count += 1;
     *        return R.product(R.range(1, n + 1));
     *      });
     *      factorial(5); //=> 120
     *      factorial(5); //=> 120
     *      factorial(5); //=> 120
     *      count; //=> 1
     */
    var memoize = _curry1(function memoize(fn) {
        var cache = {};
        return _arity(fn.length, function () {
            var key = toString(arguments);
            if (!_has(key, cache)) {
                cache[key] = fn.apply(this, arguments);
            }
            return cache[key];
        });
    });

    /**
     * Splits a string into an array of strings based on the given
     * separator.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category String
     * @sig (String | RegExp) -> String -> [String]
     * @param {String|RegExp} sep The pattern.
     * @param {String} str The string to separate into an array.
     * @return {Array} The array of strings from `str` separated by `str`.
     * @see R.join
     * @example
     *
     *      var pathComponents = R.split('/');
     *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
     *
     *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
     */
    var split = invoker(1, 'split');

    /**
     * Determines whether a given string matches a given regular expression.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category String
     * @sig RegExp -> String -> Boolean
     * @param {RegExp} pattern
     * @param {String} str
     * @return {Boolean}
     * @see R.match
     * @example
     *
     *      R.test(/^x/, 'xyz'); //=> true
     *      R.test(/^y/, 'xyz'); //=> false
     */
    var test = _curry2(function test(pattern, str) {
        if (!_isRegExp(pattern)) {
            throw new TypeError('\u2018test\u2019 requires a value of type RegExp as its first argument; received ' + toString(pattern));
        }
        return _cloneRegExp(pattern).test(str);
    });

    /**
     * The lower case version of a string.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category String
     * @sig String -> String
     * @param {String} str The string to lower case.
     * @return {String} The lower case version of `str`.
     * @see R.toUpper
     * @example
     *
     *      R.toLower('XYZ'); //=> 'xyz'
     */
    var toLower = invoker(0, 'toLowerCase');

    /**
     * The upper case version of a string.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category String
     * @sig String -> String
     * @param {String} str The string to upper case.
     * @return {String} The upper case version of `str`.
     * @see R.toLower
     * @example
     *
     *      R.toUpper('abc'); //=> 'ABC'
     */
    var toUpper = invoker(0, 'toUpperCase');

    /**
     * Returns a new list containing only one copy of each element in the original
     * list, based upon the value returned by applying the supplied function to
     * each list element. Prefers the first item if the supplied function produces
     * the same value on two items. `R.equals` is used for comparison.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig (a -> b) -> [a] -> [a]
     * @param {Function} fn A function used to produce a value to use during comparisons.
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
     */
    var uniqBy = _curry2(function uniqBy(fn, list) {
        var set = new _Set();
        var result = [];
        var idx = 0;
        var appliedItem, item;
        while (idx < list.length) {
            item = list[idx];
            appliedItem = fn(item);
            if (set.add(appliedItem)) {
                result.push(item);
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Returns the result of concatenating the given lists or strings.
     *
     * Dispatches to the `concat` method of the first argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a] -> [a]
     * @sig String -> String -> String
     * @param {Array|String} a
     * @param {Array|String} b
     * @return {Array|String}
     *
     * @example
     *
     *      R.concat([], []); //=> []
     *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
     *      R.concat('ABC', 'DEF'); // 'ABCDEF'
     */
    var concat = flip(invoker(1, 'concat'));

    /**
     * Finds the set (i.e. no duplicates) of all elements contained in the first or
     * second list, but not both.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Relation
     * @sig [*] -> [*] -> [*]
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The elements in `list1` or `list2`, but not both.
     * @see R.symmetricDifferenceWith
     * @example
     *
     *      R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=> [1,2,7,6,5]
     *      R.symmetricDifference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5,1,2]
     */
    var symmetricDifference = _curry2(function symmetricDifference(list1, list2) {
        return concat(difference(list1, list2), difference(list2, list1));
    });

    /**
     * Finds the set (i.e. no duplicates) of all elements contained in the first or
     * second list, but not both. Duplication is determined according to the value
     * returned by applying the supplied predicate to two list elements.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Relation
     * @sig (a -> a -> Boolean) -> [a] -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The elements in `list1` or `list2`, but not both.
     * @see R.symmetricDifference
     * @example
     *
     *      var eqA = R.eqBy(R.prop('a'));
     *      var l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];
     *      var l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];
     *      R.symmetricDifferenceWith(eqA, l1, l2); //=> [{a: 1}, {a: 2}, {a: 5}, {a: 6}]
     */
    var symmetricDifferenceWith = _curry3(function symmetricDifferenceWith(pred, list1, list2) {
        return concat(differenceWith(pred, list1, list2), differenceWith(pred, list2, list1));
    });

    /**
     * Returns a new list containing only one copy of each element in the original
     * list. `R.equals` is used to determine equality.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a]
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
     *      R.uniq([1, '1']);     //=> [1, '1']
     *      R.uniq([[42], [42]]); //=> [[42]]
     */
    var uniq = uniqBy(identity);

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of those
     * elements common to both lists.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig [*] -> [*] -> [*]
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The list of elements found in both `list1` and `list2`.
     * @see R.intersectionWith
     * @example
     *
     *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
     */
    var intersection = _curry2(function intersection(list1, list2) {
        var lookupList, filteredList;
        if (list1.length > list2.length) {
            lookupList = list1;
            filteredList = list2;
        } else {
            lookupList = list2;
            filteredList = list1;
        }
        return uniq(_filter(flip(_contains)(lookupList), filteredList));
    });

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of the elements
     * of each list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig [*] -> [*] -> [*]
     * @param {Array} as The first list.
     * @param {Array} bs The second list.
     * @return {Array} The first and second lists concatenated, with
     *         duplicates removed.
     * @example
     *
     *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
     */
    var union = _curry2(compose(uniq, _concat));

    var R = {
        F: F,
        T: T,
        __: __,
        add: add,
        addIndex: addIndex,
        adjust: adjust,
        all: all,
        allPass: allPass,
        allUniq: allUniq,
        always: always,
        and: and,
        any: any,
        anyPass: anyPass,
        ap: ap,
        aperture: aperture,
        append: append,
        apply: apply,
        applySpec: applySpec,
        assoc: assoc,
        assocPath: assocPath,
        binary: binary,
        bind: bind,
        both: both,
        call: call,
        chain: chain,
        clamp: clamp,
        clone: clone,
        comparator: comparator,
        complement: complement,
        compose: compose,
        composeK: composeK,
        composeP: composeP,
        concat: concat,
        cond: cond,
        construct: construct,
        constructN: constructN,
        contains: contains,
        converge: converge,
        countBy: countBy,
        curry: curry,
        curryN: curryN,
        dec: dec,
        defaultTo: defaultTo,
        difference: difference,
        differenceWith: differenceWith,
        dissoc: dissoc,
        dissocPath: dissocPath,
        divide: divide,
        drop: drop,
        dropLast: dropLast,
        dropLastWhile: dropLastWhile,
        dropRepeats: dropRepeats,
        dropRepeatsWith: dropRepeatsWith,
        dropWhile: dropWhile,
        either: either,
        empty: empty,
        eqBy: eqBy,
        eqProps: eqProps,
        equals: equals,
        evolve: evolve,
        filter: filter,
        find: find,
        findIndex: findIndex,
        findLast: findLast,
        findLastIndex: findLastIndex,
        flatten: flatten,
        flip: flip,
        forEach: forEach,
        fromPairs: fromPairs,
        groupBy: groupBy,
        groupWith: groupWith,
        gt: gt,
        gte: gte,
        has: has,
        hasIn: hasIn,
        head: head,
        identical: identical,
        identity: identity,
        ifElse: ifElse,
        inc: inc,
        indexBy: indexBy,
        indexOf: indexOf,
        init: init,
        insert: insert,
        insertAll: insertAll,
        intersection: intersection,
        intersectionWith: intersectionWith,
        intersperse: intersperse,
        into: into,
        invert: invert,
        invertObj: invertObj,
        invoker: invoker,
        is: is,
        isArrayLike: isArrayLike,
        isEmpty: isEmpty,
        isNil: isNil,
        join: join,
        juxt: juxt,
        keys: keys,
        keysIn: keysIn,
        last: last,
        lastIndexOf: lastIndexOf,
        length: length,
        lens: lens,
        lensIndex: lensIndex,
        lensPath: lensPath,
        lensProp: lensProp,
        lift: lift,
        liftN: liftN,
        lt: lt,
        lte: lte,
        map: map,
        mapAccum: mapAccum,
        mapAccumRight: mapAccumRight,
        mapObjIndexed: mapObjIndexed,
        match: match,
        mathMod: mathMod,
        max: max,
        maxBy: maxBy,
        mean: mean,
        median: median,
        memoize: memoize,
        merge: merge,
        mergeAll: mergeAll,
        mergeWith: mergeWith,
        mergeWithKey: mergeWithKey,
        min: min,
        minBy: minBy,
        modulo: modulo,
        multiply: multiply,
        nAry: nAry,
        negate: negate,
        none: none,
        not: not,
        nth: nth,
        nthArg: nthArg,
        objOf: objOf,
        of: of,
        omit: omit,
        once: once,
        or: or,
        over: over,
        pair: pair,
        partial: partial,
        partialRight: partialRight,
        partition: partition,
        path: path,
        pathEq: pathEq,
        pathOr: pathOr,
        pathSatisfies: pathSatisfies,
        pick: pick,
        pickAll: pickAll,
        pickBy: pickBy,
        pipe: pipe,
        pipeK: pipeK,
        pipeP: pipeP,
        pluck: pluck,
        prepend: prepend,
        product: product,
        project: project,
        prop: prop,
        propEq: propEq,
        propIs: propIs,
        propOr: propOr,
        propSatisfies: propSatisfies,
        props: props,
        range: range,
        reduce: reduce,
        reduceBy: reduceBy,
        reduceRight: reduceRight,
        reduced: reduced,
        reject: reject,
        remove: remove,
        repeat: repeat,
        replace: replace,
        reverse: reverse,
        scan: scan,
        sequence: sequence,
        set: set,
        slice: slice,
        sort: sort,
        sortBy: sortBy,
        split: split,
        splitAt: splitAt,
        splitEvery: splitEvery,
        splitWhen: splitWhen,
        subtract: subtract,
        sum: sum,
        symmetricDifference: symmetricDifference,
        symmetricDifferenceWith: symmetricDifferenceWith,
        tail: tail,
        take: take,
        takeLast: takeLast,
        takeLastWhile: takeLastWhile,
        takeWhile: takeWhile,
        tap: tap,
        test: test,
        times: times,
        toLower: toLower,
        toPairs: toPairs,
        toPairsIn: toPairsIn,
        toString: toString,
        toUpper: toUpper,
        transduce: transduce,
        transpose: transpose,
        traverse: traverse,
        trim: trim,
        tryCatch: tryCatch,
        type: type,
        unapply: unapply,
        unary: unary,
        uncurryN: uncurryN,
        unfold: unfold,
        union: union,
        unionWith: unionWith,
        uniq: uniq,
        uniqBy: uniqBy,
        uniqWith: uniqWith,
        unless: unless,
        unnest: unnest,
        until: until,
        update: update,
        useWith: useWith,
        values: values,
        valuesIn: valuesIn,
        view: view,
        when: when,
        where: where,
        whereEq: whereEq,
        without: without,
        wrap: wrap,
        xprod: xprod,
        zip: zip,
        zipObj: zipObj,
        zipWith: zipWith
    };
  /* eslint-env amd */

  /* TEST_ENTRY_POINT */

  if (true) {
    module.exports = R;
  } else if (typeof define === 'function' && define.amd) {
    define(function() { return R; });
  } else {
    this.R = R;
  }

}.call(this));


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.roundTimeBin = roundTimeBin;
exports.default = binningMixin;

var _binningHelpers = __webpack_require__(22);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _events = __webpack_require__(15);

var _filters = __webpack_require__(21);

var _core = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function roundTimeBin(date, timeInterval, operation) {
  // Turn off brush snapping for milliseconds, as a design decision
  if (!timeInterval || timeInterval === "millisecond") {
    return date;
  }

  if (_d2.default.time[timeInterval]) {
    return _d2.default.time[timeInterval].utc[operation](date);
  }

  var unit = timeInterval === "quarter" ? "month" : "year";
  var ranges = [];
  switch (timeInterval) {
    case "quarter":
      ranges = [-2, 2, 3];
      break;
    case "decade":
      ranges = [-5, 5, 10];
      break;
    case "century":
      ranges = [-50, 50, 100];
      break;
  }

  var startRange = operation === "round" ? ranges[0] : operation === "ceil" ? 0 : -ranges[2];
  var endRange = operation === "round" ? ranges[1] : operation === "ceil" ? ranges[2] : 0;

  var subHalf = _d2.default.time[unit].offset(date, startRange);
  var addHalf = _d2.default.time[unit].offset(date, endRange);

  return _d2.default.time[unit].utc.round(_d2.default.time[unit + "s"](subHalf, addHalf, ranges[2])[0]);
}

function binningMixin(chart) {
  var _timeBinInputVal = "auto";

  var _line_events = ["bin"];
  var _listeners = _d2.default.dispatch.apply(_d2.default, _line_events);
  var _on = chart.on.bind(chart);

  chart.on = function (event, listener) {
    if (_line_events.indexOf(event) === -1) {
      _on(event, listener);
    } else {
      _listeners.on(event, listener);
    }
    return chart;
  };

  chart._invokeBinListener = function (f) {
    if (f !== "undefined") {
      _listeners.bin(chart, f);
    }
  };

  chart.binInputOptions = function () {
    return _binningHelpers.BIN_INPUT_OPTIONS;
  };

  chart.timeBinInputVal = function (val) {
    if (typeof val === "undefined") {
      return _timeBinInputVal;
    }
    _timeBinInputVal = val;
    return chart;
  };

  chart._binBrushExtent = function (extent0, isRangeChart) {
    var bin_bounds = chart.group().binParams()[0] ? chart.group().binParams()[0].binBounds : null;

    var chartBounds = isRangeChart ? chart.rangeChart().extendBrush() : bin_bounds;

    if (!extent0[0].getTime || extent0[0].getTime() === extent0[1].getTime()) {
      return extent0;
    }

    var timeInterval = chart.group().binParams()[0].timeBin;

    var extent1 = extent0.map(function (date) {
      return roundTimeBin(date, timeInterval, "round");
    });

    if (extent1[0] < chartBounds[0]) {
      extent1[0] = roundTimeBin(extent0[0], timeInterval, "ceil");
    }

    if (extent1[1] > chartBounds[1]) {
      extent1[1] = roundTimeBin(extent0[1], timeInterval, "floor");
    }

    /* istanbul ignore next */
    // if empty when rounded, use floor & ceil instead
    if (extent1[0] >= extent1[1]) {
      extent1[0] = roundTimeBin(extent0[0], timeInterval, "floor");
      extent1[1] = roundTimeBin(extent0[1], timeInterval, "ceil");
    }

    /* istanbul ignore next */
    if (!isNaN(chart.xAxisMax()) && extent1[0].getTime() === chart.xAxisMax().getTime()) {
      var binNumSecs = chart.binInputOptions().filter(function (d) {
        return chart.group().binParams()[0].timeBin === d.val;
      })[0].numSeconds;
      extent1[0] = new Date(extent1[0].getTime() - binNumSecs * 1000);
      extent1[0] = roundTimeBin(extent1[0], timeInterval, "round");
    }

    /* istanbul ignore next */
    if (!isNaN(chart.xAxisMin()) && extent1[1].getTime() === chart.xAxisMin().getTime()) {
      var _binNumSecs = chart.binInputOptions().filter(function (d) {
        return chart.group().binParams()[0].timeBin === d.val;
      })[0].numSeconds;
      extent1[1] = new Date(extent1[1].getTime() + _binNumSecs * 1000);
      extent1[1] = roundTimeBin(extent1[1], timeInterval, "round");
    }

    return extent1;
  };

  chart.binBrush = function (isRangeChart) {
    var extent0 = isRangeChart ? chart.rangeChart().extendBrush() : chart.extendBrush();
    if (!extent0[0].getTime || extent0[0].getTime() === extent0[1].getTime()) {
      return;
    }

    var extent1 = chart._binBrushExtent(extent0, isRangeChart);
    var rangedFilter = _filters.filters.RangedFilter(extent1[0], extent1[1]);
    _events.events.trigger(function () {
      chart.replaceFilter(rangedFilter);
    }, _core.constants.EVENT_DELAY);
  };

  chart.changeBinVal = function (val) {
    chart.timeBinInputVal(val);

    var currentStack = chart.stack().slice();
    /* istanbul ignore next */

    var _loop = function _loop(i) {
      var binParams = currentStack[i].group.binParams().map(function (binParam, idx) {
        if (idx === i && binParam) {
          var binBounds = binParam.binBounds,
              numBins = binParam.numBins;

          var isAuto = val === "auto";
          var bounds = binBounds.map(function (date) {
            return date.getTime();
          });
          binParam.timeBin = isAuto ? (0, _binningHelpers.autoBinParams)(bounds, numBins) : val;
          binParam.auto = isAuto; // hightlights the "auto" UI button
        }
        return binParam;
      });

      /* istanbul ignore next */
      if (i === 0) {
        chart.group(currentStack[i].group.binParams(binParams), currentStack[i].name);
      } else {
        chart.stack(currentStack[i].group.binParams(binParams), currentStack[i].name, currentStack[i].accessor);
      }
    };

    for (var i = 0; i < currentStack.length; i++) {
      _loop(i);
    }

    chart._invokeBinListener(val);
    return chart.renderAsync().then(function () {
      chart.binBrush();
    });
  };

  return chart;
}

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = bubbleChart;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _bubbleMixin = __webpack_require__(38);

var _bubbleMixin2 = _interopRequireDefault(_bubbleMixin);

var _capMixin = __webpack_require__(16);

var _capMixin2 = _interopRequireDefault(_capMixin);

var _coordinateGridMixin = __webpack_require__(14);

var _coordinateGridMixin2 = _interopRequireDefault(_coordinateGridMixin);

var _utils = __webpack_require__(4);

var _core = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A concrete implementation of a general purpose bubble chart that allows data visualization using the
 * following dimensions:
 * - x axis position
 * - y axis position
 * - bubble radius
 * - color
 * Examples:
 * - {@link https://mapd.github.io/mapd-charting/example/example1.html Carrier Departure Delay by Arrival Delay (Minutes)
}
 * @name bubbleChart
 * @memberof dc
 * @mixes dc.bubbleMixin
 * @mixes dc.coordinateGridMixin
 * @example
 * // create a bubble chart under #chart-container1 element using the default global chart group
 * var bubbleChart1 = dc.bubbleChart('#chart-container1');
 * // create a bubble chart under #chart-container2 element using chart group A
 * var bubbleChart2 = dc.bubbleChart('#chart-container2', 'chartGroupA');
 * @param {String|node|d3.selection} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector} specifying
 * a dom block element such as a div; or a dom element or d3 selection.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
 * Interaction with a chart will only trigger events and redraws within the chart's group.
 * @return {dc.bubbleChart}
 */
function bubbleChart(parent, chartGroup) {
  /* OVERRIDE -----------------------------------------------------------------*/
  var _chart = (0, _bubbleMixin2.default)((0, _capMixin2.default)((0, _coordinateGridMixin2.default)({})));
  var _popupHeader = [];
  var _isHoverNode = null;
  /* --------------------------------------------------------------------------*/

  var _elasticRadius = false;
  var _sortBubbleSize = false;
  var _hasSizeMeasure = false;
  var SMALLEST_SIZED_BUBBLE_RADIUS = 2;

  _chart.transitionDuration(750);

  var bubbleLocator = function bubbleLocator(d) {
    return "translate(" + bubbleX(d) + "," + bubbleY(d) + ")";
  };

  /* OVERRIDE -----------------------------------------------------------------*/
  _chart.setPopupHeader = function (_) {
    if (!arguments.length) {
      return _popupHeader;
    }
    _popupHeader = _;
    return _chart;
  };

  _chart.measureValue = function (value, key, type) {
    if (type === "measure") {
      var customFormatter = _chart.valueFormatter();
      return customFormatter && customFormatter(value, key) || _utils.utils.formatValue(value);
    } else {
      _utils.utils.formatValue(value);
    }
  };

  _chart.hideOverlappedLabels = function () {
    var nodes = _chart.svg().selectAll(".node");

    var labelHeight = 10;
    var letterWidth = 5;

    nodes[0].reverse();

    nodes.classed("hide-label", function (d) {
      return _chart.bubbleR(d) < _chart.minRadiusWithLabel();
    }).each(function (d, i) {
      var a = this;
      var aR = i > 0 ? d.radius : _chart.bubbleR(d);
      var aX = i > 0 ? d.xPixel : bubbleX(d);
      var aY = i > 0 ? d.yPixel : bubbleY(d);
      var aKey = d.key0;

      if (_d2.default.select(a).classed("hide-label")) {
        return;
      }

      for (var j = i + 1; j < nodes[0].length; j++) {
        var b = _d2.default.select(nodes[0][j]);
        var d = b.datum();

        var bX = d.xPixel = bubbleX(d);
        var bY = d.yPixel = bubbleY(d);
        var bR = d.radius = _chart.bubbleR(d);
        var bKey = d.key0;

        if (Math.abs(aY - bY) > labelHeight || bR < _chart.minRadiusWithLabel() || b.classed("hide-label")) {
          continue;
        }

        var aXmin = aX - String(aKey).length * letterWidth / 2;
        var aXmax = aX + String(aKey).length * letterWidth / 2;

        var bXmin = bX - String(bKey).length * letterWidth / 2;
        var bXmax = bX + String(bKey).length * letterWidth / 2;

        var isLabelOverlapped = aXmin >= bXmin && aXmin <= bXmax || aXmax >= bXmin && aXmax <= bXmax || aXmin <= bXmin && aXmax >= bXmax;

        if (isLabelOverlapped) {
          b.classed("hide-label", true);
        }
      }
    });
  };

  function isNodeOverlapped(d1, d2) {
    var dist = Math.sqrt((d1.xPixel - d2.xPixel) * (d1.xPixel - d2.xPixel) + (d1.yPixel - d2.yPixel) * (d1.yPixel - d2.yPixel));
    return d1.radius + 8 >= dist;
  }

  _chart.showPopup = function (d, i) {
    if (_chart.svg().select(".mouse-out-detect").empty()) {
      _chart.svg().insert("rect", ":first-child").attr("class", "mouse-out-detect").attr({ width: _chart.width(), height: _chart.height() }).on("mousemove", _chart.hidePopup);
    }

    _isHoverNode = d;

    var popup = _chart.popup();

    var popupBox = popup.select(".chart-popup-content").html("");

    popupBox.append("div").attr("class", "popup-bridge").style("width", _chart.bubbleR(d) * 2 + "px").style("height", _chart.bubbleR(d) + 24 + "px").style("border-radius", "0 0 " + _chart.bubbleR(d) + "px " + _chart.bubbleR(d) + "px").on("click", function () {
      _chart.onClick(d);
    }).append("div").attr("class", "bridge-hitbox");

    var popupTableWrap = popupBox.append("div").attr("class", "popup-table-wrap").on("mouseleave", _chart.hidePopup);

    var popupTable = popupTableWrap.append("table").attr("class", "popup-table");

    var popupTableHeader = popupTable.append("tr");

    var headerItems = popupTableHeader.selectAll("th").data(_popupHeader).enter().append("th");

    headerItems.append("div").attr("class", "ellipse-text").text(function (d) {
      return d.label;
    }).append("div").attr("class", "full-text").text(function (d) {
      return d.label;
    }).on("mouseenter", function () {
      _d2.default.select(this).style("transform", function () {
        var elm = _d2.default.select(this);
        var textWidth = elm.node().getBoundingClientRect().width;
        var boxWidth = elm.node().parentNode.getBoundingClientRect().width;

        if (textWidth < boxWidth) {
          elm.classed("scroll-text", false);
          return "none";
        }
        var dist = textWidth - boxWidth;

        elm.style("transition-duration", dist * 0.05 + "s").classed("scroll-text", true).on("webkitTransitionEnd", function () {
          setTimeout(function () {
            elm.classed("scroll-text", false).style("transform", "translateX(0)");
          }, 500);

          setTimeout(function () {
            elm.style("transform", "translateX(" + -dist + "px)").classed("scroll-text", true);
          }, 1000);
        });

        return "translateX(" + -dist + "px)";
      });
    }).on("mouseleave", function () {
      _d2.default.select(this).classed("scroll-text", false).style("transform", "translateX(0)");
    });

    var dataRows = [d];
    var nodes = _chart.svg().selectAll(".node");
    var foundCurrentNode = false;

    nodes[0].reverse();

    nodes.each(function (node, i) {
      if (d === node) {
        foundCurrentNode = true;
        return;
      }

      if (foundCurrentNode && isNodeOverlapped(d, node)) {
        dataRows.push(node);
      }
    });

    var rowItems = popupTable.selectAll(".popup-row-item").data(dataRows).enter().append("tr").html(function (d) {
      return renderPopupRow(d);
    }).on("click", function (d) {
      _chart.onClick(d);
    }).attr("class", "popup-row-item");

    _chart.updatePopup();

    popup.classed("js-showPopup popup-scrollable delay-pointer scatter-plot-popup", true);

    _chart.root().node().parentNode.parentNode.style.zIndex = 1;

    setTimeout(function () {
      popup.classed("delay-pointer", false);
    }, 250);

    positionPopup(d, this);
  };

  _chart.updatePopup = function () {
    if (_chart.hasFilter()) {
      _chart.popup().selectAll(".popup-row-item").each(function (d) {
        _d2.default.select(this).classed("deselected", !_chart.isSelectedNode(d)).classed("selected", _chart.isSelectedNode(d));
      });
    } else {
      _chart.popup().selectAll(".popup-row-item").classed("deselected", false).classed("selected", false);
    }
  };

  function renderPopupRow(d) {
    var str = "\n            <td>\n                <div class=\"table-dim\">\n                    <div class=\"table-legend\" style=\"background:" + _chart.getColor(d) + "\"></div>\n                    <div class=\"table-dim-val\">" + _chart.label()(d) + "</div>\n                </div>\n            </td>\n        ";

    for (var i = 1; i < _popupHeader.length; i++) {
      if (_popupHeader[i].alias) {
        var value = _popupHeader[i];
        str = str + ("<td>" + _chart.measureValue(d[value.alias], value.label, value.type) + "</td>");
      }
    }
    return str;
  }

  _chart.hidePopup = function () {
    _chart.popup().classed("js-showPopup", false);

    _chart.root().node().parentNode.parentNode.style.zIndex = "auto";

    _d2.default.selectAll(".node-hover").classed("node-hover", false);

    _isHoverNode = null;
  };

  function positionPopup(d, e) {
    var x = bubbleX(d) + _chart.margins().left;
    var y = bubbleY(d) + _chart.margins().top;

    var popup = _chart.popup().style("transform", function () {
      var popupWidth = _d2.default.select(this).select(".chart-popup-box").node().getBoundingClientRect().width / 2;
      var offsetX = x - popupWidth < 0 ? popupWidth - x - 16 : x + popupWidth > _chart.width() ? _chart.width() - (x + popupWidth) + 16 : 0;

      _d2.default.select(this).select(".popup-bridge").style("left", function () {
        return offsetX !== 0 ? popupWidth - offsetX + "px" : "50%";
      });
      return "translate(" + (x + offsetX) + "px," + y + "px)";
    });

    popup.select(".chart-popup-box").classed("align-center", true).classed("popdown", function () {
      return popup.node().getBoundingClientRect().top - 76 < _d2.default.select(this).node().getBoundingClientRect().height;
    }).select(".popup-table-wrap").style("overflow-y", function () {
      return popup.select(".popup-table").node().getBoundingClientRect().height > 160 ? "scroll" : "hidden";
    });
  }

  /* --------------------------------------------------------------------------*/

  /**
   * Turn on or off the elastic bubble radius feature, or return the value of the flag. If this
   * feature is turned on, then bubble radii will be automatically rescaled to fit the chart better.
   * @name elasticRadius
   * @memberof dc.bubbleChart
   * @instance
   * @param {Boolean} [elasticRadius=false]
   * @return {Boolean}
   * @return {dc.bubbleChart}
   */
  _chart.elasticRadius = function (elasticRadius) {
    if (!arguments.length) {
      return _elasticRadius;
    }
    _elasticRadius = elasticRadius;
    return _chart;
  };

  _chart.hasSizeMeasure = function (hasSizeMeasure) {
    if (!arguments.length) {
      return _hasSizeMeasure;
    }
    _hasSizeMeasure = hasSizeMeasure;
    return _chart;
  };

  /**
   * Turn on or off the bubble sorting feature, or return the value of the flag. If enabled,
   * bubbles will be sorted by their radius, with smaller bubbles in front.
   * @name sortBubbleSize
   * @memberof dc.bubbleChart
   * @instance
   * @param {Boolean} [sortBubbleSize=false]
   * @return {Boolean}
   * @return {dc.bubbleChart}
   */
  _chart.sortBubbleSize = function (sortBubbleSize) {
    if (!arguments.length) {
      return _sortBubbleSize;
    }
    _sortBubbleSize = sortBubbleSize;
    return _chart;
  };

  _chart.plotData = function () {
    if (_elasticRadius) {
      _chart.r().domain([_chart.rMin(), _chart.rMax()]);
    }

    // If the chart has a size measure, we're going to render bubbles
    // differently than if the chart doesn't have a size measure
    if (_hasSizeMeasure) {
      // If it has a size measure, we're going to scale the bubbles. This scale
      // is a function of a multiplier and the chart width. We allow the user to
      // select the multiplier for the lower and upper bounds of bubble radii.
      // However, we want to enforce an absolute minimum radius of 2px on
      // rendered bubbles.
      var minimumBubbleSizeInPixels = Math.max(SMALLEST_SIZED_BUBBLE_RADIUS, _chart.xAxisLength() * _chart.minBubbleRelativeSize());
      _chart.r().range([minimumBubbleSizeInPixels, _chart.xAxisLength() * _chart.maxBubbleRelativeSize()]);
    } else {
      // If we have a size measure, the bubble size will be a fixed radius
      // determined by the user and stored in _chart.MIN_RADIUS. This fixed with
      // is not responsive and will not vary with screen size.
      _chart.r().range([_chart.MIN_RADIUS, _chart.MIN_RADIUS]);
    }

    var data = _chart.data();
    if (_sortBubbleSize) {
      // sort descending so smaller bubbles are on top
      var radiusAccessor = _chart.radiusValueAccessor();
      data.sort(function (a, b) {
        return _d2.default.descending(radiusAccessor(a), radiusAccessor(b));
      });
    }
    var bubbleG = _chart.chartBodyG().selectAll("g." + _chart.BUBBLE_NODE_CLASS)

    /* OVERRIDE -----------------------------------------------------------------*/
    .data(data);
    /* --------------------------------------------------------------------------*/

    if (_sortBubbleSize) {
      // Call order here to update dom order based on sort
      bubbleG.order();
    }

    renderNodes(bubbleG);

    updateNodes(bubbleG);

    removeNodes(bubbleG);

    _chart.fadeDeselectedArea();
  };

  function renderNodes(bubbleG) {
    var bubbleGEnter = void 0;
    bubbleGEnter = bubbleG.enter().append("g");
    bubbleGEnter.append("circle").attr("class", function (d, i) {
      return _chart.BUBBLE_CLASS + " _" + i;
    }).on("click", _chart.onClick).attr("fill", _chart.getColor).attr("r", 0);

    var debouncePopUp = _chart.debounce(function (d, i, elm) {
      _d2.default.select(elm).classed("node-hover", true);
      _chart.showPopup(d, i);
    }, 250);

    bubbleGEnter.attr("class", _chart.BUBBLE_NODE_CLASS).attr("transform", bubbleLocator)
    /* OVERRIDE -----------------------------------------------------------------*/
    .on("mouseover", function (d, i) {
      if (JSON.stringify(_isHoverNode) !== JSON.stringify(d)) {
        debouncePopUp(d, i, this);
        _chart.hidePopup();
      }
    });
    /* --------------------------------------------------------------------------*/

    (0, _core.transition)(bubbleG, _chart.transitionDuration()).selectAll("circle." + _chart.BUBBLE_CLASS).attr("r", function (d) {
      return _chart.bubbleR(d);
    }).attr("opacity", function (d) {
      return _chart.bubbleR(d) > 0 ? 1 : 0;
    });

    _chart._doRenderLabel(bubbleGEnter);

    _chart.prepareLockAxis("x");
  }

  function updateNodes(bubbleG) {
    (0, _core.transition)(bubbleG, _chart.transitionDuration()).attr("transform", bubbleLocator)

    /* OVERRIDE -----------------------------------------------------------------*/
    .select("circle." + _chart.BUBBLE_CLASS)
    /* --------------------------------------------------------------------------*/

    .attr("fill", _chart.getColor).attr("r", function (d) {
      return _chart.bubbleR(d);
    }).attr("opacity", function (d) {
      return _chart.bubbleR(d) > 0 ? 1 : 0;
    });

    _chart.doUpdateLabels(bubbleG);
    _chart.doUpdateTitles(bubbleG);
  }

  function removeNodes(bubbleG) {
    bubbleG.exit().remove();
  }

  function bubbleX(d) {
    var x = _chart.x()(_chart.keyAccessor()(d));
    if (isNaN(x)) {
      x = 0;
    }
    return x;
  }

  function bubbleY(d) {
    var y = _chart.y()(_chart.valueAccessor()(d));
    if (isNaN(y)) {
      y = 0;
    }
    return y;
  }

  _chart.renderBrush = function () {
    // override default x axis brush from parent chart
  };

  _chart.redrawBrush = function () {
    // override default x axis brush from parent chart
    _chart.fadeDeselectedArea();
  };

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cloudChart;

var _baseMixin = __webpack_require__(7);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

var _capMixin = __webpack_require__(16);

var _capMixin2 = _interopRequireDefault(_capMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _colorMixin = __webpack_require__(12);

var _colorMixin2 = _interopRequireDefault(_colorMixin);

var _marginMixin = __webpack_require__(18);

var _marginMixin2 = _interopRequireDefault(_marginMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function cloudChart(parent, chartGroup) {
  var _g = void 0;
  var _chart = (0, _capMixin2.default)((0, _marginMixin2.default)((0, _colorMixin2.default)((0, _baseMixin2.default)({}))));
  var _cloudData = void 0;
  var _cloudLayout = void 0;
  var _r = void 0;
  var _tags = void 0; // store output of _cloudLayout
  var _noRelayout = false; // flag to set on click so rerender doesn't relayout elements
  var _hasBeenRendered = false;

  _chart.setNoRelayout = function (val) {
    _noRelayout = val;
  };

  function drawChart() {
    _cloudData = _chart.data();
    calculateSizeScale();
    _cloudLayout = _d2.default.layout.cloud().size([_chart.width(), _chart.height()]).words(_cloudData.map(function (d) {
      return {
        key0: d.key0,
        value: d.value,
        color: d.color,
        text: d.key0,
        size: _r(_chart.valueAccessor()(d))
      };
    }

    // return {key: d.key0, value: d.value, text: d.key0, size: _r(_chart.valueAccessor()(d))};
    )).rotate(function () {
      return 0;
    }).font("Impact").fontSize(function (d) {
      return d.size;
    }).on("end", cloudDraw);
    _cloudLayout.start();
  }

  function calculateSizeScale() {
    var extent = _d2.default.extent(_cloudData, _chart.cappedValueAccessor);

    _r = _d2.default.scale.log().domain(extent).range([10, Math.max(14, Math.min(_chart.effectiveWidth(), _chart.effectiveHeight()) / 10)]);
  }

  function cloudDraw(newTags) {
    _tags = newTags;
    var tagElems = _g.attr("transform", "translate(" + _cloudLayout.size()[0] / 2 + "," + _cloudLayout.size()[1] / 2 + ")").selectAll("text").data(_tags);
    tagElems.enter().append("text");
    tagElems.exit().remove();
    tagElems.style("font-size", function (d) {
      return d.size + "px";
    }).style("font-family", "Impact").style("fill", _chart.getColor) // function(d, i) { return fill(i); })
    .style("cursor", "pointer").attr("text-anchor", "middle").attr("transform", function (d) {
      return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
    }).text(function (d) {
      return d.key0;
    }).on("click", onClick).classed("deselected", function (d) {
      return _chart.hasFilter() ? !isSelectedTag(d) : false;
    }).classed("selected", function (d) {
      return _chart.hasFilter() ? isSelectedTag(d) : false;
    });

    createTitles(tagElems);
  }

  function onClick(d) {
    _noRelayout = true;
    _chart.onClick(d);
  }

  function createTitles(tags) {
    if (_chart.renderTitle()) {
      tags.selectAll("title").remove();
      tags.append("title").text(_chart.title());
    }
  }

  function isSelectedTag(d) {
    return _chart.hasFilter(_chart.cappedKeyAccessor(d));
  }

  _chart.title(function (d) {
    return _chart.cappedKeyAccessor(d) + ": " + _chart.cappedValueAccessor(d);
  });

  _chart.label(_chart.cappedKeyAccessor);

  _chart._doRender = function () {
    _chart.resetSvg();
    _g = _chart.svg().append("g").attr("transform", "translate(" + _chart.margins().left + "," + _chart.margins().top + ")");

    if (_noRelayout) {
      cloudDraw(_tags); // skip layout so tags remain in place
      _noRelayout = false;
    } else {
      drawChart();
    }
    var _hasBeenRendered = true;

    return _chart;
  };

  _chart._doRedraw = function () {
    if (!_hasBeenRendered) {
      return _chart._doRender();
    }
    if (_noRelayout) {
      cloudDraw(_tags);
      _noRelayout = false;
    } else {
      drawChart();
    }
    return _chart;
  };

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = compositeChart;

var _coordinateGridMixin = __webpack_require__(14);

var _coordinateGridMixin2 = _interopRequireDefault(_coordinateGridMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _core = __webpack_require__(3);

var _utils = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Composite charts are a special kind of chart that render multiple charts on the same Coordinate
 * Grid. You can overlay (compose) different bar/line/area charts in a single composite chart to
 * achieve some quite flexible charting effects.
 * @name compositeChart
 * @memberof dc
 * @mixes dc.coordinateGridMixin
 * @example
 * // create a composite chart under #chart-container1 element using the default global chart group
 * var compositeChart1 = dc.compositeChart('#chart-container1');
 * // create a composite chart under #chart-container2 element using chart group A
 * var compositeChart2 = dc.compositeChart('#chart-container2', 'chartGroupA');
 * @param {String|node|d3.selection} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector} specifying
 * a dom block element such as a div; or a dom element or d3 selection.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
 * Interaction with a chart will only trigger events and redraws within the chart's group.
 * @return {dc.compositeChart}
 */
function compositeChart(parent, chartGroup) {
  var SUB_CHART_CLASS = "sub";
  var DEFAULT_RIGHT_Y_AXIS_LABEL_PADDING = 12;

  var _chart = (0, _coordinateGridMixin2.default)({});
  var _children = [];

  var _childOptions = {};

  var _shareColors = false,
      _shareTitle = true,
      _alignYAxes = false;

  var _rightYAxis = _d2.default.svg.axis(),
      _rightYAxisLabel = 0,
      _rightYAxisLabelPadding = DEFAULT_RIGHT_Y_AXIS_LABEL_PADDING,
      _rightY = void 0,
      _rightAxisGridLines = false;

  _chart._mandatoryAttributes([]);
  _chart.transitionDuration(500);

  (0, _core.override)(_chart, "_generateG", function () {
    var g = this.__generateG();

    for (var i = 0; i < _children.length; ++i) {
      var child = _children[i];

      generateChildG(child, i);

      if (!child.dimension()) {
        child.dimension(_chart.dimension());
      }
      if (!child.group()) {
        child.group(_chart.group());
      }

      child.chartGroup(_chart.chartGroup());
      child.svg(_chart.svg());
      child.xUnits(_chart.xUnits());
      child.transitionDuration(_chart.transitionDuration());
      child.brushOn(_chart.brushOn());
      child.renderTitle(_chart.renderTitle());
      child.elasticX(_chart.elasticX());
    }

    return g;
  });

  _chart._brushing = function () {
    var extent = _chart.extendBrush();
    var brushIsEmpty = _chart.brushIsEmpty(extent);

    for (var i = 0; i < _children.length; ++i) {
      _children[i].filterAll();
      if (!brushIsEmpty) {
        _children[i].filter(extent);
      }
    }
  };

  _chart._prepareYAxis = function () {
    var left = leftYAxisChildren().length !== 0;
    var right = rightYAxisChildren().length !== 0;
    var ranges = calculateYAxisRanges(left, right);

    if (left) {
      prepareLeftYAxis(ranges);
    }
    if (right) {
      prepareRightYAxis(ranges);
    }

    if (leftYAxisChildren().length > 0 && !_rightAxisGridLines) {
      _chart._renderHorizontalGridLinesForAxis(_chart.g(), _chart.y(), _chart.yAxis());
    } else if (rightYAxisChildren().length > 0) {
      _chart._renderHorizontalGridLinesForAxis(_chart.g(), _rightY, _rightYAxis);
    }
  };

  _chart.renderYAxis = function () {
    if (leftYAxisChildren().length !== 0) {
      _chart.renderYAxisAt("y", _chart.yAxis(), _chart.margins().left);
      _chart.renderYAxisLabel("y", _chart.yAxisLabel(), -90);
    }

    if (rightYAxisChildren().length !== 0) {
      _chart.renderYAxisAt("yr", _chart.rightYAxis(), _chart.width() - _chart.margins().right);
      _chart.renderYAxisLabel("yr", _chart.rightYAxisLabel(), 90, _chart.width() - _rightYAxisLabelPadding);
    }
  };

  function calculateYAxisRanges(left, right) {
    var lyAxisMin = void 0,
        lyAxisMax = void 0,
        ryAxisMin = void 0,
        ryAxisMax = void 0;

    if (left) {
      lyAxisMin = yAxisMin();
      lyAxisMax = yAxisMax();
    }

    if (right) {
      ryAxisMin = rightYAxisMin();
      ryAxisMax = rightYAxisMax();
    }

    if (_chart.alignYAxes() && left && right && (lyAxisMin < 0 || ryAxisMin < 0)) {
      // both y axis are linear and at least one doesn't start at zero
      var leftYRatio = void 0,
          rightYRatio = void 0;

      if (lyAxisMin < 0) {
        leftYRatio = lyAxisMax / lyAxisMin;
      }

      if (ryAxisMin < 0) {
        rightYRatio = ryAxisMax / ryAxisMin;
      }

      if (lyAxisMin < 0 && ryAxisMin < 0) {
        if (leftYRatio < rightYRatio) {
          ryAxisMax = ryAxisMin * leftYRatio;
        } else {
          lyAxisMax = lyAxisMin * rightYRatio;
        }
      } else if (lyAxisMin < 0) {
        ryAxisMin = ryAxisMax / leftYRatio;
      } else {
        lyAxisMin = lyAxisMax / (ryAxisMax / ryAxisMin);
      }
    }
    return {
      lyAxisMin: lyAxisMin,
      lyAxisMax: lyAxisMax,
      ryAxisMin: ryAxisMin,
      ryAxisMax: ryAxisMax
    };
  }

  function prepareRightYAxis(ranges) {
    if (_chart.rightY() === undefined || _chart.elasticY() || _chart.resizing()) {
      if (_chart.rightY() === undefined) {
        _chart.rightY(_d2.default.scale.linear());
      }
      _chart.rightY().domain([ranges.ryAxisMin, ranges.ryAxisMax]).rangeRound([_chart.yAxisHeight(), 0]);
    }

    _chart.rightY().range([_chart.yAxisHeight(), 0]);
    _chart.rightYAxis(_chart.rightYAxis().scale(_chart.rightY()));

    _chart.rightYAxis().orient("right");
  }

  function prepareLeftYAxis(ranges) {
    if (_chart.y() === undefined || _chart.elasticY() || _chart.resizing()) {
      if (_chart.y() === undefined) {
        _chart.y(_d2.default.scale.linear());
      }
      _chart.y().domain([ranges.lyAxisMin, ranges.lyAxisMax]).rangeRound([_chart.yAxisHeight(), 0]);
    }

    _chart.y().range([_chart.yAxisHeight(), 0]);
    _chart.yAxis(_chart.yAxis().scale(_chart.y()));

    _chart.yAxis().orient("left");
  }

  function generateChildG(child, i) {
    child._generateG(_chart.g());
    child.g().attr("class", SUB_CHART_CLASS + " _" + i);
  }

  _chart.plotData = function () {
    for (var i = 0; i < _children.length; ++i) {
      var child = _children[i];

      if (!child.g()) {
        generateChildG(child, i);
      }

      if (_shareColors) {
        child.colors(_chart.colors());
      }

      child.x(_chart.x());

      child.xAxis(_chart.xAxis());

      if (child.useRightYAxis()) {
        child.y(_chart.rightY());
        child.yAxis(_chart.rightYAxis());
      } else {
        child.y(_chart.y());
        child.yAxis(_chart.yAxis());
      }

      child.plotData();

      child._activateRenderlets();
    }
  };

  /**
   * Get or set whether to draw gridlines from the right y axis.  Drawing from the left y axis is the
   * default behavior. This option is only respected when subcharts with both left and right y-axes
   * are present.
   * @name useRightAxisGridLines
   * @memberof dc.compositeChart
   * @instance
   * @param {Boolean} [useRightAxisGridLines=false]
   * @return {Boolean}
   * @return {dc.compositeChart}
   */
  _chart.useRightAxisGridLines = function (useRightAxisGridLines) {
    if (!arguments) {
      return _rightAxisGridLines;
    }

    _rightAxisGridLines = useRightAxisGridLines;
    return _chart;
  };

  /**
   * Get or set chart-specific options for all child charts. This is equivalent to calling
   * {@link #dc.baseMixin+options .options} on each child chart.
   * @name childOptions
   * @memberof dc.compositeChart
   * @instance
   * @param {Object} [childOptions]
   * @return {Object}
   * @return {dc.compositeChart}
   */
  _chart.childOptions = function (childOptions) {
    if (!arguments.length) {
      return _childOptions;
    }
    _childOptions = childOptions;
    _children.forEach(function (child) {
      child.options(_childOptions);
    });
    return _chart;
  };

  _chart.fadeDeselectedArea = function () {
    for (var i = 0; i < _children.length; ++i) {
      var child = _children[i];
      child.brush(_chart.brush());
      child.fadeDeselectedArea();
    }
  };

  /**
   * Set or get the right y axis label.
   * @name rightYAxisLabel
   * @memberof dc.compositeChart
   * @instance
   * @param {String} [rightYAxisLabel]
   * @param {Number} [padding]
   * @return {String}
   * @return {dc.compositeChart}
   */
  _chart.rightYAxisLabel = function (rightYAxisLabel, padding) {
    if (!arguments.length) {
      return _rightYAxisLabel;
    }
    _rightYAxisLabel = rightYAxisLabel;
    _chart.margins().right -= _rightYAxisLabelPadding;
    _rightYAxisLabelPadding = padding === undefined ? DEFAULT_RIGHT_Y_AXIS_LABEL_PADDING : padding;
    _chart.margins().right += _rightYAxisLabelPadding;
    return _chart;
  };

  /**
   * Combine the given charts into one single composite coordinate grid chart.
   * @name compose
   * @memberof dc.compositeChart
   * @instance
   * @example
   * moveChart.compose([
   *     // when creating sub-chart you need to pass in the parent chart
   *     dc.lineChart(moveChart)
   *         .group(indexAvgByMonthGroup) // if group is missing then parent's group will be used
   *         .valueAccessor(function (d){return d.value.avg;})
   *         // most of the normal functions will continue to work in a composed chart
   *         .renderArea(true)
   *         .stack(monthlyMoveGroup, function (d){return d.value;})
   *         .title(function (d){
   *             var value = d.value.avg?d.value.avg:d.value;
   *             if(isNaN(value)) value = 0;
   *             return dateFormat(d.key) + '\n' + numberFormat(value);
   *         }),
   *     dc.barChart(moveChart)
   *         .group(volumeByMonthGroup)
   *         .centerBar(true)
   * ]);
   * @param {Array<Chart>} [subChartArray]
   * @return {dc.compositeChart}
   */
  _chart.compose = function (subChartArray) {
    _children = subChartArray;
    _children.forEach(function (child) {
      child.height(_chart.height());
      child.width(_chart.width());
      child.margins(_chart.margins());

      if (_shareTitle) {
        child.title(_chart.title());
      }

      child.options(_childOptions);
    });
    return _chart;
  };

  /**
   * Returns the child charts which are composed into the composite chart.
   * @name children
   * @memberof dc.compositeChart
   * @instance
   * @return {Array<dc.baseMixin>}
   */
  _chart.children = function () {
    return _children;
  };

  /**
   * Get or set color sharing for the chart. If set, the {@link #dc.colorMixin+colors .colors()} value from this chart
   * will be shared with composed children. Additionally if the child chart implements
   * Stackable and has not set a custom .colorAccessor, then it will generate a color
   * specific to its order in the composition.
   * @name shareColors
   * @memberof dc.compositeChart
   * @instance
   * @param {Boolean} [shareColors=false]
   * @return {Boolean}
   * @return {dc.compositeChart}
   */
  _chart.shareColors = function (shareColors) {
    if (!arguments.length) {
      return _shareColors;
    }
    _shareColors = shareColors;
    return _chart;
  };

  /**
   * Get or set title sharing for the chart. If set, the {@link #dc.baseMixin+title .title()} value from
   * this chart will be shared with composed children.
   * @name shareTitle
   * @memberof dc.compositeChart
   * @instance
   * @param {Boolean} [shareTitle=true]
   * @return {Boolean}
   * @return {dc.compositeChart}
   */
  _chart.shareTitle = function (shareTitle) {
    if (!arguments.length) {
      return _shareTitle;
    }
    _shareTitle = shareTitle;
    return _chart;
  };

  /**
   * Get or set the y scale for the right axis. The right y scale is typically automatically
   * generated by the chart implementation.
   * @name rightY
   * @memberof dc.compositeChart
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/Scales d3.scale}
   * @param {d3.scale} [yScale]
   * @return {d3.scale}
   * @return {dc.compositeChart}
   */
  _chart.rightY = function (yScale) {
    if (!arguments.length) {
      return _rightY;
    }
    _rightY = yScale;
    _chart.rescale();
    return _chart;
  };

  /**
   * Get or set alignment between left and right y axes. A line connecting '0' on both y axis
   * will be parallel to x axis.
   * @name alignYAxes
   * @memberof dc.compositeChart
   * @instance
   * @param {Boolean} [alignYAxes=false]
   * @return {Chart}
   */
  _chart.alignYAxes = function (alignYAxes) {
    if (!arguments.length) {
      return _alignYAxes;
    }
    _alignYAxes = alignYAxes;
    _chart.rescale();
    return _chart;
  };

  function leftYAxisChildren() {
    return _children.filter(function (child) {
      return !child.useRightYAxis();
    });
  }

  function rightYAxisChildren() {
    return _children.filter(function (child) {
      return child.useRightYAxis();
    });
  }

  function getYAxisMin(charts) {
    return charts.map(function (c) {
      return c.yAxisMin();
    });
  }

  delete _chart.yAxisMin;
  function yAxisMin() {
    return _d2.default.min(getYAxisMin(leftYAxisChildren()));
  }

  function rightYAxisMin() {
    return _d2.default.min(getYAxisMin(rightYAxisChildren()));
  }

  function getYAxisMax(charts) {
    return charts.map(function (c) {
      return c.yAxisMax();
    });
  }

  delete _chart.yAxisMax;
  function yAxisMax() {
    return _utils.utils.add(_d2.default.max(getYAxisMax(leftYAxisChildren())), _chart.yAxisPadding());
  }

  function rightYAxisMax() {
    return _utils.utils.add(_d2.default.max(getYAxisMax(rightYAxisChildren())), _chart.yAxisPadding());
  }

  function getAllXAxisMinFromChildCharts() {
    return _children.map(function (c) {
      return c.xAxisMin();
    });
  }

  (0, _core.override)(_chart, "xAxisMin", function () {
    return _utils.utils.subtract(_d2.default.min(getAllXAxisMinFromChildCharts()), _chart.xAxisPadding());
  });

  function getAllXAxisMaxFromChildCharts() {
    return _children.map(function (c) {
      return c.xAxisMax();
    });
  }

  (0, _core.override)(_chart, "xAxisMax", function () {
    return _utils.utils.add(_d2.default.max(getAllXAxisMaxFromChildCharts()), _chart.xAxisPadding());
  });

  _chart.legendables = function () {
    return _children.reduce(function (items, child) {
      if (_shareColors) {
        child.colors(_chart.colors());
      }
      items.push.apply(items, child.legendables());
      return items;
    }, []);
  };

  _chart.legendHighlight = function (d) {
    for (var j = 0; j < _children.length; ++j) {
      var child = _children[j];
      child.legendHighlight(d);
    }
  };

  _chart.legendReset = function (d) {
    for (var j = 0; j < _children.length; ++j) {
      var child = _children[j];
      child.legendReset(d);
    }
  };

  _chart.legendToggle = function () {
    console.log("composite should not be getting legendToggle itself");
  };

  /**
   * Set or get the right y axis used by the composite chart. This function is most useful when y
   * axis customization is required. The y axis in dc.js is an instance of a [d3 axis
   * object](https://github.com/mbostock/d3/wiki/SVG-Axes#wiki-_axis) therefore it supports any valid
   * d3 axis manipulation. **Caution**: The y axis is usually generated internally by dc;
   * resetting it may cause unexpected results.
   * @name rightYAxis
   * @memberof dc.compositeChart
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/SVG-Axes d3.svg.axis}
   * @example
   * // customize y axis tick format
   * chart.rightYAxis().tickFormat(function (v) {return v + '%';});
   * // customize y axis tick values
   * chart.rightYAxis().tickValues([0, 100, 200, 300]);
   * @param {d3.svg.axis} [rightYAxis]
   * @return {d3.svg.axis}
   * @return {dc.compositeChart}
   */
  _chart.rightYAxis = function (rightYAxis) {
    if (!arguments.length) {
      return _rightYAxis;
    }
    _rightYAxis = rightYAxis;
    return _chart;
  };

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = dataCount;

var _baseMixin = __webpack_require__(7);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _coreAsync = __webpack_require__(5);

var _core = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The data count widget is a simple widget designed to display the number of records selected by the
 * current filters out of the total number of records in the data set. Once created the data count widget
 * will automatically update the text content of the following elements under the parent element.
 *
 * '.total-count' - total number of records
 * '.filter-count' - number of records matched by the current filters
 *
 * @name dataCount
 * @memberof dc
 * @mixes dc.baseMixin
 * @example
 * var ndx = crossfilter(data);
 * var all = ndx.groupAll();
 *
 * dc.dataCount('.dc-data-count')
 *     .dimension(ndx)
 *     .group(all);
 * @param {String|node|d3.selection} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector} specifying
 * a dom block element such as a div; or a dom element or d3 selection.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
 * Interaction with a chart will only trigger events and redraws within the chart's group.
 * @return {dc.dataCount}
 */
function dataCount(parent, chartGroup) {
  var _formatNumber = _d2.default.format(",d");
  var _chart = (0, _baseMixin2.default)({});
  var _html = { some: "", all: ""

    /* OVERRIDE ---------------------------------------------------------------- */
  };_chart.isCountChart = function () {
    return true;
  }; // override for count chart
  /* ------------------------------------------------------------------------- */

  (0, _core.override)(_chart, "group", function (group, name) {
    if (!arguments.length) {
      return _chart._group();
    }

    (0, _coreAsync.groupAll)(group);
    return _chart._group(group, name);
  });
  /**
   * Gets or sets an optional object specifying HTML templates to use depending how many items are
   * selected. The text `%total-count` will replaced with the total number of records, and the text
   * `%filter-count` will be replaced with the number of selected records.
   * - all: HTML template to use if all items are selected
   * - some: HTML template to use if not all items are selected
   * @name html
   * @memberof dc.dataCount
   * @instance
   * @example
   * counter.html({
   *      some: '%filter-count out of %total-count records selected',
   *      all: 'All records selected. Click on charts to apply filters'
   * })
   * @param {{some:String, all: String}} [options]
   * @return {{some:String, all: String}}
   * @return {dc.dataCount}
   */
  _chart.html = function (options) {
    if (!arguments.length) {
      return _html;
    }
    if (options.all) {
      _html.all = options.all;
    }
    if (options.some) {
      _html.some = options.some;
    }
    return _chart;
  };

  /**
   * Gets or sets an optional function to format the filter count and total count.
   * @name formatNumber
   * @memberof dc.dataCount
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/Formatting d3.format}
   * @example
   * counter.formatNumber(d3.format('.2g'))
   * @param {Function} [formatter=d3.format('.2g')]
   * @return {Function}
   * @return {dc.dataCount}
   */
  _chart.formatNumber = function (formatter) {
    if (!arguments.length) {
      return _formatNumber;
    }
    _formatNumber = formatter;
    return _chart;
  };

  /* OVERRIDE ---------------------------------------------------------------- */
  _chart.setDataAsync(function (group, callbacks) {
    return group.valueAsync().then(function (data) {
      callbacks(null, data);
    }).catch(function (error) {
      callbacks(error);
    });
  });
  /* ------------------------------------------------------------------------- */

  _chart._doRender = function () {
    // ok to call size b/c will hit cache every time
    var tot = _chart.dimension().size();
    _chart.root().style("width", "auto").style("height", "auto");

    /* OVERRIDE ---------------------------------------------------------------- */
    var val = null;
    if (_chart.dataCache != null) {
      val = _chart.dataCache;
    } else {
      val = _chart.group().value();
    }
    /* ------------------------------------------------------------------------- */

    var all = _formatNumber(tot);
    var selected = _formatNumber(val);

    if (tot === val && _html.all !== "") {
      _chart.root().html(_html.all.replace("%total-count", all).replace("%filter-count", selected));
    } else if (_html.some !== "") {
      _chart.root().html(_html.some.replace("%total-count", all).replace("%filter-count", selected));
    } else {
      _chart.selectAll(".total-count").text(all);

      /* OVERRIDE ---------------------------------------------------------------- */
      _chart.selectAll(".filter-count").classed("dark-text", all !== selected).text(selected);
      /* ------------------------------------------------------------------------- */
    }
    return _chart;
  };

  _chart._doRedraw = function () {
    return _chart._doRender();
  };

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = dataGrid;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _baseMixin = __webpack_require__(7);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Data grid is a simple widget designed to list the filtered records, providing
 * a simple way to define how the items are displayed.
 *
 * Note: Unlike other charts, the data grid chart (and data table) use the group attribute as a keying function
 * for {@link https://github.com/mbostock/d3/wiki/Arrays#-nest nesting} the data together in groups.
 * Do not pass in a crossfilter group as this will not work.
 *
 * Examples:
 * - {@link http://europarl.me/dc.js/web/ep/index.html List of members of the european parliament}
 * @name dataGrid
 * @memberof dc
 * @mixes dc.baseMixin
 * @param {String|node|d3.selection} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector} specifying
 * a dom block element such as a div; or a dom element or d3 selection.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
 * Interaction with a chart will only trigger events and redraws within the chart's group.
 * @return {dc.dataGrid}
 */
function dataGrid(parent, chartGroup) {
  var LABEL_CSS_CLASS = "dc-grid-label";
  var ITEM_CSS_CLASS = "dc-grid-item";
  var GROUP_CSS_CLASS = "dc-grid-group";
  var GRID_CSS_CLASS = "dc-grid-top";

  var _chart = (0, _baseMixin2.default)({});

  var _size = 999; // shouldn't be needed, but you might
  var _html = function _html(d) {
    return "you need to provide an html() handling param:  " + JSON.stringify(d);
  };
  var _sortBy = function _sortBy(d) {
    return d;
  };
  var _order = _d2.default.ascending;
  var _beginSlice = 0,
      _endSlice = void 0;

  var _htmlGroup = function _htmlGroup(d) {
    return "<div class='" + GROUP_CSS_CLASS + "'><h1 class='" + LABEL_CSS_CLASS + "'>" + _chart.keyAccessor()(d) + "</h1></div>";
  };

  _chart._doRender = function () {
    _chart.selectAll("div." + GRID_CSS_CLASS).remove();

    renderItems(renderGroups());

    return _chart;
  };

  function renderGroups() {
    var groups = _chart.root().selectAll("div." + GRID_CSS_CLASS).data(nestEntries(), function (d) {
      return _chart.keyAccessor()(d);
    });

    var itemGroup = groups.enter().append("div").attr("class", GRID_CSS_CLASS);

    if (_htmlGroup) {
      itemGroup.html(function (d) {
        return _htmlGroup(d);
      });
    }

    groups.exit().remove();
    return itemGroup;
  }

  function nestEntries() {
    var entries = _chart.dimension().top(_size);

    return _d2.default.nest().key(_chart.group()).sortKeys(_order).entries(entries.sort(function (a, b) {
      return _order(_sortBy(a), _sortBy(b));
    }).slice(_beginSlice, _endSlice));
  }

  function renderItems(groups) {
    var items = groups.order().selectAll("div." + ITEM_CSS_CLASS).data(function (d) {
      return d.values;
    });

    items.enter().append("div").attr("class", ITEM_CSS_CLASS).html(function (d) {
      return _html(d);
    });

    items.exit().remove();

    return items;
  }

  _chart._doRedraw = function () {
    return _chart._doRender();
  };

  /**
   * Get or set the index of the beginning slice which determines which entries get displayed by the widget.
   * Useful when implementing pagination.
   * @name beginSlice
   * @memberof dc.dataGrid
   * @instance
   * @param {Number} [beginSlice=0]
   * @return {Number}
   * @return {dc.dataGrid}
   */
  _chart.beginSlice = function (beginSlice) {
    if (!arguments.length) {
      return _beginSlice;
    }
    _beginSlice = beginSlice;
    return _chart;
  };

  /**
   * Get or set the index of the end slice which determines which entries get displayed by the widget
   * Useful when implementing pagination.
   * @name endSlice
   * @memberof dc.dataGrid
   * @instance
   * @param {Number} [endSlice]
   * @return {Number}
   * @return {dc.dataGrid}
   */
  _chart.endSlice = function (endSlice) {
    if (!arguments.length) {
      return _endSlice;
    }
    _endSlice = endSlice;
    return _chart;
  };

  /**
   * Get or set the grid size which determines the number of items displayed by the widget.
   * @name size
   * @memberof dc.dataGrid
   * @instance
   * @param {Number} [size=999]
   * @return {Number}
   * @return {dc.dataGrid}
   */
  _chart.size = function (size) {
    if (!arguments.length) {
      return _size;
    }
    _size = size;
    return _chart;
  };

  /**
   * Get or set the function that formats an item. The data grid widget uses a
   * function to generate dynamic html. Use your favourite templating engine or
   * generate the string directly.
   * @name html
   * @memberof dc.dataGrid
   * @instance
   * @example
   * chart.html(function (d) { return '<div class='item '+data.exampleCategory+''>'+data.exampleString+'</div>';});
   * @param {Function} [html]
   * @return {Function}
   * @return {dc.dataGrid}
   */
  _chart.html = function (html) {
    if (!arguments.length) {
      return _html;
    }
    _html = html;
    return _chart;
  };

  /**
   * Get or set the function that formats a group label.
   * @name htmlGroup
   * @memberof dc.dataGrid
   * @instance
   * @example
   * chart.htmlGroup (function (d) { return '<h2>'.d.key . 'with ' . d.values.length .' items</h2>'});
   * @param {Function} [htmlGroup]
   * @return {Function}
   * @return {dc.dataGrid}
   */
  _chart.htmlGroup = function (htmlGroup) {
    if (!arguments.length) {
      return _htmlGroup;
    }
    _htmlGroup = htmlGroup;
    return _chart;
  };

  /**
   * Get or set sort-by function. This function works as a value accessor at the item
   * level and returns a particular field to be sorted.
   * @name sortBy
   * @memberof dc.dataGrid
   * @instance
   * @example
   * chart.sortBy(function(d) {
   *     return d.date;
   * });
   * @param {Function} [sortByFunction]
   * @return {Function}
   * @return {dc.dataGrid}
   */
  _chart.sortBy = function (sortByFunction) {
    if (!arguments.length) {
      return _sortBy;
    }
    _sortBy = sortByFunction;
    return _chart;
  };

  /**
   * Get or set sort order function.
   * @name order
   * @memberof dc.dataGrid
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/Arrays#d3_ascending d3.ascending}
   * @see {@link https://github.com/mbostock/d3/wiki/Arrays#d3_descending d3.descending}
   * @example
   * chart.order(d3.descending);
   * @param {Function} [order=d3.ascending]
   * @return {Function}
   * @return {dc.dataGrid}
   */
  _chart.order = function (order) {
    if (!arguments.length) {
      return _order;
    }
    _order = order;
    return _chart;
  };

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = geoChoroplethChart;

var _baseMixin = __webpack_require__(7);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

var _colorMixin = __webpack_require__(12);

var _colorMixin2 = _interopRequireDefault(_colorMixin);

var _d2 = __webpack_require__(1);

var _d3 = _interopRequireDefault(_d2);

var _mapMixin = __webpack_require__(41);

var _mapMixin2 = _interopRequireDefault(_mapMixin);

var _core = __webpack_require__(3);

var _utils = __webpack_require__(4);

var _bbox = __webpack_require__(261);

var _bbox2 = _interopRequireDefault(_bbox);

var _bboxClip = __webpack_require__(263);

var _bboxClip2 = _interopRequireDefault(_bboxClip);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The geo choropleth chart is designed as an easy way to create a crossfilter driven choropleth map
 * from GeoJson data. This chart implementation was inspired by
 * {@link http://bl.ocks.org/4060606 the great d3 choropleth example}.
 *
 * @name geoChoroplethChart
 * @memberof dc
 * @mixes dc.colorMixin
 * @mixes dc.baseMixin
 * @example
 * // create a choropleth chart under '#us-chart' element using the default global chart group
 * var chart1 = dc.geoChoroplethChart('#us-chart');
 * // create a choropleth chart under '#us-chart2' element using chart group A
 * var chart2 = dc.compositeChart('#us-chart2', 'chartGroupA');
 * @param {String|node|d3.selection} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector} specifying
 * a dom block element such as a div; or a dom element or d3 selection.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
 * Interaction with a chart will only trigger events and redraws within the chart's group.
 * @return {dc.geoChoroplethChart}
 */
function geoChoroplethChart(parent, useMap, chartGroup, mapbox) {
  var _useMap = useMap !== undefined ? useMap : false;
  var parentDivId = parent.attributes.id.value;
  var _chart = null;
  if (_useMap) {
    _chart = (0, _mapMixin2.default)((0, _colorMixin2.default)((0, _baseMixin2.default)({})), parentDivId, mapbox);
  } else {
    _chart = (0, _colorMixin2.default)((0, _baseMixin2.default)({}));
  }

  _chart.colorAccessor(function (d) {
    return d || 0;
  });

  /* OVERRIDE -----------------------------------------------------------------*/
  _chart.accent = accentPoly;
  _chart.unAccent = unAccentPoly;

  _chart.measureValue = function (d) {
    var customFormatter = _chart.valueFormatter();
    return customFormatter && customFormatter(d) || _utils.utils.formatValue(d);
  };

  var _hasBeenRendered = false;
  /* --------------------------------------------------------------------------*/

  var _geoPath = _d3.default.geo.path();
  if (_useMap) {
    _geoPath.projection(_chart.mapProject.bind(_chart));
  }

  _chart._projectionFlag;

  var _geoJsons = [];
  _chart.transitionDuration(0);

  function findGeomMinMax(layerIndex) {
    var _geoJson = geoJson(layerIndex);
    var data = _geoJson.data;

    var realGeoJson = {
      type: "FeatureCollection",
      features: data
    };

    var _turfBbox = (0, _bbox2.default)(realGeoJson),
        _turfBbox2 = _slicedToArray(_turfBbox, 4),
        xMin = _turfBbox2[0],
        yMin = _turfBbox2[1],
        xMax = _turfBbox2[2],
        yMax = _turfBbox2[3];

    return [[xMin, yMin], [xMax, yMax]];
  }

  _chart.fitBounds = function () {
    if (geoJson(0)) {
      var bounds = geoJson(0).bounds;
      var llb = _chart.convertBounds(bounds);
      _chart.map().fitBounds(llb, { animate: false }, { skipRedraw: true });
    }
  };

  var _shiftToZoom = false;
  _chart.shiftToZoom = function (shiftToZoom) {
    if (shiftToZoom !== undefined) {
      _shiftToZoom = shiftToZoom;
    }
    return _shiftToZoom;
  };

  _chart.destroyChart = function () {
    this.map().remove();
  };

  _chart.getClosestResult = function () {
    // don't use logic in mouseup event in map-mixin.js
    return;
  };

  _chart._doRender = function (d) {
    _chart.resetSvg(); // will use map mixin reset svg if we inherit map mixin
    for (var layerIndex = 0; layerIndex < _geoJsons.length; ++layerIndex) {
      var states = _chart.svg().append("g").attr("class", "layer" + layerIndex);
      // .attr('transform', 'translate(0, -16)');

      // Clip each feature to the supported map extents
      var data = geoJson(layerIndex).data.map(function (feature) {
        return (0, _bboxClip2.default)(feature, [_chart.lonMin(), _chart.latMin(), _chart.lonMax(), _chart.latMax()]);
      });

      var regionG = states.selectAll("g." + geoJson(layerIndex).name).data(data).enter().append("g").attr("class", geoJson(layerIndex).name);

      regionG.append("path").attr("fill", "white").attr("d", _geoPath);

      regionG.append("title");

      plotData(layerIndex, d);
    }
    _chart._projectionFlag = false;

    /* OVERRIDE -----------------------------------------------------------------*/
    _hasBeenRendered = true;
    /* --------------------------------------------------------------------------*/
  };

  function plotData(layerIndex, d) {
    var data = generateLayeredData(d);

    if (isDataLayer(layerIndex)) {
      var regionG = renderRegionG(layerIndex);

      renderPaths(regionG, layerIndex, data);

      // renderTitle(regionG, layerIndex, data);
    }
  }

  function generateLayeredData(d) {
    var data = {};
    var groupAll = d;
    for (var i = 0; i < groupAll.length; ++i) {
      data[_chart.keyAccessor()(groupAll[i])] = _chart.valueAccessor()(groupAll[i]);
    }
    return data;
  }

  function isDataLayer(layerIndex) {
    return geoJson(layerIndex).keyAccessor;
  }

  function renderRegionG(layerIndex) {
    var regionG = _chart.svg().selectAll(layerSelector(layerIndex)).classed("selected", function (d) {
      return isSelected(layerIndex, d);
    }).classed("deselected", function (d) {
      return isDeselected(layerIndex, d);
    }).attr("class", function (d) {
      var layerNameClass = geoJson(layerIndex).name;
      var regionClass = _utils.utils.nameToId(geoJson(layerIndex).keyAccessor(d));
      var baseClasses = layerNameClass + " " + regionClass;
      if (isSelected(layerIndex, d)) {
        baseClasses = baseClasses + " selected";
      }
      if (isDeselected(layerIndex, d)) {
        baseClasses = baseClasses + " deselected";
      }
      return baseClasses;
    });
    return regionG;
  }

  function layerSelector(layerIndex) {
    return "g.layer" + layerIndex + " g." + geoJson(layerIndex).name;
  }

  /* OVERRIDE EXTEND ----------------------------------------------------------*/
  function accentPoly(label) {
    var layerNameClass = geoJson(0).name; // hack for now as we only allow one layer currently
    _chart.selectAll("g." + layerNameClass).each(function (d) {
      if (getKey(0, d) == label) {
        _chart.accentSelected(this);
      }
    });
  }

  function unAccentPoly(label) {
    var layerNameClass = geoJson(0).name; // hack for now as we only allow one layer currently
    _chart.selectAll("g." + layerNameClass).each(function (d) {
      if (getKey(0, d) == label) {
        _chart.unAccentSelected(this);
      }
    });
  }
  /* --------------------------------------------------------------------------*/

  function isSelected(layerIndex, d) {
    return _chart.hasFilter() && _chart.hasFilter(getKey(layerIndex, d)) ^ _chart.filtersInverse();
  }

  function isDeselected(layerIndex, d) {
    return _chart.hasFilter() && !isSelected(layerIndex, d);
  }

  function getKey(layerIndex, d) {
    return geoJson(layerIndex).keyAccessor(d);
  }

  function geoJson(index) {
    return _geoJsons[index];
  }

  function renderPaths(regionG, layerIndex, data) {
    /* OVERRIDE ---------------------------------------------------------------- */
    var dragRegion = _d3.default.behavior.drag().on("dragstart", function () {
      _d3.default.event.sourceEvent.preventDefault();
    });
    /* ------------------------------------------------------------------------- */

    var paths = regionG.select("path").attr("fill", function () {
      var currentFill = _d3.default.select(this).attr("fill");
      if (currentFill) {
        return currentFill;
      }
      return "#e2e2e2";
    })
    /* OVERRIDE ---------------------------------------------------------------- */
    .on("mouseenter", function (d, i) {
      showPopup(d, i, data);
    }).on("mousemove", positionPopup).on("mouseleave", hidePopup).call(dragRegion)
    /* ------------------------------------------------------------------------- */
    .on("click", function (d) {
      return _chart.onClick(d, layerIndex);
    });

    (0, _core.transition)(paths, _chart.transitionDuration()).attr("fill", function (d, i) {
      var dataColor = data[geoJson(layerIndex).keyAccessor(d)];
      return _chart.getColor(dataColor, i);
    });
  }

  _chart.onClick = function (d, layerIndex) {
    var selectedRegion = geoJson(layerIndex).keyAccessor(d);
    _chart.handleFilterClick(_d3.default.event, selectedRegion);
  };

  function renderTitle(regionG, layerIndex, data) {
    if (_chart.renderTitle()) {
      regionG.selectAll("title").text(function (d) {
        var key = getKey(layerIndex, d);

        /* OVERRIDE -----------------------------------------------------------------*/
        var value = Number(data[key]).toFixed(2);
        return _chart.title()({ key0: key, value: value });
        /* --------------------------------------------------------------------------*/
      });
    }
  }

  _chart._doRedraw = function (data) {
    /* OVERRIDE -----------------------------------------------------------------*/
    if (!_hasBeenRendered) {
      return _chart._doRender();
    }
    /* --------------------------------------------------------------------------*/

    for (var layerIndex = 0; layerIndex < _geoJsons.length; ++layerIndex) {
      plotData(layerIndex, data);
      if (_chart._projectionFlag) {
        _chart.svg().selectAll("g." + geoJson(layerIndex).name + " path").attr("d", _geoPath);
      }
    }
    _chart._projectionFlag = false;
  };

  /**
   * **mandatory**
   *
   * Use this function to insert a new GeoJson map layer. This function can be invoked multiple times
   * if you have multiple GeoJson data layers to render on top of each other. If you overlay multiple
   * layers with the same name the new overlay will override the existing one.
   * @name overlayGeoJson
   * @memberof dc.geoChoroplethChart
   * @instance
   * @see {@link http://geojson.org/ GeoJSON}
   * @see {@link https://github.com/mbostock/topojson/wiki TopoJSON}
   * @see {@link https://github.com/mbostock/topojson/wiki/API-Reference#feature topojson.feature}
   * @example
   * // insert a layer for rendering US states
   * chart.overlayGeoJson(statesJson.features, 'state', function(d) {
   *      return d.properties.name;
   * })
   * @param {geoJson} json - a geojson feed
   * @param {String} name - name of the layer
   * @param {Function} keyAccessor - accessor function used to extract 'key' from the GeoJson data. The key extracted by
   * this function should match the keys returned by the crossfilter groups.
   * @return {dc.geoChoroplethChart}
   */
  _chart.overlayGeoJson = function (json, name, keyAccessor) {
    for (var i = 0; i < _geoJsons.length; ++i) {
      if (_geoJsons[i].name === name) {
        _geoJsons[i].data = json;
        _geoJsons[i].keyAccessor = keyAccessor;
        return _chart;
      }
    }
    _geoJsons.push({ name: name, data: json, keyAccessor: keyAccessor });
    _geoJsons[_geoJsons.length - 1].bounds = findGeomMinMax(_geoJsons.length - 1);

    return _chart;
  };

  /**
   * Set custom geo projection function. See the available [d3 geo projection
   * functions](https://github.com/mbostock/d3/wiki/Geo-Projections).
   * @name projection
   * @memberof dc.geoChoroplethChart
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/Geo-Projections d3.geo.projection}
   * @see {@link https://github.com/d3/d3-geo-projection Extended d3.geo.projection}
   * @param {d3.projection} [projection=d3.geo.albersUsa()]
   * @return {dc.geoChoroplethChart}
   */
  _chart.projection = function (projection) {
    if (!_useMap) {
      _geoPath.projection(projection);
      _chart._projectionFlag = true;
    }
    return _chart;
  };

  /**
   * Returns all GeoJson layers currently registered with this chart. The returned array is a
   * reference to this chart's internal data structure, so any modification to this array will also
   * modify this chart's internal registration.
   * @name geoJsons
   * @memberof dc.geoChoroplethChart
   * @instance
   * @return {Array<{name:String, data: Object, accessor: Function}>}
   */
  _chart.geoJsons = function () {
    return _geoJsons;
  };

  /**
   * Returns the {@link https://github.com/mbostock/d3/wiki/Geo-Paths#path d3.geo.path} object used to
   * render the projection and features.  Can be useful for figuring out the bounding box of the
   * feature set and thus a way to calculate scale and translation for the projection.
   * @name geoPath
   * @memberof dc.geoChoroplethChart
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/Geo-Paths#path d3.geo.path}
   * @return {d3.geo.path}
   */
  _chart.geoPath = function () {
    return _geoPath;
  };

  /**
   * Remove a GeoJson layer from this chart by name
   * @name removeGeoJson
   * @memberof dc.geoChoroplethChart
   * @instance
   * @param {String} name
   * @return {dc.geoChoroplethChart}
   */
  _chart.removeGeoJson = function (name) {
    var geoJsons = [];

    for (var i = 0; i < _geoJsons.length; ++i) {
      var layer = _geoJsons[i];
      if (layer.name !== name) {
        geoJsons.push(layer);
      }
    }

    _geoJsons = geoJsons;

    return _chart;
  };
  /* OVERRIDE ---------------------------------------------------------------- */
  function showPopup(d, i, data) {
    var popup = _chart.popup();

    var popupBox = popup.select(".chart-popup-content").html("");

    popupBox.append("div").attr("class", "popup-legend").style("background-color", _chart.getColor(data[geoJson(0).keyAccessor(d)], i));

    popupBox.append("div").attr("class", "popup-value").html(function () {
      var key = getKey(0, d);
      var value = isNaN(data[key]) ? "N/A" : _chart.measureValue(data[key]);
      return '<div class="popup-value-dim">' + key + '</div><div class="popup-value-measure">' + value + "</div>";
    });

    popup.classed("js-showPopup", true);
  }

  function hidePopup() {
    _chart.popup().classed("js-showPopup", false);
  }

  function positionPopup() {
    var coordinates = [0, 0];
    coordinates = _chart.popupCoordinates(_d3.default.mouse(this));
    var x = coordinates[0];
    var y = coordinates[1] - 16;
    var popup = _chart.popup().attr("style", function () {
      return "transform:translate(" + x + "px," + y + "px)";
    });

    popup.select(".chart-popup-box").classed("align-right", function () {
      return x + _d3.default.select(this).node().getBoundingClientRect().width > _chart.width();
    });
  }
  /* ------------------------------------------------------------------------- */

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utilsLatlon = __webpack_require__(24);

var LatLonUtils = _interopRequireWildcard(_utilsLatlon);

var _mapdDraw = __webpack_require__(13);

var MapdDraw = _interopRequireWildcard(_mapdDraw);

var _simplifyJs = __webpack_require__(260);

var _simplifyJs2 = _interopRequireDefault(_simplifyJs);

var _logger = __webpack_require__(36);

var _LatLonCircle = __webpack_require__(190);

var _LatLonCircle2 = _interopRequireDefault(_LatLonCircle);

var _LatLonPoly = __webpack_require__(192);

var _LatLonPoly2 = _interopRequireDefault(_LatLonPoly);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AABox2d = MapdDraw.AABox2d,
    Mat2 = MapdDraw.Mat2,
    Point2d = MapdDraw.Point2d,
    Vec2d = MapdDraw.Vec2d;

var MathExt = MapdDraw.Math;

/* istanbul ignore next */

var ShapeHandler = function () {
  function ShapeHandler(parent, drawEngine, chart, buttonGroup, buttonId, defaultStyle, defaultSelectStyle) {
    _classCallCheck(this, ShapeHandler);

    this.parent = parent;
    this.drawEngine = drawEngine;
    this.canvas = drawEngine.getCanvas();
    this.chart = chart;
    this.baseMap = chart.map();
    this.buttonGroup = buttonGroup;
    this.buttonId = buttonId;
    this.defaultStyle = defaultStyle;
    this.defaultSelectStyle = defaultSelectStyle;
    this.mousedownCB = this.mousedownCB.bind(this);
    this.mouseupCB = this.mouseupCB.bind(this);
    this.mousemoveCB = this.mousemoveCB.bind(this);
    this.mouseoverCB = this.mouseoverCB.bind(this);
    this.clickCB = this.clickCB.bind(this);
    this.dblclickCB = this.dblclickCB.bind(this);
    this.keydownCB = this.keydownCB.bind(this);
    this.active = false;

    this.useLonLat = typeof this.chart.useLonLat === "function" && this.chart.useLonLat();
  }

  _createClass(ShapeHandler, [{
    key: "disableBasemapEvents",
    value: function disableBasemapEvents() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.chart.hidePopup(true);
      this.chart.enableInteractions(false, options);
    }
  }, {
    key: "enableBasemapEvents",
    value: function enableBasemapEvents() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.chart.enableInteractions(true, options);
    }
  }, {
    key: "addShape",
    value: function addShape(shape) {
      var selectOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this.drawEngine.addShape(shape, selectOpts);
      this.drawEngine.moveShapeToTop(shape);
    }
  }, {
    key: "setupFinalShape",
    value: function setupFinalShape(shape) {
      var selectOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // deactivate the button associated with this shape handler
      // first to make sure that when the shape is selected,
      // the selection event handler is run. The selection event
      // handler is only run when all the button are deactivated,
      // so need to deactivate the button first, and the select
      // the new shape
      this.buttonGroup.deactivateButton(this.buttonId);
      if (this.drawEngine.hasShape(shape)) {
        this.drawEngine.selectShape(shape);
      } else {
        this.drawEngine.addShape(shape, selectOpts, true);
        this.drawEngine.moveShapeToTop(shape);
      }
      this.chart.addFilterShape(shape);
      this.canvas.focus();
    }
  }, {
    key: "mousedownCB",
    value: function mousedownCB(event) {}
  }, {
    key: "mouseupCB",
    value: function mouseupCB(event) {}
  }, {
    key: "mousemoveCB",
    value: function mousemoveCB(event) {}
  }, {
    key: "mouseoverCB",
    value: function mouseoverCB(event) {}
  }, {
    key: "clickCB",
    value: function clickCB(event) {}
  }, {
    key: "dblclickCB",
    value: function dblclickCB(event) {}
  }, {
    key: "keydownCB",
    value: function keydownCB(event) {}
  }, {
    key: "isMouseEventInCanvas",
    value: function isMouseEventInCanvas(mouseEvent) {
      var width = this.canvas.offsetWidth;
      var height = this.canvas.offsetHeight;
      var rect = this.canvas.getBoundingClientRect();

      var diffX = mouseEvent.clientX - rect.left - this.canvas.clientLeft;
      var diffY = mouseEvent.clientY - rect.top - this.canvas.clientTop;

      return diffX >= 0 && diffX < width && diffY >= 0 && diffY < height;
    }
  }, {
    key: "getRelativeMousePosFromEvent",
    value: function getRelativeMousePosFromEvent(mouseEvent) {
      var width = this.canvas.offsetWidth;
      var height = this.canvas.offsetHeight;
      var rect = this.canvas.getBoundingClientRect();

      var diffX = mouseEvent.clientX - rect.left - this.canvas.clientLeft;
      var diffY = mouseEvent.clientY - rect.top - this.canvas.clientTop;
      var mousepos = Point2d.create(diffX, diffY);

      return mousepos;
    }
  }, {
    key: "activate",
    value: function activate() {
      if (!this.active) {
        document.addEventListener("mousedown", this.mousedownCB);
        document.addEventListener("mouseup", this.mouseupCB);
        document.addEventListener("mousemove", this.mousemoveCB);
        document.addEventListener("mouseover", this.mouseoverCB);
        document.addEventListener("click", this.clickCB);
        document.addEventListener("dblclick", this.dblclickCB);

        // NOTE: canvas div was setup to be focusable
        // and handle keyboard events in initControls()
        // function
        this.canvas.addEventListener("keydown", this.keydownCB);
        this.canvas.focus();

        this.active = true;
      }
    }
  }, {
    key: "deactivate",
    value: function deactivate() {
      if (this.active) {
        this.destroy();
        document.removeEventListener("mousedown", this.mousedownCB);
        document.removeEventListener("mouseup", this.mouseupCB);
        document.removeEventListener("mousemove", this.mousemoveCB);
        document.removeEventListener("mouseover", this.mouseoverCB);
        document.removeEventListener("click", this.clickCB);
        document.removeEventListener("dblclick", this.dblclickCB);

        this.canvas.removeEventListener("keydown", this.keydownCB);
        this.canvas.blur();

        this.active = false;
      }
    }
  }]);

  return ShapeHandler;
}();

/* istanbul ignore next */


var CircleShapeHandler = function (_ShapeHandler) {
  _inherits(CircleShapeHandler, _ShapeHandler);

  function CircleShapeHandler(parent, drawEngine, chart, buttonGroup, buttonId, defaultStyle, defaultSelectStyle) {
    _classCallCheck(this, CircleShapeHandler);

    var _this = _possibleConstructorReturn(this, (CircleShapeHandler.__proto__ || Object.getPrototypeOf(CircleShapeHandler)).call(this, parent, drawEngine, chart, buttonGroup, buttonId, defaultStyle, defaultSelectStyle));

    _this.startmousepos = Point2d.create(0, 0);
    _this.startmouseworldpos = Point2d.create(0, 0);
    if (_this.useLonLat) {
      _this.startmouselatlonpos = Point2d.create(0, 0);
    }
    _this.activeshape = null;
    _this.timer = null;
    return _this;
  }

  _createClass(CircleShapeHandler, [{
    key: "deactivateShape",
    value: function deactivateShape() {
      if (this.activeShape) {
        var shape = this.activeShape;
        if (performance.now() - this.timer < 500) {
          // this is a click, so give the circle a default radius
          var bounds = this.chart.getDataRenderBounds();
          var currXRange = [bounds[0][0], bounds[1][0]];
          var currYRange = [bounds[0][1], bounds[2][1]];
          var projDims = [0.1 * Math.abs(currXRange[1] - currXRange[0]), 0.1 * Math.abs(currYRange[1] - currYRange[0])];
          if (this.useLonLat) {
            var pos = shape.getPosition();
            // convert from mercator to lat/lon
            LatLonUtils.conv900913To4326(pos, pos);

            projDims[0] = LatLonUtils.distance_in_meters(pos[0], pos[1], pos[0] + projDims[0], pos[1]) / 1000.0;
            projDims[1] = LatLonUtils.distance_in_meters(pos[0], pos[1], pos[0], pos[1] + projDims[1]) / 1000.0;
            shape.initialRadius = Math.min(projDims[0], projDims[1]);
          } else {
            shape.radius = Math.min(projDims[0], projDims[1]);
          }
        }
        // need to unset the active shape here first
        // before calling setupFinalShape, because
        // inside that call it's going to call destroy()
        this.activeShape = null;
        shape.setStyle(this.defaultStyle);
        this.setupFinalShape(shape);
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.activeShape) {
        this.drawEngine.deleteShape(this.activeShape);
        this.activeShape = null;
      }
    }
  }, {
    key: "mousedownCB",
    value: function mousedownCB(event) {
      if (!this.isMouseEventInCanvas(event)) {
        return;
      }

      this.disableBasemapEvents();
      Point2d.copy(this.startmousepos, this.getRelativeMousePosFromEvent(event));
      this.drawEngine.project(this.startmouseworldpos, this.startmousepos);
      this.timer = performance.now();

      // convert from mercator to lat/lon
      var selectOpts = {};
      if (this.useLonLat) {
        LatLonUtils.conv900913To4326(this.startmouselatlonpos, this.startmouseworldpos);

        this.activeShape = new _LatLonCircle2.default(this.drawEngine, Object.assign({
          position: this.startmouseworldpos,
          radius: 0
        }, this.defaultSelectStyle));

        selectOpts.uniformScaleOnly = true;
        selectOpts.centerScaleOnly = true;
        selectOpts.rotatable = false;
      } else {
        this.activeShape = new MapdDraw.Circle(Object.assign({
          position: this.startmouseworldpos,
          radius: 0
        }, this.defaultSelectStyle));
      }
      this.canvas.focus();
      this.addShape(this.activeShape, selectOpts);
      event.stopImmediatePropagation();
      event.preventDefault();
    }
  }, {
    key: "mouseupCB",
    value: function mouseupCB(event) {
      this.deactivateShape();
    }
  }, {
    key: "mousemoveCB",
    value: function mousemoveCB(event) {
      if (this.activeShape) {
        var mousepos = this.getRelativeMousePosFromEvent(event);
        var mousescreenpos = Point2d.create(0, 0);
        this.drawEngine.project(mousescreenpos, mousepos);

        if (this.useLonLat) {
          // convert from mercator to lat/lon
          LatLonUtils.conv900913To4326(mousescreenpos, mousescreenpos);
          var radius = LatLonUtils.distance_in_meters(this.startmouselatlonpos[0], this.startmouselatlonpos[1], mousescreenpos[0], mousescreenpos[1]);
          this.activeShape.initialRadius = radius / 1000;
        } else {
          var _radius = Point2d.distance(this.startmouseworldpos, mousescreenpos);
          this.activeShape.radius = _radius;
        }

        // stopping all mousemove events, namely to stop hover callbacks
        event.stopImmediatePropagation();
        event.preventDefault();
      }
    }
  }, {
    key: "clickCB",
    value: function clickCB(event) {
      this.deactivateShape();
    }
  }, {
    key: "keydownCB",
    value: function keydownCB(event) {
      if (event.key === "Escape" || event.code === "Escape" || event.keyCode === 27) {
        this.destroy();
        this.enableBasemapEvents();
      }
    }
  }]);

  return CircleShapeHandler;
}(ShapeHandler);

/* istanbul ignore next */


var PolylineShapeHandler = function (_ShapeHandler2) {
  _inherits(PolylineShapeHandler, _ShapeHandler2);

  function PolylineShapeHandler(parent, drawEngine, chart, buttonGroup, buttonId, defaultStyle, defaultSelectStyle) {
    _classCallCheck(this, PolylineShapeHandler);

    var _this2 = _possibleConstructorReturn(this, (PolylineShapeHandler.__proto__ || Object.getPrototypeOf(PolylineShapeHandler)).call(this, parent, drawEngine, chart, buttonGroup, buttonId, defaultStyle, defaultSelectStyle));

    _this2.activeShape = null;
    _this2.startVert = null;
    _this2.lastVert = null;
    _this2.lineShape = null;
    _this2.prevVertPos = null;
    _this2.activeIdx = -1;
    _this2.startPosAABox = AABox2d.create();
    _this2.timer = null;

    _this2.enableBasemapDebounceFunc = chart.debounce(function () {
      if (_this2.active) {
        _this2.enableBasemapEvents();
      }
    }, 100);
    return _this2;
  }

  _createClass(PolylineShapeHandler, [{
    key: "destroy",
    value: function destroy() {
      if (this.startVert) {
        this.drawEngine.deleteShape(this.startVert);
      }
      if (this.lastVert) {
        this.drawEngine.deleteShape(this.lastVert);
      }
      if (this.lineShape) {
        this.drawEngine.deleteShape(this.lineShape);
      }

      this.startVert = this.lastVert = this.lineShape = this.activeShape = this.prevVertPos = null;
      AABox2d.initEmpty(this.startPosAABox);
      this.activeIdx = -1;
    }
  }, {
    key: "appendVertex",
    value: function appendVertex(mousepos, mouseworldpos) {
      if (this.lineShape) {
        if (!this.prevVertPos || Math.abs(mousepos[0] - this.prevVertPos[0]) > 2 || Math.abs(mousepos[1] - this.prevVertPos[1]) > 2) {
          this.prevVertPos = mousepos;
          return this.lineShape.appendVert(mouseworldpos);
        }
      }
      return -1;
    }
  }, {
    key: "finishShape",
    value: function finishShape() {
      var verts = this.lineShape ? this.lineShape.vertsRef : [];
      var removeLastVert = verts.length > 1 && !Point2d.equals(verts[0], verts[verts.length - 1]) && this.lastVert && !Point2d.equals(verts[verts.length - 1], this.lastVert.getPositionRef());
      if (verts.length > 2 && (!removeLastVert || verts.length > 3)) {
        // Check if there is a loop in the current verts, remove the last point
        // if so
        if (removeLastVert) {
          verts.pop();
        }

        var args = [];
        var PolyClass = null;
        if (this.useLonLat) {
          PolyClass = _LatLonPoly2.default;
          args.push(this.drawEngine);
        } else {
          PolyClass = MapdDraw.Poly;
        }
        args.push(Object.assign({
          verts: verts
        }, this.defaultStyle));
        var poly = new (Function.prototype.bind.apply(PolyClass, [null].concat(args)))();
        this.setupFinalShape(poly);

        // clear out all other shapes using our destroy method
        this.destroy();
      } else {
        this.destroy();
        this.enableBasemapEvents();
      }
    }
  }, {
    key: "mousedownCB",
    value: function mousedownCB(event) {
      if (!this.isMouseEventInCanvas(event)) {
        this.timer = null;
        return;
      }

      this.timer = performance.now();
    }
  }, {
    key: "mouseupCB",
    value: function mouseupCB(event) {
      if (this.timer && performance.now() - this.timer < 500) {
        this.disableBasemapEvents();

        var shapeBuilt = false;
        var mousepos = this.getRelativeMousePosFromEvent(event);
        var mouseworldpos = Point2d.create(0, 0);
        this.drawEngine.project(mouseworldpos, mousepos);

        if (!this.startVert) {
          this.lineShape = new MapdDraw.PolyLine(Object.assign({
            verts: [mouseworldpos]
          }, this.defaultSelectStyle));
          this.addShape(this.lineShape);
          this.startVert = new MapdDraw.Point({
            position: mouseworldpos,
            size: 5
          });
          this.addShape(this.startVert);
          this.activeShape = this.startVert;
          this.prevVertPos = mousepos;
          this.activeIdx = 0;
        } else if (!this.lastVert && this.lineShape.numVerts > 1) {
          var verts = this.lineShape.vertsRef;
          this.lastVert = new MapdDraw.Point({
            position: verts[1],
            size: 5
          });
          this.addShape(this.lastVert);
          this.activeShape = this.lastVert;
          this.activeIdx = 1;
        } else if (this.lastVert) {
          var startpos = this.startVert.getPosition();
          this.drawEngine.unproject(startpos, startpos);
          AABox2d.initCenterExtents(this.startPosAABox, startpos, [10, 10]);
          if (AABox2d.containsPt(this.startPosAABox, mousepos)) {
            this.finishShape();
            shapeBuilt = true;
          } else {
            var _verts = this.lineShape.vertsRef;
            this.lastVert.setPosition(_verts[_verts.length - 1]);
            this.activeShape = this.lastVert;
          }
        }

        if (!shapeBuilt) {
          this.enableBasemapDebounceFunc();
          this.canvas.focus();
          this.activeShape = null;
          this.activeIdx = -1;
        }
        event.preventDefault();
      }
    }
  }, {
    key: "mousemoveCB",
    value: function mousemoveCB(event) {
      if (this.startVert && this.lineShape && this.activeIdx < 0) {
        var mousepos = this.getRelativeMousePosFromEvent(event);
        var mouseworldpos = Point2d.create(0, 0);
        this.drawEngine.project(mouseworldpos, mousepos);
        this.activeIdx = this.appendVertex(mousepos, mouseworldpos);
      }

      if (this.activeShape || this.activeIdx >= 0) {
        var _mousepos = this.getRelativeMousePosFromEvent(event);
        var _mouseworldpos = Point2d.create(0, 0);
        this.drawEngine.project(_mouseworldpos, _mousepos);

        if (event.shiftKey) {
          if (this.activeIdx === 1) {
            var diff = Vec2d.create();
            var prevmousepos = Point2d.create();
            var verts = this.lineShape.vertsRef;
            this.drawEngine.unproject(prevmousepos, verts[0]);
            Point2d.sub(diff, _mousepos, prevmousepos);
            var angle = Math.atan2(diff[1], diff[0]);
            angle = MathExt.round(angle / MathExt.QUATER_PI) * MathExt.QUATER_PI;
            var transformDir = [Math.cos(angle), Math.sin(angle)];
            Vec2d.scale(diff, transformDir, Vec2d.dot(diff, transformDir));
            Point2d.addVec2(_mousepos, prevmousepos, diff);
            this.drawEngine.project(_mouseworldpos, _mousepos);
          } else if (this.activeIdx > 1) {
            var _verts2 = this.lineShape.vertsRef;
            var pt1 = Point2d.create();
            this.drawEngine.unproject(pt1, _verts2[this.activeIdx - 2]);
            var pt2 = Point2d.create();
            this.drawEngine.unproject(pt2, _verts2[this.activeIdx - 1]);
            var dir1 = Vec2d.create();
            Point2d.sub(dir1, pt2, pt1);
            Vec2d.normalize(dir1, dir1);
            var dir2 = [0, 0];
            Point2d.sub(dir2, _mousepos, pt2);
            // Vec2d.normalize(dir2, dir2)
            var _angle = Vec2d.angle(dir1, dir2);
            _angle = MathExt.round(_angle / MathExt.QUATER_PI) * MathExt.QUATER_PI;
            var matrix = Mat2.create();
            Mat2.fromRotation(matrix, _angle);
            var _transformDir = [0, 0];
            Vec2d.transformMat2(_transformDir, dir1, matrix);
            Vec2d.scale(_transformDir, _transformDir, Vec2d.dot(dir2, _transformDir));
            Point2d.addVec2(_mousepos, pt2, _transformDir);
            this.drawEngine.project(_mouseworldpos, _mousepos);
          }
        }

        if (this.activeShape) {
          this.activeShape.setPosition(_mouseworldpos);
        }

        if (this.activeIdx >= 0) {
          this.lineShape.setVertPosition(this.activeIdx, _mouseworldpos);
          this.canvas.focus();
        }
        event.preventDefault();
      }
    }
  }, {
    key: "dblclickCB",
    value: function dblclickCB(event) {
      if (!this.isMouseEventInCanvas(event)) {
        return;
      }

      this.finishShape();
    }
  }, {
    key: "keydownCB",
    value: function keydownCB(event) {
      if (event.key === "Escape" || event.code === "Escape" || event.keyCode === 27) {
        this.destroy();
        this.enableBasemapEvents();
      } else if (event.key === "Enter" || event.code === "Enter" || event.code === "NumpadEnter" || event.keyCode === 13) {
        this.finishShape();
      }
    }
  }]);

  return PolylineShapeHandler;
}(ShapeHandler);

/* istanbul ignore next */


var LassoShapeHandler = function (_ShapeHandler3) {
  _inherits(LassoShapeHandler, _ShapeHandler3);

  function LassoShapeHandler(parent, drawEngine, chart, buttonGroup, buttonId, defaultStyle, defaultSelectStyle) {
    _classCallCheck(this, LassoShapeHandler);

    var _this3 = _possibleConstructorReturn(this, (LassoShapeHandler.__proto__ || Object.getPrototypeOf(LassoShapeHandler)).call(this, parent, drawEngine, chart, buttonGroup, buttonId, defaultStyle, defaultSelectStyle));

    _this3.activeShape = null;
    _this3.lastPos = null;
    _this3.lastWorldPos = null;
    return _this3;
  }

  _createClass(LassoShapeHandler, [{
    key: "destroy",
    value: function destroy() {
      if (this.activeShape) {
        this.drawEngine.deleteShape(this.activeShape);
        this.activeShape = null;
      }
      this.lastPos = this.lastWorldPos = null;
    }
  }, {
    key: "mousedownCB",
    value: function mousedownCB(event) {
      if (!this.isMouseEventInCanvas(event)) {
        return;
      }

      this.disableBasemapEvents();
      this.activeShape = null;
      this.lastPos = this.getRelativeMousePosFromEvent(event);
      this.lastWorldPos = Point2d.create(0, 0);
      this.drawEngine.project(this.lastWorldPos, this.lastPos);
      event.preventDefault();
    }
  }, {
    key: "mousemoveCB",
    value: function mousemoveCB(event) {
      if (!this.isMouseEventInCanvas(event)) {
        if (this.activeShape) {
          this.drawEngine.deleteShape(this.activeShape);
          this.activeShape = null;
          this.lastPos = null;
          this.lastWorldPos = null;
          this.enableBasemapEvents();
        }
        return;
      }

      if (this.lastPos) {
        var currPos = this.getRelativeMousePosFromEvent(event);
        var currWorldPos = Point2d.create(0, 0);
        this.drawEngine.project(currWorldPos, currPos);
        if (!Point2d.equals(currPos, this.lastPos)) {
          if (!this.activeShape) {
            this.activeShape = new MapdDraw.PolyLine(Object.assign({
              verts: [this.lastWorldPos, currWorldPos]
            }, this.defaultSelectStyle));
            this.addShape(this.activeShape);
          } else {
            this.activeShape.appendVert(currWorldPos);
          }
          Point2d.copy(this.lastPos, currPos);
          Point2d.copy(this.lastWorldPos, currWorldPos);
          this.canvas.focus();
        }
        event.preventDefault();
      }
    }
  }, {
    key: "mouseupCB",
    value: function mouseupCB(event) {
      var _this4 = this;

      if (this.activeShape) {
        var verts = this.activeShape.vertsRef;
        var screenVert = Point2d.create(0, 0);
        var worldVert = Point2d.create(0, 0);
        var simpleVerts = verts.map(function (vert) {
          _this4.drawEngine.unproject(screenVert, vert);
          return {
            x: screenVert[0],
            y: screenVert[1]
          };
        });
        simpleVerts = (0, _simplifyJs2.default)(simpleVerts, 4, true);
        var newverts = simpleVerts.map(function (vert) {
          Point2d.set(screenVert, vert.x, vert.y);
          _this4.drawEngine.project(worldVert, screenVert);
          return Point2d.clone(worldVert);
        });

        if (newverts.length < 3) {
          _logger.logger.warn("The resulting lasso shape is a point or a straight line. Cannot build a polygon from it. Please try again");
          this.drawEngine.deleteShape(this.activeShape);
          this.activeShape = null;
        } else {
          var args = [];
          var PolyClass = null;
          if (this.useLonLat) {
            PolyClass = _LatLonPoly2.default;
            args.push(this.drawEngine);
          } else {
            PolyClass = MapdDraw.Poly;
          }
          args.push(Object.assign({
            verts: newverts
          }, this.defaultStyle));
          var poly = new (Function.prototype.bind.apply(PolyClass, [null].concat(args)))();
          this.drawEngine.deleteShape(this.activeShape);
          this.setupFinalShape(poly);
          event.preventDefault();
        }
      }
      this.lastPos = null;
      this.lastWorldPos = null;
    }
  }, {
    key: "keydownCB",
    value: function keydownCB(event) {
      if (event.key === "Escape" || event.code === "Escape" || event.keyCode === 27) {
        this.destroy();
        this.enableBasemapEvents();
      }
    }
  }]);

  return LassoShapeHandler;
}(ShapeHandler);

/* istanbul ignore next */


var LassoButtonGroupController = function () {
  function LassoButtonGroupController(parentContainer, parentChart, parentDrawEngine, defaultStyle, defaultSelectStyle) {
    _classCallCheck(this, LassoButtonGroupController);

    this._container = parentContainer;
    this._chart = parentChart;
    this._drawEngine = parentDrawEngine;
    this._buttonElements = {};
    this._activeButton = null;
    this._activeShape = null;

    this._selectionchangedCB = this._selectionchangedCB.bind(this);
    this._dragbeginCB = this._dragbeginCB.bind(this);
    this._dragendCB = this._dragendCB.bind(this);
    this._keyboardCB = this._keyboardCB.bind(this);
    this._initControls(defaultStyle, defaultSelectStyle);
  }

  _createClass(LassoButtonGroupController, [{
    key: "destroy",
    value: function destroy() {
      if (this._controlsInitted) {
        var canvas = this._drawEngine.getCanvas();
        canvas.removeEventListener("keydown", this._keyboardCB);

        this._circleHandler.deactivate();
        this._polylineHandler.deactivate();
        this._lassoHandler.deactivate();

        this._drawEngine.off(MapdDraw.ShapeBuilder.EventConstants.DRAG_END, this._dragendCB);
        this._drawEngine.off(MapdDraw.ShapeBuilder.EventConstants.DRAG_END, this._dragbeginCB);
        this._drawEngine.off(MapdDraw.ShapeBuilder.EventConstants.SELECTION_CHANGED, this._selectionchangedCB);

        this._controlContainer.removeChild(this._controlGroup);
        this._container.removeChild(this._controlContainer);
      }
    }
  }, {
    key: "_createControlButton",
    value: function _createControlButton(id) {
      var _this5 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var button = document.createElement("button");
      button.className = "mapd-draw-button " + options.className;
      button.setAttribute("title", options.title);
      this._controlGroup.appendChild(button);

      button.addEventListener("click", function (e) {
        e.preventDefault();
        e.stopPropagation();

        var clickedButton = e.target;
        if (_this5._activeButton && _this5._activeButton.button === clickedButton) {
          _this5.deactivateButtons();
          if (options.onDeactivate) {
            options.onDeactivate();
          }
          return;
        }

        _this5.setActiveButton(id, options);
        options.onActivate();
      }, true);

      button.addEventListener("mousedown", function (e) {
        _this5._chart.hidePopup(true);
        e.stopPropagation();
        e.preventDefault();
      });

      button.addEventListener("mouseover", function (e) {
        _this5._chart.hidePopup(true);
        _this5._chart.popupDisplayable(false);
        _this5._drawEngine.disableInteractions(false);
      });

      button.addEventListener("mouseout", function (e) {
        if (!_this5._activeShape && !_this5._activeButton) {
          _this5._chart.popupDisplayable(true);
          _this5._drawEngine.enableInteractions();
        }
      });

      button.addEventListener("mousemove", function (e) {
        e.stopImmediatePropagation();
        e.preventDefault();
      });

      return button;
    }
  }, {
    key: "_createButtonControl",
    value: function _createButtonControl(id, ShapeHandlerClass, defaultStyle, defaultSelectStyle) {
      var _this6 = this;

      var keybindingStr = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";

      var shapeHandler = new ShapeHandlerClass(this._container, this._drawEngine, this._chart, this, id, defaultStyle, defaultSelectStyle);
      this._buttonElements[id] = this._createControlButton(id, {
        className: "mapd-draw-button-" + id,
        title: "Create a " + id + (keybindingStr ? " [" + keybindingStr + "]" : ""),
        onActivate: function onActivate() {
          _this6._drawEngine.disableInteractions();
          _this6._activeShape = shapeHandler;
          _this6._activeShape.activate();
        },
        onDeactivate: function onDeactivate() {
          _this6._drawEngine.enableInteractions();
        }
      });
      return shapeHandler;
    }
  }, {
    key: "isActive",
    value: function isActive() {
      return Boolean(this._activeButton);
    }
  }, {
    key: "deactivateButton",
    value: function deactivateButton(id) {
      if (this._activeButton && this._buttonElements[id] === this._activeButton.button) {
        this.deactivateButtons();
        return true;
      }
      return false;
    }
  }, {
    key: "deactivateButtons",
    value: function deactivateButtons() {
      if (this._activeButton) {
        this._activeButton.button.classList.remove("mapd-draw-active-button");
        if (this._activeButton.options && this._activeButton.options.onDeactivate) {
          this._activeButton.options.onDeactivate();
        }
        this._activeButton = null;
      }

      if (this._activeShape) {
        this._activeShape.deactivate();
        this._activeShape = null;
      }

      // NOTE: not setting popup displayable here.
      // Leaving that for the "mouseout" event
    }
  }, {
    key: "setActiveButton",
    value: function setActiveButton(id, options) {
      var button = this._buttonElements[id];
      if (!button) {
        return;
      }

      if (button && id !== "trash") {
        this.deactivateButtons();
        button.classList.add("mapd-draw-active-button");
        this._activeButton = {
          button: button,
          id: id,
          options: options
        };
      }

      // NOTE: this does not stop chart.getClosestResult()
      // from being called, so there could be unnecessary
      // backend calls still although popups are disabled
      // We may want to consider a way to disable those as well
      this._chart.popupDisplayable(false);
    }
  }, {
    key: "_selectionchangedCB",
    value: function _selectionchangedCB(event) {
      if (!this._activeShape && !this._activeButton) {
        var canvas = this._drawEngine.getCanvas();
        if (event.selectedShapes && event.selectedShapes.length) {
          this._chart.hidePopup(true);
          this._chart.popupDisplayable(false);

          // deactivate all map interactions except scroll zoom
          this._chart.enableInteractions(false, {
            scrollZoom: true
          });

          canvas.focus();
        } else {
          this._chart.popupDisplayable(true);
          this._chart.enableInteractions(true);
          canvas.blur();
        }
      }
    }
  }, {
    key: "_dragbeginCB",
    value: function _dragbeginCB(event) {
      if (!this._activeShape && !this._activeButton) {
        var canvas = this._drawEngine.getCanvas();
        canvas.focus();
      }
    }
  }, {
    key: "_dragendCB",
    value: function _dragendCB(event) {
      event.shapes.forEach(function (shape) {
        if (shape instanceof _LatLonCircle2.default) {
          // need to reset the inital radius of the latlon circle
          // so that any rescaling is done relative to this
          // new radius
          shape.resetInitialRadius();
        }
      });
    }
  }, {
    key: "_keyboardCB",
    value: function _keyboardCB(event) {
      var _this7 = this;

      if ((event.key === "Backspace" || event.code === "Backspace" || event.keyCode === 8) && this._drawEngine) {
        var selectedShapes = this._drawEngine.selectedShapes;
        if (selectedShapes.length) {
          this._drawEngine.deleteSelectedShapes();
          selectedShapes.forEach(function (shape) {
            _this7._chart.deleteFilterShape(shape);
          });
        }
        event.preventDefault();
      }
    }
  }, {
    key: "_initControls",
    value: function _initControls(defaultStyle, defaultSelectStyle) {
      var margins = null;
      if (typeof this._chart.margins === "function") {
        margins = this._chart.margins();
      }

      this._controlContainer = document.createElement("div");
      this._controlContainer.style.top = (margins && margins.top ? margins.top : 0) + "px";
      this._controlContainer.style.left = (margins && margins.left ? margins.left : 0) + "px";
      this._controlContainer.style.position = "absolute";
      this._controlContainer.className = "mapd-draw-button-container";
      this._container.appendChild(this._controlContainer);

      var canvas = this._drawEngine.getCanvas();
      // make the canvas focusable so we can catch keyboard events
      // from it, but don't outline it when it is focused
      canvas.setAttribute("tabindex", -1);
      canvas.style.outline = "none";

      this._controlGroup = document.createElement("div");
      this._controlGroup.className = "mapd-draw-button-control-group";
      this._controlContainer.appendChild(this._controlGroup);

      this._drawEngine.on(MapdDraw.ShapeBuilder.EventConstants.SELECTION_CHANGED, this._selectionchangedCB);
      this._drawEngine.on(MapdDraw.ShapeBuilder.EventConstants.DRAG_BEGIN, this._dragbeginCB);
      this._drawEngine.on(MapdDraw.ShapeBuilder.EventConstants.DRAG_END, this._dragendCB);

      this._circleHandler = this._createButtonControl("circle", CircleShapeHandler, defaultStyle, defaultSelectStyle);
      this._polylineHandler = this._createButtonControl("polyline", PolylineShapeHandler, defaultStyle, defaultSelectStyle);
      this._lassoHandler = this._createButtonControl("lasso", LassoShapeHandler, defaultStyle, defaultSelectStyle);

      // NOTE: the canvas dom element needs to have a "tabindex" set to have
      // focusability, and best to have "outline: none" as part
      // of its style so an outline isn't shown when focused
      canvas.addEventListener("keydown", this._keyboardCB);

      this._controlsInitted = true;
    }
  }]);

  return LassoButtonGroupController;
}();

exports.default = LassoButtonGroupController;

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

(function () { 'use strict';

// to suit your point format, run search/replace for '.x' and '.y';
// for 3D version, see 3d branch (configurability would draw significant performance overhead)

// square distance between 2 points
function getSqDist(p1, p2) {

    var dx = p1.x - p2.x,
        dy = p1.y - p2.y;

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2) {

    var x = p1.x,
        y = p1.y,
        dx = p2.x - x,
        dy = p2.y - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2.x;
            y = p2.y;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p.x - x;
    dy = p.y - y;

    return dx * dx + dy * dy;
}
// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance) {

    var prevPoint = points[0],
        newPoints = [prevPoint],
        point;

    for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified) {
    var maxSqDist = sqTolerance,
        index;

    for (var i = first + 1; i < last; i++) {
        var sqDist = getSqSegDist(points[i], points[first], points[last]);

        if (sqDist > maxSqDist) {
            index = i;
            maxSqDist = sqDist;
        }
    }

    if (maxSqDist > sqTolerance) {
        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
        simplified.push(points[index]);
        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
    }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance) {
    var last = points.length - 1;

    var simplified = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
function simplify(points, tolerance, highestQuality) {

    if (points.length <= 2) return points;

    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}

// export as AMD module / Node module / browser or worker variable
if (true) !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return simplify; }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
else if (typeof module !== 'undefined') {
    module.exports = simplify;
    module.exports.default = simplify;
} else if (typeof self !== 'undefined') self.simplify = simplify;
else window.simplify = simplify;

})();


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var meta_1 = __webpack_require__(262);
/**
 * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.
 *
 * @name bbox
 * @param {GeoJSON} geojson any GeoJSON object
 * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order
 * @example
 * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);
 * var bbox = turf.bbox(line);
 * var bboxPolygon = turf.bboxPolygon(bbox);
 *
 * //addToMap
 * var addToMap = [line, bboxPolygon]
 */
function bbox(geojson) {
    var result = [Infinity, Infinity, -Infinity, -Infinity];
    meta_1.coordEach(geojson, function (coord) {
        if (result[0] > coord[0]) {
            result[0] = coord[0];
        }
        if (result[1] > coord[1]) {
            result[1] = coord[1];
        }
        if (result[2] < coord[0]) {
            result[2] = coord[0];
        }
        if (result[3] < coord[1]) {
            result[3] = coord[1];
        }
    });
    return result;
}
exports.default = bbox;


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var helpers = __webpack_require__(42);

/**
 * Callback for coordEach
 *
 * @callback coordEachCallback
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 */

/**
 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
 *
 * @name coordEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 * });
 */
function coordEach(geojson, callback, excludeWrapCoord) {
    // Handles null Geometry -- Skips this GeoJSON
    if (geojson === null) return;
    var j, k, l, geometry, stopG, coords,
        geometryMaybeCollection,
        wrapShrink = 0,
        coordIndex = 0,
        isGeometryCollection,
        type = geojson.type,
        isFeatureCollection = type === 'FeatureCollection',
        isFeature = type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :
            (isFeature ? geojson.geometry : geojson));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
            var multiFeatureIndex = 0;
            var geometryIndex = 0;
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;

            // Handles null Geometry -- Skips this geometry
            if (geometry === null) continue;
            coords = geometry.coordinates;
            var geomType = geometry.type;

            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;

            switch (geomType) {
            case null:
                break;
            case 'Point':
                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                coordIndex++;
                multiFeatureIndex++;
                break;
            case 'LineString':
            case 'MultiPoint':
                for (j = 0; j < coords.length; j++) {
                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                    coordIndex++;
                    if (geomType === 'MultiPoint') multiFeatureIndex++;
                }
                if (geomType === 'LineString') multiFeatureIndex++;
                break;
            case 'Polygon':
            case 'MultiLineString':
                for (j = 0; j < coords.length; j++) {
                    for (k = 0; k < coords[j].length - wrapShrink; k++) {
                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                        coordIndex++;
                    }
                    if (geomType === 'MultiLineString') multiFeatureIndex++;
                    if (geomType === 'Polygon') geometryIndex++;
                }
                if (geomType === 'Polygon') multiFeatureIndex++;
                break;
            case 'MultiPolygon':
                for (j = 0; j < coords.length; j++) {
                    geometryIndex = 0;
                    for (k = 0; k < coords[j].length; k++) {
                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                            coordIndex++;
                        }
                        geometryIndex++;
                    }
                    multiFeatureIndex++;
                }
                break;
            case 'GeometryCollection':
                for (j = 0; j < geometry.geometries.length; j++)
                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;
                break;
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
    }
}

/**
 * Callback for coordReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback coordReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 */

/**
 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
 *
 * @name coordReduce
 * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=previousValue
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   return currentCoord;
 * });
 */
function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
    var previousValue = initialValue;
    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;
        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
    }, excludeWrapCoord);
    return previousValue;
}

/**
 * Callback for propEach
 *
 * @callback propEachCallback
 * @param {Object} currentProperties The current Properties being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
 *
 * @name propEach
 * @param {FeatureCollection|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentProperties, featureIndex)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propEach(features, function (currentProperties, featureIndex) {
 *   //=currentProperties
 *   //=featureIndex
 * });
 */
function propEach(geojson, callback) {
    var i;
    switch (geojson.type) {
    case 'FeatureCollection':
        for (i = 0; i < geojson.features.length; i++) {
            if (callback(geojson.features[i].properties, i) === false) break;
        }
        break;
    case 'Feature':
        callback(geojson.properties, 0);
        break;
    }
}


/**
 * Callback for propReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback propReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {*} currentProperties The current Properties being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @name propReduce
 * @param {FeatureCollection|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
 *   //=previousValue
 *   //=currentProperties
 *   //=featureIndex
 *   return currentProperties
 * });
 */
function propReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    propEach(geojson, function (currentProperties, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;
        else previousValue = callback(previousValue, currentProperties, featureIndex);
    });
    return previousValue;
}

/**
 * Callback for featureEach
 *
 * @callback featureEachCallback
 * @param {Feature<any>} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Iterate over features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name featureEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.featureEach(features, function (currentFeature, featureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 * });
 */
function featureEach(geojson, callback) {
    if (geojson.type === 'Feature') {
        callback(geojson, 0);
    } else if (geojson.type === 'FeatureCollection') {
        for (var i = 0; i < geojson.features.length; i++) {
            if (callback(geojson.features[i], i) === false) break;
        }
    }
}

/**
 * Callback for featureReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback featureReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name featureReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   return currentFeature
 * });
 */
function featureReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    featureEach(geojson, function (currentFeature, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex);
    });
    return previousValue;
}

/**
 * Get all coordinates from any GeoJSON object.
 *
 * @name coordAll
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @returns {Array<Array<number>>} coordinate position array
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * var coords = turf.coordAll(features);
 * //= [[26, 37], [36, 53]]
 */
function coordAll(geojson) {
    var coords = [];
    coordEach(geojson, function (coord) {
        coords.push(coord);
    });
    return coords;
}

/**
 * Callback for geomEach
 *
 * @callback geomEachCallback
 * @param {Geometry} currentGeometry The current Geometry being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {Object} featureProperties The current Feature Properties being processed.
 * @param {Array<number>} featureBBox The current Feature BBox being processed.
 * @param {number|string} featureId The current Feature Id being processed.
 */

/**
 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
 *
 * @name geomEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
 *   //=currentGeometry
 *   //=featureIndex
 *   //=featureProperties
 *   //=featureBBox
 *   //=featureId
 * });
 */
function geomEach(geojson, callback) {
    var i, j, g, geometry, stopG,
        geometryMaybeCollection,
        isGeometryCollection,
        featureProperties,
        featureBBox,
        featureId,
        featureIndex = 0,
        isFeatureCollection = geojson.type === 'FeatureCollection',
        isFeature = geojson.type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (i = 0; i < stop; i++) {

        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :
            (isFeature ? geojson.geometry : geojson));
        featureProperties = (isFeatureCollection ? geojson.features[i].properties :
            (isFeature ? geojson.properties : {}));
        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :
            (isFeature ? geojson.bbox : undefined));
        featureId = (isFeatureCollection ? geojson.features[i].id :
            (isFeature ? geojson.id : undefined));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;

            // Handle null Geometry
            if (geometry === null) {
                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
                continue;
            }
            switch (geometry.type) {
            case 'Point':
            case 'LineString':
            case 'MultiPoint':
            case 'Polygon':
            case 'MultiLineString':
            case 'MultiPolygon': {
                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
                break;
            }
            case 'GeometryCollection': {
                for (j = 0; j < geometry.geometries.length; j++) {
                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;
                }
                break;
            }
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
        // Only increase `featureIndex` per each feature
        featureIndex++;
    }
}

/**
 * Callback for geomReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback geomReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Geometry} currentGeometry The current Geometry being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {Object} featureProperties The current Feature Properties being processed.
 * @param {Array<number>} featureBBox The current Feature BBox being processed.
 * @param {number|string} featureId The current Feature Id being processed.
 */

/**
 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
 *
 * @name geomReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
 *   //=previousValue
 *   //=currentGeometry
 *   //=featureIndex
 *   //=featureProperties
 *   //=featureBBox
 *   //=featureId
 *   return currentGeometry
 * });
 */
function geomReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;
        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);
    });
    return previousValue;
}

/**
 * Callback for flattenEach
 *
 * @callback flattenEachCallback
 * @param {Feature} currentFeature The current flattened feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 */

/**
 * Iterate over flattened features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name flattenEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 *   //=multiFeatureIndex
 * });
 */
function flattenEach(geojson, callback) {
    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {
        // Callback for single geometry
        var type = (geometry === null) ? null : geometry.type;
        switch (type) {
        case null:
        case 'Point':
        case 'LineString':
        case 'Polygon':
            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;
            return;
        }

        var geomType;

        // Callback for multi-geometry
        switch (type) {
        case 'MultiPoint':
            geomType = 'Point';
            break;
        case 'MultiLineString':
            geomType = 'LineString';
            break;
        case 'MultiPolygon':
            geomType = 'Polygon';
            break;
        }

        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
            var coordinate = geometry.coordinates[multiFeatureIndex];
            var geom = {
                type: geomType,
                coordinates: coordinate
            };
            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;
        }
    });
}

/**
 * Callback for flattenReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback flattenReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 */

/**
 * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
 *
 * @name flattenReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   return currentFeature
 * });
 */
function flattenReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {
        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);
    });
    return previousValue;
}

/**
 * Callback for segmentEach
 *
 * @callback segmentEachCallback
 * @param {Feature<LineString>} currentSegment The current Segment being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 * @param {number} segmentIndex The current index of the Segment being processed.
 * @returns {void}
 */

/**
 * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
 * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
 *   //=currentSegment
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   //=segmentIndex
 * });
 *
 * // Calculate the total number of segments
 * var total = 0;
 * turf.segmentEach(polygon, function () {
 *     total++;
 * });
 */
function segmentEach(geojson, callback) {
    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
        var segmentIndex = 0;

        // Exclude null Geometries
        if (!feature.geometry) return;
        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
        var type = feature.geometry.type;
        if (type === 'Point' || type === 'MultiPoint') return;

        // Generate 2-vertex line segments
        var previousCoords;
        var previousFeatureIndex = 0;
        var previousMultiIndex = 0;
        var prevGeomIndex = 0;
        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`
            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
                previousCoords = currentCoord;
                previousFeatureIndex = featureIndex;
                previousMultiIndex = multiPartIndexCoord;
                prevGeomIndex = geometryIndex;
                segmentIndex = 0;
                return;
            }
            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);
            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;
            segmentIndex++;
            previousCoords = currentCoord;
        }) === false) return false;
    });
}

/**
 * Callback for segmentReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback segmentReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentSegment The current Segment being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 * @param {number} segmentIndex The current index of the Segment being processed.
 */

/**
 * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
 * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
 *   //= previousSegment
 *   //= currentSegment
 *   //= featureIndex
 *   //= multiFeatureIndex
 *   //= geometryIndex
 *   //= segmentInex
 *   return currentSegment
 * });
 *
 * // Calculate the total number of segments
 * var initialValue = 0
 * var total = turf.segmentReduce(polygon, function (previousValue) {
 *     previousValue++;
 *     return previousValue;
 * }, initialValue);
 */
function segmentReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    var started = false;
    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
        if (started === false && initialValue === undefined) previousValue = currentSegment;
        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);
        started = true;
    });
    return previousValue;
}

/**
 * Callback for lineEach
 *
 * @callback lineEachCallback
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed
 * @param {number} featureIndex The current index of the Feature being processed
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
 * @param {number} geometryIndex The current index of the Geometry being processed
 */

/**
 * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
 * similar to Array.forEach.
 *
 * @name lineEach
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)
 * @example
 * var multiLine = turf.multiLineString([
 *   [[26, 37], [35, 45]],
 *   [[36, 53], [38, 50], [41, 55]]
 * ]);
 *
 * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=currentLine
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 * });
 */
function lineEach(geojson, callback) {
    // validation
    if (!geojson) throw new Error('geojson is required');

    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
        if (feature.geometry === null) return;
        var type = feature.geometry.type;
        var coords = feature.geometry.coordinates;
        switch (type) {
        case 'LineString':
            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;
            break;
        case 'Polygon':
            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
            }
            break;
        }
    });
}

/**
 * Callback for lineReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback lineReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} featureIndex The current index of the Feature being processed
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
 * @param {number} geometryIndex The current index of the Geometry being processed
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name lineReduce
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var multiPoly = turf.multiPolygon([
 *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
 *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
 * ]);
 *
 * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=previousValue
 *   //=currentLine
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   return currentLine
 * });
 */
function lineReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;
        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);
    });
    return previousValue;
}

/**
 * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.
 *
 * Negative indexes are permitted.
 * Point & MultiPoint will always return null.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.featureIndex=0] Feature Index
 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
 * @param {number} [options.geometryIndex=0] Geometry Index
 * @param {number} [options.segmentIndex=0] Segment Index
 * @param {Object} [options.properties={}] Translate Properties to output LineString
 * @param {BBox} [options.bbox={}] Translate BBox to output LineString
 * @param {number|string} [options.id={}] Translate Id to output LineString
 * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString
 * @example
 * var multiLine = turf.multiLineString([
 *     [[10, 10], [50, 30], [30, 40]],
 *     [[-10, -10], [-50, -30], [-30, -40]]
 * ]);
 *
 * // First Segment (defaults are 0)
 * turf.findSegment(multiLine);
 * // => Feature<LineString<[[10, 10], [50, 30]]>>
 *
 * // First Segment of 2nd Multi Feature
 * turf.findSegment(multiLine, {multiFeatureIndex: 1});
 * // => Feature<LineString<[[-10, -10], [-50, -30]]>>
 *
 * // Last Segment of Last Multi Feature
 * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});
 * // => Feature<LineString<[[-50, -30], [-30, -40]]>>
 */
function findSegment(geojson, options) {
    // Optional Parameters
    options = options || {};
    if (!helpers.isObject(options)) throw new Error('options is invalid');
    var featureIndex = options.featureIndex || 0;
    var multiFeatureIndex = options.multiFeatureIndex || 0;
    var geometryIndex = options.geometryIndex || 0;
    var segmentIndex = options.segmentIndex || 0;

    // Find FeatureIndex
    var properties = options.properties;
    var geometry;

    switch (geojson.type) {
    case 'FeatureCollection':
        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
        properties = properties || geojson.features[featureIndex].properties;
        geometry = geojson.features[featureIndex].geometry;
        break;
    case 'Feature':
        properties = properties || geojson.properties;
        geometry = geojson.geometry;
        break;
    case 'Point':
    case 'MultiPoint':
        return null;
    case 'LineString':
    case 'Polygon':
    case 'MultiLineString':
    case 'MultiPolygon':
        geometry = geojson;
        break;
    default:
        throw new Error('geojson is invalid');
    }

    // Find SegmentIndex
    if (geometry === null) return null;
    var coords = geometry.coordinates;
    switch (geometry.type) {
    case 'Point':
    case 'MultiPoint':
        return null;
    case 'LineString':
        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;
        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);
    case 'Polygon':
        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);
    case 'MultiLineString':
        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);
    case 'MultiPolygon':
        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);
    }
    throw new Error('geojson is invalid');
}

/**
 * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.
 *
 * Negative indexes are permitted.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.featureIndex=0] Feature Index
 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
 * @param {number} [options.geometryIndex=0] Geometry Index
 * @param {number} [options.coordIndex=0] Coord Index
 * @param {Object} [options.properties={}] Translate Properties to output Point
 * @param {BBox} [options.bbox={}] Translate BBox to output Point
 * @param {number|string} [options.id={}] Translate Id to output Point
 * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point
 * @example
 * var multiLine = turf.multiLineString([
 *     [[10, 10], [50, 30], [30, 40]],
 *     [[-10, -10], [-50, -30], [-30, -40]]
 * ]);
 *
 * // First Segment (defaults are 0)
 * turf.findPoint(multiLine);
 * // => Feature<Point<[10, 10]>>
 *
 * // First Segment of the 2nd Multi-Feature
 * turf.findPoint(multiLine, {multiFeatureIndex: 1});
 * // => Feature<Point<[-10, -10]>>
 *
 * // Last Segment of last Multi-Feature
 * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});
 * // => Feature<Point<[-30, -40]>>
 */
function findPoint(geojson, options) {
    // Optional Parameters
    options = options || {};
    if (!helpers.isObject(options)) throw new Error('options is invalid');
    var featureIndex = options.featureIndex || 0;
    var multiFeatureIndex = options.multiFeatureIndex || 0;
    var geometryIndex = options.geometryIndex || 0;
    var coordIndex = options.coordIndex || 0;

    // Find FeatureIndex
    var properties = options.properties;
    var geometry;

    switch (geojson.type) {
    case 'FeatureCollection':
        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
        properties = properties || geojson.features[featureIndex].properties;
        geometry = geojson.features[featureIndex].geometry;
        break;
    case 'Feature':
        properties = properties || geojson.properties;
        geometry = geojson.geometry;
        break;
    case 'Point':
    case 'MultiPoint':
        return null;
    case 'LineString':
    case 'Polygon':
    case 'MultiLineString':
    case 'MultiPolygon':
        geometry = geojson;
        break;
    default:
        throw new Error('geojson is invalid');
    }

    // Find Coord Index
    if (geometry === null) return null;
    var coords = geometry.coordinates;
    switch (geometry.type) {
    case 'Point':
        return helpers.point(coords, properties, options);
    case 'MultiPoint':
        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
        return helpers.point(coords[multiFeatureIndex], properties, options);
    case 'LineString':
        if (coordIndex < 0) coordIndex = coords.length + coordIndex;
        return helpers.point(coords[coordIndex], properties, options);
    case 'Polygon':
        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;
        return helpers.point(coords[geometryIndex][coordIndex], properties, options);
    case 'MultiLineString':
        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;
        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);
    case 'MultiPolygon':
        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);
    }
    throw new Error('geojson is invalid');
}

exports.coordEach = coordEach;
exports.coordReduce = coordReduce;
exports.propEach = propEach;
exports.propReduce = propReduce;
exports.featureEach = featureEach;
exports.featureReduce = featureReduce;
exports.coordAll = coordAll;
exports.geomEach = geomEach;
exports.geomReduce = geomReduce;
exports.flattenEach = flattenEach;
exports.flattenReduce = flattenReduce;
exports.segmentEach = segmentEach;
exports.segmentReduce = segmentReduce;
exports.lineEach = lineEach;
exports.lineReduce = lineReduce;
exports.findSegment = findSegment;
exports.findPoint = findPoint;


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
}
Object.defineProperty(exports, "__esModule", { value: true });
var helpers_1 = __webpack_require__(42);
var invariant_1 = __webpack_require__(264);
var lineclip = __importStar(__webpack_require__(265));
/**
 * Takes a {@link Feature} and a bbox and clips the feature to the bbox using
 * [lineclip](https://github.com/mapbox/lineclip).
 * May result in degenerate edges when clipping Polygons.
 *
 * @name bboxClip
 * @param {Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature feature to clip to the bbox
 * @param {BBox} bbox extent in [minX, minY, maxX, maxY] order
 * @returns {Feature<LineString|MultiLineString|Polygon|MultiPolygon>} clipped Feature
 * @example
 * var bbox = [0, 0, 10, 10];
 * var poly = turf.polygon([[[2, 2], [8, 4], [12, 8], [3, 7], [2, 2]]]);
 *
 * var clipped = turf.bboxClip(poly, bbox);
 *
 * //addToMap
 * var addToMap = [bbox, poly, clipped]
 */
function bboxClip(feature, bbox) {
    var geom = invariant_1.getGeom(feature);
    var type = geom.type;
    var properties = feature.type === "Feature" ? feature.properties : {};
    var coords = geom.coordinates;
    switch (type) {
        case "LineString":
        case "MultiLineString":
            var lines_1 = [];
            if (type === "LineString") {
                coords = [coords];
            }
            coords.forEach(function (line) {
                lineclip.polyline(line, bbox, lines_1);
            });
            if (lines_1.length === 1) {
                return helpers_1.lineString(lines_1[0], properties);
            }
            return helpers_1.multiLineString(lines_1, properties);
        case "Polygon":
            return helpers_1.polygon(clipPolygon(coords, bbox), properties);
        case "MultiPolygon":
            return helpers_1.multiPolygon(coords.map(function (poly) {
                return clipPolygon(poly, bbox);
            }), properties);
        default:
            throw new Error("geometry " + type + " not supported");
    }
}
exports.default = bboxClip;
function clipPolygon(rings, bbox) {
    var outRings = [];
    for (var _i = 0, rings_1 = rings; _i < rings_1.length; _i++) {
        var ring = rings_1[_i];
        var clipped = lineclip.polygon(ring, bbox);
        if (clipped.length > 0) {
            if (clipped[0][0] !== clipped[clipped.length - 1][0] || clipped[0][1] !== clipped[clipped.length - 1][1]) {
                clipped.push(clipped[0]);
            }
            if (clipped.length >= 4) {
                outRings.push(clipped);
            }
        }
    }
    return outRings;
}


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var helpers_1 = __webpack_require__(42);
/**
 * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
 *
 * @name getCoord
 * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers
 * @returns {Array<number>} coordinates
 * @example
 * var pt = turf.point([10, 10]);
 *
 * var coord = turf.getCoord(pt);
 * //= [10, 10]
 */
function getCoord(coord) {
    if (!coord) {
        throw new Error("coord is required");
    }
    if (!Array.isArray(coord)) {
        if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
            return coord.geometry.coordinates;
        }
        if (coord.type === "Point") {
            return coord.coordinates;
        }
    }
    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
        return coord;
    }
    throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
exports.getCoord = getCoord;
/**
 * Unwrap coordinates from a Feature, Geometry Object or an Array
 *
 * @name getCoords
 * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array
 * @returns {Array<any>} coordinates
 * @example
 * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);
 *
 * var coords = turf.getCoords(poly);
 * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]
 */
function getCoords(coords) {
    if (Array.isArray(coords)) {
        return coords;
    }
    // Feature
    if (coords.type === "Feature") {
        if (coords.geometry !== null) {
            return coords.geometry.coordinates;
        }
    }
    else {
        // Geometry
        if (coords.coordinates) {
            return coords.coordinates;
        }
    }
    throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
exports.getCoords = getCoords;
/**
 * Checks if coordinates contains a number
 *
 * @name containsNumber
 * @param {Array<any>} coordinates GeoJSON Coordinates
 * @returns {boolean} true if Array contains a number
 */
function containsNumber(coordinates) {
    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {
        return true;
    }
    if (Array.isArray(coordinates[0]) && coordinates[0].length) {
        return containsNumber(coordinates[0]);
    }
    throw new Error("coordinates must only contain numbers");
}
exports.containsNumber = containsNumber;
/**
 * Enforce expectations about types of GeoJSON objects for Turf.
 *
 * @name geojsonType
 * @param {GeoJSON} value any GeoJSON object
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function geojsonType(value, type, name) {
    if (!type || !name) {
        throw new Error("type and name required");
    }
    if (!value || value.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + value.type);
    }
}
exports.geojsonType = geojsonType;
/**
 * Enforce expectations about types of {@link Feature} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name featureOf
 * @param {Feature} feature a feature with an expected geometry type
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} error if value is not the expected type.
 */
function featureOf(feature, type, name) {
    if (!feature) {
        throw new Error("No feature passed");
    }
    if (!name) {
        throw new Error(".featureOf() requires a name");
    }
    if (!feature || feature.type !== "Feature" || !feature.geometry) {
        throw new Error("Invalid input to " + name + ", Feature with geometry required");
    }
    if (!feature.geometry || feature.geometry.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
    }
}
exports.featureOf = featureOf;
/**
 * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name collectionOf
 * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function collectionOf(featureCollection, type, name) {
    if (!featureCollection) {
        throw new Error("No featureCollection passed");
    }
    if (!name) {
        throw new Error(".collectionOf() requires a name");
    }
    if (!featureCollection || featureCollection.type !== "FeatureCollection") {
        throw new Error("Invalid input to " + name + ", FeatureCollection required");
    }
    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {
        var feature = _a[_i];
        if (!feature || feature.type !== "Feature" || !feature.geometry) {
            throw new Error("Invalid input to " + name + ", Feature with geometry required");
        }
        if (!feature.geometry || feature.geometry.type !== type) {
            throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
        }
    }
}
exports.collectionOf = collectionOf;
/**
 * Get Geometry from Feature or Geometry Object
 *
 * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
 * @returns {Geometry|null} GeoJSON Geometry Object
 * @throws {Error} if geojson is not a Feature or Geometry Object
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getGeom(point)
 * //={"type": "Point", "coordinates": [110, 40]}
 */
function getGeom(geojson) {
    if (geojson.type === "Feature") {
        return geojson.geometry;
    }
    return geojson;
}
exports.getGeom = getGeom;
/**
 * Get GeoJSON object's type, Geometry type is prioritize.
 *
 * @param {GeoJSON} geojson GeoJSON object
 * @param {string} [name="geojson"] name of the variable to display in error message
 * @returns {string} GeoJSON type
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getType(point)
 * //="Point"
 */
function getType(geojson, name) {
    if (geojson.type === "FeatureCollection") {
        return "FeatureCollection";
    }
    if (geojson.type === "GeometryCollection") {
        return "GeometryCollection";
    }
    if (geojson.type === "Feature" && geojson.geometry !== null) {
        return geojson.geometry.type;
    }
    return geojson.type;
}
exports.getType = getType;


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = lineclip;
module.exports.default = lineclip;

lineclip.polyline = lineclip;
lineclip.polygon = polygonclip;


// Cohen-Sutherland line clippign algorithm, adapted to efficiently
// handle polylines rather than just segments

function lineclip(points, bbox, result) {

    var len = points.length,
        codeA = bitCode(points[0], bbox),
        part = [],
        i, a, b, codeB, lastCode;

    if (!result) result = [];

    for (i = 1; i < len; i++) {
        a = points[i - 1];
        b = points[i];
        codeB = lastCode = bitCode(b, bbox);

        while (true) {

            if (!(codeA | codeB)) { // accept
                part.push(a);

                if (codeB !== lastCode) { // segment went outside
                    part.push(b);

                    if (i < len - 1) { // start a new line
                        result.push(part);
                        part = [];
                    }
                } else if (i === len - 1) {
                    part.push(b);
                }
                break;

            } else if (codeA & codeB) { // trivial reject
                break;

            } else if (codeA) { // a outside, intersect with clip edge
                a = intersect(a, b, codeA, bbox);
                codeA = bitCode(a, bbox);

            } else { // b outside
                b = intersect(a, b, codeB, bbox);
                codeB = bitCode(b, bbox);
            }
        }

        codeA = lastCode;
    }

    if (part.length) result.push(part);

    return result;
}

// Sutherland-Hodgeman polygon clipping algorithm

function polygonclip(points, bbox) {

    var result, edge, prev, prevInside, i, p, inside;

    // clip against each side of the clip rectangle
    for (edge = 1; edge <= 8; edge *= 2) {
        result = [];
        prev = points[points.length - 1];
        prevInside = !(bitCode(prev, bbox) & edge);

        for (i = 0; i < points.length; i++) {
            p = points[i];
            inside = !(bitCode(p, bbox) & edge);

            // if segment goes through the clip window, add an intersection
            if (inside !== prevInside) result.push(intersect(prev, p, edge, bbox));

            if (inside) result.push(p); // add a point if it's inside

            prev = p;
            prevInside = inside;
        }

        points = result;

        if (!points.length) break;
    }

    return result;
}

// intersect a segment against one of the 4 lines that make up the bbox

function intersect(a, b, edge, bbox) {
    return edge & 8 ? [a[0] + (b[0] - a[0]) * (bbox[3] - a[1]) / (b[1] - a[1]), bbox[3]] : // top
           edge & 4 ? [a[0] + (b[0] - a[0]) * (bbox[1] - a[1]) / (b[1] - a[1]), bbox[1]] : // bottom
           edge & 2 ? [bbox[2], a[1] + (b[1] - a[1]) * (bbox[2] - a[0]) / (b[0] - a[0])] : // right
           edge & 1 ? [bbox[0], a[1] + (b[1] - a[1]) * (bbox[0] - a[0]) / (b[0] - a[0])] : // left
           null;
}

// bit code reflects the point position relative to the bbox:

//         left  mid  right
//    top  1001  1000  1010
//    mid  0001  0000  0010
// bottom  0101  0100  0110

function bitCode(p, bbox) {
    var code = 0;

    if (p[0] < bbox[0]) code |= 1; // left
    else if (p[0] > bbox[2]) code |= 2; // right

    if (p[1] < bbox[1]) code |= 4; // bottom
    else if (p[1] > bbox[3]) code |= 8; // top

    return code;
}


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = pieChart;

var _baseMixin = __webpack_require__(7);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

var _capMixin = __webpack_require__(16);

var _capMixin2 = _interopRequireDefault(_capMixin);

var _colorMixin = __webpack_require__(12);

var _colorMixin2 = _interopRequireDefault(_colorMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _multipleKeyLabelMixin = __webpack_require__(184);

var _multipleKeyLabelMixin2 = _interopRequireDefault(_multipleKeyLabelMixin);

var _formattingHelpers = __webpack_require__(10);

var _core = __webpack_require__(3);

var _coreAsync = __webpack_require__(5);

var _utils = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The pie chart implementation is usually used to visualize a small categorical distribution.  The pie
 * chart uses keyAccessor to determine the slices, and valueAccessor to calculate the size of each
 * slice relative to the sum of all values. Slices are ordered by {@link #dc.baseMixin+ordering ordering}
 * which defaults to sorting by key.
 *
 * @name pieChart
 * @memberof dc
 * @mixes dc.capMixin
 * @mixes dc.colorMixin
 * @mixes dc.baseMixin
 * @example
 * // create a pie chart under #chart-container1 element using the default global chart group
 * var chart1 = dc.pieChart('#chart-container1');
 * // create a pie chart under #chart-container2 element using chart group A
 * var chart2 = dc.pieChart('#chart-container2', 'chartGroupA');
 * @param {String|node|d3.selection} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector} specifying
 * a dom block element such as a div; or a dom element or d3 selection.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
 * Interaction with a chart will only trigger events and redraws within the chart's group.
 * @return {dc.pieChart}
 */
function pieChart(parent, chartGroup) {
  var DEFAULT_MIN_ANGLE_FOR_LABEL = 0.4;

  var _sliceCssClass = "pie-slice";
  var _emptyCssClass = "empty-chart";
  var _emptyTitle = "empty";

  var _radius = void 0,
      _givenRadius = void 0,
      // specified radius, if any
  _innerRadius = 0,
      _externalRadiusPadding = 0;

  var _g = void 0;
  var _cx = void 0;
  var _cy = void 0;
  var _minAngleForLabel = DEFAULT_MIN_ANGLE_FOR_LABEL;
  var _externalLabelRadius = void 0;
  var _drawPaths = false;
  var _chart = (0, _capMixin2.default)((0, _colorMixin2.default)((0, _baseMixin2.default)({})));
  var ENABLE_ABSOLUTE_LABELS = void 0;
  var ENABLE_PERCENTAGE_LABELS = void 0;
  var ENABLE_PERCENTAGE_LABELS_IN_POPUP = void 0;
  var ENABLE_ALL_OTHERS_LABELS = void 0;
  /* OVERRIDE ---------------------------------------------------------------- */
  var _pieStyle = void 0; // "pie" or "donut"
  var _pieSizeThreshold = 480;
  var _hasBeenRendered = false;
  _chart.redoSelect = highlightFilter;
  _chart.accent = accentSlice;
  _chart.unAccent = unAccentSlice;
  /* ------------------------------------------------------------------------- */

  _chart.colorAccessor(_chart.cappedKeyAccessor);

  _chart.title(function (d) {
    return _chart.cappedKeyAccessor(d) + ": " + _chart.cappedValueAccessor(d);
  });

  /**
   * Get or set the maximum number of slices the pie chart will generate. The top slices are determined by
   * value from high to low. Other slices exeeding the cap will be rolled up into one single *Others* slice.
   * @name slicesCap
   * @memberof dc.pieChart
   * @instance
   * @param {Number} [cap]
   * @return {Number}
   * @return {dc.pieChart}
   */
  _chart.slicesCap = _chart.cap;

  _chart.label(_chart.cappedKeyAccessor);
  _chart.renderLabel(true);

  _chart.transitionDuration(350);

  /* OVERRIDE ---------------------------------------------------------------- */
  _chart.measureValue = function (d) {
    var key = _chart.getMeasureName();
    var customFormatter = _chart.valueFormatter();
    var value = _chart.cappedValueAccessor(d);
    return customFormatter && customFormatter(value, key) || _utils.utils.formatValue(value);
  };

  _chart.redoSelect = highlightFilter;
  _chart.accent = accentSlice;
  _chart.unAccent = unAccentSlice;

  var originalDataAsync = _chart.getDataAsync();
  _chart.setDataAsync(function (group, callback) {
    originalDataAsync(group, function (err, result) {
      if (err || !ENABLE_ALL_OTHERS_LABELS || !result) {
        callback(err, result);
        return;
      }

      // data is cached during redraw/render, so it's possible that it was
      // cached with the all other row already included
      if (result.some(function (_ref) {
        var key0 = _ref.key0;
        return key0 === "All Others";
      })) {
        callback(null, result);
        return;
      }

      // Get the total value (across the whole table, no groups) for the current
      // size measure and incoming crossfilters
      group.getCrossfilter().groupAll()

      // Include the size measure
      .reduce([group.reduce()[0]])

      // Add the chart's own dimension index which excludes its filters
      .valueAsync(false, false, group.dimension().getDimensionIndex()).then(function (filterSize) {
        var val = filterSize - _d2.default.sum(result, _chart.valueAccessor());
        if (val > 0) {
          result.push({ key0: "All Others", val: val, isAllOthers: true });
        }
        callback(null, result);
      }).catch(function (err) {
        callback(err);
      });
    });
  });

  (0, _core.override)(_chart, "getColor", function (data, index) {
    if (data.isAllOthers) {
      return "#888888";
    }
    return _chart._getColor(data, index);
  });
  /* ------------------------------------------------------------------------- */

  _chart._doRender = function () {
    _chart.resetSvg();

    _g = _chart.svg().append("g").attr("class", "pie-wrapper").attr("transform", "translate(" + _chart.cx() + "," + _chart.cy() + ")");

    drawChart();

    /* OVERRIDE -----------------------------------------------------------------*/
    _hasBeenRendered = true;
    /* --------------------------------------------------------------------------*/
    return _chart;
  };

  function drawChart() {
    /* OVERRIDE ---------------------------------------------------------------- */
    // set radius on basis of chart dimension if missing
    // _radius = d3.min([_chart.width(), _chart.height()]) / 2;
    _radius = _givenRadius ? _givenRadius : _d2.default.min([_chart.width(), _chart.height()]) / 2;
    /* ------------------------------------------------------------------------- */

    var arc = buildArcs();

    var pie = pieLayout();

    var chartData = _chart.data();

    var pieData = void 0;
    // if we have data...
    if (chartData && _d2.default.sum(chartData, _chart.valueAccessor())) {
      pieData = pie(_utils.utils.maybeFormatInfinity(_chart.data()));
      _g.classed(_emptyCssClass, false);
    } else {
      // otherwise we'd be getting NaNs, so override
      // note: abuse others for its ignoring the value accessor
      pieData = pie([{ key: _emptyTitle, value: 1, others: [_emptyTitle] }]);
      _g.classed(_emptyCssClass, true);
    }

    if (ENABLE_PERCENTAGE_LABELS_IN_POPUP) {
      var total = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = pieData[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var datum = _step.value;

          total += datum.value;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = pieData[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _datum = _step2.value;

          _datum.percentage = (0, _formattingHelpers.formatPercentage)(_datum.value, total);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }

    if (_g) {
      var slices = _g.selectAll("g." + _sliceCssClass).data(pieData);

      createElements(slices, arc, pieData);

      updateElements(pieData, arc);

      removeElements(slices);

      highlightFilter();

      (0, _core.transition)(_g, _chart.transitionDuration()).attr("transform", "translate(" + _chart.cx() + "," + _chart.cy() + ")");
    }

    // Recreate the popup in case the chart changed data during redraw
    _chart.generatePopup();
  }

  function createElements(slices, arc, pieData) {
    var slicesEnter = createSliceNodes(slices);

    createSlicePath(slicesEnter, arc);

    createLabels(pieData, arc);
  }

  function createSliceNodes(slices) {
    var slicesEnter = slices.enter().append("g").attr("class", function (d, i) {
      return _sliceCssClass + " _" + i;
    })
    /* OVERRIDE ---------------------------------------------------------------- */
    .classed("stroke-thick", pieIsBig);
    /* ------------------------------------------------------------------------- */
    return slicesEnter;
  }

  function createSlicePath(slicesEnter, arc) {
    var slicePath = slicesEnter.append("path").attr("fill", fill).on("click", onClick)
    /* OVERRIDE ---------------------------------------------------------------- */
    .on("mouseenter", showPopup).on("mousemove", positionPopup).on("mouseleave", hidePopup)
    /* ------------------------------------------------------------------------- */
    .attr("d", function (d, i) {
      return safeArc(d, i, arc);
    });

    (0, _core.transition)(slicePath, _chart.transitionDuration(), function (s) {
      s.attrTween("d", tweenPie);
    });
  }

  function createTitles(slicesEnter) {
    if (_chart.renderTitle()) {
      slicesEnter.append("title").text(function (d) {
        return _chart.title()(d.data);
      });
    }
  }

  function positionLabels(labelsEnter, arc) {
    (0, _core.transition)(labelsEnter, _chart.transitionDuration()).attr("transform", function (d) {
      return labelPosition(d, arc);
    });

    /* OVERRIDE ---------------------------------------------------------------- */

    labelsEnter.style("font-size", pieIsBig() ? "14px" : "12px");

    labelsEnter.select(".value-dim").classed("deselected-label", function (d) {
      return _chart.hasFilter() && !isSelectedSlice(d);
    }).html(function (d) {
      return _chart.label()(d.data);
    }).html(function (d) {
      var availableLabelWidth = getAvailableLabelWidth(d);
      var width = _d2.default.select(this).node().getBoundingClientRect().width;
      var label = _chart.label()(d.data);
      var displayText = truncateLabelWithNull(label, width, availableLabelWidth);

      _d2.default.select(this.parentNode).classed("hide-label", displayText === "");

      return displayText;
    });

    if (_chart.measureLabelsOn()) {
      labelsEnter.select(".value-measure").classed("deselected-label", function (d) {
        return _chart.hasFilter() && !isSelectedSlice(d);
      })
      // the label needs to be in the DOM for computing its width
      .text(function (d) {
        if (_d2.default.select(this.parentNode).classed("hide-label")) {
          return "";
        } else {
          return _chart.measureValue(d.data);
        }
      }).text(function (d) {
        if (_d2.default.select(this.parentNode).classed("hide-label")) {
          return "";
        }
        var availableLabelWidth = getAvailableLabelWidth(d);
        var width = _d2.default.select(this).node().getBoundingClientRect().width;

        return width > availableLabelWidth ? truncateLabel(_chart.measureValue(d.data), width, availableLabelWidth) : _chart.measureValue(d.data);
      });

      if (ENABLE_PERCENTAGE_LABELS) {
        labelsEnter.select(".value-percentage").classed("deselected-label", function (d) {
          return _chart.hasFilter() && !isSelectedSlice(d);
        }).text(function (d) {
          if (_d2.default.select(this.parentNode).classed("hide-label")) {
            return "";
          } else {
            var availableLabelWidth = getAvailableLabelWidth(d);
            var width = _d2.default.select(this).node().getBoundingClientRect().width;

            return width > availableLabelWidth ? truncateLabel(d.percentage, width, availableLabelWidth) : d.percentage;
          }
        });
      }
    }
    /* ------------------------------------------------------------------------- */
  }

  function createLabels(pieData, arc) {
    if (_chart.renderLabel()) {
      var labels = _g.selectAll("g.pie-label").data(pieData);

      labels.exit().remove();

      var labelsEnter = labels.enter()
      /* OVERRIDE ---------------------------------------------------------------- */
      .append("g").attr("class", function (d, i) {
        var classes = "pie-label _" + i;
        if (_externalLabelRadius) {
          classes = classes + " external";
        }
        return classes;
      }).attr("transform", function (d) {
        return labelPosition(d, arc);
      })
      /* ------------------------------------------------------------------------- */
      .on("click", onClick);

      /* OVERRIDE ---------------------------------------------------------------- */
      if (ENABLE_ABSOLUTE_LABELS && ENABLE_PERCENTAGE_LABELS) {
        labelsEnter.append("text").attr("class", "value-dim").attr("dy", "-0.8em");

        labelsEnter.append("text").attr("class", "value-measure").attr("dy", ".4em");

        labelsEnter.append("text").attr("class", "value-percentage").attr("dy", "1.6em");
      } else if (ENABLE_ABSOLUTE_LABELS) {
        labelsEnter.append("text").attr("class", "value-dim").attr("dy", "0");

        labelsEnter.append("text").attr("class", "value-measure").attr("dy", "1.2em");
      } else if (ENABLE_PERCENTAGE_LABELS) {
        labelsEnter.append("text").attr("class", "value-dim").attr("dy", "0");

        labelsEnter.append("text").attr("class", "value-percentage").attr("dy", "1.2em");
      } else {
        labelsEnter.append("text").attr("class", "value-dim").attr("dy", ".4em");
      }
      /* ------------------------------------------------------------------------- */

      positionLabels(labelsEnter, arc);
      if (_externalLabelRadius && _drawPaths) {
        updateLabelPaths(pieData, arc);
      }
    }
  }

  function updateLabelPaths(pieData, arc) {
    var polyline = _g.selectAll("polyline." + _sliceCssClass).data(pieData);

    polyline.enter().append("polyline").attr("class", function (d, i) {
      return "pie-path _" + i + " " + _sliceCssClass;
    });

    polyline.exit().remove();
    (0, _core.transition)(polyline, _chart.transitionDuration()).attrTween("points", function (d) {
      this._current = this._current || d;
      var interpolate = _d2.default.interpolate(this._current, d);
      this._current = interpolate(0);
      return function (t) {
        var arc2 = _d2.default.svg.arc().outerRadius(_radius - _externalRadiusPadding + _externalLabelRadius).innerRadius(_radius - _externalRadiusPadding);
        var d2 = interpolate(t);
        return [arc.centroid(d2), arc2.centroid(d2)];
      };
    }).style("visibility", function (d) {
      return d.endAngle - d.startAngle < 0.0001 ? "hidden" : "visible";
    });
  }

  function updateElements(pieData, arc) {
    updateSlicePaths(pieData, arc);
    updateLabels(pieData, arc);
    updateTitles(pieData);
  }

  function updateSlicePaths(pieData, arc) {
    var slicePaths = _g.selectAll("g." + _sliceCssClass).data(pieData).classed("all-others", function (d) {
      return d.data.isAllOthers;
    }).select("path").attr("d", function (d, i) {
      return safeArc(d, i, arc);
    });
    (0, _core.transition)(slicePaths, _chart.transitionDuration(), function (s) {
      s.attrTween("d", tweenPie);
    }).attr("fill", fill);
  }

  function updateLabels(pieData, arc) {
    if (_chart.renderLabel()) {
      /* OVERRIDE ---------------------------------------------------------------- */
      var labels = _g.selectAll("g.pie-label")
      /* ------------------------------------------------------------------------- */
      .data(pieData);
      positionLabels(labels, arc);
      if (_externalLabelRadius && _drawPaths) {
        updateLabelPaths(pieData, arc);
      }
    }
  }

  function updateTitles(pieData) {
    if (_chart.renderTitle()) {
      _g.selectAll("g." + _sliceCssClass).data(pieData).select("title").text(function (d) {
        return _chart.title()(d.data);
      });
    }
  }

  function removeElements(slices) {
    slices.exit().remove();
  }

  /* OVERRIDE ---------------------------------------------------------------- */
  function accentSlice(label) {
    _chart.selectAll("g." + _sliceCssClass).each(function (d) {
      if (_chart.cappedKeyAccessor(d.data) == label) {
        _chart.accentSelected(this);
      }
    });
  }

  function unAccentSlice(label) {
    _chart.selectAll("g." + _sliceCssClass).each(function (d) {
      if (_chart.cappedKeyAccessor(d.data) == label) {
        _chart.unAccentSelected(this);
      }
    });
  }
  /* ------------------------------------------------------------------------- */

  function highlightFilter() {
    if (_chart.hasFilter()) {
      _chart.selectAll("g." + _sliceCssClass).each(function (d) {
        if (isSelectedSlice(d)) {
          _chart.highlightSelected(this);
        } else {
          _chart.fadeDeselected(this);
        }
      });
    } else {
      _chart.selectAll("g." + _sliceCssClass).each(function () {
        _chart.resetHighlight(this);
      });
    }
  }

  /**
   * Get or set the external radius padding of the pie chart. This will force the radius of the
   * pie chart to become smaller or larger depending on the value.
   * @name externalRadiusPadding
   * @memberof dc.pieChart
   * @instance
   * @param {Number} [externalRadiusPadding=0]
   * @return {Number}
   * @return {dc.pieChart}
   */
  _chart.externalRadiusPadding = function (externalRadiusPadding) {
    if (!arguments.length) {
      return _externalRadiusPadding;
    }
    _externalRadiusPadding = externalRadiusPadding;
    return _chart;
  };

  /**
   * Get or set the inner radius of the pie chart. If the inner radius is greater than 0px then the
   * pie chart will be rendered as a doughnut chart.
   * @name innerRadius
   * @memberof dc.pieChart
   * @instance
   * @param {Number} [innerRadius=0]
   * @return {Number}
   * @return {dc.pieChart}
   */
  _chart.innerRadius = function (innerRadius) {
    if (!arguments.length) {
      /* OVERRIDE ---------------------------------------------------------------- */
      return _pieStyle ? _pieStyle === "donut" ? (Math.min(_chart.width(), _chart.height()) - _externalRadiusPadding) / 5 : 0 : _innerRadius;
      /* ------------------------------------------------------------------------- */
    }
    _innerRadius = innerRadius;
    return _chart;
  };
  /* OVERRIDE ---------------------------------------------------------------- */
  _chart.pieStyle = function (pieStyle) {
    if (!arguments.length) {
      return _pieStyle;
    }

    _pieStyle = pieStyle;
    return _chart;
  };
  /* ------------------------------------------------------------------------- */

  /**
   * Get or set the outer radius. If the radius is not set, it will be half of the minimum of the
   * chart width and height.
   * @name radius
   * @memberof dc.pieChart
   * @instance
   * @param {Number} [radius]
   * @return {Number}
   * @return {dc.pieChart}
   */
  _chart.radius = function (radius) {
    if (!arguments.length) {
      return _givenRadius;
    }
    _givenRadius = radius;
    return _chart;
  };

  /**
   * Get or set center x coordinate position. Default is center of svg.
   * @name cx
   * @memberof dc.pieChart
   * @instance
   * @param {Number} [cx]
   * @return {Number}
   * @return {dc.pieChart}
   */
  _chart.cx = function (cx) {
    if (!arguments.length) {
      return _cx || _chart.width() / 2;
    }
    _cx = cx;
    return _chart;
  };

  /**
   * Get or set center y coordinate position. Default is center of svg.
   * @name cy
   * @memberof dc.pieChart
   * @instance
   * @param {Number} [cy]
   * @return {Number}
   * @return {dc.pieChart}
   */
  _chart.cy = function (cy) {
    if (!arguments.length) {
      return _cy || _chart.height() / 2;
    }
    _cy = cy;
    return _chart;
  };

  function buildArcs() {
    /* OVERRIDE ---------------------------------------------------------------- */
    return _d2.default.svg.arc().outerRadius(_radius - _externalRadiusPadding).innerRadius(_chart.innerRadius());
    /* ------------------------------------------------------------------------- */
  }

  function isSelectedSlice(d) {
    return _chart.hasFilter(_chart.cappedKeyAccessor(d.data)) ^ _chart.filtersInverse();
  }

  _chart._doRedraw = function () {
    /* OVERRIDE ---------------------------------------------------------------- */
    if (!_hasBeenRendered) {
      // guard to prevent a redraw before a render
      return _chart._doRender();
    }
    /* ------------------------------------------------------------------------- */
    drawChart();
    return _chart;
  };

  /**
   * Get or set the minimal slice angle for label rendering. Any slice with a smaller angle will not
   * display a slice label.
   * @name minAngleForLabel
   * @memberof dc.pieChart
   * @instance
   * @param {Number} [minAngleForLabel=0.5]
   * @return {Number}
   * @return {dc.pieChart}
   */
  _chart.minAngleForLabel = function (minAngleForLabel) {
    if (!arguments.length) {
      return _minAngleForLabel;
    }
    _minAngleForLabel = minAngleForLabel;
    return _chart;
  };

  function pieLayout() {
    return _d2.default.layout.pie().sort(null).value(_chart.cappedValueAccessor);
  }

  /* OVERRIDE ---------------------------------------------------------------- */
  function getAvailableLabelWidth(d) {
    var angle = d.endAngle - d.startAngle;

    if (isNaN(angle) || angle * (_radius / 2) < (_chart.measureLabelsOn() ? 28 : 20)) {
      return 0;
    }

    var arc = buildArcs();
    var centroid = labelCentroid(d, arc);
    var adjacent = Math.abs(centroid[1]);

    if (angle >= Math.TWO_PI) {
      // when there's a single slice, no need to compute more than that
      return adjacent;
    }
    var useAngle = centroid[0] * centroid[1] < 0 ? d.startAngle : d.endAngle;
    var refAngle = centroid[1] >= 0 ? Math.PI : centroid[0] < 0 ? Math.PI * 2 : 0;

    var tan = Math.tan(Math.abs(refAngle - useAngle));
    var opposite = tan * adjacent;
    var labelWidth = (refAngle >= d.startAngle && refAngle < d.endAngle ? Math.abs(centroid[0]) + opposite : Math.abs(centroid[0]) - opposite) * 2;
    var maxLabelWidth = _radius - _chart.innerRadius() - 24;

    return labelWidth > maxLabelWidth || labelWidth < 0 ? maxLabelWidth : labelWidth;
  }

  function truncateLabel(data, width, availableLabelWidth) {
    if (width > availableLabelWidth) {
      var APPROX_FONT_WIDTH = 9;
      return String(data).slice(0, availableLabelWidth / APPROX_FONT_WIDTH) + "";
    } else {
      String(data);
    }
  }

  function truncateLabelWithNull(data, width, availableLabelWidth) {
    if (width > availableLabelWidth) {
      return truncateLabel(data.toString().replace(_formattingHelpers.nullLabelHtml, "NULL"), width, availableLabelWidth).replace(/\bNULL[^A-Za-z]/g, _formattingHelpers.nullLabelHtml + " ");
    } else {
      return data;
    }
  }

  /* ------------------------------------------------------------------------- */

  function sliceTooSmall(d) {
    var angle = d.endAngle - d.startAngle;
    return isNaN(angle) || angle < _minAngleForLabel;
  }

  function sliceHasNoData(d) {
    return _chart.cappedValueAccessor(d) === 0;
  }

  function tweenPie(b) {
    /* OVERRIDE ---------------------------------------------------------------- */
    b.innerRadius = _chart.innerRadius();
    /* ------------------------------------------------------------------------- */
    var current = this._current;
    if (isOffCanvas(current)) {
      current = { startAngle: 0, endAngle: 0 };
    }
    var i = _d2.default.interpolate(current, b);
    this._current = i(0);
    return function (t) {
      return safeArc(i(t), 0, buildArcs());
    };
  }

  function isOffCanvas(current) {
    return !current || isNaN(current.startAngle) || isNaN(current.endAngle);
  }

  function fill(d, i) {
    return _chart.getColor(d.data, i);
  }

  function onClick(d, i) {
    if (_g.attr("class") !== _emptyCssClass && !d.data.isAllOthers) {
      _chart.onClick(d.data, i);
    }
  }
  /* OVERRIDE ---------------------------------------------------------------- */
  function showPopup(d, i) {
    var popup = _chart.popup();

    var popupBox = popup.select(".chart-popup-content").html("");

    popupBox.append("div").attr("class", "popup-legend").style("background-color", fill(d, i));

    popupBox.append("div").attr("class", "popup-value").html(function () {
      return "<div class=\"popup-value-dim\">" + _chart.label()(d.data) + "</div><div class=\"popup-value-measure\">" + _chart.measureValue(d.data) + "</div>" + (ENABLE_PERCENTAGE_LABELS_IN_POPUP ? "<div class=\"popup-value-measure\">" + d.percentage + "</div>" : "");
    });

    popup.classed("js-showPopup", true);
  }

  function hidePopup() {
    _chart.popup().classed("js-showPopup", false);
  }

  function positionPopup() {
    var coordinates = [0, 0];
    coordinates = _chart.popupCoordinates(_d2.default.mouse(this));
    var x = coordinates[0] + _chart.width() / 2;
    var y = coordinates[1] + _chart.height() / 2;

    var popup = _chart.popup().attr("style", function () {
      return "transform:translate(" + x + "px," + y + "px)";
    });

    popup.select(".chart-popup-box").classed("align-center", function () {
      return x + _d2.default.select(this).node().getBoundingClientRect().width > _chart.width() && x - _d2.default.select(this).node().getBoundingClientRect().width / 2 >= 0;
    }).classed("align-right", function () {
      return x + _d2.default.select(this).node().getBoundingClientRect().width > _chart.width() && x - _d2.default.select(this).node().getBoundingClientRect().width >= 0;
    });
  }

  function pieIsBig() {
    return _pieSizeThreshold < Math.min(_chart.width(), _chart.height());
  }
  /* ------------------------------------------------------------------------- */

  function safeArc(d, i, arc) {
    var path = arc(d, i);
    if (path.indexOf("NaN") >= 0) {
      path = "M0,0";
    }
    return path;
  }

  /**
   * Title to use for the only slice when there is no data.
   * @name emptyTitle
   * @memberof dc.pieChart
   * @instance
   * @param {String} [title]
   * @return {String}
   * @return {dc.pieChart}
   */
  _chart.emptyTitle = function (title) {
    if (arguments.length === 0) {
      return _emptyTitle;
    }
    _emptyTitle = title;
    return _chart;
  };

  /**
   * Position slice labels offset from the outer edge of the chart
   *
   * The given argument sets the radial offset.
   * @name externalLabels
   * @memberof dc.pieChart
   * @instance
   * @param {Number} [externalLabelRadius]
   * @return {Number}
   * @return {dc.pieChart}
   */
  _chart.externalLabels = function (externalLabelRadius) {
    if (arguments.length === 0) {
      return _externalLabelRadius;
    } else if (externalLabelRadius) {
      _externalLabelRadius = externalLabelRadius;
    } else {
      _externalLabelRadius = undefined;
    }

    return _chart;
  };

  /**
   * Get or set whether to draw lines from pie slices to their labels.
   *
   * @name drawPaths
   * @memberof dc.pieChart
   * @instance
   * @param {Boolean} [drawPaths]
   * @return {Boolean}
   * @return {dc.pieChart}
   */
  _chart.drawPaths = function (drawPaths) {
    if (arguments.length === 0) {
      return _drawPaths;
    }
    _drawPaths = drawPaths;
    return _chart;
  };

  function labelPosition(d, arc) {
    var centroid = void 0;
    if (_externalLabelRadius) {
      centroid = _d2.default.svg.arc().outerRadius(_radius - _externalRadiusPadding + _externalLabelRadius).innerRadius(_radius - _externalRadiusPadding + _externalLabelRadius).centroid(d);
    } else {
      /* OVERRIDE -----------------------------------------------------------------*/
      centroid = labelCentroid(d, arc);
      /* --------------------------------------------------------------------------*/
    }
    if (isNaN(centroid[0]) || isNaN(centroid[1])) {
      return "translate(0,0)";
    } else {
      return "translate(" + centroid + ")";
    }
  }

  /* OVERRIDE -----------------------------------------------------------------*/
  function labelCentroid(d, arc) {
    var centroid = void 0;
    if (_externalLabelRadius) {
      centroid = _d2.default.svg.arc().outerRadius(_radius - _externalRadiusPadding + _externalLabelRadius).innerRadius(_radius - _externalRadiusPadding + _externalLabelRadius).centroid(d);
    } else {
      centroid = _innerRadius === 0 && _pieStyle != "donut" ? _d2.default.svg.arc().outerRadius(_radius - _externalRadiusPadding).innerRadius(_radius / 5).centroid(d) : arc.centroid(d);
    }

    return centroid;
  }
  /* --------------------------------------------------------------------------*/

  _chart.legendables = function () {
    return _chart.data().map(function (d, i) {
      /* OVERRIDE -----------------------------------------------------------------*/
      var legendable = {
        name: d.key0,
        data: d.value,
        others: d.others,
        chart: _chart
        /* --------------------------------------------------------------------------*/

      };legendable.color = _chart.getColor(d, i);
      return legendable;
    });
  };

  _chart.legendHighlight = function (d) {
    highlightSliceFromLegendable(d, true);
  };

  _chart.legendReset = function (d) {
    highlightSliceFromLegendable(d, false);
  };

  _chart.legendToggle = function (d) {
    _chart.onClick({ key: d.name, others: d.others });
  };

  function highlightSliceFromLegendable(legendable, highlighted) {
    _chart.selectAll("g.pie-slice").each(function (d) {
      if (legendable.name === d.data.key) {
        _d2.default.select(this).classed("highlight", highlighted);
      }
    });
  }

  _chart = (0, _multipleKeyLabelMixin2.default)(_chart);

  /**
   * Controls Absolute values toggle from immerse
   * @param showAbsoluteValues
   * @returns {dc.pieChart|*}
   */
  _chart.showAbsoluteValues = function (showAbsoluteValues) {
    if (!arguments.length) {
      return ENABLE_ABSOLUTE_LABELS;
    }
    ENABLE_ABSOLUTE_LABELS = showAbsoluteValues;

    if (_hasBeenRendered) {
      _chart._doRender();
    }
    return _chart;
  };

  /**
   * Controls Percent values toggle from immerse
   * @param showPercentValues
   * @returns {dc.pieChart|*}
   */
  _chart.showPercentValues = function (showPercentValues) {
    if (!arguments.length) {
      return ENABLE_PERCENTAGE_LABELS;
    }
    ENABLE_PERCENTAGE_LABELS = showPercentValues;

    if (_hasBeenRendered) {
      _chart._doRender();
    }
    return _chart;
  };

  /**
   * Controls All Others value toggle from immerse
   * @param showAllOthers
   * @returns {dc.pieChart|*}
   */
  _chart.showAllOthers = function (showAllOthers) {
    if (!arguments.length) {
      return ENABLE_ALL_OTHERS_LABELS;
    }
    ENABLE_ALL_OTHERS_LABELS = showAllOthers;

    if (_hasBeenRendered) {
      _chart.expireCache();
      _chart.renderAsync();
    }
    return _chart;
  };

  /**
   * Whether chart should show percentage values in popup
   * @param showPercentValues
   * @returns {dc.pieChart|*}
   */
  _chart.showPercentValuesInPopup = function (showPercentValuesInPopup) {
    if (!arguments.length) {
      return ENABLE_PERCENTAGE_LABELS_IN_POPUP;
    }
    ENABLE_PERCENTAGE_LABELS_IN_POPUP = showPercentValuesInPopup;

    if (_hasBeenRendered) {
      _chart.generatePopup();
    }
    return _chart;
  };

  return _chart.anchor(parent, chartGroup);
}
/** ***************************************************************************
 * END OVERRIDE: dc.pieChart                                                  *
 * ***************************************************************************/

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = lineChart;

var _core = __webpack_require__(3);

var _utils = __webpack_require__(4);

var _coordinateGridMixin = __webpack_require__(14);

var _coordinateGridMixin2 = _interopRequireDefault(_coordinateGridMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _elasticDimensionMixin = __webpack_require__(186);

var _elasticDimensionMixin2 = _interopRequireDefault(_elasticDimensionMixin);

var _stackMixin = __webpack_require__(39);

var _stackMixin2 = _interopRequireDefault(_stackMixin);

var _multiSeriesMixin = __webpack_require__(188);

var _multiSeriesMixin2 = _interopRequireDefault(_multiSeriesMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Concrete line/area chart implementation.
 *
 * Examples:
 * - {@link https://mapd.github.io/mapd-charting/example/example1.html Number of Flights by Departure Time}
 * @name lineChart
 * @memberof dc
 * @mixes dc.stackMixin
 * @mixes dc.coordinateGridMixin
 * @example
 * // create a line chart under #chart-container1 element using the default global chart group
 * var chart1 = dc.lineChart('#chart-container1');
 * // create a line chart under #chart-container2 element using chart group A
 * var chart2 = dc.lineChart('#chart-container2', 'chartGroupA');
 * // create a sub-chart under a composite parent chart
 * var chart3 = dc.lineChart(compositeChart);
 * @param {String|node|d3.selection|dc.compositeChart} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector}
 * specifying a dom block element such as a div; or a dom element or d3 selection.  If the line
 * chart is a sub-chart in a {@link #dc.compositeChart Composite Chart} then pass in the parent
 * composite chart instance instead.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
 * Interaction with a chart will only trigger events and redraws within the chart's group.
 * @return {dc.lineChart}
 */
function lineChart(parent, chartGroup) {
  var DEFAULT_DOT_RADIUS = 5;
  var TOOLTIP_G_CLASS = "dc-tooltip";
  var DOT_CIRCLE_CLASS = "dot";
  var Y_AXIS_REF_LINE_CLASS = "yRef";
  var X_AXIS_REF_LINE_CLASS = "xRef";
  var DEFAULT_DOT_OPACITY = 1e-6;

  var _chart = (0, _elasticDimensionMixin2.default)((0, _stackMixin2.default)((0, _coordinateGridMixin2.default)({})));
  var _renderArea = false;
  var _dotRadius = DEFAULT_DOT_RADIUS;
  var _dataPointRadius = null;
  var _dataPointFillOpacity = DEFAULT_DOT_OPACITY;
  var _dataPointStrokeOpacity = DEFAULT_DOT_OPACITY;
  var _interpolate = "linear";
  var _tension = 0.7;
  var _defined = void 0;
  var _dashStyle = void 0;
  var _xyTipsOn = true;

  _chart.transitionDuration(500);
  _chart._rangeBandPadding(1);

  _chart.plotData = function () {
    var chartBody = _chart.chartBodyG();
    var layersList = chartBody.selectAll("g.stack-list");

    if (layersList.empty()) {
      layersList = chartBody.append("g").attr("class", "stack-list");
    }

    var layers = layersList.selectAll("g.stack").data(_chart.data());

    var layersEnter = layers.enter().append("g").attr("class", function (d, i) {
      return "stack " + "_" + i;
    });

    drawLine(layersEnter, layers);

    drawArea(layersEnter, layers);

    drawDots(chartBody, layers);
  };

  /**
   * Gets or sets the interpolator to use for lines drawn, by string name, allowing e.g. step
   * functions, splines, and cubic interpolation.  This is passed to
   * {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#line_interpolate d3.svg.line.interpolate} and
   * {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#area_interpolate d3.svg.area.interpolate},
   * where you can find a complete list of valid arguments
   * @name interpolate
   * @memberof dc.lineChart
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#line_interpolate d3.svg.line.interpolate}
   * @see {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#area_interpolate d3.svg.area.interpolate}
   * @param  {String} [interpolate='linear']
   * @return {String}
   * @return {dc.lineChart}
   */
  _chart.interpolate = function (interpolate) {
    if (!arguments.length) {
      return _interpolate;
    }
    _interpolate = interpolate;
    return _chart;
  };

  /**
   * Gets or sets the tension to use for lines drawn, in the range 0 to 1.
   * This parameter further customizes the interpolation behavior.  It is passed to
   * {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#line_tension d3.svg.line.tension} and
   * {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#area_tension d3.svg.area.tension}.
   * @name tension
   * @memberof dc.lineChart
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#line_interpolate d3.svg.line.interpolate}
   * @see {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#area_interpolate d3.svg.area.interpolate}
   * @param  {Number} [tension=0.7]
   * @return {Number}
   * @return {dc.lineChart}
   */
  _chart.tension = function (tension) {
    if (!arguments.length) {
      return _tension;
    }
    _tension = tension;
    return _chart;
  };

  /**
   * Gets or sets a function that will determine discontinuities in the line which should be
   * skipped: the path will be broken into separate subpaths if some points are undefined.
   * This function is passed to
   * {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#line_defined d3.svg.line.defined}
   *
   * Note: crossfilter will sometimes coerce nulls to 0, so you may need to carefully write
   * custom reduce functions to get this to work, depending on your data. See
   * https://github.com/dc-js/dc.js/issues/615#issuecomment-49089248
   * @name defined
   * @memberof dc.lineChart
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#line_defined d3.svg.line.defined}
   * @param  {Function} [defined]
   * @return {Function}
   * @return {dc.lineChart}
   */
  _chart.defined = function (defined) {
    if (!arguments.length) {
      return _defined;
    }
    _defined = defined;
    return _chart;
  };

  /**
   * Set the line's d3 dashstyle. This value becomes the 'stroke-dasharray' of line. Defaults to empty
   * array (solid line).
   * @name dashStyle
   * @memberof dc.lineChart
   * @instance
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray stroke-dasharray}
   * @example
   * // create a Dash Dot Dot Dot
   * chart.dashStyle([3,1,1,1]);
   * @param  {Array<Number>} [dashStyle=[]]
   * @return {Array<Number>}
   * @return {dc.lineChart}
   */
  _chart.dashStyle = function (dashStyle) {
    if (!arguments.length) {
      return _dashStyle;
    }
    _dashStyle = dashStyle;
    return _chart;
  };

  _chart.measureValue = function (value) {
    var customFormatter = _chart.valueFormatter();
    return customFormatter && customFormatter(value) || _utils.utils.formatValue(value);
  };

  _chart.dimensionValue = function (value) {
    var customFormatter = _chart.dateFormatter();
    return customFormatter && customFormatter(value) || _utils.utils.formatValue(value);
  };
  /**
   * Get or set render area flag. If the flag is set to true then the chart will render the area
   * beneath each line and the line chart effectively becomes an area chart.
   * @name renderArea
   * @memberof dc.lineChart
   * @instance
   * @param  {Boolean} [renderArea=false]
   * @return {Boolean}
   * @return {dc.lineChart}
   */
  _chart.renderArea = function (renderArea) {
    if (!arguments.length) {
      return _renderArea;
    }
    _renderArea = renderArea;
    return _chart;
  };

  function colors(d, i) {
    if (d.name) {
      d.layer = d.name;
      return _chart.getColor(d, i);
    } else {
      return _chart.getColor(d, i);
    }
  }

  function drawLine(layersEnter, layers) {
    var line = _d2.default.svg.line().x(function (d) {
      return _chart.x()(d.x);
    }).y(function (d) {
      /* OVERRIDE ---------------------------------------------------------------- */
      if (_renderArea) {
        return _chart.y()(d.y + d.y0);
      } else {
        return _chart.y()(d.y);
      }
      /* ------------------------------------------------------------------------- */
    }).interpolate(_interpolate).tension(_tension);
    if (_defined) {
      line.defined(_defined);
    }

    var path = layersEnter.append("path").attr("class", "line").attr("stroke", colors);
    if (_dashStyle) {
      path.attr("stroke-dasharray", _dashStyle);
    }

    (0, _core.transition)(layers.select("path.line"), _chart.transitionDuration())
    // .ease('linear')
    .attr("stroke", colors).attr("d", function (d) {
      return safeD(line(d.values));
    });
  }

  function drawArea(layersEnter, layers) {
    if (_renderArea) {
      var area = _d2.default.svg.area().x(function (d) {
        return _chart.x()(d.x);
      }).y(function (d) {
        return _chart.y()(d.y + d.y0);
      }).y0(function (d) {
        return _chart.y()(d.y0);
      }).interpolate(_interpolate).tension(_tension);
      if (_defined) {
        area.defined(_defined);
      }

      layersEnter.append("path").attr("class", "area").attr("fill", colors).attr("d", function (d) {
        return safeD(area(d.values));
      });

      (0, _core.transition)(layers.select("path.area"), _chart.transitionDuration())
      // .ease('linear')
      .attr("fill", colors).attr("d", function (d) {
        return safeD(area(d.values));
      });
    }
  }

  function safeD(d) {
    return !d || d.indexOf("NaN") >= 0 ? "M0,0" : d;
  }

  function hoverOverBrush() {
    var g = _chart.g().on("mouseout", function () {
      hideBrushDots();
    }).on("mousemove", function () {
      if (_chart.isBrushing()) {
        hidePopup();
      } else {
        showBrushDots(g, this);
      }
    });
  }

  function hideBrushDots() {
    _chart.g().selectAll(".dot").style("fill-opacity", 0);
    hidePopup();
  }

  function showBrushDots(g, e) {
    var coordinates = [0, 0];
    coordinates = _chart.popupCoordinates(_d2.default.mouse(e));
    var x = coordinates[0];
    var y = coordinates[1];
    var xAdjusted = x - _chart.margins().left;

    var popupRows = [];

    var toolTips = g.selectAll(".dc-tooltip").each(function () {
      var lastDot = null;
      var hoverDot = null;

      var dots = _d2.default.select(this).selectAll(".dot").style("fill-opacity", 0);

      dots[0].sort(function (a, b) {
        return _d2.default.select(a).attr("cx") - _d2.default.select(b).attr("cx");
      });

      dots[0].some(function (obj, i) {
        var elm = _d2.default.select(obj);

        if (xAdjusted < elm.attr("cx")) {
          hoverDot = { elm: elm, datum: elm.datum(), i: i };
          return true;
        }

        lastDot = { elm: elm, datum: elm.datum(), i: i };
      });

      hoverDot = lastDot && hoverDot ? Math.abs(lastDot.elm.attr("cx") - xAdjusted) < Math.abs(hoverDot.elm.attr("cx") - xAdjusted) ? lastDot : hoverDot : hoverDot;

      if (hoverDot && Math.abs(hoverDot.elm.attr("cx") - xAdjusted) < 32) {
        hoverDot.elm.style("fill-opacity", 1);
        popupRows.push(hoverDot);
      }
    });

    if (popupRows.length > 0) {
      showPopup(popupRows, x, y);
    } else {
      hidePopup();
    }
  }

  function showPopup(arr, x, y) {
    if (!_chart.popupIsEnabled()) {
      hidePopup();
      return false;
    }
    var popup = _chart.popup();

    var popupBox = popup.select(".chart-popup-content").html("").classed("popup-list", true);

    popupBox.append("div").attr("class", "popup-header").text(_chart.popupTextAccessor(arr));

    var popupItems = popupBox.selectAll(".popup-item").data(arr.sort(function (a, b) {
      return _renderArea ? b.datum.y + b.datum.y0 - (a.datum.y + a.datum.y0) : b.datum.y - a.datum.y;
    })).enter().append("div").attr("class", "popup-item");

    popupItems.append("div").attr("class", "popup-legend").style("background-color", function (d) {
      return colors(d.datum, d.i);
    });

    if (_chart.series().keys()) {
      popupItems.append("div").attr("class", "popup-item-key").text(function (d) {
        return _chart.colorDomain()[d.datum.idx];
      });
    }

    popupItems.append("div").attr("class", "popup-item-value").classed("text-align-right", Boolean(_chart.series().keys())).text(function (d) {
      return _chart.measureValue(d.datum.y);
    });

    positionPopup(x, y);
    popup.classed("js-showPopup", true);
  }

  function hidePopup() {
    _chart.popup().classed("js-showPopup", false);
  }

  function positionPopup(x, y) {
    var popup = _chart.popup().attr("style", function () {
      return "transform:translate(" + x + "px," + y + "px)";
    });

    popup.select(".chart-popup-box").classed("align-left-center", true).classed("align-right-center", function () {
      return x + (_d2.default.select(this).node().getBoundingClientRect().width + 32) > _chart.width();
    });
  }

  function drawDots(chartBody, layers) {
    /* OVERRIDE ---------------------------------------------------------------- */
    // if (!_chart.brushOn() && _chart.xyTipsOn()) {
    /* ------------------------------------------------------------------------- */

    var tooltipListClass = TOOLTIP_G_CLASS + "-list";
    var tooltips = chartBody.select("g." + tooltipListClass);

    if (tooltips.empty()) {
      tooltips = chartBody.append("g").attr("class", tooltipListClass);
    }

    layers.each(function (d, layerIndex) {
      var points = d.values;
      if (_defined) {
        points = points.filter(_defined);
      }

      var g = tooltips.select("g." + TOOLTIP_G_CLASS + "._" + layerIndex);
      if (g.empty()) {
        g = tooltips.append("g").attr("class", TOOLTIP_G_CLASS + " _" + layerIndex);
      }

      createRefLines(g);

      var dots = g.selectAll("circle." + DOT_CIRCLE_CLASS).data(points, function (d) {
        return d.x instanceof Date ? d.x.toISOString() : d.x;
      });

      dots.enter().append("circle").attr("class", DOT_CIRCLE_CLASS).attr("r", getDotRadius()).style("fill-opacity", _dataPointFillOpacity).style("stroke-opacity", _dataPointStrokeOpacity).on("mousemove", function () {
        var dot = _d2.default.select(this);
        showDot(dot);
        showRefLines(dot, g);
      }).on("mouseout", function () {
        var dot = _d2.default.select(this);
        hideDot(dot);
        hideRefLines(g);
      });

      dots.attr("cx", function (d) {
        return _utils.utils.safeNumber(_chart.x()(d.x));
      }).attr("cy", function (d) {
        /* OVERRIDE ---------------------------------------------------------------- */
        if (_renderArea) {
          return _utils.utils.safeNumber(_chart.y()(d.y + d.y0));
        } else {
          return _utils.utils.safeNumber(_chart.y()(d.y));
        }
        /* ------------------------------------------------------------------------- */
      }).attr("fill", colors).call(renderTitle, d);

      dots.exit().remove();
    });

    if (_chart.brushOn() && !_chart.focusChart()) {
      hoverOverBrush();
    }

    /* OVERRIDE ---------------------------------------------------------------- */
    // }
    /* ------------------------------------------------------------------------- */
  }

  function createRefLines(g) {
    var yRefLine = g.select("path." + Y_AXIS_REF_LINE_CLASS).empty() ? g.append("path").attr("class", Y_AXIS_REF_LINE_CLASS) : g.select("path." + Y_AXIS_REF_LINE_CLASS);
    yRefLine.style("display", "none").attr("stroke-dasharray", "5,5");

    var xRefLine = g.select("path." + X_AXIS_REF_LINE_CLASS).empty() ? g.append("path").attr("class", X_AXIS_REF_LINE_CLASS) : g.select("path." + X_AXIS_REF_LINE_CLASS);
    xRefLine.style("display", "none").attr("stroke-dasharray", "5,5");
  }

  function showDot(dot) {
    dot.style("fill-opacity", 0.8);
    dot.style("stroke-opacity", 0.8);
    dot.attr("r", _dotRadius);
    return dot;
  }

  function showRefLines(dot, g) {
    var x = dot.attr("cx");
    var y = dot.attr("cy");
    var yAxisX = _chart._yAxisX() - _chart.margins().left;
    var yAxisRefPathD = "M" + yAxisX + " " + y + "L" + x + " " + y;
    var xAxisRefPathD = "M" + x + " " + _chart.yAxisHeight() + "L" + x + " " + y;
    g.select("path." + Y_AXIS_REF_LINE_CLASS).style("display", "").attr("d", yAxisRefPathD);
    g.select("path." + X_AXIS_REF_LINE_CLASS).style("display", "").attr("d", xAxisRefPathD);
  }

  function getDotRadius() {
    return _dataPointRadius || _dotRadius;
  }

  function hideDot(dot) {
    dot.style("fill-opacity", _dataPointFillOpacity).style("stroke-opacity", _dataPointStrokeOpacity).attr("r", getDotRadius());
  }

  function hideRefLines(g) {
    g.select("path." + Y_AXIS_REF_LINE_CLASS).style("display", "none");
    g.select("path." + X_AXIS_REF_LINE_CLASS).style("display", "none");
  }

  function renderTitle(dot, d) {
    if (_chart.renderTitle()) {
      dot.selectAll("title").remove();
      dot.append("title").text((0, _utils.pluck)("data", _chart.title(d.name)));
    }
  }

  /**
   * Turn on/off the mouseover behavior of an individual data point which renders a circle and x/y axis
   * dashed lines back to each respective axis.  This is ignored if the chart
   * {@link #dc.coordinateGridMixin+brushOn brush} is on
   * @name xyTipsOn
   * @memberof dc.lineChart
   * @instance
   * @param  {Boolean} [xyTipsOn=false]
   * @return {Boolean}
   * @return {dc.lineChart}
   */
  _chart.xyTipsOn = function (xyTipsOn) {
    if (!arguments.length) {
      return _xyTipsOn;
    }
    _xyTipsOn = xyTipsOn;
    return _chart;
  };

  /**
   * Get or set the radius (in px) for dots displayed on the data points.
   * @name dotRadius
   * @memberof dc.lineChart
   * @instance
   * @param  {Number} [dotRadius=5]
   * @return {Number}
   * @return {dc.lineChart}
   */
  _chart.dotRadius = function (dotRadius) {
    if (!arguments.length) {
      return _dotRadius;
    }
    _dotRadius = dotRadius;
    return _chart;
  };

  /**
   * Always show individual dots for each datapoint.
   * If `options` is falsy, it disables data point rendering.
   *
   * If no `options` are provided, the current `options` values are instead returned.
   * @name renderDataPoints
   * @memberof dc.lineChart
   * @instance
   * @example
   * chart.renderDataPoints({radius: 2, fillOpacity: 0.8, strokeOpacity: 0.8})
   * @param  {{fillOpacity: Number, strokeOpacity: Number, radius: Number}} [options={fillOpacity: 0.8, strokeOpacity: 0.8, radius: 2}]
   * @return {{fillOpacity: Number, strokeOpacity: Number, radius: Number}}
   * @return {dc.lineChart}
   */
  _chart.renderDataPoints = function (options) {
    if (!arguments.length) {
      return {
        fillOpacity: _dataPointFillOpacity,
        strokeOpacity: _dataPointStrokeOpacity,
        radius: _dataPointRadius
      };
    } else if (!options) {
      _dataPointFillOpacity = DEFAULT_DOT_OPACITY;
      _dataPointStrokeOpacity = DEFAULT_DOT_OPACITY;
      _dataPointRadius = null;
    } else {
      _dataPointFillOpacity = options.fillOpacity || 0.8;
      _dataPointStrokeOpacity = options.strokeOpacity || 0.8;
      _dataPointRadius = options.radius || 2;
    }
    return _chart;
  };

  function colorFilter(color, dashstyle, inv) {
    return function () {
      var item = _d2.default.select(this);
      var match = item.attr("stroke") === color && item.attr("stroke-dasharray") === (dashstyle instanceof Array ? dashstyle.join(",") : null) || item.attr("fill") === color;
      return inv ? !match : match;
    };
  }

  _chart.legendHighlight = function (d) {
    if (!_chart.isLegendableHidden(d)) {
      _chart.g().selectAll("path.line, path.area").classed("highlight", colorFilter(d.color, d.dashstyle)).classed("fadeout", colorFilter(d.color, d.dashstyle, true));
    }
  };

  _chart.legendReset = function () {
    _chart.g().selectAll("path.line, path.area").classed("highlight", false).classed("fadeout", false);
  };

  (0, _core.override)(_chart, "legendables", function () {
    var legendables = _chart._legendables();
    if (!_dashStyle) {
      return legendables;
    }
    return legendables.map(function (l) {
      l.dashstyle = _dashStyle;
      return l;
    });
  });

  _chart = (0, _multiSeriesMixin2.default)(_chart);

  _chart.destroyChart = function () {
    (0, _core.deregisterChart)(_chart, _chart.chartGroup());
    _chart.on("filtered", null);
    _chart.filterAll();
    _chart.resetSvg();
    _chart.root().attr("style", "").attr("class", "").html("");
    _chart._doRender = function () {
      return _chart;
    };
  };

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = numberChart;

var _baseMixin = __webpack_require__(7);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _utils = __webpack_require__(4);

var _coreAsync = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function numberChart(parent, chartGroup) {
  var _chart = (0, _baseMixin2.default)({});
  var _colors = "#22a7f0";
  var _fontSize = null;
  var _chartWidth = null;

  _chart.colors = function (_) {
    if (!arguments.length) {
      return _colors;
    }
    _colors = _;
    return _chart;
  };

  _chart.getColor = function (selected, all) {
    return typeof _colors === "string" ? _colors : _colors[0];
  };

  _chart.setDataAsync(function (group, callbacks) {
    return group.valueAsync().then(function (data) {
      callbacks(null, data);
    }).catch(function (error) {
      callbacks(error);
    });
  });

  _chart._doRender = function (val) {
    var customFormatter = _chart.valueFormatter();
    var formattedValue = val;
    if (customFormatter && customFormatter(val)) {
      formattedValue = customFormatter(val);
    } else {
      formattedValue = _utils.utils.formatValue(val);
      if (formattedValue === "-0") {
        formattedValue = 0;
      }
    }

    var wrapper = _chart.root().html("").append("div").attr("class", "number-chart-wrapper");

    var TEXT_PADDING_RATIO = 5;
    var chartWidth = _chart.width();
    var chartHeight = _chart.height();
    var wrapperWidth = chartWidth - chartWidth / 100 * TEXT_PADDING_RATIO;
    var wrapperHeight = chartHeight - chartHeight / 100 * TEXT_PADDING_RATIO;
    var fontSize = _utils.utils.getFontSizeFromWidth(formattedValue, wrapperWidth, wrapperHeight);
    wrapper.append("span").attr("class", "number-chart-number").style("color", _chart.getColor).style("font-size", fontSize + "px").html(formattedValue);

    return _chart;
  };

  _chart._doRedraw = function (val) {
    return _chart._doRender(val);
  };

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = rasterChart;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _stackedLegend = __webpack_require__(270);

var _coordinateGridRasterMixin = __webpack_require__(193);

var _coordinateGridRasterMixin2 = _interopRequireDefault(_coordinateGridRasterMixin);

var _mapMixin = __webpack_require__(41);

var _mapMixin2 = _interopRequireDefault(_mapMixin);

var _baseMixin = __webpack_require__(7);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

var _scatterMixin = __webpack_require__(202);

var _scatterMixin2 = _interopRequireDefault(_scatterMixin);

var _coreAsync = __webpack_require__(5);

var _legendables = __webpack_require__(293);

var _lodash = __webpack_require__(23);

var _ = _interopRequireWildcard(_lodash);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function rasterChart(parent, useMap, chartGroup, _mapboxgl) {
  var _chart = null;
  var _legend = null;

  var _useMap = useMap !== undefined ? useMap : false;

  var parentDivId = parent.attributes.id.value;

  var browser = detectBrowser();
  function detectBrowser() {
    // from SO: http://bit.ly/1Wd156O
    var isOpera = Boolean(window.opr) && Boolean(opr.addons) || Boolean(window.opera) || navigator.userAgent.indexOf(" OPR/") >= 0;
    var isFirefox = typeof InstallTrigger !== "undefined";
    var isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf("Constructor") > 0;
    var isIE = /* @cc_on!@*/false || Boolean(document.documentMode);
    var isEdge = !isIE && Boolean(window.StyleMedia);
    var isChrome = Boolean(window.chrome) && Boolean(window.chrome.webstore);
    return { isOpera: isOpera, isFirefox: isFirefox, isSafari: isSafari, isIE: isIE, isEdge: isEdge, isChrome: isChrome };
  }

  if (_useMap) {
    _chart = (0, _mapMixin2.default)((0, _baseMixin2.default)({}), parentDivId, _mapboxgl, true, false);
  } else {
    _chart = (0, _scatterMixin2.default)((0, _coordinateGridRasterMixin2.default)({}, _mapboxgl, browser), _mapboxgl, true);
  }

  // unset predefined mandatory attributes
  _chart._mandatoryAttributes([]);

  var _con = window.hasOwnProperty("con") ? con : null;
  var _imageOverlay = null;
  var _renderBoundsMap = {};
  var _layerNames = {};
  var _layers = [];
  var _hasBeenRendered = false;

  var _events = ["vegaSpec"];
  var _listeners = _d2.default.dispatch.apply(_d2.default, _events);
  var _on = _chart.on.bind(_chart);

  var _x = null;
  var _y = null;
  var _xScaleName = "x";
  var _yScaleName = "y";

  var _xLatLngBnds = null;
  var _yLatLngBnds = null;
  var _useGeoTypes = false;

  var _usePixelRatio = false;
  var _pixelRatio = 1;

  var _minPopupShapeBoundsArea = 16 * 16;
  var _popupSearchRadius = 2;
  var _popupDivClassName = "map-popup";
  var _popupDisplayable = true;
  var _legendOpen = true;

  var _shiftToZoom = false;

  _chart.on = function (event, listener) {
    if (_events.indexOf(event) === -1) {
      _on(event, listener);
    } else {
      _listeners.on(event, listener);
    }
    return _chart;
  };

  _chart._invokeVegaSpecListener = function (spec) {
    _listeners.vegaSpec(_chart, spec);
  };

  _chart.legendOpen = function (_) {
    if (!arguments.length) {
      return _legendOpen;
    }
    _legendOpen = _;
    return _chart;
  };

  _chart.popupDisplayable = function (displayable) {
    _popupDisplayable = Boolean(displayable);
  };

  _chart.x = function (x) {
    if (!arguments.length) {
      return _x;
    }
    _x = x;
    return _chart;
  };

  _chart.y = function (_) {
    if (!arguments.length) {
      return _y;
    }
    _y = _;
    return _chart;
  };

  _chart.xLatLngBnds = function (_) {
    if (!arguments.length) {
      return _xLatLngBnds;
    }
    _xLatLngBnds = _;
    return chart;
  };

  _chart.yLatLngBnds = function (_) {
    if (!arguments.length) {
      return _yLatLngBnds;
    }
    _yLatLngBnds = _;
    return chart;
  };

  _chart._resetRenderBounds = function () {
    _renderBoundsMap = {};
  };

  _chart._resetLayers = function () {
    _layers = [];
    _layerNames = {};
  };

  _chart.pushLayer = function (layerName, layer) {
    if (_layerNames[layerName]) {
      return;
    } else if (!layerName.match(/^\w+$/)) {
      throw new Error("A layer name can only have alpha numeric characters (A-Z, a-z, 0-9, or _)");
    }

    if (
    // pointmap prioritized color hack
    layer.getState().mark === "point" && layerName !== "backendScatter" && layer.getState().encoding.color.prioritizedColor && layer.getState().encoding.color.prioritizedColor.length > 0) {
      for (var i = 0; i < layer.getState().encoding.color.prioritizedColor.length; i++) {
        // Prevent adding the same layer multiple times
        if (_layerNames[layerName + "_z" + i * 2] || _layerNames[layerName + "_z" + (i * 2 + 1)]) {
          return;
        } else if (!(layerName + "_z" + i * 2).match(/^\w+$/) || !(layerName + "_z" + (i * 2 + 1)).match(/^\w+$/)) {
          throw new Error("A layer name can only have alpha numeric characters (A-Z, a-z, 0-9, or _)");
        }

        // Currently only one priority color is supported for Pointmap, so we create two z indexed layers, z_0 and z_1 for it
        // Not clear how multiple priority color would be supported later, so making an assumption here to be be z_2 and z_3 for second priority color and so on
        _layers.push(layerName + "_z" + i * 2);
        _layerNames[layerName + "_z" + i * 2] = layer;
        _layers.push(layerName + "_z" + (i * 2 + 1));
        _layerNames[layerName + "_z" + (i * 2 + 1)] = layer;
      }
    } else {
      _layers.push(layerName);
      _layerNames[layerName] = layer;
    }

    return _chart;
  };

  _chart.popLayer = function () {
    var layerName = _layers.pop();
    var layer = _layerNames[layerName];
    delete _layerNames[layerName];
    return layer;
  };

  _chart.popAllLayers = function () {
    var poppedLayers = _layers.map(function (layerName) {
      var layer = _layerNames[layerName];
      delete _layerNames[layerName];
      return layer;
    });
    _layers = [];
    return poppedLayers;
  };

  _chart.getLayer = function (layerName) {
    return _layerNames[layerName];
  };

  _chart.getAllLayers = function () {
    return Object.keys(_layerNames).map(function (k) {
      return _layerNames[k];
    });
  };

  _chart.getLayerAt = function (idx) {
    var layerName = _layers[idx];
    return _layerNames[layerName];
  };

  _chart.getLayers = function () {
    return _layers.map(function (layerName) {
      return _layerNames[layerName];
    });
  };

  _chart.getLayerNames = function () {
    return _layers;
  };

  _chart.xRangeFilter = function (filter) {
    for (var layerName in _layerNames) {
      var _layer2 = _layerNames[layerName];
      // layer.xDim() & layer.xDim().filter(filter)
    }
  };

  _chart.yRangeFilter = function (filter) {
    for (var layerName in _layerNames) {
      var _layer3 = _layerNames[layerName];
      // layer.yDim() && layer.yDim().filter(filter)
    }
  };

  _chart.clearLayerFilters = function () {
    for (var layerName in _layerNames) {
      var _layer4 = _layerNames[layerName];
      if (typeof _layer4.filterAll === "function") {
        _layer4.filterAll(_chart);
      }
    }
  };

  _chart.destroyChart = function () {
    _legend.setState({});

    _chart.filterAll();
    for (var layerName in _layerNames) {
      var _layer5 = _layerNames[layerName];
      _layer5.destroyLayer(_chart);
    }

    if (_chart.map()) {
      _chart.map().remove();
    }
  };

  _chart.con = function (_) {
    if (!arguments.length) {
      return _con;
    }
    _con = _;
    return _chart;
  };

  _chart.useGeoTypes = function (geoTypesEnabled) {
    _chart._useGeoTypes = geoTypesEnabled;
    return _chart;
  };

  // TODO(croot): pixel ratio should probably be configured on the backend
  // rather than here to deal with scenarios where data is used directly
  // in pixel-space.
  _chart.usePixelRatio = function (usePixelRatio) {
    if (!arguments.length) {
      return _usePixelRatio;
    }

    _usePixelRatio = Boolean(usePixelRatio);
    if (_usePixelRatio) {
      _pixelRatio = window.devicePixelRatio || 1;
    } else {
      _pixelRatio = 1;
    }

    return _chart;
  };

  _chart._getPixelRatio = function () {
    return _pixelRatio;
  };

  _chart.setSample = function () {
    _layers.forEach(function (layerName) {
      var layer = _layerNames[layerName];
      if (layer && typeof layer.setSample === "function") {
        layer.setSample();
      }
    });
  };

  _chart.shiftToZoom = function (shiftToZoom) {
    if (shiftToZoom !== undefined) {
      _shiftToZoom = shiftToZoom;
    }
    return _shiftToZoom;
  };

  function getCountFromBoundingBox(chart, _layer) {
    var mapBounds = chart.map().getBounds();
    var geoTable = _layer.getState().encoding.geoTable;
    var geoCol = _layer.getState().encoding.geocol;

    var preflightQuery = "SELECT COUNT(*) AS n FROM " + geoTable + " WHERE ST_XMax(" + geoTable + "." + geoCol + ") >= " + mapBounds._sw.lng + " AND ST_XMin(" + geoTable + "." + geoCol + ") <= " + mapBounds._ne.lng + " AND ST_YMax(" + geoTable + "." + geoCol + ") >= " + mapBounds._sw.lat + " AND ST_YMin(" + geoTable + "." + geoCol + ") <= " + mapBounds._ne.lat;

    return chart.con().queryAsync(preflightQuery, {});
  }

  function handleRenderVega(callback) {
    var bounds = _chart.getDataRenderBounds();
    _chart._updateXAndYScales(bounds);

    _chart._vegaSpec = genLayeredVega(_chart);
    _chart.con().renderVegaAsync(_chart.__dcFlag__, JSON.stringify(_chart._vegaSpec), {}).then(function (result) {
      if (!window || !window.paused) {
        _renderBoundsMap[result.nonce] = bounds;
      }
      callback(null, result);
    }).catch(function (error) {
      callback(error);
    });
  }

  _chart.setDataAsync(function (group, callback) {
    var layers = _chart.getAllLayers();
    var polyLayers = layers.length ? _.filter(layers, function (layer) {
      return layer.getState().mark.type === "poly";
    }) : null;
    if (polyLayers && polyLayers.length) {
      // add bboxCount to poly layers run sample

      var countsPromise = polyLayers.map(function (currentLayer) {
        return getCountFromBoundingBox(_chart, currentLayer);
      });

      Promise.all(countsPromise).then(function (resArr) {
        resArr.forEach(function (res, index) {
          var count = res && res[0] && res[0].n;
          var currentLayer = polyLayers[index];
          currentLayer.setState(_extends({}, currentLayer.getState(), {
            bboxCount: count
          }));
        });
        handleRenderVega(callback);
      });
    } else {
      handleRenderVega(callback);
    }
  });

  _chart.data(function (group) {
    if (_chart.dataCache !== null) {
      return _chart.dataCache;
    }

    var bounds = _chart.getDataRenderBounds();
    _chart._updateXAndYScales(bounds);

    _chart._vegaSpec = genLayeredVega(_chart, group, (0, _coreAsync.lastFilteredSize)(group.getCrossfilterId()));

    var result = _chart.con().renderVega(_chart.__dcFlag__, JSON.stringify(_chart._vegaSpec));

    _renderBoundsMap[result.nonce] = bounds;
    return result;
  });

  _chart._getXScaleName = function () {
    return _xScaleName;
  };

  _chart._getYScaleName = function () {
    return _yScaleName;
  };

  _chart._updateXAndYScales = function (renderBounds) {
    // renderBounds should be in this order - top left, top-right, bottom-right, bottom-left
    var useRenderBounds = renderBounds && renderBounds.length === 4 && renderBounds[0] instanceof Array && renderBounds[0].length === 2;

    if (_x === null) {
      _x = _d2.default.scale.linear();
    }

    if (_y === null) {
      _y = _d2.default.scale.linear();
    }

    // if _chart.useLonLat() is not true, the chart bounds have already been projected into mercator space
    // TODO(adb): could probably collape this into line 353
    if (_chart._useGeoTypes && typeof _chart.useLonLat === "function" && _chart.useLonLat()) {
      _xLatLngBnds = [renderBounds[0][0], renderBounds[1][0]];
      _yLatLngBnds = [renderBounds[2][1], renderBounds[0][1]];
    }

    if (useRenderBounds) {
      if (typeof _chart.useLonLat === "function" && _chart.useLonLat()) {
        _x.domain([_chart.conv4326To900913X(renderBounds[0][0]), _chart.conv4326To900913X(renderBounds[1][0])]);
        _y.domain([_chart.conv4326To900913Y(renderBounds[2][1]), _chart.conv4326To900913Y(renderBounds[0][1])]);
      } else {
        _x.domain([renderBounds[0][0], renderBounds[1][0]]);
        _y.domain([renderBounds[2][1], renderBounds[0][1]]);
      }
    } else {
      var layers = getLayers();
      var xRanges = [];
      var yRanges = [];

      for (layer in layers) {
        var xDim = layer.xDim(),
            yDim = layer.yDim(),
            viewBoxDim = layer.viewBoxDim();
        if (xDim) {
          var range = xDim.getFilter();
          if (range !== null) {
            xRanges.push(range);
          }
        }
        if (yDim) {
          var range = yDim.getFilter();
          if (range !== null) {
            yRanges.push(range);
          }
        }
      }

      if (xRanges.length) {
        var xRange = xRanges.reduce(function (prevVal, currVal) {
          return [Math.min(prevVal[0], currVal[0]), Math.max(prevVal[1], currVal[1])];
        }, [Number.MAX_VALUE, -Number.MAX_VALUE]);

        if (typeof _chart.useLonLat === "function" && _chart.useLonLat()) {
          _x.domain([_chart.conv4326To900913X(xRange[0]), _chart.conv4326To900913X(xRange[1])]);
        } else {
          _x.domain(xRange);
        }
      } else {
        _x.domain([0.001, 0.999]);
      }

      if (yRanges.length) {
        var yRange = yRanges.reduce(function (prevVal, currVal) {
          return [Math.min(prevVal[0], currVal[0]), Math.max(prevVal[1], currVal[1])];
        }, [Number.MAX_VALUE, -Number.MAX_VALUE]);

        if (typeof _chart.useLonLat === "function" && _chart.useLonLat()) {
          _y.domain([_chart.conv4326To900913X(yRange[0]), _chart.conv4326To900913X(yRange[1])]);
        } else {
          _y.domain(yRange);
        }
      } else {
        _y.domain([0.001, 0.999]);
      }
    }
  };

  _chart._determineScaleType = function (scale) {
    var scaleType = null;
    if (scale.rangeBand !== undefined) {
      return "ordinal";
    }
    if (scale.exponent !== undefined) {
      return "power";
    }
    if (scale.base !== undefined) {
      return "log";
    }
    if (scale.quantiles !== undefined) {
      return "quantiles";
    }
    if (scale.interpolate !== undefined) {
      return "linear";
    }
    return "quantize";
  };

  function removeOverlay(overlay) {
    _chart._removeOverlay(overlay);
  }

  // We need to default to redraw = true here since base-mixin (in _chart.render())
  //  calls this, w/o any interface to set the redraw boolean, and for
  //  backendScatter, we need to take the image from the data and swap it out.
  _chart._doRender = function (data, redraw, doNotForceData) {
    if (!data && Boolean(!doNotForceData)) {
      data = _chart.data();
    }

    var selectedLayer = null;
    if (data.vega_metadata) {
      var vega_metadata = JSON.parse(data.vega_metadata);
      for (var layerName in _layerNames) {
        if (typeof _layerNames[layerName]._updateFromMetadata === "function") {
          selectedLayer = _layerNames[layerName].getState();
          _layerNames[layerName]._updateFromMetadata(vega_metadata, layerName);
        }
      }
    }

    var state = (0, _stackedLegend.getLegendStateFromChart)(_chart, useMap, selectedLayer);
    _legend.setState(state);

    if (_chart.isLoaded()) {
      if (Object.keys(data).length) {
        _chart._setOverlay({
          data: data.image,
          bounds: _renderBoundsMap[data.nonce],
          nonce: data.nonce,
          browser: browser,
          redraw: Boolean(redraw)
        });
        _hasBeenRendered = true;
      } else {
        _chart._setOverlay({
          data: null,
          bounds: null,
          nonce: null,
          browser: browser,
          redraw: Boolean(redraw)
        });
      }
    } else {
      _chart.map().once("style.load", function () {
        _chart._doRender(data, redraw, doNotForceData);
      });
    }
  };

  _chart._doRedraw = function (data) {
    _chart._doRender(data || null, true);
  };

  _chart.minPopupShapeBoundsArea = function (minPopupShapeBoundsArea) {
    if (!arguments.length) {
      return _minPopupShapeBoundsArea;
    }
    _minPopupShapeBoundsArea = minPopupShapeBoundsArea;
    return _chart;
  };

  _chart.popupSearchRadius = function (popupSearchRadius) {
    if (!arguments.length) {
      return _popupSearchRadius;
    }
    _popupSearchRadius = popupSearchRadius;
    return _chart;
  };

  _chart.getClosestResult = function getClosestResult(point, callback) {
    var height = typeof _chart.effectiveHeight === "function" ? _chart.effectiveHeight() : _chart.height();
    var pixelRatio = _chart._getPixelRatio() || 1;
    var pixel = new TPixel({
      x: Math.round(point.x * pixelRatio),
      y: Math.round((height - point.y) * pixelRatio)
    });

    if (!point) {
      return;
    }

    var cnt = 0;
    var layerObj = {};
    _layers.forEach(function (layerName) {
      var layer = _layerNames[layerName];
      if (layer.getPopupAndRenderColumns && layer.hasPopupColumns && layer.hasPopupColumns()) {
        layerObj[layerName] = layer.getPopupAndRenderColumns(_chart);
        ++cnt;
      }
    });

    // TODO best to fail, skip cb, or call cb wo args?
    if (!cnt) {
      return;
    }

    _chart.con().getResultRowForPixelAsync(_chart.__dcFlag__, pixel, layerObj, Math.ceil(_popupSearchRadius * pixelRatio)).then(function (results) {
      return callback(results[0]);
    }).catch(function (error) {
      throw new Error("getResultRowForPixel failed with message: " + error.error_msg);
    });
  };

  _chart.measureValue = function (value, key) {
    var customFormatter = _chart.valueFormatter();
    // hack to undo the popup concatenation like "AVG(arrdelay)"
    var keyTrimmed = null;
    if (key) {
      keyTrimmed = key.replace(/.*\((.*)\).*/, "$1");
    }
    return keyTrimmed && customFormatter && customFormatter(value, keyTrimmed) || value;
  };

  _chart.displayPopup = function displayPopup(result, animate) {
    if (!_popupDisplayable || !result || !result.row_set || !result.row_set.length) {
      return;
    }
    if (_chart.select("." + _popupDivClassName).empty()) {
      // only one popup at a time
      var _layer6 = _layerNames[result.vega_table_name];
      if (_layer6 && _layer6.areResultsValidForPopup(result.row_set)) {
        var mapPopup = _chart.root().append("div").attr("class", _popupDivClassName);
        _layer6.displayPopup(_chart, mapPopup, result, _minPopupShapeBoundsArea, animate);
      }
    }
  };

  _chart.hidePopup = function hidePopup(animate) {
    var popupElem = _chart.select("." + _popupDivClassName);
    if (!popupElem.empty()) {
      for (var i = 0; i < _layers.length; ++i) {
        var layerName = _layers[i];
        var _layer7 = _layerNames[layerName];
        if (_layer7) {
          // TODO(croot): can this be improved? I presume only
          // one popup can be shown at a time
          if (animate) {
            _layer7.hidePopup(_chart, function () {
              _chart.select("." + _popupDivClassName).remove();
            });
          } else {
            _chart.select("." + _popupDivClassName).remove();
          }
          break;
        }
      }
    }
  };

  var anchored = _chart.anchor(parent, chartGroup);
  var legend = anchored.root().append("div").attr("class", "legend");
  _legend = new _legendables.Legend(legend.node());

  _legend.on("open", _stackedLegend.handleLegendOpen.bind(_chart));
  _legend.on("lock", _stackedLegend.handleLegendLock.bind(_chart));
  _legend.on("input", _stackedLegend.handleLegendInput.bind(_chart));
  _legend.on("toggle", _stackedLegend.handleLegendToggle.bind(_chart));
  _legend.on("doneRender", _stackedLegend.handleLegendDoneRender.bind(_chart));

  _chart.legend = function (l) {
    return _legend;
  };

  _chart.deleteLayerLegend = function (currentLayerId, deleteLayerId, prevLayerId) {
    if (currentLayerId !== "master") {
      _chart.root().selectAll(".legend").filter(function (d, i) {
        return i === deleteLayerId && prevLayerId === "master" || !(currentLayerId !== deleteLayerId && prevLayerId < deleteLayerId);
      }).remove();
    }
  };

  _chart.destroyChartLegend = function () {
    _chart.root().selectAll(".legend").remove();
  };

  return anchored;
}

function valuesOb(obj) {
  return Object.keys(obj).map(function (key) {
    return obj[key];
  });
}

function genLayeredVega(chart) {
  var pixelRatio = chart._getPixelRatio();
  var width = (typeof chart.effectiveWidth === "function" ? chart.effectiveWidth() : chart.width()) * pixelRatio;
  var height = (typeof chart.effectiveHeight === "function" ? chart.effectiveHeight() : chart.height()) * pixelRatio;

  var data = [];

  var scales = [{
    name: chart._getXScaleName(),
    type: chart._determineScaleType(chart.x()),
    domain: chart.x().domain(),
    range: "width",
    nullValue: -100
  }, {
    name: chart._getYScaleName(),
    type: chart._determineScaleType(chart.y()),
    domain: chart.y().domain(),
    range: "height",
    nullValue: -100
  }];

  // NOTE(adb): When geo types are enabled, vega spatial projections are applied and the scales for the x and y properties are not being used. However, we still need the legacy scaling terms to properly size poly popups on hover, which is why _xLatLngBnds, etc are separate scales
  var projections = [];
  if (chart._useGeoTypes) {
    projections.push({
      name: "mercator_map_projection",
      type: "mercator",
      bounds: {
        x: chart.xLatLngBnds(),
        y: chart.yLatLngBnds()
      }
    });
  }
  var marks = [];

  chart.getLayerNames().forEach(function (layerName) {
    var layerVega = chart.getLayer(layerName).genVega(chart, layerName);

    data.push.apply(data, _toConsumableArray(layerVega.data));
    scales.push.apply(scales, _toConsumableArray(layerVega.scales));
    marks.push.apply(marks, _toConsumableArray(layerVega.marks));
  });

  var vegaSpec = {
    width: Math.round(width),
    height: Math.round(height),
    viewRenderOptions: {
      // BE scatterplot does not use mapbox, and the scatterplot renderer needs to be changed to work with unpremultiplied images
      premultipliedAlpha: chart.getLayerNames().length > 0 && chart.getLayerNames()[0] === "backendScatter"
    },
    data: data,
    scales: scales,
    projections: projections,
    marks: marks
  };

  chart._invokeVegaSpecListener(vegaSpec);

  return vegaSpec;
}

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.getLegendStateFromChart = getLegendStateFromChart;
exports.handleLegendToggle = handleLegendToggle;
exports.handleLegendDoneRender = handleLegendDoneRender;
exports.handleLegendOpen = handleLegendOpen;
exports.handleLegendLock = handleLegendLock;
exports.handleLegendInput = handleLegendInput;
exports.toLegendState = toLegendState;

var _lodash = __webpack_require__(23);

var _ = _interopRequireWildcard(_lodash);

var _utilsVega = __webpack_require__(19);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var hasLegendOpenProp = function hasLegendOpenProp(color) {
  return _typeof(color.legend) === "object" && color.legend.hasOwnProperty("open");
};
var hasLegendLockedProp = function hasLegendLockedProp(color) {
  return _typeof(color.legend) === "object" && color.legend.hasOwnProperty("locked");
};
var hasLegendTitleProp = function hasLegendTitleProp(color) {
  return _typeof(color.legend) === "object" && color.legend.hasOwnProperty("title");
};
var handleColorLegendOpenUndefined = function handleColorLegendOpenUndefined(color) {
  return typeof color.legend.open === "undefined" ? true : color.legend.open;
};
var handleNonStackedOpenState = function handleNonStackedOpenState(state) {
  return state.type === "gradient" ? Object.assign({}, state, { open: true }) : state;
};
var handleNonStackedNullLegend = function handleNonStackedNullLegend(state // used for ["NULL", "NULL"} quantitative legend domain
) {
  return Object.assign({}, state, {
    type: "nominal",
    range: state.range,
    domain: state.domain.slice(1),
    open: true
  });
};

var TOP_PADDING = 56;
var LASSO_TOOL_VERTICAL_SPACE = 120;

function setLegendState(setter) {
  return function setState(state) {
    return _extends({}, state, {
      encoding: _extends({}, state.encoding, {
        color: _extends({}, state.encoding.color, {
          legend: _extends({}, state.encoding.color.legend, setter(state.encoding.color))
        })
      })
    });
  };
}

function setColorState(setter) {
  return function setState(state) {
    return _extends({}, state, {
      encoding: _extends({}, state.encoding, {
        color: _extends({}, state.encoding.color, setter(state.encoding.color))
      })
    });
  };
}

function setColorScaleDomain_v2(domain) {
  return function setState(state) {
    return _extends({}, state, {
      encoding: _extends({}, state.encoding, {
        color: _extends({}, state.encoding.color, {
          scale: _extends({}, state.encoding.color.scale, {
            domain: domain
          })
        })
      })
    });
  };
}

function setColorScaleDomain_v1(domain) {
  return function setState(state) {
    return _extends({}, state, {
      encoding: _extends({}, state.encoding, {
        color: _extends({}, state.encoding.color, {
          domain: domain
        })
      })
    });
  };
}

function getLegendStateFromChart(chart, useMap, selectedLayer) {
  // the getLegendStateFromChart in _doRender gets called from few different options
  // and some of them are calling with all layers in chart.
  // As a result, a legend for each layer is rendered.
  // Thus, we need to remove extra legends here
  var legends = chart.root().selectAll(".legend");
  var layers = chart.getLayerNames();

  if (legends.size() > layers.length && selectedLayer && selectedLayer.currentLayer !== "master") {
    chart.root().selectAll(".legend").filter(function (d, i) {
      return i !== selectedLayer.currentLayer;
    }).remove();
  }

  return toLegendState((0, _utilsVega.getRealLayers)(chart.getLayerNames()).map(function (layerName) {
    var layer = chart.getLayer(layerName);
    var layerState = layer.getState();
    var color = layer.getState().encoding.color;

    if (layers.length > 1 || _.isEqual(selectedLayer, layerState)) {
      if (_typeof(color.scale) === "object" && color.scale.domain === "auto") {
        return _extends({}, color, {
          scale: _extends({}, color.scale, {
            domain: layer.colorDomain()
          })
        });
      } else if (typeof color.scale === "undefined" && color.domain === "auto") {
        return _extends({}, color, {
          domain: layer.colorDomain()
        });
      } else {
        return color;
      }
    } else {
      return color;
    }
  }), chart, useMap);
}

function handleLegendToggle() {
  var _this = this;

  // when chart legend is collapsed, also collapse layer legends
  this.getLayers().forEach(function (l) {
    return l.setState(setLegendState(function (color) {
      return {
        open: !_this.legend().state.open
      };
    }));
  });
  this.legend().setState(_extends({}, this.legend().state, {
    open: !this.legend().state.open
  }));
}

function handleLegendDoneRender() {
  var _this2 = this;

  this.root().classed("horizontal-lasso-tools", function () {
    var legendNode = _this2.root().select(".legendables").node();
    var isHorizontal = legendNode && legendNode.clientHeight > _this2.height() - LASSO_TOOL_VERTICAL_SPACE;

    _this2.root().select(".mapd-draw-button-control-group").style("width", isHorizontal ? legendNode.clientWidth + 2 + "px" : "auto");

    return isHorizontal;
  });
}

function handleLegendOpen() {
  var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

  this.getLayers()[index].setState(setLegendState(function (color) {
    return {
      open: hasLegendOpenProp(color) ? !handleColorLegendOpenUndefined(color) : false
    };
  }));
  this.legend().setState(getLegendStateFromChart(this));
}

function handleLegendLock(_ref) {
  var locked = _ref.locked,
      _ref$index = _ref.index,
      index = _ref$index === undefined ? 0 : _ref$index;

  var layer = this.getLayers()[index];

  layer.setState(setLegendState(function (color) {
    return {
      locked: typeof locked === "undefined" ? true : !locked
    };
  }));

  var _layer$getState = layer.getState(),
      color = _layer$getState.encoding.color;

  var redraw = false;
  if (_typeof(color.scale) === "object") {
    // this if or raster-layer-heatmap-mixin.js
    if (color.legend.locked) {
      var colorDomain = color.scale.domain || layer.colorDomain();
      layer.setState(setColorScaleDomain_v2(colorDomain));
    } else {
      layer.setState(setColorScaleDomain_v2("auto"));
      redraw = true;
    }
  } else if (typeof color.scale === "undefined" && typeof color.domain !== "undefined") {
    if (color.legend.locked && color.domain === "auto") {
      layer.setState(setColorScaleDomain_v1(layer.colorDomain()));
    } else if (!color.legend.locked) {
      layer.setState(setColorScaleDomain_v1("auto"));
      redraw = true;
    }
  }

  if (redraw) {
    this.renderAsync(); // not setting the state for the legend here because it'll happen on the redraw
  } else {
    this.legend().setState(getLegendStateFromChart(this));
  }
}

function handleLegendInput(_ref2) {
  var domain = _ref2.domain,
      _ref2$index = _ref2.index,
      index = _ref2$index === undefined ? 0 : _ref2$index;

  var layer = this.getLayers()[index];
  var scale = layer.getState().encoding.color.scale;


  var legendDomain = this.legend().state.domain || this.legend().state.list[index].domain;
  if (_.difference(domain, legendDomain).length > 0) {
    // automatically lock color legend when min/max input changes
    layer.setState(setLegendState(function (color) {
      return {
        locked: true
      };
    }));
  }

  if ((typeof scale === "undefined" ? "undefined" : _typeof(scale)) === "object") {
    layer.setState(setColorScaleDomain_v2(domain));
  } else {
    layer.setState(setColorState(function () {
      return {
        domain: domain
      };
    }));
  }

  this.legend().setState(getLegendStateFromChart(this));
  this.renderAsync();
}

function legendState(state) {
  var useMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  if (state.type === "ordinal") {
    return {
      type: "nominal",
      title: hasLegendTitleProp(state) ? state.legend.title : "Legend",
      open: hasLegendOpenProp(state) ? state.legend.open : true,
      // When there is Other category (categories besides topN), we show it in the Color Palette in chart editor.
      // We also need to include the Other category in legend. Thus, when there is Other category exist in result
      // where hideOther is false we include Other in domain.
      // For it's color swatch, we have two options:
      // 1. When the Other toggle is enabled, we show color swatch (color defined from color palette in chart editor) for the Other category range,
      // 2. If the Other toggle is disabled, we don't include color swatch for the Other domain
      range: !state.hideOther && state.hasOwnProperty("showOther") && state.showOther === true ? state.range.concat([state.defaultOtherRange]) // When Other is toggled OFF, don't show color swatch in legend
      : state.range,
      domain: state.hideOther ? state.domain : state.domain.concat(["Other"]),
      position: useMap ? "bottom-left" : "top-right"
    };
  } else if (state.type === "quantitative" && state.domain && isNullLegend(state.domain)) {
    // handles quantitative legend for all null color measure column, ["NULL", "NULL"] domain
    return {
      type: "nominal", // show nominal legend with one "NULL" value when all null quantitavie color measure is selected
      title: hasLegendTitleProp(state) ? state.legend.title : "Legend",
      open: hasLegendOpenProp(state) ? state.legend.open : true,
      range: state.range,
      domain: state.domain.slice(1),
      position: useMap ? "bottom-left" : "top-right"
    };
  } else if (state.type === "quantitative") {
    return {
      type: "gradient",
      title: hasLegendTitleProp(state) ? state.legend.title : "Legend",
      locked: hasLegendLockedProp(state) ? state.legend.locked : false,
      open: hasLegendOpenProp(state) ? state.legend.open : true,
      range: state.range,
      domain: state.domain,
      position: "bottom-left"
    };
  } else if (state.type === "quantize") {
    var scale = state.scale;

    return {
      type: "gradient",
      title: hasLegendTitleProp(state) ? state.legend.title : "Legend",
      locked: hasLegendLockedProp(state) ? state.legend.locked : false,
      open: hasLegendOpenProp(state) ? state.legend.open : true,
      range: scale.range,
      domain: scale.domain,
      position: "bottom-left"
    };
  } else {
    return {};
  }
}

function toLegendState() {
  var states = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var chart = arguments[1];
  var useMap = arguments[2];

  if (states.length === 1 && states[0].domain && isNullLegend(states[0].domain)) {
    // handles legend for all null color measure column, ["NULL", "NULL"] domain
    return handleNonStackedNullLegend(states[0], useMap);
  } else if (states.length === 1) {
    return handleNonStackedOpenState(legendState(states[0], useMap));
  } else if (states.length) {
    return {
      type: "stacked",
      list: states.map(legendState),
      open: typeof chart.legendOpen() === "undefined" ? true : chart.legendOpen(),
      maxHeight: chart.height() - TOP_PADDING
    };
  } else {
    return {};
  }
}

function isNullLegend(domain) {
  // only return true if there is more than one "NULL" value
  return domain.reduce(function (cnt, d) {
    return d === "NULL" ? cnt + 1 : cnt;
  }, 0) > 1;
}

/***/ }),
/* 271 */
/***/ (function(module, exports) {

/*eslint-disable no-cond-assign */
module.exports = parse;
module.exports.parse = parse;
module.exports.stringify = stringify;

var numberRegexp = /[-+]?([0-9]*\.[0-9]+|[0-9]+)([eE][-+]?[0-9]+)?/;
// Matches sequences like '100 100' or '100 100 100'.
var tuples = new RegExp('^' + numberRegexp.source + '(\\s' + numberRegexp.source + '){1,}');

/*
 * Parse WKT and return GeoJSON.
 *
 * @param {string} _ A WKT geometry
 * @return {?Object} A GeoJSON geometry object
 */
function parse (input) {
  var parts = input.split(';');
  var _ = parts.pop();
  var srid = (parts.shift() || '').split('=').pop();

  var i = 0;

  function $ (re) {
    var match = _.substring(i).match(re);
    if (!match) return null;
    else {
      i += match[0].length;
      return match[0];
    }
  }

  function crs (obj) {
    if (obj && srid.match(/\d+/)) {
      obj.crs = {
        type: 'name',
        properties: {
          name: 'urn:ogc:def:crs:EPSG::' + srid
        }
      };
    }

    return obj;
  }

  function white () { $(/^\s*/); }

  function multicoords () {
    white();
    var depth = 0;
    var rings = [];
    var stack = [rings];
    var pointer = rings;
    var elem;

    while (elem =
           $(/^(\()/) ||
             $(/^(\))/) ||
               $(/^(,)/) ||
                 $(tuples)) {
      if (elem === '(') {
        stack.push(pointer);
        pointer = [];
        stack[stack.length - 1].push(pointer);
        depth++;
      } else if (elem === ')') {
        // For the case: Polygon(), ...
        if (pointer.length === 0) return null;

        pointer = stack.pop();
        // the stack was empty, input was malformed
        if (!pointer) return null;
        depth--;
        if (depth === 0) break;
      } else if (elem === ',') {
        pointer = [];
        stack[stack.length - 1].push(pointer);
      } else if (!elem.split(/\s/g).some(isNaN)) {
        Array.prototype.push.apply(pointer, elem.split(/\s/g).map(parseFloat));
      } else {
        return null;
      }
      white();
    }

    if (depth !== 0) return null;

    return rings;
  }

  function coords () {
    var list = [];
    var item;
    var pt;
    while (pt =
           $(tuples) ||
             $(/^(,)/)) {
      if (pt === ',') {
        list.push(item);
        item = [];
      } else if (!pt.split(/\s/g).some(isNaN)) {
        if (!item) item = [];
        Array.prototype.push.apply(item, pt.split(/\s/g).map(parseFloat));
      }
      white();
    }

    if (item) list.push(item);
    else return null;

    return list.length ? list : null;
  }

  function point () {
    if (!$(/^(point(\sz)?)/i)) return null;
    white();
    if (!$(/^(\()/)) return null;
    var c = coords();
    if (!c) return null;
    white();
    if (!$(/^(\))/)) return null;
    return {
      type: 'Point',
      coordinates: c[0]
    };
  }

  function multipoint () {
    if (!$(/^(multipoint)/i)) return null;
    white();
    var newCoordsFormat = _
      .substring(_.indexOf('(') + 1, _.length - 1)
      .replace(/\(/g, '')
      .replace(/\)/g, '');
    _ = 'MULTIPOINT (' + newCoordsFormat + ')';
    var c = multicoords();
    if (!c) return null;
    white();
    return {
      type: 'MultiPoint',
      coordinates: c
    };
  }

  function multilinestring () {
    if (!$(/^(multilinestring)/i)) return null;
    white();
    var c = multicoords();
    if (!c) return null;
    white();
    return {
      type: 'MultiLineString',
      coordinates: c
    };
  }

  function linestring () {
    if (!$(/^(linestring(\sz)?)/i)) return null;
    white();
    if (!$(/^(\()/)) return null;
    var c = coords();
    if (!c) return null;
    if (!$(/^(\))/)) return null;
    return {
      type: 'LineString',
      coordinates: c
    };
  }

  function polygon () {
    if (!$(/^(polygon(\sz)?)/i)) return null;
    white();
    var c = multicoords();
    if (!c) return null;
    return {
      type: 'Polygon',
      coordinates: c
    };
  }

  function multipolygon () {
    if (!$(/^(multipolygon)/i)) return null;
    white();
    var c = multicoords();
    if (!c) return null;
    return {
      type: 'MultiPolygon',
      coordinates: c
    };
  }

  function geometrycollection () {
    var geometries = [];
    var geometry;

    if (!$(/^(geometrycollection)/i)) return null;
    white();

    if (!$(/^(\()/)) return null;
    while (geometry = root()) {
      geometries.push(geometry);
      white();
      $(/^(,)/);
      white();
    }
    if (!$(/^(\))/)) return null;

    return {
      type: 'GeometryCollection',
      geometries: geometries
    };
  }

  function root () {
    return point() ||
      linestring() ||
      polygon() ||
      multipoint() ||
      multilinestring() ||
      multipolygon() ||
      geometrycollection();
  }

  return crs(root());
}

/**
 * Stringifies a GeoJSON object into WKT
 */
function stringify (gj) {
  if (gj.type === 'Feature') {
    gj = gj.geometry;
  }

  function pairWKT (c) {
    return c.join(' ');
  }

  function ringWKT (r) {
    return r.map(pairWKT).join(', ');
  }

  function ringsWKT (r) {
    return r.map(ringWKT).map(wrapParens).join(', ');
  }

  function multiRingsWKT (r) {
    return r.map(ringsWKT).map(wrapParens).join(', ');
  }

  function wrapParens (s) { return '(' + s + ')'; }

  switch (gj.type) {
    case 'Point':
      return 'POINT (' + pairWKT(gj.coordinates) + ')';
    case 'LineString':
      return 'LINESTRING (' + ringWKT(gj.coordinates) + ')';
    case 'Polygon':
      return 'POLYGON (' + ringsWKT(gj.coordinates) + ')';
    case 'MultiPoint':
      return 'MULTIPOINT (' + ringWKT(gj.coordinates) + ')';
    case 'MultiPolygon':
      return 'MULTIPOLYGON (' + multiRingsWKT(gj.coordinates) + ')';
    case 'MultiLineString':
      return 'MULTILINESTRING (' + ringsWKT(gj.coordinates) + ')';
    case 'GeometryCollection':
      return 'GEOMETRYCOLLECTION (' + gj.geometries.map(stringify).join(', ') + ')';
    default:
      throw new Error('stringify requires a valid GeoJSON Feature or geometry object as input');
  }
}


/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = bindEventHandlers;

var _coreAsync = __webpack_require__(5);

var _mapboxPortedFunctions = __webpack_require__(273);

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* istanbul ignore next */
function bindAll(funcNames, thisArg) {
  funcNames.forEach(function (funcName) {
    if (!thisArg[funcName]) {
      return;
    }
    thisArg[funcName] = thisArg[funcName].bind(thisArg);
  });
}

/* istanbul ignore next */
function isInChart(chart, container, e, mousePos) {
  var width = chart.effectiveWidth();
  var height = chart.effectiveHeight();
  var margins = chart.margins();
  var left = margins.left;
  var top = margins.top;
  var rect = container.getBoundingClientRect();

  e = e.touches ? e.touches[0] : e;

  var diffX = e.clientX - left - rect.left - container.clientLeft;
  var diffY = e.clientY - top - rect.top - container.clientTop;

  if (mousePos) {
    mousePos.x = diffX;
    mousePos.y = diffY;
  }

  return diffX >= 0 && diffX < width && diffY >= 0 && diffY < height;
}

/* istanbul ignore next */

var BaseHandler = function () {
  function BaseHandler(chart, container, dataBounds, dataScale, dataOffset, filterDimensionCB, chartRedrawCB, mapboxglModule) {
    _classCallCheck(this, BaseHandler);

    this._chart = chart;
    this._map = chart.map();
    this._container = container;
    this._currDataBounds = dataBounds;
    this._scale = dataScale;
    this._offset = dataOffset;
    this._filterDimensionCB = filterDimensionCB;
    this._chartRedrawCB = chartRedrawCB;
    this._mapboxglModule = mapboxglModule;
  }

  _createClass(BaseHandler, [{
    key: "isEnabled",
    value: function isEnabled() {
      return Boolean(this._enabled);
    }
  }, {
    key: "isActive",
    value: function isActive() {
      return Boolean(this._active);
    }
  }, {
    key: "enable",
    value: function enable() {
      if (this.isEnabled()) {
        return;
      }

      this._enable();
      this._enabled = true;
    }
  }, {
    key: "disable",
    value: function disable() {
      if (!this.isEnabled()) {
        return;
      }

      this._disable();
      this._enabled = false;
    }
  }, {
    key: "_fireEvent",
    value: function _fireEvent(type, e, eventMetaData) {
      if (!eventMetaData) {
        eventMetaData = {};
      }
      eventMetaData.originalEvent = e;

      return this._map.fire(type, eventMetaData);
    }
  }]);

  return BaseHandler;
}();

/* istanbul ignore next */


function testProp(props, docStyle) {
  for (var i = 0; i < props.length; i = i + 1) {
    if (props[i] in docStyle) {
      return props[i];
    }
  }
}

/* istanbul ignore next */
function createHTMLElement(tagName, className, container) {
  var el = document.createElement(tagName);
  if (className) {
    el.className = className;
  }
  if (container) {
    container.appendChild(el);
  }
  return el;
}

/* istanbul ignore next */

var BoxZoomHandler = function (_BaseHandler) {
  _inherits(BoxZoomHandler, _BaseHandler);

  function BoxZoomHandler(chart, container, dataBounds, dataScale, dataOffset, filterDimensionsCB, chartRedrawCB, mapboxglModule) {
    _classCallCheck(this, BoxZoomHandler);

    var _this = _possibleConstructorReturn(this, (BoxZoomHandler.__proto__ || Object.getPrototypeOf(BoxZoomHandler)).call(this, chart, container, dataBounds, dataScale, dataOffset, filterDimensionsCB, chartRedrawCB, mapboxglModule));

    _this._startBoxZoomPos = null;
    _this._boxZoomBox = null;
    var docStyle = document.documentElement.style;
    _this._selectProp = testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"], docStyle);
    _this._transformProp = testProp(["transform", "WebkitTransform"], docStyle);

    bindAll(["onBoxZoom", "onMouseMove", "onMouseUp", "onKeyDown"], _this);
    return _this;
  }

  _createClass(BoxZoomHandler, [{
    key: "_enable",
    value: function _enable() {
      this._container.addEventListener("mousedown", this.onBoxZoom);
    }
  }, {
    key: "_disable",
    value: function _disable() {
      if (this._active) {
        this._finish();
        this._fireEvent("boxzoomcancel", {});
      }
      this._container.removeEventListener("mousedown", this.onBoxZoom);
    }
  }, {
    key: "_enableDrag",
    value: function _enableDrag() {
      if (this._selectProp) {
        document.documentElement.style[this._selectProp] = this._userSelect;
      }
    }
  }, {
    key: "_disableDrag",
    value: function _disableDrag() {
      if (this._selectProp) {
        this._userSelect = document.documentElement.style[this._selectProp];
        document.documentElement.style[this._selectProp] = "none";
      }
    }
  }, {
    key: "onBoxZoom",
    value: function onBoxZoom(e) {
      // make sure the mouse position is in the
      // chart
      var pos = new this._mapboxglModule.Point(0, 0);
      if (!isInChart(this._chart, this._container, e, pos)) {
        return;
      }

      if (!(e.shiftKey && e.button === 0)) {
        return;
      }

      document.addEventListener("mousemove", this.onMouseMove, false);
      document.addEventListener("keydown", this.onKeyDown, false);
      document.addEventListener("mouseup", this.onMouseUp, false);

      this._disableDrag();

      this._startBoxZoomPos = pos;
      this._active = true;
    }
  }, {
    key: "onMouseMove",
    value: function onMouseMove(e) {
      var p0 = this._startBoxZoomPos;
      var p1 = new this._mapboxglModule.Point(0, 0);

      if (!isInChart(this._chart, this._container, e, p1) && !this._active) {
        return;
      }

      if (!this._boxZoomBox) {
        var rootNode = this._chart.root().node();
        this._boxZoomBox = createHTMLElement("div", "mapboxgl-boxzoom", rootNode);
        rootNode.classList.add("mapboxgl-crosshair");
        this._fireEvent("boxzoomstart", e);
      }

      var minX = Math.min(p0.x, p1.x);
      var maxX = Math.max(p0.x, p1.x);
      var minY = Math.min(p0.y, p1.y);
      var maxY = Math.max(p0.y, p1.y);

      var margins = this._chart.margins();

      this._boxZoomBox.style[this._transformProp] = "translate(" + (minX + margins.left) + "px," + (minY + margins.top) + "px)";
      this._boxZoomBox.style.width = maxX - minX + "px";
      this._boxZoomBox.style.height = maxY - minY + "px";
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp(e) {
      var _this2 = this;

      if (e.button !== 0) {
        return;
      }

      var p0 = this._startBoxZoomPos;
      var p1 = new this._mapboxglModule.Point(0, 0);
      if (!isInChart(this._chart, this._container, e, p1) && !this._active) {
        return;
      }

      this._finish();

      if (p0.x === p1.x && p0.y === p1.y) {
        this._fireEvent("boxzoomcancel", e);
      } else {
        var startPos = this._chart.unproject(p0);
        var endPos = this._chart.unproject(p1);

        var xmin = Math.min(startPos.x, endPos.x);
        var xmax = Math.max(startPos.x, endPos.x);

        var ymin = Math.min(startPos.y, endPos.y);
        var ymax = Math.max(startPos.y, endPos.y);

        var bounds = this._chart._fitToMaxBounds([[xmin, ymin], [xmax, ymax]], true);
        xmin = bounds[0][0];
        xmax = bounds[1][0];
        ymin = bounds[0][1];
        ymax = bounds[1][1];

        this._fireEvent("movestart", e);
        this._fireEvent("zoomstart", e);

        var startminx = this._currDataBounds[0][0];
        var startmaxx = this._currDataBounds[0][1];
        var endminx = xmin;
        var endmaxx = xmax;

        var startminy = this._currDataBounds[1][0];
        var startmaxy = this._currDataBounds[1][1];
        var endminy = ymin;
        var endmaxy = ymax;

        var diffminx = endminx - startminx;
        var diffmaxx = endmaxx - startmaxx;
        var diffminy = endminy - startminy;
        var diffmaxy = endmaxy - startmaxy;

        var duration = 500;
        this._active = true;

        var ease = (0, _mapboxPortedFunctions.bezier)(0.25, 0.1, 0.25, 1);

        var abortFunc = (0, _mapboxPortedFunctions.timed)(function (t) {
          _this2._perFrameFunc(e, ease(t), startminx, diffminx, startmaxx, diffmaxx, startminy, diffminy, startmaxy, diffmaxy);
          if (t === 1) {
            _this2._boxZoomFinished(e, xmin, xmax, ymin, ymax);
          }
        }, duration);
      }
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(e) {
      if (e.keyCode === 27) {
        this._finish();
        this._fireEvent("boxzoomcancel", e);
      }
    }
  }, {
    key: "_boxZoomFinished",
    value: function _boxZoomFinished(e, xmin, xmax, ymin, ymax) {
      this._fireEvent("zoomend", e);
      this._fireEvent("moveend", e);

      this._filterDimensionCB([xmin, xmax], [ymin, ymax]);

      var bounds = [[xmin, ymax], [xmax, ymax], [xmax, ymin], [xmin, ymin]];

      (0, _coreAsync.redrawAllAsync)(this._chart.chartGroup());

      this._active = false;
      this._fireEvent("boxzoomend", e, {
        boxZoomBounds: bounds
      });
    }
  }, {
    key: "_perFrameFunc",
    value: function _perFrameFunc(e, t, startminx, diffminx, startmaxx, diffmaxx, startminy, diffminy, startmaxy, diffmaxy) {
      var xrange = [startminx + t * diffminx, startmaxx + t * diffmaxx];

      var yrange = [startminy + t * diffminy, startmaxy + t * diffmaxy];

      var xDiff = xrange[1] - xrange[0];
      var yDiff = yrange[1] - yrange[0];
      var xBoundsDiff = this._currDataBounds[0][1] - this._currDataBounds[0][0];
      var yBoundsDiff = this._currDataBounds[1][1] - this._currDataBounds[1][0];
      var xBoundsScale = xDiff / xBoundsDiff;
      var yBoundsScale = yDiff / yBoundsDiff;

      this._scale[0] = xBoundsScale;
      this._scale[1] = yBoundsScale;
      this._offset[0] = (xrange[0] - this._currDataBounds[0][0]) / xBoundsDiff;
      this._offset[1] = (yrange[0] - this._currDataBounds[1][0]) / yBoundsDiff;

      this._filterDimensionCB(xrange, yrange);

      this._chart._updateXAndYScales(this._chart.getDataRenderBounds());
      this._chartRedrawCB();

      this._fireEvent("move", e);
    }
  }, {
    key: "_finish",
    value: function _finish() {
      this._active = false;

      document.removeEventListener("mousemove", this.onMouseMove, false);
      document.removeEventListener("keydown", this.onKeyDown, false);
      document.removeEventListener("mouseup", this.onMouseUp, false);

      var rootNode = this._chart.root().node();
      rootNode.classList.remove("mapboxgl-crosshair");

      if (this._boxZoomBox) {
        this._boxZoomBox.parentNode.removeChild(this._boxZoomBox);
        this._boxZoomBox = null;
      }

      this._enableDrag();
    }
  }]);

  return BoxZoomHandler;
}(BaseHandler);

/* istanbul ignore next */


var ScrollZoomHandler = function (_BaseHandler2) {
  _inherits(ScrollZoomHandler, _BaseHandler2);

  function ScrollZoomHandler(chart, container, dataBounds, dataScale, dataOffset, filterDimensionsCB, chartRedrawCB, mapboxglModule, browser) {
    _classCallCheck(this, ScrollZoomHandler);

    var _this3 = _possibleConstructorReturn(this, (ScrollZoomHandler.__proto__ || Object.getPrototypeOf(ScrollZoomHandler)).call(this, chart, container, dataBounds, dataScale, dataOffset, filterDimensionsCB, chartRedrawCB, mapboxglModule));

    _this3._startWheelPos = null;
    _this3._wheelType = null;
    _this3._lastWheelVal = 0;
    _this3._singularWheelTimeout = null;
    _this3._wheelTimeout = null;
    _this3._browser = browser;

    bindAll(["_onSingularWheelTimeout", "_onWheelTimeout", "onWheel"], _this3);
    return _this3;
  }

  _createClass(ScrollZoomHandler, [{
    key: "_onSingularWheelTimeout",
    value: function _onSingularWheelTimeout() {
      this._wheelType = "wheel";
      this._wheelZoom(true, -this._lastWheelVal);
    }
  }, {
    key: "_onWheelTimeout",
    value: function _onWheelTimeout() {
      this._wheelZoom(true, -this._lastWheelVal);
    }

    // enable() {
    //   super.enable()
    //   console.log(`CROOT - scrollZoom enable ${this._enabled} ${this.isEnabled()}`)
    //   console.trace()
    // }

    // disable() {
    //   super.disable()
    //   console.log(`CROOT - scrollZoom disable ${this._enabled} ${this.isEnabled()}`)
    //   console.trace()
    // }

  }, {
    key: "_enable",
    value: function _enable() {
      this._container.addEventListener("wheel", this.onWheel);
      this._container.addEventListener("mousewheel", this.onWheel);
    }
  }, {
    key: "_disable",
    value: function _disable() {
      this._container.removeEventListener("wheel", this.onWheel);
      this._container.removeEventListener("mousewheel", this.onWheel);
    }
  }, {
    key: "onWheel",
    value: function onWheel(e) {
      var value = 0;

      // make sure the mouse position is in the
      // chart
      var pos = new this._mapboxglModule.Point(0, 0);
      if (!isInChart(this._chart, this._container, e, pos)) {
        return;
      }

      if (e.type === "wheel") {
        // Pressing the shift key causes some mouse wheels to scroll horizontally.
        // This ensures we capture the scroll difference regardless of direction
        value = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY;
        // Firefox doubles the values on retina screens...
        if (this._browser.isFirefox && e.deltaMode === window.WheelEvent.DOM_DELTA_PIXEL) {
          value = value / (window.devicePixelRatio || 1);
        }

        if (e.deltaMode === window.WheelEvent.DOM_DELTA_LINE) {
          value = value * 40;
        }
      } else if (e.type === "mousewheel") {
        value = -(Math.abs(e.wheelDeltaX) > Math.abs(e.wheelDeltaY) ? e.wheelDeltaX : e.wheelDeltaY);
        if (this._browser.isSafari) {
          value = value / 3;
        }
      }

      var now = Date.now();
      var timeDelta = now - (this._time || 0);

      this._startWheelPos = pos;
      this._time = now;

      if (value !== 0 && value % 4.000244140625 === 0) {
        // This one is definitely a mouse wheel event.
        this._wheelType = "wheel";

        // Normalize this value to match trackpad.
        value = Math.floor(value / 4);
      } else if (value !== 0 && Math.abs(value) < 4) {
        // This one is definitely a trackpad event because it is so small.
        this._wheelType = "trackpad";
      } else if (timeDelta > 400) {
        // This is likely a new scroll action.
        this._wheelType = null;
        this._lastWheelVal = value;

        // Start a timeout in case this was a singular event, and dely it by up to 40ms.
        this._singularWheelTimeout = setTimeout(this._onSingularWheelTimeout, 40);
      } else if (!this._wheelType) {
        // This is a repeating event, but we don"t know the type of event just yet.
        // If the delta per time is small, we assume it"s a fast trackpad; otherwise we switch into wheel mode.
        this._wheelType = Math.abs(timeDelta * value) < 200 ? "trackpad" : "wheel";
      }

      // Slow down zoom if shift key is held for more precise zooming
      if (e.shiftKey && value) {
        value = value / 4;
      }

      // Only fire the callback if we actually know what type of scrolling device the user uses.
      if (this._wheelType) {
        // Make sure our delayed event isn"t fired again, because we accumulate
        // the previous event (which was less than 40ms ago) into this event.
        if (this._singularWheelTimeout) {
          clearTimeout(this._singularWheelTimeout);
          this._singularWheelTimeout = null;
          value = value + this._lastWheelVal;
        }

        this._lastWheelVal = value;

        if (this._wheelTimeout) {
          clearTimeout(this._wheelTimeout);
          this._wheelTimeout = null;
        }

        // Start a timeout to do a full re-render when the scrolling event
        // is finished. Set it at an arbitrary timeout - 50ms
        this._wheelTimeout = setTimeout(this._onWheelTimeout, 50);

        this._wheelZoom(false, -value, e);
      }

      e.preventDefault();
    }
  }, {
    key: "_wheelZoom",
    value: function _wheelZoom(doFullRender, delta, e) {
      if (this._chart.shiftToZoom() && (!e || !e.shiftKey)) {
        return;
      }

      if (!doFullRender && delta === 0 || !this._chart.elasticX() || !this._chart.elasticY()) {
        return;
      }

      if (delta !== 0) {
        // Scale by sigmoid of scroll wheel delta.
        var scale = 2 / (1 + Math.exp(-Math.abs(delta / 100)));
        if (delta < 0 && scale !== 0) {
          scale = 1 / scale;
        }

        scale = 1 / scale;

        var xRange = this._chart.xRange();
        var yRange = this._chart.yRange();

        if (xRange === null) {
          xRange = [0, 0];
        }

        if (yRange === null) {
          yRange = [0, 0];
        }

        var wheelData = this._chart.unproject(this._startWheelPos);

        var xDiff = scale * (xRange[1] - xRange[0]);
        var yDiff = scale * (yRange[1] - yRange[0]);

        // we want to keep wheelData where it is in pixel space,
        // so we need to extrapolate from there to get the data bounds
        // of the window

        // NOTE: the following is currently only designed
        // to work with linear scales.

        // TODO(croot): come up with a generic extrapolation
        // technique for any scale.

        var width = this._chart.effectiveWidth();
        var height = this._chart.effectiveHeight();

        var xmin = wheelData.x - xDiff * (this._startWheelPos.x / width);
        var xmax = xmin + xDiff;

        var ymin = wheelData.y - yDiff * ((height - this._startWheelPos.y - 1) / height);
        var ymax = ymin + yDiff;

        var bounds = this._chart._fitToMaxBounds([[xmin, ymin], [xmax, ymax]], true);
        xmin = bounds[0][0];
        ymin = bounds[0][1];
        xmax = bounds[1][0];
        ymax = bounds[1][1];

        xDiff = xmax - xmin;
        yDiff = ymax - ymin;

        var xBoundsDiff = this._currDataBounds[0][1] - this._currDataBounds[0][0];
        var yBoundsDiff = this._currDataBounds[1][1] - this._currDataBounds[1][0];
        var xBoundsScale = xDiff / xBoundsDiff;
        var yBoundsScale = yDiff / yBoundsDiff;

        this._scale[0] = xBoundsScale;
        this._scale[1] = yBoundsScale;
        this._offset[0] = (xmin - this._currDataBounds[0][0]) / xBoundsDiff;
        this._offset[1] = (ymin - this._currDataBounds[1][0]) / yBoundsDiff;

        this._filterDimensionCB([xmin, xmax], [ymin, ymax]);
        this._fireEvent("zoom", e);
        this._fireEvent("move", e);
      }

      if (doFullRender) {
        (0, _coreAsync.redrawAllAsync)(this._chart.chartGroup());
      } else {
        this._chart._updateXAndYScales(this._chart.getDataRenderBounds());
        this._chartRedrawCB();
      }
    }
  }]);

  return ScrollZoomHandler;
}(BaseHandler);

/* istanbul ignore next */


var DragPanHandler = function (_BaseHandler3) {
  _inherits(DragPanHandler, _BaseHandler3);

  function DragPanHandler(chart, container, dataBounds, dataScale, dataOffset, filterDimensionsCB, chartRedrawCB, mapboxglModule) {
    _classCallCheck(this, DragPanHandler);

    var _this4 = _possibleConstructorReturn(this, (DragPanHandler.__proto__ || Object.getPrototypeOf(DragPanHandler)).call(this, chart, container, dataBounds, dataScale, dataOffset, filterDimensionsCB, chartRedrawCB, mapboxglModule));

    _this4._dragInertia = [];
    _this4._startDragPos = null;
    _this4._dragPos = null;

    bindAll(["onDrag", "onMove", "onTouchEnd", "onMouseUp"], _this4);
    return _this4;
  }

  _createClass(DragPanHandler, [{
    key: "_enable",
    value: function _enable() {
      this._container.addEventListener("mousedown", this.onDrag);
      this._container.addEventListener("touchstart", this.onDrag);
    }
  }, {
    key: "_disable",
    value: function _disable() {
      this._container.removeEventListener("mousedown", this.onDrag);
      this._container.removeEventListener("touchstart", this.onDrag);

      document.removeEventListener("touchmove", this.onMove);
      document.removeEventListener("touchend", this.onTouchEnd);
      document.removeEventListener("mousemove", this.onMove);
      document.removeEventListener("mouseup", this.onMouseUp);

      if (this._active) {
        this._active = false;
        this._fireEvent("dragend", {});
        this._fireEvent("moveend", {});
      }
    }
  }, {
    key: "onDrag",
    value: function onDrag(e) {
      if (this._ignoreEvent(e)) {
        return;
      }

      // make sure the mouse position is in the chart
      var pos = new this._mapboxglModule.Point(0, 0);
      if (!isInChart(this._chart, this._container, e, pos)) {
        return;
      }

      if (this._active) {
        return;
      }

      if (e.touches) {
        document.addEventListener("touchmove", this.onMove);
        document.addEventListener("touchend", this.onTouchEnd);
      } else {
        document.addEventListener("mousemove", this.onMove);
        document.addEventListener("mouseup", this.onMouseUp);
      }

      this._active = false;
      this._startDragPos = this._dragPos = pos;
      this._dragInertia = [[Date.now(), this._dragPos]];
    }
  }, {
    key: "onMove",
    value: function onMove(e) {
      // make sure the mouse position is in the chart
      if (this._ignoreEvent(e)) {
        return;
      }

      var pos = new this._mapboxglModule.Point(0, 0);
      if (!this._chart.elasticX() || !this._chart.elasticY() || !isInChart(this._chart, this._container, e, pos) && !this._active) {
        return;
      }

      if (!this._active) {
        this._active = true;
        this._fireEvent("dragstart", e);
        this._fireEvent("movestart", e);
      }

      // TODO(croot): stop other animated pans/zooms here if/when
      // they're supported.
      this._drainInertiaBuffer();
      this._dragInertia.push([Date.now(), pos]);

      var xRange = this._chart.xRange();
      if (xRange === null) {
        xRange = [0, 0];
      }

      var yRange = this._chart.yRange();
      if (yRange === null) {
        yRange = [0, 0];
      }

      var prevPos = this._chart.unproject(this._dragPos);
      var currPos = this._chart.unproject(pos);

      var deltaX = currPos.x - prevPos.x;
      var deltaY = currPos.y - prevPos.y;

      var xmin = xRange[0] - deltaX;
      var xmax = xRange[1] - deltaX;

      var ymin = yRange[0] - deltaY;
      var ymax = yRange[1] - deltaY;

      var bounds = this._chart._fitToMaxBounds([[xmin, ymin], [xmax, ymax]], true);
      deltaX = deltaX + (xmin - bounds[0][0]);
      deltaY = deltaY + (ymin - bounds[0][1]);
      xmin = bounds[0][0];
      ymin = bounds[0][1];
      xmax = bounds[1][0];
      ymax = bounds[1][1];

      var xBoundsDiff = this._currDataBounds[0][1] - this._currDataBounds[0][0];
      var yBoundsDiff = this._currDataBounds[1][1] - this._currDataBounds[1][0];

      this._offset[0] -= deltaX / xBoundsDiff;
      this._offset[1] -= deltaY / yBoundsDiff;

      this._filterDimensionCB([xmin, xmax], [ymin, ymax]);

      this._chart._updateXAndYScales(this._chart.getDataRenderBounds());
      this._chartRedrawCB();

      this._fireEvent("drag", e);
      this._fireEvent("move", e);

      this._dragPos = pos;

      e.preventDefault();
    }
  }, {
    key: "_onUp",
    value: function _onUp(e) {
      var _this5 = this;

      if (!this._active) {
        return;
      }

      this._active = false;
      this._fireEvent("dragend", e);
      this._drainInertiaBuffer();

      var finish = function finish() {
        (0, _coreAsync.redrawAllAsync)(_this5._chart.chartGroup());
        _this5._fireEvent("moveend", e);
      };

      var inertia = this._dragInertia;
      if (inertia.length < 2) {
        finish();
        return;
      }

      var last = inertia[inertia.length - 1];
      var first = inertia[0];
      var flingOffset = last[1].sub(first[1]);
      var flingDuration = (last[0] - first[0]) / 1000;

      if (flingDuration === 0 || last[1].equals(first[1])) {
        finish();
        return;
      }

      var inertiaLinearity = 0.3;
      var inertiaMaxSpeed = 1400; // pixels/second
      var inertiaDeceleration = 2500; // pixels/second squared

      // calculate px/s velocity & adjust for increased initial animation speed when easing out
      var velocity = flingOffset.mult(inertiaLinearity / flingDuration);
      var speed = velocity.mag(); // pixels/sec

      if (speed > inertiaMaxSpeed) {
        speed = inertiaMaxSpeed;
        velocity._unit()._mult(speed);
      }

      var duration = speed / (inertiaDeceleration * inertiaLinearity);
      var offset = velocity.mult(-duration / 2);

      finish();

      // TODO(croot):
      // Do the animated ease-out of the pan like mapbox
    }
  }, {
    key: "onTouchEnd",
    value: function onTouchEnd(e) {
      // TODO(croot): check that the event is in the chart window?
      if (this._ignoreEvent(e)) {
        return;
      }
      this._onUp(e);
      document.removeEventListener("touchmove", this.onMove);
      document.removeEventListener("touchend", this.onTouchEnd);
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp(e) {
      // TODO(croot): check that the event is in the chart window?
      if (this._ignoreEvent(e)) {
        return;
      }
      this._onUp(e);
      document.removeEventListener("mousemove", this.onMove);
      document.removeEventListener("mouseup", this.onMouseUp);
    }
  }, {
    key: "_ignoreEvent",
    value: function _ignoreEvent(e) {
      if (this._chart.shiftToZoom() && e && !e.shiftKey) {
        return true;
      }
      var map = this._chart.map();
      if (map.boxZoom && map.boxZoom.isActive()) {
        return true;
      }

      if (e.touches) {
        return e.touches.length > 1;
      } else {
        if (e.ctrlKey) {
          return true;
        }
        var buttons = 1;
        var button = 0;
        return e.type === "mousemove" ? e.buttons & buttons === 0 : e.button !== button;
      }
    }
  }, {
    key: "_drainInertiaBuffer",
    value: function _drainInertiaBuffer() {
      var now = Date.now();
      var cutoff = 160; // msec

      if (this._dragInertia) {
        while (this._dragInertia.length > 0 && now - this._dragInertia[0][0] > cutoff) {
          this._dragInertia.shift();
        }
      }
    }
  }]);

  return DragPanHandler;
}(BaseHandler);

/* istanbul ignore next */


function bindEventHandlers(chart, container, dataBounds, dataScale, dataOffset, filterDimensionsCB, chartRedrawCB, browser, mapboxglModule, enableInteractions) {
  var map = chart.map();
  var startPos = null;
  var tapped = null;

  map.scrollZoom = new ScrollZoomHandler(chart, container, dataBounds, dataScale, dataOffset, filterDimensionsCB, chartRedrawCB, mapboxglModule, browser);
  map.boxZoom = new BoxZoomHandler(chart, container, dataBounds, dataScale, dataOffset, filterDimensionsCB, chartRedrawCB, mapboxglModule);
  map.dragPan = new DragPanHandler(chart, container, dataBounds, dataScale, dataOffset, filterDimensionsCB, chartRedrawCB, mapboxglModule);

  container.addEventListener("mouseout", onMouseOut, false);
  container.addEventListener("mousedown", onMouseDown, false);
  container.addEventListener("mouseup", onMouseUp, false);
  container.addEventListener("mousemove", onMouseMove, false);
  container.addEventListener("touchstart", onTouchStart, false);
  container.addEventListener("touchend", onTouchEnd, false);
  container.addEventListener("touchmove", onTouchMove, false);
  container.addEventListener("touchcancel", onTouchCancel, false);
  container.addEventListener("click", onClick, false);
  container.addEventListener("dblclick", onDblClick, false);

  function destroyAllEvents() {
    container.removeEventListener("mouseout", onMouseOut);
    container.removeEventListener("mousedown", onMouseDown);
    container.removeEventListener("mouseup", onMouseUp);
    container.removeEventListener("mousemove", onMouseMove);
    container.removeEventListener("touchstart", onTouchStart);
    container.removeEventListener("touchend", onTouchEnd);
    container.removeEventListener("touchmove", onTouchMove);
    container.removeEventListener("touchcancel", onTouchCancel);
    container.removeEventListener("click", onClick);
    container.removeEventListener("dblclick", onDblClick);
  }

  function onMouseOut(e) {
    var pos = new mapboxglModule.Point(0, 0);
    if (isInChart(chart, container, e, pos)) {
      fireMouseEvent("mouseout", e, pos);
    }
  }

  function onMouseDown(e) {
    // TODO(croot): if we support animated
    // pans/zooms, we want to stop any currently
    // running animation here first:

    var pos = new mapboxglModule.Point(0, 0);
    if (isInChart(chart, container, e, pos)) {
      startPos = pos;
      fireMouseEvent("mousedown", e, pos);
    }
  }

  function onMouseUp(e) {
    var pos = new mapboxglModule.Point(0, 0);
    fireMouseEvent("mouseup", e, pos);
  }

  function onMouseMove(e) {
    var pos = new mapboxglModule.Point(0, 0);
    if (isInChart(chart, container, e, pos)) {
      if (map.dragPan && map.dragPan.isActive()) {
        return;
      }

      var target = e.toElement || e.target;
      while (target && target !== container) {
        target = target.parentNode;
      }
      if (target !== container) {
        return;
      }

      fireMouseEvent("mousemove", e, pos);
    }
  }

  function onTouchStart(e) {
    if (isInChart(chart, container, e)) {
      // TODO(croot): if we support animated
      // pans/zooms, we want to stop any currently
      // running animation here first:
      if (map.dragPan && map.dragPan.isActive() || map.bozZoom && map.boxZoom.isActive()) {
        return;
      }

      fireTouchEvent("touchstart", e);

      if (!e.touches || e.touches.length > 1) {
        return;
      }

      if (tapped) {
        clearTimeout(tapped);
        tapped = null;
        fireMouseEvent("dblclick", e);
      } else {
        tapped = setTimeout(onTouchTimeout, 300);
      }
    }
  }

  function onTouchMove(e) {
    if (isInChart(chart, container, e)) {
      fireTouchEvent("touchmove", e);
    }
  }

  function onTouchEnd(e) {
    if (isInChart(chart, container, e)) {
      fireTouchEvent("touchend", e);
    }
  }

  function onTouchCancel(e) {
    if (isInChart(chart, container, e)) {
      fireTouchEvent("touchcancel", e);
    }
  }

  function onTouchTimeout() {
    tapped = null;
  }

  function onClick(e) {
    var pos = new mapboxglModule.Point(0, 0);
    if (isInChart(chart, container, e, pos)) {
      if (pos.equals(startPos)) {
        fireMouseEvent("click", e, pos);
      }
    }
  }

  function onDblClick(e) {
    var pos = new mapboxglModule.Point(0, 0);
    if (isInChart(chart, container, e, pos)) {
      fireMouseEvent("dblclick", e, pos);
      e.preventDefault();
    }
  }

  function fireMouseEvent(type, e, pos) {
    return map.fire(type, {
      dataCoord: chart.unproject(pos),
      point: pos,
      originalEvent: e
    });
  }

  function touchPos(touchContainer, e) {
    var rect = touchContainer.getBoundingClientRect();
    var points = [];
    var margins = chart.margins();

    for (var i = 0; i < e.touches.length; i = i + 1) {
      // TODO(croot): should we only add points that are
      // within the container?
      points.push(new mapboxglModule.Point(e.touches[i].clientX - margins.left - rect.left - touchContainer.clientLeft, e.touches[i].clientY - margins.top - rect.top - touchContainer.clientTop));
    }
    return points;
  }

  function fireTouchEvent(type, e) {
    var touches = touchPos(container, e);
    var singular = touches.reduce(function (prev, curr, i, arr) {
      return prev.add(curr.div(arr.length));
    }, new mapboxglModule.Point(0, 0));

    return map.fire(type, {
      dataCoord: chart.unproject(singular),
      point: singular,
      dataCoords: touches.map(function (t) {
        return chart.unproject(t);
      }, this),
      points: touches,
      originalEvent: e
    });
  }

  function enableInteractionsInternal(shiftToZoom) {
    map.scrollZoom.enable();
    if (!shiftToZoom) {
      map.boxZoom.enable();
    }
    // NOTE: box zoom must be enabled before dragPan
    map.dragPan.enable();
  }

  function disableInteractionsInternal() {
    map.dragPan.disable();
    map.boxZoom.disable();
    map.scrollZoom.disable();
  }

  var rtn = {
    enableInteractions: function enableInteractions(shiftToZoom) {
      enableInteractionsInternal(shiftToZoom);
    },

    disableInteractions: function disableInteractions() {
      disableInteractionsInternal();
    },

    destroy: function destroy() {
      destroyAllEvents();
      disableInteractionsInternal();
    },

    getInteractionPropNames: function getInteractionPropNames(chart) {
      return chart.shiftToZoom() ? ["scrollZoom", "dragPan"] : ["scrollZoom", "boxZoom", "dragPan"];
    }
  };

  if (enableInteractions) {
    rtn.enableInteractions(chart.shiftToZoom());
  }

  return rtn;
}

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.timed = undefined;
exports.bezier = bezier;

var _unitbezier = __webpack_require__(274);

var _unitbezier2 = _interopRequireDefault(_unitbezier);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Given given (x, y), (x1, y1) control points for a bezier curve,
 * return a function that interpolates along that curve.
 *
 * @param p1x control point 1 x coordinate
 * @param p1y control point 1 y coordinate
 * @param p2x control point 2 x coordinate
 * @param p2y control point 2 y coordinate
 * @private
 */
function bezier(p1x, p1y, p2x, p2y) {
  var bezier = new _unitbezier2.default(p1x, p1y, p2x, p2y);
  return function (t) {
    return bezier.solve(t);
  };
}
/**
 * Provides a function that outputs milliseconds: either performance.now()
 * or a fallback to Date.now()
 */
/**
 * As part of the initiative to upgrade our Mapbox dependency, these
 * functions have been copied from our forked version of Mapbox so that Mapbox
 * can be updated independently
 * - See [FE-8035]
 */

var Now = function () {
  if (window.performance && window.performance.now) {
    return window.performance.now.bind(window.performance);
  } else {
    return Date.now.bind(Date);
  }
}();

var frame = function frame(fn) {
  var frameFn = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  return frameFn(fn);
};

var timed = exports.timed = function timed(fn, dur, ctx) {
  if (!dur) {
    fn.call(ctx, 1);
    return null;
  }

  var abort = false;
  var start = Now();

  function tick(now) {
    if (abort) {
      return;
    }
    now = Now();

    if (now >= start + dur) {
      fn.call(ctx, 1);
    } else {
      fn.call(ctx, (now - start) / dur);
      frame(tick);
    }
  }

  frame(tick);

  return function () {
    abort = true;
  };
};

/***/ }),
/* 274 */
/***/ (function(module, exports) {

/*
 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Ported from Webkit
 * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h
 */

module.exports = UnitBezier;

function UnitBezier(p1x, p1y, p2x, p2y) {
    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
    this.cx = 3.0 * p1x;
    this.bx = 3.0 * (p2x - p1x) - this.cx;
    this.ax = 1.0 - this.cx - this.bx;

    this.cy = 3.0 * p1y;
    this.by = 3.0 * (p2y - p1y) - this.cy;
    this.ay = 1.0 - this.cy - this.by;

    this.p1x = p1x;
    this.p1y = p2y;
    this.p2x = p2x;
    this.p2y = p2y;
}

UnitBezier.prototype.sampleCurveX = function(t) {
    // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
    return ((this.ax * t + this.bx) * t + this.cx) * t;
};

UnitBezier.prototype.sampleCurveY = function(t) {
    return ((this.ay * t + this.by) * t + this.cy) * t;
};

UnitBezier.prototype.sampleCurveDerivativeX = function(t) {
    return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
};

UnitBezier.prototype.solveCurveX = function(x, epsilon) {
    if (typeof epsilon === 'undefined') epsilon = 1e-6;

    var t0, t1, t2, x2, i;

    // First try a few iterations of Newton's method -- normally very fast.
    for (t2 = x, i = 0; i < 8; i++) {

        x2 = this.sampleCurveX(t2) - x;
        if (Math.abs(x2) < epsilon) return t2;

        var d2 = this.sampleCurveDerivativeX(t2);
        if (Math.abs(d2) < 1e-6) break;

        t2 = t2 - x2 / d2;
    }

    // Fall back to the bisection method for reliability.
    t0 = 0.0;
    t1 = 1.0;
    t2 = x;

    if (t2 < t0) return t0;
    if (t2 > t1) return t1;

    while (t0 < t1) {

        x2 = this.sampleCurveX(t2);
        if (Math.abs(x2 - x) < epsilon) return t2;

        if (x > x2) {
            t0 = t2;
        } else {
            t1 = t2;
        }

        t2 = (t1 - t0) * 0.5 + t0;
    }

    // Failure.
    return t2;
};

UnitBezier.prototype.solve = function(x, epsilon) {
    return this.sampleCurveY(this.solveCurveX(x, epsilon));
};


/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(276);

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(8);
var bind = __webpack_require__(194);
var Axios = __webpack_require__(278);
var mergeConfig = __webpack_require__(200);
var defaults = __webpack_require__(197);

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(201);
axios.CancelToken = __webpack_require__(291);
axios.isCancel = __webpack_require__(196);

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(292);

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


/***/ }),
/* 277 */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

module.exports = function isBuffer (obj) {
  return obj != null && obj.constructor != null &&
    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}


/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(8);
var buildURL = __webpack_require__(195);
var InterceptorManager = __webpack_require__(279);
var dispatchRequest = __webpack_require__(280);
var mergeConfig = __webpack_require__(200);

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);
  config.method = config.method ? config.method.toLowerCase() : 'get';

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(8);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(8);
var transformData = __webpack_require__(281);
var isCancel = __webpack_require__(196);
var defaults = __webpack_require__(197);
var isAbsoluteURL = __webpack_require__(289);
var combineURLs = __webpack_require__(290);

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers || {}
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(8);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


/***/ }),
/* 282 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(8);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(199);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};


/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(8);

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(8);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(8);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(201);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var legend_1 = __webpack_require__(294);
exports.Legend = legend_1.default;
//# sourceMappingURL=index.js.map

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var h_1 = __webpack_require__(295);
var vdom_1 = __webpack_require__(298);
var d3_dispatch_1 = __webpack_require__(307);
var d3_format_1 = __webpack_require__(309);
var commafy = function (d) { return typeof d === "number" ? d3_format_1.format(",")(parseFloat(d.toFixed(2))) : d; };
var formatNumber = function (d) {
    if (String(d).length <= 4) {
        return commafy(d);
    }
    else if (d < 0.0001) {
        return d3_format_1.format(".2")(d);
    }
    else {
        return d3_format_1.format(".2s")(d);
    }
};
function rangeStep(domain, index, bins) {
    if (bins === void 0) { bins = 9; }
    if (index === 0) {
        return domain[0];
    }
    else if (index + 1 === bins) {
        return domain[1];
    }
    else {
        var increment = (domain[1] - domain[0]) / bins;
        return domain[0] + increment * index;
    }
}
function validateNumericalInput(previousValue, nextValue) {
    if (isNaN(parseFloat(nextValue))) {
        return parseFloat(previousValue);
    }
    else {
        return parseFloat(nextValue);
    }
}
function renderTickIcon(state, dispatch) {
    var _this = this;
    return h_1.default("div.tick", { on: { click: function () { return dispatch.call("open", _this, state.index); } } });
}
function renderToggleIcon(state, dispatch) {
    var _this = this;
    return h_1.default("div.open-toggle", {
        on: {
            click: function () {
                dispatch.call("toggle", _this, state);
            }
        }
    });
}
function renderLockIcon(locked, index, dispatch) {
    var _this = this;
    return h_1.default("div.lock" + (locked ? ".locked" : ".unlocked"), { on: { click: function () { return dispatch.call("lock", _this, { locked: locked, index: index }); } } }, [
        h_1.default("svg", { attrs: { viewBox: [0, 0, 48, 48] } }, [
            h_1.default("g", { style: { stroke: "white" } }, [
                h_1.default("path", {
                    attrs: {
                        d: locked
                            ? "M34,20v-4c0-5.5-4.5-10-10-10c-5.5,0-10,4.5-10,10v4H8v20h32V20H34z M18,16c0-3.3,2.7-6,6-6s6,2.7,6,6v4H18V16z"
                            : "M18,20v-8c0-3.3,2.7-6,6-6s6,2.7,6,6v2h4v-2c0-5.5-4.5-10-10-10c-5.5,0-10,4.5-10,10v8H8v20h32V20H18z"
                    }
                })
            ])
        ])
    ]);
}
function renderInput(state, domain, dispatch) {
    var _this = this;
    return h_1.default("input", {
        hook: {
            update: function (prevNode, nextNode) {
                nextNode.elm.value = domain.value;
            }
        },
        props: {
            value: domain.value
        },
        on: {
            focus: function (e) {
                e.target.select();
            },
            blur: function (e) {
                var value = validateNumericalInput(domain.value, e.target.value);
                var _a = state.domain, min = _a[0], max = _a[1];
                dispatch.call("input", _this, {
                    index: state.index,
                    domain: domain.index === 0 ? [value, max] : [min, value]
                });
            },
            keydown: function (e) {
                if (e.code === "Enter") {
                    e.target.blur();
                }
            }
        }
    });
}
function renderGradientLegend(state, dispatch) {
    var stacked = typeof state.index === "number";
    return h_1.default("div.legend.gradient-legend" + (stacked ? ".with-header" : ".legendables") + (state.open ? ".open" : ".collapsed") + (state.position ? "." + state.position : ""), [
        stacked ?
            h_1.default("div.header", [h_1.default("div.title-text", state.title), renderTickIcon(state, dispatch)]) : h_1.default("div"),
        state.open
            ? h_1.default("div.range", state.range.map(function (color, index) {
                var isMinMax = index === 0 || index === state.range.length - 1;
                var step = Array.isArray(state.domain) ? formatNumber(rangeStep(state.domain, index, state.range.length)) : null;
                var domain = Array.isArray(state.domain) ? state.domain : [null, null];
                var min = domain[0], max = domain[1];
                return h_1.default("div.block", [
                    h_1.default("div.color", { style: { background: color } }),
                    h_1.default("div.text." + (isMinMax ? "extent" : "step"), [h_1.default("span", "" + (domain.length > 2 ? domain[index] : step))].concat(isMinMax
                        ? [
                            renderInput(state, { value: domain.length === 2 ? domain[index === 0 ? 0 : 1] : domain[index], index: index }, dispatch)
                        ]
                        : []))
                ]);
            }).slice())
            : h_1.default("div"),
        state.open ?
            renderLockIcon(state.locked, state.index, dispatch) : h_1.default("div")
    ]);
}
exports.renderGradientLegend = renderGradientLegend;
function renderNominalLegend(state, dispatch) {
    var _this = this;
    var stacked = typeof state.index === "number";
    return h_1.default("div.legend.nominal-legend" + (stacked ? "" : ".legendables") + (state.open ? ".open" : ".collapsed") + (state.position ? "." + state.position : ""), [
        !stacked ? renderToggleIcon(state, dispatch) : h_1.default("div"),
        state.title &&
            h_1.default("div.header", [h_1.default("div.title-text", state.title), renderTickIcon(state, dispatch)]),
        state.open
            ? h_1.default("div.body", state.domain.map(function (value, index) {
                return h_1.default("div.legend-row", { on: { click: function () { return dispatch.call("filter", _this, value); } } }, [
                    h_1.default("div.color", {
                        style: { background: state.range[index] }
                    }),
                    h_1.default("div.text", "" + value)
                ]);
            }))
            : h_1.default("div")
    ]);
}
exports.renderNominalLegend = renderNominalLegend;
function renderStackedLegend(state, dispatch) {
    return h_1.default("div.legendables" + (state.open ? ".open" : ".collapsed") + (state.list.length > 1 ? ".show-ticks" : ""), { style: { maxHeight: state.maxHeight + "px" } }, [renderToggleIcon(state, dispatch)].concat(state.list.map(function (legend, index) {
        if (legend.type === "gradient") {
            return renderGradientLegend(__assign({}, legend, { index: index }), dispatch);
        }
        else if (legend.type === "nominal") {
            return renderNominalLegend(__assign({}, legend, { index: index }), dispatch);
        }
    })));
}
exports.renderStackedLegend = renderStackedLegend;
var Legend = /** @class */ (function () {
    function Legend(node) {
        var _this = this;
        this.setState = function (state) {
            if (typeof state === "function") {
                _this.state = state(_this.state);
            }
            else {
                _this.state = state;
            }
            var vnode;
            if (_this.state.type === "gradient") {
                vnode = renderGradientLegend(_this.state, _this.dispatch);
            }
            else if (_this.state.type === "nominal") {
                vnode = renderNominalLegend(_this.state, _this.dispatch);
            }
            else if (_this.state.type === "stacked") {
                vnode = renderStackedLegend(_this.state, _this.dispatch);
            }
            else {
                vnode = h_1.default("div");
            }
            _this.node = vdom_1.patch(_this.node, vnode);
            _this.dispatch.call("doneRender", _this, state);
            return _this.node;
        };
        this.node = node;
        this.dispatch = d3_dispatch_1.dispatch("filter", "input", "open", "lock", "toggle", "doneRender");
        this.state = null;
    }
    Legend.prototype.on = function (event, callback) {
        this.dispatch.on(event, callback);
    };
    return Legend;
}());
exports.default = Legend;
//# sourceMappingURL=legend.js.map

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var vnode_1 = __webpack_require__(296);
var is = __webpack_require__(297);
function addNS(data, children, sel) {
    data.ns = 'http://www.w3.org/2000/svg';
    if (sel !== 'foreignObject' && children !== undefined) {
        for (var i = 0; i < children.length; ++i) {
            var childData = children[i].data;
            if (childData !== undefined) {
                addNS(childData, children[i].children, children[i].sel);
            }
        }
    }
}
function h(sel, b, c) {
    var data = {}, children, text, i;
    if (c !== undefined) {
        data = b;
        if (is.array(c)) {
            children = c;
        }
        else if (is.primitive(c)) {
            text = c;
        }
        else if (c && c.sel) {
            children = [c];
        }
    }
    else if (b !== undefined) {
        if (is.array(b)) {
            children = b;
        }
        else if (is.primitive(b)) {
            text = b;
        }
        else if (b && b.sel) {
            children = [b];
        }
        else {
            data = b;
        }
    }
    if (children !== undefined) {
        for (i = 0; i < children.length; ++i) {
            if (is.primitive(children[i]))
                children[i] = vnode_1.vnode(undefined, undefined, undefined, children[i], undefined);
        }
    }
    if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g' &&
        (sel.length === 3 || sel[3] === '.' || sel[3] === '#')) {
        addNS(data, children, sel);
    }
    return vnode_1.vnode(sel, data, children, text, undefined);
}
exports.h = h;
;
exports.default = h;
//# sourceMappingURL=h.js.map

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function vnode(sel, data, children, text, elm) {
    var key = data === undefined ? undefined : data.key;
    return { sel: sel, data: data, children: children,
        text: text, elm: elm, key: key };
}
exports.vnode = vnode;
exports.default = vnode;
//# sourceMappingURL=vnode.js.map

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.array = Array.isArray;
function primitive(s) {
    return typeof s === 'string' || typeof s === 'number';
}
exports.primitive = primitive;
//# sourceMappingURL=is.js.map

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var snabbdom_1 = __webpack_require__(299);
var attributes_1 = __webpack_require__(302);
var class_1 = __webpack_require__(303);
var props_1 = __webpack_require__(304);
var style_1 = __webpack_require__(305);
var eventlisteners_1 = __webpack_require__(306);
exports.patch = snabbdom_1.init([
    class_1.default,
    props_1.default,
    style_1.default,
    attributes_1.default,
    eventlisteners_1.default
]);
//# sourceMappingURL=vdom.js.map

/***/ }),
/* 299 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["init"] = init;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vnode__ = __webpack_require__(203);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__is__ = __webpack_require__(204);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__htmldomapi__ = __webpack_require__(300);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__h__ = __webpack_require__(205);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_3__h__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__thunk__ = __webpack_require__(301);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "thunk", function() { return __WEBPACK_IMPORTED_MODULE_4__thunk__["a"]; });



function isUndef(s) { return s === undefined; }
function isDef(s) { return s !== undefined; }
var emptyNode = Object(__WEBPACK_IMPORTED_MODULE_0__vnode__["a" /* default */])('', {}, [], undefined, undefined);
function sameVnode(vnode1, vnode2) {
    return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
}
function isVnode(vnode) {
    return vnode.sel !== undefined;
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
    var i, map = {}, key, ch;
    for (i = beginIdx; i <= endIdx; ++i) {
        ch = children[i];
        if (ch != null) {
            key = ch.key;
            if (key !== undefined)
                map[key] = i;
        }
    }
    return map;
}
var hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];


function init(modules, domApi) {
    var i, j, cbs = {};
    var api = domApi !== undefined ? domApi : __WEBPACK_IMPORTED_MODULE_2__htmldomapi__["a" /* default */];
    for (i = 0; i < hooks.length; ++i) {
        cbs[hooks[i]] = [];
        for (j = 0; j < modules.length; ++j) {
            var hook = modules[j][hooks[i]];
            if (hook !== undefined) {
                cbs[hooks[i]].push(hook);
            }
        }
    }
    function emptyNodeAt(elm) {
        var id = elm.id ? '#' + elm.id : '';
        var c = elm.className ? '.' + elm.className.split(' ').join('.') : '';
        return Object(__WEBPACK_IMPORTED_MODULE_0__vnode__["a" /* default */])(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);
    }
    function createRmCb(childElm, listeners) {
        return function rmCb() {
            if (--listeners === 0) {
                var parent_1 = api.parentNode(childElm);
                api.removeChild(parent_1, childElm);
            }
        };
    }
    function createElm(vnode, insertedVnodeQueue) {
        var i, data = vnode.data;
        if (data !== undefined) {
            if (isDef(i = data.hook) && isDef(i = i.init)) {
                i(vnode);
                data = vnode.data;
            }
        }
        var children = vnode.children, sel = vnode.sel;
        if (sel === '!') {
            if (isUndef(vnode.text)) {
                vnode.text = '';
            }
            vnode.elm = api.createComment(vnode.text);
        }
        else if (sel !== undefined) {
            // Parse selector
            var hashIdx = sel.indexOf('#');
            var dotIdx = sel.indexOf('.', hashIdx);
            var hash = hashIdx > 0 ? hashIdx : sel.length;
            var dot = dotIdx > 0 ? dotIdx : sel.length;
            var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
            var elm = vnode.elm = isDef(data) && isDef(i = data.ns) ? api.createElementNS(i, tag)
                : api.createElement(tag);
            if (hash < dot)
                elm.setAttribute('id', sel.slice(hash + 1, dot));
            if (dotIdx > 0)
                elm.setAttribute('class', sel.slice(dot + 1).replace(/\./g, ' '));
            for (i = 0; i < cbs.create.length; ++i)
                cbs.create[i](emptyNode, vnode);
            if (__WEBPACK_IMPORTED_MODULE_1__is__["a" /* array */](children)) {
                for (i = 0; i < children.length; ++i) {
                    var ch = children[i];
                    if (ch != null) {
                        api.appendChild(elm, createElm(ch, insertedVnodeQueue));
                    }
                }
            }
            else if (__WEBPACK_IMPORTED_MODULE_1__is__["b" /* primitive */](vnode.text)) {
                api.appendChild(elm, api.createTextNode(vnode.text));
            }
            i = vnode.data.hook; // Reuse variable
            if (isDef(i)) {
                if (i.create)
                    i.create(emptyNode, vnode);
                if (i.insert)
                    insertedVnodeQueue.push(vnode);
            }
        }
        else {
            vnode.elm = api.createTextNode(vnode.text);
        }
        return vnode.elm;
    }
    function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
        for (; startIdx <= endIdx; ++startIdx) {
            var ch = vnodes[startIdx];
            if (ch != null) {
                api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
            }
        }
    }
    function invokeDestroyHook(vnode) {
        var i, j, data = vnode.data;
        if (data !== undefined) {
            if (isDef(i = data.hook) && isDef(i = i.destroy))
                i(vnode);
            for (i = 0; i < cbs.destroy.length; ++i)
                cbs.destroy[i](vnode);
            if (vnode.children !== undefined) {
                for (j = 0; j < vnode.children.length; ++j) {
                    i = vnode.children[j];
                    if (i != null && typeof i !== "string") {
                        invokeDestroyHook(i);
                    }
                }
            }
        }
    }
    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
            var i_1 = void 0, listeners = void 0, rm = void 0, ch = vnodes[startIdx];
            if (ch != null) {
                if (isDef(ch.sel)) {
                    invokeDestroyHook(ch);
                    listeners = cbs.remove.length + 1;
                    rm = createRmCb(ch.elm, listeners);
                    for (i_1 = 0; i_1 < cbs.remove.length; ++i_1)
                        cbs.remove[i_1](ch, rm);
                    if (isDef(i_1 = ch.data) && isDef(i_1 = i_1.hook) && isDef(i_1 = i_1.remove)) {
                        i_1(ch, rm);
                    }
                    else {
                        rm();
                    }
                }
                else {
                    api.removeChild(parentElm, ch.elm);
                }
            }
        }
    }
    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
        var oldStartIdx = 0, newStartIdx = 0;
        var oldEndIdx = oldCh.length - 1;
        var oldStartVnode = oldCh[0];
        var oldEndVnode = oldCh[oldEndIdx];
        var newEndIdx = newCh.length - 1;
        var newStartVnode = newCh[0];
        var newEndVnode = newCh[newEndIdx];
        var oldKeyToIdx;
        var idxInOld;
        var elmToMove;
        var before;
        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (oldStartVnode == null) {
                oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
            }
            else if (oldEndVnode == null) {
                oldEndVnode = oldCh[--oldEndIdx];
            }
            else if (newStartVnode == null) {
                newStartVnode = newCh[++newStartIdx];
            }
            else if (newEndVnode == null) {
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldStartVnode, newStartVnode)) {
                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else if (sameVnode(oldEndVnode, newEndVnode)) {
                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldStartVnode, newEndVnode)) {
                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
                api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldEndVnode, newStartVnode)) {
                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
                api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else {
                if (oldKeyToIdx === undefined) {
                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                }
                idxInOld = oldKeyToIdx[newStartVnode.key];
                if (isUndef(idxInOld)) {
                    api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                    newStartVnode = newCh[++newStartIdx];
                }
                else {
                    elmToMove = oldCh[idxInOld];
                    if (elmToMove.sel !== newStartVnode.sel) {
                        api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                    }
                    else {
                        patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
                        oldCh[idxInOld] = undefined;
                        api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
                    }
                    newStartVnode = newCh[++newStartIdx];
                }
            }
        }
        if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
            if (oldStartIdx > oldEndIdx) {
                before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
                addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
            }
            else {
                removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
            }
        }
    }
    function patchVnode(oldVnode, vnode, insertedVnodeQueue) {
        var i, hook;
        if (isDef(i = vnode.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {
            i(oldVnode, vnode);
        }
        var elm = vnode.elm = oldVnode.elm;
        var oldCh = oldVnode.children;
        var ch = vnode.children;
        if (oldVnode === vnode)
            return;
        if (vnode.data !== undefined) {
            for (i = 0; i < cbs.update.length; ++i)
                cbs.update[i](oldVnode, vnode);
            i = vnode.data.hook;
            if (isDef(i) && isDef(i = i.update))
                i(oldVnode, vnode);
        }
        if (isUndef(vnode.text)) {
            if (isDef(oldCh) && isDef(ch)) {
                if (oldCh !== ch)
                    updateChildren(elm, oldCh, ch, insertedVnodeQueue);
            }
            else if (isDef(ch)) {
                if (isDef(oldVnode.text))
                    api.setTextContent(elm, '');
                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
            }
            else if (isDef(oldCh)) {
                removeVnodes(elm, oldCh, 0, oldCh.length - 1);
            }
            else if (isDef(oldVnode.text)) {
                api.setTextContent(elm, '');
            }
        }
        else if (oldVnode.text !== vnode.text) {
            api.setTextContent(elm, vnode.text);
        }
        if (isDef(hook) && isDef(i = hook.postpatch)) {
            i(oldVnode, vnode);
        }
    }
    return function patch(oldVnode, vnode) {
        var i, elm, parent;
        var insertedVnodeQueue = [];
        for (i = 0; i < cbs.pre.length; ++i)
            cbs.pre[i]();
        if (!isVnode(oldVnode)) {
            oldVnode = emptyNodeAt(oldVnode);
        }
        if (sameVnode(oldVnode, vnode)) {
            patchVnode(oldVnode, vnode, insertedVnodeQueue);
        }
        else {
            elm = oldVnode.elm;
            parent = api.parentNode(elm);
            createElm(vnode, insertedVnodeQueue);
            if (parent !== null) {
                api.insertBefore(parent, vnode.elm, api.nextSibling(elm));
                removeVnodes(parent, [oldVnode], 0, 0);
            }
        }
        for (i = 0; i < insertedVnodeQueue.length; ++i) {
            insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
        }
        for (i = 0; i < cbs.post.length; ++i)
            cbs.post[i]();
        return vnode;
    };
}
//# sourceMappingURL=snabbdom.js.map

/***/ }),
/* 300 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export htmlDomApi */
function createElement(tagName) {
    return document.createElement(tagName);
}
function createElementNS(namespaceURI, qualifiedName) {
    return document.createElementNS(namespaceURI, qualifiedName);
}
function createTextNode(text) {
    return document.createTextNode(text);
}
function createComment(text) {
    return document.createComment(text);
}
function insertBefore(parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
    node.removeChild(child);
}
function appendChild(node, child) {
    node.appendChild(child);
}
function parentNode(node) {
    return node.parentNode;
}
function nextSibling(node) {
    return node.nextSibling;
}
function tagName(elm) {
    return elm.tagName;
}
function setTextContent(node, text) {
    node.textContent = text;
}
function getTextContent(node) {
    return node.textContent;
}
function isElement(node) {
    return node.nodeType === 1;
}
function isText(node) {
    return node.nodeType === 3;
}
function isComment(node) {
    return node.nodeType === 8;
}
var htmlDomApi = {
    createElement: createElement,
    createElementNS: createElementNS,
    createTextNode: createTextNode,
    createComment: createComment,
    insertBefore: insertBefore,
    removeChild: removeChild,
    appendChild: appendChild,
    parentNode: parentNode,
    nextSibling: nextSibling,
    tagName: tagName,
    setTextContent: setTextContent,
    getTextContent: getTextContent,
    isElement: isElement,
    isText: isText,
    isComment: isComment,
};
/* harmony default export */ __webpack_exports__["a"] = (htmlDomApi);
//# sourceMappingURL=htmldomapi.js.map

/***/ }),
/* 301 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return thunk; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__h__ = __webpack_require__(205);

function copyToThunk(vnode, thunk) {
    thunk.elm = vnode.elm;
    vnode.data.fn = thunk.data.fn;
    vnode.data.args = thunk.data.args;
    thunk.data = vnode.data;
    thunk.children = vnode.children;
    thunk.text = vnode.text;
    thunk.elm = vnode.elm;
}
function init(thunk) {
    var cur = thunk.data;
    var vnode = cur.fn.apply(undefined, cur.args);
    copyToThunk(vnode, thunk);
}
function prepatch(oldVnode, thunk) {
    var i, old = oldVnode.data, cur = thunk.data;
    var oldArgs = old.args, args = cur.args;
    if (old.fn !== cur.fn || oldArgs.length !== args.length) {
        copyToThunk(cur.fn.apply(undefined, args), thunk);
        return;
    }
    for (i = 0; i < args.length; ++i) {
        if (oldArgs[i] !== args[i]) {
            copyToThunk(cur.fn.apply(undefined, args), thunk);
            return;
        }
    }
    copyToThunk(oldVnode, thunk);
}
var thunk = function thunk(sel, key, fn, args) {
    if (args === undefined) {
        args = fn;
        fn = key;
        key = undefined;
    }
    return Object(__WEBPACK_IMPORTED_MODULE_0__h__["a" /* h */])(sel, {
        key: key,
        hook: { init: init, prepatch: prepatch },
        fn: fn,
        args: args
    });
};
/* unused harmony default export */ var _unused_webpack_default_export = (thunk);
//# sourceMappingURL=thunk.js.map

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var xlinkNS = 'http://www.w3.org/1999/xlink';
var xmlNS = 'http://www.w3.org/XML/1998/namespace';
var colonChar = 58;
var xChar = 120;
function updateAttrs(oldVnode, vnode) {
    var key, elm = vnode.elm, oldAttrs = oldVnode.data.attrs, attrs = vnode.data.attrs;
    if (!oldAttrs && !attrs)
        return;
    if (oldAttrs === attrs)
        return;
    oldAttrs = oldAttrs || {};
    attrs = attrs || {};
    // update modified attributes, add new attributes
    for (key in attrs) {
        var cur = attrs[key];
        var old = oldAttrs[key];
        if (old !== cur) {
            if (cur === true) {
                elm.setAttribute(key, "");
            }
            else if (cur === false) {
                elm.removeAttribute(key);
            }
            else {
                if (key.charCodeAt(0) !== xChar) {
                    elm.setAttribute(key, cur);
                }
                else if (key.charCodeAt(3) === colonChar) {
                    // Assume xml namespace
                    elm.setAttributeNS(xmlNS, key, cur);
                }
                else if (key.charCodeAt(5) === colonChar) {
                    // Assume xlink namespace
                    elm.setAttributeNS(xlinkNS, key, cur);
                }
                else {
                    elm.setAttribute(key, cur);
                }
            }
        }
    }
    // remove removed attributes
    // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)
    // the other option is to remove all attributes with value == undefined
    for (key in oldAttrs) {
        if (!(key in attrs)) {
            elm.removeAttribute(key);
        }
    }
}
exports.attributesModule = { create: updateAttrs, update: updateAttrs };
exports.default = exports.attributesModule;
//# sourceMappingURL=attributes.js.map

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function updateClass(oldVnode, vnode) {
    var cur, name, elm = vnode.elm, oldClass = oldVnode.data.class, klass = vnode.data.class;
    if (!oldClass && !klass)
        return;
    if (oldClass === klass)
        return;
    oldClass = oldClass || {};
    klass = klass || {};
    for (name in oldClass) {
        if (!klass[name]) {
            elm.classList.remove(name);
        }
    }
    for (name in klass) {
        cur = klass[name];
        if (cur !== oldClass[name]) {
            elm.classList[cur ? 'add' : 'remove'](name);
        }
    }
}
exports.classModule = { create: updateClass, update: updateClass };
exports.default = exports.classModule;
//# sourceMappingURL=class.js.map

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function updateProps(oldVnode, vnode) {
    var key, cur, old, elm = vnode.elm, oldProps = oldVnode.data.props, props = vnode.data.props;
    if (!oldProps && !props)
        return;
    if (oldProps === props)
        return;
    oldProps = oldProps || {};
    props = props || {};
    for (key in oldProps) {
        if (!props[key]) {
            delete elm[key];
        }
    }
    for (key in props) {
        cur = props[key];
        old = oldProps[key];
        if (old !== cur && (key !== 'value' || elm[key] !== cur)) {
            elm[key] = cur;
        }
    }
}
exports.propsModule = { create: updateProps, update: updateProps };
exports.default = exports.propsModule;
//# sourceMappingURL=props.js.map

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var raf = (typeof window !== 'undefined' && window.requestAnimationFrame) || setTimeout;
var nextFrame = function (fn) { raf(function () { raf(fn); }); };
var reflowForced = false;
function setNextFrame(obj, prop, val) {
    nextFrame(function () { obj[prop] = val; });
}
function updateStyle(oldVnode, vnode) {
    var cur, name, elm = vnode.elm, oldStyle = oldVnode.data.style, style = vnode.data.style;
    if (!oldStyle && !style)
        return;
    if (oldStyle === style)
        return;
    oldStyle = oldStyle || {};
    style = style || {};
    var oldHasDel = 'delayed' in oldStyle;
    for (name in oldStyle) {
        if (!style[name]) {
            if (name[0] === '-' && name[1] === '-') {
                elm.style.removeProperty(name);
            }
            else {
                elm.style[name] = '';
            }
        }
    }
    for (name in style) {
        cur = style[name];
        if (name === 'delayed' && style.delayed) {
            for (var name2 in style.delayed) {
                cur = style.delayed[name2];
                if (!oldHasDel || cur !== oldStyle.delayed[name2]) {
                    setNextFrame(elm.style, name2, cur);
                }
            }
        }
        else if (name !== 'remove' && cur !== oldStyle[name]) {
            if (name[0] === '-' && name[1] === '-') {
                elm.style.setProperty(name, cur);
            }
            else {
                elm.style[name] = cur;
            }
        }
    }
}
function applyDestroyStyle(vnode) {
    var style, name, elm = vnode.elm, s = vnode.data.style;
    if (!s || !(style = s.destroy))
        return;
    for (name in style) {
        elm.style[name] = style[name];
    }
}
function applyRemoveStyle(vnode, rm) {
    var s = vnode.data.style;
    if (!s || !s.remove) {
        rm();
        return;
    }
    if (!reflowForced) {
        getComputedStyle(document.body).transform;
        reflowForced = true;
    }
    var name, elm = vnode.elm, i = 0, compStyle, style = s.remove, amount = 0, applied = [];
    for (name in style) {
        applied.push(name);
        elm.style[name] = style[name];
    }
    compStyle = getComputedStyle(elm);
    var props = compStyle['transition-property'].split(', ');
    for (; i < props.length; ++i) {
        if (applied.indexOf(props[i]) !== -1)
            amount++;
    }
    elm.addEventListener('transitionend', function (ev) {
        if (ev.target === elm)
            --amount;
        if (amount === 0)
            rm();
    });
}
function forceReflow() {
    reflowForced = false;
}
exports.styleModule = {
    pre: forceReflow,
    create: updateStyle,
    update: updateStyle,
    destroy: applyDestroyStyle,
    remove: applyRemoveStyle
};
exports.default = exports.styleModule;
//# sourceMappingURL=style.js.map

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function invokeHandler(handler, vnode, event) {
    if (typeof handler === "function") {
        // call function handler
        handler.call(vnode, event, vnode);
    }
    else if (typeof handler === "object") {
        // call handler with arguments
        if (typeof handler[0] === "function") {
            // special case for single argument for performance
            if (handler.length === 2) {
                handler[0].call(vnode, handler[1], event, vnode);
            }
            else {
                var args = handler.slice(1);
                args.push(event);
                args.push(vnode);
                handler[0].apply(vnode, args);
            }
        }
        else {
            // call multiple handlers
            for (var i = 0; i < handler.length; i++) {
                invokeHandler(handler[i]);
            }
        }
    }
}
function handleEvent(event, vnode) {
    var name = event.type, on = vnode.data.on;
    // call event handler(s) if exists
    if (on && on[name]) {
        invokeHandler(on[name], vnode, event);
    }
}
function createListener() {
    return function handler(event) {
        handleEvent(event, handler.vnode);
    };
}
function updateEventListeners(oldVnode, vnode) {
    var oldOn = oldVnode.data.on, oldListener = oldVnode.listener, oldElm = oldVnode.elm, on = vnode && vnode.data.on, elm = (vnode && vnode.elm), name;
    // optimization for reused immutable handlers
    if (oldOn === on) {
        return;
    }
    // remove existing listeners which no longer used
    if (oldOn && oldListener) {
        // if element changed or deleted we remove all existing listeners unconditionally
        if (!on) {
            for (name in oldOn) {
                // remove listener if element was changed or existing listeners removed
                oldElm.removeEventListener(name, oldListener, false);
            }
        }
        else {
            for (name in oldOn) {
                // remove listener if existing listener removed
                if (!on[name]) {
                    oldElm.removeEventListener(name, oldListener, false);
                }
            }
        }
    }
    // add new listeners which has not already attached
    if (on) {
        // reuse existing listener or create new
        var listener = vnode.listener = oldVnode.listener || createListener();
        // update vnode for listener
        listener.vnode = vnode;
        // if element changed or added we add all needed listeners unconditionally
        if (!oldOn) {
            for (name in on) {
                // add listener if element was changed or new listeners added
                elm.addEventListener(name, listener, false);
            }
        }
        else {
            for (name in on) {
                // add listener if new listener added
                if (!oldOn[name]) {
                    elm.addEventListener(name, listener, false);
                }
            }
        }
    }
}
exports.eventListenersModule = {
    create: updateEventListeners,
    update: updateEventListeners,
    destroy: updateEventListeners
};
exports.default = exports.eventListenersModule;
//# sourceMappingURL=eventlisteners.js.map

/***/ }),
/* 307 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dispatch__ = __webpack_require__(308);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "dispatch", function() { return __WEBPACK_IMPORTED_MODULE_0__dispatch__["a"]; });



/***/ }),
/* 308 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var noop = {value: function() {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ __webpack_exports__["a"] = (dispatch);


/***/ }),
/* 309 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__defaultLocale__ = __webpack_require__(310);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "formatDefaultLocale", function() { return __WEBPACK_IMPORTED_MODULE_0__defaultLocale__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "format", function() { return __WEBPACK_IMPORTED_MODULE_0__defaultLocale__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "formatPrefix", function() { return __WEBPACK_IMPORTED_MODULE_0__defaultLocale__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__locale__ = __webpack_require__(206);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "formatLocale", function() { return __WEBPACK_IMPORTED_MODULE_1__locale__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__formatSpecifier__ = __webpack_require__(207);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "formatSpecifier", function() { return __WEBPACK_IMPORTED_MODULE_2__formatSpecifier__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__precisionFixed__ = __webpack_require__(317);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "precisionFixed", function() { return __WEBPACK_IMPORTED_MODULE_3__precisionFixed__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__precisionPrefix__ = __webpack_require__(318);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "precisionPrefix", function() { return __WEBPACK_IMPORTED_MODULE_4__precisionPrefix__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__precisionRound__ = __webpack_require__(319);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "precisionRound", function() { return __WEBPACK_IMPORTED_MODULE_5__precisionRound__["a"]; });








/***/ }),
/* 310 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return formatPrefix; });
/* harmony export (immutable) */ __webpack_exports__["a"] = defaultLocale;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__locale__ = __webpack_require__(206);


var locale;
var format;
var formatPrefix;

defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = Object(__WEBPACK_IMPORTED_MODULE_0__locale__["a" /* default */])(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}


/***/ }),
/* 311 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
});


/***/ }),
/* 312 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
});


/***/ }),
/* 313 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
/* harmony default export */ __webpack_exports__["a"] = (function(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (i0 > 0) { if (!+s[i]) break out; i0 = 0; } break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
});


/***/ }),
/* 314 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__formatPrefixAuto__ = __webpack_require__(208);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__formatRounded__ = __webpack_require__(315);



/* harmony default export */ __webpack_exports__["a"] = ({
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return Object(__WEBPACK_IMPORTED_MODULE_1__formatRounded__["a" /* default */])(x * 100, p); },
  "r": __WEBPACK_IMPORTED_MODULE_1__formatRounded__["a" /* default */],
  "s": __WEBPACK_IMPORTED_MODULE_0__formatPrefixAuto__["a" /* default */],
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
});


/***/ }),
/* 315 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__formatDecimal__ = __webpack_require__(43);


/* harmony default export */ __webpack_exports__["a"] = (function(x, p) {
  var d = Object(__WEBPACK_IMPORTED_MODULE_0__formatDecimal__["a" /* default */])(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
});


/***/ }),
/* 316 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return x;
});


/***/ }),
/* 317 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__exponent__ = __webpack_require__(30);


/* harmony default export */ __webpack_exports__["a"] = (function(step) {
  return Math.max(0, -Object(__WEBPACK_IMPORTED_MODULE_0__exponent__["a" /* default */])(Math.abs(step)));
});


/***/ }),
/* 318 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__exponent__ = __webpack_require__(30);


/* harmony default export */ __webpack_exports__["a"] = (function(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Object(__WEBPACK_IMPORTED_MODULE_0__exponent__["a" /* default */])(value) / 3))) * 3 - Object(__WEBPACK_IMPORTED_MODULE_0__exponent__["a" /* default */])(Math.abs(step)));
});


/***/ }),
/* 319 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__exponent__ = __webpack_require__(30);


/* harmony default export */ __webpack_exports__["a"] = (function(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, Object(__WEBPACK_IMPORTED_MODULE_0__exponent__["a" /* default */])(max) - Object(__WEBPACK_IMPORTED_MODULE_0__exponent__["a" /* default */])(step)) + 1;
});


/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rowChart;

var _baseMixin = __webpack_require__(7);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

var _capMixin = __webpack_require__(16);

var _capMixin2 = _interopRequireDefault(_capMixin);

var _colorMixin = __webpack_require__(12);

var _colorMixin2 = _interopRequireDefault(_colorMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _lockAxisMixin = __webpack_require__(40);

var _lockAxisMixin2 = _interopRequireDefault(_lockAxisMixin);

var _marginMixin = __webpack_require__(18);

var _marginMixin2 = _interopRequireDefault(_marginMixin);

var _core = __webpack_require__(3);

var _utils = __webpack_require__(4);

var _formattingHelpers = __webpack_require__(10);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Concrete row chart implementation.
 *
 * Examples:
 * - {@link https://mapd.github.io/mapd-charting/example/example1.html Total Number of Flights by State}
 * @name rowChart
 * @memberof dc
 * @mixes dc.capMixin
 * @mixes dc.marginMixin
 * @mixes dc.colorMixin
 * @mixes dc.baseMixin
 * @example
 * // create a row chart under #chart-container1 element using the default global chart group
 * var chart1 = dc.rowChart('#chart-container1');
 * // create a row chart under #chart-container2 element using chart group A
 * var chart2 = dc.rowChart('#chart-container2', 'chartGroupA');
 * @param {String|node|d3.selection} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector} specifying
 * a dom block element such as a div; or a dom element or d3 selection.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
 * Interaction with a chart will only trigger events and redraws within the chart's group.
 * @return {dc.rowChart}
 */
function rowChart(parent, chartGroup) {
  var _g = void 0;

  var _labelOffsetX = 8;
  var _labelOffsetY = 16;
  var _hasLabelOffsetY = false;
  var _dyOffset = "0.35em"; // this helps center labels https://github.com/mbostock/d3/wiki/SVG-Shapes#svg_text
  var _titleLabelOffsetX = 2;
  var MAX_TICK_WIDTH = 64;
  var DEFAULT_NUM_TICKS = 10;

  /* OVERRIDE -----------------------------------------------------------------*/
  var _xAxisLabel = void 0;
  var _yAxisLabel = void 0;
  var _autoScroll = false;
  var _minBarHeight = 16;
  var _isBigBar = false;
  var _scrollTop = 0;
  /* --------------------------------------------------------------------------*/

  var _gap = 4;

  var _fixedBarHeight = false;
  var _rowCssClass = "row";
  var _titleRowCssClass = "titlerow";
  var _renderTitleLabel = false;

  var _chart = (0, _lockAxisMixin2.default)((0, _capMixin2.default)((0, _marginMixin2.default)((0, _colorMixin2.default)((0, _baseMixin2.default)({})))));

  var _x = void 0;

  var _elasticX = void 0;

  var _xAxis = _d2.default.svg.axis().orient("bottom");
  var xFormatCache = (0, _formattingHelpers.formatCache)(_xAxis);

  var _rowData = void 0;

  _chart.rowsCap = _chart.cap;

  /* OVERRIDE -----------------------------------------------------------------*/
  _chart.accent = accentRow;
  _chart.unAccent = unAccentRow;

  _chart.setYAxisLabel = function (yAxisLabel) {
    _yAxisLabel = yAxisLabel;
  };

  _chart.xAxisLabel = function (_, padding) {
    if (!arguments.length) {
      return _xAxisLabel;
    }
    _xAxisLabel = _;

    return _chart;
  };

  _chart.scrollTop = function (_) {
    if (!arguments.length) {
      return _scrollTop;
    }
    _scrollTop = _;

    return _chart;
  };

  _chart.getNumTicksForXAxis = function () {
    var effectiveWidth = _chart.effectiveWidth();
    var numTicks = _chart.xAxis().scale().ticks().length;
    return effectiveWidth / numTicks < MAX_TICK_WIDTH ? Math.ceil(effectiveWidth / MAX_TICK_WIDTH) : DEFAULT_NUM_TICKS;
  };
  /* --------------------------------------------------------------------------*/

  function calculateAxisScale() {
    if (!_x) {
      _x = _d2.default.scale.linear();
    }
    _x.range([0, _chart.effectiveWidth()]);

    if (_elasticX) {
      var extent = _d2.default.extent(_rowData, _chart.cappedValueAccessor);
      if (extent[0] > 0) {
        extent[0] = 0;
      } else if (extent[0] === extent[1] && extent[0] < 0) {
        extent[1] = 0;
      }
      _x.domain(extent);
    }
    _xAxis.scale(_x);

    _chart.xAxis().ticks(_chart.getNumTicksForXAxis());
  }

  function setXAxisFormat() {
    var numberFormatter = _chart.valueFormatter();
    var key = _chart.getMeasureName();
    // We have no good way of knowing if the valueFormatter has a formatter for the X axis in
    // particular, since that code is a black box. So we run through a test value and if it returns
    // `null`, we know it doesn't know how to format it. It's dumb, but it works.
    var validFormatting = numberFormatter && numberFormatter(0, key) !== null;
    if (validFormatting) {
      xFormatCache.setTickFormat(function (d) {
        return numberFormatter(d, key);
      });
    } else {
      xFormatCache.setTickFormatFromCache();
    }
  }

  function drawAxis() {
    /* OVERRIDE -----------------------------------------------------------------*/
    var root = _chart.root();
    var axisG = root.select("g.axis");

    calculateAxisScale();

    if (axisG.empty()) {
      if (_chart.autoScroll()) {
        axisG = root.append("div").attr("class", "external-axis").style("height", _chart.margins().bottom + "px").append("svg").attr("height", 32).append("g").attr("class", "axis").attr("transform", "translate(" + _chart.margins().left + ", 1)");

        var saveScrollTop = _chart.debounce(function () {
          _scrollTop = _d2.default.select(this).node().scrollTop;
        }, 250);

        _chart.root().select(".svg-wrapper").on("scroll", saveScrollTop);
      } else {
        axisG = _g.append("g").attr("class", "axis").attr("transform", "translate(0, " + _chart.effectiveHeight() + ")");
      }
    }

    if (_chart.autoScroll()) {
      root.select(".external-axis svg").attr("width", _chart.width());
    }

    var yLabel = root.selectAll(".y-axis-label");

    if (yLabel.empty()) {
      yLabel = root.append("div").attr("class", "y-axis-label");
    }

    yLabel.text(typeof aliases !== "undefined" ? aliases[_yAxisLabel] : _yAxisLabel).style("top", _chart.effectiveHeight() / 2 + _chart.margins().top + "px");

    var xLabel = root.selectAll(".x-axis-label");

    if (xLabel.empty()) {
      xLabel = root.append("div").attr("class", "x-axis-label");
    }

    xLabel.text(_chart.xAxisLabel()).style("left", _chart.effectiveWidth() / 2 + _chart.margins().left + "px");
    /* --------------------------------------------------------------------------*/

    setXAxisFormat();
    (0, _core.transition)(axisG, _chart.transitionDuration()).call(_xAxis);

    _chart.prepareLockAxis("x");
  }

  _chart._doRender = function (data) {
    _chart.resetSvg();

    _g = _chart.svg().append("g").attr("transform", "translate(" + _chart.margins().left + "," + _chart.margins().top + ")");

    drawChart(data);

    return _chart;
  };

  _chart.title(function (d) {
    return _chart.cappedKeyAccessor(d) + ": " + _chart.cappedValueAccessor(d);
  });

  /* OVERRIDE ---------------------------------------------------------------- */
  _chart.measureValue = function (d) {
    var key = _chart.getMeasureName();
    var customFormatter = _chart.valueFormatter();
    var value = _chart.cappedValueAccessor(d);
    return customFormatter && customFormatter(value, key) || _utils.utils.formatValue(value);
  };
  /* ------------------------------------------------------------------------- */

  /**
   * Gets or sets the x scale. The x scale can be any d3
   * {@link https://github.com/mbostock/d3/wiki/Quantitative-Scales quantitive scale}
   * @name x
   * @memberof dc.rowChart
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/Quantitative-Scales quantitive scale}
   * @param {d3.scale} [scale]
   * @return {d3.scale}
   * @return {dc.rowChart}
   */
  _chart.x = function (scale) {
    if (!arguments.length) {
      return _x;
    }
    _x = scale;
    return _chart;
  };

  function drawGridLines() {
    _g.selectAll("g.tick").select("line.grid-line").remove();

    _g.selectAll("g.tick").append("line").attr("class", "grid-line").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", function () {
      return -_chart.effectiveHeight();
    });
  }

  function drawChart(data) {
    /* OVERRIDE -----------------------------------------------------------------*/
    var rData = data ? data : _chart.data();
    _rowData = _utils.utils.maybeFormatInfinity(rData);
    /* --------------------------------------------------------------------------*/

    drawAxis();
    drawGridLines();

    var rows = _g.selectAll("g." + _rowCssClass).data(_rowData);

    createElements(rows);
    removeElements(rows);
    updateElements(rows);

    if (_chart.autoScroll()) {
      _chart.root().select(".svg-wrapper").node().scrollTop = _scrollTop;
    }
  }

  function createElements(rows) {
    var rowEnter = rows.enter().append("g").attr("class", function (d, i) {
      return _rowCssClass + " _" + i;
    });

    rowEnter.append("rect").attr("width", 0);

    createLabels(rowEnter);
    updateLabels(rows);
  }

  function removeElements(rows) {
    rows.exit().remove();
  }

  function rootValue() {
    var root = _x(0);
    return root === -Infinity || root !== root ? _x(1) : root;
  }

  function updateElements(rows) {
    var n = _rowData.length;

    var height = void 0;

    if (!_fixedBarHeight) {
      height = (_chart.effectiveHeight() - _gap - (n + 1) * _gap) / n;
    } else {
      height = _fixedBarHeight;
    }

    /* OVERRIDE -----------------------------------------------------------------*/

    _isBigBar = _labelOffsetY * 2 > (_chart.measureLabelsOn() ? 64 : 32);

    if (_isBigBar) {
      height = (_chart.effectiveHeight() - _gap - (n + 1) * _gap) / n;
    }

    if (_chart.autoScroll()) {
      height = height < _minBarHeight ? _minBarHeight : height;
      _chart.root().select(".svg-wrapper").style("height", _chart.height() - _chart.margins().bottom + "px").style("overflow-y", "auto").style("overflow-x", "hidden");
      _chart.svg().attr("height", height === _minBarHeight ? n * (height + _gap) + 8 : _chart.height() - 56);
    }
    /* --------------------------------------------------------------------------*/

    // vertically align label in center unless they override the value via property setter
    if (!_hasLabelOffsetY) {
      _labelOffsetY = height / 2;
    }

    var rect = rows.attr("transform", function (d, i) {
      return "translate(0," + ((i + 1) * _gap + i * height) + ")";
    }).select("rect").attr("height", height).attr("fill", _chart.getColor).on("click", onClick).classed("deselected", function (d) {
      return _chart.hasFilter() ? !isSelectedRow(d) : false;
    }).classed("selected", function (d) {
      return _chart.hasFilter() ? isSelectedRow(d) : false;
    });

    (0, _core.transition)(rect, _chart.transitionDuration()).attr("width", function (d) {
      return Math.abs(rootValue() - _x(_chart.cappedValueAccessor(d)));
    }).attr("transform", translateX);

    if (!_chart.measureLabelsOn()) {
      createTitles(rows);
    }

    updateLabels(rows);
  }

  function createTitles(rows) {
    if (_chart.renderTitle()) {
      rows.selectAll("title").remove();
      rows.append("title").text(_chart.title());
    }
  }

  function createLabels(rowEnter) {
    if (_chart.renderLabel()) {
      rowEnter.append("text").on("click", onClick);
    }

    /* OVERRIDE -----------------------------------------------------------------*/
    if (_chart.measureLabelsOn()) {
      rowEnter.append("text").attr("class", "value-measure").on("click", onClick);
    }
    /* --------------------------------------------------------------------------*/

    if (_chart.renderTitleLabel()) {
      rowEnter.append("text").attr("class", _titleRowCssClass).on("click", onClick);
    }
  }

  function updateLabels(rows) {
    /* OVERRIDE -----------------------------------------------------------------*/
    rows.selectAll("text").style("font-size", _isBigBar ? "14px" : "12px");
    /* --------------------------------------------------------------------------*/

    if (_chart.renderLabel()) {
      var lab = rows.select("text").attr("x", _labelOffsetX).attr("y", _labelOffsetY).attr("dy", _dyOffset)
      /* OVERRIDE -----------------------------------------------------------------*/
      .attr("dy", isStackLabel() ? "-0.25em" : _dyOffset)
      /* --------------------------------------------------------------------------*/
      .on("click", onClick).attr("class", function (d, i) {
        return _rowCssClass + " _" + i;
      })
      /* OVERRIDE -----------------------------------------------------------------*/
      .classed("value-dim", true).classed("deselected-label", function (d) {
        return _chart.hasFilter() && !isSelectedRow(d);
      })
      /* --------------------------------------------------------------------------*/
      .html(_chart.cappedLabel);
      (0, _core.transition)(lab, _chart.transitionDuration()).attr("transform", translateX);
    }

    /* OVERRIDE -----------------------------------------------------------------*/
    if (_chart.measureLabelsOn()) {
      var measureLab = rows.select(".value-measure").classed("deselected-label", function (d) {
        return _chart.hasFilter() && !isSelectedRow(d);
      }).attr("y", _labelOffsetY).attr("dy", isStackLabel() ? "1.1em" : _dyOffset).on("click", onClick).attr("text-anchor", isStackLabel() ? "start" : "end").html(function (d) {
        if (d.label) {
          return d.label;
        } else {
          return _chart.measureValue(d);
        }
      }).attr("x", function (d, i) {
        if (isStackLabel()) {
          return _labelOffsetX + 1;
        }

        var thisLabel = _d2.default.select(this);

        var width = Math.abs(rootValue() - _x(_chart.cappedValueAccessor(d)));

        //
        // handle Firefox getBBox bug
        // https://bugzilla.mozilla.org/show_bug.cgi?id=612118
        //
        var measureWidth = 0;
        var labelNode = thisLabel.node();
        if (labelNode && labelNode.getClientRects && labelNode.getClientRects().length > 0) {
          measureWidth = labelNode.getBBox().width;
        }

        var dimWidth = 0;
        var textNode = _chart.svg().select("text.value-dim._" + i).node();
        if (textNode && textNode.getClientRects && textNode.getClientRects().length > 0) {
          dimWidth = textNode.getBBox().width;
        }
        var minIdealWidth = measureWidth + dimWidth + 16;

        thisLabel.attr("text-anchor", isStackLabel() || width < minIdealWidth ? "start" : "end");

        return width > minIdealWidth ? width - 4 : dimWidth + 16;
      });
      (0, _core.transition)(measureLab, _chart.transitionDuration()).attr("transform", translateX);
    }
    /* --------------------------------------------------------------------------*/

    if (_chart.renderTitleLabel()) {
      var titlelab = rows.select("." + _titleRowCssClass).attr("x", _chart.effectiveWidth() - _titleLabelOffsetX).attr("y", _labelOffsetY).attr("text-anchor", "end").on("click", onClick).attr("class", function (d, i) {
        return _titleRowCssClass + " _" + i;
      }).text(function (d) {
        return _chart.title()(d);
      });
      (0, _core.transition)(titlelab, _chart.transitionDuration()).attr("transform", translateX);
    }
  }

  /**
   * Turn on/off Title label rendering (values) using SVG style of text-anchor 'end'
   * @name renderTitleLabel
   * @memberof dc.rowChart
   * @instance
   * @param {Boolean} [renderTitleLabel=false]
   * @return {Boolean}
   * @return {dc.rowChart}
   */
  _chart.renderTitleLabel = function (renderTitleLabel) {
    if (!arguments.length) {
      return _renderTitleLabel;
    }
    _renderTitleLabel = renderTitleLabel;
    return _chart;
  };

  function onClick(d) {
    _chart.onClick(d);
  }

  /* OVERRIDE -----------------------------------------------------------------*/
  function isStackLabel() {
    return _chart.measureLabelsOn() && _labelOffsetY > 16;
  }
  /* --------------------------------------------------------------------------*/

  function translateX(d) {
    var x = _x(_chart.cappedValueAccessor(d)),
        x0 = rootValue(),
        s = x > x0 ? x0 : x;
    return "translate(" + s + ",0)";
  }

  _chart._doRedraw = function (data) {
    if (!_g) {
      return _chart._doRender(data);
    }

    drawChart(data);
    return _chart;
  };

  /**
   * Get the x axis for the row chart instance.  Note: not settable for row charts.
   * See the {@link https://github.com/mbostock/d3/wiki/SVG-Axes#wiki-axis d3 axis object}
   * documention for more information.
   * @name xAxis
   * @memberof dc.rowChart
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/SVG-Axes#wiki-axis d3.svg.axis}
   * @example
   * // customize x axis tick format
   * chart.xAxis().tickFormat(function (v) {return v + '%';});
   * // customize x axis tick values
   * chart.xAxis().tickValues([0, 100, 200, 300]);
   * @return {d3.svg.axis}
   */
  _chart.xAxis = function () {
    return _xAxis;
  };

  /**
   * Get or set the fixed bar height. Default is [false] which will auto-scale bars.
   * For example, if you want to fix the height for a specific number of bars (useful in TopN charts)
   * you could fix height as follows (where count = total number of bars in your TopN and gap is
   * your vertical gap space).
   * @name fixedBarHeight
   * @memberof dc.rowChart
   * @instance
   * @example
   * chart.fixedBarHeight( chartheight - (count + 1) * gap / count);
   * @param {Boolean|Number} [fixedBarHeight=false]
   * @return {Boolean|Number}
   * @return {dc.rowChart}
   */
  _chart.fixedBarHeight = function (fixedBarHeight) {
    if (!arguments.length) {
      return _fixedBarHeight;
    }
    _fixedBarHeight = fixedBarHeight;
    return _chart;
  };

  /**
   * Get or set the vertical gap space between rows on a particular row chart instance
   * @name gap
   * @memberof dc.rowChart
   * @instance
   * @param {Number} [gap=5]
   * @return {Number}
   * @return {dc.rowChart}
   */
  _chart.gap = function (gap) {
    if (!arguments.length) {
      return _gap;
    }
    _gap = gap;
    return _chart;
  };

  /**
   * Get or set the elasticity on x axis. If this attribute is set to true, then the x axis will rescle to auto-fit the
   * data range when filtered.
   * @name elasticX
   * @memberof dc.rowChart
   * @instance
   * @param {Boolean} [elasticX]
   * @return {Boolean}
   * @return {dc.rowChart}
   */
  _chart.elasticX = function (elasticX) {
    if (!arguments.length) {
      return _elasticX;
    }
    _elasticX = elasticX;
    return _chart;
  };

  /* OVERRIDE -----------------------------------------------------------------*/
  _chart.autoScroll = function (autoScroll) {
    if (!arguments.length) {
      return _autoScroll;
    }
    _autoScroll = autoScroll;
    return _chart;
  };

  /* --------------------------------------------------------------------------*/
  /**
   * Get or set the x offset (horizontal space to the top left corner of a row) for labels on a particular row chart.
   * @name labelOffsetX
   * @memberof dc.rowChart
   * @instance
   * @param {Number} [labelOffsetX=10]
   * @return {Number}
   * @return {dc.rowChart}
   */
  _chart.labelOffsetX = function (labelOffsetX) {
    if (!arguments.length) {
      return _labelOffsetX;
    }
    _labelOffsetX = labelOffsetX;
    return _chart;
  };

  /**
   * Get or set the y offset (vertical space to the top left corner of a row) for labels on a particular row chart.
   * @name labelOffsetY
   * @memberof dc.rowChart
   * @instance
   * @param {Number} [labelOffsety=15]
   * @return {Number}
   * @return {dc.rowChart}
   */
  _chart.labelOffsetY = function (labelOffsety) {
    if (!arguments.length) {
      return _labelOffsetY;
    }
    _labelOffsetY = labelOffsety;
    _hasLabelOffsetY = true;
    return _chart;
  };

  /**
   * Get of set the x offset (horizontal space between right edge of row and right edge or text.
   * @name titleLabelOffsetX
   * @memberof dc.rowChart
   * @instance
   * @param {Number} [titleLabelOffsetX=2]
   * @return {Number}
   * @return {dc.rowChart}
   */
  _chart.titleLabelOffsetX = function (titleLabelOffsetX) {
    if (!arguments.length) {
      return _titleLabelOffsetX;
    }
    _titleLabelOffsetX = titleLabelOffsetX;
    return _chart;
  };

  /* OVERRIDE -----------------------------------------------------------------*/
  function accentRow(label) {
    _chart.selectAll("g." + _rowCssClass).each(function (d) {
      if (_chart.cappedKeyAccessor(d) == label) {
        _chart.accentSelected(this);
      }
    });
  }

  function unAccentRow(label) {
    _chart.selectAll("g." + _rowCssClass).each(function (d) {
      if (_chart.cappedKeyAccessor(d) == label) {
        _chart.unAccentSelected(this);
      }
    });
  }
  /* --------------------------------------------------------------------------*/

  function isSelectedRow(d) {
    return _chart.hasFilter(_chart.cappedKeyAccessor(d)) ^ _chart.filtersInverse();
  }

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = scatterPlot;

var _coordinateGridMixin = __webpack_require__(14);

var _coordinateGridMixin2 = _interopRequireDefault(_coordinateGridMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _events = __webpack_require__(15);

var _filters = __webpack_require__(21);

var _core = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A scatter plot chart
 *
 * Examples:
 * - {@link http://dc-js.github.io/dc.js/examples/scatter.html Scatter Chart}
 * - {@link http://dc-js.github.io/dc.js/examples/multi-scatter.html Multi-Scatter Chart}
 * @name scatterPlot
 * @memberof dc
 * @mixes dc.coordinateGridMixin
 * @example
 * // create a scatter plot under #chart-container1 element using the default global chart group
 * var chart1 = dc.scatterPlot('#chart-container1');
 * // create a scatter plot under #chart-container2 element using chart group A
 * var chart2 = dc.scatterPlot('#chart-container2', 'chartGroupA');
 * // create a sub-chart under a composite parent chart
 * var chart3 = dc.scatterPlot(compositeChart);
 * @param {String|node|d3.selection} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector} specifying
 * a dom block element such as a div; or a dom element or d3 selection.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
 * Interaction with a chart will only trigger events and redraws within the chart's group.
 * @return {dc.scatterPlot}
 */
function scatterPlot(parent, chartGroup) {
  var _chart = (0, _coordinateGridMixin2.default)({});
  var _symbol = _d2.default.svg.symbol();

  var _existenceAccessor = function _existenceAccessor(d) {
    return d.value;
  };

  var originalKeyAccessor = _chart.keyAccessor();
  _chart.keyAccessor(function (d) {
    return originalKeyAccessor(d)[0];
  });
  _chart.valueAccessor(function (d) {
    return originalKeyAccessor(d)[1];
  });
  _chart.colorAccessor(function () {
    return _chart._groupName;
  });

  var _locator = function _locator(d) {
    return "translate(" + _chart.x()(_chart.keyAccessor()(d)) + "," + _chart.y()(_chart.valueAccessor()(d)) + ")";
  };

  var _symbolSize = 3;
  var _highlightedSize = 5;
  var _hiddenSize = 0;

  _symbol.size(function (d) {
    if (!_existenceAccessor(d)) {
      return _hiddenSize;
    } else if (this.filtered) {
      return Math.pow(_highlightedSize, 2);
    } else {
      return Math.pow(_symbolSize, 2);
    }
  });

  (0, _core.override)(_chart, "_filter", function (filter) {
    if (!arguments.length) {
      return _chart.__filter();
    }

    return _chart.__filter(_filters.filters.RangedTwoDimensionalFilter(filter));
  });

  _chart.plotData = function () {
    var symbols = _chart.chartBodyG().selectAll("path.symbol").data(_chart.data());

    symbols.enter().append("path").attr("class", "symbol").attr("opacity", 0).attr("fill", _chart.getColor).attr("transform", _locator);

    (0, _core.transition)(symbols, _chart.transitionDuration()).attr("opacity", function (d) {
      return _existenceAccessor(d) ? 1 : 0;
    }).attr("fill", _chart.getColor).attr("transform", _locator).attr("d", _symbol);

    (0, _core.transition)(symbols.exit(), _chart.transitionDuration()).attr("opacity", 0).remove();
  };

  /**
   * Get or set the existence accessor.  If a point exists, it is drawn with
   * {@link #dc.scatterPlot+symbolSize symbolSize} radius and
   * opacity 1; if it does not exist, it is drawn with
   * {@link #dc.scatterPlot+hiddenSize hiddenSize} radius and opacity 0. By default,
   * the existence accessor checks if the reduced value is truthy.
   * @name existenceAccessor
   * @memberof dc.scatterPlot
   * @instance
   * @see {@link #dc.scatterPlot+symbolSize symbolSize}
   * @see {@link #dc.scatterPlot+hiddenSize hiddenSize}
   * @example
   * // default accessor
   * chart.existenceAccessor(function (d) { return d.value; });
   * @param {Function} [accessor]
   * @return {Function}
   * @return {dc.scatterPlot}
   */
  _chart.existenceAccessor = function (accessor) {
    if (!arguments.length) {
      return _existenceAccessor;
    }
    _existenceAccessor = accessor;
    return this;
  };

  /**
   * Get or set the symbol type used for each point. By default the symbol is a circle.
   * Type can be a constant or an accessor.
   * @name symbol
   * @memberof dc.scatterPlot
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#symbol_type d3.svg.symbol().type()}
   * @example
   * // Circle type
   * chart.symbol('circle');
   * // Square type
   * chart.symbol('square');
   * @param {String|Function} [type='circle']
   * @return {String|Function}
   * @return {dc.scatterPlot}
   */
  _chart.symbol = function (type) {
    if (!arguments.length) {
      return _symbol.type();
    }
    _symbol.type(type);
    return _chart;
  };

  /**
   * Set or get radius for symbols.
   * @name symbolSize
   * @memberof dc.scatterPlot
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#symbol_size d3.svg.symbol().size()}
   * @param {Number} [symbolSize=3]
   * @return {Number}
   * @return {dc.scatterPlot}
   */
  _chart.symbolSize = function (symbolSize) {
    if (!arguments.length) {
      return _symbolSize;
    }
    _symbolSize = symbolSize;
    return _chart;
  };

  /**
   * Set or get radius for highlighted symbols.
   * @name highlightedSize
   * @memberof dc.scatterPlot
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#symbol_size d3.svg.symbol().size()}
   * @param {Number} [highlightedSize=5]
   * @return {Number}
   * @return {dc.scatterPlot}
   */
  _chart.highlightedSize = function (highlightedSize) {
    if (!arguments.length) {
      return _highlightedSize;
    }
    _highlightedSize = highlightedSize;
    return _chart;
  };

  /**
   * Set or get radius for symbols when the group is empty.
   * @name hiddenSize
   * @memberof dc.scatterPlot
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/SVG-Shapes#symbol_size d3.svg.symbol().size()}
   * @param {Number} [hiddenSize=0]
   * @return {Number}
   * @return {dc.scatterPlot}
   */
  _chart.hiddenSize = function (hiddenSize) {
    if (!arguments.length) {
      return _hiddenSize;
    }
    _hiddenSize = hiddenSize;
    return _chart;
  };

  _chart.legendables = function () {
    return [{ chart: _chart, name: _chart._groupName, color: _chart.getColor() }];
  };

  _chart.legendHighlight = function (d) {
    resizeSymbolsWhere(function (symbol) {
      return symbol.attr("fill") === d.color;
    }, _highlightedSize);
    _chart.selectAll(".chart-body path.symbol").filter(function () {
      return _d2.default.select(this).attr("fill") !== d.color;
    }).classed("fadeout", true);
  };

  _chart.legendReset = function (d) {
    resizeSymbolsWhere(function (symbol) {
      return symbol.attr("fill") === d.color;
    }, _symbolSize);
    _chart.selectAll(".chart-body path.symbol").filter(function () {
      return _d2.default.select(this).attr("fill") !== d.color;
    }).classed("fadeout", false);
  };

  function resizeSymbolsWhere(condition, size) {
    var symbols = _chart.selectAll(".chart-body path.symbol").filter(function () {
      return condition(_d2.default.select(this));
    });
    var oldSize = _symbol.size();
    _symbol.size(Math.pow(size, 2));
    (0, _core.transition)(symbols, _chart.transitionDuration()).attr("d", _symbol);
    _symbol.size(oldSize);
  }

  _chart.setHandlePaths = function () {
    // no handle paths for poly-brushes
  };

  _chart.extendBrush = function () {
    var extent = _chart.brush().extent();
    if (_chart.round()) {
      extent[0] = extent[0].map(_chart.round());
      extent[1] = extent[1].map(_chart.round());

      _chart.g().select(".brush").call(_chart.brush().extent(extent));
    }
    return extent;
  };

  _chart.brushIsEmpty = function (extent) {
    return _chart.brush().empty() || !extent || extent[0][0] >= extent[1][0] || extent[0][1] >= extent[1][1];
  };

  function resizeFiltered(filter) {
    var symbols = _chart.selectAll(".chart-body path.symbol").each(function (d) {
      this.filtered = filter && filter.isFiltered(d.key);
    });

    (0, _core.transition)(symbols, _chart.transitionDuration()).attr("d", _symbol);
  }

  _chart._brushing = function () {
    var extent = _chart.extendBrush();

    _chart.redrawBrush(_chart.g());

    if (_chart.brushIsEmpty(extent)) {
      _events.events.trigger(function () {
        _chart.filterAll();
        _chart.redrawGroup();
      });

      resizeFiltered(false);
    } else {
      var ranged2DFilter = _filters.filters.RangedTwoDimensionalFilter(extent);
      _events.events.trigger(function () {
        _chart.filterAll();
        _chart.filter(ranged2DFilter);
        _chart.redrawGroup();
      }, _core.constants.EVENT_DELAY);

      resizeFiltered(ranged2DFilter);
    }
  };

  _chart.setBrushY = function (gBrush) {
    gBrush.call(_chart.brush().y(_chart.y()));
  };

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.splitStrOnLastAs = undefined;
exports.default = mapdTable;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _formattingHelpers = __webpack_require__(10);

var _baseMixin = __webpack_require__(7);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

var _core = __webpack_require__(3);

var _coreAsync = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var INITIAL_SIZE = 50;
var GROUP_DATA_WIDTH = 20;
var NON_GROUP_DATA_WIDTH = 8;
var NON_INDEX = -1;
var ADDITIONAL_HEIGHT = 18;
var SCROLL_DIVISOR = 5;

var splitStrOnLastAs = exports.splitStrOnLastAs = function splitStrOnLastAs(str) {
  var splitStr = [];
  splitStr[0] = str.substring(0, str.lastIndexOf("AS") - 1);
  splitStr[1] = str.substring(str.lastIndexOf("AS") + 3, str.length);
  return splitStr;
};

function mapdTable(parent, chartGroup) {
  var _chart = (0, _baseMixin2.default)({});
  var _tableWrapper = null;

  var _size = INITIAL_SIZE;
  var _offset = 0;
  var _scrollTop = 0;
  var _pauseAutoLoad = false;

  var _filteredColumns = {};
  var _columnFilterMap = {};
  var _crossfilter = null;
  var _tableFilter = null;
  var _sortColumn = null;
  var _dimOrGroup = null;
  var _isGroupedData = false;
  var _colAliases = null;
  var _sampling = false;
  var _nullsOrder = "";

  var _table_events = ["sort"];
  var _listeners = _d2.default.dispatch.apply(_d2.default, _table_events);
  var _on = _chart.on.bind(_chart);

  _chart.on = function (event, listener) {
    if (_table_events.indexOf(event) === NON_INDEX) {
      _on(event, listener);
    } else {
      _listeners.on(event, listener);
    }
    return _chart;
  };

  _chart._invokeSortListener = function (f) {
    if (f !== "undefined") {
      _listeners.sort(_chart, f);
    }
  };

  _chart.resetTable = function () {
    _chart.root().html("");
  };

  _chart.crossfilter = function (_) {
    if (!arguments.length) {
      return _crossfilter;
    }
    _tableFilter = _.filter();
    _crossfilter = _;
    return _chart;
  };

  _chart.sortColumn = function (_) {
    if (!arguments.length) {
      return _sortColumn;
    }
    _sortColumn = _;
    return _chart;
  };

  _chart.nullsOrder = function (_) {
    if (!arguments.length) {
      return _nullsOrder;
    }
    _nullsOrder = _;
    return _chart;
  };

  _chart.tableWrapper = function (_) {
    if (!arguments.length) {
      return _tableWrapper;
    }
    _tableWrapper = _;
    return _chart;
  };

  _chart.colAliases = function (_) {
    if (!arguments.length) {
      return _colAliases;
    }
    _colAliases = _;
    return _chart;
  };

  _chart.addRowsCallback = function (error, data) {
    if (error) {
      return;
    }
    if (data.length > 0) {
      _pauseAutoLoad = false;
      _chart.dataCache = (_chart.dataCache || []).concat(data);
      _chart._doRedraw(_chart.dataCache);
    }
  };

  _chart.addRows = function () {
    _pauseAutoLoad = true;
    _offset = _offset + _size;
    _chart.getData(_size, _offset, _chart.addRowsCallback);
  };

  _chart.setDataAsync(function (group, callback) {
    var size = _chart.resetTableStateReturnSize();
    _chart.getData(size, 0, callback);
  });

  _chart.data(function () {
    return _chart.dataCache;
  });

  _chart.getData = function (size, offset, callback) {
    _isGroupedData = _chart.dimension().value()[0];
    _dimOrGroup = _isGroupedData ? _chart.group() : _chart.dimension();
    _dimOrGroup.order(_sortColumn ? _sortColumn.col.name : null);
    var sortFuncName = _sortColumn && _sortColumn.order === "asc" ? "bottomAsync" : "topAsync";

    if (!_isGroupedData) {
      _dimOrGroup.nullsOrder(_sortColumn ? _nullsOrder : "");
    }

    if (sortFuncName === "topAsync") {
      return _dimOrGroup[sortFuncName](size, offset).then(function (result) {
        return callback(null, result);
      }).catch(function (error) {
        return callback(error);
      });
    } else {
      return _dimOrGroup[sortFuncName](size, offset, null, callback);
    }
  };

  _chart.resetTableStateReturnSize = function () {
    _pauseAutoLoad = false;

    if (!_isGroupedData && _tableWrapper) {
      _tableWrapper.select(".md-table-scroll").node().scrollTop = 0;
    }
    var size = _size;

    if (_isGroupedData) {
      size = _offset > 0 ? _offset : size;
    } else {
      _offset = 0;
    }
    return size;
  };

  _chart.addFilteredColumn = function (columnName) {
    _filteredColumns[columnName] = null;
  };

  _chart.removeFilteredColumn = function (columnName) {
    delete _filteredColumns[columnName];
  };

  _chart.clearFilteredColumns = function () {
    _filteredColumns = {};
  };

  _chart.getFilteredColumns = function () {
    return _filteredColumns;
  };

  _chart.clearTableFilter = function () {
    _columnFilterMap = {};
    _chart.clearFilteredColumns();
    _tableFilter.filter();
  };

  _chart._doRender = function (data) {
    if (!_tableWrapper) {
      _chart.resetTable();
      _tableWrapper = _chart.root().append("div").attr("class", "md-table-wrapper");

      _tableWrapper.append("div").attr("class", "md-header-spacer");

      _tableWrapper.append("div").attr("class", "md-table-scroll").append("table");

      _tableWrapper.append("div").attr("class", "md-table-header");
    }

    renderTable(data);

    if (_isGroupedData) {
      _tableWrapper.select(".md-table-scroll").node().scrollTop = _scrollTop;
    }

    if (!_pauseAutoLoad) {
      shouldLoadMore();
    }

    return _chart;
  };

  function shouldLoadMore() {
    var scrollDivNode = _tableWrapper.select(".md-table-scroll").node();
    var tableNode = _tableWrapper.select("table").node();
    if (tableNode.scrollHeight > 0 && tableNode.scrollHeight <= scrollDivNode.scrollTop + scrollDivNode.getBoundingClientRect().height + ADDITIONAL_HEIGHT) {
      _chart.addRows();
    }
  }

  function getMeasureColHeaderLabel(d) {
    return d.agg_mode ? d.agg_mode.toUpperCase() + " " + d.expression : d.expression;
  }

  function renderTable() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    var table = _chart.tableWrapper().select("table").html("");

    if (data.length === 0) {
      return;
    }

    var cols = [];

    if (_isGroupedData) {
      _chart.dimension().getDimensionName().forEach(function (d, i) {
        cols.push({
          expression: d,
          name: "key" + i,
          label: _colAliases ? _colAliases[i] : d,
          type: "dimension",
          measureName: d.measureName,
          formatKey: d.measureName || d
        });
      });
      _chart.group().reduce().forEach(function (d, i) {
        if (d.expression) {
          var label = _colAliases ? _colAliases[_chart.dimension().value().length + i] : getMeasureColHeaderLabel(d);
          cols.push({
            expression: d.expression,
            name: d.name,
            agg_mode: d.agg_mode,
            label: label,
            type: "measure",
            measureName: d.measureName,
            formatKey: d.measureName || label
          });
        }
      });
    } else {
      cols = _chart.dimension().getProjectOn().map(function (d, i) {
        var splitStr = splitStrOnLastAs(d);
        var label = _colAliases ? _colAliases[i] : splitStr[0];
        return {
          expression: splitStr[0],
          name: splitStr[1],
          label: label,
          type: "project",
          measureName: d.measureName,
          formatKey: d.measureName || label
        };
      });
    }

    var tableHeader = table.append("tr").selectAll("th").data(cols).enter();

    tableHeader.append("th").text(function (d) {
      return d.label;
    });

    var tableRows = table.selectAll(".table-row").data(data).enter();

    var rowItem = tableRows.append("tr").attr("class", function (d) {
      var tableRowCls = "table-row ";
      if (_isGroupedData) {
        tableRowCls = tableRowCls + "grouped-data ";

        if (_chart.hasFilter()) {
          var key = _chart.keyAccessor()(d);
          tableRowCls = tableRowCls + (!_chart.hasFilter(key) ^ _chart.filtersInverse() ? "deselected" : "selected");
        }
      }
      return tableRowCls;
    });

    cols.forEach(function (col) {
      rowItem.append("td").html(function (d) {
        // use custom formatter or default one
        var customFormatter = void 0;
        var val = d[col.name];
        if (col.type === "measure") {
          customFormatter = _chart.valueFormatter();
        } else if (Array.isArray(val) && val[0].value instanceof Date) {
          customFormatter = _chart.dateFormatter();
          val = val[0].value;
        } else {
          customFormatter = _chart.valueFormatter();
        }

        var key = val && val[0] && val[0].isExtract ? null : col.formatKey;
        return customFormatter && customFormatter(val, key) || (0, _formattingHelpers.formatDataValue)(val);
      }).classed("filtered", col.expression in _filteredColumns).on("click", function (d) {
        // detect if user is selecting text or clicking a value, if so don't filter data
        var s = window.getSelection().toString();
        if (s.length) {
          return;
        }

        if (_isGroupedData) {
          _chart.onClick(d);
        } else if (col.expression in _filteredColumns) {
          delete _columnFilterMap[col.expression];
          // this doesn't work. It ~never~ worked.
          // const filterArray = cols.map(c => _columnFilterMap[c.expression])
          var filterArray = [];
          _chart.removeFilteredColumn(col.expression);
          if (filterArray.some(function (f) {
            return f !== undefined && f !== null;
          })) {
            _chart.onClick(filterArray); // will update global filter Clear icon
          } else {
            _chart.filterAll();
          }
          (0, _coreAsync.redrawAllAsync)(_chart.chartGroup());
        } else {
          filterCol(col.expression, d[col.name]);
          var _filterArray = cols.map(function (c) {
            return _columnFilterMap[c.expression];
          });
          _chart.onClick(_filterArray); // will update global filter Clear icon
        }
      });
    });

    var dockedHeader = _chart.tableWrapper().select(".md-table-header").html("").append("div").attr("class", "docked-table-header").style("left", function () {
      return "-" + _tableWrapper.select(".md-table-scroll").node().scrollLeft + "px";
    });

    _chart.tableWrapper().select(".md-table-scroll").on("scroll", function () {
      dockedHeader.style("left", "-" + _d2.default.select(this).node().scrollLeft + "px");

      var tableScrollElm = _d2.default.select(this).node();

      if (!_pauseAutoLoad) {
        var scrollHeight = tableScrollElm.scrollTop + tableScrollElm.getBoundingClientRect().height;

        if (tableScrollElm.scrollTop > _scrollTop && table.node().scrollHeight <= scrollHeight + scrollHeight / SCROLL_DIVISOR) {
          _chart.addRows();
        }
      }

      _scrollTop = tableScrollElm.scrollTop;
    });

    table.selectAll("th").each(function (d, i) {
      var headerItem = dockedHeader.append("div").attr("class", "table-header-item").classed("isFiltered", function () {
        return d.expression in _filteredColumns;
      });

      var sortLabel = headerItem.append("div").attr("class", "table-sort").classed("disabled", function () {
        var isString = data[0] ? typeof data[0]["col" + i] === "string" : false;
        return !_isGroupedData && isString;
      }).classed("active", _sortColumn ? _sortColumn.index === i : false).classed(_sortColumn ? _sortColumn.order : "", true).style("width", _d2.default.select(this).node().getBoundingClientRect().width + "px");

      var textSpan = sortLabel.append("span").text(d.label);

      var sortButton = sortLabel.append("div").attr("class", "sort-btn").on("click", function () {
        _tableWrapper.selectAll(".table-sort").classed("active asc desc", false);

        if (_sortColumn && _sortColumn.index === i) {
          _sortColumn = _sortColumn.order === "desc" ? { index: i, col: d, order: "asc" } : null;
        } else {
          _sortColumn = { index: i, col: d, order: "desc" };
        }

        _chart._invokeSortListener(_sortColumn);
        (0, _coreAsync.redrawAllAsync)(_chart.chartGroup());
      });

      sortButton.append("svg").attr("class", "svg-icon").classed("icon-sort", true).attr("viewBox", "0 0 48 48").append("use").attr("xlink:href", "#icon-sort");

      sortButton.append("svg").attr("class", "svg-icon").classed("icon-sort-arrow", true).attr("viewBox", "0 0 48 48").append("use").attr("xlink:href", "#icon-arrow1");

      headerItem.append("div").attr("class", "unfilter-btn").attr("data-expr", d.expression).on("click", function () {
        clearColFilter(_d2.default.select(this).attr("data-expr"));
      }).style("left", textSpan.node().getBoundingClientRect().width + GROUP_DATA_WIDTH + "px").append("svg").attr("class", "svg-icon").classed("icon-unfilter", true).attr("viewBox", "0 0 48 48").append("use").attr("xlink:href", "#icon-unfilter");
    });
  }

  function filterCol(expr, val) {
    var key = _crossfilter.getTable()[0] + "." + expr;
    var columns = _crossfilter.getColumns();
    var type = columns[key].type;

    if (type === "TIMESTAMP") {
      val = "TIMESTAMP(3) '" + val.toISOString().slice(0, -1) // Slice off the 'Z' at the end
      .replace("T", " ") + "'";
    } else if (type === "DATE") {
      var dateFormat = _d2.default.time.format.utc("%Y-%m-%d");
      val = "DATE '" + dateFormat(val) + "'";
    }

    _chart.addFilteredColumn(expr);
    _columnFilterMap[expr] = val;
    _tableFilter.filter(computeTableFilter(_columnFilterMap));

    (0, _coreAsync.redrawAllAsync)(_chart.chartGroup());
  }

  function clearColFilter(expr) {
    delete _columnFilterMap[expr];
    _chart.removeFilteredColumn(expr);
    _tableFilter.filter(computeTableFilter(_columnFilterMap));
    _chart.filterAll();
    (0, _coreAsync.redrawAllAsync)(_chart.chartGroup());
  }

  function computeTableFilter(columnFilterMap) {
    // should use class letiables?
    var filter = "";
    var subFilterExpression = null;

    for (var expr in columnFilterMap) {
      if (columnFilterMap[expr] === "null") {
        // null gets translated to "null" by this point
        subFilterExpression = expr + " IS null";
      } else {
        subFilterExpression = expr + " = " + columnFilterMap[expr];
      }

      if (filter === "") {
        filter = filter + subFilterExpression;
      } else {
        filter = filter + " AND " + subFilterExpression;
      }
    }
    return filter;
  }

  _chart._doRedraw = function (data) {
    return _chart._doRender(data);
  };

  _chart.size = function (size) {
    if (!arguments.length) {
      return _size;
    }
    _size = size;
    return _chart;
  };

  _chart.pauseAutoLoad = function () {
    return _pauseAutoLoad;
  };

  _chart.offset = function () {
    return _offset;
  };

  _chart.destroyChart = function () {
    _chart.sampling(false);
  };

  /* istanbul ignore next */
  _chart.sampling = function (setting) {
    // setting should be true or false
    if (!arguments.length) {
      return _sampling;
    }

    if (setting && !_sampling) {
      // if wasn't sampling
      (0, _core.incrementSampledCount)();
    } else if (!setting && _sampling) {
      (0, _core.decrementSampledCount)();
    }

    _sampling = setting;

    if (_sampling === false) {
      _chart.dimension().samplingRatio(null); // unset sampling
    }

    return _chart;
  };

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = boxPlot;

var _core = __webpack_require__(3);

var _coordinateGridMixin = __webpack_require__(14);

var _coordinateGridMixin2 = _interopRequireDefault(_coordinateGridMixin);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _utils = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A box plot is a chart that depicts numerical data via their quartile ranges.
 * @name boxPlot
 * @memberof dc
 * @mixes dc.coordinateGridMixin
 * @example
 * // create a box plot under #chart-container1 element using the default global chart group
 * var boxPlot1 = dc.boxPlot('#chart-container1');
 * // create a box plot under #chart-container2 element using chart group A
 * var boxPlot2 = dc.boxPlot('#chart-container2', 'chartGroupA');
 * @param {String|node|d3.selection} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector} specifying
 * a dom block element such as a div; or a dom element or d3 selection.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.
 * Interaction with a chart will only trigger events and redraws within the chart's group.
 * @return {dc.boxPlot}
 */
function boxPlot(parent, chartGroup) {
  var _chart = (0, _coordinateGridMixin2.default)({});

  // Returns a function to compute the interquartile range.
  function DEFAULT_WHISKERS_IQR(k) {
    return function (d) {
      var q1 = d.quartiles[0],
          q3 = d.quartiles[2],
          iqr = (q3 - q1) * k,
          i = -1,
          j = d.length;
      do {
        ++i;
      } while (d[i] < q1 - iqr);
      do {
        --j;
      } while (d[j] > q3 + iqr);
      return [i, j];
    };
  }

  var _whiskerIqrFactor = 1.5;
  var _whiskersIqr = DEFAULT_WHISKERS_IQR;
  var _whiskers = _whiskersIqr(_whiskerIqrFactor);

  var _box = _d2.default.box();
  var _tickFormat = null;

  var _boxWidth = function _boxWidth(innerChartWidth, xUnits) {
    if (_chart.isOrdinal()) {
      return _chart.x().rangeBand();
    } else {
      return innerChartWidth / (1 + _chart.boxPadding()) / xUnits;
    }
  };

  // default padding to handle min/max whisker text
  _chart.yAxisPadding(12);

  // default to ordinal
  _chart.x(_d2.default.scale.ordinal());
  _chart.xUnits(_core.units.ordinal);

  // valueAccessor should return an array of values that can be coerced into numbers
  // or if data is overloaded for a static array of arrays, it should be `Number`.
  // Empty arrays are not included.
  _chart.data(function (group) {
    return group.all().map(function (d) {
      d.map = function (accessor) {
        return accessor.call(d, d);
      };
      return d;
    }).filter(function (d) {
      var values = _chart.valueAccessor()(d);
      return values.length !== 0;
    });
  });

  /**
   * Get or set the spacing between boxes as a fraction of box size. Valid values are within 0-1.
   * See the {@link https://github.com/mbostock/d3/wiki/Ordinal-Scales#wiki-ordinal_rangeBands d3 docs}
   * for a visual description of how the padding is applied.
   * @name boxPadding
   * @memberof dc.boxPlot
   * @instance
   * @see {@link https://github.com/mbostock/d3/wiki/Ordinal-Scales#wiki-ordinal_rangeBands d3.scale.ordinal.rangeBands}
   * @param {Number} [padding=0.8]
   * @return {Number}
   * @return {dc.boxPlot}
   */
  _chart.boxPadding = _chart._rangeBandPadding;
  _chart.boxPadding(0.8);

  /**
   * Get or set the outer padding on an ordinal box chart. This setting has no effect on non-ordinal charts
   * or on charts with a custom {@link #dc.boxPlot+boxWidth .boxWidth}. Will pad the width by
   * `padding * barWidth` on each side of the chart.
   * @name outerPadding
   * @memberof dc.boxPlot
   * @instance
   * @param {Number} [padding=0.5]
   * @return {Number}
   * @return {dc.boxPlot}
   */
  _chart.outerPadding = _chart._outerRangeBandPadding;
  _chart.outerPadding(0.5);

  /**
   * Get or set the numerical width of the boxplot box. The width may also be a function taking as
   * parameters the chart width excluding the right and left margins, as well as the number of x
   * units.
   * @example
   * // Using numerical parameter
   * chart.boxWidth(10);
   * // Using function
   * chart.boxWidth((innerChartWidth, xUnits) { ... });
   * @name boxWidth
   * @memberof dc.boxPlot
   * @instance
   * @param {Number|Function} [boxWidth=0.5]
   * @return {Number|Function}
   * @return {dc.boxPlot}
   */
  _chart.boxWidth = function (boxWidth) {
    if (!arguments.length) {
      return _boxWidth;
    }
    _boxWidth = _d2.default.functor(boxWidth);
    return _chart;
  };

  var boxTransform = function boxTransform(d, i) {
    var xOffset = _chart.x()(_chart.keyAccessor()(d, i));
    return "translate(" + xOffset + ", 0)";
  };

  _chart._preprocessData = function () {
    if (_chart.elasticX()) {
      _chart.x().domain([]);
    }
  };

  _chart.plotData = function () {
    var _calculatedBoxWidth = _boxWidth(_chart.effectiveWidth(), _chart.xUnitCount());

    _box.whiskers(_whiskers).width(_calculatedBoxWidth).height(_chart.effectiveHeight()).value(_chart.valueAccessor()).domain(_chart.y().domain()).duration(_chart.transitionDuration()).tickFormat(_tickFormat);

    var boxesG = _chart.chartBodyG().selectAll("g.box").data(_chart.data(), function (d) {
      return d.key;
    });

    renderBoxes(boxesG);
    updateBoxes(boxesG);
    removeBoxes(boxesG);

    _chart.fadeDeselectedArea();
  };

  function renderBoxes(boxesG) {
    var boxesGEnter = boxesG.enter().append("g");

    boxesGEnter.attr("class", "box").attr("transform", boxTransform).call(_box).on("click", function (d) {
      _chart.filter(d.key);
      _chart.redrawGroup();
    });
  }

  function updateBoxes(boxesG) {
    (0, _core.transition)(boxesG, _chart.transitionDuration()).attr("transform", boxTransform).call(_box).each(function () {
      _d2.default.select(this).select("rect.box").attr("fill", _chart.getColor);
    });
  }

  function removeBoxes(boxesG) {
    boxesG.exit().remove().call(_box);
  }

  _chart.fadeDeselectedArea = function () {
    if (_chart.hasFilter()) {
      _chart.g().selectAll("g.box").each(function (d) {
        if (_chart.isSelectedNode(d)) {
          _chart.highlightSelected(this);
        } else {
          _chart.fadeDeselected(this);
        }
      });
    } else {
      _chart.g().selectAll("g.box").each(function () {
        _chart.resetHighlight(this);
      });
    }
  };

  _chart.isSelectedNode = function (d) {
    return _chart.hasFilter(d.key);
  };

  _chart.yAxisMin = function () {
    var min = _d2.default.min(_chart.data(), function (e) {
      return _d2.default.min(_chart.valueAccessor()(e));
    });
    return _utils.utils.subtract(min, _chart.yAxisPadding());
  };

  _chart.yAxisMax = function () {
    var max = _d2.default.max(_chart.data(), function (e) {
      return _d2.default.max(_chart.valueAccessor()(e));
    });
    return _utils.utils.add(max, _chart.yAxisPadding());
  };

  /**
   * Set the numerical format of the boxplot median, whiskers and quartile labels. Defaults to
   * integer formatting.
   * @example
   * // format ticks to 2 decimal places
   * chart.tickFormat(d3.format('.2f'));
   * @name tickFormat
   * @memberof dc.boxPlot
   * @instance
   * @param {Function} [tickFormat]
   * @return {Number|Function}
   * @return {dc.boxPlot}
   */
  _chart.tickFormat = function (tickFormat) {
    if (!arguments.length) {
      return _tickFormat;
    }
    _tickFormat = tickFormat;
    return _chart;
  };

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = countWidget;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _core = __webpack_require__(3);

var _coreAsync = __webpack_require__(5);

var _baseMixin = __webpack_require__(7);

var _baseMixin2 = _interopRequireDefault(_baseMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function countWidget(parent, chartGroup) {
  var _chart = (0, _baseMixin2.default)({});

  var _formatNumber = _d2.default.format(",");
  var _countLabel = "rows";
  var _tot = null;

  (0, _core.override)(_chart, "group", function (group, name) {
    if (!arguments.length) {
      return _chart._group();
    }

    (0, _coreAsync.groupAll)(group);
    return _chart._group(group, name);
  });

  var noop = function noop() {
    return null;
  };
  _chart.isCountChart = function () {
    return true;
  };
  _chart.dataFetchRequestCallback(noop);
  _chart.dataFetchSuccessfulCallback(noop);

  _chart.formatNumber = function (formatter) {
    if (!arguments.length) {
      return _formatNumber;
    }
    _formatNumber = formatter;
    return _chart;
  };

  _chart.countLabel = function (_) {
    if (!arguments.length) {
      return _countLabel;
    }
    _countLabel = _;
    return _chart;
  };

  _chart.tot = function (number) {
    if (!arguments.length) {
      return _tot;
    }
    _tot = number;
    return _chart;
  };

  _chart.getTotalRecordsAsync = function () {
    if (_chart.tot()) {
      return Promise.resolve();
    }

    return _chart.dimension().sizeAsync().then(function (tot) {
      _chart.tot(tot);
      return Promise.resolve();
    });
  };

  _chart.setDataAsync(function (group, callbacks) {
    return _chart.getTotalRecordsAsync().then(function () {
      var id = group.getCrossfilterId();
      var filterSize = (0, _coreAsync.lastFilteredSize)(id);
      if (filterSize !== undefined) {
        return Promise.resolve(filterSize);
      } else {
        return group.valueAsync().then(function (value) {
          (0, _coreAsync.setLastFilteredSize)(id, value);
          return value;
        });
      }
    }).then(function (value) {
      callbacks(null, value);
    }).catch(function (error) {
      callbacks(error);
    });
  });

  _chart._doRender = function (val) {
    var all = _formatNumber(_chart.tot());
    var selected = _formatNumber(val);

    var wrapper = _chart.root().style("width", "auto").style("height", "auto").html("").append("div").attr("class", "count-widget");

    wrapper.append("span").attr("class", "count-selected").classed("not-filtered", selected === all).text(selected === "-0" ? 0 : selected);

    wrapper.append("span").classed("not-filtered", selected === all).text(" of ");

    wrapper.append("span").attr("class", "count-all").text(all);

    wrapper.append("span").attr("class", "count-label").text(" " + _countLabel);

    return _chart;
  };

  _chart._doRedraw = function (val) {
    return _chart._doRender(val);
  };

  return _chart.anchor(parent, chartGroup);
}

/***/ }),
/* 325 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ResyncFollowsWalker */
/* harmony export (immutable) */ __webpack_exports__["a"] = computeAllProdsFollows;
/* unused harmony export buildBetweenProdsFollowPrefix */
/* unused harmony export buildInProdFollowPrefix */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__rest__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__first__ = __webpack_require__(217);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__constants__ = __webpack_require__(218);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__gast_gast_public__ = __webpack_require__(6);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();





// This ResyncFollowsWalker computes all of the follows required for RESYNC
// (skipping reference production).
var ResyncFollowsWalker = /** @class */ (function (_super) {
    __extends(ResyncFollowsWalker, _super);
    function ResyncFollowsWalker(topProd) {
        var _this = _super.call(this) || this;
        _this.topProd = topProd;
        _this.follows = {};
        return _this;
    }
    ResyncFollowsWalker.prototype.startWalking = function () {
        this.walk(this.topProd);
        return this.follows;
    };
    ResyncFollowsWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {
        // do nothing! just like in the public sector after 13:00
    };
    ResyncFollowsWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {
        var followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) +
            this.topProd.name;
        var fullRest = currRest.concat(prevRest);
        var restProd = new __WEBPACK_IMPORTED_MODULE_4__gast_gast_public__["c" /* Flat */]({ definition: fullRest });
        var t_in_topProd_follows = Object(__WEBPACK_IMPORTED_MODULE_1__first__["a" /* first */])(restProd);
        this.follows[followName] = t_in_topProd_follows;
    };
    return ResyncFollowsWalker;
}(__WEBPACK_IMPORTED_MODULE_0__rest__["a" /* RestWalker */]));

function computeAllProdsFollows(topProductions) {
    var reSyncFollows = {};
    Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["u" /* forEach */])(topProductions, function (topProd) {
        var currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();
        Object(__WEBPACK_IMPORTED_MODULE_2__utils_utils__["f" /* assign */])(reSyncFollows, currRefsFollow);
    });
    return reSyncFollows;
}
function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {
    return inner.name + occurenceInParent + __WEBPACK_IMPORTED_MODULE_3__constants__["a" /* IN */];
}
function buildInProdFollowPrefix(terminal) {
    var terminalName = terminal.terminalType.name;
    return terminalName + terminal.idx + __WEBPACK_IMPORTED_MODULE_3__constants__["a" /* IN */];
}
//# sourceMappingURL=follow.js.map

/***/ }),
/* 326 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return failedOptimizationPrefixMsg; });
/* harmony export (immutable) */ __webpack_exports__["c"] = getOptimizedStartCodesIndices;
/* unused harmony export firstCharOptimizedIndices */
/* harmony export (immutable) */ __webpack_exports__["a"] = canMatchCharCode;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_regexp_to_ast__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_regexp_to_ast___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_regexp_to_ast__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__reg_exp_parser__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lexer__ = __webpack_require__(215);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var complementErrorMessage = "Complement Sets are not supported for first char optimization";
var failedOptimizationPrefixMsg = 'Unable to use "first char" lexer optimizations:\n';
function getOptimizedStartCodesIndices(regExp, ensureOptimizations) {
    if (ensureOptimizations === void 0) { ensureOptimizations = false; }
    try {
        var ast = Object(__WEBPACK_IMPORTED_MODULE_2__reg_exp_parser__["b" /* getRegExpAst */])(regExp);
        var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);
        return firstChars;
    }
    catch (e) {
        /* istanbul ignore next */
        // Testing this relies on the regexp-to-ast library having a bug... */
        // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc
        if (e.message === complementErrorMessage) {
            if (ensureOptimizations) {
                Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["d" /* PRINT_WARNING */])("" + failedOptimizationPrefixMsg +
                    ("\tUnable to optimize: < " + regExp.toString() + " >\n") +
                    "\tComplement Sets cannot be automatically optimized.\n" +
                    "\tThis will disable the lexer's first char optimizations.\n" +
                    "\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.");
            }
        }
        else {
            var msgSuffix = "";
            if (ensureOptimizations) {
                msgSuffix =
                    "\n\tThis will disable the lexer's first char optimizations.\n" +
                        "\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.";
            }
            Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["c" /* PRINT_ERROR */])(failedOptimizationPrefixMsg + "\n" +
                ("\tFailed parsing: < " + regExp.toString() + " >\n") +
                ("\tUsing the regexp-to-ast library version: " + __WEBPACK_IMPORTED_MODULE_0_regexp_to_ast__["VERSION"] + "\n") +
                "\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues" +
                msgSuffix);
        }
    }
    return [];
}
function firstCharOptimizedIndices(ast, result, ignoreCase) {
    switch (ast.type) {
        case "Disjunction":
            for (var i = 0; i < ast.value.length; i++) {
                firstCharOptimizedIndices(ast.value[i], result, ignoreCase);
            }
            break;
        case "Alternative":
            var terms = ast.value;
            for (var i = 0; i < terms.length; i++) {
                var term = terms[i];
                // skip terms that cannot effect the first char results
                switch (term.type) {
                    case "EndAnchor":
                    // A group back reference cannot affect potential starting char.
                    // because if a back reference is the first production than automatically
                    // the group being referenced has had to come BEFORE so its codes have already been added
                    case "GroupBackReference":
                    // assertions do not affect potential starting codes
                    case "Lookahead":
                    case "NegativeLookahead":
                    case "StartAnchor":
                    case "WordBoundary":
                    case "NonWordBoundary":
                        continue;
                }
                var atom = term;
                switch (atom.type) {
                    case "Character":
                        addOptimizedIdxToResult(atom.value, result, ignoreCase);
                        break;
                    case "Set":
                        if (atom.complement === true) {
                            throw Error(complementErrorMessage);
                        }
                        Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["u" /* forEach */])(atom.value, function (code) {
                            if (typeof code === "number") {
                                addOptimizedIdxToResult(code, result, ignoreCase);
                            }
                            else {
                                // range
                                var range = code;
                                // cannot optimize when ignoreCase is
                                if (ignoreCase === true) {
                                    for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {
                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                                    }
                                }
                                // Optimization (2 orders of magnitude less work for very large ranges)
                                else {
                                    // handle unoptimized values
                                    for (var rangeCode = range.from; rangeCode <= range.to &&
                                        rangeCode < __WEBPACK_IMPORTED_MODULE_3__lexer__["g" /* minOptimizationVal */]; rangeCode++) {
                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                                    }
                                    // Less common charCode where we optimize for faster init time, by using larger "buckets"
                                    if (range.to >= __WEBPACK_IMPORTED_MODULE_3__lexer__["g" /* minOptimizationVal */]) {
                                        var minUnOptVal = range.from >= __WEBPACK_IMPORTED_MODULE_3__lexer__["g" /* minOptimizationVal */]
                                            ? range.from
                                            : __WEBPACK_IMPORTED_MODULE_3__lexer__["g" /* minOptimizationVal */];
                                        var maxUnOptVal = range.to;
                                        var minOptIdx = Object(__WEBPACK_IMPORTED_MODULE_3__lexer__["e" /* charCodeToOptimizedIndex */])(minUnOptVal);
                                        var maxOptIdx = Object(__WEBPACK_IMPORTED_MODULE_3__lexer__["e" /* charCodeToOptimizedIndex */])(maxUnOptVal);
                                        for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {
                                            result[currOptIdx] = currOptIdx;
                                        }
                                    }
                                }
                            }
                        });
                        break;
                    case "Group":
                        firstCharOptimizedIndices(atom.value, result, ignoreCase);
                        break;
                    /* istanbul ignore next */
                    default:
                        throw Error("Non Exhaustive Match");
                }
                // reached a mandatory production, no more **start** codes can be found on this alternative
                var isOptionalQuantifier = atom.quantifier !== undefined &&
                    atom.quantifier.atLeast === 0;
                if (
                // A group may be optional due to empty contents /(?:)/
                // or if everything inside it is optional /((a)?)/
                (atom.type === "Group" &&
                    isWholeOptional(atom) === false) ||
                    // If this term is not a group it may only be optional if it has an optional quantifier
                    (atom.type !== "Group" && isOptionalQuantifier === false)) {
                    break;
                }
            }
            break;
        /* istanbul ignore next */
        default:
            throw Error("non exhaustive match!");
    }
    // console.log(Object.keys(result).length)
    return Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["U" /* values */])(result);
}
function addOptimizedIdxToResult(code, result, ignoreCase) {
    var optimizedCharIdx = Object(__WEBPACK_IMPORTED_MODULE_3__lexer__["e" /* charCodeToOptimizedIndex */])(code);
    result[optimizedCharIdx] = optimizedCharIdx;
    if (ignoreCase === true) {
        handleIgnoreCase(code, result);
    }
}
function handleIgnoreCase(code, result) {
    var char = String.fromCharCode(code);
    var upperChar = char.toUpperCase();
    /* istanbul ignore else */
    if (upperChar !== char) {
        var optimizedCharIdx = Object(__WEBPACK_IMPORTED_MODULE_3__lexer__["e" /* charCodeToOptimizedIndex */])(upperChar.charCodeAt(0));
        result[optimizedCharIdx] = optimizedCharIdx;
    }
    else {
        var lowerChar = char.toLowerCase();
        if (lowerChar !== char) {
            var optimizedCharIdx = Object(__WEBPACK_IMPORTED_MODULE_3__lexer__["e" /* charCodeToOptimizedIndex */])(lowerChar.charCodeAt(0));
            result[optimizedCharIdx] = optimizedCharIdx;
        }
    }
}
function findCode(setNode, targetCharCodes) {
    return Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["q" /* find */])(setNode.value, function (codeOrRange) {
        if (typeof codeOrRange === "number") {
            return Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["j" /* contains */])(targetCharCodes, codeOrRange);
        }
        else {
            // range
            var range_1 = codeOrRange;
            return (Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["q" /* find */])(targetCharCodes, function (targetCode) {
                return range_1.from <= targetCode && targetCode <= range_1.to;
            }) !== undefined);
        }
    });
}
function isWholeOptional(ast) {
    if (ast.quantifier && ast.quantifier.atLeast === 0) {
        return true;
    }
    if (!ast.value) {
        return false;
    }
    return Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["y" /* isArray */])(ast.value)
        ? Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["o" /* every */])(ast.value, isWholeOptional)
        : isWholeOptional(ast.value);
}
var CharCodeFinder = /** @class */ (function (_super) {
    __extends(CharCodeFinder, _super);
    function CharCodeFinder(targetCharCodes) {
        var _this = _super.call(this) || this;
        _this.targetCharCodes = targetCharCodes;
        _this.found = false;
        return _this;
    }
    CharCodeFinder.prototype.visitChildren = function (node) {
        // No need to keep looking...
        if (this.found === true) {
            return;
        }
        // switch lookaheads as they do not actually consume any characters thus
        // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.
        switch (node.type) {
            case "Lookahead":
                this.visitLookahead(node);
                return;
            case "NegativeLookahead":
                this.visitNegativeLookahead(node);
                return;
        }
        _super.prototype.visitChildren.call(this, node);
    };
    CharCodeFinder.prototype.visitCharacter = function (node) {
        if (Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["j" /* contains */])(this.targetCharCodes, node.value)) {
            this.found = true;
        }
    };
    CharCodeFinder.prototype.visitSet = function (node) {
        if (node.complement) {
            if (findCode(node, this.targetCharCodes) === undefined) {
                this.found = true;
            }
        }
        else {
            if (findCode(node, this.targetCharCodes) !== undefined) {
                this.found = true;
            }
        }
    };
    return CharCodeFinder;
}(__WEBPACK_IMPORTED_MODULE_0_regexp_to_ast__["BaseRegExpVisitor"]));
function canMatchCharCode(charCodes, pattern) {
    if (pattern instanceof RegExp) {
        var ast = Object(__WEBPACK_IMPORTED_MODULE_2__reg_exp_parser__["b" /* getRegExpAst */])(pattern);
        var charCodeFinder = new CharCodeFinder(charCodes);
        charCodeFinder.visit(ast);
        return charCodeFinder.found;
    }
    else {
        return (Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["q" /* find */])(pattern, function (char) {
            return Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["j" /* contains */])(charCodes, char.charCodeAt(0));
        }) !== undefined);
    }
}
//# sourceMappingURL=reg_exp.js.map

/***/ }),
/* 327 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = resolveGrammar;
/* unused harmony export GastRefResolverVisitor */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__parser_parser__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__gast_gast_visitor_public__ = __webpack_require__(20);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



function resolveGrammar(topLevels, errMsgProvider) {
    var refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);
    refResolver.resolveRefs();
    return refResolver.errors;
}
var GastRefResolverVisitor = /** @class */ (function (_super) {
    __extends(GastRefResolverVisitor, _super);
    function GastRefResolverVisitor(nameToTopRule, errMsgProvider) {
        var _this = _super.call(this) || this;
        _this.nameToTopRule = nameToTopRule;
        _this.errMsgProvider = errMsgProvider;
        _this.errors = [];
        return _this;
    }
    GastRefResolverVisitor.prototype.resolveRefs = function () {
        var _this = this;
        Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["u" /* forEach */])(Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["U" /* values */])(this.nameToTopRule), function (prod) {
            _this.currTopLevel = prod;
            prod.accept(_this);
        });
    };
    GastRefResolverVisitor.prototype.visitNonTerminal = function (node) {
        var ref = this.nameToTopRule[node.nonTerminalName];
        if (!ref) {
            var msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);
            this.errors.push({
                message: msg,
                type: __WEBPACK_IMPORTED_MODULE_0__parser_parser__["h" /* ParserDefinitionErrorType */].UNRESOLVED_SUBRULE_REF,
                ruleName: this.currTopLevel.name,
                unresolvedRefName: node.nonTerminalName
            });
        }
        else {
            node.referencedRule = ref;
        }
    };
    return GastRefResolverVisitor;
}(__WEBPACK_IMPORTED_MODULE_2__gast_gast_visitor_public__["a" /* GAstVisitor */]));

//# sourceMappingURL=resolver.js.map

/***/ }),
/* 328 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LooksAhead; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__grammar_lookahead__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__parser__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__grammar_keys__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__grammar_gast_gast__ = __webpack_require__(26);





/**
 * Trait responsible for the lookahead related utilities and optimizations.
 */
var LooksAhead = /** @class */ (function () {
    function LooksAhead() {
    }
    LooksAhead.prototype.initLooksAhead = function (config) {
        this.dynamicTokensEnabled = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["w" /* has */])(config, "dynamicTokensEnabled")
            ? config.dynamicTokensEnabled
            : __WEBPACK_IMPORTED_MODULE_2__parser__["b" /* DEFAULT_PARSER_CONFIG */].dynamicTokensEnabled;
        this.maxLookahead = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["w" /* has */])(config, "maxLookahead")
            ? config.maxLookahead
            : __WEBPACK_IMPORTED_MODULE_2__parser__["b" /* DEFAULT_PARSER_CONFIG */].maxLookahead;
        /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */
        this.lookAheadFuncsCache = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["z" /* isES2015MapSupported */])() ? new Map() : [];
        // Performance optimization on newer engines that support ES6 Map
        // For larger Maps this is slightly faster than using a plain object (array in our case).
        /* istanbul ignore else - The else branch will be tested on older node.js versions and IE11 */
        if (Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["z" /* isES2015MapSupported */])()) {
            this.getLaFuncFromCache = this.getLaFuncFromMap;
            this.setLaFuncCache = this.setLaFuncCacheUsingMap;
        }
        else {
            this.getLaFuncFromCache = this.getLaFuncFromObj;
            this.setLaFuncCache = this.setLaFuncUsingObj;
        }
    };
    LooksAhead.prototype.preComputeLookaheadFunctions = function (rules) {
        var _this = this;
        Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["u" /* forEach */])(rules, function (currRule) {
            _this.TRACE_INIT(currRule.name + " Rule Lookahead", function () {
                var _a = Object(__WEBPACK_IMPORTED_MODULE_4__grammar_gast_gast__["b" /* collectMethods */])(currRule), alternation = _a.alternation, repetition = _a.repetition, option = _a.option, repetitionMandatory = _a.repetitionMandatory, repetitionMandatoryWithSeparator = _a.repetitionMandatoryWithSeparator, repetitionWithSeparator = _a.repetitionWithSeparator;
                Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["u" /* forEach */])(alternation, function (currProd) {
                    var prodIdx = currProd.idx === 0 ? "" : currProd.idx;
                    _this.TRACE_INIT("" + Object(__WEBPACK_IMPORTED_MODULE_4__grammar_gast_gast__["c" /* getProductionDslName */])(currProd) + prodIdx, function () {
                        var laFunc = Object(__WEBPACK_IMPORTED_MODULE_0__grammar_lookahead__["d" /* buildLookaheadFuncForOr */])(currProd.idx, currRule, currProd.maxLookahead || _this.maxLookahead, currProd.hasPredicates, _this.dynamicTokensEnabled, _this.lookAheadBuilderForAlternatives);
                        var key = Object(__WEBPACK_IMPORTED_MODULE_3__grammar_keys__["j" /* getKeyForAutomaticLookahead */])(_this.fullRuleNameToShort[currRule.name], __WEBPACK_IMPORTED_MODULE_3__grammar_keys__["h" /* OR_IDX */], currProd.idx);
                        _this.setLaFuncCache(key, laFunc);
                    });
                });
                Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["u" /* forEach */])(repetition, function (currProd) {
                    _this.computeLookaheadFunc(currRule, currProd.idx, __WEBPACK_IMPORTED_MODULE_3__grammar_keys__["e" /* MANY_IDX */], __WEBPACK_IMPORTED_MODULE_0__grammar_lookahead__["a" /* PROD_TYPE */].REPETITION, currProd.maxLookahead, Object(__WEBPACK_IMPORTED_MODULE_4__grammar_gast_gast__["c" /* getProductionDslName */])(currProd));
                });
                Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["u" /* forEach */])(option, function (currProd) {
                    _this.computeLookaheadFunc(currRule, currProd.idx, __WEBPACK_IMPORTED_MODULE_3__grammar_keys__["g" /* OPTION_IDX */], __WEBPACK_IMPORTED_MODULE_0__grammar_lookahead__["a" /* PROD_TYPE */].OPTION, currProd.maxLookahead, Object(__WEBPACK_IMPORTED_MODULE_4__grammar_gast_gast__["c" /* getProductionDslName */])(currProd));
                });
                Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["u" /* forEach */])(repetitionMandatory, function (currProd) {
                    _this.computeLookaheadFunc(currRule, currProd.idx, __WEBPACK_IMPORTED_MODULE_3__grammar_keys__["a" /* AT_LEAST_ONE_IDX */], __WEBPACK_IMPORTED_MODULE_0__grammar_lookahead__["a" /* PROD_TYPE */].REPETITION_MANDATORY, currProd.maxLookahead, Object(__WEBPACK_IMPORTED_MODULE_4__grammar_gast_gast__["c" /* getProductionDslName */])(currProd));
                });
                Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["u" /* forEach */])(repetitionMandatoryWithSeparator, function (currProd) {
                    _this.computeLookaheadFunc(currRule, currProd.idx, __WEBPACK_IMPORTED_MODULE_3__grammar_keys__["b" /* AT_LEAST_ONE_SEP_IDX */], __WEBPACK_IMPORTED_MODULE_0__grammar_lookahead__["a" /* PROD_TYPE */].REPETITION_MANDATORY_WITH_SEPARATOR, currProd.maxLookahead, Object(__WEBPACK_IMPORTED_MODULE_4__grammar_gast_gast__["c" /* getProductionDslName */])(currProd));
                });
                Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["u" /* forEach */])(repetitionWithSeparator, function (currProd) {
                    _this.computeLookaheadFunc(currRule, currProd.idx, __WEBPACK_IMPORTED_MODULE_3__grammar_keys__["f" /* MANY_SEP_IDX */], __WEBPACK_IMPORTED_MODULE_0__grammar_lookahead__["a" /* PROD_TYPE */].REPETITION_WITH_SEPARATOR, currProd.maxLookahead, Object(__WEBPACK_IMPORTED_MODULE_4__grammar_gast_gast__["c" /* getProductionDslName */])(currProd));
                });
            });
        });
    };
    LooksAhead.prototype.computeLookaheadFunc = function (rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {
        var _this = this;
        this.TRACE_INIT("" + dslMethodName + (prodOccurrence === 0 ? "" : prodOccurrence), function () {
            var laFunc = Object(__WEBPACK_IMPORTED_MODULE_0__grammar_lookahead__["c" /* buildLookaheadFuncForOptionalProd */])(prodOccurrence, rule, prodMaxLookahead || _this.maxLookahead, _this.dynamicTokensEnabled, prodType, _this.lookAheadBuilderForOptional);
            var key = Object(__WEBPACK_IMPORTED_MODULE_3__grammar_keys__["j" /* getKeyForAutomaticLookahead */])(_this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);
            _this.setLaFuncCache(key, laFunc);
        });
    };
    LooksAhead.prototype.lookAheadBuilderForOptional = function (alt, tokenMatcher, dynamicTokensEnabled) {
        return Object(__WEBPACK_IMPORTED_MODULE_0__grammar_lookahead__["e" /* buildSingleAlternativeLookaheadFunction */])(alt, tokenMatcher, dynamicTokensEnabled);
    };
    LooksAhead.prototype.lookAheadBuilderForAlternatives = function (alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {
        return Object(__WEBPACK_IMPORTED_MODULE_0__grammar_lookahead__["b" /* buildAlternativesLookAheadFunc */])(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled);
    };
    // this actually returns a number, but it is always used as a string (object prop key)
    LooksAhead.prototype.getKeyForAutomaticLookahead = function (dslMethodIdx, occurrence) {
        var currRuleShortName = this.getLastExplicitRuleShortName();
        return Object(__WEBPACK_IMPORTED_MODULE_3__grammar_keys__["j" /* getKeyForAutomaticLookahead */])(currRuleShortName, dslMethodIdx, occurrence);
    };
    /* istanbul ignore next */
    LooksAhead.prototype.getLaFuncFromCache = function (key) {
        return undefined;
    };
    LooksAhead.prototype.getLaFuncFromMap = function (key) {
        return this.lookAheadFuncsCache.get(key);
    };
    /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */
    LooksAhead.prototype.getLaFuncFromObj = function (key) {
        return this.lookAheadFuncsCache[key];
    };
    /* istanbul ignore next */
    LooksAhead.prototype.setLaFuncCache = function (key, value) { };
    LooksAhead.prototype.setLaFuncCacheUsingMap = function (key, value) {
        this.lookAheadFuncsCache.set(key, value);
    };
    /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */
    LooksAhead.prototype.setLaFuncUsingObj = function (key, value) {
        this.lookAheadFuncsCache[key] = value;
    };
    return LooksAhead;
}());

//# sourceMappingURL=looksahead.js.map

/***/ }),
/* 329 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TreeBuilder; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__cst_cst__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__cst_cst_visitor__ = __webpack_require__(330);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__grammar_keys__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__parser__ = __webpack_require__(9);





/**
 * This trait is responsible for the CST building logic.
 */
var TreeBuilder = /** @class */ (function () {
    function TreeBuilder() {
    }
    TreeBuilder.prototype.initTreeBuilder = function (config) {
        this.LAST_EXPLICIT_RULE_STACK = [];
        this.CST_STACK = [];
        this.outputCst = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["w" /* has */])(config, "outputCst")
            ? config.outputCst
            : __WEBPACK_IMPORTED_MODULE_4__parser__["b" /* DEFAULT_PARSER_CONFIG */].outputCst;
        this.nodeLocationTracking = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["w" /* has */])(config, "nodeLocationTracking")
            ? config.nodeLocationTracking
            : __WEBPACK_IMPORTED_MODULE_4__parser__["b" /* DEFAULT_PARSER_CONFIG */].nodeLocationTracking;
        if (!this.outputCst) {
            this.cstInvocationStateUpdate = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["b" /* NOOP */];
            this.cstFinallyStateUpdate = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["b" /* NOOP */];
            this.cstPostTerminal = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["b" /* NOOP */];
            this.cstPostNonTerminal = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["b" /* NOOP */];
            this.cstPostRule = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["b" /* NOOP */];
            this.getLastExplicitRuleShortName = this.getLastExplicitRuleShortNameNoCst;
            this.getPreviousExplicitRuleShortName = this.getPreviousExplicitRuleShortNameNoCst;
            this.getLastExplicitRuleOccurrenceIndex = this.getLastExplicitRuleOccurrenceIndexNoCst;
            this.manyInternal = this.manyInternalNoCst;
            this.orInternal = this.orInternalNoCst;
            this.optionInternal = this.optionInternalNoCst;
            this.atLeastOneInternal = this.atLeastOneInternalNoCst;
            this.manySepFirstInternal = this.manySepFirstInternalNoCst;
            this.atLeastOneSepFirstInternal = this.atLeastOneSepFirstInternalNoCst;
        }
        else {
            if (/full/i.test(this.nodeLocationTracking)) {
                if (this.recoveryEnabled) {
                    this.setNodeLocationFromToken = __WEBPACK_IMPORTED_MODULE_0__cst_cst__["e" /* setNodeLocationFull */];
                    this.setNodeLocationFromNode = __WEBPACK_IMPORTED_MODULE_0__cst_cst__["e" /* setNodeLocationFull */];
                    this.cstPostRule = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["b" /* NOOP */];
                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;
                }
                else {
                    this.setNodeLocationFromToken = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["b" /* NOOP */];
                    this.setNodeLocationFromNode = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["b" /* NOOP */];
                    this.cstPostRule = this.cstPostRuleFull;
                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;
                }
            }
            else if (/onlyOffset/i.test(this.nodeLocationTracking)) {
                if (this.recoveryEnabled) {
                    this.setNodeLocationFromToken = (__WEBPACK_IMPORTED_MODULE_0__cst_cst__["f" /* setNodeLocationOnlyOffset */]);
                    this.setNodeLocationFromNode = (__WEBPACK_IMPORTED_MODULE_0__cst_cst__["f" /* setNodeLocationOnlyOffset */]);
                    this.cstPostRule = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["b" /* NOOP */];
                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;
                }
                else {
                    this.setNodeLocationFromToken = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["b" /* NOOP */];
                    this.setNodeLocationFromNode = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["b" /* NOOP */];
                    this.cstPostRule = this.cstPostRuleOnlyOffset;
                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;
                }
            }
            else if (/none/i.test(this.nodeLocationTracking)) {
                this.setNodeLocationFromToken = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["b" /* NOOP */];
                this.setNodeLocationFromNode = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["b" /* NOOP */];
                this.cstPostRule = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["b" /* NOOP */];
                this.setInitialNodeLocation = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["b" /* NOOP */];
            }
            else {
                throw Error("Invalid <nodeLocationTracking> config option: \"" + config.nodeLocationTracking + "\"");
            }
        }
    };
    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery = function (cstNode) {
        cstNode.location = {
            startOffset: NaN,
            endOffset: NaN
        };
    };
    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular = function (cstNode) {
        cstNode.location = {
            // without error recovery the starting Location of a new CstNode is guaranteed
            // To be the next Token's startOffset (for valid inputs).
            // For invalid inputs there won't be any CSTOutput so this potential
            // inaccuracy does not matter
            startOffset: this.LA(1).startOffset,
            endOffset: NaN
        };
    };
    TreeBuilder.prototype.setInitialNodeLocationFullRecovery = function (cstNode) {
        cstNode.location = {
            startOffset: NaN,
            startLine: NaN,
            startColumn: NaN,
            endOffset: NaN,
            endLine: NaN,
            endColumn: NaN
        };
    };
    /**
     *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work

     * @param cstNode
     */
    TreeBuilder.prototype.setInitialNodeLocationFullRegular = function (cstNode) {
        var nextToken = this.LA(1);
        cstNode.location = {
            startOffset: nextToken.startOffset,
            startLine: nextToken.startLine,
            startColumn: nextToken.startColumn,
            endOffset: NaN,
            endLine: NaN,
            endColumn: NaN
        };
    };
    // CST
    TreeBuilder.prototype.cstNestedInvocationStateUpdate = function (nestedName, shortName) {
        var cstNode = {
            name: nestedName,
            fullName: this.shortRuleNameToFull[this.getLastExplicitRuleShortName()] +
                nestedName,
            children: {}
        };
        this.setInitialNodeLocation(cstNode);
        this.CST_STACK.push(cstNode);
    };
    TreeBuilder.prototype.cstInvocationStateUpdate = function (fullRuleName, shortName) {
        this.LAST_EXPLICIT_RULE_STACK.push(this.RULE_STACK.length - 1);
        var cstNode = {
            name: fullRuleName,
            children: {}
        };
        this.setInitialNodeLocation(cstNode);
        this.CST_STACK.push(cstNode);
    };
    TreeBuilder.prototype.cstFinallyStateUpdate = function () {
        this.LAST_EXPLICIT_RULE_STACK.pop();
        this.CST_STACK.pop();
    };
    TreeBuilder.prototype.cstNestedFinallyStateUpdate = function () {
        var lastCstNode = this.CST_STACK.pop();
        // TODO: the naming is bad, this should go directly to the
        //       (correct) cstLocation update method
        //       e.g if we put other logic in postRule...
        this.cstPostRule(lastCstNode);
    };
    TreeBuilder.prototype.cstPostRuleFull = function (ruleCstNode) {
        var prevToken = this.LA(0);
        var loc = ruleCstNode.location;
        // If this condition is true it means we consumed at least one Token
        // In this CstNode or its nested children.
        if (loc.startOffset <= prevToken.startOffset === true) {
            loc.endOffset = prevToken.endOffset;
            loc.endLine = prevToken.endLine;
            loc.endColumn = prevToken.endColumn;
        }
        // "empty" CstNode edge case
        else {
            loc.startOffset = NaN;
            loc.startLine = NaN;
            loc.startColumn = NaN;
        }
    };
    TreeBuilder.prototype.cstPostRuleOnlyOffset = function (ruleCstNode) {
        var prevToken = this.LA(0);
        var loc = ruleCstNode.location;
        // If this condition is true it means we consumed at least one Token
        // In this CstNode or its nested children.
        if (loc.startOffset <= prevToken.startOffset === true) {
            loc.endOffset = prevToken.endOffset;
        }
        // "empty" CstNode edge case
        else {
            loc.startOffset = NaN;
        }
    };
    TreeBuilder.prototype.cstPostTerminal = function (key, consumedToken) {
        var rootCst = this.CST_STACK[this.CST_STACK.length - 1];
        Object(__WEBPACK_IMPORTED_MODULE_0__cst_cst__["c" /* addTerminalToCst */])(rootCst, consumedToken, key);
        // This is only used when **both** error recovery and CST Output are enabled.
        this.setNodeLocationFromToken(rootCst.location, consumedToken);
    };
    TreeBuilder.prototype.cstPostNonTerminal = function (ruleCstResult, ruleName) {
        // Avoid side effects due to back tracking
        // TODO: This costs a 2-3% in performance, A flag on IParserConfig
        //   could be used to get rid of this conditional, but not sure its worth the effort
        //   and API complexity.
        if (this.isBackTracking() !== true) {
            var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];
            Object(__WEBPACK_IMPORTED_MODULE_0__cst_cst__["b" /* addNoneTerminalToCst */])(preCstNode, ruleName, ruleCstResult);
            // This is only used when **both** error recovery and CST Output are enabled.
            this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);
        }
    };
    TreeBuilder.prototype.getBaseCstVisitorConstructor = function () {
        if (Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["F" /* isUndefined */])(this.baseCstVisitorConstructor)) {
            var newBaseCstVisitorConstructor = Object(__WEBPACK_IMPORTED_MODULE_2__cst_cst_visitor__["a" /* createBaseSemanticVisitorConstructor */])(this.className, this.allRuleNames);
            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;
            return newBaseCstVisitorConstructor;
        }
        return this.baseCstVisitorConstructor;
    };
    TreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults = function () {
        if (Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["F" /* isUndefined */])(this.baseCstVisitorWithDefaultsConstructor)) {
            var newConstructor = Object(__WEBPACK_IMPORTED_MODULE_2__cst_cst_visitor__["b" /* createBaseVisitorConstructorWithDefaults */])(this.className, this.allRuleNames, this.getBaseCstVisitorConstructor());
            this.baseCstVisitorWithDefaultsConstructor = newConstructor;
            return newConstructor;
        }
        return this.baseCstVisitorWithDefaultsConstructor;
    };
    TreeBuilder.prototype.nestedRuleBeforeClause = function (methodOpts, laKey) {
        var nestedName;
        if (methodOpts.NAME !== undefined) {
            nestedName = methodOpts.NAME;
            this.nestedRuleInvocationStateUpdate(nestedName, laKey);
            return nestedName;
        }
        else {
            return undefined;
        }
    };
    TreeBuilder.prototype.nestedAltBeforeClause = function (methodOpts, occurrence, methodKeyIdx, altIdx) {
        var ruleIdx = this.getLastExplicitRuleShortName();
        var shortName = Object(__WEBPACK_IMPORTED_MODULE_3__grammar_keys__["i" /* getKeyForAltIndex */])(ruleIdx, methodKeyIdx, occurrence, altIdx);
        var nestedName;
        if (methodOpts.NAME !== undefined) {
            nestedName = methodOpts.NAME;
            this.nestedRuleInvocationStateUpdate(nestedName, shortName);
            return {
                shortName: shortName,
                nestedName: nestedName
            };
        }
        else {
            return undefined;
        }
    };
    TreeBuilder.prototype.nestedRuleFinallyClause = function (laKey, nestedName) {
        var cstStack = this.CST_STACK;
        var nestedRuleCst = cstStack[cstStack.length - 1];
        this.nestedRuleFinallyStateUpdate();
        // this return a different result than the previous invocation because "nestedRuleFinallyStateUpdate" pops the cst stack
        var parentCstNode = cstStack[cstStack.length - 1];
        Object(__WEBPACK_IMPORTED_MODULE_0__cst_cst__["b" /* addNoneTerminalToCst */])(parentCstNode, nestedName, nestedRuleCst);
        this.setNodeLocationFromNode(parentCstNode.location, nestedRuleCst.location);
    };
    TreeBuilder.prototype.getLastExplicitRuleShortName = function () {
        var lastExplictIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 1];
        return this.RULE_STACK[lastExplictIndex];
    };
    TreeBuilder.prototype.getLastExplicitRuleShortNameNoCst = function () {
        var ruleStack = this.RULE_STACK;
        return ruleStack[ruleStack.length - 1];
    };
    TreeBuilder.prototype.getPreviousExplicitRuleShortName = function () {
        var lastExplicitIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 2];
        return this.RULE_STACK[lastExplicitIndex];
    };
    TreeBuilder.prototype.getPreviousExplicitRuleShortNameNoCst = function () {
        var ruleStack = this.RULE_STACK;
        return ruleStack[ruleStack.length - 2];
    };
    TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex = function () {
        var lastExplicitIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 1];
        return this.RULE_OCCURRENCE_STACK[lastExplicitIndex];
    };
    TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndexNoCst = function () {
        var occurrenceStack = this.RULE_OCCURRENCE_STACK;
        return occurrenceStack[occurrenceStack.length - 1];
    };
    TreeBuilder.prototype.nestedRuleInvocationStateUpdate = function (nestedRuleName, shortNameKey) {
        this.RULE_OCCURRENCE_STACK.push(1);
        this.RULE_STACK.push(shortNameKey);
        this.cstNestedInvocationStateUpdate(nestedRuleName, shortNameKey);
    };
    TreeBuilder.prototype.nestedRuleFinallyStateUpdate = function () {
        this.RULE_STACK.pop();
        this.RULE_OCCURRENCE_STACK.pop();
        // NOOP when cst is disabled
        this.cstNestedFinallyStateUpdate();
    };
    return TreeBuilder;
}());

//# sourceMappingURL=tree_builder.js.map

/***/ }),
/* 330 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export defaultVisit */
/* harmony export (immutable) */ __webpack_exports__["a"] = createBaseSemanticVisitorConstructor;
/* harmony export (immutable) */ __webpack_exports__["b"] = createBaseVisitorConstructorWithDefaults;
/* unused harmony export CstVisitorDefinitionError */
/* unused harmony export validateVisitor */
/* unused harmony export validateMissingCstMethods */
/* unused harmony export validateRedundantMethods */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lang_lang_extensions__ = __webpack_require__(221);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__grammar_checks__ = __webpack_require__(33);



function defaultVisit(ctx, param) {
    var childrenNames = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["G" /* keys */])(ctx);
    var childrenNamesLength = childrenNames.length;
    for (var i = 0; i < childrenNamesLength; i++) {
        var currChildName = childrenNames[i];
        var currChildArray = ctx[currChildName];
        var currChildArrayLength = currChildArray.length;
        for (var j = 0; j < currChildArrayLength; j++) {
            var currChild = currChildArray[j];
            // distinction between Tokens Children and CstNode children
            if (currChild.tokenTypeIdx === undefined) {
                if (currChild.fullName !== undefined) {
                    this[currChild.fullName](currChild.children, param);
                }
                else {
                    this[currChild.name](currChild.children, param);
                }
            }
        }
    }
    // defaultVisit does not support generic out param
    return undefined;
}
function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {
    var derivedConstructor = function () { };
    // can be overwritten according to:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/
    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname
    Object(__WEBPACK_IMPORTED_MODULE_1__lang_lang_extensions__["b" /* defineNameProp */])(derivedConstructor, grammarName + "BaseSemantics");
    var semanticProto = {
        visit: function (cstNode, param) {
            // enables writing more concise visitor methods when CstNode has only a single child
            if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["y" /* isArray */])(cstNode)) {
                // A CST Node's children dictionary can never have empty arrays as values
                // If a key is defined there will be at least one element in the corresponding value array.
                cstNode = cstNode[0];
            }
            // enables passing optional CstNodes concisely.
            if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["F" /* isUndefined */])(cstNode)) {
                return undefined;
            }
            if (cstNode.fullName !== undefined) {
                return this[cstNode.fullName](cstNode.children, param);
            }
            else {
                return this[cstNode.name](cstNode.children, param);
            }
        },
        validateVisitor: function () {
            var semanticDefinitionErrors = validateVisitor(this, ruleNames);
            if (!Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["A" /* isEmpty */])(semanticDefinitionErrors)) {
                var errorMessages = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */])(semanticDefinitionErrors, function (currDefError) { return currDefError.msg; });
                throw Error("Errors Detected in CST Visitor <" + Object(__WEBPACK_IMPORTED_MODULE_1__lang_lang_extensions__["c" /* functionName */])(this.constructor) + ">:\n\t" +
                    ("" + errorMessages.join("\n\n").replace(/\n/g, "\n\t")));
            }
        }
    };
    derivedConstructor.prototype = semanticProto;
    derivedConstructor.prototype.constructor = derivedConstructor;
    derivedConstructor._RULE_NAMES = ruleNames;
    return derivedConstructor;
}
function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {
    var derivedConstructor = function () { };
    // can be overwritten according to:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/
    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname
    Object(__WEBPACK_IMPORTED_MODULE_1__lang_lang_extensions__["b" /* defineNameProp */])(derivedConstructor, grammarName + "BaseSemanticsWithDefaults");
    var withDefaultsProto = Object.create(baseConstructor.prototype);
    Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(ruleNames, function (ruleName) {
        withDefaultsProto[ruleName] = defaultVisit;
    });
    derivedConstructor.prototype = withDefaultsProto;
    derivedConstructor.prototype.constructor = derivedConstructor;
    return derivedConstructor;
}
var CstVisitorDefinitionError;
(function (CstVisitorDefinitionError) {
    CstVisitorDefinitionError[CstVisitorDefinitionError["REDUNDANT_METHOD"] = 0] = "REDUNDANT_METHOD";
    CstVisitorDefinitionError[CstVisitorDefinitionError["MISSING_METHOD"] = 1] = "MISSING_METHOD";
})(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}));
function validateVisitor(visitorInstance, ruleNames) {
    var missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);
    var redundantErrors = validateRedundantMethods(visitorInstance, ruleNames);
    return missingErrors.concat(redundantErrors);
}
function validateMissingCstMethods(visitorInstance, ruleNames) {
    var errors = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */])(ruleNames, function (currRuleName) {
        if (!Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["B" /* isFunction */])(visitorInstance[currRuleName])) {
            return {
                msg: "Missing visitor method: <" + currRuleName + "> on " + Object(__WEBPACK_IMPORTED_MODULE_1__lang_lang_extensions__["c" /* functionName */])(visitorInstance.constructor) + " CST Visitor.",
                type: CstVisitorDefinitionError.MISSING_METHOD,
                methodName: currRuleName
            };
        }
    });
    return Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["i" /* compact */])(errors);
}
var VALID_PROP_NAMES = ["constructor", "visit", "validateVisitor"];
function validateRedundantMethods(visitorInstance, ruleNames) {
    var errors = [];
    for (var prop in visitorInstance) {
        if (__WEBPACK_IMPORTED_MODULE_2__grammar_checks__["b" /* validTermsPattern */].test(prop) &&
            Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["B" /* isFunction */])(visitorInstance[prop]) &&
            !Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["j" /* contains */])(VALID_PROP_NAMES, prop) &&
            !Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["j" /* contains */])(ruleNames, prop)) {
            errors.push({
                msg: "Redundant visitor method: <" + prop + "> on " + Object(__WEBPACK_IMPORTED_MODULE_1__lang_lang_extensions__["c" /* functionName */])(visitorInstance.constructor) + " CST Visitor\n" +
                    "There is no Grammar Rule corresponding to this method's name.\n" +
                    ("For utility methods on visitor classes use methods names that do not match /" + __WEBPACK_IMPORTED_MODULE_2__grammar_checks__["b" /* validTermsPattern */].source + "/."),
                type: CstVisitorDefinitionError.REDUNDANT_METHOD,
                methodName: prop
            });
        }
    }
    return errors;
}
//# sourceMappingURL=cst_visitor.js.map

/***/ }),
/* 331 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LexerAdapter; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__parser__ = __webpack_require__(9);

/**
 * Trait responsible abstracting over the interaction with Lexer output (Token vector).
 *
 * This could be generalized to support other kinds of lexers, e.g.
 * - Just in Time Lexing / Lexer-Less parsing.
 * - Streaming Lexer.
 */
var LexerAdapter = /** @class */ (function () {
    function LexerAdapter() {
    }
    LexerAdapter.prototype.initLexerAdapter = function () {
        this.tokVector = [];
        this.tokVectorLength = 0;
        this.currIdx = -1;
    };
    Object.defineProperty(LexerAdapter.prototype, "input", {
        get: function () {
            return this.tokVector;
        },
        set: function (newInput) {
            if (this.selfAnalysisDone !== true) {
                throw Error("Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.");
            }
            this.reset();
            this.tokVector = newInput;
            this.tokVectorLength = newInput.length;
        },
        enumerable: true,
        configurable: true
    });
    // skips a token and returns the next token
    LexerAdapter.prototype.SKIP_TOKEN = function () {
        if (this.currIdx <= this.tokVector.length - 2) {
            this.consumeToken();
            return this.LA(1);
        }
        else {
            return __WEBPACK_IMPORTED_MODULE_0__parser__["e" /* END_OF_FILE */];
        }
    };
    // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers
    // or lexers dependent on parser context.
    LexerAdapter.prototype.LA = function (howMuch) {
        var soughtIdx = this.currIdx + howMuch;
        if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {
            return __WEBPACK_IMPORTED_MODULE_0__parser__["e" /* END_OF_FILE */];
        }
        else {
            return this.tokVector[soughtIdx];
        }
    };
    LexerAdapter.prototype.consumeToken = function () {
        this.currIdx++;
    };
    LexerAdapter.prototype.exportLexerState = function () {
        return this.currIdx;
    };
    LexerAdapter.prototype.importLexerState = function (newState) {
        this.currIdx = newState;
    };
    LexerAdapter.prototype.resetLexerState = function () {
        this.currIdx = -1;
    };
    LexerAdapter.prototype.moveToTerminatedState = function () {
        this.currIdx = this.tokVector.length - 1;
    };
    LexerAdapter.prototype.getLexerPosition = function () {
        return this.exportLexerState();
    };
    return LexerAdapter;
}());

//# sourceMappingURL=lexer_adapter.js.map

/***/ }),
/* 332 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RecognizerApi; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__exceptions_public__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__parser__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__errors_public__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__grammar_checks__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__grammar_gast_gast_public__ = __webpack_require__(6);






/**
 * This trait is responsible for implementing the public API
 * for defining Chevrotain parsers, i.e:
 * - CONSUME
 * - RULE
 * - OPTION
 * - ...
 */
var RecognizerApi = /** @class */ (function () {
    function RecognizerApi() {
    }
    RecognizerApi.prototype.ACTION = function (impl) {
        return impl.call(this);
    };
    RecognizerApi.prototype.consume = function (idx, tokType, options) {
        return this.consumeInternal(tokType, idx, options);
    };
    RecognizerApi.prototype.subrule = function (idx, ruleToCall, options) {
        return this.subruleInternal(ruleToCall, idx, options);
    };
    RecognizerApi.prototype.option = function (idx, actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, idx);
    };
    RecognizerApi.prototype.or = function (idx, altsOrOpts) {
        return this.orInternal(altsOrOpts, idx);
    };
    RecognizerApi.prototype.many = function (idx, actionORMethodDef) {
        return this.manyInternal(idx, actionORMethodDef);
    };
    RecognizerApi.prototype.atLeastOne = function (idx, actionORMethodDef) {
        return this.atLeastOneInternal(idx, actionORMethodDef);
    };
    RecognizerApi.prototype.CONSUME = function (tokType, options) {
        return this.consumeInternal(tokType, 0, options);
    };
    RecognizerApi.prototype.CONSUME1 = function (tokType, options) {
        return this.consumeInternal(tokType, 1, options);
    };
    RecognizerApi.prototype.CONSUME2 = function (tokType, options) {
        return this.consumeInternal(tokType, 2, options);
    };
    RecognizerApi.prototype.CONSUME3 = function (tokType, options) {
        return this.consumeInternal(tokType, 3, options);
    };
    RecognizerApi.prototype.CONSUME4 = function (tokType, options) {
        return this.consumeInternal(tokType, 4, options);
    };
    RecognizerApi.prototype.CONSUME5 = function (tokType, options) {
        return this.consumeInternal(tokType, 5, options);
    };
    RecognizerApi.prototype.CONSUME6 = function (tokType, options) {
        return this.consumeInternal(tokType, 6, options);
    };
    RecognizerApi.prototype.CONSUME7 = function (tokType, options) {
        return this.consumeInternal(tokType, 7, options);
    };
    RecognizerApi.prototype.CONSUME8 = function (tokType, options) {
        return this.consumeInternal(tokType, 8, options);
    };
    RecognizerApi.prototype.CONSUME9 = function (tokType, options) {
        return this.consumeInternal(tokType, 9, options);
    };
    RecognizerApi.prototype.SUBRULE = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 0, options);
    };
    RecognizerApi.prototype.SUBRULE1 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 1, options);
    };
    RecognizerApi.prototype.SUBRULE2 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 2, options);
    };
    RecognizerApi.prototype.SUBRULE3 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 3, options);
    };
    RecognizerApi.prototype.SUBRULE4 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 4, options);
    };
    RecognizerApi.prototype.SUBRULE5 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 5, options);
    };
    RecognizerApi.prototype.SUBRULE6 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 6, options);
    };
    RecognizerApi.prototype.SUBRULE7 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 7, options);
    };
    RecognizerApi.prototype.SUBRULE8 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 8, options);
    };
    RecognizerApi.prototype.SUBRULE9 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 9, options);
    };
    RecognizerApi.prototype.OPTION = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 0);
    };
    RecognizerApi.prototype.OPTION1 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 1);
    };
    RecognizerApi.prototype.OPTION2 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 2);
    };
    RecognizerApi.prototype.OPTION3 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 3);
    };
    RecognizerApi.prototype.OPTION4 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 4);
    };
    RecognizerApi.prototype.OPTION5 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 5);
    };
    RecognizerApi.prototype.OPTION6 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 6);
    };
    RecognizerApi.prototype.OPTION7 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 7);
    };
    RecognizerApi.prototype.OPTION8 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 8);
    };
    RecognizerApi.prototype.OPTION9 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 9);
    };
    RecognizerApi.prototype.OR = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 0);
    };
    RecognizerApi.prototype.OR1 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 1);
    };
    RecognizerApi.prototype.OR2 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 2);
    };
    RecognizerApi.prototype.OR3 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 3);
    };
    RecognizerApi.prototype.OR4 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 4);
    };
    RecognizerApi.prototype.OR5 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 5);
    };
    RecognizerApi.prototype.OR6 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 6);
    };
    RecognizerApi.prototype.OR7 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 7);
    };
    RecognizerApi.prototype.OR8 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 8);
    };
    RecognizerApi.prototype.OR9 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 9);
    };
    RecognizerApi.prototype.MANY = function (actionORMethodDef) {
        this.manyInternal(0, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY1 = function (actionORMethodDef) {
        this.manyInternal(1, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY2 = function (actionORMethodDef) {
        this.manyInternal(2, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY3 = function (actionORMethodDef) {
        this.manyInternal(3, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY4 = function (actionORMethodDef) {
        this.manyInternal(4, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY5 = function (actionORMethodDef) {
        this.manyInternal(5, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY6 = function (actionORMethodDef) {
        this.manyInternal(6, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY7 = function (actionORMethodDef) {
        this.manyInternal(7, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY8 = function (actionORMethodDef) {
        this.manyInternal(8, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY9 = function (actionORMethodDef) {
        this.manyInternal(9, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY_SEP = function (options) {
        this.manySepFirstInternal(0, options);
    };
    RecognizerApi.prototype.MANY_SEP1 = function (options) {
        this.manySepFirstInternal(1, options);
    };
    RecognizerApi.prototype.MANY_SEP2 = function (options) {
        this.manySepFirstInternal(2, options);
    };
    RecognizerApi.prototype.MANY_SEP3 = function (options) {
        this.manySepFirstInternal(3, options);
    };
    RecognizerApi.prototype.MANY_SEP4 = function (options) {
        this.manySepFirstInternal(4, options);
    };
    RecognizerApi.prototype.MANY_SEP5 = function (options) {
        this.manySepFirstInternal(5, options);
    };
    RecognizerApi.prototype.MANY_SEP6 = function (options) {
        this.manySepFirstInternal(6, options);
    };
    RecognizerApi.prototype.MANY_SEP7 = function (options) {
        this.manySepFirstInternal(7, options);
    };
    RecognizerApi.prototype.MANY_SEP8 = function (options) {
        this.manySepFirstInternal(8, options);
    };
    RecognizerApi.prototype.MANY_SEP9 = function (options) {
        this.manySepFirstInternal(9, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE = function (actionORMethodDef) {
        this.atLeastOneInternal(0, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE1 = function (actionORMethodDef) {
        return this.atLeastOneInternal(1, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE2 = function (actionORMethodDef) {
        this.atLeastOneInternal(2, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE3 = function (actionORMethodDef) {
        this.atLeastOneInternal(3, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE4 = function (actionORMethodDef) {
        this.atLeastOneInternal(4, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE5 = function (actionORMethodDef) {
        this.atLeastOneInternal(5, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE6 = function (actionORMethodDef) {
        this.atLeastOneInternal(6, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE7 = function (actionORMethodDef) {
        this.atLeastOneInternal(7, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE8 = function (actionORMethodDef) {
        this.atLeastOneInternal(8, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE9 = function (actionORMethodDef) {
        this.atLeastOneInternal(9, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP = function (options) {
        this.atLeastOneSepFirstInternal(0, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP1 = function (options) {
        this.atLeastOneSepFirstInternal(1, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP2 = function (options) {
        this.atLeastOneSepFirstInternal(2, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP3 = function (options) {
        this.atLeastOneSepFirstInternal(3, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP4 = function (options) {
        this.atLeastOneSepFirstInternal(4, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP5 = function (options) {
        this.atLeastOneSepFirstInternal(5, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP6 = function (options) {
        this.atLeastOneSepFirstInternal(6, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP7 = function (options) {
        this.atLeastOneSepFirstInternal(7, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP8 = function (options) {
        this.atLeastOneSepFirstInternal(8, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP9 = function (options) {
        this.atLeastOneSepFirstInternal(9, options);
    };
    RecognizerApi.prototype.RULE = function (name, implementation, config) {
        if (config === void 0) { config = __WEBPACK_IMPORTED_MODULE_2__parser__["c" /* DEFAULT_RULE_CONFIG */]; }
        if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["j" /* contains */])(this.definedRulesNames, name)) {
            var errMsg = __WEBPACK_IMPORTED_MODULE_3__errors_public__["b" /* defaultGrammarValidatorErrorProvider */].buildDuplicateRuleNameError({
                topLevelRule: name,
                grammarName: this.className
            });
            var error = {
                message: errMsg,
                type: __WEBPACK_IMPORTED_MODULE_2__parser__["h" /* ParserDefinitionErrorType */].DUPLICATE_RULE_NAME,
                ruleName: name
            };
            this.definitionErrors.push(error);
        }
        this.definedRulesNames.push(name);
        var ruleImplementation = this.defineRule(name, implementation, config);
        this[name] = ruleImplementation;
        return ruleImplementation;
    };
    RecognizerApi.prototype.OVERRIDE_RULE = function (name, impl, config) {
        if (config === void 0) { config = __WEBPACK_IMPORTED_MODULE_2__parser__["c" /* DEFAULT_RULE_CONFIG */]; }
        var ruleErrors = [];
        ruleErrors = ruleErrors.concat(Object(__WEBPACK_IMPORTED_MODULE_4__grammar_checks__["d" /* validateRuleIsOverridden */])(name, this.definedRulesNames, this.className));
        this.definitionErrors.push.apply(this.definitionErrors, ruleErrors); // mutability for the win
        var ruleImplementation = this.defineRule(name, impl, config);
        this[name] = ruleImplementation;
        return ruleImplementation;
    };
    RecognizerApi.prototype.BACKTRACK = function (grammarRule, args) {
        return function () {
            // save org state
            this.isBackTrackingStack.push(1);
            var orgState = this.saveRecogState();
            try {
                grammarRule.apply(this, args);
                // if no exception was thrown we have succeed parsing the rule.
                return true;
            }
            catch (e) {
                if (Object(__WEBPACK_IMPORTED_MODULE_1__exceptions_public__["e" /* isRecognitionException */])(e)) {
                    return false;
                }
                else {
                    throw e;
                }
            }
            finally {
                this.reloadRecogState(orgState);
                this.isBackTrackingStack.pop();
            }
        };
    };
    // GAST export APIs
    RecognizerApi.prototype.getGAstProductions = function () {
        return this.gastProductionsCache;
    };
    RecognizerApi.prototype.getSerializedGastProductions = function () {
        return Object(__WEBPACK_IMPORTED_MODULE_5__grammar_gast_gast_public__["l" /* serializeGrammar */])(Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["U" /* values */])(this.gastProductionsCache));
    };
    return RecognizerApi;
}());

//# sourceMappingURL=recognizer_api.js.map

/***/ }),
/* 333 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RecognizerEngine; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__grammar_keys__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__exceptions_public__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__grammar_lookahead__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__grammar_interpreter__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__parser__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__recoverable__ = __webpack_require__(220);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__scan_tokens_public__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__scan_tokens__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__lang_lang_extensions__ = __webpack_require__(221);










/**
 * This trait is responsible for the runtime parsing engine
 * Used by the official API (recognizer_api.ts)
 */
var RecognizerEngine = /** @class */ (function () {
    function RecognizerEngine() {
    }
    RecognizerEngine.prototype.initRecognizerEngine = function (tokenVocabulary, config) {
        this.className = Object(__WEBPACK_IMPORTED_MODULE_9__lang_lang_extensions__["a" /* classNameFromInstance */])(this);
        // TODO: would using an ES6 Map or plain object be faster (CST building scenario)
        this.shortRuleNameToFull = {};
        this.fullRuleNameToShort = {};
        this.ruleShortNameIdx = 256;
        this.tokenMatcher = __WEBPACK_IMPORTED_MODULE_8__scan_tokens__["e" /* tokenStructuredMatcherNoCategories */];
        this.definedRulesNames = [];
        this.tokensMap = {};
        this.allRuleNames = [];
        this.isBackTrackingStack = [];
        this.RULE_STACK = [];
        this.RULE_OCCURRENCE_STACK = [];
        this.gastProductionsCache = {};
        if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(config, "serializedGrammar")) {
            throw Error("The Parser's configuration can no longer contain a <serializedGrammar> property.\n" +
                "\tSee: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_6-0-0\n" +
                "\tFor Further details.");
        }
        if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["y" /* isArray */])(tokenVocabulary)) {
            // This only checks for Token vocabularies provided as arrays.
            // That is good enough because the main objective is to detect users of pre-V4.0 APIs
            // rather than all edge cases of empty Token vocabularies.
            if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["A" /* isEmpty */])(tokenVocabulary)) {
                throw Error("A Token Vocabulary cannot be empty.\n" +
                    "\tNote that the first argument for the parser constructor\n" +
                    "\tis no longer a Token vector (since v4.0).");
            }
            if (typeof tokenVocabulary[0].startOffset === "number") {
                throw Error("The Parser constructor no longer accepts a token vector as the first argument.\n" +
                    "\tSee: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_4-0-0\n" +
                    "\tFor Further details.");
            }
        }
        if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["y" /* isArray */])(tokenVocabulary)) {
            this.tokensMap = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["O" /* reduce */])(tokenVocabulary, function (acc, tokType) {
                acc[tokType.name] = tokType;
                return acc;
            }, {});
        }
        else if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(tokenVocabulary, "modes") &&
            Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["o" /* every */])(Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["t" /* flatten */])(Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["U" /* values */])(tokenVocabulary.modes)), __WEBPACK_IMPORTED_MODULE_8__scan_tokens__["c" /* isTokenType */])) {
            var allTokenTypes = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["t" /* flatten */])(Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["U" /* values */])(tokenVocabulary.modes));
            var uniqueTokens = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["T" /* uniq */])(allTokenTypes);
            this.tokensMap = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["O" /* reduce */])(uniqueTokens, function (acc, tokType) {
                acc[tokType.name] = tokType;
                return acc;
            }, {});
        }
        else if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["C" /* isObject */])(tokenVocabulary)) {
            this.tokensMap = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["h" /* cloneObj */])(tokenVocabulary);
        }
        else {
            throw new Error("<tokensDictionary> argument must be An Array of Token constructors," +
                " A dictionary of Token constructors or an IMultiModeLexerDefinition");
        }
        // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been
        // parsed with a clear error message ("expecting EOF but found ...")
        /* tslint:disable */
        this.tokensMap["EOF"] = __WEBPACK_IMPORTED_MODULE_7__scan_tokens_public__["a" /* EOF */];
        // TODO: This check may not be accurate for multi mode lexers
        var noTokenCategoriesUsed = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["o" /* every */])(Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["U" /* values */])(tokenVocabulary), function (tokenConstructor) { return Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["A" /* isEmpty */])(tokenConstructor.categoryMatches); });
        this.tokenMatcher = noTokenCategoriesUsed
            ? __WEBPACK_IMPORTED_MODULE_8__scan_tokens__["e" /* tokenStructuredMatcherNoCategories */]
            : __WEBPACK_IMPORTED_MODULE_8__scan_tokens__["d" /* tokenStructuredMatcher */];
        // Because ES2015+ syntax should be supported for creating Token classes
        // We cannot assume that the Token classes were created using the "extendToken" utilities
        // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization
        Object(__WEBPACK_IMPORTED_MODULE_8__scan_tokens__["a" /* augmentTokenTypes */])(Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["U" /* values */])(this.tokensMap));
    };
    RecognizerEngine.prototype.defineRule = function (ruleName, impl, config) {
        if (this.selfAnalysisDone) {
            throw Error("Grammar rule <" + ruleName + "> may not be defined after the 'performSelfAnalysis' method has been called'\n" +
                "Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.");
        }
        var resyncEnabled = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(config, "resyncEnabled")
            ? config.resyncEnabled
            : __WEBPACK_IMPORTED_MODULE_5__parser__["c" /* DEFAULT_RULE_CONFIG */].resyncEnabled;
        var recoveryValueFunc = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(config, "recoveryValueFunc")
            ? config.recoveryValueFunc
            : __WEBPACK_IMPORTED_MODULE_5__parser__["c" /* DEFAULT_RULE_CONFIG */].recoveryValueFunc;
        // performance optimization: Use small integers as keys for the longer human readable "full" rule names.
        // this greatly improves Map access time (as much as 8% for some performance benchmarks).
        /* tslint:disable */
        var shortName = this.ruleShortNameIdx <<
            (__WEBPACK_IMPORTED_MODULE_1__grammar_keys__["c" /* BITS_FOR_METHOD_TYPE */] + __WEBPACK_IMPORTED_MODULE_1__grammar_keys__["d" /* BITS_FOR_OCCURRENCE_IDX */]);
        /* tslint:enable */
        this.ruleShortNameIdx++;
        this.shortRuleNameToFull[shortName] = ruleName;
        this.fullRuleNameToShort[ruleName] = shortName;
        function invokeRuleWithTry(args) {
            try {
                if (this.outputCst === true) {
                    impl.apply(this, args);
                    var cst = this.CST_STACK[this.CST_STACK.length - 1];
                    this.cstPostRule(cst);
                    return cst;
                }
                else {
                    return impl.apply(this, args);
                }
            }
            catch (e) {
                return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
            }
            finally {
                this.ruleFinallyStateUpdate();
            }
        }
        var wrappedGrammarRule;
        wrappedGrammarRule = function (idxInCallingRule, args) {
            if (idxInCallingRule === void 0) { idxInCallingRule = 0; }
            this.ruleInvocationStateUpdate(shortName, ruleName, idxInCallingRule);
            return invokeRuleWithTry.call(this, args);
        };
        var ruleNamePropName = "ruleName";
        wrappedGrammarRule[ruleNamePropName] = ruleName;
        wrappedGrammarRule["originalGrammarAction"] = impl;
        return wrappedGrammarRule;
    };
    RecognizerEngine.prototype.invokeRuleCatch = function (e, resyncEnabledConfig, recoveryValueFunc) {
        var isFirstInvokedRule = this.RULE_STACK.length === 1;
        // note the reSync is always enabled for the first rule invocation, because we must always be able to
        // reSync with EOF and just output some INVALID ParseTree
        // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking
        // path is really the most valid one
        var reSyncEnabled = resyncEnabledConfig &&
            !this.isBackTracking() &&
            this.recoveryEnabled;
        if (Object(__WEBPACK_IMPORTED_MODULE_2__exceptions_public__["e" /* isRecognitionException */])(e)) {
            var recogError = e;
            if (reSyncEnabled) {
                var reSyncTokType = this.findReSyncTokenType();
                if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {
                    recogError.resyncedTokens = this.reSyncTo(reSyncTokType);
                    if (this.outputCst) {
                        var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                        partialCstResult.recoveredNode = true;
                        return partialCstResult;
                    }
                    else {
                        return recoveryValueFunc();
                    }
                }
                else {
                    if (this.outputCst) {
                        var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                        partialCstResult.recoveredNode = true;
                        recogError.partialCstResult = partialCstResult;
                    }
                    // to be handled Further up the call stack
                    throw recogError;
                }
            }
            else if (isFirstInvokedRule) {
                // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case
                this.moveToTerminatedState();
                // the parser should never throw one of its own errors outside its flow.
                // even if error recovery is disabled
                return recoveryValueFunc();
            }
            else {
                // to be recovered Further up the call stack
                throw recogError;
            }
        }
        else {
            // some other Error type which we don't know how to handle (for example a built in JavaScript Error)
            throw e;
        }
    };
    // Implementation of parsing DSL
    RecognizerEngine.prototype.optionInternal = function (actionORMethodDef, occurrence) {
        var key = this.getKeyForAutomaticLookahead(__WEBPACK_IMPORTED_MODULE_1__grammar_keys__["g" /* OPTION_IDX */], occurrence);
        var nestedName = this.nestedRuleBeforeClause(actionORMethodDef, key);
        try {
            return this.optionInternalLogic(actionORMethodDef, occurrence, key);
        }
        finally {
            if (nestedName !== undefined) {
                this.nestedRuleFinallyClause(key, nestedName);
            }
        }
    };
    RecognizerEngine.prototype.optionInternalNoCst = function (actionORMethodDef, occurrence) {
        var key = this.getKeyForAutomaticLookahead(__WEBPACK_IMPORTED_MODULE_1__grammar_keys__["g" /* OPTION_IDX */], occurrence);
        return this.optionInternalLogic(actionORMethodDef, occurrence, key);
    };
    RecognizerEngine.prototype.optionInternalLogic = function (actionORMethodDef, occurrence, key) {
        var _this = this;
        var lookAheadFunc = this.getLaFuncFromCache(key);
        var action;
        var predicate;
        if (actionORMethodDef.DEF !== undefined) {
            action = actionORMethodDef.DEF;
            predicate = actionORMethodDef.GATE;
            // predicate present
            if (predicate !== undefined) {
                var orgLookaheadFunction_1 = lookAheadFunc;
                lookAheadFunc = function () {
                    return (predicate.call(_this) && orgLookaheadFunction_1.call(_this));
                };
            }
        }
        else {
            action = actionORMethodDef;
        }
        if (lookAheadFunc.call(this) === true) {
            return action.call(this);
        }
        return undefined;
    };
    RecognizerEngine.prototype.atLeastOneInternal = function (prodOccurrence, actionORMethodDef) {
        var laKey = this.getKeyForAutomaticLookahead(__WEBPACK_IMPORTED_MODULE_1__grammar_keys__["a" /* AT_LEAST_ONE_IDX */], prodOccurrence);
        var nestedName = this.nestedRuleBeforeClause(actionORMethodDef, laKey);
        try {
            return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);
        }
        finally {
            if (nestedName !== undefined) {
                this.nestedRuleFinallyClause(laKey, nestedName);
            }
        }
    };
    RecognizerEngine.prototype.atLeastOneInternalNoCst = function (prodOccurrence, actionORMethodDef) {
        var key = this.getKeyForAutomaticLookahead(__WEBPACK_IMPORTED_MODULE_1__grammar_keys__["a" /* AT_LEAST_ONE_IDX */], prodOccurrence);
        this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key);
    };
    RecognizerEngine.prototype.atLeastOneInternalLogic = function (prodOccurrence, actionORMethodDef, key) {
        var _this = this;
        var lookAheadFunc = this.getLaFuncFromCache(key);
        var action;
        var predicate;
        if (actionORMethodDef.DEF !== undefined) {
            action = actionORMethodDef.DEF;
            predicate = actionORMethodDef.GATE;
            // predicate present
            if (predicate !== undefined) {
                var orgLookaheadFunction_2 = lookAheadFunc;
                lookAheadFunc = function () {
                    return (predicate.call(_this) && orgLookaheadFunction_2.call(_this));
                };
            }
        }
        else {
            action = actionORMethodDef;
        }
        if (lookAheadFunc.call(this) === true) {
            var notStuck = this.doSingleRepetition(action);
            while (lookAheadFunc.call(this) === true &&
                notStuck === true) {
                notStuck = this.doSingleRepetition(action);
            }
        }
        else {
            throw this.raiseEarlyExitException(prodOccurrence, __WEBPACK_IMPORTED_MODULE_3__grammar_lookahead__["a" /* PROD_TYPE */].REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);
        }
        // note that while it may seem that this can cause an error because by using a recursive call to
        // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call
        // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.
        // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled
        this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, __WEBPACK_IMPORTED_MODULE_1__grammar_keys__["a" /* AT_LEAST_ONE_IDX */], prodOccurrence, __WEBPACK_IMPORTED_MODULE_4__grammar_interpreter__["c" /* NextTerminalAfterAtLeastOneWalker */]);
    };
    RecognizerEngine.prototype.atLeastOneSepFirstInternal = function (prodOccurrence, options) {
        var laKey = this.getKeyForAutomaticLookahead(__WEBPACK_IMPORTED_MODULE_1__grammar_keys__["b" /* AT_LEAST_ONE_SEP_IDX */], prodOccurrence);
        var nestedName = this.nestedRuleBeforeClause(options, laKey);
        try {
            this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);
        }
        finally {
            if (nestedName !== undefined) {
                this.nestedRuleFinallyClause(laKey, nestedName);
            }
        }
    };
    RecognizerEngine.prototype.atLeastOneSepFirstInternalNoCst = function (prodOccurrence, options) {
        var laKey = this.getKeyForAutomaticLookahead(__WEBPACK_IMPORTED_MODULE_1__grammar_keys__["b" /* AT_LEAST_ONE_SEP_IDX */], prodOccurrence);
        this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);
    };
    RecognizerEngine.prototype.atLeastOneSepFirstInternalLogic = function (prodOccurrence, options, key) {
        var _this = this;
        var action = options.DEF;
        var separator = options.SEP;
        var firstIterationLookaheadFunc = this.getLaFuncFromCache(key);
        // 1st iteration
        if (firstIterationLookaheadFunc.call(this) === true) {
            ;
            action.call(this);
            //  TODO: Optimization can move this function construction into "attemptInRepetitionRecovery"
            //  because it is only needed in error recovery scenarios.
            var separatorLookAheadFunc = function () {
                return _this.tokenMatcher(_this.LA(1), separator);
            };
            // 2nd..nth iterations
            while (this.tokenMatcher(this.LA(1), separator) === true) {
                // note that this CONSUME will never enter recovery because
                // the separatorLookAheadFunc checks that the separator really does exist.
                this.CONSUME(separator);
                action.call(this);
            }
            // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
                prodOccurrence,
                separator,
                separatorLookAheadFunc,
                action,
                __WEBPACK_IMPORTED_MODULE_4__grammar_interpreter__["b" /* NextTerminalAfterAtLeastOneSepWalker */]
            ], separatorLookAheadFunc, __WEBPACK_IMPORTED_MODULE_1__grammar_keys__["b" /* AT_LEAST_ONE_SEP_IDX */], prodOccurrence, __WEBPACK_IMPORTED_MODULE_4__grammar_interpreter__["b" /* NextTerminalAfterAtLeastOneSepWalker */]);
        }
        else {
            throw this.raiseEarlyExitException(prodOccurrence, __WEBPACK_IMPORTED_MODULE_3__grammar_lookahead__["a" /* PROD_TYPE */].REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);
        }
    };
    RecognizerEngine.prototype.manyInternal = function (prodOccurrence, actionORMethodDef) {
        var laKey = this.getKeyForAutomaticLookahead(__WEBPACK_IMPORTED_MODULE_1__grammar_keys__["e" /* MANY_IDX */], prodOccurrence);
        var nestedName = this.nestedRuleBeforeClause(actionORMethodDef, laKey);
        try {
            return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);
        }
        finally {
            if (nestedName !== undefined) {
                this.nestedRuleFinallyClause(laKey, nestedName);
            }
        }
    };
    RecognizerEngine.prototype.manyInternalNoCst = function (prodOccurrence, actionORMethodDef) {
        var laKey = this.getKeyForAutomaticLookahead(__WEBPACK_IMPORTED_MODULE_1__grammar_keys__["e" /* MANY_IDX */], prodOccurrence);
        return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);
    };
    RecognizerEngine.prototype.manyInternalLogic = function (prodOccurrence, actionORMethodDef, key) {
        var _this = this;
        var lookaheadFunction = this.getLaFuncFromCache(key);
        var action;
        var predicate;
        if (actionORMethodDef.DEF !== undefined) {
            action = actionORMethodDef.DEF;
            predicate = actionORMethodDef.GATE;
            // predicate present
            if (predicate !== undefined) {
                var orgLookaheadFunction_3 = lookaheadFunction;
                lookaheadFunction = function () {
                    return (predicate.call(_this) && orgLookaheadFunction_3.call(_this));
                };
            }
        }
        else {
            action = actionORMethodDef;
        }
        var notStuck = true;
        while (lookaheadFunction.call(this) === true && notStuck === true) {
            notStuck = this.doSingleRepetition(action);
        }
        // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled
        this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, __WEBPACK_IMPORTED_MODULE_1__grammar_keys__["e" /* MANY_IDX */], prodOccurrence, __WEBPACK_IMPORTED_MODULE_4__grammar_interpreter__["e" /* NextTerminalAfterManyWalker */], 
        // The notStuck parameter is only relevant when "attemptInRepetitionRecovery"
        // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]
        // An infinite loop cannot occur as:
        // - Either the lookahead is guaranteed to consume something (Single Token Separator)
        // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).
        notStuck);
    };
    RecognizerEngine.prototype.manySepFirstInternal = function (prodOccurrence, options) {
        var laKey = this.getKeyForAutomaticLookahead(__WEBPACK_IMPORTED_MODULE_1__grammar_keys__["f" /* MANY_SEP_IDX */], prodOccurrence);
        var nestedName = this.nestedRuleBeforeClause(options, laKey);
        try {
            this.manySepFirstInternalLogic(prodOccurrence, options, laKey);
        }
        finally {
            if (nestedName !== undefined) {
                this.nestedRuleFinallyClause(laKey, nestedName);
            }
        }
    };
    RecognizerEngine.prototype.manySepFirstInternalNoCst = function (prodOccurrence, options) {
        var laKey = this.getKeyForAutomaticLookahead(__WEBPACK_IMPORTED_MODULE_1__grammar_keys__["f" /* MANY_SEP_IDX */], prodOccurrence);
        this.manySepFirstInternalLogic(prodOccurrence, options, laKey);
    };
    RecognizerEngine.prototype.manySepFirstInternalLogic = function (prodOccurrence, options, key) {
        var _this = this;
        var action = options.DEF;
        var separator = options.SEP;
        var firstIterationLaFunc = this.getLaFuncFromCache(key);
        // 1st iteration
        if (firstIterationLaFunc.call(this) === true) {
            action.call(this);
            var separatorLookAheadFunc = function () {
                return _this.tokenMatcher(_this.LA(1), separator);
            };
            // 2nd..nth iterations
            while (this.tokenMatcher(this.LA(1), separator) === true) {
                // note that this CONSUME will never enter recovery because
                // the separatorLookAheadFunc checks that the separator really does exist.
                this.CONSUME(separator);
                // No need for checking infinite loop here due to consuming the separator.
                action.call(this);
            }
            // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
                prodOccurrence,
                separator,
                separatorLookAheadFunc,
                action,
                __WEBPACK_IMPORTED_MODULE_4__grammar_interpreter__["d" /* NextTerminalAfterManySepWalker */]
            ], separatorLookAheadFunc, __WEBPACK_IMPORTED_MODULE_1__grammar_keys__["f" /* MANY_SEP_IDX */], prodOccurrence, __WEBPACK_IMPORTED_MODULE_4__grammar_interpreter__["d" /* NextTerminalAfterManySepWalker */]);
        }
    };
    RecognizerEngine.prototype.repetitionSepSecondInternal = function (prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {
        while (separatorLookAheadFunc()) {
            // note that this CONSUME will never enter recovery because
            // the separatorLookAheadFunc checks that the separator really does exist.
            this.CONSUME(separator);
            action.call(this);
        }
        // we can only arrive to this function after an error
        // has occurred (hence the name 'second') so the following
        // IF will always be entered, its possible to remove it...
        // however it is kept to avoid confusion and be consistent.
        // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled
        /* istanbul ignore else */
        this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
            prodOccurrence,
            separator,
            separatorLookAheadFunc,
            action,
            nextTerminalAfterWalker
        ], separatorLookAheadFunc, __WEBPACK_IMPORTED_MODULE_1__grammar_keys__["b" /* AT_LEAST_ONE_SEP_IDX */], prodOccurrence, nextTerminalAfterWalker);
    };
    RecognizerEngine.prototype.doSingleRepetition = function (action) {
        var beforeIteration = this.getLexerPosition();
        action.call(this);
        var afterIteration = this.getLexerPosition();
        // This boolean will indicate if this repetition progressed
        // or if we are "stuck" (potential infinite loop in the repetition).
        return afterIteration > beforeIteration;
    };
    RecognizerEngine.prototype.orInternalNoCst = function (altsOrOpts, occurrence) {
        var alts = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["y" /* isArray */])(altsOrOpts)
            ? altsOrOpts
            : altsOrOpts.DEF;
        var laKey = this.getKeyForAutomaticLookahead(__WEBPACK_IMPORTED_MODULE_1__grammar_keys__["h" /* OR_IDX */], occurrence);
        var laFunc = this.getLaFuncFromCache(laKey);
        var altIdxToTake = laFunc.call(this, alts);
        if (altIdxToTake !== undefined) {
            var chosenAlternative = alts[altIdxToTake];
            return chosenAlternative.ALT.call(this);
        }
        this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);
    };
    RecognizerEngine.prototype.orInternal = function (altsOrOpts, occurrence) {
        var laKey = this.getKeyForAutomaticLookahead(__WEBPACK_IMPORTED_MODULE_1__grammar_keys__["h" /* OR_IDX */], occurrence);
        var nestedName = this.nestedRuleBeforeClause(altsOrOpts, laKey);
        try {
            var alts = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["y" /* isArray */])(altsOrOpts)
                ? altsOrOpts
                : altsOrOpts.DEF;
            var laFunc = this.getLaFuncFromCache(laKey);
            var altIdxToTake = laFunc.call(this, alts);
            if (altIdxToTake !== undefined) {
                var chosenAlternative = alts[altIdxToTake];
                var nestedAltBeforeClauseResult = this.nestedAltBeforeClause(chosenAlternative, occurrence, __WEBPACK_IMPORTED_MODULE_1__grammar_keys__["h" /* OR_IDX */], altIdxToTake);
                try {
                    return chosenAlternative.ALT.call(this);
                }
                finally {
                    if (nestedAltBeforeClauseResult !== undefined) {
                        this.nestedRuleFinallyClause(nestedAltBeforeClauseResult.shortName, nestedAltBeforeClauseResult.nestedName);
                    }
                }
            }
            this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);
        }
        finally {
            if (nestedName !== undefined) {
                this.nestedRuleFinallyClause(laKey, nestedName);
            }
        }
    };
    RecognizerEngine.prototype.ruleFinallyStateUpdate = function () {
        this.RULE_STACK.pop();
        this.RULE_OCCURRENCE_STACK.pop();
        // NOOP when cst is disabled
        this.cstFinallyStateUpdate();
        if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {
            var firstRedundantTok = this.LA(1);
            var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({
                firstRedundant: firstRedundantTok,
                ruleName: this.getCurrRuleFullName()
            });
            this.SAVE_ERROR(new __WEBPACK_IMPORTED_MODULE_2__exceptions_public__["d" /* NotAllInputParsedException */](errMsg, firstRedundantTok));
        }
    };
    RecognizerEngine.prototype.subruleInternal = function (ruleToCall, idx, options) {
        var ruleResult;
        try {
            var args = options !== undefined ? options.ARGS : undefined;
            ruleResult = ruleToCall.call(this, idx, args);
            this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined
                ? options.LABEL
                : ruleToCall.ruleName);
            return ruleResult;
        }
        catch (e) {
            this.subruleInternalError(e, options, ruleToCall.ruleName);
        }
    };
    RecognizerEngine.prototype.subruleInternalError = function (e, options, ruleName) {
        if (Object(__WEBPACK_IMPORTED_MODULE_2__exceptions_public__["e" /* isRecognitionException */])(e) && e.partialCstResult !== undefined) {
            this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined
                ? options.LABEL
                : ruleName);
            delete e.partialCstResult;
        }
        throw e;
    };
    RecognizerEngine.prototype.consumeInternal = function (tokType, idx, options) {
        var consumedToken;
        try {
            var nextToken = this.LA(1);
            if (this.tokenMatcher(nextToken, tokType) === true) {
                this.consumeToken();
                consumedToken = nextToken;
            }
            else {
                this.consumeInternalError(tokType, nextToken, options);
            }
        }
        catch (eFromConsumption) {
            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);
        }
        this.cstPostTerminal(options !== undefined && options.LABEL !== undefined
            ? options.LABEL
            : tokType.name, consumedToken);
        return consumedToken;
    };
    RecognizerEngine.prototype.consumeInternalError = function (tokType, nextToken, options) {
        var msg;
        var previousToken = this.LA(0);
        if (options !== undefined && options.ERR_MSG) {
            msg = options.ERR_MSG;
        }
        else {
            msg = this.errorMessageProvider.buildMismatchTokenMessage({
                expected: tokType,
                actual: nextToken,
                previous: previousToken,
                ruleName: this.getCurrRuleFullName()
            });
        }
        throw this.SAVE_ERROR(new __WEBPACK_IMPORTED_MODULE_2__exceptions_public__["b" /* MismatchedTokenException */](msg, nextToken, previousToken));
    };
    RecognizerEngine.prototype.consumeInternalRecovery = function (tokType, idx, eFromConsumption) {
        // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it
        // but the original syntax could have been parsed successfully without any backtracking + recovery
        if (this.recoveryEnabled &&
            // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?
            eFromConsumption.name === "MismatchedTokenException" &&
            !this.isBackTracking()) {
            var follows = this.getFollowsForInRuleRecovery(tokType, idx);
            try {
                return this.tryInRuleRecovery(tokType, follows);
            }
            catch (eFromInRuleRecovery) {
                if (eFromInRuleRecovery.name === __WEBPACK_IMPORTED_MODULE_6__recoverable__["a" /* IN_RULE_RECOVERY_EXCEPTION */]) {
                    // failed in RuleRecovery.
                    // throw the original error in order to trigger reSync error recovery
                    throw eFromConsumption;
                }
                else {
                    throw eFromInRuleRecovery;
                }
            }
        }
        else {
            throw eFromConsumption;
        }
    };
    RecognizerEngine.prototype.saveRecogState = function () {
        // errors is a getter which will clone the errors array
        var savedErrors = this.errors;
        var savedRuleStack = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["g" /* cloneArr */])(this.RULE_STACK);
        return {
            errors: savedErrors,
            lexerState: this.exportLexerState(),
            RULE_STACK: savedRuleStack,
            CST_STACK: this.CST_STACK,
            LAST_EXPLICIT_RULE_STACK: this.LAST_EXPLICIT_RULE_STACK
        };
    };
    RecognizerEngine.prototype.reloadRecogState = function (newState) {
        this.errors = newState.errors;
        this.importLexerState(newState.lexerState);
        this.RULE_STACK = newState.RULE_STACK;
    };
    RecognizerEngine.prototype.ruleInvocationStateUpdate = function (shortName, fullName, idxInCallingRule) {
        this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);
        this.RULE_STACK.push(shortName);
        // NOOP when cst is disabled
        this.cstInvocationStateUpdate(fullName, shortName);
    };
    RecognizerEngine.prototype.isBackTracking = function () {
        return this.isBackTrackingStack.length !== 0;
    };
    RecognizerEngine.prototype.getCurrRuleFullName = function () {
        var shortName = this.getLastExplicitRuleShortName();
        return this.shortRuleNameToFull[shortName];
    };
    RecognizerEngine.prototype.shortRuleNameToFullName = function (shortName) {
        return this.shortRuleNameToFull[shortName];
    };
    RecognizerEngine.prototype.isAtEndOfInput = function () {
        return this.tokenMatcher(this.LA(1), __WEBPACK_IMPORTED_MODULE_7__scan_tokens_public__["a" /* EOF */]);
    };
    RecognizerEngine.prototype.reset = function () {
        this.resetLexerState();
        this.isBackTrackingStack = [];
        this.errors = [];
        this.RULE_STACK = [];
        this.LAST_EXPLICIT_RULE_STACK = [];
        // TODO: extract a specific rest for TreeBuilder trait
        this.CST_STACK = [];
        this.RULE_OCCURRENCE_STACK = [];
    };
    return RecognizerEngine;
}());

//# sourceMappingURL=recognizer_engine.js.map

/***/ }),
/* 334 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ErrorHandler; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__exceptions_public__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__grammar_lookahead__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__parser__ = __webpack_require__(9);




/**
 * Trait responsible for runtime parsing errors.
 */
var ErrorHandler = /** @class */ (function () {
    function ErrorHandler() {
    }
    ErrorHandler.prototype.initErrorHandler = function (config) {
        this._errors = [];
        this.errorMessageProvider = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["k" /* defaults */])(config.errorMessageProvider, __WEBPACK_IMPORTED_MODULE_3__parser__["b" /* DEFAULT_PARSER_CONFIG */].errorMessageProvider);
    };
    ErrorHandler.prototype.SAVE_ERROR = function (error) {
        if (Object(__WEBPACK_IMPORTED_MODULE_0__exceptions_public__["e" /* isRecognitionException */])(error)) {
            error.context = {
                ruleStack: this.getHumanReadableRuleStack(),
                ruleOccurrenceStack: Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["g" /* cloneArr */])(this.RULE_OCCURRENCE_STACK)
            };
            this._errors.push(error);
            return error;
        }
        else {
            throw Error("Trying to save an Error which is not a RecognitionException");
        }
    };
    Object.defineProperty(ErrorHandler.prototype, "errors", {
        // TODO: extract these methods to ErrorHandler Trait?
        get: function () {
            return Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["g" /* cloneArr */])(this._errors);
        },
        set: function (newErrors) {
            this._errors = newErrors;
        },
        enumerable: true,
        configurable: true
    });
    // TODO: consider caching the error message computed information
    ErrorHandler.prototype.raiseEarlyExitException = function (occurrence, prodType, userDefinedErrMsg) {
        var ruleName = this.getCurrRuleFullName();
        var ruleGrammar = this.getGAstProductions()[ruleName];
        var lookAheadPathsPerAlternative = Object(__WEBPACK_IMPORTED_MODULE_2__grammar_lookahead__["g" /* getLookaheadPathsForOptionalProd */])(occurrence, ruleGrammar, prodType, this.maxLookahead);
        var insideProdPaths = lookAheadPathsPerAlternative[0];
        var actualTokens = [];
        for (var i = 1; i <= this.maxLookahead; i++) {
            actualTokens.push(this.LA(i));
        }
        var msg = this.errorMessageProvider.buildEarlyExitMessage({
            expectedIterationPaths: insideProdPaths,
            actual: actualTokens,
            previous: this.LA(0),
            customUserDescription: userDefinedErrMsg,
            ruleName: ruleName
        });
        throw this.SAVE_ERROR(new __WEBPACK_IMPORTED_MODULE_0__exceptions_public__["a" /* EarlyExitException */](msg, this.LA(1), this.LA(0)));
    };
    // TODO: consider caching the error message computed information
    ErrorHandler.prototype.raiseNoAltException = function (occurrence, errMsgTypes) {
        var ruleName = this.getCurrRuleFullName();
        var ruleGrammar = this.getGAstProductions()[ruleName];
        // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?
        var lookAheadPathsPerAlternative = Object(__WEBPACK_IMPORTED_MODULE_2__grammar_lookahead__["h" /* getLookaheadPathsForOr */])(occurrence, ruleGrammar, this.maxLookahead);
        var actualTokens = [];
        for (var i = 1; i <= this.maxLookahead; i++) {
            actualTokens.push(this.LA(i));
        }
        var previousToken = this.LA(0);
        var errMsg = this.errorMessageProvider.buildNoViableAltMessage({
            expectedPathsPerAlt: lookAheadPathsPerAlternative,
            actual: actualTokens,
            previous: previousToken,
            customUserDescription: errMsgTypes,
            ruleName: this.getCurrRuleFullName()
        });
        throw this.SAVE_ERROR(new __WEBPACK_IMPORTED_MODULE_0__exceptions_public__["c" /* NoViableAltException */](errMsg, this.LA(1), previousToken));
    };
    return ErrorHandler;
}());

//# sourceMappingURL=error_handler.js.map

/***/ }),
/* 335 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ContentAssist; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__grammar_interpreter__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_utils__ = __webpack_require__(2);


var ContentAssist = /** @class */ (function () {
    function ContentAssist() {
    }
    ContentAssist.prototype.initContentAssist = function () { };
    ContentAssist.prototype.computeContentAssist = function (startRuleName, precedingInput) {
        var startRuleGast = this.gastProductionsCache[startRuleName];
        if (Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["F" /* isUndefined */])(startRuleGast)) {
            throw Error("Rule ->" + startRuleName + "<- does not exist in this grammar.");
        }
        return Object(__WEBPACK_IMPORTED_MODULE_0__grammar_interpreter__["f" /* nextPossibleTokensAfter */])([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);
    };
    // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...
    // TODO: should this be more explicitly part of the public API?
    ContentAssist.prototype.getNextPossibleTokenTypes = function (grammarPath) {
        var topRuleName = Object(__WEBPACK_IMPORTED_MODULE_1__utils_utils__["s" /* first */])(grammarPath.ruleStack);
        var gastProductions = this.getGAstProductions();
        var topProduction = gastProductions[topRuleName];
        var nextPossibleTokenTypes = new __WEBPACK_IMPORTED_MODULE_0__grammar_interpreter__["a" /* NextAfterTokenWalker */](topProduction, grammarPath).startWalking();
        return nextPossibleTokenTypes;
    };
    return ContentAssist;
}());

//# sourceMappingURL=context_assist.js.map

/***/ }),
/* 336 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GastRecorder; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__grammar_gast_gast_public__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__scan_lexer_public__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__scan_tokens__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__scan_tokens_public__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__parser__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__grammar_keys__ = __webpack_require__(27);







var RECORDING_NULL_OBJECT = {
    description: "This Object indicates the Parser is during Recording Phase"
};
Object.freeze(RECORDING_NULL_OBJECT);
var HANDLE_SEPARATOR = true;
var MAX_METHOD_IDX = Math.pow(2, __WEBPACK_IMPORTED_MODULE_6__grammar_keys__["d" /* BITS_FOR_OCCURRENCE_IDX */]) - 1;
var RFT = Object(__WEBPACK_IMPORTED_MODULE_4__scan_tokens_public__["b" /* createToken */])({ name: "RECORDING_PHASE_TOKEN", pattern: __WEBPACK_IMPORTED_MODULE_2__scan_lexer_public__["a" /* Lexer */].NA });
Object(__WEBPACK_IMPORTED_MODULE_3__scan_tokens__["a" /* augmentTokenTypes */])([RFT]);
var RECORDING_PHASE_TOKEN = Object(__WEBPACK_IMPORTED_MODULE_4__scan_tokens_public__["c" /* createTokenInstance */])(RFT, "This IToken indicates the Parser is in Recording Phase\n\t" +
    "" +
    "See: https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording for details", 
// Using "-1" instead of NaN (as in EOF) because an actual number is less likely to
// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.
-1, -1, -1, -1, -1, -1);
Object.freeze(RECORDING_PHASE_TOKEN);
var RECORDING_PHASE_CSTNODE = {
    name: "This CSTNode indicates the Parser is in Recording Phase\n\t" +
        "See: https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording for details",
    children: {}
};
/**
 * This trait handles the creation of the GAST structure for Chevrotain Grammars
 */
var GastRecorder = /** @class */ (function () {
    function GastRecorder() {
    }
    GastRecorder.prototype.initGastRecorder = function (config) {
        this.recordingProdStack = [];
        this.RECORDING_PHASE = false;
    };
    GastRecorder.prototype.enableRecording = function () {
        var _this = this;
        this.RECORDING_PHASE = true;
        this.TRACE_INIT("Enable Recording", function () {
            var _loop_1 = function (i) {
                var idx = i > 0 ? i : "";
                _this["CONSUME" + idx] = function (arg1, arg2) {
                    return this.consumeInternalRecord(arg1, i, arg2);
                };
                _this["SUBRULE" + idx] = function (arg1, arg2) {
                    return this.subruleInternalRecord(arg1, i, arg2);
                };
                _this["OPTION" + idx] = function (arg1) {
                    return this.optionInternalRecord(arg1, i);
                };
                _this["OR" + idx] = function (arg1) {
                    return this.orInternalRecord(arg1, i);
                };
                _this["MANY" + idx] = function (arg1) {
                    this.manyInternalRecord(i, arg1);
                };
                _this["MANY_SEP" + idx] = function (arg1) {
                    this.manySepFirstInternalRecord(i, arg1);
                };
                _this["AT_LEAST_ONE" + idx] = function (arg1) {
                    this.atLeastOneInternalRecord(i, arg1);
                };
                _this["AT_LEAST_ONE_SEP" + idx] = function (arg1) {
                    this.atLeastOneSepFirstInternalRecord(i, arg1);
                };
            };
            /**
             * Warning Dark Voodoo Magic upcoming!
             * We are "replacing" the public parsing DSL methods API
             * With **new** alternative implementations on the Parser **instance**
             *
             * So far this is the only way I've found to avoid performance regressions during parsing time.
             * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the "internal"
             *   implementations directly instead.
             */
            for (var i = 0; i < 10; i++) {
                _loop_1(i);
            }
            // DSL methods with the idx(suffix) as an argument
            _this["consume"] = function (idx, arg1, arg2) {
                return this.consumeInternalRecord(arg1, idx, arg2);
            };
            _this["subrule"] = function (idx, arg1, arg2) {
                return this.subruleInternalRecord(arg1, idx, arg2);
            };
            _this["option"] = function (idx, arg1) {
                return this.optionInternalRecord(arg1, idx);
            };
            _this["or"] = function (idx, arg1) {
                return this.orInternalRecord(arg1, idx);
            };
            _this["many"] = function (idx, arg1) {
                this.manyInternalRecord(idx, arg1);
            };
            _this["atLeastOne"] = function (idx, arg1) {
                this.atLeastOneInternalRecord(idx, arg1);
            };
            _this.ACTION = _this.ACTION_RECORD;
            _this.BACKTRACK = _this.BACKTRACK_RECORD;
            _this.LA = _this.LA_RECORD;
        });
    };
    GastRecorder.prototype.disableRecording = function () {
        var _this = this;
        this.RECORDING_PHASE = false;
        // By deleting these **instance** properties, any future invocation
        // will be deferred to the original methods on the **prototype** object
        // This seems to get rid of any incorrect optimizations that V8 may
        // do during the recording phase.
        this.TRACE_INIT("Deleting Recording methods", function () {
            for (var i = 0; i < 10; i++) {
                var idx = i > 0 ? i : "";
                delete _this["CONSUME" + idx];
                delete _this["SUBRULE" + idx];
                delete _this["OPTION" + idx];
                delete _this["OR" + idx];
                delete _this["MANY" + idx];
                delete _this["MANY_SEP" + idx];
                delete _this["AT_LEAST_ONE" + idx];
                delete _this["AT_LEAST_ONE_SEP" + idx];
            }
            delete _this["consume"];
            delete _this["subrule"];
            delete _this["option"];
            delete _this["or"];
            delete _this["many"];
            delete _this["atLeastOne"];
            delete _this.ACTION;
            delete _this.BACKTRACK;
            delete _this.LA;
        });
    };
    // TODO: is there any way to use this method to check no
    //   Parser methods are called inside an ACTION?
    //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?
    GastRecorder.prototype.ACTION_RECORD = function (impl) {
        // NO-OP during recording
        return;
    };
    // Executing backtracking logic will break our recording logic assumptions
    GastRecorder.prototype.BACKTRACK_RECORD = function (grammarRule, args) {
        return function () { return true; };
    };
    // LA is part of the official API and may be used for custom lookahead logic
    // by end users who may forget to wrap it in ACTION or inside a GATE
    GastRecorder.prototype.LA_RECORD = function (howMuch) {
        // We cannot use the RECORD_PHASE_TOKEN here because someone may depend
        // On LA return EOF at the end of the input so an infinite loop may occur.
        return __WEBPACK_IMPORTED_MODULE_5__parser__["e" /* END_OF_FILE */];
    };
    GastRecorder.prototype.topLevelRuleRecord = function (name, def) {
        try {
            var newTopLevelRule = new __WEBPACK_IMPORTED_MODULE_1__grammar_gast_gast_public__["j" /* Rule */]({ definition: [], name: name });
            newTopLevelRule.name = name;
            this.recordingProdStack.push(newTopLevelRule);
            def.call(this);
            this.recordingProdStack.pop();
            return newTopLevelRule;
        }
        catch (originalError) {
            if (originalError.KNOWN_RECORDER_ERROR !== true) {
                try {
                    originalError.message =
                        originalError.message +
                            '\n\t This error was thrown during the "grammar recording phase" For more info see:\n\t' +
                            "https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording";
                }
                catch (mutabilityError) {
                    // We may not be able to modify the original error object
                    throw originalError;
                }
            }
            throw originalError;
        }
    };
    // Implementation of parsing DSL
    GastRecorder.prototype.optionInternalRecord = function (actionORMethodDef, occurrence) {
        return recordProd.call(this, __WEBPACK_IMPORTED_MODULE_1__grammar_gast_gast_public__["e" /* Option */], actionORMethodDef, occurrence);
    };
    GastRecorder.prototype.atLeastOneInternalRecord = function (occurrence, actionORMethodDef) {
        recordProd.call(this, __WEBPACK_IMPORTED_MODULE_1__grammar_gast_gast_public__["g" /* RepetitionMandatory */], actionORMethodDef, occurrence);
    };
    GastRecorder.prototype.atLeastOneSepFirstInternalRecord = function (occurrence, options) {
        recordProd.call(this, __WEBPACK_IMPORTED_MODULE_1__grammar_gast_gast_public__["h" /* RepetitionMandatoryWithSeparator */], options, occurrence, HANDLE_SEPARATOR);
    };
    GastRecorder.prototype.manyInternalRecord = function (occurrence, actionORMethodDef) {
        recordProd.call(this, __WEBPACK_IMPORTED_MODULE_1__grammar_gast_gast_public__["f" /* Repetition */], actionORMethodDef, occurrence);
    };
    GastRecorder.prototype.manySepFirstInternalRecord = function (occurrence, options) {
        recordProd.call(this, __WEBPACK_IMPORTED_MODULE_1__grammar_gast_gast_public__["i" /* RepetitionWithSeparator */], options, occurrence, HANDLE_SEPARATOR);
    };
    GastRecorder.prototype.orInternalRecord = function (altsOrOpts, occurrence) {
        return recordOrProd.call(this, altsOrOpts, occurrence);
    };
    GastRecorder.prototype.subruleInternalRecord = function (ruleToCall, occurrence, options) {
        assertMethodIdxIsValid(occurrence);
        if (!ruleToCall || Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(ruleToCall, "ruleName") === false) {
            var error = new Error("<SUBRULE" + getIdxSuffix(occurrence) + "> argument is invalid" +
                (" expecting a Parser method reference but got: <" + JSON.stringify(ruleToCall) + ">") +
                ("\n inside top level rule: <" + this.recordingProdStack[0].name + ">"));
            error.KNOWN_RECORDER_ERROR = true;
            throw error;
        }
        var prevProd = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["M" /* peek */])(this.recordingProdStack);
        var ruleName = ruleToCall["ruleName"];
        var newNoneTerminal = new __WEBPACK_IMPORTED_MODULE_1__grammar_gast_gast_public__["d" /* NonTerminal */]({
            idx: occurrence,
            nonTerminalName: ruleName,
            // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created
            referencedRule: undefined
        });
        prevProd.definition.push(newNoneTerminal);
        return this.outputCst
            ? RECORDING_PHASE_CSTNODE
            : RECORDING_NULL_OBJECT;
    };
    GastRecorder.prototype.consumeInternalRecord = function (tokType, occurrence, options) {
        assertMethodIdxIsValid(occurrence);
        if (!Object(__WEBPACK_IMPORTED_MODULE_3__scan_tokens__["b" /* hasShortKeyProperty */])(tokType)) {
            var error = new Error("<CONSUME" + getIdxSuffix(occurrence) + "> argument is invalid" +
                (" expecting a TokenType reference but got: <" + JSON.stringify(tokType) + ">") +
                ("\n inside top level rule: <" + this.recordingProdStack[0].name + ">"));
            error.KNOWN_RECORDER_ERROR = true;
            throw error;
        }
        var prevProd = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["M" /* peek */])(this.recordingProdStack);
        var newNoneTerminal = new __WEBPACK_IMPORTED_MODULE_1__grammar_gast_gast_public__["k" /* Terminal */]({
            idx: occurrence,
            terminalType: tokType
        });
        prevProd.definition.push(newNoneTerminal);
        return RECORDING_PHASE_TOKEN;
    };
    return GastRecorder;
}());

function recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {
    if (handleSep === void 0) { handleSep = false; }
    assertMethodIdxIsValid(occurrence);
    var prevProd = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["M" /* peek */])(this.recordingProdStack);
    var grammarAction = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["B" /* isFunction */])(mainProdArg)
        ? mainProdArg
        : mainProdArg.DEF;
    var newProd = new prodConstructor({ definition: [], idx: occurrence });
    if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(mainProdArg, "NAME")) {
        newProd.name = mainProdArg.NAME;
    }
    if (handleSep) {
        newProd.separator = mainProdArg.SEP;
    }
    if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(mainProdArg, "MAX_LOOKAHEAD")) {
        newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
    }
    this.recordingProdStack.push(newProd);
    grammarAction.call(this);
    prevProd.definition.push(newProd);
    this.recordingProdStack.pop();
    return RECORDING_NULL_OBJECT;
}
function recordOrProd(mainProdArg, occurrence) {
    var _this = this;
    assertMethodIdxIsValid(occurrence);
    var prevProd = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["M" /* peek */])(this.recordingProdStack);
    // Only an array of alternatives
    var hasOptions = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["y" /* isArray */])(mainProdArg) === false;
    var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;
    var newOrProd = new __WEBPACK_IMPORTED_MODULE_1__grammar_gast_gast_public__["b" /* Alternation */]({
        definition: [],
        idx: occurrence,
        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true
    });
    if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(mainProdArg, "NAME")) {
        newOrProd.name = mainProdArg.NAME;
    }
    if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(mainProdArg, "MAX_LOOKAHEAD")) {
        newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
    }
    var hasPredicates = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["Q" /* some */])(alts, function (currAlt) { return Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["B" /* isFunction */])(currAlt.GATE); });
    newOrProd.hasPredicates = hasPredicates;
    prevProd.definition.push(newOrProd);
    Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(alts, function (currAlt) {
        var currAltFlat = new __WEBPACK_IMPORTED_MODULE_1__grammar_gast_gast_public__["c" /* Flat */]({ definition: [] });
        newOrProd.definition.push(currAltFlat);
        if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(currAlt, "NAME")) {
            currAltFlat.name = currAlt.NAME;
        }
        if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(currAlt, "IGNORE_AMBIGUITIES")) {
            currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;
        }
        // **implicit** ignoreAmbiguities due to usage of gate
        else if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(currAlt, "GATE")) {
            currAltFlat.ignoreAmbiguities = true;
        }
        _this.recordingProdStack.push(currAltFlat);
        currAlt.ALT.call(_this);
        _this.recordingProdStack.pop();
    });
    return RECORDING_NULL_OBJECT;
}
function getIdxSuffix(idx) {
    return idx === 0 ? "" : "" + idx;
}
function assertMethodIdxIsValid(idx) {
    if (idx < 0 || idx > MAX_METHOD_IDX) {
        var error = new Error(
        // The stack trace will contain all the needed details
        "Invalid DSL Method idx value: <" + idx + ">\n\t" +
            ("Idx value must be a none negative value smaller than " + (MAX_METHOD_IDX +
                1)));
        error.KNOWN_RECORDER_ERROR = true;
        throw error;
    }
}
//# sourceMappingURL=gast_recorder.js.map

/***/ }),
/* 337 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PerformanceTracer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parser__ = __webpack_require__(9);


/**
 * Trait responsible for runtime parsing errors.
 */
var PerformanceTracer = /** @class */ (function () {
    function PerformanceTracer() {
    }
    PerformanceTracer.prototype.initPerformanceTracer = function (config) {
        if (Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["w" /* has */])(config, "traceInitPerf")) {
            var userTraceInitPerf = config.traceInitPerf;
            var traceIsNumber = typeof userTraceInitPerf === "number";
            this.traceInitMaxIdent = traceIsNumber
                ? userTraceInitPerf
                : Infinity;
            this.traceInitPerf = traceIsNumber
                ? userTraceInitPerf > 0
                : userTraceInitPerf;
        }
        else {
            this.traceInitMaxIdent = 0;
            this.traceInitPerf = __WEBPACK_IMPORTED_MODULE_1__parser__["b" /* DEFAULT_PARSER_CONFIG */].traceInitPerf;
        }
        this.traceInitIndent = -1;
    };
    PerformanceTracer.prototype.TRACE_INIT = function (phaseDesc, phaseImpl) {
        // No need to optimize this using NOOP pattern because
        // It is not called in a hot spot...
        if (this.traceInitPerf === true) {
            this.traceInitIndent++;
            var indent = new Array(this.traceInitIndent + 1).join("\t");
            if (this.traceInitIndent < this.traceInitMaxIdent) {
                console.log(indent + "--> <" + phaseDesc + ">");
            }
            var _a = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["R" /* timer */])(phaseImpl), time = _a.time, value = _a.value;
            /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */
            var traceMethod = time > 10 ? console.warn : console.log;
            if (this.traceInitIndent < this.traceInitMaxIdent) {
                traceMethod(indent + "<-- <" + phaseDesc + "> time: " + time + "ms");
            }
            this.traceInitIndent--;
            return value;
        }
        else {
            return phaseImpl();
        }
    };
    return PerformanceTracer;
}());

//# sourceMappingURL=perf_tracer.js.map

/***/ }),
/* 338 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = createSyntaxDiagramsCode;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__version__ = __webpack_require__(214);

function createSyntaxDiagramsCode(grammar, _a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.resourceBase, resourceBase = _c === void 0 ? "https://unpkg.com/chevrotain@" + __WEBPACK_IMPORTED_MODULE_0__version__["a" /* VERSION */] + "/diagrams/" : _c, _d = _b.css, css = _d === void 0 ? "https://unpkg.com/chevrotain@" + __WEBPACK_IMPORTED_MODULE_0__version__["a" /* VERSION */] + "/diagrams/diagrams.css" : _d;
    var header = "\n<!-- This is a generated file -->\n<!DOCTYPE html>\n<meta charset=\"utf-8\">\n<style>\n  body {\n    background-color: hsl(30, 20%, 95%)\n  }\n</style>\n\n";
    var cssHtml = "\n<link rel='stylesheet' href='" + css + "'>\n";
    var scripts = "\n<script src='" + resourceBase + "vendor/railroad-diagrams.js'></script>\n<script src='" + resourceBase + "src/diagrams_builder.js'></script>\n<script src='" + resourceBase + "src/diagrams_behavior.js'></script>\n<script src='" + resourceBase + "src/main.js'></script>\n";
    var diagramsDiv = "\n<div id=\"diagrams\" align=\"center\"></div>    \n";
    var serializedGrammar = "\n<script>\n    window.serializedGrammar = " + JSON.stringify(grammar, null, "  ") + ";\n</script>\n";
    var initLogic = "\n<script>\n    var diagramsDiv = document.getElementById(\"diagrams\");\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\n</script>\n";
    return (header + cssHtml + scripts + diagramsDiv + serializedGrammar + initLogic);
}
//# sourceMappingURL=render_public.js.map

/***/ }),
/* 339 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = generateParserFactory;
/* harmony export (immutable) */ __webpack_exports__["b"] = generateParserModule;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__generate__ = __webpack_require__(340);

function generateParserFactory(options) {
    var wrapperText = Object(__WEBPACK_IMPORTED_MODULE_0__generate__["b" /* genWrapperFunction */])({
        name: options.name,
        rules: options.rules
    });
    var constructorWrapper = new Function("tokenVocabulary", "config", "chevrotain", wrapperText);
    return function (config) {
        return constructorWrapper(options.tokenVocabulary, config, 
        // TODO: check how the require is transpiled/webpacked
        __webpack_require__(213));
    };
}
function generateParserModule(options) {
    return Object(__WEBPACK_IMPORTED_MODULE_0__generate__["a" /* genUmdModule */])({ name: options.name, rules: options.rules });
}
//# sourceMappingURL=generate_public.js.map

/***/ }),
/* 340 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = genUmdModule;
/* harmony export (immutable) */ __webpack_exports__["b"] = genWrapperFunction;
/* unused harmony export genClass */
/* unused harmony export genAllRules */
/* unused harmony export genRule */
/* unused harmony export genTerminal */
/* unused harmony export genNonTerminal */
/* unused harmony export genAlternation */
/* unused harmony export genSingleAlt */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse_grammar_gast_gast_public__ = __webpack_require__(6);


/**
 * Missing features
 * 1. Rule arguments
 * 2. Gates
 * 3. embedded actions
 */
var NL = "\n";
function genUmdModule(options) {
    return "\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['chevrotain'], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory(require('chevrotain'));\n    } else {\n        // Browser globals (root is window)\n        root.returnExports = factory(root.b);\n    }\n}(typeof self !== 'undefined' ? self : this, function (chevrotain) {\n\n" + genClass(options) + "\n    \nreturn {\n    " + options.name + ": " + options.name + " \n}\n}));\n";
}
function genWrapperFunction(options) {
    return "    \n" + genClass(options) + "\nreturn new " + options.name + "(tokenVocabulary, config)    \n";
}
function genClass(options) {
    // TODO: how to pass the token vocabulary? Constructor? other?
    var result = "\nfunction " + options.name + "(tokenVocabulary, config) {\n    // invoke super constructor\n    // No support for embedded actions currently, so we can 'hardcode'\n    // The use of CstParser.\n    chevrotain.CstParser.call(this, tokenVocabulary, config)\n\n    const $ = this\n\n    " + genAllRules(options.rules) + "\n\n    // very important to call this after all the rules have been defined.\n    // otherwise the parser may not work correctly as it will lack information\n    // derived during the self analysis phase.\n    this.performSelfAnalysis(this)\n}\n\n// inheritance as implemented in javascript in the previous decade... :(\n" + options.name + ".prototype = Object.create(chevrotain.CstParser.prototype)\n" + options.name + ".prototype.constructor = " + options.name + "    \n    ";
    return result;
}
function genAllRules(rules) {
    var rulesText = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */])(rules, function (currRule) {
        return genRule(currRule, 1);
    });
    return rulesText.join("\n");
}
function genRule(prod, n) {
    var result = indent(n, "$.RULE(\"" + prod.name + "\", function() {") + NL;
    result += genDefinition(prod.definition, n + 1);
    result += indent(n + 1, "})") + NL;
    return result;
}
function genTerminal(prod, n) {
    var name = prod.terminalType.name;
    // TODO: potential performance optimization, avoid tokenMap Dictionary access
    return indent(n, "$.CONSUME" + prod.idx + "(this.tokensMap." + name + ")" + NL);
}
function genNonTerminal(prod, n) {
    return indent(n, "$.SUBRULE" + prod.idx + "($." + prod.nonTerminalName + ")" + NL);
}
function genAlternation(prod, n) {
    var result = indent(n, "$.OR" + prod.idx + "([") + NL;
    var alts = Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["I" /* map */])(prod.definition, function (altDef) { return genSingleAlt(altDef, n + 1); });
    result += alts.join("," + NL);
    result += NL + indent(n, "])" + NL);
    return result;
}
function genSingleAlt(prod, n) {
    var result = indent(n, "{") + NL;
    if (prod.name) {
        result += indent(n + 1, "NAME: \"" + prod.name + "\",") + NL;
    }
    result += indent(n + 1, "ALT: function() {") + NL;
    result += genDefinition(prod.definition, n + 1);
    result += indent(n + 1, "}") + NL;
    result += indent(n, "}");
    return result;
}
function genProd(prod, n) {
    /* istanbul ignore else */
    if (prod instanceof __WEBPACK_IMPORTED_MODULE_1__parse_grammar_gast_gast_public__["d" /* NonTerminal */]) {
        return genNonTerminal(prod, n);
    }
    else if (prod instanceof __WEBPACK_IMPORTED_MODULE_1__parse_grammar_gast_gast_public__["e" /* Option */]) {
        return genDSLRule("OPTION", prod, n);
    }
    else if (prod instanceof __WEBPACK_IMPORTED_MODULE_1__parse_grammar_gast_gast_public__["g" /* RepetitionMandatory */]) {
        return genDSLRule("AT_LEAST_ONE", prod, n);
    }
    else if (prod instanceof __WEBPACK_IMPORTED_MODULE_1__parse_grammar_gast_gast_public__["h" /* RepetitionMandatoryWithSeparator */]) {
        return genDSLRule("AT_LEAST_ONE_SEP", prod, n);
    }
    else if (prod instanceof __WEBPACK_IMPORTED_MODULE_1__parse_grammar_gast_gast_public__["i" /* RepetitionWithSeparator */]) {
        return genDSLRule("MANY_SEP", prod, n);
    }
    else if (prod instanceof __WEBPACK_IMPORTED_MODULE_1__parse_grammar_gast_gast_public__["f" /* Repetition */]) {
        return genDSLRule("MANY", prod, n);
    }
    else if (prod instanceof __WEBPACK_IMPORTED_MODULE_1__parse_grammar_gast_gast_public__["b" /* Alternation */]) {
        return genAlternation(prod, n);
    }
    else if (prod instanceof __WEBPACK_IMPORTED_MODULE_1__parse_grammar_gast_gast_public__["k" /* Terminal */]) {
        return genTerminal(prod, n);
    }
    else if (prod instanceof __WEBPACK_IMPORTED_MODULE_1__parse_grammar_gast_gast_public__["c" /* Flat */]) {
        return genDefinition(prod.definition, n);
    }
    else {
        throw Error("non exhaustive match");
    }
}
function genDSLRule(dslName, prod, n) {
    var result = indent(n, "$." + (dslName + prod.idx) + "(");
    if (prod.name || prod.separator) {
        result += "{" + NL;
        if (prod.name) {
            result += indent(n + 1, "NAME: \"" + prod.name + "\"") + "," + NL;
        }
        if (prod.separator) {
            result +=
                indent(n + 1, "SEP: this.tokensMap." + prod.separator.name) +
                    "," +
                    NL;
        }
        result += "DEF: " + genDefFunction(prod.definition, n + 2) + NL;
        result += indent(n, "}") + NL;
    }
    else {
        result += genDefFunction(prod.definition, n + 1);
    }
    result += indent(n, ")") + NL;
    return result;
}
function genDefFunction(definition, n) {
    var def = "function() {" + NL;
    def += genDefinition(definition, n);
    def += indent(n, "}") + NL;
    return def;
}
function genDefinition(def, n) {
    var result = "";
    Object(__WEBPACK_IMPORTED_MODULE_0__utils_utils__["u" /* forEach */])(def, function (prod) {
        result += genProd(prod, n + 1);
    });
    return result;
}
function indent(howMuch, text) {
    var spaces = Array(howMuch * 4 + 1).join(" ");
    return spaces + text;
}
//# sourceMappingURL=generate.js.map

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = rasterLayer;

var _capMixin = __webpack_require__(16);

var _capMixin2 = _interopRequireDefault(_capMixin);

var _rasterLayerPointMixin = __webpack_require__(210);

var _rasterLayerPointMixin2 = _interopRequireDefault(_rasterLayerPointMixin);

var _rasterLayerPolyMixin = __webpack_require__(211);

var _rasterLayerPolyMixin2 = _interopRequireDefault(_rasterLayerPolyMixin);

var _rasterLayerHeatmapMixin = __webpack_require__(209);

var _rasterLayerHeatmapMixin2 = _interopRequireDefault(_rasterLayerHeatmapMixin);

var _rasterLayerLineMixin = __webpack_require__(342);

var _rasterLayerLineMixin2 = _interopRequireDefault(_rasterLayerLineMixin);

var _utilsVega = __webpack_require__(19);

var _mapdDraw = __webpack_require__(13);

var _moment = __webpack_require__(0);

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var validLayerTypes = ["points", "polys", "heat", "lines"];

function rasterLayer(layerType) {
  var _layerType = layerType;

  var _dimension = null;
  var _group = null;
  var _mandatoryAttributes2 = [];

  var _layer = (0, _capMixin2.default)({
    setDataAsync: function setDataAsync(callback) {
      // noop.
      // This is to appease mixins that require an object initialized with a baseMixin
    },
    data: function data(callback) {
      // noop.
      // This is to appease mixins that require an object initialized with a baseMixin
    },
    filter: function filter() {
      // noop.
      // This is to appease mixins that require an object initialized with a baseMixin
    },
    _mandatoryAttributes: function _mandatoryAttributes(mandatoryAttributes) {
      // needed for layer mixins to control mandatory checks.

      if (!arguments.length) {
        return _mandatoryAttributes2;
      }
      _mandatoryAttributes2 = mandatoryAttributes;
      return _layer;
    }
  });

  _layer.othersGrouper(false); // TODO(croot): what does othersGrouper in capMixin do exactly?
  // Always set to false for now, tho user can override.

  if (layerType === "points") {
    _layer = (0, _rasterLayerPointMixin2.default)(_layer);
  } else if (layerType === "polys") {
    _layer = (0, _rasterLayerPolyMixin2.default)(_layer);
  } else if (/heat/.test(layerType)) {
    _layer = (0, _rasterLayerHeatmapMixin2.default)(_layer);
  } else if (layerType === "lines") {
    _layer = (0, _rasterLayerLineMixin2.default)(_layer);
  } else {
    throw new Error('"' + layerType + '" is not a valid layer type. The valid layer types are: ' + validLayerTypes.join(", "));
  }

  var _opacity = 1;

  // NOTE: builds _layer.defaultFillColor(), _layer.nullFillColor(),
  //              _layer.fillColorScale(), & _layer.fillColorAttr()
  (0, _utilsVega.createVegaAttrMixin)(_layer, "fillColor", "#22A7F0", "#CACACA", true);

  // NOTE: builds _layer.defaultStrokeColor(), _layer.nullStrokeColor(),
  //              _layer.strokeColorScale(), & _layer.strokeColorAttr()
  (0, _utilsVega.createVegaAttrMixin)(_layer, "strokeColor", "white", "white", true);

  // NOTE: builds _layer.defaultStrokeWidth(), _layer.nullStrokeWidth(),
  //              _layer.strokeWidthScale(), & _layer.strokeWidthAttr()
  (0, _utilsVega.createVegaAttrMixin)(_layer, "strokeWidth", 0, 0, true);

  _layer.popupColumns = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, []);
  _layer.popupColumnsMapped = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, {});
  _layer.popupFunction = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);
  _layer.popupStyle = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, {});
  _layer.densityAccumulatorEnabled = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, false);

  var _popup_wrap_class = "map-popup-wrap-new";
  var _popup_box_class = "map-popup-box-new";
  var _popup_item_copy_class = "popup-item-copy";
  var _popup_box_item_wrap_class = "map-popup-item-wrap";
  var _popup_box_item_class = "map-popup-item";
  var _popup_item_key_class = "popup-item-key";
  var _popup_item_val_class = "popup-item-val";
  var _layerPopups = {};

  _layer.layerType = function () {
    return _layerType;
  };

  /**
   * **mandatory**
   *
   * Set or get the dimension attribute of a chart. In `dc`, a dimension can be any valid [crossfilter
   * dimension](https://github.com/square/crossfilter/wiki/API-Reference#wiki-dimension).
   *
   * If a value is given, then it will be used as the new dimension. If no value is specified then
   * the current dimension will be returned.
   * @name dimension
   * @memberof dc.baseMixin
   * @instance
   * @see {@link https://github.com/square/crossfilter/wiki/API-Reference#dimension crossfilter.dimension}
   * @example
   * var index = crossfilter([]);
   * var dimension = index.dimension(dc.pluck('key'));
   * chart.dimension(dimension);
   * @param {crossfilter.dimension} [dimension]
   * @return {crossfilter.dimension}
   * @return {dc.baseMixin}
   */
  _layer.dimension = function (dimension) {
    if (!arguments.length) {
      return _dimension;
    }
    _dimension = dimension;
    return _layer;
  };

  /**
   * **mandatory**
   *
   * Set or get the group attribute of a chart. In `dc` a group is a
   * {@link https://github.com/square/crossfilter/wiki/API-Reference#group-map-reduce crossfilter group}.
   * Usually the group should be created from the particular dimension associated with the same chart. If a value is
   * given, then it will be used as the new group.
   *
   * If no value specified then the current group will be returned.
   * If `name` is specified then it will be used to generate legend label.
   * @name group
   * @memberof dc.baseMixin
   * @instance
   * @see {@link https://github.com/square/crossfilter/wiki/API-Reference#group-map-reduce crossfilter.group}
   * @example
   * var index = crossfilter([]);
   * var dimension = index.dimension(dc.pluck('key'));
   * chart.dimension(dimension);
   * chart.group(dimension.group(crossfilter.reduceSum()));
   * @param {crossfilter.group} [group]
   * @param {String} [name]
   * @return {crossfilter.group}
   * @return {dc.baseMixin}
   */
  _layer.group = function (group, name) {
    if (!arguments.length) {
      return _group;
    }
    _group = group;
    _layer._groupName = name;
    return _layer;
  };

  _layer.opacity = function (opacity) {
    if (!arguments.length) {
      return _opacity;
    }
    _opacity = opacity;
    return _layer;
  };

  function genHeatConfigFromChart(chart, layerName) {
    return {
      table: _layer.crossfilter().getTable()[0],
      width: Math.round(chart.width() * chart._getPixelRatio()),
      height: Math.round(chart.height() * chart._getPixelRatio()),
      min: chart.conv4326To900913(chart._minCoord),
      max: chart.conv4326To900913(chart._maxCoord),
      filter: _layer.crossfilter().getFilterString(layerName),
      globalFilter: _layer.crossfilter().getGlobalFilterString(),
      neLat: chart._maxCoord[1],
      zoom: chart.zoom()
    };
  }

  _layer.genVega = function (chart, layerName) {
    var cap = _layer.cap();
    var group = _layer.group() || {};
    var query = "";
    if (group.type === "dimension") {
      query = group.writeTopQuery(cap, undefined, true);
    } else if (group.type === "group") {
      query = group.writeTopQuery(cap, undefined, false, true);
    }

    if (!query.length) {
      // throw new Error("Crossfilter group/dimension did not provide a sql query string for layer " + layerName + "." + (groupType.length ? " Group type: " + (group.type || "unknown") + "." : ""))
    }

    if (_layer.type === "heatmap") {
      var vega = _layer._genVega(_extends({}, genHeatConfigFromChart(chart, layerName), {
        layerName: layerName
      }));
      return vega;
    } else {
      var _vega = _layer._genVega(chart, layerName, group, query);
      return _vega;
    }
  };

  _layer.hasPopupColumns = function () {
    var popCols = _layer.popupColumns();
    return Boolean(popCols && popCols instanceof Array && popCols.length > 0);
  };

  // A Utility function to map size or color measure label for custom measure popup
  // Label is the same as field most of the case but for custom measures, it could be different
  _layer.getMeasureLabel = function (measureRegex) {
    var measureBlock = null;
    if (measureRegex[2] === "color" || measureRegex[2] === "strokeColor") {
      measureBlock = _layer.getState().encoding.color;
    } else if (measureRegex[2] === "size" || measureRegex[2] === "strokeWidth") {
      measureBlock = _layer.getState().encoding.size;
    } else if (measureRegex[2] === "x" || measureRegex[2] === "y") {
      measureBlock = _layer.getState().encoding[measureRegex[2]];
    } else if (measureRegex[2] === "orientation") {
      measureBlock = _layer.getState().encoding.orientation;
    }
    if (measureBlock && measureBlock.label) {
      return measureBlock.label;
    }
    return measureBlock;
  };

  function isMeasureCol(colAttr) {
    return colAttr === "x" || colAttr === "y" || colAttr === "color" || colAttr === "size" || colAttr === "strokeColor" || colAttr === "strokeWidth" || colAttr === "orientation";
  }

  function addPopupColumnToSet(colAttr, popupColSet) {
    // TODO(croot): getProjectOn for groups requires the two arguments,
    // dimension.getProjectOn() doesn't have any args.
    // Need to come up with a better API for group.getProjectOn()
    // and improve the api so that "as key0" are not automatically
    // added to those projection statements.

    // TODO(croot): performance could be improved here with a better
    // data structure, but probably not an issue given the amount
    // of popup col attrs to iterate through is small
    var dim = _layer.group() || _layer.dimension();
    if (dim || _layer.layerType() === "points" || _layer.layerType() === "lines" || _layer.layerType() === "polys") {
      var projExprs = _layer.layerType() === "points" || _layer.layerType() === "lines" || _layer.layerType() === "polys" || _layer.layerType() === "" ? _layer.getProjections() : dim.getProjectOn(true); // handles the group and dimension case
      var regex = /^\s*([\s\S]+)\s+as\s+(\S+)/i;
      var funcRegex = /^\s*(\S+\s*\(.*\))\s+as\s+(\S+)/i;
      for (var i = 0; i < projExprs.length; ++i) {
        var projExpr = projExprs[i];
        var regexRtn = projExpr.match(regex);
        if (regexRtn) {
          if (regexRtn[2] === colAttr) {
            if (isMeasureCol(colAttr)) {
              // column selector label is used for layer.popupColumns(), so we need to remove it from popupColSet for color/size or x/y measures
              var label = _layer.getMeasureLabel(regexRtn);
              popupColSet.delete(regexRtn[1]);
              popupColSet.delete(label);
            } else {
              popupColSet.delete(colAttr);
            }

            colAttr = projExpr;
            break;
          }
        } else if ((regexRtn = projExpr.match(funcRegex)) && regexRtn[2] === colAttr) {
          popupColSet.delete(colAttr);
          colAttr = projExpr;
          break;
        } else if (projExpr && projExpr.replace(/^\s+|\s+$/g, "") === colAttr) {
          break;
        }
      }
    }
    return popupColSet.add(colAttr);
  }

  _layer.getPopupAndRenderColumns = function (chart) {
    var popupColsSet = new Set();
    var popupCols = _layer.popupColumns();
    if (popupCols) {
      popupCols.forEach(function (colAttr) {
        addPopupColumnToSet(colAttr, popupColsSet);
      });
    }
    _layer._addRenderAttrsToPopupColumnSet(chart, popupColsSet);

    var rtnArray = [];
    popupColsSet.forEach(function (colName) {
      rtnArray.push(colName);
    });
    return rtnArray;
  };

  // this function maps hit testing response to popupColumns items
  function mapDataViaColumns(data, popupColumns, chart) {
    var newData = {};
    var columnSet = new Set(popupColumns);
    for (var key in data) {
      if (columnSet.has(key)) {
        newData[key] = data[key];
        data[key] instanceof Date ? (0, _moment2.default)(data[key]).utc() : data[key];

        if (typeof chart.useLonLat === "function" && chart.useLonLat()) {
          if (key === "x") {
            newData[key] = chart.conv900913To4326X(data[key]);
          } else if (key === "y") {
            newData[key] = chart.conv900913To4326Y(data[key]);
          }
        }
      } else {
        // check response key is size or measure column which is in popupColumns
        var dim = _layer.group() || _layer.dimension();
        var projExprs = _layer.layerType() === "points" || _layer.layerType() === "lines" || _layer.layerType() === "polys" || _layer.layerType() === "" ? _layer.getProjections() : dim.getProjectOn(true);

        var regex = /^\s*(.*?[\s\S].+)\s+as\s+(\S+)/i;
        for (var i = 0; i < projExprs.length; ++i) {
          var projExpr = projExprs[i];
          var regexRtn = projExpr.match(regex);
          // for custom columns, the column label is different than the column value,
          // so need to access the measure column label that is passed from immerse here
          var label = _layer.getMeasureLabel(regexRtn);
          if (columnSet.has(label)) {
            newData[label] = data[regexRtn[2]];
          }
        }
      }
    }
    return newData;
  }

  _layer.areResultsValidForPopup = function (results) {
    if (!results) {
      return false;
    }
    return _layer._areResultsValidForPopup(results[0]);
  };

  function replaceURL(colVal) {
    if (typeof colVal === "string") {
      var urlRegExpr = /(((https?:\/\/)|(www\.))[^\s^<>'"`]+)/g;
      return colVal.replace(urlRegExpr, function (url) {
        var hyperlink = url;
        if (!hyperlink.match("^https?://")) {
          hyperlink = "http://" + hyperlink;
        }
        return '<a href="' + hyperlink + '" target="_blank" rel="noopener noreferrer">' + url + "</a>";
      });
    } else {
      return colVal;
    }
  }

  function renderPopupHTML(data, columnOrder, columnMap, formatMeasureValue) {
    var html = '<div class="' + _popup_item_copy_class + '">' + '<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" xmlns="http://www.w3.org/2000/svg">' + '<path d="M10.6668 0.666748H2.66683C1.9335 0.666748 1.3335 1.26675 1.3335 2.00008V11.3334H2.66683V2.00008H10.6668V0.666748ZM10.0002 3.33341L14.0002 7.33341V14.0001C14.0002 14.7334 13.4002 15.3334 12.6668 15.3334H5.32683C4.5935 15.3334 4.00016 14.7334 4.00016 14.0001L4.00683 4.66675C4.00683 3.93341 4.60016 3.33341 5.3335 3.33341H10.0002ZM9.3335 8.00008H13.0002L9.3335 4.33341V8.00008Z"/>' + "</svg>" + "</div>";

    html += '<div class="' + _popup_box_item_wrap_class + '">';

    columnOrder.forEach(function (key) {
      if (typeof data[key] === "undefined") {
        return;
      }

      var columnKey = columnMap && columnMap[key] ? columnMap[key] : key;
      var columnKeyTrimmed = columnKey.replace(/.*\((.*)\).*/, "$1");

      html = html + ('<div class="' + _popup_box_item_class + '"><span class="' + _popup_item_key_class + '">' + columnKey + ':</span><span class="' + _popup_item_val_class + '"> ' + replaceURL(formatMeasureValue(data[key], columnKeyTrimmed)) + "</span></div>");
    });
    html += "</div>";
    return html;
  }

  _layer.displayPopup = function (chart, parentElem, result, minPopupArea, animate) {
    // hit testing response includes color or size measure's result as "color" or "size"
    var data = result.row_set[0];

    // popupColumns have color or size measure label
    var popupColumns = _layer.popupColumns();
    var mappedColumns = _layer.popupColumnsMapped();
    var filteredData = mapDataViaColumns(data, popupColumns, chart);

    var width = typeof chart.effectiveWidth === "function" ? chart.effectiveWidth() : chart.width();
    var height = typeof chart.effectiveHeight === "function" ? chart.effectiveHeight() : chart.height();
    var margins = typeof chart.margins === "function" ? chart.margins() : { left: 0, right: 0, top: 0, bottom: 0 };

    var xscale = chart.x();
    var yscale = chart.y();

    var origXRange = xscale.range();
    var origYRange = yscale.range();

    xscale.range([0, width]);
    yscale.range([0, height]);

    var hoverSvgProps = {
      chart: chart,
      parentElem: parentElem,
      data: data,
      width: width,
      height: height,
      margins: margins,
      xscale: xscale,
      yscale: yscale,
      minPopupArea: minPopupArea,
      animate: animate
    };

    var bounds = _layer._displayPopup(hoverSvgProps);

    // restore the original ranges so we don't screw anything else up
    xscale.range(origXRange);
    yscale.range(origYRange);

    var boundsCtr = _mapdDraw.AABox2d.getCenter(_mapdDraw.Point2d.create(), bounds);
    var overlapBounds = _mapdDraw.AABox2d.create(0, 0, width, height);
    _mapdDraw.AABox2d.intersection(overlapBounds, overlapBounds, bounds);

    if (_mapdDraw.AABox2d.isEmpty(overlapBounds)) {
      // there is no overlap with the two bounds, we should
      // never get here
      throw new Error("Found a non-overlapping bounds for a pop-up shape and its parent div");
    }

    var overlapSz = _mapdDraw.AABox2d.getSize(_mapdDraw.Point2d.create(), overlapBounds);
    var overlapCtr = _mapdDraw.AABox2d.getCenter(_mapdDraw.Point2d.create(), overlapBounds);

    var padding = 6; // in pixels TODO(croot): expose in css?
    var topOffset = 0;

    var popupDiv = parentElem.append("div").attr("class", _popup_wrap_class).style({ left: boundsCtr[0] + "px", top: boundsCtr[1] + "px" });

    var popupBox = popupDiv.append("div").attr("class", _popup_box_class).html(_layer.popupFunction() ? _layer.popupFunction(filteredData, popupColumns, mappedColumns) : renderPopupHTML(filteredData, popupColumns, mappedColumns, chart.measureValue)).style("left", function () {
      var rect = d3.select(this).node().getBoundingClientRect();
      var boxWidth = rect.width;
      var halfBoxWidth = boxWidth / 2;
      var boxHeight = rect.height;
      var halfBoxHeight = boxHeight / 2;

      // check top first
      var left = 0;
      var hDiff = 0,
          wDiff = 0;

      if (overlapSz[0] >= boxWidth || boundsCtr[0] + halfBoxWidth < width && boundsCtr[0] - halfBoxWidth >= 0) {
        left = boundsCtr[0] - overlapCtr[0];
        hDiff = overlapBounds[_mapdDraw.AABox2d.MINY] - boxHeight;

        if (hDiff >= 0) {
          // can fit on top of shape and in the center of the shape horizontally
          topOffset = -(boundsCtr[1] - overlapBounds[_mapdDraw.AABox2d.MINY] + Math.min(padding, hDiff) + halfBoxHeight);
          return left + "px";
        }

        hDiff = overlapBounds[_mapdDraw.AABox2d.MAXY] + boxHeight;
        if (hDiff < height) {
          // can fit on bottom and in the center of the shape horizontally
          topOffset = overlapBounds[_mapdDraw.AABox2d.MAXY] - boundsCtr[1] + Math.min(padding, hDiff) + halfBoxHeight;
          return left + "px";
        }
      }

      if (overlapSz[1] >= boxHeight || boundsCtr[1] + halfBoxHeight < height && boundsCtr[1] - halfBoxHeight >= 0) {
        topOffset = overlapCtr[1] - boundsCtr[1];

        wDiff = overlapBounds[_mapdDraw.AABox2d.MINX] - boxWidth;
        if (wDiff >= 0) {
          // can fit on the left in the center of the shape vertically
          left = -(boundsCtr[0] - overlapBounds[_mapdDraw.AABox2d.MINX] + Math.min(padding, wDiff) + halfBoxWidth);
          return left + "px";
        }

        wDiff = overlapBounds[_mapdDraw.AABox2d.MAXX] + boxWidth;
        if (wDiff < width) {
          // can fit on right in the center of the shape vertically
          left = overlapBounds[_mapdDraw.AABox2d.MAXX] - boundsCtr[0] + Math.min(padding, wDiff) + halfBoxWidth;
          return left + "px";
        }
      }

      if (width - overlapSz[0] >= boxWidth && height - overlapSz[1] >= boxHeight) {
        // we can fit the popup box in the remaining negative space.
        // Let's figure out where exactly
        if (Math.abs(boxHeight - overlapSz[1]) < Math.abs(boxWidth - overlapSz[0])) {
          hDiff = height - overlapSz[1] - boxHeight;
          if (overlapBounds[_mapdDraw.AABox2d.MINY] < height - overlapBounds[_mapdDraw.AABox2d.MAXY]) {
            topOffset = Math.min(padding, hDiff) + halfBoxHeight - boundsCtr[1];
          } else {
            topOffset = height - Math.min(padding, hDiff) - halfBoxHeight - boundsCtr[1];
          }

          wDiff = overlapBounds[_mapdDraw.AABox2d.MINX] - boxWidth;
          if (wDiff >= 0) {
            // can fit on the left of the bounds
            left = -(boundsCtr[0] - overlapBounds[_mapdDraw.AABox2d.MINX] + Math.min(padding, wDiff) + halfBoxWidth);
          } else {
            wDiff = overlapBounds[_mapdDraw.AABox2d.MAXX] + boxWidth;
            // can fit on right right of the bounds
            left = overlapBounds[_mapdDraw.AABox2d.MAXX] - boundsCtr[0] + Math.min(padding, wDiff) + halfBoxWidth;
          }
          return left + "px";
        } else {
          wDiff = width - overlapSz[0] - boxWidth;
          if (overlapBounds[_mapdDraw.AABox2d.MINX] < width - overlapBounds[_mapdDraw.AABox2d.MAXX]) {
            left = Math.min(padding, wDiff) + halfBoxWidth - boundsCtr[0];
          } else {
            left = width - Math.min(padding, wDiff) - halfBoxWidth - boundsCtr[0];
          }

          hDiff = overlapBounds[_mapdDraw.AABox2d.MINY] - boxHeight;
          if (hDiff >= 0) {
            // can fit on top of shape and in the center of the shape horizontally
            topOffset = -(boundsCtr[1] - overlapBounds[_mapdDraw.AABox2d.MINY] + Math.min(padding, hDiff) + halfBoxHeight);
          } else {
            hDiff = overlapBounds[_mapdDraw.AABox2d.MAXY] + boxHeight;
            // can fit on bottom and in the center of the shape horizontally
            topOffset = overlapBounds[_mapdDraw.AABox2d.MAXY] - boundsCtr[1] + Math.min(padding, hDiff) + halfBoxHeight;
          }
          return left + "px";
        }
      }

      if (boxWidth * boxHeight < overlapSz[0] * overlapSz[1]) {
        // use the center of the overlapping bounds in the case where the box
        // can't fit anwhere on the outside
        topOffset = overlapCtr[1] - boundsCtr[1];
        left = overlapCtr[0] - boundsCtr[0];
      } else {
        // use the center of the screen
        topOffset = height / 2 - boundsCtr[1];
        left = width / 2 - boundsCtr[0];
      }
      return left + "px";
    }).style("top", function () {
      return topOffset + "px";
    });

    // Copy from popup content
    var copyPopupContent = function copyPopupContent() {
      var copyRange = document.createRange();
      copyRange.selectNodeContents(document.getElementsByClassName(_popup_box_item_wrap_class).item(0));
      window.getSelection().removeAllRanges();
      window.getSelection().addRange(copyRange);
      document.execCommand("copy");
      window.getSelection().removeAllRanges();
    };

    var popupCopyIcon = document.getElementsByClassName(_popup_item_copy_class).item(0);

    popupCopyIcon.addEventListener("click", function () {
      copyPopupContent();
    });

    _layerPopups[chart] = popupBox;

    if (animate) {
      popupDiv.classed("showPopup", true);
    }
  };

  _layer.isPopupDisplayed = function (chart) {
    return _layerPopups[chart] !== undefined;
  };

  _layer.hidePopup = function (chart, hideCallback) {
    if (_layerPopups[chart]) {
      var popup = chart.select("." + _popup_wrap_class);
      if (popup) {
        popup.classed("removePopup", true).on("animationend", function () {
          delete _layerPopups[chart];
          hideCallback(chart);
        });
      }

      _layer._hidePopup(chart);
    }
  };

  _layer.destroyLayer = function (chart) {
    // need to define a "_destroyLayer" method for each
    // layer mixin
    _layer._destroyLayer(chart);
  };

  _layer._addQueryDrivenRenderPropToSet = function (setObj, markPropObj, prop) {
    if (_typeof(markPropObj[prop]) !== "object") {
      return;
    }

    if (typeof markPropObj[prop].field !== "string") {
      return;
    }

    var queryAttr = markPropObj[prop].field;
    addPopupColumnToSet(queryAttr, setObj);
    return setObj;
  };

  return _layer;
}

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = rasterLayerLineMixin;

var _utilsVega = __webpack_require__(19);

var _coreAsync = __webpack_require__(5);

var _utils = __webpack_require__(4);

var _d = __webpack_require__(1);

var d3 = _interopRequireWildcard(_d);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var AUTOSIZE_DOMAIN_DEFAULTS = [100000, 1000];
var AUTOSIZE_RANGE_DEFAULTS = [1.0, 3.0];
var AUTOSIZE_RANGE_MININUM = [1, 1];
var SIZING_THRESHOLD_FOR_AUTOSIZE_RANGE_MININUM = 100000;

function getSizing(sizeAttr, cap) {
  var lastFilteredSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : cap;
  var pixelRatio = arguments[3];
  var layerName = arguments[4];

  if (typeof sizeAttr === "number") {
    return sizeAttr;
  } else if ((typeof sizeAttr === "undefined" ? "undefined" : _typeof(sizeAttr)) === "object" && (sizeAttr.type === "quantitative" || sizeAttr.type === "custom")) {
    return {
      scale: (0, _utilsVega.getSizeScaleName)(layerName),
      field: "strokeWidth"
    };
  } else if (sizeAttr === "auto") {
    var size = Math.min(lastFilteredSize, cap);
    var dynamicRScale = d3.scale.sqrt().domain(AUTOSIZE_DOMAIN_DEFAULTS).range(size > SIZING_THRESHOLD_FOR_AUTOSIZE_RANGE_MININUM ? AUTOSIZE_RANGE_MININUM : AUTOSIZE_RANGE_DEFAULTS).clamp(true);
    return Math.round(dynamicRScale(size) * pixelRatio);
  } else {
    return null;
  }
}

function getColor(color, layerName) {
  if ((typeof color === "undefined" ? "undefined" : _typeof(color)) === "object" && color.type === "density") {
    return {
      scale: (0, _utilsVega.getColorScaleName)(layerName),
      value: 0
    };
  } else if ((typeof color === "undefined" ? "undefined" : _typeof(color)) === "object" && (color.type === "ordinal" || color.type === "quantitative")) {
    return {
      scale: (0, _utilsVega.getColorScaleName)(layerName),
      field: "strokeColor"
    };
  } else if ((typeof color === "undefined" ? "undefined" : _typeof(color)) === "object") {
    return (0, _utilsVega.adjustOpacity)(color.value, color.opacity);
  } else {
    return color;
  }
}

function rasterLayerLineMixin(_layer) {
  var state = null;
  _layer.colorDomain = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);
  _layer.sizeDomain = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);

  _layer.setState = function (setter) {
    if (typeof setter === "function") {
      state = setter(state);
    } else {
      state = setter;
    }

    if (!state.hasOwnProperty("transform")) {
      state.transform = {};
    }

    return _layer;
  };

  _layer.getState = function () {
    return state;
  };

  _layer.getTransforms = function (table, filter, globalFilter, state, lastFilteredSize, isDataExport) {
    var transforms = [];
    var transform = state.transform;
    var _state$encoding = state.encoding,
        size = _state$encoding.size,
        color = _state$encoding.color,
        geocol = _state$encoding.geocol,
        geoTable = _state$encoding.geoTable;

    var rowIdTable = doJoin() ? state.data[1].table : state.data[0].table;

    var fields = [];
    var alias = [];
    var ops = [];

    // Adds /*+ cpu_mode */ in data export query since we are limiting to some number of rows.
    var groupbyDim = state.transform.groupby ? state.transform.groupby.map(function (g, i) {
      return {
        type: "project",
        expr: "" + (isDataExport && i === 0 ? "/*+ cpu_mode */ " : "") + state.data[0].table + "." + g,
        as: "key" + i
      };
    }) : [];

    var groupby = doJoin() ? [{
      type: "project",
      expr: state.data[0].table + "." + state.data[0].attr,
      as: "key0"
    }] : groupbyDim;

    var colorProjection = groupby.length && color.type === "quantitative" ? _utils.parser.parseExpression(color.aggregate) : "SAMPLE(" + rowIdTable + "." + color.field + ")";

    function doJoin() {
      return state.data.length > 1;
    }

    if (groupby.length > 0) {
      transforms.push({
        type: "aggregate",
        fields: fields,
        ops: ops,
        as: alias,
        groupby: groupby
      });
      transforms.push({
        type: "project",
        expr: "LAST_SAMPLE(" + rowIdTable + ".rowid)",
        as: "rowid"
      });
      transforms.push({
        type: "project",
        expr: "SAMPLE(" + geoTable + "." + geocol + ")",
        as: "sampled_geo"
      });
    } else {
      transforms.push({
        type: "project",
        expr: "" + (isDataExport ? "/*+ cpu_mode */ " : "") + geoTable + "." + geocol
      });
    }

    if ((typeof size === "undefined" ? "undefined" : _typeof(size)) === "object" && (size.type === "quantitative" || size.type === "custom")) {
      if (groupby.length > 0 && size.type === "quantitative") {
        fields.push(state.data[0].table + "." + size.field);
        alias.push("strokeWidth");
        ops.push(size.aggregate);
      } else {
        transforms.push({
          type: "project",
          expr: size.field,
          as: "strokeWidth"
        });
      }
    }

    if ((typeof color === "undefined" ? "undefined" : _typeof(color)) === "object" && (color.type === "quantitative" || color.type === "ordinal")) {
      if (groupby.length > 0 && color.colorMeasureAggType !== "Custom") {
        fields.push(colorProjection);
        alias.push("strokeColor");
        ops.push(null);
      } else {
        var expression = color.field || color.aggregate;

        transforms.push({
          type: "project",
          expr: expression,
          as: "strokeColor"
        });
      }
    }

    if (doJoin()) {
      transforms.push({
        type: "filter",
        expr: state.data[0].table + "." + state.data[0].attr + " = " + state.data[1].table + "." + state.data[1].attr
      });
    }

    if (typeof transform.limit === "number") {
      if (transform.sample && !doJoin()) {
        // use Knuth's hash sampling on single data source chart
        transforms.push({
          type: "sample",
          method: "multiplicative",
          size: lastFilteredSize || transform.tableSize,
          limit: transform.limit,
          sampleTable: geoTable
        });
      } else {
        // when geo join is applied, we won't use Knuth's sampling but use LIMIT
        transforms.push({
          type: "limit",
          row: transform.limit
        });
      }
    }

    if (typeof filter === "string" && filter.length) {
      transforms.push({
        type: "filter",
        expr: filter
      });
    }

    if (typeof globalFilter === "string" && globalFilter.length) {
      transforms.push({
        type: "filter",
        expr: globalFilter
      });
    }

    return transforms;
  };

  _layer.getProjections = function () {
    return _layer.getTransforms("", "", "", state, (0, _coreAsync.lastFilteredSize)(_layer.crossfilter().getId())).filter(function (transform) {
      return transform.type === "project" && transform.hasOwnProperty("as");
    }).map(function (projection) {
      return _utils.parser.parseTransform({ select: [] }, projection);
    }).map(function (sql) {
      return sql.select[0];
    });
  };

  function getAutoColorVegaTransforms(data, layerName, statsLayerName) {
    var aggregateNode = {
      type: "aggregate",
      fields: [],
      ops: [],
      as: []
    };

    var transforms = [aggregateNode];
    if (state.encoding.color.type === "quantitative") {
      aggregateNode.fields = aggregateNode.fields.concat(["strokeColor", "strokeColor", "strokeColor", "strokeColor"]);
      aggregateNode.ops = aggregateNode.ops.concat(["min", "max", "avg", "stddev"]);
      aggregateNode.as = aggregateNode.as.concat(["mincol", "maxcol", "avgcol", "stdcol"]);
      transforms.push({
        type: "formula",
        expr: "max(mincol, avgcol-2*stdcol)",
        as: "mincolor"
      }, {
        type: "formula",
        expr: "min(maxcol, avgcol+2*stdcol)",
        as: "maxcolor"
      });
    } else if (state.encoding.color.type === "ordinal") {
      // will be used when we support auto for ordinal color type
      aggregateNode.fields.push("color");
      aggregateNode.ops.push("distinct");
      aggregateNode.as.push("distinctcolor");
    }

    data.push({
      name: statsLayerName,
      source: layerName,
      transform: transforms
    });
  }

  function usesAutoColors() {
    return state.encoding.color.domain === "auto";
  }

  _layer._updateFromMetadata = function (metadata) {
    var layerName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

    if (usesAutoColors() && Array.isArray(metadata.scales)) {
      var colorScaleName = (0, _utilsVega.getColorScaleName)(layerName);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = metadata.scales[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var scale = _step.value;

          if (scale.name === colorScaleName) {
            _layer.colorDomain(scale.domain);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  };

  _layer.__genVega = function (_ref) {
    var table = _ref.table,
        filter = _ref.filter,
        lastFilteredSize = _ref.lastFilteredSize,
        globalFilter = _ref.globalFilter,
        pixelRatio = _ref.pixelRatio,
        layerName = _ref.layerName,
        useProjection = _ref.useProjection;

    var autocolors = usesAutoColors();
    var getStatsLayerName = function getStatsLayerName() {
      return layerName + "_stats";
    };

    var size = getSizing(state.encoding.size, state.transform && state.transform.limit, lastFilteredSize, pixelRatio, layerName);

    var data = [{
      name: layerName,
      format: "lines",
      sql: _utils.parser.writeSQL({
        type: "root",
        source: [].concat(_toConsumableArray(new Set(state.data.map(function (source) {
          return source.table;
        })))).join(", "),
        transform: _layer.getTransforms(table, filter, globalFilter, state, lastFilteredSize)
      }),
      enableHitTesting: state.enableHitTesting
    }];

    var scaledomainfields = {};

    if (autocolors) {
      getAutoColorVegaTransforms(data, layerName, getStatsLayerName());

      if (state.encoding.color.type === "quantitative") {
        scaledomainfields.color = ["mincolor", "maxcolor"];
      } else if (state.encoding.color.type === "ordinal") {
        // will be used when we support auto for ordinal color type
        scaledomainfields.color = ["distinctcolor"];
      }
    }

    var scales = (0, _utilsVega.getScales)(state.encoding, layerName, scaledomainfields, getStatsLayerName());

    var marks = [{
      type: "lines",
      from: {
        data: layerName
      },
      properties: Object.assign({}, {
        x: {
          field: "x"
        },
        y: {
          field: "y"
        },
        strokeColor: getColor(state.encoding.color, layerName),
        strokeWidth: size,
        lineJoin: _typeof(state.mark) === "object" ? state.mark.lineJoin : "bevel"
      })
    }];

    if (useProjection) {
      marks[0].transform = {
        projection: "mercator_map_projection"
      };
    } else {
      marks[0].properties.x.scale = "x";
      marks[0].properties.y.scale = "y";
    }

    return {
      data: data,
      scales: scales,
      marks: marks
    };
  };

  _layer.viewBoxDim = (0, _utilsVega.createRasterLayerGetterSetter)(_layer, null);

  (0, _utilsVega.createVegaAttrMixin)(_layer, "size", 3, 1, true);

  var _vega = null;
  var _minMaxCache = {};
  var _cf = null;

  _layer.crossfilter = function (cf) {
    if (!arguments.length) {
      return _cf;
    }
    _cf = cf;
    return _layer;
  };

  _layer._requiresCap = function () {
    return false;
  };

  _layer._genVega = function (chart, layerName, group, query) {
    // needed to set LastFilteredSize when linemap map first initialized
    if (_layer.viewBoxDim()) {
      _layer.viewBoxDim().groupAll().valueAsync().then(function (value) {
        (0, _coreAsync.setLastFilteredSize)(_layer.crossfilter().getId(), value);
      });
    }

    _vega = _layer.__genVega({
      layerName: layerName,
      table: _layer.crossfilter().getTable()[0],
      filter: _layer.crossfilter().getFilterString(layerName),
      globalFilter: _layer.crossfilter().getGlobalFilterString(),
      lastFilteredSize: (0, _coreAsync.lastFilteredSize)(_layer.crossfilter().getId()),
      pixelRatio: chart._getPixelRatio(),
      useProjection: chart._useGeoTypes
    });

    return _vega;
  };

  _layer._addRenderAttrsToPopupColumnSet = function (chart, popupColsSet) {
    if (chart._useGeoTypes) {
      if (state.encoding.geocol && state.transform.groupby && state.transform.groupby.length) {
        popupColsSet.add("sampled_geo");
      } else {
        popupColsSet.add(state.encoding.geocol);
      }
    }

    if (_vega && Array.isArray(_vega.marks) && _vega.marks.length > 0 && _vega.marks[0].properties) {
      _utilsVega.renderAttributes.forEach(function (rndrProp) {
        if (rndrProp !== "x" && rndrProp !== "y") {
          _layer._addQueryDrivenRenderPropToSet(popupColsSet, _vega.marks[0].properties, rndrProp);
        }
      });
    }
  };

  _layer._areResultsValidForPopup = function (results) {
    return Boolean(state.encoding.geocol && (results[state.encoding.geocol] || results.sampled_geo));
  };

  _layer._displayPopup = function (svgProps) {
    return (0, _utilsVega.__displayPopup)(_extends({}, svgProps, { _vega: _vega, _layer: _layer, state: state }));
  };

  var _scaledPopups = {};
  _layer._hidePopup = function (chart, hideCallback) {
    var mapPoly = chart.select(".map-polyline");

    if (mapPoly) {
      if (_scaledPopups[chart]) {
        mapPoly.classed("removePoly", true);
      } else {
        mapPoly.classed("fadeOutPoly", true);
        // mapPoly.attr('transform', 'scale(0, 0)');
      }

      if (hideCallback) {
        mapPoly.on("animationend", function () {
          hideCallback(chart);
        });
      }

      delete _scaledPopups[chart];
    }
  };

  _layer._destroyLayer = function (chart) {
    var viewBoxDim = _layer.viewBoxDim();
    if (viewBoxDim) {
      viewBoxDim.dispose();
    }
  };

  return _layer;
}

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rasterMixin;

var _core = __webpack_require__(3);

var _coreAsync = __webpack_require__(5);

var _utils = __webpack_require__(4);

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function rasterMixin(_chart) {
  var _con = window.hasOwnProperty("con") ? con : null;
  var _sampling = false;
  var _tableName = null;
  var _popupColumns = [];
  var _popupColumnsMapped = {};
  var _popupSearchRadius = 2;
  var _popupFunction = null;
  var _colorBy = null;
  var _sizeBy = null;
  var _showColorByInPopup = false;
  var _mouseLeave = false; // used by displayPopup to maybe return early
  var _minMaxCache = {};
  var _crossfilter = null;

  var _data_events = ["preData"];
  var _listeners = _d2.default.dispatch.apply(_d2.default, _data_events);
  var _on = _chart.on.bind(_chart);

  var _popupDisplayable = true;

  _chart.popupDisplayable = function (displayable) {
    _popupDisplayable = Boolean(displayable);
  };

  _chart.on = function (event, listener) {
    if (_data_events.indexOf(event) === -1) {
      _on(event, listener);
    } else {
      _listeners.on(event, listener);
    }
    return _chart;
  };

  _chart._invokePreDataListener = function (f) {
    if (f !== "undefined") {
      _listeners.preData(_chart, f);
    }
  };

  _chart.getMinMax = function (value) {
    if (_minMaxCache[value]) {
      return Promise.resolve(_minMaxCache[value]);
    }

    return _chart.crossfilter().groupAll().reduce([{ expression: value, agg_mode: "min", name: "minimum" }, { expression: value, agg_mode: "max", name: "maximum" }]).valuesAsync(true).then(function (bounds) {
      _minMaxCache[value] = [bounds.minimum, bounds.maximum];
      return _minMaxCache[value];
    });
  };

  _chart.getTopValues = function (value) {
    var NUM_TOP_VALUES = 10;
    var OFFSET = 0;

    if (_minMaxCache[value]) {
      return Promise.resolve(_minMaxCache[value]);
    }

    return _chart.crossfilter().dimension(value).order("val").group().reduceCount(value).topAsync(NUM_TOP_VALUES, OFFSET, null, true).then(function (results) {
      return results.map(function (result) {
        return result.key0;
      });
    });
  };

  _chart.crossfilter = function (_) {
    if (!arguments.length) {
      return _crossfilter;
    }
    _crossfilter = _;
    return _chart;
  };

  _chart.xRangeFilter = function (range) {
    if (!_chart.xDim()) {
      throw new Error("Must set xDim before invoking xRange");
    }

    var xValue = _chart.xDim().value()[0];

    if (!arguments.length) {
      return _minMaxCache[xValue];
    }

    _minMaxCache[xValue] = range;
    return _chart;
  };

  _chart.yRangeFilter = function (range) {
    if (!_chart.yDim()) {
      throw new Error("Must set yDim before invoking yRange");
    }

    var yValue = _chart.yDim().value()[0];

    if (!arguments.length) {
      return _minMaxCache[yValue];
    }

    _minMaxCache[yValue] = range;
    return _chart;
  };

  _chart.popupSearchRadius = function (popupSearchRadius) {
    if (!arguments.length) {
      return _popupSearchRadius;
    }
    _popupSearchRadius = popupSearchRadius;
    return _chart;
  };

  _chart._resetVegaSpec = function () {
    var pixelRatio = this._getPixelRatio();
    _chart._vegaSpec.width = Math.round(_chart.width() * pixelRatio);
    _chart._vegaSpec.height = Math.round(_chart.height() * pixelRatio);
    _chart._vegaSpec.data = [{
      name: "table",
      sql: "select x, y from tweets;"
    }];
    if (_tableName) {
      _chart._vegaSpec.data[0].dbTableName = _tableName;
    }
    _chart._vegaSpec.scales = [];
    _chart._vegaSpec.marks = [];
  };

  _chart.con = function (_) {
    if (!arguments.length) {
      return _con;
    }
    _con = _;
    return _chart;
  };

  _chart.popupColumns = function (popupColumns) {
    if (!arguments.length) {
      return _popupColumns;
    }
    _popupColumns = popupColumns;
    return _chart;
  };

  _chart.popupColumnsMapped = function (popupColumnsMapped) {
    if (!arguments.length) {
      return _popupColumnsMapped;
    }
    _popupColumnsMapped = popupColumnsMapped;
    return _chart;
  };

  _chart.tableName = function (tableName) {
    if (!arguments.length) {
      return _tableName;
    }
    _tableName = tableName;
    return _chart;
  };

  _chart.popupFunction = function (popupFunction) {
    if (!arguments.length) {
      return _popupFunction;
    }
    _popupFunction = popupFunction;
    return _chart;
  };

  // _determineScaleType because there is no way to determine the scale type
  // in d3 except for looking to see what member methods exist for it
  _chart.sampling = function (isSetting) {
    // isSetting should be true or false
    if (!arguments.length) {
      return _sampling;
    }
    if (isSetting && !_sampling) {
      // if wasn't sampling
      (0, _core.incrementSampledCount)();
    } else if (!isSetting && _sampling) {
      (0, _core.decrementSampledCount)();
    }
    _sampling = isSetting;
    if (_sampling === false) {
      _chart.dimension().samplingRatio(null); // unset sampling
    }
    return _chart;
  };

  _chart.setSample = function () {
    if (_sampling) {
      var id = _chart.dimension().getCrossfilterId();
      var filterSize = (0, _coreAsync.lastFilteredSize)(id);
      if (filterSize == undefined) {
        _chart.dimension().samplingRatio(null);
      } else {
        _chart.dimension().samplingRatio(Math.min(_chart.cap() / filterSize, 1.0));
      }
    }
  };

  _chart._determineScaleType = function (scale) {
    var scaleType = null;
    if (scale.rangeBand !== undefined) {
      return "ordinal";
    }
    if (scale.exponent !== undefined) {
      return "power";
    }
    if (scale.base !== undefined) {
      return "log";
    }
    if (scale.quantiles !== undefined) {
      return "quantiles";
    }
    if (scale.interpolate !== undefined) {
      return "linear";
    }
    return "quantize";
  };

  _chart.vegaSpec = function (_) {
    if (!arguments.length) {
      return _chart._vegaSpec;
    }
    _chart._vegaSpec = _;
    return _chart;
  };

  _chart.colorBy = function (_) {
    if (!arguments.length) {
      return _colorBy;
    }
    _colorBy = _;
    return _chart;
  };

  _chart.sizeBy = function (_) {
    if (!arguments.length) {
      return _sizeBy;
    }
    _sizeBy = _;
    return _chart;
  };

  _chart.getClosestResult = function getClosestResult(point, callback) {
    if (_chart.drawMode && _chart.drawMode() || !_chart.popupColumns().length) {
      return;
    }
    var height = typeof _chart.effectiveHeight === "function" ? _chart.effectiveHeight() : _chart.height();
    var pixelRatio = _chart._getPixelRatio() || 1;
    var pixel = new TPixel({
      x: Math.round(point.x * pixelRatio),
      y: Math.round((height - point.y) * pixelRatio)
    });
    var tableName = _chart.tableName();
    var columns = getColumnsWithPoints();
    // TODO best to fail, skip cb, or call cb wo args?
    if (!point || !tableName || !columns.length || columns.length === 3 && hideColorColumnInPopup()) {
      return;
    }

    _chart.con().getResultRowForPixelAsync(_chart.__dcFlag__, pixel, { table: columns }, _popupSearchRadius * pixelRatio).then(function (results) {
      return callback(results[0]);
    });
  };

  _chart.displayPopup = function displayPopup(result) {
    if (!_popupDisplayable || _mouseLeave || !result || !result.row_set || !result.row_set.length) {
      return;
    }
    if (_chart.select(".map-popup").empty()) {
      // show only one popup at a time.
      var data = result.row_set[0];
      var mappedData = mapDataViaColumns(data, _popupColumnsMapped);
      if (Object.keys(mappedData).length === 2) {
        return;
      } // xPoint && yPoint
      var offsetBridge = 0;

      var width = typeof _chart.effectiveWidth === "function" ? _chart.effectiveWidth() : _chart.width();
      var height = typeof _chart.effectiveHeight === "function" ? _chart.effectiveHeight() : _chart.height();
      var margins = typeof _chart.margins === "function" ? _chart.margins() : { left: 0, right: 0, top: 0, bottom: 0 };

      var xscale = _chart.x();
      var yscale = _chart.y();

      var origXRange = xscale.range();
      var origYRange = yscale.range();

      xscale.range([0, width]);
      yscale.range([0, height]);

      var xPixel = xscale(data.xPoint) + margins.left;
      var yPixel = height - yscale(data.yPoint) + margins.top;

      // restore the original ranges so we don't screw anything else up
      xscale.range(origXRange);
      yscale.range(origYRange);

      var mapPopup = _chart.root().append("div").attr("class", "map-popup");
      mapPopup.on("wheel", function () {
        _chart.select(".map-popup").remove();
      });
      mapPopup.append("div").attr("class", "map-point-wrap").append("div").attr("class", "map-point").style({ left: xPixel + "px", top: yPixel + "px" }).append("div").attr("class", "map-point-gfx").style("background", colorPopupBackground(result.row_set[0]));
      mapPopup.append("div").attr("class", "map-popup-wrap").style({ left: xPixel + "px", top: yPixel + "px" }).append("div").attr("class", "map-popup-box").html(_chart.popupFunction() ? _popupFunction(mappedData) : renderPopupHTML(mappedData)).style("left", function () {
        var boxWidth = _d2.default.select(this).node().getBoundingClientRect().width;
        var overflow = _chart.width() - (xPixel + boxWidth / 2) < 0 ? _chart.width() - (xPixel + boxWidth / 2) - 6 : xPixel - boxWidth / 2 < 0 ? -(xPixel - boxWidth / 2) + 6 : 0;
        offsetBridge = boxWidth / 2 - overflow;
        return overflow + "px";
      }).classed("pop-down", function () {
        var boxHeight = _d2.default.select(this).node().getBoundingClientRect().height;
        return yPixel - (boxHeight + 12) < 8;
      }).append("div").attr("class", "map-popup-bridge").style("left", function () {
        return offsetBridge + "px";
      });
    }
  };

  _chart.hidePopup = function hidePopup() {
    if (!_chart.select(".map-popup").empty()) {
      _chart.select(".map-popup-wrap").classed("removePopup", true).on("animationend", function () {
        _chart.select(".map-popup").remove();
      });
      _chart.select(".map-point").classed("removePoint", true);
    }
  };

  _chart._vegaSpec = {};

  return _chart;

  function getColumnsWithPoints() {
    var columns = _chart.popupColumns().slice();

    if (typeof _chart.useLonLat === "function" && _chart.useLonLat()) {
      columns.push("conv_4326_900913_x(" + _chart._xDimName + ") AS xPoint");
      columns.push("conv_4326_900913_y(" + _chart._yDimName + ") AS yPoint");
    } else {
      columns.push(_chart._xDimName + " AS xPoint");
      columns.push(_chart._yDimName + " AS yPoint");
    }

    if (_chart.colorBy() && columns.indexOf(_chart.colorBy().value) === -1) {
      columns.push(_chart.colorBy().value);
    }

    return columns;
  }

  function renderPopupHTML(data) {
    var html = "";
    for (var key in data) {
      if (key !== "xPoint" && key !== "yPoint" && !(_chart.colorBy() && key === _chart.colorBy().value && hideColorColumnInPopup())) {
        html = html + ('<div class="map-popup-item"><span class="popup-item-key">' + key + ':</span><span class="popup-item-val"> ' + _utils.utils.formatValue(data[key]) + "</span></div>");
      }
    }
    return html;
  }

  function colorPopupBackground(data) {
    if (!_chart.colors().domain || !_chart.colorBy()) {
      return _chart.defaultColor();
    } else if (isNaN(_chart.colors().domain()[0])) {
      var matchIndex = _chart.colors().domain().indexOf(data[_chart.colorBy().value]);
      return matchIndex !== -1 ? _chart.colors().range()[matchIndex] : _chart.defaultColor();
    } else {
      return _chart.colors()(data[_chart.colorBy().value]);
    }
  }

  function mapDataViaColumns(data, _popupColumnsMapped) {
    var newData = {};
    for (var key in data) {
      var newKey = _popupColumnsMapped[key] || key;
      newData[newKey] = data[key];
    }
    return newData;
  }

  function hideColorColumnInPopup() {
    return _chart.colorBy() && _chart.popupColumns().indexOf(_chart.colorBy().value) === -1;
  }
}

/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = legendContinuous;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function legendContinuous() {
  var LABEL_GAP = 2;
  var _legend = {},
      _parent = void 0,
      _x = 0,
      _y = 0,
      _itemHeight = 12,
      _gap = 5,
      _horizontal = false,
      _legendWidth = 560,
      _itemWidth = 70,
      _autoItemWidth = false;

  var _g = void 0;

  /* OVERRIDE -----------------------------------------------------------------*/
  var _wrapper = void 0;
  var _lock = void 0;
  var _lockable = true;
  var _isLocked = false;
  /* --------------------------------------------------------------------------*/

  _legend.parent = function (p) {
    if (!arguments.length) {
      return _parent;
    }
    _parent = p;
    return _legend;
  };

  _legend.render = function () {
    /* OVERRIDE -----------------------------------------------------------------*/
    _parent.root().select(".legend-cont").remove();

    _wrapper = _parent.root().append("div").attr("class", "legend-cont").style("display", _parent.colorByExpr() === null ? "none" : "block");

    var title = _wrapper.append("div").attr("class", "legend-title").append("span").text(_parent.colorByExpr());

    var legendGroup = _wrapper.append("div").attr("class", "legend-group");

    if (_lockable) {
      generateLock();
    }

    var legendables = _parent.legendablesContinuous();

    var itemEnter = legendGroup.selectAll(".legend-item").data(legendables).enter().append("div").attr("class", "legend-item");

    itemEnter.append("div").attr("class", "legend-swatch").style("background-color", function (d) {
      return d ? d.color : "#e2e2e2";
    });

    itemEnter.append("div").attr("class", "legend-label").append("span").text(function (d) {
      return d ? d.value : 0;
    });

    legendGroup.selectAll(".legend-item:first-child , .legend-item:last-child").on("mouseenter", function () {
      var item = _d2.default.select(this);
      var w = item.select("span").node().getBoundingClientRect().width + 8;
      item.select(".legend-input input").style("width", w + "px");
    }).selectAll(".legend-label").append("div").attr("class", "legend-input").append("input").attr("value", function (d) {
      return d ? d.value : 0;
    }).on("focus", function () {
      this.select();

      var item = _d2.default.select(this.parentNode.parentNode);
      item.classed("active", true);

      var w = item.select("span").node().getBoundingClientRect().width + 8;
      item.select(".legend-input input").style("width", w + "px");
    }).on("blur", function () {
      _d2.default.select(this.parentNode.parentNode).classed("active", false);
    }).on("change", onChange);
  };

  function legendItemHeight() {
    return _gap + _itemHeight;
  }

  _legend.x = function (x) {
    if (!arguments.length) {
      return _x;
    }
    _x = x;
    return _legend;
  };

  _legend.y = function (y) {
    if (!arguments.length) {
      return _y;
    }
    _y = y;
    return _legend;
  };

  _legend.gap = function (gap) {
    if (!arguments.length) {
      return _gap;
    }
    _gap = gap;
    return _legend;
  };

  _legend.itemHeight = function (itemHeight) {
    if (!arguments.length) {
      return _itemHeight;
    }
    _itemHeight = itemHeight;
    return _legend;
  };

  _legend.horizontal = function (horizontal) {
    if (!arguments.length) {
      return _horizontal;
    }
    _horizontal = horizontal;
    return _legend;
  };

  _legend.legendWidth = function (legendWidth) {
    if (!arguments.length) {
      return _legendWidth;
    }
    _legendWidth = legendWidth;
    return _legend;
  };

  _legend.itemWidth = function (itemWidth) {
    if (!arguments.length) {
      return _itemWidth;
    }
    _itemWidth = itemWidth;
    return _legend;
  };

  _legend.autoItemWidth = function (autoItemWidth) {
    if (!arguments.length) {
      return _autoItemWidth;
    }
    _autoItemWidth = autoItemWidth;
    return _legend;
  };
  /* OVERRIDE -----------------------------------------------------------------*/
  function generateLock() {
    _lock = _wrapper.append("div").attr("class", "legend-lock").classed("js-isLocked", _isLocked).on("click", toggleLock);

    _lock.append("svg").attr("class", "svg-icon").classed("icon-lock", true).attr("viewBox", "0 0 48 48").append("use").attr("xlink:href", "#icon-lock");
    _lock.append("svg").attr("class", "svg-icon").classed("icon-unlock", true).attr("viewBox", "0 0 48 48").append("use").attr("xlink:href", "#icon-unlock");
    return _lock;
  }

  function toggleLock() {
    _isLocked = !_isLocked;
    _lock.classed("js-isLocked", _isLocked);

    if (_isLocked) {
      _parent.legendLock()();
    } else {
      _parent.legendUnlock()(true);
    }
  }

  function onChange() {
    var startVal = _wrapper.select(".legend-item:first-child .legend-input input")[0][0].value;
    var endVal = _wrapper.select(".legend-item:last-child .legend-input input")[0][0].value;

    _parent.legendInputChange()([startVal, endVal], _parent.colors().range().length);

    _isLocked = true;
    _lock.classed("js-isLocked", _isLocked);
  }

  /* --------------------------------------------------------------------------*/

  return _legend;
}

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = legend;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

var _utils = __webpack_require__(4);

var _dcLegendMixin = __webpack_require__(346);

var _dcLegendMixin2 = _interopRequireDefault(_dcLegendMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Legend is a attachable widget that can be added to other dc charts to render horizontal legend
 * labels.
 *
 * @name legend
 * @memberof dc
 * @example
 * chart.legend(dc.legend().x(400).y(10).itemHeight(13).gap(5))
 * @return {dc.legend}
 */
function legend() {
  var LABEL_GAP = 2;

  var _legend = {},
      _parent = void 0,
      _x = 0,
      _y = 0,
      _itemHeight = 12,
      _gap = 5,
      _horizontal = false,
      _legendWidth = 560,
      _itemWidth = 70,
      _autoItemWidth = false;

  var _g = void 0;

  _legend.parent = function (p) {
    if (!arguments.length) {
      return _parent;
    }
    _parent = p;
    return _legend;
  };

  _legend.render = function () {
    _parent.svg().select("g.dc-legend").remove();
    _g = _parent.svg().append("g").attr("class", "dc-legend").attr("transform", "translate(" + _x + "," + _y + ")");
    var legendables = _parent.legendables();

    var itemEnter = _g.selectAll("g.dc-legend-item").data(legendables).enter().append("g").attr("class", "dc-legend-item").on("mouseover", function (d) {
      _parent.legendHighlight(d);
    }).on("mouseout", function (d) {
      _parent.legendReset(d);
    }).on("click", function (d) {
      d.chart.legendToggle(d);
    });

    _g.selectAll("g.dc-legend-item").classed("fadeout", function (d) {
      return d.chart.isLegendableHidden(d);
    });

    if (legendables.some((0, _utils.pluck)("dashstyle"))) {
      itemEnter.append("line").attr("x1", 0).attr("y1", _itemHeight / 2).attr("x2", _itemHeight).attr("y2", _itemHeight / 2).attr("stroke-width", 2).attr("stroke-dasharray", (0, _utils.pluck)("dashstyle")).attr("stroke", (0, _utils.pluck)("color"));
    } else {
      itemEnter.append("rect").attr("width", _itemHeight).attr("height", _itemHeight).attr("fill", function (d) {
        return d ? d.color : "blue";
      });
    }

    itemEnter.append("text").text((0, _utils.pluck)("name")).attr("x", _itemHeight + LABEL_GAP).attr("y", function () {
      return _itemHeight / 2 + (this.clientHeight ? this.clientHeight : 13) / 2 - 2;
    });

    var _cumulativeLegendTextWidth = 0;
    var row = 0;
    itemEnter.attr("transform", function (d, i) {
      if (_horizontal) {
        var translateBy = "translate(" + _cumulativeLegendTextWidth + "," + row * legendItemHeight() + ")";
        var itemWidth = _autoItemWidth === true ? this.getBBox().width + _gap : _itemWidth;

        if (_cumulativeLegendTextWidth + itemWidth >= _legendWidth) {
          ++row;
          _cumulativeLegendTextWidth = 0;
        } else {
          _cumulativeLegendTextWidth = _cumulativeLegendTextWidth + itemWidth;
        }
        return translateBy;
      } else {
        return "translate(0," + i * legendItemHeight() + ")";
      }
    });
  };

  function legendItemHeight() {
    return _gap + _itemHeight;
  }

  /**
   * Set or get x coordinate for legend widget.
   * @name x
   * @memberof dc.legend
   * @instance
   * @param  {Number} [x=0]
   * @return {Number}
   * @return {dc.legend}
   */
  _legend.x = function (x) {
    if (!arguments.length) {
      return _x;
    }
    _x = x;
    return _legend;
  };

  /**
   * Set or get y coordinate for legend widget.
   * @name y
   * @memberof dc.legend
   * @instance
   * @param  {Number} [y=0]
   * @return {Number}
   * @return {dc.legend}
   */
  _legend.y = function (y) {
    if (!arguments.length) {
      return _y;
    }
    _y = y;
    return _legend;
  };

  /**
   * Set or get gap between legend items.
   * @name gap
   * @memberof dc.legend
   * @instance
   * @param  {Number} [gap=5]
   * @return {Number}
   * @return {dc.legend}
   */
  _legend.gap = function (gap) {
    if (!arguments.length) {
      return _gap;
    }
    _gap = gap;
    return _legend;
  };

  /**
   * Set or get legend item height.
   * @name itemHeight
   * @memberof dc.legend
   * @instance
   * @param  {Number} [itemHeight=12]
   * @return {Number}
   * @return {dc.legend}
   */
  _legend.itemHeight = function (itemHeight) {
    if (!arguments.length) {
      return _itemHeight;
    }
    _itemHeight = itemHeight;
    return _legend;
  };

  /**
   * Position legend horizontally instead of vertically.
   * @name horizontal
   * @memberof dc.legend
   * @instance
   * @param  {Boolean} [horizontal=false]
   * @return {Boolean}
   * @return {dc.legend}
   */
  _legend.horizontal = function (horizontal) {
    if (!arguments.length) {
      return _horizontal;
    }
    _horizontal = horizontal;
    return _legend;
  };

  /**
   * Maximum width for horizontal legend.
   * @name legendWidth
   * @memberof dc.legend
   * @instance
   * @param  {Number} [legendWidth=500]
   * @return {Number}
   * @return {dc.legend}
   */
  _legend.legendWidth = function (legendWidth) {
    if (!arguments.length) {
      return _legendWidth;
    }
    _legendWidth = legendWidth;
    return _legend;
  };

  /**
   * legendItem width for horizontal legend.
   * @name itemWidth
   * @memberof dc.legend
   * @instance
   * @param  {Number} [itemWidth=70]
   * @return {Number}
   * @return {dc.legend}
   */
  _legend.itemWidth = function (itemWidth) {
    if (!arguments.length) {
      return _itemWidth;
    }
    _itemWidth = itemWidth;
    return _legend;
  };

  /**
   * Turn automatic width for legend items on or off. If true, {@link #dc.legend+itemWidth itemWidth} is ignored.
   * This setting takes into account {@link #dc.legend+gap gap}.
   * @name autoItemWidth
   * @memberof dc.legend
   * @instance
   * @param  {Boolean} [autoItemWidth=false]
   * @return {Boolean}
   * @return {dc.legend}
   */
  _legend.autoItemWidth = function (autoItemWidth) {
    if (!arguments.length) {
      return _autoItemWidth;
    }
    _autoItemWidth = autoItemWidth;
    return _legend;
  };

  /**
    #### .legendText([legendTextFunction])
    Set or get the legend text function. The legend widget uses this function to render
    the legend text on each item. If no function is specified the legend widget will display
    the names associated with each group.
     Default: pluck('name')
     ```js
    // create numbered legend items
    chart.legend(dc.legend().legendText(function(d, i) { return i + '. ' + d.name; }))
     // create legend displaying group counts
    chart.legend(dc.legend().legendText(function(d) { return d.name + ': ' d.data; }))
    ```
    **/
  _legend.legendText = function (_) {
    if (!arguments.length) {
      return _legendText;
    }
    _legendText = _;
    return _legend;
  };

  _legend = (0, _dcLegendMixin2.default)(_legend);

  return _legend;
}

/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = legendMixin;
function legendMixin(legend) {
  legend._scrollPos = 0;
  legend._expanded = true;
  legend._heightRatio = 3;
  legend._title = "Legend";
  legend._key = "key0";

  legend.legendType = function () {
    return "custom";
  };

  legend.render = function () {
    // Does not re-render if a custom cursor is on the screen
    if (document.getElementById("cursor") !== null) {
      return;
    }

    legend.parent().root().select(".dc-legend").remove();

    var wrapper = legend.parent().root().append("div").attr("class", "dc-legend").classed("collapsed", !legend._expanded);

    var header = wrapper.append("div").attr("class", "dc-legend-header").text(legend._expanded ? legend._title : "Legend").on("click", function () {
      legend._expanded = !legend._expanded;
      legend.render();
    });

    if (legend._expanded) {
      header.append("div").attr("class", "toggle-btn");

      var body = wrapper.append("div").attr("class", "dc-legend-body").style("max-height", legend.parent().height() / legend._heightRatio + "px").on("scroll", function () {
        legend._scrollPos = body.node().scrollTop;
      });

      var legendables = legend.legendables();

      var itemEnter = body.selectAll(".dc-legend-item").data(legendables).enter().append("div").attr("class", "dc-legend-item");

      itemEnter.append("div").attr("class", "legend-item-color").style("background", function (d) {
        return d ? d.color : "#868686";
      });

      itemEnter.append("div").attr("class", "legend-item-text").text(function (d) {
        return d.name;
      });

      var bodyNode = body.node();
      if (bodyNode) {
        // fix for #4196#issuecomment-376704328
        bodyNode.scrollTop = legend._scrollPos;
      }
    }
  };

  legend.removeLegend = function () {
    legend.parent().root().select(".dc-legend").remove();
    legend.parent().legend(null);
  };

  legend.legendables = function () {
    var colors = legend.parent().colors();
    return zip2(colors.domain(), colors.range()).map(function (data) {
      return {
        name: data[0],
        color: data[1],
        chart: legend.parent()
      };
    });
  };

  legend.setTitle = function (title) {
    legend._title = title;
    return legend;
  };

  legend.setKey = function (key) {
    legend._key = key;
    return legend;
  };

  function zip2(list1, list2) {
    return (list1.length < list2.length ? list1 : list2).map(function (_, i) {
      return [list1[i], list2[i]];
    });
  }

  return legend;
}

/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = legendCont;

var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OFFSET_WIDTH = 8;

function unLockedPreRedrawRenderHandler(chart) {
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : chart.data();

  if (!data.image) {
    chart.colorDomain(_d2.default.extent(data, chart.colorAccessor()));
  }
}

function legendCont() {
  var _legend = {};
  var _parent = null;
  var _legendTitle = "";
  var _chartType = "";
  var _wrapper = null;
  var _lock = null;
  var _minMax = null;
  var _isLocked = false;

  _legend.legendType = function () {
    return "quantitative";
  };

  _legend.isLocked = function (_) {
    if (!arguments.length) {
      return _isLocked;
    }
    _isLocked = _;
    return _legend;
  };

  _legend.parent = function (p) {
    if (!arguments.length) {
      return _parent;
    }
    _parent = p;
    return _legend;
  };

  _legend.minMax = function (_) {
    if (!arguments.length) {
      return _minMax;
    }
    _minMax = _;
    return _legend;
  };

  _legend.legendTitle = function (_) {
    if (!arguments.length) {
      return _legendTitle;
    }
    _legendTitle = _;
    return _legend;
  };

  _legend.chartType = function (_) {
    if (!arguments.length) {
      return _chartType;
    }
    _chartType = _;
    return _legend;
  };

  _legend.removeLegend = function () {
    _parent.root().select(".legend-cont").remove();
    _parent._invokeClearCustomContLegendListener();
    _parent.legend(null);
  };

  _legend.render = function () {
    _parent.root().select(".legend-cont").remove();

    _wrapper = _parent.root().append("div").attr("class", "legend-cont");

    var legendGroup = _wrapper.append("div").attr("class", "legend-group");

    initLock();

    var legendables = _parent.legendablesContinuous();

    var itemEnter = legendGroup.selectAll(".legend-item").data(legendables).enter().append("div").attr("class", "legend-item");

    itemEnter.append("div").attr("class", "legend-swatch").style("background-color", function (d) {
      return d ? d.color : "#e2e2e2";
    }); // eslint-disable-line no-confusing-arrow

    itemEnter.append("div").attr("class", "legend-label").append("span").text(function (d) {
      return (typeof d === "undefined" ? "undefined" : _typeof(d)) === "object" && d.value !== "NaN" ? d.value : 0;
    }); // eslint-disable-line no-confusing-arrow

    legendGroup.selectAll(".legend-item:first-child , .legend-item:last-child").on("mouseenter", function () {
      var item = _d2.default.select(this);
      var w = item.select("span").node().getBoundingClientRect().width + OFFSET_WIDTH;
      item.select(".legend-input input").style("width", w + "px");
    }).selectAll(".legend-label").append("div").attr("class", "legend-input").append("input").attr("value", function (d) {
      return (typeof d === "undefined" ? "undefined" : _typeof(d)) === "object" && d.value !== "NaN" ? d.value : 0;
    }) // eslint-disable-line no-confusing-arrow
    .on("click", function () {
      this.select();
      var item = _d2.default.select(this.parentNode.parentNode);
      item.classed("active", true);

      var w = item.select("span").node().getBoundingClientRect().width + OFFSET_WIDTH;
      item.select(".legend-input input").style("width", w + "px");
    }).on("blur", function () {
      _d2.default.select(this.parentNode.parentNode).classed("active", false);
    }).on("change", onChange);
  };

  function initLock() {
    _lock = _wrapper.append("div").attr("class", "legend-lock").classed("js-isLocked", _isLocked).on("click", toggleLock);

    var lockIcon = _lock.append("svg").attr("class", "svg-icon").classed("icon-lock", true).attr("viewBox", "0 0 48 48");

    lockIcon.append("g").style("stroke", "white").style("stroke-width", "6").append("use").attr("xlink:href", "#icon-lock");

    lockIcon.append("use").attr("xlink:href", "#icon-lock");

    var unLockIcon = _lock.append("svg").attr("class", "svg-icon").classed("icon-unlock", true).attr("viewBox", "0 0 48 48");

    unLockIcon.append("g").style("stroke", "white").style("stroke-width", "6").append("use").attr("xlink:href", "#icon-unlock");

    unLockIcon.append("use").attr("xlink:href", "#icon-unlock");

    if (_isLocked) {
      _parent.on("preRender.color", null);
      _parent.on("preRedraw.color", null);
    } else {
      _parent.on("preRender.color", unLockedPreRedrawRenderHandler);
      _parent.on("preRedraw.color", unLockedPreRedrawRenderHandler);
    }
  }

  function toggleLock() {
    _isLocked = !_isLocked;

    if (_isLocked) {
      _parent._invokeSetCustomContLegendListener({
        detail: _parent.colors().domain()
      });
    } else {
      var minMax = _chartType === "pointmap" || _chartType === "backendScatter" ? _minMax : _d2.default.extent(_parent.data(), _parent.colorAccessor());
      if (minMax) {
        _parent.colorDomain(minMax);
      }
      _parent._invokeClearCustomContLegendListener();
    }
    _parent.redrawAsync();
  }

  function onChange() {
    var parseVal = function parseVal(val) {
      return parseFloat(val.replace(/,/g, ""));
    };
    var currVal = _d2.default.select(this).attr("value");
    var inputBox1 = parseVal(_wrapper.select(".legend-item:first-child .legend-input input").node().value);
    var inputBox2 = parseVal(_wrapper.select(".legend-item:last-child .legend-input input").node().value);

    var startVal = isFinite(inputBox1) ? inputBox1 : _parent.colorDomain()[0];
    var endVal = isFinite(inputBox2) ? inputBox2 : _parent.colorDomain()[1];

    if (!isNaN(startVal) && !isNaN(endVal)) {
      _isLocked = true;
      _parent.colorDomain([startVal, endVal]).on("preRedraw.color", null).redrawAsync();
      _parent._invokeSetCustomContLegendListener({
        detail: [startVal, endVal]
      });
    } else {
      _d2.default.select(this).property("value", currVal);
    }
  }

  return _legend;
}

/***/ }),
/* 348 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 349 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 350 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 351 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _d = __webpack_require__(1);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function () {
  // Inspired by http://informationandvisualization.de/blog/box-plot
  _d2.default.box = function () {
    var width = 1,
        height = 1,
        duration = 0,
        domain = null,
        value = Number,
        whiskers = boxWhiskers,
        quartiles = boxQuartiles,
        tickFormat = null;

    // For each small multiple
    function box(g) {
      g.each(function (d, i) {
        d = d.map(value).sort(_d2.default.ascending);
        var g = _d2.default.select(this),
            n = d.length,
            min = d[0],
            max = d[n - 1];

        // Compute quartiles. Must return exactly 3 elements.
        var quartileData = d.quartiles = quartiles(d);

        // Compute whiskers. Must return exactly 2 elements, or null.
        var whiskerIndices = whiskers && whiskers.call(this, d, i),
            whiskerData = whiskerIndices && whiskerIndices.map(function (i) {
          return d[i];
        });

        // Compute outliers. If no whiskers are specified, all data are 'outliers'.
        // We compute the outliers as indices, so that we can join across transitions!
        var outlierIndices = whiskerIndices ? _d2.default.range(0, whiskerIndices[0]).concat(_d2.default.range(whiskerIndices[1] + 1, n)) : _d2.default.range(n);

        // Compute the new x-scale.
        var x1 = _d2.default.scale.linear().domain(domain && domain.call(this, d, i) || [min, max]).range([height, 0]);

        // Retrieve the old x-scale, if this is an update.
        var x0 = this.__chart__ || _d2.default.scale.linear().domain([0, Infinity]).range(x1.range());

        // Stash the new scale.
        this.__chart__ = x1;

        // Note: the box, median, and box tick elements are fixed in number,
        // so we only have to handle enter and update. In contrast, the outliers
        // and other elements are variable, so we need to exit them! Variable
        // elements also fade in and out.

        // Update center line: the vertical line spanning the whiskers.
        var center = g.selectAll("line.center").data(whiskerData ? [whiskerData] : []);

        center.enter().insert("line", "rect").attr("class", "center").attr("x1", width / 2).attr("y1", function (d) {
          return x0(d[0]);
        }).attr("x2", width / 2).attr("y2", function (d) {
          return x0(d[1]);
        }).style("opacity", 1e-6).transition().duration(duration).style("opacity", 1).attr("y1", function (d) {
          return x1(d[0]);
        }).attr("y2", function (d) {
          return x1(d[1]);
        });

        center.transition().duration(duration).style("opacity", 1).attr("y1", function (d) {
          return x1(d[0]);
        }).attr("y2", function (d) {
          return x1(d[1]);
        });

        center.exit().transition().duration(duration).style("opacity", 1e-6).attr("y1", function (d) {
          return x1(d[0]);
        }).attr("y2", function (d) {
          return x1(d[1]);
        }).remove();

        // Update innerquartile box.
        var box = g.selectAll("rect.box").data([quartileData]);

        box.enter().append("rect").attr("class", "box").attr("x", 0).attr("y", function (d) {
          return x0(d[2]);
        }).attr("width", width).attr("height", function (d) {
          return x0(d[0]) - x0(d[2]);
        }).transition().duration(duration).attr("y", function (d) {
          return x1(d[2]);
        }).attr("height", function (d) {
          return x1(d[0]) - x1(d[2]);
        });

        box.transition().duration(duration).attr("y", function (d) {
          return x1(d[2]);
        }).attr("height", function (d) {
          return x1(d[0]) - x1(d[2]);
        });

        // Update median line.
        var medianLine = g.selectAll("line.median").data([quartileData[1]]);

        medianLine.enter().append("line").attr("class", "median").attr("x1", 0).attr("y1", x0).attr("x2", width).attr("y2", x0).transition().duration(duration).attr("y1", x1).attr("y2", x1);

        medianLine.transition().duration(duration).attr("y1", x1).attr("y2", x1);

        // Update whiskers.
        var whisker = g.selectAll("line.whisker").data(whiskerData || []);

        whisker.enter().insert("line", "circle, text").attr("class", "whisker").attr("x1", 0).attr("y1", x0).attr("x2", width).attr("y2", x0).style("opacity", 1e-6).transition().duration(duration).attr("y1", x1).attr("y2", x1).style("opacity", 1);

        whisker.transition().duration(duration).attr("y1", x1).attr("y2", x1).style("opacity", 1);

        whisker.exit().transition().duration(duration).attr("y1", x1).attr("y2", x1).style("opacity", 1e-6).remove();

        // Update outliers.
        var outlier = g.selectAll("circle.outlier").data(outlierIndices, Number);

        outlier.enter().insert("circle", "text").attr("class", "outlier").attr("r", 5).attr("cx", width / 2).attr("cy", function (i) {
          return x0(d[i]);
        }).style("opacity", 1e-6).transition().duration(duration).attr("cy", function (i) {
          return x1(d[i]);
        }).style("opacity", 1);

        outlier.transition().duration(duration).attr("cy", function (i) {
          return x1(d[i]);
        }).style("opacity", 1);

        outlier.exit().transition().duration(duration).attr("cy", function (i) {
          return x1(d[i]);
        }).style("opacity", 1e-6).remove();

        // Compute the tick format.
        var format = tickFormat || x1.tickFormat(8);

        // Update box ticks.
        var boxTick = g.selectAll("text.box").data(quartileData);

        boxTick.enter().append("text").attr("class", "box").attr("dy", ".3em").attr("dx", function (d, i) {
          return i & 1 ? 6 : -6;
        }).attr("x", function (d, i) {
          return i & 1 ? width : 0;
        }).attr("y", x0).attr("text-anchor", function (d, i) {
          return i & 1 ? "start" : "end";
        }).text(format).transition().duration(duration).attr("y", x1);

        boxTick.transition().duration(duration).text(format).attr("y", x1);

        // Update whisker ticks. These are handled separately from the box
        // ticks because they may or may not exist, and we want don't want
        // to join box ticks pre-transition with whisker ticks post-.
        var whiskerTick = g.selectAll("text.whisker").data(whiskerData || []);

        whiskerTick.enter().append("text").attr("class", "whisker").attr("dy", ".3em").attr("dx", 6).attr("x", width).attr("y", x0).text(format).style("opacity", 1e-6).transition().duration(duration).attr("y", x1).style("opacity", 1);

        whiskerTick.transition().duration(duration).text(format).attr("y", x1).style("opacity", 1);

        whiskerTick.exit().transition().duration(duration).attr("y", x1).style("opacity", 1e-6).remove();
      });
      _d2.default.timer.flush();
    }

    box.width = function (x) {
      if (!arguments.length) {
        return width;
      }
      width = x;
      return box;
    };

    box.height = function (x) {
      if (!arguments.length) {
        return height;
      }
      height = x;
      return box;
    };

    box.tickFormat = function (x) {
      if (!arguments.length) {
        return tickFormat;
      }
      tickFormat = x;
      return box;
    };

    box.duration = function (x) {
      if (!arguments.length) {
        return duration;
      }
      duration = x;
      return box;
    };

    box.domain = function (x) {
      if (!arguments.length) {
        return domain;
      }
      domain = x === null ? x : _d2.default.functor(x);
      return box;
    };

    box.value = function (x) {
      if (!arguments.length) {
        return value;
      }
      value = x;
      return box;
    };

    box.whiskers = function (x) {
      if (!arguments.length) {
        return whiskers;
      }
      whiskers = x;
      return box;
    };

    box.quartiles = function (x) {
      if (!arguments.length) {
        return quartiles;
      }
      quartiles = x;
      return box;
    };

    return box;
  };

  function boxWhiskers(d) {
    return [0, d.length - 1];
  }

  function boxQuartiles(d) {
    return [_d2.default.quantile(d, 0.25), _d2.default.quantile(d, 0.5), _d2.default.quantile(d, 0.75)];
  }
})();

/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

/* Mapbox GL JS is licensed under the 3-Clause BSD License. Full text of license: https://github.com/mapbox/mapbox-gl-js/blob/v1.9.1/LICENSE.txt */
(function (global, factory) {
 true ? module.exports = factory() :
typeof define === 'function' && define.amd ? define(factory) :
(global = global || self, global.mapboxgl = factory());
}(this, (function () { 'use strict';

/* eslint-disable */

var shared, worker, mapboxgl;
// define gets called three times: one for each chunk. we rely on the order
// they're imported to know which is which
function define(_, chunk) {
if (!shared) {
    shared = chunk;
} else if (!worker) {
    worker = chunk;
} else {
    var workerBundleString = 'var sharedChunk = {}; (' + shared + ')(sharedChunk); (' + worker + ')(sharedChunk);'

    var sharedChunk = {};
    shared(sharedChunk);
    mapboxgl = chunk(sharedChunk);
    mapboxgl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: 'text/javascript' }));
}
}


define(["exports"],(function(t){"use strict";function e(t,e){return t(e={exports:{}},e.exports),e.exports}var r=n;function n(t,e,r,n){this.cx=3*t,this.bx=3*(r-t)-this.cx,this.ax=1-this.cx-this.bx,this.cy=3*e,this.by=3*(n-e)-this.cy,this.ay=1-this.cy-this.by,this.p1x=t,this.p1y=n,this.p2x=r,this.p2y=n;}n.prototype.sampleCurveX=function(t){return ((this.ax*t+this.bx)*t+this.cx)*t},n.prototype.sampleCurveY=function(t){return ((this.ay*t+this.by)*t+this.cy)*t},n.prototype.sampleCurveDerivativeX=function(t){return (3*this.ax*t+2*this.bx)*t+this.cx},n.prototype.solveCurveX=function(t,e){var r,n,i,a,o;for(void 0===e&&(e=1e-6),i=t,o=0;o<8;o++){if(a=this.sampleCurveX(i)-t,Math.abs(a)<e)return i;var s=this.sampleCurveDerivativeX(i);if(Math.abs(s)<1e-6)break;i-=a/s;}if((i=t)<(r=0))return r;if(i>(n=1))return n;for(;r<n;){if(a=this.sampleCurveX(i),Math.abs(a-t)<e)return i;t>a?r=i:n=i,i=.5*(n-r)+r;}return i},n.prototype.solve=function(t,e){return this.sampleCurveY(this.solveCurveX(t,e))};var i=a;function a(t,e){this.x=t,this.y=e;}function o(t,e,n,i){var a=new r(t,e,n,i);return function(t){return a.solve(t)}}a.prototype={clone:function(){return new a(this.x,this.y)},add:function(t){return this.clone()._add(t)},sub:function(t){return this.clone()._sub(t)},multByPoint:function(t){return this.clone()._multByPoint(t)},divByPoint:function(t){return this.clone()._divByPoint(t)},mult:function(t){return this.clone()._mult(t)},div:function(t){return this.clone()._div(t)},rotate:function(t){return this.clone()._rotate(t)},rotateAround:function(t,e){return this.clone()._rotateAround(t,e)},matMult:function(t){return this.clone()._matMult(t)},unit:function(){return this.clone()._unit()},perp:function(){return this.clone()._perp()},round:function(){return this.clone()._round()},mag:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},equals:function(t){return this.x===t.x&&this.y===t.y},dist:function(t){return Math.sqrt(this.distSqr(t))},distSqr:function(t){var e=t.x-this.x,r=t.y-this.y;return e*e+r*r},angle:function(){return Math.atan2(this.y,this.x)},angleTo:function(t){return Math.atan2(this.y-t.y,this.x-t.x)},angleWith:function(t){return this.angleWithSep(t.x,t.y)},angleWithSep:function(t,e){return Math.atan2(this.x*e-this.y*t,this.x*t+this.y*e)},_matMult:function(t){var e=t[2]*this.x+t[3]*this.y;return this.x=t[0]*this.x+t[1]*this.y,this.y=e,this},_add:function(t){return this.x+=t.x,this.y+=t.y,this},_sub:function(t){return this.x-=t.x,this.y-=t.y,this},_mult:function(t){return this.x*=t,this.y*=t,this},_div:function(t){return this.x/=t,this.y/=t,this},_multByPoint:function(t){return this.x*=t.x,this.y*=t.y,this},_divByPoint:function(t){return this.x/=t.x,this.y/=t.y,this},_unit:function(){return this._div(this.mag()),this},_perp:function(){var t=this.y;return this.y=this.x,this.x=-t,this},_rotate:function(t){var e=Math.cos(t),r=Math.sin(t),n=r*this.x+e*this.y;return this.x=e*this.x-r*this.y,this.y=n,this},_rotateAround:function(t,e){var r=Math.cos(t),n=Math.sin(t),i=e.y+n*(this.x-e.x)+r*(this.y-e.y);return this.x=e.x+r*(this.x-e.x)-n*(this.y-e.y),this.y=i,this},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}},a.convert=function(t){return t instanceof a?t:Array.isArray(t)?new a(t[0],t[1]):t};var s=o(.25,.1,.25,1);function u(t,e,r){return Math.min(r,Math.max(e,t))}function l(t,e,r){var n=r-e,i=((t-e)%n+n)%n+e;return i===e?r:i}function p(t){for(var e=[],r=arguments.length-1;r-- >0;)e[r]=arguments[r+1];for(var n=0,i=e;n<i.length;n+=1){var a=i[n];for(var o in a)t[o]=a[o];}return t}var c=1;function h(){return c++}function f(){return function t(e){return e?(e^16*Math.random()>>e/4).toString(16):([1e7]+-[1e3]+-4e3+-8e3+-1e11).replace(/[018]/g,t)}()}function y(t){return !!t&&/^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t)}function d(t,e){t.forEach((function(t){e[t]&&(e[t]=e[t].bind(e));}));}function m(t,e){return -1!==t.indexOf(e,t.length-e.length)}function v(t,e,r){var n={};for(var i in t)n[i]=e.call(r||this,t[i],i,t);return n}function g(t,e,r){var n={};for(var i in t)e.call(r||this,t[i],i,t)&&(n[i]=t[i]);return n}function x(t){return Array.isArray(t)?t.map(x):"object"==typeof t&&t?v(t,x):t}var b={};function w(t){b[t]||("undefined"!=typeof console&&console.warn(t),b[t]=!0);}function _(t,e,r){return (r.y-t.y)*(e.x-t.x)>(e.y-t.y)*(r.x-t.x)}function A(t){for(var e=0,r=0,n=t.length,i=n-1,a=void 0,o=void 0;r<n;i=r++)e+=((o=t[i]).x-(a=t[r]).x)*(a.y+o.y);return e}function S(){return "undefined"!=typeof WorkerGlobalScope&&"undefined"!=typeof self&&self instanceof WorkerGlobalScope}function k(t){var e={};if(t.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g,(function(t,r,n,i){var a=n||i;return e[r]=!a||a.toLowerCase(),""})),e["max-age"]){var r=parseInt(e["max-age"],10);isNaN(r)?delete e["max-age"]:e["max-age"]=r;}return e}var I=null;function z(t){if(null==I){var e=t.navigator?t.navigator.userAgent:null;I=!!t.safari||!(!e||!(/\b(iPad|iPhone|iPod)\b/.test(e)||e.match("Safari")&&!e.match("Chrome")));}return I}function C(t){try{var e=self[t];return e.setItem("_mapbox_test_",1),e.removeItem("_mapbox_test_"),!0}catch(t){return !1}}var M,T,E,P,B=self.performance&&self.performance.now?self.performance.now.bind(self.performance):Date.now.bind(Date),V=self.requestAnimationFrame||self.mozRequestAnimationFrame||self.webkitRequestAnimationFrame||self.msRequestAnimationFrame,F=self.cancelAnimationFrame||self.mozCancelAnimationFrame||self.webkitCancelAnimationFrame||self.msCancelAnimationFrame,D={now:B,frame:function(t){var e=V(t);return {cancel:function(){return F(e)}}},getImageData:function(t,e){void 0===e&&(e=0);var r=self.document.createElement("canvas"),n=r.getContext("2d");if(!n)throw new Error("failed to create canvas 2d context");return r.width=t.width,r.height=t.height,n.drawImage(t,0,0,t.width,t.height),n.getImageData(-e,-e,t.width+2*e,t.height+2*e)},resolveURL:function(t){return M||(M=self.document.createElement("a")),M.href=t,M.href},hardwareConcurrency:self.navigator.hardwareConcurrency||4,get devicePixelRatio(){return self.devicePixelRatio},get prefersReducedMotion(){return !!self.matchMedia&&(null==T&&(T=self.matchMedia("(prefers-reduced-motion: reduce)")),T.matches)}},L={API_URL:"https://api.mapbox.com",get EVENTS_URL(){return this.API_URL?0===this.API_URL.indexOf("https://api.mapbox.cn")?"https://events.mapbox.cn/events/v2":0===this.API_URL.indexOf("https://api.mapbox.com")?"https://events.mapbox.com/events/v2":null:null},FEEDBACK_URL:"https://apps.mapbox.com/feedback",REQUIRE_ACCESS_TOKEN:!0,ACCESS_TOKEN:null,MAX_PARALLEL_IMAGE_REQUESTS:16},R={supported:!1,testSupport:function(t){!O&&P&&(U?j(t):E=t);}},O=!1,U=!1;function j(t){var e=t.createTexture();t.bindTexture(t.TEXTURE_2D,e);try{if(t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,P),t.isContextLost())return;R.supported=!0;}catch(t){}t.deleteTexture(e),O=!0;}self.document&&((P=self.document.createElement("img")).onload=function(){E&&j(E),E=null,U=!0;},P.onerror=function(){O=!0,E=null;},P.src="data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");var q="01",N=function(t,e){this._transformRequestFn=t,this._customAccessToken=e,this._createSkuToken();};function K(t){return 0===t.indexOf("mapbox:")}N.prototype._createSkuToken=function(){var t=function(){for(var t="",e=0;e<10;e++)t+="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62*Math.random())];return {token:["1",q,t].join(""),tokenExpiresAt:Date.now()+432e5}}();this._skuToken=t.token,this._skuTokenExpiresAt=t.tokenExpiresAt;},N.prototype._isSkuTokenExpired=function(){return Date.now()>this._skuTokenExpiresAt},N.prototype.transformRequest=function(t,e){return this._transformRequestFn&&this._transformRequestFn(t,e)||{url:t}},N.prototype.normalizeStyleURL=function(t,e){if(!K(t))return t;var r=J(t);return r.path="/styles/v1"+r.path,this._makeAPIURL(r,this._customAccessToken||e)},N.prototype.normalizeGlyphsURL=function(t,e){if(!K(t))return t;var r=J(t);return r.path="/fonts/v1"+r.path,this._makeAPIURL(r,this._customAccessToken||e)},N.prototype.normalizeSourceURL=function(t,e){if(!K(t))return t;var r=J(t);return r.path="/v4/"+r.authority+".json",r.params.push("secure"),this._makeAPIURL(r,this._customAccessToken||e)},N.prototype.normalizeSpriteURL=function(t,e,r,n){var i=J(t);return K(t)?(i.path="/styles/v1"+i.path+"/sprite"+e+r,this._makeAPIURL(i,this._customAccessToken||n)):(i.path+=""+e+r,H(i))},N.prototype.normalizeTileURL=function(t,e){if(this._isSkuTokenExpired()&&this._createSkuToken(),t&&!K(t))return t;var r=J(t);r.path=r.path.replace(/(\.(png|jpg)\d*)(?=$)/,(D.devicePixelRatio>=2||512===e?"@2x":"")+(R.supported?".webp":"$1")),r.path=r.path.replace(/^.+\/v4\//,"/"),r.path="/v4"+r.path;var n=this._customAccessToken||function(t){for(var e=0,r=t;e<r.length;e+=1){var n=r[e].match(/^access_token=(.*)$/);if(n)return n[1]}return null}(r.params)||L.ACCESS_TOKEN;return L.REQUIRE_ACCESS_TOKEN&&n&&this._skuToken&&r.params.push("sku="+this._skuToken),this._makeAPIURL(r,n)},N.prototype.canonicalizeTileURL=function(t,e){var r=J(t);if(!r.path.match(/(^\/v4\/)/)||!r.path.match(/\.[\w]+$/))return t;var n="mapbox://tiles/";n+=r.path.replace("/v4/","");var i=r.params;return e&&(i=i.filter((function(t){return !t.match(/^access_token=/)}))),i.length&&(n+="?"+i.join("&")),n},N.prototype.canonicalizeTileset=function(t,e){for(var r=!!e&&K(e),n=[],i=0,a=t.tiles||[];i<a.length;i+=1){var o=a[i];G(o)?n.push(this.canonicalizeTileURL(o,r)):n.push(o);}return n},N.prototype._makeAPIURL=function(t,e){var r="See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes",n=J(L.API_URL);if(t.protocol=n.protocol,t.authority=n.authority,"/"!==n.path&&(t.path=""+n.path+t.path),!L.REQUIRE_ACCESS_TOKEN)return H(t);if(!(e=e||L.ACCESS_TOKEN))throw new Error("An API access token is required to use Mapbox GL. "+r);if("s"===e[0])throw new Error("Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). "+r);return t.params=t.params.filter((function(t){return -1===t.indexOf("access_token")})),t.params.push("access_token="+e),H(t)};var X=/^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;function G(t){return X.test(t)}var Z=/^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;function J(t){var e=t.match(Z);if(!e)throw new Error("Unable to parse URL object");return {protocol:e[1],authority:e[2],path:e[3]||"/",params:e[4]?e[4].split("&"):[]}}function H(t){var e=t.params.length?"?"+t.params.join("&"):"";return t.protocol+"://"+t.authority+t.path+e}function Y(t){if(!t)return null;var e=t.split(".");if(!e||3!==e.length)return null;try{return JSON.parse(decodeURIComponent(self.atob(e[1]).split("").map((function(t){return "%"+("00"+t.charCodeAt(0).toString(16)).slice(-2)})).join("")))}catch(t){return null}}var $=function(t){this.type=t,this.anonId=null,this.eventData={},this.queue=[],this.pendingRequest=null;};$.prototype.getStorageKey=function(t){var e,r=Y(L.ACCESS_TOKEN);return e=r&&r.u?self.btoa(encodeURIComponent(r.u).replace(/%([0-9A-F]{2})/g,(function(t,e){return String.fromCharCode(Number("0x"+e))}))):L.ACCESS_TOKEN||"",t?"mapbox.eventData."+t+":"+e:"mapbox.eventData:"+e},$.prototype.fetchEventData=function(){var t=C("localStorage"),e=this.getStorageKey(),r=this.getStorageKey("uuid");if(t)try{var n=self.localStorage.getItem(e);n&&(this.eventData=JSON.parse(n));var i=self.localStorage.getItem(r);i&&(this.anonId=i);}catch(t){w("Unable to read from LocalStorage");}},$.prototype.saveEventData=function(){var t=C("localStorage"),e=this.getStorageKey(),r=this.getStorageKey("uuid");if(t)try{self.localStorage.setItem(r,this.anonId),Object.keys(this.eventData).length>=1&&self.localStorage.setItem(e,JSON.stringify(this.eventData));}catch(t){w("Unable to write to LocalStorage");}},$.prototype.processRequests=function(t){},$.prototype.postEvent=function(t,e,r,n){var i=this;if(L.EVENTS_URL){var a=J(L.EVENTS_URL);a.params.push("access_token="+(n||L.ACCESS_TOKEN||""));var o={event:this.type,created:new Date(t).toISOString(),sdkIdentifier:"mapbox-gl-js",sdkVersion:"1.9.1",skuId:q,userId:this.anonId},s=e?p(o,e):o,u={url:H(a),headers:{"Content-Type":"text/plain"},body:JSON.stringify([s])};this.pendingRequest=wt(u,(function(t){i.pendingRequest=null,r(t),i.saveEventData(),i.processRequests(n);}));}},$.prototype.queueRequest=function(t,e){this.queue.push(t),this.processRequests(e);};var W,Q,tt=function(t){function e(){t.call(this,"map.load"),this.success={},this.skuToken="";}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.postMapLoadEvent=function(t,e,r,n){this.skuToken=r,(L.EVENTS_URL&&n||L.ACCESS_TOKEN&&Array.isArray(t)&&t.some((function(t){return K(t)||G(t)})))&&this.queueRequest({id:e,timestamp:Date.now()},n);},e.prototype.processRequests=function(t){var e=this;if(!this.pendingRequest&&0!==this.queue.length){var r=this.queue.shift(),n=r.id,i=r.timestamp;n&&this.success[n]||(this.anonId||this.fetchEventData(),y(this.anonId)||(this.anonId=f()),this.postEvent(i,{skuToken:this.skuToken},(function(t){t||n&&(e.success[n]=!0);}),t));}},e}($),et=new(function(t){function e(e){t.call(this,"appUserTurnstile"),this._customAccessToken=e;}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.postTurnstileEvent=function(t,e){L.EVENTS_URL&&L.ACCESS_TOKEN&&Array.isArray(t)&&t.some((function(t){return K(t)||G(t)}))&&this.queueRequest(Date.now(),e);},e.prototype.processRequests=function(t){var e=this;if(!this.pendingRequest&&0!==this.queue.length){this.anonId&&this.eventData.lastSuccess&&this.eventData.tokenU||this.fetchEventData();var r=Y(L.ACCESS_TOKEN),n=r?r.u:L.ACCESS_TOKEN,i=n!==this.eventData.tokenU;y(this.anonId)||(this.anonId=f(),i=!0);var a=this.queue.shift();if(this.eventData.lastSuccess){var o=new Date(this.eventData.lastSuccess),s=new Date(a),u=(a-this.eventData.lastSuccess)/864e5;i=i||u>=1||u<-1||o.getDate()!==s.getDate();}else i=!0;if(!i)return this.processRequests();this.postEvent(a,{"enabled.telemetry":!1},(function(t){t||(e.eventData.lastSuccess=a,e.eventData.tokenU=n);}),t);}},e}($)),rt=et.postTurnstileEvent.bind(et),nt=new tt,it=nt.postMapLoadEvent.bind(nt),at="mapbox-tiles",ot=500,st=50,ut=42e4;function lt(){self.caches&&!W&&(W=self.caches.open(at));}function pt(t){var e=t.indexOf("?");return e<0?t:t.slice(0,e)}var ct,ht=1/0;function ft(){return null==ct&&(ct=self.OffscreenCanvas&&new self.OffscreenCanvas(1,1).getContext("2d")&&"function"==typeof self.createImageBitmap),ct}var yt={Unknown:"Unknown",Style:"Style",Source:"Source",Tile:"Tile",Glyphs:"Glyphs",SpriteImage:"SpriteImage",SpriteJSON:"SpriteJSON",Image:"Image"};"function"==typeof Object.freeze&&Object.freeze(yt);var dt=function(t){function e(e,r,n){401===r&&G(n)&&(e+=": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes"),t.call(this,e),this.status=r,this.url=n,this.name=this.constructor.name,this.message=e;}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.toString=function(){return this.name+": "+this.message+" ("+this.status+"): "+this.url},e}(Error),mt=S()?function(){return self.worker&&self.worker.referrer}:function(){return ("blob:"===self.location.protocol?self.parent:self).location.href};var vt,gt,xt=function(t,e){if(!(/^file:/.test(r=t.url)||/^file:/.test(mt())&&!/^\w+:/.test(r))){if(self.fetch&&self.Request&&self.AbortController&&self.Request.prototype.hasOwnProperty("signal"))return function(t,e){var r,n=new self.AbortController,i=new self.Request(t.url,{method:t.method||"GET",body:t.body,credentials:t.credentials,headers:t.headers,referrer:mt(),signal:n.signal}),a=!1,o=!1,s=(r=i.url).indexOf("sku=")>0&&G(r);"json"===t.type&&i.headers.set("Accept","application/json");var u=function(r,n,a){if(!o){if(r&&"SecurityError"!==r.message&&w(r),n&&a)return l(n);var u=Date.now();self.fetch(i).then((function(r){if(r.ok){var n=s?r.clone():null;return l(r,n,u)}return e(new dt(r.statusText,r.status,t.url))})).catch((function(t){20!==t.code&&e(new Error(t.message));}));}},l=function(r,n,s){("arrayBuffer"===t.type?r.arrayBuffer():"json"===t.type?r.json():r.text()).then((function(t){o||(n&&s&&function(t,e,r){if(lt(),W){var n={status:e.status,statusText:e.statusText,headers:new self.Headers};e.headers.forEach((function(t,e){return n.headers.set(e,t)}));var i=k(e.headers.get("Cache-Control")||"");i["no-store"]||(i["max-age"]&&n.headers.set("Expires",new Date(r+1e3*i["max-age"]).toUTCString()),new Date(n.headers.get("Expires")).getTime()-r<ut||function(t,e){if(void 0===Q)try{new Response(new ReadableStream),Q=!0;}catch(t){Q=!1;}Q?e(t.body):t.blob().then(e);}(e,(function(e){var r=new self.Response(e,n);lt(),W&&W.then((function(e){return e.put(pt(t.url),r)})).catch((function(t){return w(t.message)}));})));}}(i,n,s),a=!0,e(null,t,r.headers.get("Cache-Control"),r.headers.get("Expires")));})).catch((function(t){o||e(new Error(t.message));}));};return s?function(t,e){if(lt(),!W)return e(null);var r=pt(t.url);W.then((function(t){t.match(r).then((function(n){var i=function(t){if(!t)return !1;var e=new Date(t.headers.get("Expires")||0),r=k(t.headers.get("Cache-Control")||"");return e>Date.now()&&!r["no-cache"]}(n);t.delete(r),i&&t.put(r,n.clone()),e(null,n,i);})).catch(e);})).catch(e);}(i,u):u(null,null),{cancel:function(){o=!0,a||n.abort();}}}(t,e);if(S()&&self.worker&&self.worker.actor)return self.worker.actor.send("getResource",t,e,void 0,!0)}var r;return function(t,e){var r=new self.XMLHttpRequest;for(var n in r.open(t.method||"GET",t.url,!0),"arrayBuffer"===t.type&&(r.responseType="arraybuffer"),t.headers)r.setRequestHeader(n,t.headers[n]);return "json"===t.type&&(r.responseType="text",r.setRequestHeader("Accept","application/json")),r.withCredentials="include"===t.credentials,r.onerror=function(){e(new Error(r.statusText));},r.onload=function(){if((r.status>=200&&r.status<300||0===r.status)&&null!==r.response){var n=r.response;if("json"===t.type)try{n=JSON.parse(r.response);}catch(t){return e(t)}e(null,n,r.getResponseHeader("Cache-Control"),r.getResponseHeader("Expires"));}else e(new dt(r.statusText,r.status,t.url));},r.send(t.body),{cancel:function(){return r.abort()}}}(t,e)},bt=function(t,e){return xt(p(t,{type:"arrayBuffer"}),e)},wt=function(t,e){return xt(p(t,{method:"POST"}),e)};vt=[],gt=0;var _t=function(t,e){if(R.supported&&(t.headers||(t.headers={}),t.headers.accept="image/webp,*/*"),gt>=L.MAX_PARALLEL_IMAGE_REQUESTS){var r={requestParameters:t,callback:e,cancelled:!1,cancel:function(){this.cancelled=!0;}};return vt.push(r),r}gt++;var n=!1,i=function(){if(!n)for(n=!0,gt--;vt.length&&gt<L.MAX_PARALLEL_IMAGE_REQUESTS;){var t=vt.shift();t.cancelled||(t.cancel=_t(t.requestParameters,t.callback).cancel);}},a=bt(t,(function(t,r,n,a){i(),t?e(t):r&&(ft()?function(t,e){var r=new self.Blob([new Uint8Array(t)],{type:"image/png"});self.createImageBitmap(r).then((function(t){e(null,t);})).catch((function(t){e(new Error("Could not load image because of "+t.message+". Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));}));}(r,e):function(t,e,r,n){var i=new self.Image,a=self.URL;i.onload=function(){e(null,i),a.revokeObjectURL(i.src);},i.onerror=function(){return e(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."))};var o=new self.Blob([new Uint8Array(t)],{type:"image/png"});i.cacheControl=r,i.expires=n,i.src=t.byteLength?a.createObjectURL(o):"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";}(r,e,n,a));}));return {cancel:function(){a.cancel(),i();}}};function At(t,e,r){r[t]&&-1!==r[t].indexOf(e)||(r[t]=r[t]||[],r[t].push(e));}function St(t,e,r){if(r&&r[t]){var n=r[t].indexOf(e);-1!==n&&r[t].splice(n,1);}}var kt=function(t,e){void 0===e&&(e={}),p(this,e),this.type=t;},It=function(t){function e(e,r){void 0===r&&(r={}),t.call(this,"error",p({error:e},r));}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e}(kt),zt=function(){};zt.prototype.on=function(t,e){return this._listeners=this._listeners||{},At(t,e,this._listeners),this},zt.prototype.off=function(t,e){return St(t,e,this._listeners),St(t,e,this._oneTimeListeners),this},zt.prototype.once=function(t,e){return this._oneTimeListeners=this._oneTimeListeners||{},At(t,e,this._oneTimeListeners),this},zt.prototype.fire=function(t,e){"string"==typeof t&&(t=new kt(t,e||{}));var r=t.type;if(this.listens(r)){t.target=this;for(var n=0,i=this._listeners&&this._listeners[r]?this._listeners[r].slice():[];n<i.length;n+=1)i[n].call(this,t);for(var a=0,o=this._oneTimeListeners&&this._oneTimeListeners[r]?this._oneTimeListeners[r].slice():[];a<o.length;a+=1){var s=o[a];St(r,s,this._oneTimeListeners),s.call(this,t);}var u=this._eventedParent;u&&(p(t,"function"==typeof this._eventedParentData?this._eventedParentData():this._eventedParentData),u.fire(t));}else t instanceof It&&console.error(t.error);return this},zt.prototype.listens=function(t){return this._listeners&&this._listeners[t]&&this._listeners[t].length>0||this._oneTimeListeners&&this._oneTimeListeners[t]&&this._oneTimeListeners[t].length>0||this._eventedParent&&this._eventedParent.listens(t)},zt.prototype.setEventedParent=function(t,e){return this._eventedParent=t,this._eventedParentData=e,this};var Ct={$version:8,$root:{version:{required:!0,type:"enum",values:[8]},name:{type:"string"},metadata:{type:"*"},center:{type:"array",value:"number"},zoom:{type:"number"},bearing:{type:"number",default:0,period:360,units:"degrees"},pitch:{type:"number",default:0,units:"degrees"},light:{type:"light"},sources:{required:!0,type:"sources"},sprite:{type:"string"},glyphs:{type:"string"},transition:{type:"transition"},layers:{required:!0,type:"array",value:"layer"}},sources:{"*":{type:"source"}},source:["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],source_vector:{type:{required:!0,type:"enum",values:{vector:{}}},url:{type:"string"},tiles:{type:"array",value:"string"},bounds:{type:"array",value:"number",length:4,default:[-180,-85.051129,180,85.051129]},scheme:{type:"enum",values:{xyz:{},tms:{}},default:"xyz"},minzoom:{type:"number",default:0},maxzoom:{type:"number",default:22},attribution:{type:"string"},promoteId:{type:"promoteId"},"*":{type:"*"}},source_raster:{type:{required:!0,type:"enum",values:{raster:{}}},url:{type:"string"},tiles:{type:"array",value:"string"},bounds:{type:"array",value:"number",length:4,default:[-180,-85.051129,180,85.051129]},minzoom:{type:"number",default:0},maxzoom:{type:"number",default:22},tileSize:{type:"number",default:512,units:"pixels"},scheme:{type:"enum",values:{xyz:{},tms:{}},default:"xyz"},attribution:{type:"string"},"*":{type:"*"}},source_raster_dem:{type:{required:!0,type:"enum",values:{"raster-dem":{}}},url:{type:"string"},tiles:{type:"array",value:"string"},bounds:{type:"array",value:"number",length:4,default:[-180,-85.051129,180,85.051129]},minzoom:{type:"number",default:0},maxzoom:{type:"number",default:22},tileSize:{type:"number",default:512,units:"pixels"},attribution:{type:"string"},encoding:{type:"enum",values:{terrarium:{},mapbox:{}},default:"mapbox"},"*":{type:"*"}},source_geojson:{type:{required:!0,type:"enum",values:{geojson:{}}},data:{type:"*"},maxzoom:{type:"number",default:18},attribution:{type:"string"},buffer:{type:"number",default:128,maximum:512,minimum:0},tolerance:{type:"number",default:.375},cluster:{type:"boolean",default:!1},clusterRadius:{type:"number",default:50,minimum:0},clusterMaxZoom:{type:"number"},clusterProperties:{type:"*"},lineMetrics:{type:"boolean",default:!1},generateId:{type:"boolean",default:!1},promoteId:{type:"promoteId"}},source_video:{type:{required:!0,type:"enum",values:{video:{}}},urls:{required:!0,type:"array",value:"string"},coordinates:{required:!0,type:"array",length:4,value:{type:"array",length:2,value:"number"}}},source_image:{type:{required:!0,type:"enum",values:{image:{}}},url:{required:!0,type:"string"},coordinates:{required:!0,type:"array",length:4,value:{type:"array",length:2,value:"number"}}},layer:{id:{type:"string",required:!0},type:{type:"enum",values:{fill:{},line:{},symbol:{},circle:{},heatmap:{},"fill-extrusion":{},raster:{},hillshade:{},background:{}},required:!0},metadata:{type:"*"},source:{type:"string"},"source-layer":{type:"string"},minzoom:{type:"number",minimum:0,maximum:24},maxzoom:{type:"number",minimum:0,maximum:24},filter:{type:"filter"},layout:{type:"layout"},paint:{type:"paint"}},layout:["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background"],layout_background:{visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_fill:{"fill-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_circle:{"circle-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_heatmap:{visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},"layout_fill-extrusion":{visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_line:{"line-cap":{type:"enum",values:{butt:{},round:{},square:{}},default:"butt",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"line-join":{type:"enum",values:{bevel:{},round:{},miter:{}},default:"miter",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{type:"number",default:2,requires:[{"line-join":"miter"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"line-round-limit":{type:"number",default:1.05,requires:[{"line-join":"round"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"line-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_symbol:{"symbol-placement":{type:"enum",values:{point:{},line:{},"line-center":{}},default:"point",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"symbol-spacing":{type:"number",default:250,minimum:1,units:"pixels",requires:[{"symbol-placement":"line"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{type:"boolean",default:!1,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{type:"enum",values:{auto:{},"viewport-y":{},source:{}},default:"auto",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{type:"boolean",default:!1,requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{type:"boolean",default:!1,requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-optional":{type:"boolean",default:!1,requires:["icon-image","text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-size":{type:"number",default:1,minimum:0,units:"factor of the original icon size",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{type:"enum",values:{none:{},width:{},height:{},both:{}},default:"none",requires:["icon-image","text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{type:"array",value:"number",length:4,default:[0,0,0,0],units:"pixels",requires:["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"icon-image":{type:"resolvedImage",tokens:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{type:"number",default:0,period:360,units:"degrees",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{type:"number",default:2,minimum:0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{type:"boolean",default:!1,requires:["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-offset":{type:"array",value:"number",length:2,default:[0,0],requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{type:"enum",values:{center:{},left:{},right:{},top:{},bottom:{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},default:"center",requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-field":{type:"formatted",default:"",tokens:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-font":{type:"array",value:"string",default:["Open Sans Regular","Arial Unicode MS Regular"],requires:["text-field"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-size":{type:"number",default:16,minimum:0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{type:"number",default:10,minimum:0,units:"ems",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{type:"number",default:1.2,units:"ems",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-letter-spacing":{type:"number",default:0,units:"ems",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-justify":{type:"enum",values:{auto:{},left:{},center:{},right:{}},default:"center",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{type:"number",units:"ems",default:0,requires:["text-field"],"property-type":"data-driven",expression:{interpolated:!0,parameters:["zoom","feature"]}},"text-variable-anchor":{type:"array",value:"enum",values:{center:{},left:{},right:{},top:{},bottom:{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},requires:["text-field",{"symbol-placement":["point"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-anchor":{type:"enum",values:{center:{},left:{},right:{},top:{},bottom:{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},default:"center",requires:["text-field",{"!":"text-variable-anchor"}],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{type:"number",default:45,units:"degrees",requires:["text-field",{"symbol-placement":["line","line-center"]}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-writing-mode":{type:"array",value:"enum",values:{horizontal:{},vertical:{}},requires:["text-field",{"symbol-placement":["point"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-rotate":{type:"number",default:0,period:360,units:"degrees",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-padding":{type:"number",default:2,minimum:0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-keep-upright":{type:"boolean",default:!0,requires:["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-transform":{type:"enum",values:{none:{},uppercase:{},lowercase:{}},default:"none",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-offset":{type:"array",value:"number",units:"ems",length:2,default:[0,0],requires:["text-field",{"!":"text-radial-offset"}],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{type:"boolean",default:!1,requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{type:"boolean",default:!1,requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-optional":{type:"boolean",default:!1,requires:["text-field","icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_raster:{visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_hillshade:{visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},filter:{type:"array",value:"*"},filter_operator:{type:"enum",values:{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},in:{},"!in":{},all:{},any:{},none:{},has:{},"!has":{}}},geometry_type:{type:"enum",values:{Point:{},LineString:{},Polygon:{}}},function:{expression:{type:"expression"},stops:{type:"array",value:"function_stop"},base:{type:"number",default:1,minimum:0},property:{type:"string",default:"$zoom"},type:{type:"enum",values:{identity:{},exponential:{},interval:{},categorical:{}},default:"exponential"},colorSpace:{type:"enum",values:{rgb:{},lab:{},hcl:{}},default:"rgb"},default:{type:"*",required:!1}},function_stop:{type:"array",minimum:0,maximum:24,value:["number","color"],length:2},expression:{type:"array",value:"*",minimum:1},expression_name:{type:"enum",values:{let:{group:"Variable binding"},var:{group:"Variable binding"},literal:{group:"Types"},array:{group:"Types"},at:{group:"Lookup"},in:{group:"Lookup"},case:{group:"Decision"},match:{group:"Decision"},coalesce:{group:"Decision"},step:{group:"Ramps, scales, curves"},interpolate:{group:"Ramps, scales, curves"},"interpolate-hcl":{group:"Ramps, scales, curves"},"interpolate-lab":{group:"Ramps, scales, curves"},ln2:{group:"Math"},pi:{group:"Math"},e:{group:"Math"},typeof:{group:"Types"},string:{group:"Types"},number:{group:"Types"},boolean:{group:"Types"},object:{group:"Types"},collator:{group:"Types"},format:{group:"Types"},image:{group:"Types"},"number-format":{group:"Types"},"to-string":{group:"Types"},"to-number":{group:"Types"},"to-boolean":{group:"Types"},"to-rgba":{group:"Color"},"to-color":{group:"Types"},rgb:{group:"Color"},rgba:{group:"Color"},get:{group:"Lookup"},has:{group:"Lookup"},length:{group:"Lookup"},properties:{group:"Feature data"},"feature-state":{group:"Feature data"},"geometry-type":{group:"Feature data"},id:{group:"Feature data"},zoom:{group:"Zoom"},"heatmap-density":{group:"Heatmap"},"line-progress":{group:"Feature data"},accumulated:{group:"Feature data"},"+":{group:"Math"},"*":{group:"Math"},"-":{group:"Math"},"/":{group:"Math"},"%":{group:"Math"},"^":{group:"Math"},sqrt:{group:"Math"},log10:{group:"Math"},ln:{group:"Math"},log2:{group:"Math"},sin:{group:"Math"},cos:{group:"Math"},tan:{group:"Math"},asin:{group:"Math"},acos:{group:"Math"},atan:{group:"Math"},min:{group:"Math"},max:{group:"Math"},round:{group:"Math"},abs:{group:"Math"},ceil:{group:"Math"},floor:{group:"Math"},"==":{group:"Decision"},"!=":{group:"Decision"},">":{group:"Decision"},"<":{group:"Decision"},">=":{group:"Decision"},"<=":{group:"Decision"},all:{group:"Decision"},any:{group:"Decision"},"!":{group:"Decision"},within:{group:"Decision"},"is-supported-script":{group:"String"},upcase:{group:"String"},downcase:{group:"String"},concat:{group:"String"},"resolved-locale":{group:"String"}}},light:{anchor:{type:"enum",default:"viewport",values:{map:{},viewport:{}},"property-type":"data-constant",transition:!1,expression:{interpolated:!1,parameters:["zoom"]}},position:{type:"array",default:[1.15,210,30],length:3,value:"number","property-type":"data-constant",transition:!0,expression:{interpolated:!0,parameters:["zoom"]}},color:{type:"color","property-type":"data-constant",default:"#ffffff",expression:{interpolated:!0,parameters:["zoom"]},transition:!0},intensity:{type:"number","property-type":"data-constant",default:.5,minimum:0,maximum:1,expression:{interpolated:!0,parameters:["zoom"]},transition:!0}},paint:["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background"],paint_fill:{"fill-antialias":{type:"boolean",default:!0,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"fill-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"fill-pattern"}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{type:"color",transition:!0,requires:[{"!":"fill-pattern"},{"fill-antialias":!0}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["fill-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"fill-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"cross-faded-data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"fill-extrusion-pattern"}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["fill-extrusion-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"cross-faded-data-driven"},"fill-extrusion-height":{type:"number",default:0,minimum:0,units:"meters",transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{type:"number",default:0,minimum:0,units:"meters",transition:!0,requires:["fill-extrusion-height"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{type:"boolean",default:!0,transition:!1,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"}},paint_line:{"line-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"line-pattern"}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["line-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"line-width":{type:"number",default:1,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{type:"number",default:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{type:"array",value:"number",minimum:0,transition:!0,units:"line widths",requires:[{"!":"line-pattern"}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"cross-faded"},"line-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"cross-faded-data-driven"},"line-gradient":{type:"color",transition:!1,requires:[{"!":"line-dasharray"},{"!":"line-pattern"},{source:"geojson",has:{lineMetrics:!0}}],expression:{interpolated:!0,parameters:["line-progress"]},"property-type":"color-ramp"}},paint_circle:{"circle-radius":{type:"number",default:5,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{type:"number",default:0,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["circle-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{type:"enum",values:{map:{},viewport:{}},default:"map",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{type:"enum",values:{map:{},viewport:{}},default:"viewport",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"}},paint_heatmap:{"heatmap-radius":{type:"number",default:30,minimum:1,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{type:"number",default:1,minimum:0,transition:!1,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{type:"number",default:1,minimum:0,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"heatmap-color":{type:"color",default:["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",.1,"royalblue",.3,"cyan",.5,"lime",.7,"yellow",1,"red"],transition:!1,expression:{interpolated:!0,parameters:["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},paint_symbol:{"icon-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{type:"color",default:"#000000",transition:!0,requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{type:"color",default:"rgba(0, 0, 0, 0)",transition:!0,requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["icon-image","icon-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{type:"color",default:"#000000",transition:!0,overridable:!0,requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{type:"color",default:"rgba(0, 0, 0, 0)",transition:!0,requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["text-field","text-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"}},paint_raster:{"raster-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{type:"number",default:0,period:360,transition:!0,units:"degrees",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{type:"number",default:0,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-saturation":{type:"number",default:0,minimum:-1,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-contrast":{type:"number",default:0,minimum:-1,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-resampling":{type:"enum",values:{linear:{},nearest:{}},default:"linear",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{type:"number",default:300,minimum:0,transition:!1,units:"milliseconds",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},paint_hillshade:{"hillshade-illumination-direction":{type:"number",default:335,minimum:0,maximum:359,transition:!1,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{type:"enum",values:{map:{},viewport:{}},default:"viewport",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{type:"number",default:.5,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{type:"color",default:"#FFFFFF",transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},paint_background:{"background-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"background-pattern"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"background-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"cross-faded"},"background-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},transition:{duration:{type:"number",default:300,minimum:0,units:"milliseconds"},delay:{type:"number",default:0,minimum:0,units:"milliseconds"}},"property-type":{"data-driven":{type:"property-type"},"cross-faded":{type:"property-type"},"cross-faded-data-driven":{type:"property-type"},"color-ramp":{type:"property-type"},"data-constant":{type:"property-type"},constant:{type:"property-type"}},promoteId:{"*":{type:"string"}}},Mt=function(t,e,r,n){this.message=(t?t+": ":"")+r,n&&(this.identifier=n),null!=e&&e.__line__&&(this.line=e.__line__);};function Tt(t){var e=t.value;return e?[new Mt(t.key,e,"constants have been deprecated as of v8")]:[]}function Et(t){for(var e=[],r=arguments.length-1;r-- >0;)e[r]=arguments[r+1];for(var n=0,i=e;n<i.length;n+=1){var a=i[n];for(var o in a)t[o]=a[o];}return t}function Pt(t){return t instanceof Number||t instanceof String||t instanceof Boolean?t.valueOf():t}function Bt(t){if(Array.isArray(t))return t.map(Bt);if(t instanceof Object&&!(t instanceof Number||t instanceof String||t instanceof Boolean)){var e={};for(var r in t)e[r]=Bt(t[r]);return e}return Pt(t)}var Vt=function(t){function e(e,r){t.call(this,r),this.message=r,this.key=e;}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e}(Error),Ft=function(t,e){void 0===e&&(e=[]),this.parent=t,this.bindings={};for(var r=0,n=e;r<n.length;r+=1){var i=n[r];this.bindings[i[0]]=i[1];}};Ft.prototype.concat=function(t){return new Ft(this,t)},Ft.prototype.get=function(t){if(this.bindings[t])return this.bindings[t];if(this.parent)return this.parent.get(t);throw new Error(t+" not found in scope.")},Ft.prototype.has=function(t){return !!this.bindings[t]||!!this.parent&&this.parent.has(t)};var Dt={kind:"null"},Lt={kind:"number"},Rt={kind:"string"},Ot={kind:"boolean"},Ut={kind:"color"},jt={kind:"object"},qt={kind:"value"},Nt={kind:"collator"},Kt={kind:"formatted"},Xt={kind:"resolvedImage"};function Gt(t,e){return {kind:"array",itemType:t,N:e}}function Zt(t){if("array"===t.kind){var e=Zt(t.itemType);return "number"==typeof t.N?"array<"+e+", "+t.N+">":"value"===t.itemType.kind?"array":"array<"+e+">"}return t.kind}var Jt=[Dt,Lt,Rt,Ot,Ut,Kt,jt,Gt(qt),Xt];function Ht(t,e){if("error"===e.kind)return null;if("array"===t.kind){if("array"===e.kind&&(0===e.N&&"value"===e.itemType.kind||!Ht(t.itemType,e.itemType))&&("number"!=typeof t.N||t.N===e.N))return null}else{if(t.kind===e.kind)return null;if("value"===t.kind)for(var r=0,n=Jt;r<n.length;r+=1)if(!Ht(n[r],e))return null}return "Expected "+Zt(t)+" but found "+Zt(e)+" instead."}var Yt=e((function(t,e){var r={transparent:[0,0,0,0],aliceblue:[240,248,255,1],antiquewhite:[250,235,215,1],aqua:[0,255,255,1],aquamarine:[127,255,212,1],azure:[240,255,255,1],beige:[245,245,220,1],bisque:[255,228,196,1],black:[0,0,0,1],blanchedalmond:[255,235,205,1],blue:[0,0,255,1],blueviolet:[138,43,226,1],brown:[165,42,42,1],burlywood:[222,184,135,1],cadetblue:[95,158,160,1],chartreuse:[127,255,0,1],chocolate:[210,105,30,1],coral:[255,127,80,1],cornflowerblue:[100,149,237,1],cornsilk:[255,248,220,1],crimson:[220,20,60,1],cyan:[0,255,255,1],darkblue:[0,0,139,1],darkcyan:[0,139,139,1],darkgoldenrod:[184,134,11,1],darkgray:[169,169,169,1],darkgreen:[0,100,0,1],darkgrey:[169,169,169,1],darkkhaki:[189,183,107,1],darkmagenta:[139,0,139,1],darkolivegreen:[85,107,47,1],darkorange:[255,140,0,1],darkorchid:[153,50,204,1],darkred:[139,0,0,1],darksalmon:[233,150,122,1],darkseagreen:[143,188,143,1],darkslateblue:[72,61,139,1],darkslategray:[47,79,79,1],darkslategrey:[47,79,79,1],darkturquoise:[0,206,209,1],darkviolet:[148,0,211,1],deeppink:[255,20,147,1],deepskyblue:[0,191,255,1],dimgray:[105,105,105,1],dimgrey:[105,105,105,1],dodgerblue:[30,144,255,1],firebrick:[178,34,34,1],floralwhite:[255,250,240,1],forestgreen:[34,139,34,1],fuchsia:[255,0,255,1],gainsboro:[220,220,220,1],ghostwhite:[248,248,255,1],gold:[255,215,0,1],goldenrod:[218,165,32,1],gray:[128,128,128,1],green:[0,128,0,1],greenyellow:[173,255,47,1],grey:[128,128,128,1],honeydew:[240,255,240,1],hotpink:[255,105,180,1],indianred:[205,92,92,1],indigo:[75,0,130,1],ivory:[255,255,240,1],khaki:[240,230,140,1],lavender:[230,230,250,1],lavenderblush:[255,240,245,1],lawngreen:[124,252,0,1],lemonchiffon:[255,250,205,1],lightblue:[173,216,230,1],lightcoral:[240,128,128,1],lightcyan:[224,255,255,1],lightgoldenrodyellow:[250,250,210,1],lightgray:[211,211,211,1],lightgreen:[144,238,144,1],lightgrey:[211,211,211,1],lightpink:[255,182,193,1],lightsalmon:[255,160,122,1],lightseagreen:[32,178,170,1],lightskyblue:[135,206,250,1],lightslategray:[119,136,153,1],lightslategrey:[119,136,153,1],lightsteelblue:[176,196,222,1],lightyellow:[255,255,224,1],lime:[0,255,0,1],limegreen:[50,205,50,1],linen:[250,240,230,1],magenta:[255,0,255,1],maroon:[128,0,0,1],mediumaquamarine:[102,205,170,1],mediumblue:[0,0,205,1],mediumorchid:[186,85,211,1],mediumpurple:[147,112,219,1],mediumseagreen:[60,179,113,1],mediumslateblue:[123,104,238,1],mediumspringgreen:[0,250,154,1],mediumturquoise:[72,209,204,1],mediumvioletred:[199,21,133,1],midnightblue:[25,25,112,1],mintcream:[245,255,250,1],mistyrose:[255,228,225,1],moccasin:[255,228,181,1],navajowhite:[255,222,173,1],navy:[0,0,128,1],oldlace:[253,245,230,1],olive:[128,128,0,1],olivedrab:[107,142,35,1],orange:[255,165,0,1],orangered:[255,69,0,1],orchid:[218,112,214,1],palegoldenrod:[238,232,170,1],palegreen:[152,251,152,1],paleturquoise:[175,238,238,1],palevioletred:[219,112,147,1],papayawhip:[255,239,213,1],peachpuff:[255,218,185,1],peru:[205,133,63,1],pink:[255,192,203,1],plum:[221,160,221,1],powderblue:[176,224,230,1],purple:[128,0,128,1],rebeccapurple:[102,51,153,1],red:[255,0,0,1],rosybrown:[188,143,143,1],royalblue:[65,105,225,1],saddlebrown:[139,69,19,1],salmon:[250,128,114,1],sandybrown:[244,164,96,1],seagreen:[46,139,87,1],seashell:[255,245,238,1],sienna:[160,82,45,1],silver:[192,192,192,1],skyblue:[135,206,235,1],slateblue:[106,90,205,1],slategray:[112,128,144,1],slategrey:[112,128,144,1],snow:[255,250,250,1],springgreen:[0,255,127,1],steelblue:[70,130,180,1],tan:[210,180,140,1],teal:[0,128,128,1],thistle:[216,191,216,1],tomato:[255,99,71,1],turquoise:[64,224,208,1],violet:[238,130,238,1],wheat:[245,222,179,1],white:[255,255,255,1],whitesmoke:[245,245,245,1],yellow:[255,255,0,1],yellowgreen:[154,205,50,1]};function n(t){return (t=Math.round(t))<0?0:t>255?255:t}function i(t){return n("%"===t[t.length-1]?parseFloat(t)/100*255:parseInt(t))}function a(t){return (e="%"===t[t.length-1]?parseFloat(t)/100:parseFloat(t))<0?0:e>1?1:e;var e;}function o(t,e,r){return r<0?r+=1:r>1&&(r-=1),6*r<1?t+(e-t)*r*6:2*r<1?e:3*r<2?t+(e-t)*(2/3-r)*6:t}try{e.parseCSSColor=function(t){var e,s=t.replace(/ /g,"").toLowerCase();if(s in r)return r[s].slice();if("#"===s[0])return 4===s.length?(e=parseInt(s.substr(1),16))>=0&&e<=4095?[(3840&e)>>4|(3840&e)>>8,240&e|(240&e)>>4,15&e|(15&e)<<4,1]:null:7===s.length&&(e=parseInt(s.substr(1),16))>=0&&e<=16777215?[(16711680&e)>>16,(65280&e)>>8,255&e,1]:null;var u=s.indexOf("("),l=s.indexOf(")");if(-1!==u&&l+1===s.length){var p=s.substr(0,u),c=s.substr(u+1,l-(u+1)).split(","),h=1;switch(p){case"rgba":if(4!==c.length)return null;h=a(c.pop());case"rgb":return 3!==c.length?null:[i(c[0]),i(c[1]),i(c[2]),h];case"hsla":if(4!==c.length)return null;h=a(c.pop());case"hsl":if(3!==c.length)return null;var f=(parseFloat(c[0])%360+360)%360/360,y=a(c[1]),d=a(c[2]),m=d<=.5?d*(y+1):d+y-d*y,v=2*d-m;return [n(255*o(v,m,f+1/3)),n(255*o(v,m,f)),n(255*o(v,m,f-1/3)),h];default:return null}}return null};}catch(t){}})).parseCSSColor,$t=function(t,e,r,n){void 0===n&&(n=1),this.r=t,this.g=e,this.b=r,this.a=n;};$t.parse=function(t){if(t){if(t instanceof $t)return t;if("string"==typeof t){var e=Yt(t);if(e)return new $t(e[0]/255*e[3],e[1]/255*e[3],e[2]/255*e[3],e[3])}}},$t.prototype.toString=function(){var t=this.toArray(),e=t[1],r=t[2],n=t[3];return "rgba("+Math.round(t[0])+","+Math.round(e)+","+Math.round(r)+","+n+")"},$t.prototype.toArray=function(){var t=this.a;return 0===t?[0,0,0,0]:[255*this.r/t,255*this.g/t,255*this.b/t,t]},$t.black=new $t(0,0,0,1),$t.white=new $t(1,1,1,1),$t.transparent=new $t(0,0,0,0),$t.red=new $t(1,0,0,1);var Wt=function(t,e,r){this.sensitivity=t?e?"variant":"case":e?"accent":"base",this.locale=r,this.collator=new Intl.Collator(this.locale?this.locale:[],{sensitivity:this.sensitivity,usage:"search"});};Wt.prototype.compare=function(t,e){return this.collator.compare(t,e)},Wt.prototype.resolvedLocale=function(){return new Intl.Collator(this.locale?this.locale:[]).resolvedOptions().locale};var Qt=function(t,e,r,n,i){this.text=t,this.image=e,this.scale=r,this.fontStack=n,this.textColor=i;},te=function(t){this.sections=t;};te.fromString=function(t){return new te([new Qt(t,null,null,null,null)])},te.prototype.isEmpty=function(){return 0===this.sections.length||!this.sections.some((function(t){return 0!==t.text.length||t.image&&0!==t.image.name.length}))},te.factory=function(t){return t instanceof te?t:te.fromString(t)},te.prototype.toString=function(){return 0===this.sections.length?"":this.sections.map((function(t){return t.text})).join("")},te.prototype.serialize=function(){for(var t=["format"],e=0,r=this.sections;e<r.length;e+=1){var n=r[e];if(n.image)t.push(["image",n.image.name]);else{t.push(n.text);var i={};n.fontStack&&(i["text-font"]=["literal",n.fontStack.split(",")]),n.scale&&(i["font-scale"]=n.scale),n.textColor&&(i["text-color"]=["rgba"].concat(n.textColor.toArray())),t.push(i);}}return t};var ee=function(t){this.name=t.name,this.available=t.available;};function re(t,e,r,n){return "number"==typeof t&&t>=0&&t<=255&&"number"==typeof e&&e>=0&&e<=255&&"number"==typeof r&&r>=0&&r<=255?void 0===n||"number"==typeof n&&n>=0&&n<=1?null:"Invalid rgba value ["+[t,e,r,n].join(", ")+"]: 'a' must be between 0 and 1.":"Invalid rgba value ["+("number"==typeof n?[t,e,r,n]:[t,e,r]).join(", ")+"]: 'r', 'g', and 'b' must be between 0 and 255."}function ne(t){if(null===t)return !0;if("string"==typeof t)return !0;if("boolean"==typeof t)return !0;if("number"==typeof t)return !0;if(t instanceof $t)return !0;if(t instanceof Wt)return !0;if(t instanceof te)return !0;if(t instanceof ee)return !0;if(Array.isArray(t)){for(var e=0,r=t;e<r.length;e+=1)if(!ne(r[e]))return !1;return !0}if("object"==typeof t){for(var n in t)if(!ne(t[n]))return !1;return !0}return !1}function ie(t){if(null===t)return Dt;if("string"==typeof t)return Rt;if("boolean"==typeof t)return Ot;if("number"==typeof t)return Lt;if(t instanceof $t)return Ut;if(t instanceof Wt)return Nt;if(t instanceof te)return Kt;if(t instanceof ee)return Xt;if(Array.isArray(t)){for(var e,r=t.length,n=0,i=t;n<i.length;n+=1){var a=ie(i[n]);if(e){if(e===a)continue;e=qt;break}e=a;}return Gt(e||qt,r)}return jt}function ae(t){var e=typeof t;return null===t?"":"string"===e||"number"===e||"boolean"===e?String(t):t instanceof $t||t instanceof te||t instanceof ee?t.toString():JSON.stringify(t)}ee.prototype.toString=function(){return this.name},ee.fromString=function(t){return t?new ee({name:t,available:!1}):null},ee.prototype.serialize=function(){return ["image",this.name]};var oe=function(t,e){this.type=t,this.value=e;};oe.parse=function(t,e){if(2!==t.length)return e.error("'literal' expression requires exactly one argument, but found "+(t.length-1)+" instead.");if(!ne(t[1]))return e.error("invalid value");var r=t[1],n=ie(r),i=e.expectedType;return "array"!==n.kind||0!==n.N||!i||"array"!==i.kind||"number"==typeof i.N&&0!==i.N||(n=i),new oe(n,r)},oe.prototype.evaluate=function(){return this.value},oe.prototype.eachChild=function(){},oe.prototype.outputDefined=function(){return !0},oe.prototype.serialize=function(){return "array"===this.type.kind||"object"===this.type.kind?["literal",this.value]:this.value instanceof $t?["rgba"].concat(this.value.toArray()):this.value instanceof te?this.value.serialize():this.value};var se=function(t){this.name="ExpressionEvaluationError",this.message=t;};se.prototype.toJSON=function(){return this.message};var ue={string:Rt,number:Lt,boolean:Ot,object:jt},le=function(t,e){this.type=t,this.args=e;};le.parse=function(t,e){if(t.length<2)return e.error("Expected at least one argument.");var r,n=1,i=t[0];if("array"===i){var a,o;if(t.length>2){var s=t[1];if("string"!=typeof s||!(s in ue)||"object"===s)return e.error('The item type argument of "array" must be one of string, number, boolean',1);a=ue[s],n++;}else a=qt;if(t.length>3){if(null!==t[2]&&("number"!=typeof t[2]||t[2]<0||t[2]!==Math.floor(t[2])))return e.error('The length argument to "array" must be a positive integer literal',2);o=t[2],n++;}r=Gt(a,o);}else r=ue[i];for(var u=[];n<t.length;n++){var l=e.parse(t[n],n,qt);if(!l)return null;u.push(l);}return new le(r,u)},le.prototype.evaluate=function(t){for(var e=0;e<this.args.length;e++){var r=this.args[e].evaluate(t);if(!Ht(this.type,ie(r)))return r;if(e===this.args.length-1)throw new se("Expected value to be of type "+Zt(this.type)+", but found "+Zt(ie(r))+" instead.")}return null},le.prototype.eachChild=function(t){this.args.forEach(t);},le.prototype.outputDefined=function(){return this.args.every((function(t){return t.outputDefined()}))},le.prototype.serialize=function(){var t=this.type,e=[t.kind];if("array"===t.kind){var r=t.itemType;if("string"===r.kind||"number"===r.kind||"boolean"===r.kind){e.push(r.kind);var n=t.N;("number"==typeof n||this.args.length>1)&&e.push(n);}}return e.concat(this.args.map((function(t){return t.serialize()})))};var pe=function(t){this.type=Kt,this.sections=t;};pe.parse=function(t,e){if(t.length<2)return e.error("Expected at least one argument.");var r=t[1];if(!Array.isArray(r)&&"object"==typeof r)return e.error("First argument must be an image or text section.");for(var n=[],i=!1,a=1;a<=t.length-1;++a){var o=t[a];if(i&&"object"==typeof o&&!Array.isArray(o)){i=!1;var s=null;if(o["font-scale"]&&!(s=e.parse(o["font-scale"],1,Lt)))return null;var u=null;if(o["text-font"]&&!(u=e.parse(o["text-font"],1,Gt(Rt))))return null;var l=null;if(o["text-color"]&&!(l=e.parse(o["text-color"],1,Ut)))return null;var p=n[n.length-1];p.scale=s,p.font=u,p.textColor=l;}else{var c=e.parse(t[a],1,qt);if(!c)return null;var h=c.type.kind;if("string"!==h&&"value"!==h&&"null"!==h&&"resolvedImage"!==h)return e.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");i=!0,n.push({content:c,scale:null,font:null,textColor:null});}}return new pe(n)},pe.prototype.evaluate=function(t){return new te(this.sections.map((function(e){var r=e.content.evaluate(t);return ie(r)===Xt?new Qt("",r,null,null,null):new Qt(ae(r),null,e.scale?e.scale.evaluate(t):null,e.font?e.font.evaluate(t).join(","):null,e.textColor?e.textColor.evaluate(t):null)})))},pe.prototype.eachChild=function(t){for(var e=0,r=this.sections;e<r.length;e+=1){var n=r[e];t(n.content),n.scale&&t(n.scale),n.font&&t(n.font),n.textColor&&t(n.textColor);}},pe.prototype.outputDefined=function(){return !1},pe.prototype.serialize=function(){for(var t=["format"],e=0,r=this.sections;e<r.length;e+=1){var n=r[e];t.push(n.content.serialize());var i={};n.scale&&(i["font-scale"]=n.scale.serialize()),n.font&&(i["text-font"]=n.font.serialize()),n.textColor&&(i["text-color"]=n.textColor.serialize()),t.push(i);}return t};var ce=function(t){this.type=Xt,this.input=t;};ce.parse=function(t,e){if(2!==t.length)return e.error("Expected two arguments.");var r=e.parse(t[1],1,Rt);return r?new ce(r):e.error("No image name provided.")},ce.prototype.evaluate=function(t){var e=this.input.evaluate(t),r=ee.fromString(e);return r&&t.availableImages&&(r.available=t.availableImages.indexOf(e)>-1),r},ce.prototype.eachChild=function(t){t(this.input);},ce.prototype.outputDefined=function(){return !1},ce.prototype.serialize=function(){return ["image",this.input.serialize()]};var he={"to-boolean":Ot,"to-color":Ut,"to-number":Lt,"to-string":Rt},fe=function(t,e){this.type=t,this.args=e;};fe.parse=function(t,e){if(t.length<2)return e.error("Expected at least one argument.");var r=t[0];if(("to-boolean"===r||"to-string"===r)&&2!==t.length)return e.error("Expected one argument.");for(var n=he[r],i=[],a=1;a<t.length;a++){var o=e.parse(t[a],a,qt);if(!o)return null;i.push(o);}return new fe(n,i)},fe.prototype.evaluate=function(t){if("boolean"===this.type.kind)return Boolean(this.args[0].evaluate(t));if("color"===this.type.kind){for(var e,r,n=0,i=this.args;n<i.length;n+=1){if(r=null,(e=i[n].evaluate(t))instanceof $t)return e;if("string"==typeof e){var a=t.parseColor(e);if(a)return a}else if(Array.isArray(e)&&!(r=e.length<3||e.length>4?"Invalid rbga value "+JSON.stringify(e)+": expected an array containing either three or four numeric values.":re(e[0],e[1],e[2],e[3])))return new $t(e[0]/255,e[1]/255,e[2]/255,e[3])}throw new se(r||"Could not parse color from value '"+("string"==typeof e?e:String(JSON.stringify(e)))+"'")}if("number"===this.type.kind){for(var o=null,s=0,u=this.args;s<u.length;s+=1){if(null===(o=u[s].evaluate(t)))return 0;var l=Number(o);if(!isNaN(l))return l}throw new se("Could not convert "+JSON.stringify(o)+" to number.")}return "formatted"===this.type.kind?te.fromString(ae(this.args[0].evaluate(t))):"resolvedImage"===this.type.kind?ee.fromString(ae(this.args[0].evaluate(t))):ae(this.args[0].evaluate(t))},fe.prototype.eachChild=function(t){this.args.forEach(t);},fe.prototype.outputDefined=function(){return this.args.every((function(t){return t.outputDefined()}))},fe.prototype.serialize=function(){if("formatted"===this.type.kind)return new pe([{content:this.args[0],scale:null,font:null,textColor:null}]).serialize();if("resolvedImage"===this.type.kind)return new ce(this.args[0]).serialize();var t=["to-"+this.type.kind];return this.eachChild((function(e){t.push(e.serialize());})),t};var ye=["Unknown","Point","LineString","Polygon"],de=function(){this.globals=null,this.feature=null,this.featureState=null,this.formattedSection=null,this._parseColorCache={},this.availableImages=null,this.canonical=null;};de.prototype.id=function(){return this.feature&&"id"in this.feature?this.feature.id:null},de.prototype.geometryType=function(){return this.feature?"number"==typeof this.feature.type?ye[this.feature.type]:this.feature.type:null},de.prototype.geometry=function(){return this.feature&&"geometry"in this.feature?this.feature.geometry:null},de.prototype.canonicalID=function(){return this.canonical},de.prototype.properties=function(){return this.feature&&this.feature.properties||{}},de.prototype.parseColor=function(t){var e=this._parseColorCache[t];return e||(e=this._parseColorCache[t]=$t.parse(t)),e};var me=function(t,e,r,n){this.name=t,this.type=e,this._evaluate=r,this.args=n;};me.prototype.evaluate=function(t){return this._evaluate(t,this.args)},me.prototype.eachChild=function(t){this.args.forEach(t);},me.prototype.outputDefined=function(){return !1},me.prototype.serialize=function(){return [this.name].concat(this.args.map((function(t){return t.serialize()})))},me.parse=function(t,e){var r,n=t[0],i=me.definitions[n];if(!i)return e.error('Unknown expression "'+n+'". If you wanted a literal array, use ["literal", [...]].',0);for(var a=Array.isArray(i)?i[0]:i.type,o=Array.isArray(i)?[[i[1],i[2]]]:i.overloads,s=o.filter((function(e){var r=e[0];return !Array.isArray(r)||r.length===t.length-1})),u=null,l=0,p=s;l<p.length;l+=1){var c=p[l],h=c[0],f=c[1];u=new Xe(e.registry,e.path,null,e.scope);for(var y=[],d=!1,m=1;m<t.length;m++){var v=t[m],g=Array.isArray(h)?h[m-1]:h.type,x=u.parse(v,1+y.length,g);if(!x){d=!0;break}y.push(x);}if(!d)if(Array.isArray(h)&&h.length!==y.length)u.error("Expected "+h.length+" arguments, but found "+y.length+" instead.");else{for(var b=0;b<y.length;b++){var w=Array.isArray(h)?h[b]:h.type,_=y[b];u.concat(b+1).checkSubtype(w,_.type);}if(0===u.errors.length)return new me(n,a,f,y)}}if(1===s.length)(r=e.errors).push.apply(r,u.errors);else{for(var A=(s.length?s:o).map((function(t){var e;return e=t[0],Array.isArray(e)?"("+e.map(Zt).join(", ")+")":"("+Zt(e.type)+"...)"})).join(" | "),S=[],k=1;k<t.length;k++){var I=e.parse(t[k],1+S.length);if(!I)return null;S.push(Zt(I.type));}e.error("Expected arguments of type "+A+", but found ("+S.join(", ")+") instead.");}return null},me.register=function(t,e){for(var r in me.definitions=e,e)t[r]=me;};var ve=function(t,e,r){this.type=Nt,this.locale=r,this.caseSensitive=t,this.diacriticSensitive=e;};ve.parse=function(t,e){if(2!==t.length)return e.error("Expected one argument.");var r=t[1];if("object"!=typeof r||Array.isArray(r))return e.error("Collator options argument must be an object.");var n=e.parse(void 0!==r["case-sensitive"]&&r["case-sensitive"],1,Ot);if(!n)return null;var i=e.parse(void 0!==r["diacritic-sensitive"]&&r["diacritic-sensitive"],1,Ot);if(!i)return null;var a=null;return r.locale&&!(a=e.parse(r.locale,1,Rt))?null:new ve(n,i,a)},ve.prototype.evaluate=function(t){return new Wt(this.caseSensitive.evaluate(t),this.diacriticSensitive.evaluate(t),this.locale?this.locale.evaluate(t):null)},ve.prototype.eachChild=function(t){t(this.caseSensitive),t(this.diacriticSensitive),this.locale&&t(this.locale);},ve.prototype.outputDefined=function(){return !1},ve.prototype.serialize=function(){var t={};return t["case-sensitive"]=this.caseSensitive.serialize(),t["diacritic-sensitive"]=this.diacriticSensitive.serialize(),this.locale&&(t.locale=this.locale.serialize()),["collator",t]};var ge=function(t,e){t&&(e?this.setSouthWest(t).setNorthEast(e):4===t.length?this.setSouthWest([t[0],t[1]]).setNorthEast([t[2],t[3]]):this.setSouthWest(t[0]).setNorthEast(t[1]));};ge.prototype.setNorthEast=function(t){return this._ne=t instanceof xe?new xe(t.lng,t.lat):xe.convert(t),this},ge.prototype.setSouthWest=function(t){return this._sw=t instanceof xe?new xe(t.lng,t.lat):xe.convert(t),this},ge.prototype.extend=function(t){var e,r,n=this._sw,i=this._ne;if(t instanceof xe)e=t,r=t;else{if(!(t instanceof ge))return Array.isArray(t)?4===t.length||t.every(Array.isArray)?this.extend(ge.convert(t)):this.extend(xe.convert(t)):this;if(r=t._ne,!(e=t._sw)||!r)return this}return n||i?(n.lng=Math.min(e.lng,n.lng),n.lat=Math.min(e.lat,n.lat),i.lng=Math.max(r.lng,i.lng),i.lat=Math.max(r.lat,i.lat)):(this._sw=new xe(e.lng,e.lat),this._ne=new xe(r.lng,r.lat)),this},ge.prototype.getCenter=function(){return new xe((this._sw.lng+this._ne.lng)/2,(this._sw.lat+this._ne.lat)/2)},ge.prototype.getSouthWest=function(){return this._sw},ge.prototype.getNorthEast=function(){return this._ne},ge.prototype.getNorthWest=function(){return new xe(this.getWest(),this.getNorth())},ge.prototype.getSouthEast=function(){return new xe(this.getEast(),this.getSouth())},ge.prototype.getWest=function(){return this._sw.lng},ge.prototype.getSouth=function(){return this._sw.lat},ge.prototype.getEast=function(){return this._ne.lng},ge.prototype.getNorth=function(){return this._ne.lat},ge.prototype.toArray=function(){return [this._sw.toArray(),this._ne.toArray()]},ge.prototype.toString=function(){return "LngLatBounds("+this._sw.toString()+", "+this._ne.toString()+")"},ge.prototype.isEmpty=function(){return !(this._sw&&this._ne)},ge.prototype.contains=function(t){var e=xe.convert(t),r=e.lng,n=e.lat,i=this._sw.lng<=r&&r<=this._ne.lng;return this._sw.lng>this._ne.lng&&(i=this._sw.lng>=r&&r>=this._ne.lng),this._sw.lat<=n&&n<=this._ne.lat&&i},ge.convert=function(t){return !t||t instanceof ge?t:new ge(t)};var xe=function(t,e){if(isNaN(t)||isNaN(e))throw new Error("Invalid LngLat object: ("+t+", "+e+")");if(this.lng=+t,this.lat=+e,this.lat>90||this.lat<-90)throw new Error("Invalid LngLat latitude value: must be between -90 and 90")};xe.prototype.wrap=function(){return new xe(l(this.lng,-180,180),this.lat)},xe.prototype.toArray=function(){return [this.lng,this.lat]},xe.prototype.toString=function(){return "LngLat("+this.lng+", "+this.lat+")"},xe.prototype.distanceTo=function(t){var e=Math.PI/180,r=this.lat*e,n=t.lat*e,i=Math.sin(r)*Math.sin(n)+Math.cos(r)*Math.cos(n)*Math.cos((t.lng-this.lng)*e);return 6371008.8*Math.acos(Math.min(i,1))},xe.prototype.toBounds=function(t){void 0===t&&(t=0);var e=360*t/40075017,r=e/Math.cos(Math.PI/180*this.lat);return new ge(new xe(this.lng-r,this.lat-e),new xe(this.lng+r,this.lat+e))},xe.convert=function(t){if(t instanceof xe)return t;if(Array.isArray(t)&&(2===t.length||3===t.length))return new xe(Number(t[0]),Number(t[1]));if(!Array.isArray(t)&&"object"==typeof t&&null!==t)return new xe(Number("lng"in t?t.lng:t.lon),Number(t.lat));throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")};var be=2*Math.PI*6371008.8;function we(t){return be*Math.cos(t*Math.PI/180)}function _e(t){return (180+t)/360}function Ae(t){return (180-180/Math.PI*Math.log(Math.tan(Math.PI/4+t*Math.PI/360)))/360}function Se(t,e){return t/we(e)}function ke(t){return 360/Math.PI*Math.atan(Math.exp((180-360*t)*Math.PI/180))-90}var Ie=function(t,e,r){void 0===r&&(r=0),this.x=+t,this.y=+e,this.z=+r;};Ie.fromLngLat=function(t,e){void 0===e&&(e=0);var r=xe.convert(t);return new Ie(_e(r.lng),Ae(r.lat),Se(e,r.lat))},Ie.prototype.toLngLat=function(){return new xe(360*this.x-180,ke(this.y))},Ie.prototype.toAltitude=function(){return this.z*we(ke(this.y))},Ie.prototype.meterInMercatorCoordinateUnits=function(){return 1/be*(t=ke(this.y),1/Math.cos(t*Math.PI/180));var t;};var ze=8192;function Ce(t,e){t[0]=Math.min(t[0],e[0]),t[1]=Math.min(t[1],e[1]),t[2]=Math.max(t[2],e[0]),t[3]=Math.max(t[3],e[1]);}function Me(t,e){return !(t[0]<=e[0]||t[2]>=e[2]||t[1]<=e[1]||t[3]>=e[3])}function Te(t,e){var r=Ie.fromLngLat({lng:t[0],lat:t[1]},0),n=Math.pow(2,e.z);return [Math.round(r.x*n*ze),Math.round(r.y*n*ze)]}function Ee(t,e,r){return e[1]>t[1]!=r[1]>t[1]&&t[0]<(r[0]-e[0])*(t[1]-e[1])/(r[1]-e[1])+e[0]}function Pe(t,e){for(var r,n,i,a,o,s,u,l=!1,p=0,c=e.length;p<c;p++)for(var h=e[p],f=0,y=h.length;f<y-1;f++){if((a=(r=t)[0]-(n=h[f])[0])*(u=r[1]-(i=h[f+1])[1])-(s=r[0]-i[0])*(o=r[1]-n[1])==0&&a*s<=0&&o*u<=0)return !1;Ee(t,h[f],h[f+1])&&(l=!l);}return l}function Be(t,e){for(var r=0;r<e.length;r++)if(Pe(t,e[r]))return !0;return !1}function Ve(t,e,r,n){var i=n[0]-r[0],a=n[1]-r[1];return ((t[0]-r[0])*a-i*(t[1]-r[1]))*((e[0]-r[0])*a-i*(e[1]-r[1]))<0}function Fe(t,e,r){for(var n=0,i=r;n<i.length;n+=1)for(var a=i[n],o=0;o<a.length-1;++o)if(0!=(c=[(p=a[o+1])[0]-(l=a[o])[0],p[1]-l[1]])[0]*(h=[(u=e)[0]-(s=t)[0],u[1]-s[1]])[1]-c[1]*h[0]&&Ve(s,u,l,p)&&Ve(l,p,s,u))return !0;var s,u,l,p,c,h;return !1}function De(t,e){for(var r=0;r<t.length;++r)if(!Pe(t[r],e))return !1;for(var n=0;n<t.length-1;++n)if(Fe(t[n],t[n+1],e))return !1;return !0}function Le(t,e){for(var r=0;r<e.length;r++)if(De(t,e[r]))return !0;return !1}function Re(t,e,r){for(var n=[],i=0;i<t.length;i++){for(var a=[],o=0;o<t[i].length;o++){var s=Te(t[i][o],r);Ce(e,s),a.push(s);}n.push(a);}return n}function Oe(t,e,r){for(var n=[],i=0;i<t.length;i++){var a=Re(t[i],e,r);n.push(a);}return n}var Ue=function(t,e){this.type=Ot,this.geojson=t,this.geometries=e;};function je(t){if(t instanceof me){if("get"===t.name&&1===t.args.length)return !1;if("feature-state"===t.name)return !1;if("has"===t.name&&1===t.args.length)return !1;if("properties"===t.name||"geometry-type"===t.name||"id"===t.name)return !1;if(/^filter-/.test(t.name))return !1}if(t instanceof Ue)return !1;var e=!0;return t.eachChild((function(t){e&&!je(t)&&(e=!1);})),e}function qe(t){if(t instanceof me&&"feature-state"===t.name)return !1;var e=!0;return t.eachChild((function(t){e&&!qe(t)&&(e=!1);})),e}function Ne(t,e){if(t instanceof me&&e.indexOf(t.name)>=0)return !1;var r=!0;return t.eachChild((function(t){r&&!Ne(t,e)&&(r=!1);})),r}Ue.parse=function(t,e){if(2!==t.length)return e.error("'within' expression requires exactly one argument, but found "+(t.length-1)+" instead.");if(ne(t[1])){var r=t[1];if("FeatureCollection"===r.type)for(var n=0;n<r.features.length;++n){var i=r.features[n].geometry.type;if("Polygon"===i||"MultiPolygon"===i)return new Ue(r,r.features[n].geometry)}else if("Feature"===r.type){var a=r.geometry.type;if("Polygon"===a||"MultiPolygon"===a)return new Ue(r,r.geometry)}else if("Polygon"===r.type||"MultiPolygon"===r.type)return new Ue(r,r)}return e.error("'within' expression requires valid geojson object that contains polygon geometry type.")},Ue.prototype.evaluate=function(t){if(null!=t.geometry()&&null!=t.canonicalID()){if("Point"===t.geometryType())return function(t,e){for(var r=[1/0,1/0,-1/0,-1/0],n=[1/0,1/0,-1/0,-1/0],i=t.canonicalID(),a=[i.x*ze,i.y*ze],o=[],s=0,u=t.geometry();s<u.length;s+=1)for(var l=0,p=u[s];l<p.length;l+=1){var c=p[l],h=[c.x+a[0],c.y+a[1]];Ce(r,h),o.push(h);}if("Polygon"===e.type){var f=Re(e.coordinates,n,i);if(!Me(r,n))return !1;for(var y=0,d=o;y<d.length;y+=1)if(!Pe(d[y],f))return !1}if("MultiPolygon"===e.type){var m=Oe(e.coordinates,n,i);if(!Me(r,n))return !1;for(var v=0,g=o;v<g.length;v+=1)if(!Be(g[v],m))return !1}return !0}(t,this.geometries);if("LineString"===t.geometryType())return function(t,e){for(var r=[1/0,1/0,-1/0,-1/0],n=[1/0,1/0,-1/0,-1/0],i=t.canonicalID(),a=[i.x*ze,i.y*ze],o=[],s=0,u=t.geometry();s<u.length;s+=1){for(var l=[],p=0,c=u[s];p<c.length;p+=1){var h=c[p],f=[h.x+a[0],h.y+a[1]];Ce(r,f),l.push(f);}o.push(l);}if("Polygon"===e.type){var y=Re(e.coordinates,n,i);if(!Me(r,n))return !1;for(var d=0,m=o;d<m.length;d+=1)if(!De(m[d],y))return !1}if("MultiPolygon"===e.type){var v=Oe(e.coordinates,n,i);if(!Me(r,n))return !1;for(var g=0,x=o;g<x.length;g+=1)if(!Le(x[g],v))return !1}return !0}(t,this.geometries)}return !1},Ue.prototype.eachChild=function(){},Ue.prototype.outputDefined=function(){return !0},Ue.prototype.serialize=function(){return ["within",this.geojson]};var Ke=function(t,e){this.type=e.type,this.name=t,this.boundExpression=e;};Ke.parse=function(t,e){if(2!==t.length||"string"!=typeof t[1])return e.error("'var' expression requires exactly one string literal argument.");var r=t[1];return e.scope.has(r)?new Ke(r,e.scope.get(r)):e.error('Unknown variable "'+r+'". Make sure "'+r+'" has been bound in an enclosing "let" expression before using it.',1)},Ke.prototype.evaluate=function(t){return this.boundExpression.evaluate(t)},Ke.prototype.eachChild=function(){},Ke.prototype.outputDefined=function(){return !1},Ke.prototype.serialize=function(){return ["var",this.name]};var Xe=function(t,e,r,n,i){void 0===e&&(e=[]),void 0===n&&(n=new Ft),void 0===i&&(i=[]),this.registry=t,this.path=e,this.key=e.map((function(t){return "["+t+"]"})).join(""),this.scope=n,this.errors=i,this.expectedType=r;};function Ge(t,e){for(var r,n=t.length-1,i=0,a=n,o=0;i<=a;)if((r=t[o=Math.floor((i+a)/2)])<=e){if(o===n||e<t[o+1])return o;i=o+1;}else{if(!(r>e))throw new se("Input is not a number.");a=o-1;}return 0}Xe.prototype.parse=function(t,e,r,n,i){return void 0===i&&(i={}),e?this.concat(e,r,n)._parse(t,i):this._parse(t,i)},Xe.prototype._parse=function(t,e){function r(t,e,r){return "assert"===r?new le(e,[t]):"coerce"===r?new fe(e,[t]):t}if(null!==t&&"string"!=typeof t&&"boolean"!=typeof t&&"number"!=typeof t||(t=["literal",t]),Array.isArray(t)){if(0===t.length)return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');var n=t[0];if("string"!=typeof n)return this.error("Expression name must be a string, but found "+typeof n+' instead. If you wanted a literal array, use ["literal", [...]].',0),null;var i=this.registry[n];if(i){var a=i.parse(t,this);if(!a)return null;if(this.expectedType){var o=this.expectedType,s=a.type;if("string"!==o.kind&&"number"!==o.kind&&"boolean"!==o.kind&&"object"!==o.kind&&"array"!==o.kind||"value"!==s.kind)if("color"!==o.kind&&"formatted"!==o.kind&&"resolvedImage"!==o.kind||"value"!==s.kind&&"string"!==s.kind){if(this.checkSubtype(o,s))return null}else a=r(a,o,e.typeAnnotation||"coerce");else a=r(a,o,e.typeAnnotation||"assert");}if(!(a instanceof oe)&&"resolvedImage"!==a.type.kind&&function t(e){if(e instanceof Ke)return t(e.boundExpression);if(e instanceof me&&"error"===e.name)return !1;if(e instanceof ve)return !1;if(e instanceof Ue)return !1;var r=e instanceof fe||e instanceof le,n=!0;return e.eachChild((function(e){n=r?n&&t(e):n&&e instanceof oe;})),!!n&&je(e)&&Ne(e,["zoom","heatmap-density","line-progress","accumulated","is-supported-script"])}(a)){var u=new de;try{a=new oe(a.type,a.evaluate(u));}catch(t){return this.error(t.message),null}}return a}return this.error('Unknown expression "'+n+'". If you wanted a literal array, use ["literal", [...]].',0)}return this.error(void 0===t?"'undefined' value invalid. Use null instead.":"object"==typeof t?'Bare objects invalid. Use ["literal", {...}] instead.':"Expected an array, but found "+typeof t+" instead.")},Xe.prototype.concat=function(t,e,r){var n="number"==typeof t?this.path.concat(t):this.path,i=r?this.scope.concat(r):this.scope;return new Xe(this.registry,n,e||null,i,this.errors)},Xe.prototype.error=function(t){for(var e=[],r=arguments.length-1;r-- >0;)e[r]=arguments[r+1];var n=""+this.key+e.map((function(t){return "["+t+"]"})).join("");this.errors.push(new Vt(n,t));},Xe.prototype.checkSubtype=function(t,e){var r=Ht(t,e);return r&&this.error(r),r};var Ze=function(t,e,r){this.type=t,this.input=e,this.labels=[],this.outputs=[];for(var n=0,i=r;n<i.length;n+=1){var a=i[n],o=a[1];this.labels.push(a[0]),this.outputs.push(o);}};Ze.parse=function(t,e){if(t.length-1<4)return e.error("Expected at least 4 arguments, but found only "+(t.length-1)+".");if((t.length-1)%2!=0)return e.error("Expected an even number of arguments.");var r=e.parse(t[1],1,Lt);if(!r)return null;var n=[],i=null;e.expectedType&&"value"!==e.expectedType.kind&&(i=e.expectedType);for(var a=1;a<t.length;a+=2){var o=1===a?-1/0:t[a],s=t[a+1],u=a,l=a+1;if("number"!=typeof o)return e.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.',u);if(n.length&&n[n.length-1][0]>=o)return e.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.',u);var p=e.parse(s,l,i);if(!p)return null;i=i||p.type,n.push([o,p]);}return new Ze(i,r,n)},Ze.prototype.evaluate=function(t){var e=this.labels,r=this.outputs;if(1===e.length)return r[0].evaluate(t);var n=this.input.evaluate(t);if(n<=e[0])return r[0].evaluate(t);var i=e.length;return n>=e[i-1]?r[i-1].evaluate(t):r[Ge(e,n)].evaluate(t)},Ze.prototype.eachChild=function(t){t(this.input);for(var e=0,r=this.outputs;e<r.length;e+=1)t(r[e]);},Ze.prototype.outputDefined=function(){return this.outputs.every((function(t){return t.outputDefined()}))},Ze.prototype.serialize=function(){for(var t=["step",this.input.serialize()],e=0;e<this.labels.length;e++)e>0&&t.push(this.labels[e]),t.push(this.outputs[e].serialize());return t};var Je=He;function He(t,e,r,n){this.cx=3*t,this.bx=3*(r-t)-this.cx,this.ax=1-this.cx-this.bx,this.cy=3*e,this.by=3*(n-e)-this.cy,this.ay=1-this.cy-this.by,this.p1x=t,this.p1y=n,this.p2x=r,this.p2y=n;}function Ye(t,e,r){return t*(1-r)+e*r}He.prototype.sampleCurveX=function(t){return ((this.ax*t+this.bx)*t+this.cx)*t},He.prototype.sampleCurveY=function(t){return ((this.ay*t+this.by)*t+this.cy)*t},He.prototype.sampleCurveDerivativeX=function(t){return (3*this.ax*t+2*this.bx)*t+this.cx},He.prototype.solveCurveX=function(t,e){var r,n,i,a,o;for(void 0===e&&(e=1e-6),i=t,o=0;o<8;o++){if(a=this.sampleCurveX(i)-t,Math.abs(a)<e)return i;var s=this.sampleCurveDerivativeX(i);if(Math.abs(s)<1e-6)break;i-=a/s;}if((i=t)<(r=0))return r;if(i>(n=1))return n;for(;r<n;){if(a=this.sampleCurveX(i),Math.abs(a-t)<e)return i;t>a?r=i:n=i,i=.5*(n-r)+r;}return i},He.prototype.solve=function(t,e){return this.sampleCurveY(this.solveCurveX(t,e))};var $e=Object.freeze({__proto__:null,number:Ye,color:function(t,e,r){return new $t(Ye(t.r,e.r,r),Ye(t.g,e.g,r),Ye(t.b,e.b,r),Ye(t.a,e.a,r))},array:function(t,e,r){return t.map((function(t,n){return Ye(t,e[n],r)}))}}),We=.95047,Qe=1,tr=1.08883,er=4/29,rr=6/29,nr=3*rr*rr,ir=rr*rr*rr,ar=Math.PI/180,or=180/Math.PI;function sr(t){return t>ir?Math.pow(t,1/3):t/nr+er}function ur(t){return t>rr?t*t*t:nr*(t-er)}function lr(t){return 255*(t<=.0031308?12.92*t:1.055*Math.pow(t,1/2.4)-.055)}function pr(t){return (t/=255)<=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4)}function cr(t){var e=pr(t.r),r=pr(t.g),n=pr(t.b),i=sr((.4124564*e+.3575761*r+.1804375*n)/We),a=sr((.2126729*e+.7151522*r+.072175*n)/Qe);return {l:116*a-16,a:500*(i-a),b:200*(a-sr((.0193339*e+.119192*r+.9503041*n)/tr)),alpha:t.a}}function hr(t){var e=(t.l+16)/116,r=isNaN(t.a)?e:e+t.a/500,n=isNaN(t.b)?e:e-t.b/200;return e=Qe*ur(e),r=We*ur(r),n=tr*ur(n),new $t(lr(3.2404542*r-1.5371385*e-.4985314*n),lr(-.969266*r+1.8760108*e+.041556*n),lr(.0556434*r-.2040259*e+1.0572252*n),t.alpha)}function fr(t,e,r){var n=e-t;return t+r*(n>180||n<-180?n-360*Math.round(n/360):n)}var yr={forward:cr,reverse:hr,interpolate:function(t,e,r){return {l:Ye(t.l,e.l,r),a:Ye(t.a,e.a,r),b:Ye(t.b,e.b,r),alpha:Ye(t.alpha,e.alpha,r)}}},dr={forward:function(t){var e=cr(t),r=e.l,n=e.a,i=e.b,a=Math.atan2(i,n)*or;return {h:a<0?a+360:a,c:Math.sqrt(n*n+i*i),l:r,alpha:t.a}},reverse:function(t){var e=t.h*ar,r=t.c;return hr({l:t.l,a:Math.cos(e)*r,b:Math.sin(e)*r,alpha:t.alpha})},interpolate:function(t,e,r){return {h:fr(t.h,e.h,r),c:Ye(t.c,e.c,r),l:Ye(t.l,e.l,r),alpha:Ye(t.alpha,e.alpha,r)}}},mr=Object.freeze({__proto__:null,lab:yr,hcl:dr}),vr=function(t,e,r,n,i){this.type=t,this.operator=e,this.interpolation=r,this.input=n,this.labels=[],this.outputs=[];for(var a=0,o=i;a<o.length;a+=1){var s=o[a],u=s[1];this.labels.push(s[0]),this.outputs.push(u);}};function gr(t,e,r,n){var i=n-r,a=t-r;return 0===i?0:1===e?a/i:(Math.pow(e,a)-1)/(Math.pow(e,i)-1)}vr.interpolationFactor=function(t,e,r,n){var i=0;if("exponential"===t.name)i=gr(e,t.base,r,n);else if("linear"===t.name)i=gr(e,1,r,n);else if("cubic-bezier"===t.name){var a=t.controlPoints;i=new Je(a[0],a[1],a[2],a[3]).solve(gr(e,1,r,n));}return i},vr.parse=function(t,e){var r=t[0],n=t[1],i=t[2],a=t.slice(3);if(!Array.isArray(n)||0===n.length)return e.error("Expected an interpolation type expression.",1);if("linear"===n[0])n={name:"linear"};else if("exponential"===n[0]){var o=n[1];if("number"!=typeof o)return e.error("Exponential interpolation requires a numeric base.",1,1);n={name:"exponential",base:o};}else{if("cubic-bezier"!==n[0])return e.error("Unknown interpolation type "+String(n[0]),1,0);var s=n.slice(1);if(4!==s.length||s.some((function(t){return "number"!=typeof t||t<0||t>1})))return e.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.",1);n={name:"cubic-bezier",controlPoints:s};}if(t.length-1<4)return e.error("Expected at least 4 arguments, but found only "+(t.length-1)+".");if((t.length-1)%2!=0)return e.error("Expected an even number of arguments.");if(!(i=e.parse(i,2,Lt)))return null;var u=[],l=null;"interpolate-hcl"===r||"interpolate-lab"===r?l=Ut:e.expectedType&&"value"!==e.expectedType.kind&&(l=e.expectedType);for(var p=0;p<a.length;p+=2){var c=a[p],h=a[p+1],f=p+3,y=p+4;if("number"!=typeof c)return e.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.',f);if(u.length&&u[u.length-1][0]>=c)return e.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.',f);var d=e.parse(h,y,l);if(!d)return null;l=l||d.type,u.push([c,d]);}return "number"===l.kind||"color"===l.kind||"array"===l.kind&&"number"===l.itemType.kind&&"number"==typeof l.N?new vr(l,r,n,i,u):e.error("Type "+Zt(l)+" is not interpolatable.")},vr.prototype.evaluate=function(t){var e=this.labels,r=this.outputs;if(1===e.length)return r[0].evaluate(t);var n=this.input.evaluate(t);if(n<=e[0])return r[0].evaluate(t);var i=e.length;if(n>=e[i-1])return r[i-1].evaluate(t);var a=Ge(e,n),o=vr.interpolationFactor(this.interpolation,n,e[a],e[a+1]),s=r[a].evaluate(t),u=r[a+1].evaluate(t);return "interpolate"===this.operator?$e[this.type.kind.toLowerCase()](s,u,o):"interpolate-hcl"===this.operator?dr.reverse(dr.interpolate(dr.forward(s),dr.forward(u),o)):yr.reverse(yr.interpolate(yr.forward(s),yr.forward(u),o))},vr.prototype.eachChild=function(t){t(this.input);for(var e=0,r=this.outputs;e<r.length;e+=1)t(r[e]);},vr.prototype.outputDefined=function(){return this.outputs.every((function(t){return t.outputDefined()}))},vr.prototype.serialize=function(){var t;t="linear"===this.interpolation.name?["linear"]:"exponential"===this.interpolation.name?1===this.interpolation.base?["linear"]:["exponential",this.interpolation.base]:["cubic-bezier"].concat(this.interpolation.controlPoints);for(var e=[this.operator,t,this.input.serialize()],r=0;r<this.labels.length;r++)e.push(this.labels[r],this.outputs[r].serialize());return e};var xr=function(t,e){this.type=t,this.args=e;};xr.parse=function(t,e){if(t.length<2)return e.error("Expectected at least one argument.");var r=null,n=e.expectedType;n&&"value"!==n.kind&&(r=n);for(var i=[],a=0,o=t.slice(1);a<o.length;a+=1){var s=e.parse(o[a],1+i.length,r,void 0,{typeAnnotation:"omit"});if(!s)return null;r=r||s.type,i.push(s);}var u=n&&i.some((function(t){return Ht(n,t.type)}));return new xr(u?qt:r,i)},xr.prototype.evaluate=function(t){for(var e,r=null,n=0,i=0,a=this.args;i<a.length&&(n++,(r=a[i].evaluate(t))&&r instanceof ee&&!r.available&&(e||(e=r.name),r=null,n===this.args.length&&(r=e)),null===r);i+=1);return r},xr.prototype.eachChild=function(t){this.args.forEach(t);},xr.prototype.outputDefined=function(){return this.args.every((function(t){return t.outputDefined()}))},xr.prototype.serialize=function(){var t=["coalesce"];return this.eachChild((function(e){t.push(e.serialize());})),t};var br=function(t,e){this.type=e.type,this.bindings=[].concat(t),this.result=e;};br.prototype.evaluate=function(t){return this.result.evaluate(t)},br.prototype.eachChild=function(t){for(var e=0,r=this.bindings;e<r.length;e+=1)t(r[e][1]);t(this.result);},br.parse=function(t,e){if(t.length<4)return e.error("Expected at least 3 arguments, but found "+(t.length-1)+" instead.");for(var r=[],n=1;n<t.length-1;n+=2){var i=t[n];if("string"!=typeof i)return e.error("Expected string, but found "+typeof i+" instead.",n);if(/[^a-zA-Z0-9_]/.test(i))return e.error("Variable names must contain only alphanumeric characters or '_'.",n);var a=e.parse(t[n+1],n+1);if(!a)return null;r.push([i,a]);}var o=e.parse(t[t.length-1],t.length-1,e.expectedType,r);return o?new br(r,o):null},br.prototype.outputDefined=function(){return this.result.outputDefined()},br.prototype.serialize=function(){for(var t=["let"],e=0,r=this.bindings;e<r.length;e+=1){var n=r[e];t.push(n[0],n[1].serialize());}return t.push(this.result.serialize()),t};var wr=function(t,e,r){this.type=t,this.index=e,this.input=r;};wr.parse=function(t,e){if(3!==t.length)return e.error("Expected 2 arguments, but found "+(t.length-1)+" instead.");var r=e.parse(t[1],1,Lt),n=e.parse(t[2],2,Gt(e.expectedType||qt));return r&&n?new wr(n.type.itemType,r,n):null},wr.prototype.evaluate=function(t){var e=this.index.evaluate(t),r=this.input.evaluate(t);if(e<0)throw new se("Array index out of bounds: "+e+" < 0.");if(e>=r.length)throw new se("Array index out of bounds: "+e+" > "+(r.length-1)+".");if(e!==Math.floor(e))throw new se("Array index must be an integer, but found "+e+" instead.");return r[e]},wr.prototype.eachChild=function(t){t(this.index),t(this.input);},wr.prototype.outputDefined=function(){return !1},wr.prototype.serialize=function(){return ["at",this.index.serialize(),this.input.serialize()]};var _r=function(t,e){this.type=Ot,this.needle=t,this.haystack=e;};_r.parse=function(t,e){if(3!==t.length)return e.error("Expected 2 arguments, but found "+(t.length-1)+" instead.");var r,n=e.parse(t[1],1,qt),i=e.parse(t[2],2,qt);return n&&i?"boolean"!==(r=n.type).kind&&"string"!==r.kind&&"number"!==r.kind&&"null"!==r.kind&&"value"!==r.kind?e.error("Expected first argument to be of type boolean, string, number or null, but found "+Zt(n.type)+" instead"):new _r(n,i):null},_r.prototype.evaluate=function(t){var e=this.needle.evaluate(t),r=this.haystack.evaluate(t);if(null==e||!r)return !1;if(!function(t){return "boolean"==typeof t||"string"==typeof t||"number"==typeof t}(e))throw new se("Expected first argument to be of type boolean, string or number, but found "+Zt(ie(e))+" instead.");if(!function(t){return Array.isArray(t)||"string"==typeof t}(r))throw new se("Expected second argument to be of type array or string, but found "+Zt(ie(r))+" instead.");return r.indexOf(e)>=0},_r.prototype.eachChild=function(t){t(this.needle),t(this.haystack);},_r.prototype.outputDefined=function(){return !0},_r.prototype.serialize=function(){return ["in",this.needle.serialize(),this.haystack.serialize()]};var Ar=function(t,e,r,n,i,a){this.inputType=t,this.type=e,this.input=r,this.cases=n,this.outputs=i,this.otherwise=a;};Ar.parse=function(t,e){if(t.length<5)return e.error("Expected at least 4 arguments, but found only "+(t.length-1)+".");if(t.length%2!=1)return e.error("Expected an even number of arguments.");var r,n;e.expectedType&&"value"!==e.expectedType.kind&&(n=e.expectedType);for(var i={},a=[],o=2;o<t.length-1;o+=2){var s=t[o],u=t[o+1];Array.isArray(s)||(s=[s]);var l=e.concat(o);if(0===s.length)return l.error("Expected at least one branch label.");for(var p=0,c=s;p<c.length;p+=1){var h=c[p];if("number"!=typeof h&&"string"!=typeof h)return l.error("Branch labels must be numbers or strings.");if("number"==typeof h&&Math.abs(h)>Number.MAX_SAFE_INTEGER)return l.error("Branch labels must be integers no larger than "+Number.MAX_SAFE_INTEGER+".");if("number"==typeof h&&Math.floor(h)!==h)return l.error("Numeric branch labels must be integer values.");if(r){if(l.checkSubtype(r,ie(h)))return null}else r=ie(h);if(void 0!==i[String(h)])return l.error("Branch labels must be unique.");i[String(h)]=a.length;}var f=e.parse(u,o,n);if(!f)return null;n=n||f.type,a.push(f);}var y=e.parse(t[1],1,qt);if(!y)return null;var d=e.parse(t[t.length-1],t.length-1,n);return d?"value"!==y.type.kind&&e.concat(1).checkSubtype(r,y.type)?null:new Ar(r,n,y,i,a,d):null},Ar.prototype.evaluate=function(t){var e=this.input.evaluate(t);return (ie(e)===this.inputType&&this.outputs[this.cases[e]]||this.otherwise).evaluate(t)},Ar.prototype.eachChild=function(t){t(this.input),this.outputs.forEach(t),t(this.otherwise);},Ar.prototype.outputDefined=function(){return this.outputs.every((function(t){return t.outputDefined()}))&&this.otherwise.outputDefined()},Ar.prototype.serialize=function(){for(var t=this,e=["match",this.input.serialize()],r=[],n={},i=0,a=Object.keys(this.cases).sort();i<a.length;i+=1){var o=a[i];void 0===(c=n[this.cases[o]])?(n[this.cases[o]]=r.length,r.push([this.cases[o],[o]])):r[c][1].push(o);}for(var s=function(e){return "number"===t.inputType.kind?Number(e):e},u=0,l=r;u<l.length;u+=1){var p=l[u],c=p[0],h=p[1];e.push(1===h.length?s(h[0]):h.map(s)),e.push(this.outputs[outputIndex$1].serialize());}return e.push(this.otherwise.serialize()),e};var Sr=function(t,e,r){this.type=t,this.branches=e,this.otherwise=r;};function kr(t,e){return "=="===t||"!="===t?"boolean"===e.kind||"string"===e.kind||"number"===e.kind||"null"===e.kind||"value"===e.kind:"string"===e.kind||"number"===e.kind||"value"===e.kind}function Ir(t,e,r,n){return 0===n.compare(e,r)}function zr(t,e,r){var n="=="!==t&&"!="!==t;return function(){function i(t,e,r){this.type=Ot,this.lhs=t,this.rhs=e,this.collator=r,this.hasUntypedArgument="value"===t.type.kind||"value"===e.type.kind;}return i.parse=function(t,e){if(3!==t.length&&4!==t.length)return e.error("Expected two or three arguments.");var r=t[0],a=e.parse(t[1],1,qt);if(!a)return null;if(!kr(r,a.type))return e.concat(1).error('"'+r+"\" comparisons are not supported for type '"+Zt(a.type)+"'.");var o=e.parse(t[2],2,qt);if(!o)return null;if(!kr(r,o.type))return e.concat(2).error('"'+r+"\" comparisons are not supported for type '"+Zt(o.type)+"'.");if(a.type.kind!==o.type.kind&&"value"!==a.type.kind&&"value"!==o.type.kind)return e.error("Cannot compare types '"+Zt(a.type)+"' and '"+Zt(o.type)+"'.");n&&("value"===a.type.kind&&"value"!==o.type.kind?a=new le(o.type,[a]):"value"!==a.type.kind&&"value"===o.type.kind&&(o=new le(a.type,[o])));var s=null;if(4===t.length){if("string"!==a.type.kind&&"string"!==o.type.kind&&"value"!==a.type.kind&&"value"!==o.type.kind)return e.error("Cannot use collator to compare non-string types.");if(!(s=e.parse(t[3],3,Nt)))return null}return new i(a,o,s)},i.prototype.evaluate=function(i){var a=this.lhs.evaluate(i),o=this.rhs.evaluate(i);if(n&&this.hasUntypedArgument){var s=ie(a),u=ie(o);if(s.kind!==u.kind||"string"!==s.kind&&"number"!==s.kind)throw new se('Expected arguments for "'+t+'" to be (string, string) or (number, number), but found ('+s.kind+", "+u.kind+") instead.")}if(this.collator&&!n&&this.hasUntypedArgument){var l=ie(a),p=ie(o);if("string"!==l.kind||"string"!==p.kind)return e(i,a,o)}return this.collator?r(i,a,o,this.collator.evaluate(i)):e(i,a,o)},i.prototype.eachChild=function(t){t(this.lhs),t(this.rhs),this.collator&&t(this.collator);},i.prototype.outputDefined=function(){return !0},i.prototype.serialize=function(){var e=[t];return this.eachChild((function(t){e.push(t.serialize());})),e},i}()}Sr.parse=function(t,e){if(t.length<4)return e.error("Expected at least 3 arguments, but found only "+(t.length-1)+".");if(t.length%2!=0)return e.error("Expected an odd number of arguments.");var r;e.expectedType&&"value"!==e.expectedType.kind&&(r=e.expectedType);for(var n=[],i=1;i<t.length-1;i+=2){var a=e.parse(t[i],i,Ot);if(!a)return null;var o=e.parse(t[i+1],i+1,r);if(!o)return null;n.push([a,o]),r=r||o.type;}var s=e.parse(t[t.length-1],t.length-1,r);return s?new Sr(r,n,s):null},Sr.prototype.evaluate=function(t){for(var e=0,r=this.branches;e<r.length;e+=1){var n=r[e],i=n[1];if(n[0].evaluate(t))return i.evaluate(t)}return this.otherwise.evaluate(t)},Sr.prototype.eachChild=function(t){for(var e=0,r=this.branches;e<r.length;e+=1){var n=r[e],i=n[1];t(n[0]),t(i);}t(this.otherwise);},Sr.prototype.outputDefined=function(){return this.branches.every((function(t){return t[1].outputDefined()}))&&this.otherwise.outputDefined()},Sr.prototype.serialize=function(){var t=["case"];return this.eachChild((function(e){t.push(e.serialize());})),t};var Cr=zr("==",(function(t,e,r){return e===r}),Ir),Mr=zr("!=",(function(t,e,r){return e!==r}),(function(t,e,r,n){return !Ir(0,e,r,n)})),Tr=zr("<",(function(t,e,r){return e<r}),(function(t,e,r,n){return n.compare(e,r)<0})),Er=zr(">",(function(t,e,r){return e>r}),(function(t,e,r,n){return n.compare(e,r)>0})),Pr=zr("<=",(function(t,e,r){return e<=r}),(function(t,e,r,n){return n.compare(e,r)<=0})),Br=zr(">=",(function(t,e,r){return e>=r}),(function(t,e,r,n){return n.compare(e,r)>=0})),Vr=function(t,e,r,n,i){this.type=Rt,this.number=t,this.locale=e,this.currency=r,this.minFractionDigits=n,this.maxFractionDigits=i;};Vr.parse=function(t,e){if(3!==t.length)return e.error("Expected two arguments.");var r=e.parse(t[1],1,Lt);if(!r)return null;var n=t[2];if("object"!=typeof n||Array.isArray(n))return e.error("NumberFormat options argument must be an object.");var i=null;if(n.locale&&!(i=e.parse(n.locale,1,Rt)))return null;var a=null;if(n.currency&&!(a=e.parse(n.currency,1,Rt)))return null;var o=null;if(n["min-fraction-digits"]&&!(o=e.parse(n["min-fraction-digits"],1,Lt)))return null;var s=null;return n["max-fraction-digits"]&&!(s=e.parse(n["max-fraction-digits"],1,Lt))?null:new Vr(r,i,a,o,s)},Vr.prototype.evaluate=function(t){return new Intl.NumberFormat(this.locale?this.locale.evaluate(t):[],{style:this.currency?"currency":"decimal",currency:this.currency?this.currency.evaluate(t):void 0,minimumFractionDigits:this.minFractionDigits?this.minFractionDigits.evaluate(t):void 0,maximumFractionDigits:this.maxFractionDigits?this.maxFractionDigits.evaluate(t):void 0}).format(this.number.evaluate(t))},Vr.prototype.eachChild=function(t){t(this.number),this.locale&&t(this.locale),this.currency&&t(this.currency),this.minFractionDigits&&t(this.minFractionDigits),this.maxFractionDigits&&t(this.maxFractionDigits);},Vr.prototype.outputDefined=function(){return !1},Vr.prototype.serialize=function(){var t={};return this.locale&&(t.locale=this.locale.serialize()),this.currency&&(t.currency=this.currency.serialize()),this.minFractionDigits&&(t["min-fraction-digits"]=this.minFractionDigits.serialize()),this.maxFractionDigits&&(t["max-fraction-digits"]=this.maxFractionDigits.serialize()),["number-format",this.number.serialize(),t]};var Fr=function(t){this.type=Lt,this.input=t;};Fr.parse=function(t,e){if(2!==t.length)return e.error("Expected 1 argument, but found "+(t.length-1)+" instead.");var r=e.parse(t[1],1);return r?"array"!==r.type.kind&&"string"!==r.type.kind&&"value"!==r.type.kind?e.error("Expected argument of type string or array, but found "+Zt(r.type)+" instead."):new Fr(r):null},Fr.prototype.evaluate=function(t){var e=this.input.evaluate(t);if("string"==typeof e)return e.length;if(Array.isArray(e))return e.length;throw new se("Expected value to be of type string or array, but found "+Zt(ie(e))+" instead.")},Fr.prototype.eachChild=function(t){t(this.input);},Fr.prototype.outputDefined=function(){return !1},Fr.prototype.serialize=function(){var t=["length"];return this.eachChild((function(e){t.push(e.serialize());})),t};var Dr={"==":Cr,"!=":Mr,">":Er,"<":Tr,">=":Br,"<=":Pr,array:le,at:wr,boolean:le,case:Sr,coalesce:xr,collator:ve,format:pe,image:ce,in:_r,interpolate:vr,"interpolate-hcl":vr,"interpolate-lab":vr,length:Fr,let:br,literal:oe,match:Ar,number:le,"number-format":Vr,object:le,step:Ze,string:le,"to-boolean":fe,"to-color":fe,"to-number":fe,"to-string":fe,var:Ke,within:Ue};function Lr(t,e){var r=e[0],n=e[1],i=e[2],a=e[3];r=r.evaluate(t),n=n.evaluate(t),i=i.evaluate(t);var o=a?a.evaluate(t):1,s=re(r,n,i,o);if(s)throw new se(s);return new $t(r/255*o,n/255*o,i/255*o,o)}function Rr(t,e){return t in e}function Or(t,e){var r=e[t];return void 0===r?null:r}function Ur(t){return {type:t}}function jr(t){return {result:"success",value:t}}function qr(t){return {result:"error",value:t}}function Nr(t){return "data-driven"===t["property-type"]||"cross-faded-data-driven"===t["property-type"]}function Kr(t){return !!t.expression&&t.expression.parameters.indexOf("zoom")>-1}function Xr(t){return !!t.expression&&t.expression.interpolated}function Gr(t){return t instanceof Number?"number":t instanceof String?"string":t instanceof Boolean?"boolean":Array.isArray(t)?"array":null===t?"null":typeof t}function Zr(t){return "object"==typeof t&&null!==t&&!Array.isArray(t)}function Jr(t){return t}function Hr(t,e,r){return void 0!==t?t:void 0!==e?e:void 0!==r?r:void 0}function Yr(t,e,r,n,i){return Hr(typeof r===i?n[r]:void 0,t.default,e.default)}function $r(t,e,r){if("number"!==Gr(r))return Hr(t.default,e.default);var n=t.stops.length;if(1===n)return t.stops[0][1];if(r<=t.stops[0][0])return t.stops[0][1];if(r>=t.stops[n-1][0])return t.stops[n-1][1];var i=Ge(t.stops.map((function(t){return t[0]})),r);return t.stops[i][1]}function Wr(t,e,r){var n=void 0!==t.base?t.base:1;if("number"!==Gr(r))return Hr(t.default,e.default);var i=t.stops.length;if(1===i)return t.stops[0][1];if(r<=t.stops[0][0])return t.stops[0][1];if(r>=t.stops[i-1][0])return t.stops[i-1][1];var a=Ge(t.stops.map((function(t){return t[0]})),r),o=function(t,e,r,n){var i=n-r,a=t-r;return 0===i?0:1===e?a/i:(Math.pow(e,a)-1)/(Math.pow(e,i)-1)}(r,n,t.stops[a][0],t.stops[a+1][0]),s=t.stops[a][1],u=t.stops[a+1][1],l=$e[e.type]||Jr;if(t.colorSpace&&"rgb"!==t.colorSpace){var p=mr[t.colorSpace];l=function(t,e){return p.reverse(p.interpolate(p.forward(t),p.forward(e),o))};}return "function"==typeof s.evaluate?{evaluate:function(){for(var t=[],e=arguments.length;e--;)t[e]=arguments[e];var r=s.evaluate.apply(void 0,t),n=u.evaluate.apply(void 0,t);if(void 0!==r&&void 0!==n)return l(r,n,o)}}:l(s,u,o)}function Qr(t,e,r){return "color"===e.type?r=$t.parse(r):"formatted"===e.type?r=te.fromString(r.toString()):"resolvedImage"===e.type?r=ee.fromString(r.toString()):Gr(r)===e.type||"enum"===e.type&&e.values[r]||(r=void 0),Hr(r,t.default,e.default)}me.register(Dr,{error:[{kind:"error"},[Rt],function(t,e){throw new se(e[0].evaluate(t))}],typeof:[Rt,[qt],function(t,e){return Zt(ie(e[0].evaluate(t)))}],"to-rgba":[Gt(Lt,4),[Ut],function(t,e){return e[0].evaluate(t).toArray()}],rgb:[Ut,[Lt,Lt,Lt],Lr],rgba:[Ut,[Lt,Lt,Lt,Lt],Lr],has:{type:Ot,overloads:[[[Rt],function(t,e){return Rr(e[0].evaluate(t),t.properties())}],[[Rt,jt],function(t,e){var r=e[1];return Rr(e[0].evaluate(t),r.evaluate(t))}]]},get:{type:qt,overloads:[[[Rt],function(t,e){return Or(e[0].evaluate(t),t.properties())}],[[Rt,jt],function(t,e){var r=e[1];return Or(e[0].evaluate(t),r.evaluate(t))}]]},"feature-state":[qt,[Rt],function(t,e){return Or(e[0].evaluate(t),t.featureState||{})}],properties:[jt,[],function(t){return t.properties()}],"geometry-type":[Rt,[],function(t){return t.geometryType()}],id:[qt,[],function(t){return t.id()}],zoom:[Lt,[],function(t){return t.globals.zoom}],"heatmap-density":[Lt,[],function(t){return t.globals.heatmapDensity||0}],"line-progress":[Lt,[],function(t){return t.globals.lineProgress||0}],accumulated:[qt,[],function(t){return void 0===t.globals.accumulated?null:t.globals.accumulated}],"+":[Lt,Ur(Lt),function(t,e){for(var r=0,n=0,i=e;n<i.length;n+=1)r+=i[n].evaluate(t);return r}],"*":[Lt,Ur(Lt),function(t,e){for(var r=1,n=0,i=e;n<i.length;n+=1)r*=i[n].evaluate(t);return r}],"-":{type:Lt,overloads:[[[Lt,Lt],function(t,e){var r=e[1];return e[0].evaluate(t)-r.evaluate(t)}],[[Lt],function(t,e){return -e[0].evaluate(t)}]]},"/":[Lt,[Lt,Lt],function(t,e){var r=e[1];return e[0].evaluate(t)/r.evaluate(t)}],"%":[Lt,[Lt,Lt],function(t,e){var r=e[1];return e[0].evaluate(t)%r.evaluate(t)}],ln2:[Lt,[],function(){return Math.LN2}],pi:[Lt,[],function(){return Math.PI}],e:[Lt,[],function(){return Math.E}],"^":[Lt,[Lt,Lt],function(t,e){var r=e[1];return Math.pow(e[0].evaluate(t),r.evaluate(t))}],sqrt:[Lt,[Lt],function(t,e){return Math.sqrt(e[0].evaluate(t))}],log10:[Lt,[Lt],function(t,e){return Math.log(e[0].evaluate(t))/Math.LN10}],ln:[Lt,[Lt],function(t,e){return Math.log(e[0].evaluate(t))}],log2:[Lt,[Lt],function(t,e){return Math.log(e[0].evaluate(t))/Math.LN2}],sin:[Lt,[Lt],function(t,e){return Math.sin(e[0].evaluate(t))}],cos:[Lt,[Lt],function(t,e){return Math.cos(e[0].evaluate(t))}],tan:[Lt,[Lt],function(t,e){return Math.tan(e[0].evaluate(t))}],asin:[Lt,[Lt],function(t,e){return Math.asin(e[0].evaluate(t))}],acos:[Lt,[Lt],function(t,e){return Math.acos(e[0].evaluate(t))}],atan:[Lt,[Lt],function(t,e){return Math.atan(e[0].evaluate(t))}],min:[Lt,Ur(Lt),function(t,e){return Math.min.apply(Math,e.map((function(e){return e.evaluate(t)})))}],max:[Lt,Ur(Lt),function(t,e){return Math.max.apply(Math,e.map((function(e){return e.evaluate(t)})))}],abs:[Lt,[Lt],function(t,e){return Math.abs(e[0].evaluate(t))}],round:[Lt,[Lt],function(t,e){var r=e[0].evaluate(t);return r<0?-Math.round(-r):Math.round(r)}],floor:[Lt,[Lt],function(t,e){return Math.floor(e[0].evaluate(t))}],ceil:[Lt,[Lt],function(t,e){return Math.ceil(e[0].evaluate(t))}],"filter-==":[Ot,[Rt,qt],function(t,e){var r=e[0],n=e[1];return t.properties()[r.value]===n.value}],"filter-id-==":[Ot,[qt],function(t,e){var r=e[0];return t.id()===r.value}],"filter-type-==":[Ot,[Rt],function(t,e){var r=e[0];return t.geometryType()===r.value}],"filter-<":[Ot,[Rt,qt],function(t,e){var r=e[0],n=e[1],i=t.properties()[r.value],a=n.value;return typeof i==typeof a&&i<a}],"filter-id-<":[Ot,[qt],function(t,e){var r=e[0],n=t.id(),i=r.value;return typeof n==typeof i&&n<i}],"filter->":[Ot,[Rt,qt],function(t,e){var r=e[0],n=e[1],i=t.properties()[r.value],a=n.value;return typeof i==typeof a&&i>a}],"filter-id->":[Ot,[qt],function(t,e){var r=e[0],n=t.id(),i=r.value;return typeof n==typeof i&&n>i}],"filter-<=":[Ot,[Rt,qt],function(t,e){var r=e[0],n=e[1],i=t.properties()[r.value],a=n.value;return typeof i==typeof a&&i<=a}],"filter-id-<=":[Ot,[qt],function(t,e){var r=e[0],n=t.id(),i=r.value;return typeof n==typeof i&&n<=i}],"filter->=":[Ot,[Rt,qt],function(t,e){var r=e[0],n=e[1],i=t.properties()[r.value],a=n.value;return typeof i==typeof a&&i>=a}],"filter-id->=":[Ot,[qt],function(t,e){var r=e[0],n=t.id(),i=r.value;return typeof n==typeof i&&n>=i}],"filter-has":[Ot,[qt],function(t,e){return e[0].value in t.properties()}],"filter-has-id":[Ot,[],function(t){return null!==t.id()&&void 0!==t.id()}],"filter-type-in":[Ot,[Gt(Rt)],function(t,e){return e[0].value.indexOf(t.geometryType())>=0}],"filter-id-in":[Ot,[Gt(qt)],function(t,e){return e[0].value.indexOf(t.id())>=0}],"filter-in-small":[Ot,[Rt,Gt(qt)],function(t,e){var r=e[0];return e[1].value.indexOf(t.properties()[r.value])>=0}],"filter-in-large":[Ot,[Rt,Gt(qt)],function(t,e){var r=e[0],n=e[1];return function(t,e,r,n){for(;r<=n;){var i=r+n>>1;if(e[i]===t)return !0;e[i]>t?n=i-1:r=i+1;}return !1}(t.properties()[r.value],n.value,0,n.value.length-1)}],all:{type:Ot,overloads:[[[Ot,Ot],function(t,e){var r=e[1];return e[0].evaluate(t)&&r.evaluate(t)}],[Ur(Ot),function(t,e){for(var r=0,n=e;r<n.length;r+=1)if(!n[r].evaluate(t))return !1;return !0}]]},any:{type:Ot,overloads:[[[Ot,Ot],function(t,e){var r=e[1];return e[0].evaluate(t)||r.evaluate(t)}],[Ur(Ot),function(t,e){for(var r=0,n=e;r<n.length;r+=1)if(n[r].evaluate(t))return !0;return !1}]]},"!":[Ot,[Ot],function(t,e){return !e[0].evaluate(t)}],"is-supported-script":[Ot,[Rt],function(t,e){var r=t.globals&&t.globals.isSupportedScript;return !r||r(e[0].evaluate(t))}],upcase:[Rt,[Rt],function(t,e){return e[0].evaluate(t).toUpperCase()}],downcase:[Rt,[Rt],function(t,e){return e[0].evaluate(t).toLowerCase()}],concat:[Rt,Ur(qt),function(t,e){return e.map((function(e){return ae(e.evaluate(t))})).join("")}],"resolved-locale":[Rt,[Nt],function(t,e){return e[0].evaluate(t).resolvedLocale()}]});var tn=function(t,e){this.expression=t,this._warningHistory={},this._evaluator=new de,this._defaultValue=e?function(t){return "color"===t.type&&Zr(t.default)?new $t(0,0,0,0):"color"===t.type?$t.parse(t.default)||null:void 0===t.default?null:t.default}(e):null,this._enumValues=e&&"enum"===e.type?e.values:null;};function en(t){return Array.isArray(t)&&t.length>0&&"string"==typeof t[0]&&t[0]in Dr}function rn(t,e){var r=new Xe(Dr,[],e?function(t){var e={color:Ut,string:Rt,number:Lt,enum:Rt,boolean:Ot,formatted:Kt,resolvedImage:Xt};return "array"===t.type?Gt(e[t.value]||qt,t.length):e[t.type]}(e):void 0),n=r.parse(t,void 0,void 0,void 0,e&&"string"===e.type?{typeAnnotation:"coerce"}:void 0);return n?jr(new tn(n,e)):qr(r.errors)}tn.prototype.evaluateWithoutErrorHandling=function(t,e,r,n,i,a){return this._evaluator.globals=t,this._evaluator.feature=e,this._evaluator.featureState=r,this._evaluator.canonical=n,this._evaluator.availableImages=i||null,this._evaluator.formattedSection=a,this.expression.evaluate(this._evaluator)},tn.prototype.evaluate=function(t,e,r,n,i,a){this._evaluator.globals=t,this._evaluator.feature=e||null,this._evaluator.featureState=r||null,this._evaluator.canonical=n,this._evaluator.availableImages=i||null,this._evaluator.formattedSection=a||null;try{var o=this.expression.evaluate(this._evaluator);if(null==o||"number"==typeof o&&o!=o)return this._defaultValue;if(this._enumValues&&!(o in this._enumValues))throw new se("Expected value to be one of "+Object.keys(this._enumValues).map((function(t){return JSON.stringify(t)})).join(", ")+", but found "+JSON.stringify(o)+" instead.");return o}catch(t){return this._warningHistory[t.message]||(this._warningHistory[t.message]=!0,"undefined"!=typeof console&&console.warn(t.message)),this._defaultValue}};var nn=function(t,e){this.kind=t,this._styleExpression=e,this.isStateDependent="constant"!==t&&!qe(e.expression);};nn.prototype.evaluateWithoutErrorHandling=function(t,e,r,n,i,a){return this._styleExpression.evaluateWithoutErrorHandling(t,e,r,n,i,a)},nn.prototype.evaluate=function(t,e,r,n,i,a){return this._styleExpression.evaluate(t,e,r,n,i,a)};var an=function(t,e,r,n){this.kind=t,this.zoomStops=r,this._styleExpression=e,this.isStateDependent="camera"!==t&&!qe(e.expression),this.interpolationType=n;};function on(t,e){if("error"===(t=rn(t,e)).result)return t;var r=t.value.expression,n=je(r);if(!n&&!Nr(e))return qr([new Vt("","data expressions not supported")]);var i=Ne(r,["zoom"]);if(!i&&!Kr(e))return qr([new Vt("","zoom expressions not supported")]);var a=function t(e){var r=null;if(e instanceof br)r=t(e.result);else if(e instanceof xr)for(var n=0,i=e.args;n<i.length&&!(r=t(i[n]));n+=1);else(e instanceof Ze||e instanceof vr)&&e.input instanceof me&&"zoom"===e.input.name&&(r=e);return r instanceof Vt?r:(e.eachChild((function(e){var n=t(e);n instanceof Vt?r=n:!r&&n?r=new Vt("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.'):r&&n&&r!==n&&(r=new Vt("",'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));})),r)}(r);return a||i?a instanceof Vt?qr([a]):a instanceof vr&&!Xr(e)?qr([new Vt("",'"interpolate" expressions cannot be used with this property')]):jr(a?new an(n?"camera":"composite",t.value,a.labels,a instanceof vr?a.interpolation:void 0):new nn(n?"constant":"source",t.value)):qr([new Vt("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')])}an.prototype.evaluateWithoutErrorHandling=function(t,e,r,n,i,a){return this._styleExpression.evaluateWithoutErrorHandling(t,e,r,n,i,a)},an.prototype.evaluate=function(t,e,r,n,i,a){return this._styleExpression.evaluate(t,e,r,n,i,a)},an.prototype.interpolationFactor=function(t,e,r){return this.interpolationType?vr.interpolationFactor(this.interpolationType,t,e,r):0};var sn=function(t,e){this._parameters=t,this._specification=e,Et(this,function t(e,r){var n,i,a,o="color"===r.type,s=e.stops&&"object"==typeof e.stops[0][0],u=s||!(s||void 0!==e.property),l=e.type||(Xr(r)?"exponential":"interval");if(o&&((e=Et({},e)).stops&&(e.stops=e.stops.map((function(t){return [t[0],$t.parse(t[1])]}))),e.default=$t.parse(e.default?e.default:r.default)),e.colorSpace&&"rgb"!==e.colorSpace&&!mr[e.colorSpace])throw new Error("Unknown color space: "+e.colorSpace);if("exponential"===l)n=Wr;else if("interval"===l)n=$r;else if("categorical"===l){n=Yr,i=Object.create(null);for(var p=0,c=e.stops;p<c.length;p+=1){var h=c[p];i[h[0]]=h[1];}a=typeof e.stops[0][0];}else{if("identity"!==l)throw new Error('Unknown function type "'+l+'"');n=Qr;}if(s){for(var f={},y=[],d=0;d<e.stops.length;d++){var m=e.stops[d],v=m[0].zoom;void 0===f[v]&&(f[v]={zoom:v,type:e.type,property:e.property,default:e.default,stops:[]},y.push(v)),f[v].stops.push([m[0].value,m[1]]);}for(var g=[],x=0,b=y;x<b.length;x+=1){var w=b[x];g.push([f[w].zoom,t(f[w],r)]);}var _={name:"linear"};return {kind:"composite",interpolationType:_,interpolationFactor:vr.interpolationFactor.bind(void 0,_),zoomStops:g.map((function(t){return t[0]})),evaluate:function(t,n){var i=t.zoom;return Wr({stops:g,base:e.base},r,i).evaluate(i,n)}}}if(u){var A="exponential"===l?{name:"exponential",base:void 0!==e.base?e.base:1}:null;return {kind:"camera",interpolationType:A,interpolationFactor:vr.interpolationFactor.bind(void 0,A),zoomStops:e.stops.map((function(t){return t[0]})),evaluate:function(t){return n(e,r,t.zoom,i,a)}}}return {kind:"source",evaluate:function(t,o){var s=o&&o.properties?o.properties[e.property]:void 0;return void 0===s?Hr(e.default,r.default):n(e,r,s,i,a)}}}(this._parameters,this._specification));};function un(t){var e=t.key,r=t.value,n=t.valueSpec||{},i=t.objectElementValidators||{},a=t.style,o=t.styleSpec,s=[],u=Gr(r);if("object"!==u)return [new Mt(e,r,"object expected, "+u+" found")];for(var l in r){var p=l.split(".")[0],c=n[p]||n["*"],h=void 0;if(i[p])h=i[p];else if(n[p])h=Bn;else if(i["*"])h=i["*"];else{if(!n["*"]){s.push(new Mt(e,r[l],'unknown property "'+l+'"'));continue}h=Bn;}s=s.concat(h({key:(e?e+".":e)+l,value:r[l],valueSpec:c,style:a,styleSpec:o,object:r,objectKey:l},r));}for(var f in n)i[f]||n[f].required&&void 0===n[f].default&&void 0===r[f]&&s.push(new Mt(e,r,'missing required property "'+f+'"'));return s}function ln(t){var e=t.value,r=t.valueSpec,n=t.style,i=t.styleSpec,a=t.key,o=t.arrayElementValidator||Bn;if("array"!==Gr(e))return [new Mt(a,e,"array expected, "+Gr(e)+" found")];if(r.length&&e.length!==r.length)return [new Mt(a,e,"array length "+r.length+" expected, length "+e.length+" found")];if(r["min-length"]&&e.length<r["min-length"])return [new Mt(a,e,"array length at least "+r["min-length"]+" expected, length "+e.length+" found")];var s={type:r.value,values:r.values};i.$version<7&&(s.function=r.function),"object"===Gr(r.value)&&(s=r.value);for(var u=[],l=0;l<e.length;l++)u=u.concat(o({array:e,arrayIndex:l,value:e[l],valueSpec:s,style:n,styleSpec:i,key:a+"["+l+"]"}));return u}function pn(t){var e=t.key,r=t.value,n=t.valueSpec,i=Gr(r);return "number"===i&&r!=r&&(i="NaN"),"number"!==i?[new Mt(e,r,"number expected, "+i+" found")]:"minimum"in n&&r<n.minimum?[new Mt(e,r,r+" is less than the minimum value "+n.minimum)]:"maximum"in n&&r>n.maximum?[new Mt(e,r,r+" is greater than the maximum value "+n.maximum)]:[]}function cn(t){var e,r,n,i=t.valueSpec,a=Pt(t.value.type),o={},s="categorical"!==a&&void 0===t.value.property,u=!s,l="array"===Gr(t.value.stops)&&"array"===Gr(t.value.stops[0])&&"object"===Gr(t.value.stops[0][0]),p=un({key:t.key,value:t.value,valueSpec:t.styleSpec.function,style:t.style,styleSpec:t.styleSpec,objectElementValidators:{stops:function(t){if("identity"===a)return [new Mt(t.key,t.value,'identity function may not have a "stops" property')];var e=[],r=t.value;return e=e.concat(ln({key:t.key,value:r,valueSpec:t.valueSpec,style:t.style,styleSpec:t.styleSpec,arrayElementValidator:c})),"array"===Gr(r)&&0===r.length&&e.push(new Mt(t.key,r,"array must have at least one stop")),e},default:function(t){return Bn({key:t.key,value:t.value,valueSpec:i,style:t.style,styleSpec:t.styleSpec})}}});return "identity"===a&&s&&p.push(new Mt(t.key,t.value,'missing required property "property"')),"identity"===a||t.value.stops||p.push(new Mt(t.key,t.value,'missing required property "stops"')),"exponential"===a&&t.valueSpec.expression&&!Xr(t.valueSpec)&&p.push(new Mt(t.key,t.value,"exponential functions not supported")),t.styleSpec.$version>=8&&(u&&!Nr(t.valueSpec)?p.push(new Mt(t.key,t.value,"property functions not supported")):s&&!Kr(t.valueSpec)&&p.push(new Mt(t.key,t.value,"zoom functions not supported"))),"categorical"!==a&&!l||void 0!==t.value.property||p.push(new Mt(t.key,t.value,'"property" property is required')),p;function c(t){var e=[],a=t.value,s=t.key;if("array"!==Gr(a))return [new Mt(s,a,"array expected, "+Gr(a)+" found")];if(2!==a.length)return [new Mt(s,a,"array length 2 expected, length "+a.length+" found")];if(l){if("object"!==Gr(a[0]))return [new Mt(s,a,"object expected, "+Gr(a[0])+" found")];if(void 0===a[0].zoom)return [new Mt(s,a,"object stop key must have zoom")];if(void 0===a[0].value)return [new Mt(s,a,"object stop key must have value")];if(n&&n>Pt(a[0].zoom))return [new Mt(s,a[0].zoom,"stop zoom values must appear in ascending order")];Pt(a[0].zoom)!==n&&(n=Pt(a[0].zoom),r=void 0,o={}),e=e.concat(un({key:s+"[0]",value:a[0],valueSpec:{zoom:{}},style:t.style,styleSpec:t.styleSpec,objectElementValidators:{zoom:pn,value:h}}));}else e=e.concat(h({key:s+"[0]",value:a[0],valueSpec:{},style:t.style,styleSpec:t.styleSpec},a));return en(Bt(a[1]))?e.concat([new Mt(s+"[1]",a[1],"expressions are not allowed in function stops.")]):e.concat(Bn({key:s+"[1]",value:a[1],valueSpec:i,style:t.style,styleSpec:t.styleSpec}))}function h(t,n){var s=Gr(t.value),u=Pt(t.value),l=null!==t.value?t.value:n;if(e){if(s!==e)return [new Mt(t.key,l,s+" stop domain type must match previous stop domain type "+e)]}else e=s;if("number"!==s&&"string"!==s&&"boolean"!==s)return [new Mt(t.key,l,"stop domain value must be a number, string, or boolean")];if("number"!==s&&"categorical"!==a){var p="number expected, "+s+" found";return Nr(i)&&void 0===a&&(p+='\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),[new Mt(t.key,l,p)]}return "categorical"!==a||"number"!==s||isFinite(u)&&Math.floor(u)===u?"categorical"!==a&&"number"===s&&void 0!==r&&u<r?[new Mt(t.key,l,"stop domain values must appear in ascending order")]:(r=u,"categorical"===a&&u in o?[new Mt(t.key,l,"stop domain values must be unique")]:(o[u]=!0,[])):[new Mt(t.key,l,"integer expected, found "+u)]}}function hn(t){var e=("property"===t.expressionContext?on:rn)(Bt(t.value),t.valueSpec);if("error"===e.result)return e.value.map((function(e){return new Mt(""+t.key+e.key,t.value,e.message)}));var r=e.value.expression||e.value._styleExpression.expression;if("property"===t.expressionContext&&"text-font"===t.propertyKey&&!r.outputDefined())return [new Mt(t.key,t.value,'Invalid data expression for "'+t.propertyKey+'". Output values must be contained as literals within the expression.')];if("property"===t.expressionContext&&"layout"===t.propertyType&&!qe(r))return [new Mt(t.key,t.value,'"feature-state" data expressions are not supported with layout properties.')];if("filter"===t.expressionContext&&!qe(r))return [new Mt(t.key,t.value,'"feature-state" data expressions are not supported with filters.')];if(t.expressionContext&&0===t.expressionContext.indexOf("cluster")){if(!Ne(r,["zoom","feature-state"]))return [new Mt(t.key,t.value,'"zoom" and "feature-state" expressions are not supported with cluster properties.')];if("cluster-initial"===t.expressionContext&&!je(r))return [new Mt(t.key,t.value,"Feature data expressions are not supported with initial expression part of cluster properties.")]}return []}function fn(t){var e=t.key,r=t.value,n=t.valueSpec,i=[];return Array.isArray(n.values)?-1===n.values.indexOf(Pt(r))&&i.push(new Mt(e,r,"expected one of ["+n.values.join(", ")+"], "+JSON.stringify(r)+" found")):-1===Object.keys(n.values).indexOf(Pt(r))&&i.push(new Mt(e,r,"expected one of ["+Object.keys(n.values).join(", ")+"], "+JSON.stringify(r)+" found")),i}function yn(t){if(!0===t||!1===t)return !0;if(!Array.isArray(t)||0===t.length)return !1;switch(t[0]){case"has":return t.length>=2&&"$id"!==t[1]&&"$type"!==t[1];case"in":return t.length>=3&&("string"!=typeof t[1]||Array.isArray(t[2]));case"!in":case"!has":case"none":return !1;case"==":case"!=":case">":case">=":case"<":case"<=":return 3!==t.length||Array.isArray(t[1])||Array.isArray(t[2]);case"any":case"all":for(var e=0,r=t.slice(1);e<r.length;e+=1){var n=r[e];if(!yn(n)&&"boolean"!=typeof n)return !1}return !0;default:return !0}}sn.deserialize=function(t){return new sn(t._parameters,t._specification)},sn.serialize=function(t){return {_parameters:t._parameters,_specification:t._specification}};var dn={type:"boolean",default:!1,transition:!1,"property-type":"data-driven",expression:{interpolated:!1,parameters:["zoom","feature"]}};function mn(t){if(null==t)return {filter:function(){return !0},needGeometry:!1};yn(t)||(t=gn(t));var e=rn(t,dn);if("error"===e.result)throw new Error(e.value.map((function(t){return t.key+": "+t.message})).join(", "));return {filter:function(t,r,n){return e.value.evaluate(t,r,{},n)},needGeometry:Array.isArray(t)&&0!==t.length&&"within"===t[0]}}function vn(t,e){return t<e?-1:t>e?1:0}function gn(t){if(!t)return !0;var e,r=t[0];return t.length<=1?"any"!==r:"=="===r?xn(t[1],t[2],"=="):"!="===r?_n(xn(t[1],t[2],"==")):"<"===r||">"===r||"<="===r||">="===r?xn(t[1],t[2],r):"any"===r?(e=t.slice(1),["any"].concat(e.map(gn))):"all"===r?["all"].concat(t.slice(1).map(gn)):"none"===r?["all"].concat(t.slice(1).map(gn).map(_n)):"in"===r?bn(t[1],t.slice(2)):"!in"===r?_n(bn(t[1],t.slice(2))):"has"===r?wn(t[1]):"!has"!==r||_n(wn(t[1]))}function xn(t,e,r){switch(t){case"$type":return ["filter-type-"+r,e];case"$id":return ["filter-id-"+r,e];default:return ["filter-"+r,t,e]}}function bn(t,e){if(0===e.length)return !1;switch(t){case"$type":return ["filter-type-in",["literal",e]];case"$id":return ["filter-id-in",["literal",e]];default:return e.length>200&&!e.some((function(t){return typeof t!=typeof e[0]}))?["filter-in-large",t,["literal",e.sort(vn)]]:["filter-in-small",t,["literal",e]]}}function wn(t){switch(t){case"$type":return !0;case"$id":return ["filter-has-id"];default:return ["filter-has",t]}}function _n(t){return ["!",t]}function An(t){return yn(Bt(t.value))?hn(Et({},t,{expressionContext:"filter",valueSpec:{value:"boolean"}})):function t(e){var r=e.value,n=e.key;if("array"!==Gr(r))return [new Mt(n,r,"array expected, "+Gr(r)+" found")];var i,a=e.styleSpec,o=[];if(r.length<1)return [new Mt(n,r,"filter array must have at least 1 element")];switch(o=o.concat(fn({key:n+"[0]",value:r[0],valueSpec:a.filter_operator,style:e.style,styleSpec:e.styleSpec})),Pt(r[0])){case"<":case"<=":case">":case">=":r.length>=2&&"$type"===Pt(r[1])&&o.push(new Mt(n,r,'"$type" cannot be use with operator "'+r[0]+'"'));case"==":case"!=":3!==r.length&&o.push(new Mt(n,r,'filter array for operator "'+r[0]+'" must have 3 elements'));case"in":case"!in":r.length>=2&&"string"!==(i=Gr(r[1]))&&o.push(new Mt(n+"[1]",r[1],"string expected, "+i+" found"));for(var s=2;s<r.length;s++)i=Gr(r[s]),"$type"===Pt(r[1])?o=o.concat(fn({key:n+"["+s+"]",value:r[s],valueSpec:a.geometry_type,style:e.style,styleSpec:e.styleSpec})):"string"!==i&&"number"!==i&&"boolean"!==i&&o.push(new Mt(n+"["+s+"]",r[s],"string, number, or boolean expected, "+i+" found"));break;case"any":case"all":case"none":for(var u=1;u<r.length;u++)o=o.concat(t({key:n+"["+u+"]",value:r[u],style:e.style,styleSpec:e.styleSpec}));break;case"has":case"!has":i=Gr(r[1]),2!==r.length?o.push(new Mt(n,r,'filter array for "'+r[0]+'" operator must have 2 elements')):"string"!==i&&o.push(new Mt(n+"[1]",r[1],"string expected, "+i+" found"));}return o}(t)}function Sn(t,e){var r=t.key,n=t.style,i=t.styleSpec,a=t.value,o=t.objectKey,s=i[e+"_"+t.layerType];if(!s)return [];var u=o.match(/^(.*)-transition$/);if("paint"===e&&u&&s[u[1]]&&s[u[1]].transition)return Bn({key:r,value:a,valueSpec:i.transition,style:n,styleSpec:i});var l,p=t.valueSpec||s[o];if(!p)return [new Mt(r,a,'unknown property "'+o+'"')];if("string"===Gr(a)&&Nr(p)&&!p.tokens&&(l=/^{([^}]+)}$/.exec(a)))return [new Mt(r,a,'"'+o+'" does not support interpolation syntax\nUse an identity property function instead: `{ "type": "identity", "property": '+JSON.stringify(l[1])+" }`.")];var c=[];return "symbol"===t.layerType&&("text-field"===o&&n&&!n.glyphs&&c.push(new Mt(r,a,'use of "text-field" requires a style "glyphs" property')),"text-font"===o&&Zr(Bt(a))&&"identity"===Pt(a.type)&&c.push(new Mt(r,a,'"text-font" does not support identity functions'))),c.concat(Bn({key:t.key,value:a,valueSpec:p,style:n,styleSpec:i,expressionContext:"property",propertyType:e,propertyKey:o}))}function kn(t){return Sn(t,"paint")}function In(t){return Sn(t,"layout")}function zn(t){var e=[],r=t.value,n=t.key,i=t.style,a=t.styleSpec;r.type||r.ref||e.push(new Mt(n,r,'either "type" or "ref" is required'));var o,s=Pt(r.type),u=Pt(r.ref);if(r.id)for(var l=Pt(r.id),p=0;p<t.arrayIndex;p++){var c=i.layers[p];Pt(c.id)===l&&e.push(new Mt(n,r.id,'duplicate layer id "'+r.id+'", previously used at line '+c.id.__line__));}if("ref"in r)["type","source","source-layer","filter","layout"].forEach((function(t){t in r&&e.push(new Mt(n,r[t],'"'+t+'" is prohibited for ref layers'));})),i.layers.forEach((function(t){Pt(t.id)===u&&(o=t);})),o?o.ref?e.push(new Mt(n,r.ref,"ref cannot reference another ref layer")):s=Pt(o.type):e.push(new Mt(n,r.ref,'ref layer "'+u+'" not found'));else if("background"!==s)if(r.source){var h=i.sources&&i.sources[r.source],f=h&&Pt(h.type);h?"vector"===f&&"raster"===s?e.push(new Mt(n,r.source,'layer "'+r.id+'" requires a raster source')):"raster"===f&&"raster"!==s?e.push(new Mt(n,r.source,'layer "'+r.id+'" requires a vector source')):"vector"!==f||r["source-layer"]?"raster-dem"===f&&"hillshade"!==s?e.push(new Mt(n,r.source,"raster-dem source can only be used with layer type 'hillshade'.")):"line"!==s||!r.paint||!r.paint["line-gradient"]||"geojson"===f&&h.lineMetrics||e.push(new Mt(n,r,'layer "'+r.id+'" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.')):e.push(new Mt(n,r,'layer "'+r.id+'" must specify a "source-layer"')):e.push(new Mt(n,r.source,'source "'+r.source+'" not found'));}else e.push(new Mt(n,r,'missing required property "source"'));return e=e.concat(un({key:n,value:r,valueSpec:a.layer,style:t.style,styleSpec:t.styleSpec,objectElementValidators:{"*":function(){return []},type:function(){return Bn({key:n+".type",value:r.type,valueSpec:a.layer.type,style:t.style,styleSpec:t.styleSpec,object:r,objectKey:"type"})},filter:An,layout:function(t){return un({layer:r,key:t.key,value:t.value,style:t.style,styleSpec:t.styleSpec,objectElementValidators:{"*":function(t){return In(Et({layerType:s},t))}}})},paint:function(t){return un({layer:r,key:t.key,value:t.value,style:t.style,styleSpec:t.styleSpec,objectElementValidators:{"*":function(t){return kn(Et({layerType:s},t))}}})}}}))}function Cn(t){var e=t.value,r=t.key,n=Gr(e);return "string"!==n?[new Mt(r,e,"string expected, "+n+" found")]:[]}var Mn={promoteId:function(t){var e=t.key,r=t.value;if("string"===Gr(r))return Cn({key:e,value:r});var n=[];for(var i in r)n.push.apply(n,Cn({key:e+"."+i,value:r[i]}));return n}};function Tn(t){var e=t.value,r=t.key,n=t.styleSpec,i=t.style;if(!e.type)return [new Mt(r,e,'"type" is required')];var a,o=Pt(e.type);switch(o){case"vector":case"raster":case"raster-dem":return un({key:r,value:e,valueSpec:n["source_"+o.replace("-","_")],style:t.style,styleSpec:n,objectElementValidators:Mn});case"geojson":if(a=un({key:r,value:e,valueSpec:n.source_geojson,style:i,styleSpec:n,objectElementValidators:Mn}),e.cluster)for(var s in e.clusterProperties){var u=e.clusterProperties[s],l=u[0],p="string"==typeof l?[l,["accumulated"],["get",s]]:l;a.push.apply(a,hn({key:r+"."+s+".map",value:u[1],expressionContext:"cluster-map"})),a.push.apply(a,hn({key:r+"."+s+".reduce",value:p,expressionContext:"cluster-reduce"}));}return a;case"video":return un({key:r,value:e,valueSpec:n.source_video,style:i,styleSpec:n});case"image":return un({key:r,value:e,valueSpec:n.source_image,style:i,styleSpec:n});case"canvas":return [new Mt(r,null,"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.","source.canvas")];default:return fn({key:r+".type",value:e.type,valueSpec:{values:["vector","raster","raster-dem","geojson","video","image"]},style:i,styleSpec:n})}}function En(t){var e=t.value,r=t.styleSpec,n=r.light,i=t.style,a=[],o=Gr(e);if(void 0===e)return a;if("object"!==o)return a.concat([new Mt("light",e,"object expected, "+o+" found")]);for(var s in e){var u=s.match(/^(.*)-transition$/);a=a.concat(u&&n[u[1]]&&n[u[1]].transition?Bn({key:s,value:e[s],valueSpec:r.transition,style:i,styleSpec:r}):n[s]?Bn({key:s,value:e[s],valueSpec:n[s],style:i,styleSpec:r}):[new Mt(s,e[s],'unknown property "'+s+'"')]);}return a}var Pn={"*":function(){return []},array:ln,boolean:function(t){var e=t.value,r=t.key,n=Gr(e);return "boolean"!==n?[new Mt(r,e,"boolean expected, "+n+" found")]:[]},number:pn,color:function(t){var e=t.key,r=t.value,n=Gr(r);return "string"!==n?[new Mt(e,r,"color expected, "+n+" found")]:null===Yt(r)?[new Mt(e,r,'color expected, "'+r+'" found')]:[]},constants:Tt,enum:fn,filter:An,function:cn,layer:zn,object:un,source:Tn,light:En,string:Cn,formatted:function(t){return 0===Cn(t).length?[]:hn(t)},resolvedImage:function(t){return 0===Cn(t).length?[]:hn(t)}};function Bn(t){var e=t.value,r=t.valueSpec,n=t.styleSpec;return r.expression&&Zr(Pt(e))?cn(t):r.expression&&en(Bt(e))?hn(t):r.type&&Pn[r.type]?Pn[r.type](t):un(Et({},t,{valueSpec:r.type?n[r.type]:r}))}function Vn(t){var e=t.value,r=t.key,n=Cn(t);return n.length?n:(-1===e.indexOf("{fontstack}")&&n.push(new Mt(r,e,'"glyphs" url must include a "{fontstack}" token')),-1===e.indexOf("{range}")&&n.push(new Mt(r,e,'"glyphs" url must include a "{range}" token')),n)}function Fn(t,e){void 0===e&&(e=Ct);var r=[];return r=r.concat(Bn({key:"",value:t,valueSpec:e.$root,styleSpec:e,style:t,objectElementValidators:{glyphs:Vn,"*":function(){return []}}})),t.constants&&(r=r.concat(Tt({key:"constants",value:t.constants,style:t,styleSpec:e}))),Dn(r)}function Dn(t){return [].concat(t).sort((function(t,e){return t.line-e.line}))}function Ln(t){return function(){for(var e=[],r=arguments.length;r--;)e[r]=arguments[r];return Dn(t.apply(this,e))}}Fn.source=Ln(Tn),Fn.light=Ln(En),Fn.layer=Ln(zn),Fn.filter=Ln(An),Fn.paintProperty=Ln(kn),Fn.layoutProperty=Ln(In);var Rn=Fn,On=Rn.light,Un=Rn.paintProperty,jn=Rn.layoutProperty;function qn(t,e){var r=!1;if(e&&e.length)for(var n=0,i=e;n<i.length;n+=1)t.fire(new It(new Error(i[n].message))),r=!0;return r}var Nn=Xn,Kn=3;function Xn(t,e,r){var n=this.cells=[];if(t instanceof ArrayBuffer){this.arrayBuffer=t;var i=new Int32Array(this.arrayBuffer);t=i[0],this.d=(e=i[1])+2*(r=i[2]);for(var a=0;a<this.d*this.d;a++){var o=i[Kn+a],s=i[Kn+a+1];n.push(o===s?null:i.subarray(o,s));}var u=i[Kn+n.length+1];this.keys=i.subarray(i[Kn+n.length],u),this.bboxes=i.subarray(u),this.insert=this._insertReadonly;}else{this.d=e+2*r;for(var l=0;l<this.d*this.d;l++)n.push([]);this.keys=[],this.bboxes=[];}this.n=e,this.extent=t,this.padding=r,this.scale=e/t,this.uid=0;var p=r/e*t;this.min=-p,this.max=t+p;}Xn.prototype.insert=function(t,e,r,n,i){this._forEachCell(e,r,n,i,this._insertCell,this.uid++),this.keys.push(t),this.bboxes.push(e),this.bboxes.push(r),this.bboxes.push(n),this.bboxes.push(i);},Xn.prototype._insertReadonly=function(){throw "Cannot insert into a GridIndex created from an ArrayBuffer."},Xn.prototype._insertCell=function(t,e,r,n,i,a){this.cells[i].push(a);},Xn.prototype.query=function(t,e,r,n,i){var a=this.min,o=this.max;if(t<=a&&e<=a&&o<=r&&o<=n&&!i)return Array.prototype.slice.call(this.keys);var s=[];return this._forEachCell(t,e,r,n,this._queryCell,s,{},i),s},Xn.prototype._queryCell=function(t,e,r,n,i,a,o,s){var u=this.cells[i];if(null!==u)for(var l=this.keys,p=this.bboxes,c=0;c<u.length;c++){var h=u[c];if(void 0===o[h]){var f=4*h;(s?s(p[f+0],p[f+1],p[f+2],p[f+3]):t<=p[f+2]&&e<=p[f+3]&&r>=p[f+0]&&n>=p[f+1])?(o[h]=!0,a.push(l[h])):o[h]=!1;}}},Xn.prototype._forEachCell=function(t,e,r,n,i,a,o,s){for(var u=this._convertToCellCoord(t),l=this._convertToCellCoord(e),p=this._convertToCellCoord(r),c=this._convertToCellCoord(n),h=u;h<=p;h++)for(var f=l;f<=c;f++){var y=this.d*f+h;if((!s||s(this._convertFromCellCoord(h),this._convertFromCellCoord(f),this._convertFromCellCoord(h+1),this._convertFromCellCoord(f+1)))&&i.call(this,t,e,r,n,y,a,o,s))return}},Xn.prototype._convertFromCellCoord=function(t){return (t-this.padding)/this.scale},Xn.prototype._convertToCellCoord=function(t){return Math.max(0,Math.min(this.d-1,Math.floor(t*this.scale)+this.padding))},Xn.prototype.toArrayBuffer=function(){if(this.arrayBuffer)return this.arrayBuffer;for(var t=this.cells,e=Kn+this.cells.length+1+1,r=0,n=0;n<this.cells.length;n++)r+=this.cells[n].length;var i=new Int32Array(e+r+this.keys.length+this.bboxes.length);i[0]=this.extent,i[1]=this.n,i[2]=this.padding;for(var a=e,o=0;o<t.length;o++){var s=t[o];i[Kn+o]=a,i.set(s,a),a+=s.length;}return i[Kn+t.length]=a,i.set(this.keys,a),i[Kn+t.length+1]=a+=this.keys.length,i.set(this.bboxes,a),a+=this.bboxes.length,i.buffer};var Gn=self.ImageData,Zn=self.ImageBitmap,Jn={};function Hn(t,e,r){void 0===r&&(r={}),Object.defineProperty(e,"_classRegistryKey",{value:t,writeable:!1}),Jn[t]={klass:e,omit:r.omit||[],shallow:r.shallow||[]};}for(var Yn in Hn("Object",Object),Nn.serialize=function(t,e){var r=t.toArrayBuffer();return e&&e.push(r),{buffer:r}},Nn.deserialize=function(t){return new Nn(t.buffer)},Hn("Grid",Nn),Hn("Color",$t),Hn("Error",Error),Hn("ResolvedImage",ee),Hn("StylePropertyFunction",sn),Hn("StyleExpression",tn,{omit:["_evaluator"]}),Hn("ZoomDependentExpression",an),Hn("ZoomConstantExpression",nn),Hn("CompoundExpression",me,{omit:["_evaluate"]}),Dr)Dr[Yn]._classRegistryKey||Hn("Expression_"+Yn,Dr[Yn]);function $n(t){return t&&"undefined"!=typeof ArrayBuffer&&(t instanceof ArrayBuffer||t.constructor&&"ArrayBuffer"===t.constructor.name)}function Wn(t){return Zn&&t instanceof Zn}function Qn(t,e){if(null==t||"boolean"==typeof t||"number"==typeof t||"string"==typeof t||t instanceof Boolean||t instanceof Number||t instanceof String||t instanceof Date||t instanceof RegExp)return t;if($n(t)||Wn(t))return e&&e.push(t),t;if(ArrayBuffer.isView(t)){var r=t;return e&&e.push(r.buffer),r}if(t instanceof Gn)return e&&e.push(t.data.buffer),t;if(Array.isArray(t)){for(var n=[],i=0,a=t;i<a.length;i+=1)n.push(Qn(a[i],e));return n}if("object"==typeof t){var o=t.constructor,s=o._classRegistryKey;if(!s)throw new Error("can't serialize object of unregistered class");var u=o.serialize?o.serialize(t,e):{};if(!o.serialize){for(var l in t)if(t.hasOwnProperty(l)&&!(Jn[s].omit.indexOf(l)>=0)){var p=t[l];u[l]=Jn[s].shallow.indexOf(l)>=0?p:Qn(p,e);}t instanceof Error&&(u.message=t.message);}if(u.$name)throw new Error("$name property is reserved for worker serialization logic.");return "Object"!==s&&(u.$name=s),u}throw new Error("can't serialize object of type "+typeof t)}function ti(t){if(null==t||"boolean"==typeof t||"number"==typeof t||"string"==typeof t||t instanceof Boolean||t instanceof Number||t instanceof String||t instanceof Date||t instanceof RegExp||$n(t)||Wn(t)||ArrayBuffer.isView(t)||t instanceof Gn)return t;if(Array.isArray(t))return t.map(ti);if("object"==typeof t){var e=t.$name||"Object",r=Jn[e].klass;if(!r)throw new Error("can't deserialize unregistered class "+e);if(r.deserialize)return r.deserialize(t);for(var n=Object.create(r.prototype),i=0,a=Object.keys(t);i<a.length;i+=1){var o=a[i];if("$name"!==o){var s=t[o];n[o]=Jn[e].shallow.indexOf(o)>=0?s:ti(s);}}return n}throw new Error("can't deserialize object of type "+typeof t)}var ei=function(){this.first=!0;};ei.prototype.update=function(t,e){var r=Math.floor(t);return this.first?(this.first=!1,this.lastIntegerZoom=r,this.lastIntegerZoomTime=0,this.lastZoom=t,this.lastFloorZoom=r,!0):(this.lastFloorZoom>r?(this.lastIntegerZoom=r+1,this.lastIntegerZoomTime=e):this.lastFloorZoom<r&&(this.lastIntegerZoom=r,this.lastIntegerZoomTime=e),t!==this.lastZoom&&(this.lastZoom=t,this.lastFloorZoom=r,!0))};var ri={"Latin-1 Supplement":function(t){return t>=128&&t<=255},Arabic:function(t){return t>=1536&&t<=1791},"Arabic Supplement":function(t){return t>=1872&&t<=1919},"Arabic Extended-A":function(t){return t>=2208&&t<=2303},"Hangul Jamo":function(t){return t>=4352&&t<=4607},"Unified Canadian Aboriginal Syllabics":function(t){return t>=5120&&t<=5759},Khmer:function(t){return t>=6016&&t<=6143},"Unified Canadian Aboriginal Syllabics Extended":function(t){return t>=6320&&t<=6399},"General Punctuation":function(t){return t>=8192&&t<=8303},"Letterlike Symbols":function(t){return t>=8448&&t<=8527},"Number Forms":function(t){return t>=8528&&t<=8591},"Miscellaneous Technical":function(t){return t>=8960&&t<=9215},"Control Pictures":function(t){return t>=9216&&t<=9279},"Optical Character Recognition":function(t){return t>=9280&&t<=9311},"Enclosed Alphanumerics":function(t){return t>=9312&&t<=9471},"Geometric Shapes":function(t){return t>=9632&&t<=9727},"Miscellaneous Symbols":function(t){return t>=9728&&t<=9983},"Miscellaneous Symbols and Arrows":function(t){return t>=11008&&t<=11263},"CJK Radicals Supplement":function(t){return t>=11904&&t<=12031},"Kangxi Radicals":function(t){return t>=12032&&t<=12255},"Ideographic Description Characters":function(t){return t>=12272&&t<=12287},"CJK Symbols and Punctuation":function(t){return t>=12288&&t<=12351},Hiragana:function(t){return t>=12352&&t<=12447},Katakana:function(t){return t>=12448&&t<=12543},Bopomofo:function(t){return t>=12544&&t<=12591},"Hangul Compatibility Jamo":function(t){return t>=12592&&t<=12687},Kanbun:function(t){return t>=12688&&t<=12703},"Bopomofo Extended":function(t){return t>=12704&&t<=12735},"CJK Strokes":function(t){return t>=12736&&t<=12783},"Katakana Phonetic Extensions":function(t){return t>=12784&&t<=12799},"Enclosed CJK Letters and Months":function(t){return t>=12800&&t<=13055},"CJK Compatibility":function(t){return t>=13056&&t<=13311},"CJK Unified Ideographs Extension A":function(t){return t>=13312&&t<=19903},"Yijing Hexagram Symbols":function(t){return t>=19904&&t<=19967},"CJK Unified Ideographs":function(t){return t>=19968&&t<=40959},"Yi Syllables":function(t){return t>=40960&&t<=42127},"Yi Radicals":function(t){return t>=42128&&t<=42191},"Hangul Jamo Extended-A":function(t){return t>=43360&&t<=43391},"Hangul Syllables":function(t){return t>=44032&&t<=55215},"Hangul Jamo Extended-B":function(t){return t>=55216&&t<=55295},"Private Use Area":function(t){return t>=57344&&t<=63743},"CJK Compatibility Ideographs":function(t){return t>=63744&&t<=64255},"Arabic Presentation Forms-A":function(t){return t>=64336&&t<=65023},"Vertical Forms":function(t){return t>=65040&&t<=65055},"CJK Compatibility Forms":function(t){return t>=65072&&t<=65103},"Small Form Variants":function(t){return t>=65104&&t<=65135},"Arabic Presentation Forms-B":function(t){return t>=65136&&t<=65279},"Halfwidth and Fullwidth Forms":function(t){return t>=65280&&t<=65519}};function ni(t){for(var e=0,r=t;e<r.length;e+=1)if(ii(r[e].charCodeAt(0)))return !0;return !1}function ii(t){return !(746!==t&&747!==t&&(t<4352||!(ri["Bopomofo Extended"](t)||ri.Bopomofo(t)||ri["CJK Compatibility Forms"](t)&&!(t>=65097&&t<=65103)||ri["CJK Compatibility Ideographs"](t)||ri["CJK Compatibility"](t)||ri["CJK Radicals Supplement"](t)||ri["CJK Strokes"](t)||!(!ri["CJK Symbols and Punctuation"](t)||t>=12296&&t<=12305||t>=12308&&t<=12319||12336===t)||ri["CJK Unified Ideographs Extension A"](t)||ri["CJK Unified Ideographs"](t)||ri["Enclosed CJK Letters and Months"](t)||ri["Hangul Compatibility Jamo"](t)||ri["Hangul Jamo Extended-A"](t)||ri["Hangul Jamo Extended-B"](t)||ri["Hangul Jamo"](t)||ri["Hangul Syllables"](t)||ri.Hiragana(t)||ri["Ideographic Description Characters"](t)||ri.Kanbun(t)||ri["Kangxi Radicals"](t)||ri["Katakana Phonetic Extensions"](t)||ri.Katakana(t)&&12540!==t||!(!ri["Halfwidth and Fullwidth Forms"](t)||65288===t||65289===t||65293===t||t>=65306&&t<=65310||65339===t||65341===t||65343===t||t>=65371&&t<=65503||65507===t||t>=65512&&t<=65519)||!(!ri["Small Form Variants"](t)||t>=65112&&t<=65118||t>=65123&&t<=65126)||ri["Unified Canadian Aboriginal Syllabics"](t)||ri["Unified Canadian Aboriginal Syllabics Extended"](t)||ri["Vertical Forms"](t)||ri["Yijing Hexagram Symbols"](t)||ri["Yi Syllables"](t)||ri["Yi Radicals"](t))))}function ai(t){return !(ii(t)||function(t){return !!(ri["Latin-1 Supplement"](t)&&(167===t||169===t||174===t||177===t||188===t||189===t||190===t||215===t||247===t)||ri["General Punctuation"](t)&&(8214===t||8224===t||8225===t||8240===t||8241===t||8251===t||8252===t||8258===t||8263===t||8264===t||8265===t||8273===t)||ri["Letterlike Symbols"](t)||ri["Number Forms"](t)||ri["Miscellaneous Technical"](t)&&(t>=8960&&t<=8967||t>=8972&&t<=8991||t>=8996&&t<=9e3||9003===t||t>=9085&&t<=9114||t>=9150&&t<=9165||9167===t||t>=9169&&t<=9179||t>=9186&&t<=9215)||ri["Control Pictures"](t)&&9251!==t||ri["Optical Character Recognition"](t)||ri["Enclosed Alphanumerics"](t)||ri["Geometric Shapes"](t)||ri["Miscellaneous Symbols"](t)&&!(t>=9754&&t<=9759)||ri["Miscellaneous Symbols and Arrows"](t)&&(t>=11026&&t<=11055||t>=11088&&t<=11097||t>=11192&&t<=11243)||ri["CJK Symbols and Punctuation"](t)||ri.Katakana(t)||ri["Private Use Area"](t)||ri["CJK Compatibility Forms"](t)||ri["Small Form Variants"](t)||ri["Halfwidth and Fullwidth Forms"](t)||8734===t||8756===t||8757===t||t>=9984&&t<=10087||t>=10102&&t<=10131||65532===t||65533===t)}(t))}function oi(t){return t>=1424&&t<=2303||ri["Arabic Presentation Forms-A"](t)||ri["Arabic Presentation Forms-B"](t)}function si(t,e){return !(!e&&oi(t)||t>=2304&&t<=3583||t>=3840&&t<=4255||ri.Khmer(t))}function ui(t){for(var e=0,r=t;e<r.length;e+=1)if(oi(r[e].charCodeAt(0)))return !0;return !1}var li=null,pi="unavailable",ci=null,hi=function(t){li&&li(t);};function fi(){yi.fire(new kt("pluginStateChange",{pluginStatus:pi,pluginURL:ci}));}var yi=new zt,di=function(){return pi},mi=function(){if("deferred"!==pi||!ci)throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");pi="loading",fi(),ci&&bt({url:ci},(function(t){t?hi(t):(pi="loaded",fi());}));},vi={applyArabicShaping:null,processBidirectionalText:null,processStyledBidirectionalText:null,isLoaded:function(){return "loaded"===pi||null!=vi.applyArabicShaping},isLoading:function(){return "loading"===pi},setState:function(t){pi=t.pluginStatus,ci=t.pluginURL;},isParsed:function(){return null!=vi.applyArabicShaping&&null!=vi.processBidirectionalText&&null!=vi.processStyledBidirectionalText},getPluginURL:function(){return ci}},gi=function(t,e){this.zoom=t,e?(this.now=e.now,this.fadeDuration=e.fadeDuration,this.zoomHistory=e.zoomHistory,this.transition=e.transition):(this.now=0,this.fadeDuration=0,this.zoomHistory=new ei,this.transition={});};gi.prototype.isSupportedScript=function(t){return function(t,e){for(var r=0,n=t;r<n.length;r+=1)if(!si(n[r].charCodeAt(0),e))return !1;return !0}(t,vi.isLoaded())},gi.prototype.crossFadingFactor=function(){return 0===this.fadeDuration?1:Math.min((this.now-this.zoomHistory.lastIntegerZoomTime)/this.fadeDuration,1)},gi.prototype.getCrossfadeParameters=function(){var t=this.zoom,e=t-Math.floor(t),r=this.crossFadingFactor();return t>this.zoomHistory.lastIntegerZoom?{fromScale:2,toScale:1,t:e+(1-e)*r}:{fromScale:.5,toScale:1,t:1-(1-r)*e}};var xi=function(t,e){this.property=t,this.value=e,this.expression=function(t,e){if(Zr(t))return new sn(t,e);if(en(t)){var r=on(t,e);if("error"===r.result)throw new Error(r.value.map((function(t){return t.key+": "+t.message})).join(", "));return r.value}var n=t;return "string"==typeof t&&"color"===e.type&&(n=$t.parse(t)),{kind:"constant",evaluate:function(){return n}}}(void 0===e?t.specification.default:e,t.specification);};xi.prototype.isDataDriven=function(){return "source"===this.expression.kind||"composite"===this.expression.kind},xi.prototype.possiblyEvaluate=function(t,e,r){return this.property.possiblyEvaluate(this,t,e,r)};var bi=function(t){this.property=t,this.value=new xi(t,void 0);};bi.prototype.transitioned=function(t,e){return new _i(this.property,this.value,e,p({},t.transition,this.transition),t.now)},bi.prototype.untransitioned=function(){return new _i(this.property,this.value,null,{},0)};var wi=function(t){this._properties=t,this._values=Object.create(t.defaultTransitionablePropertyValues);};wi.prototype.getValue=function(t){return x(this._values[t].value.value)},wi.prototype.setValue=function(t,e){this._values.hasOwnProperty(t)||(this._values[t]=new bi(this._values[t].property)),this._values[t].value=new xi(this._values[t].property,null===e?void 0:x(e));},wi.prototype.getTransition=function(t){return x(this._values[t].transition)},wi.prototype.setTransition=function(t,e){this._values.hasOwnProperty(t)||(this._values[t]=new bi(this._values[t].property)),this._values[t].transition=x(e)||void 0;},wi.prototype.serialize=function(){for(var t={},e=0,r=Object.keys(this._values);e<r.length;e+=1){var n=r[e],i=this.getValue(n);void 0!==i&&(t[n]=i);var a=this.getTransition(n);void 0!==a&&(t[n+"-transition"]=a);}return t},wi.prototype.transitioned=function(t,e){for(var r=new Ai(this._properties),n=0,i=Object.keys(this._values);n<i.length;n+=1){var a=i[n];r._values[a]=this._values[a].transitioned(t,e._values[a]);}return r},wi.prototype.untransitioned=function(){for(var t=new Ai(this._properties),e=0,r=Object.keys(this._values);e<r.length;e+=1){var n=r[e];t._values[n]=this._values[n].untransitioned();}return t};var _i=function(t,e,r,n,i){this.property=t,this.value=e,this.begin=i+n.delay||0,this.end=this.begin+n.duration||0,t.specification.transition&&(n.delay||n.duration)&&(this.prior=r);};_i.prototype.possiblyEvaluate=function(t,e,r){var n=t.now||0,i=this.value.possiblyEvaluate(t,e,r),a=this.prior;if(a){if(n>this.end)return this.prior=null,i;if(this.value.isDataDriven())return this.prior=null,i;if(n<this.begin)return a.possiblyEvaluate(t,e,r);var o=(n-this.begin)/(this.end-this.begin);return this.property.interpolate(a.possiblyEvaluate(t,e,r),i,function(t){if(t<=0)return 0;if(t>=1)return 1;var e=t*t,r=e*t;return 4*(t<.5?r:3*(t-e)+r-.75)}(o))}return i};var Ai=function(t){this._properties=t,this._values=Object.create(t.defaultTransitioningPropertyValues);};Ai.prototype.possiblyEvaluate=function(t,e){for(var r=new Ii(this._properties),n=0,i=Object.keys(this._values);n<i.length;n+=1){var a=i[n];r._values[a]=this._values[a].possiblyEvaluate(t,e);}return r},Ai.prototype.hasTransition=function(){for(var t=0,e=Object.keys(this._values);t<e.length;t+=1)if(this._values[e[t]].prior)return !0;return !1};var Si=function(t){this._properties=t,this._values=Object.create(t.defaultPropertyValues);};Si.prototype.getValue=function(t){return x(this._values[t].value)},Si.prototype.setValue=function(t,e){this._values[t]=new xi(this._values[t].property,null===e?void 0:x(e));},Si.prototype.serialize=function(){for(var t={},e=0,r=Object.keys(this._values);e<r.length;e+=1){var n=r[e],i=this.getValue(n);void 0!==i&&(t[n]=i);}return t},Si.prototype.possiblyEvaluate=function(t,e){for(var r=new Ii(this._properties),n=0,i=Object.keys(this._values);n<i.length;n+=1){var a=i[n];r._values[a]=this._values[a].possiblyEvaluate(t,e);}return r};var ki=function(t,e,r){this.property=t,this.value=e,this.parameters=r;};ki.prototype.isConstant=function(){return "constant"===this.value.kind},ki.prototype.constantOr=function(t){return "constant"===this.value.kind?this.value.value:t},ki.prototype.evaluate=function(t,e,r,n){return this.property.evaluate(this.value,this.parameters,t,e,r,n)};var Ii=function(t){this._properties=t,this._values=Object.create(t.defaultPossiblyEvaluatedValues);};Ii.prototype.get=function(t){return this._values[t]};var zi=function(t){this.specification=t;};zi.prototype.possiblyEvaluate=function(t,e){return t.expression.evaluate(e)},zi.prototype.interpolate=function(t,e,r){var n=$e[this.specification.type];return n?n(t,e,r):t};var Ci=function(t,e){this.specification=t,this.overrides=e;};Ci.prototype.possiblyEvaluate=function(t,e,r,n){return new ki(this,"constant"===t.expression.kind||"camera"===t.expression.kind?{kind:"constant",value:t.expression.evaluate(e,null,{},r,n)}:t.expression,e)},Ci.prototype.interpolate=function(t,e,r){if("constant"!==t.value.kind||"constant"!==e.value.kind)return t;if(void 0===t.value.value||void 0===e.value.value)return new ki(this,{kind:"constant",value:void 0},t.parameters);var n=$e[this.specification.type];return n?new ki(this,{kind:"constant",value:n(t.value.value,e.value.value,r)},t.parameters):t},Ci.prototype.evaluate=function(t,e,r,n,i,a){return "constant"===t.kind?t.value:t.evaluate(e,r,n,i,a)};var Mi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.possiblyEvaluate=function(t,e,r,n){if(void 0===t.value)return new ki(this,{kind:"constant",value:void 0},e);if("constant"===t.expression.kind){var i=t.expression.evaluate(e,null,{},r,n),a="resolvedImage"===t.property.specification.type&&"string"!=typeof i?i.name:i,o=this._calculate(a,a,a,e);return new ki(this,{kind:"constant",value:o},e)}if("camera"===t.expression.kind){var s=this._calculate(t.expression.evaluate({zoom:e.zoom-1}),t.expression.evaluate({zoom:e.zoom}),t.expression.evaluate({zoom:e.zoom+1}),e);return new ki(this,{kind:"constant",value:s},e)}return new ki(this,t.expression,e)},e.prototype.evaluate=function(t,e,r,n,i,a){if("source"===t.kind){var o=t.evaluate(e,r,n,i,a);return this._calculate(o,o,o,e)}return "composite"===t.kind?this._calculate(t.evaluate({zoom:Math.floor(e.zoom)-1},r,n),t.evaluate({zoom:Math.floor(e.zoom)},r,n),t.evaluate({zoom:Math.floor(e.zoom)+1},r,n),e):t.value},e.prototype._calculate=function(t,e,r,n){return n.zoom>n.zoomHistory.lastIntegerZoom?{from:t,to:e}:{from:r,to:e}},e.prototype.interpolate=function(t){return t},e}(Ci),Ti=function(t){this.specification=t;};Ti.prototype.possiblyEvaluate=function(t,e,r,n){if(void 0!==t.value){if("constant"===t.expression.kind){var i=t.expression.evaluate(e,null,{},r,n);return this._calculate(i,i,i,e)}return this._calculate(t.expression.evaluate(new gi(Math.floor(e.zoom-1),e)),t.expression.evaluate(new gi(Math.floor(e.zoom),e)),t.expression.evaluate(new gi(Math.floor(e.zoom+1),e)),e)}},Ti.prototype._calculate=function(t,e,r,n){return n.zoom>n.zoomHistory.lastIntegerZoom?{from:t,to:e}:{from:r,to:e}},Ti.prototype.interpolate=function(t){return t};var Ei=function(t){this.specification=t;};Ei.prototype.possiblyEvaluate=function(t,e,r,n){return !!t.expression.evaluate(e,null,{},r,n)},Ei.prototype.interpolate=function(){return !1};var Pi=function(t){for(var e in this.properties=t,this.defaultPropertyValues={},this.defaultTransitionablePropertyValues={},this.defaultTransitioningPropertyValues={},this.defaultPossiblyEvaluatedValues={},this.overridableProperties=[],t){var r=t[e];r.specification.overridable&&this.overridableProperties.push(e);var n=this.defaultPropertyValues[e]=new xi(r,void 0),i=this.defaultTransitionablePropertyValues[e]=new bi(r);this.defaultTransitioningPropertyValues[e]=i.untransitioned(),this.defaultPossiblyEvaluatedValues[e]=n.possiblyEvaluate({});}};Hn("DataDrivenProperty",Ci),Hn("DataConstantProperty",zi),Hn("CrossFadedDataDrivenProperty",Mi),Hn("CrossFadedProperty",Ti),Hn("ColorRampProperty",Ei);var Bi=function(t){function e(e,r){if(t.call(this),this.id=e.id,this.type=e.type,this._featureFilter={filter:function(){return !0},needGeometry:!1},"custom"!==e.type&&(this.metadata=(e=e).metadata,this.minzoom=e.minzoom,this.maxzoom=e.maxzoom,"background"!==e.type&&(this.source=e.source,this.sourceLayer=e["source-layer"],this.filter=e.filter),r.layout&&(this._unevaluatedLayout=new Si(r.layout)),r.paint)){for(var n in this._transitionablePaint=new wi(r.paint),e.paint)this.setPaintProperty(n,e.paint[n],{validate:!1});for(var i in e.layout)this.setLayoutProperty(i,e.layout[i],{validate:!1});this._transitioningPaint=this._transitionablePaint.untransitioned();}}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getCrossfadeParameters=function(){return this._crossfadeParameters},e.prototype.getLayoutProperty=function(t){return "visibility"===t?this.visibility:this._unevaluatedLayout.getValue(t)},e.prototype.setLayoutProperty=function(t,e,r){void 0===r&&(r={}),null!=e&&this._validate(jn,"layers."+this.id+".layout."+t,t,e,r)||("visibility"!==t?this._unevaluatedLayout.setValue(t,e):this.visibility=e);},e.prototype.getPaintProperty=function(t){return m(t,"-transition")?this._transitionablePaint.getTransition(t.slice(0,-"-transition".length)):this._transitionablePaint.getValue(t)},e.prototype.setPaintProperty=function(t,e,r){if(void 0===r&&(r={}),null!=e&&this._validate(Un,"layers."+this.id+".paint."+t,t,e,r))return !1;if(m(t,"-transition"))return this._transitionablePaint.setTransition(t.slice(0,-"-transition".length),e||void 0),!1;var n=this._transitionablePaint._values[t],i="cross-faded-data-driven"===n.property.specification["property-type"],a=n.value.isDataDriven(),o=n.value;this._transitionablePaint.setValue(t,e),this._handleSpecialPaintPropertyUpdate(t);var s=this._transitionablePaint._values[t].value;return s.isDataDriven()||a||i||this._handleOverridablePaintPropertyUpdate(t,o,s)},e.prototype._handleSpecialPaintPropertyUpdate=function(t){},e.prototype._handleOverridablePaintPropertyUpdate=function(t,e,r){return !1},e.prototype.isHidden=function(t){return !!(this.minzoom&&t<this.minzoom)||!!(this.maxzoom&&t>=this.maxzoom)||"none"===this.visibility},e.prototype.updateTransitions=function(t){this._transitioningPaint=this._transitionablePaint.transitioned(t,this._transitioningPaint);},e.prototype.hasTransition=function(){return this._transitioningPaint.hasTransition()},e.prototype.recalculate=function(t,e){t.getCrossfadeParameters&&(this._crossfadeParameters=t.getCrossfadeParameters()),this._unevaluatedLayout&&(this.layout=this._unevaluatedLayout.possiblyEvaluate(t,e)),this.paint=this._transitioningPaint.possiblyEvaluate(t,e);},e.prototype.serialize=function(){var t={id:this.id,type:this.type,source:this.source,"source-layer":this.sourceLayer,metadata:this.metadata,minzoom:this.minzoom,maxzoom:this.maxzoom,filter:this.filter,layout:this._unevaluatedLayout&&this._unevaluatedLayout.serialize(),paint:this._transitionablePaint&&this._transitionablePaint.serialize()};return this.visibility&&(t.layout=t.layout||{},t.layout.visibility=this.visibility),g(t,(function(t,e){return !(void 0===t||"layout"===e&&!Object.keys(t).length||"paint"===e&&!Object.keys(t).length)}))},e.prototype._validate=function(t,e,r,n,i){return void 0===i&&(i={}),(!i||!1!==i.validate)&&qn(this,t.call(Rn,{key:e,layerType:this.type,objectKey:r,value:n,styleSpec:Ct,style:{glyphs:!0,sprite:!0}}))},e.prototype.is3D=function(){return !1},e.prototype.isTileClipped=function(){return !1},e.prototype.hasOffscreenPass=function(){return !1},e.prototype.resize=function(){},e.prototype.isStateDependent=function(){for(var t in this.paint._values){var e=this.paint.get(t);if(e instanceof ki&&Nr(e.property.specification)&&("source"===e.value.kind||"composite"===e.value.kind)&&e.value.isStateDependent)return !0}return !1},e}(zt),Vi={Int8:Int8Array,Uint8:Uint8Array,Int16:Int16Array,Uint16:Uint16Array,Int32:Int32Array,Uint32:Uint32Array,Float32:Float32Array},Fi=function(t,e){this._structArray=t,this._pos1=e*this.size,this._pos2=this._pos1/2,this._pos4=this._pos1/4,this._pos8=this._pos1/8;},Di=function(){this.isTransferred=!1,this.capacity=-1,this.resize(0);};function Li(t,e){void 0===e&&(e=1);var r=0,n=0;return {members:t.map((function(t){var i=Vi[t.type].BYTES_PER_ELEMENT,a=r=Ri(r,Math.max(e,i)),o=t.components||1;return n=Math.max(n,i),r+=i*o,{name:t.name,type:t.type,components:o,offset:a}})),size:Ri(r,Math.max(n,e)),alignment:e}}function Ri(t,e){return Math.ceil(t/e)*e}Di.serialize=function(t,e){return t._trim(),e&&(t.isTransferred=!0,e.push(t.arrayBuffer)),{length:t.length,arrayBuffer:t.arrayBuffer}},Di.deserialize=function(t){var e=Object.create(this.prototype);return e.arrayBuffer=t.arrayBuffer,e.length=t.length,e.capacity=t.arrayBuffer.byteLength/e.bytesPerElement,e._refreshViews(),e},Di.prototype._trim=function(){this.length!==this.capacity&&(this.capacity=this.length,this.arrayBuffer=this.arrayBuffer.slice(0,this.length*this.bytesPerElement),this._refreshViews());},Di.prototype.clear=function(){this.length=0;},Di.prototype.resize=function(t){this.reserve(t),this.length=t;},Di.prototype.reserve=function(t){if(t>this.capacity){this.capacity=Math.max(t,Math.floor(5*this.capacity),128),this.arrayBuffer=new ArrayBuffer(this.capacity*this.bytesPerElement);var e=this.uint8;this._refreshViews(),e&&this.uint8.set(e);}},Di.prototype._refreshViews=function(){throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")};var Oi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e){var r=this.length;return this.resize(r+1),this.emplace(r,t,e)},e.prototype.emplace=function(t,e,r){var n=2*t;return this.int16[n+0]=e,this.int16[n+1]=r,t},e}(Di);Oi.prototype.bytesPerElement=4,Hn("StructArrayLayout2i4",Oi);var Ui=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n){var i=this.length;return this.resize(i+1),this.emplace(i,t,e,r,n)},e.prototype.emplace=function(t,e,r,n,i){var a=4*t;return this.int16[a+0]=e,this.int16[a+1]=r,this.int16[a+2]=n,this.int16[a+3]=i,t},e}(Di);Ui.prototype.bytesPerElement=8,Hn("StructArrayLayout4i8",Ui);var ji=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n,i,a){var o=this.length;return this.resize(o+1),this.emplace(o,t,e,r,n,i,a)},e.prototype.emplace=function(t,e,r,n,i,a,o){var s=6*t;return this.int16[s+0]=e,this.int16[s+1]=r,this.int16[s+2]=n,this.int16[s+3]=i,this.int16[s+4]=a,this.int16[s+5]=o,t},e}(Di);ji.prototype.bytesPerElement=12,Hn("StructArrayLayout2i4i12",ji);var qi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n,i,a){var o=this.length;return this.resize(o+1),this.emplace(o,t,e,r,n,i,a)},e.prototype.emplace=function(t,e,r,n,i,a,o){var s=4*t,u=8*t;return this.int16[s+0]=e,this.int16[s+1]=r,this.uint8[u+4]=n,this.uint8[u+5]=i,this.uint8[u+6]=a,this.uint8[u+7]=o,t},e}(Di);qi.prototype.bytesPerElement=8,Hn("StructArrayLayout2i4ub8",qi);var Ni=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n,i,a,o,s,u,l){var p=this.length;return this.resize(p+1),this.emplace(p,t,e,r,n,i,a,o,s,u,l)},e.prototype.emplace=function(t,e,r,n,i,a,o,s,u,l,p){var c=9*t,h=18*t;return this.uint16[c+0]=e,this.uint16[c+1]=r,this.uint16[c+2]=n,this.uint16[c+3]=i,this.uint16[c+4]=a,this.uint16[c+5]=o,this.uint16[c+6]=s,this.uint16[c+7]=u,this.uint8[h+16]=l,this.uint8[h+17]=p,t},e}(Di);Ni.prototype.bytesPerElement=18,Hn("StructArrayLayout8ui2ub18",Ni);var Ki=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n,i,a,o,s,u,l,p,c){var h=this.length;return this.resize(h+1),this.emplace(h,t,e,r,n,i,a,o,s,u,l,p,c)},e.prototype.emplace=function(t,e,r,n,i,a,o,s,u,l,p,c,h){var f=12*t;return this.int16[f+0]=e,this.int16[f+1]=r,this.int16[f+2]=n,this.int16[f+3]=i,this.uint16[f+4]=a,this.uint16[f+5]=o,this.uint16[f+6]=s,this.uint16[f+7]=u,this.int16[f+8]=l,this.int16[f+9]=p,this.int16[f+10]=c,this.int16[f+11]=h,t},e}(Di);Ki.prototype.bytesPerElement=24,Hn("StructArrayLayout4i4ui4i24",Ki);var Xi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r){var n=this.length;return this.resize(n+1),this.emplace(n,t,e,r)},e.prototype.emplace=function(t,e,r,n){var i=3*t;return this.float32[i+0]=e,this.float32[i+1]=r,this.float32[i+2]=n,t},e}(Di);Xi.prototype.bytesPerElement=12,Hn("StructArrayLayout3f12",Xi);var Gi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t){var e=this.length;return this.resize(e+1),this.emplace(e,t)},e.prototype.emplace=function(t,e){return this.uint32[1*t+0]=e,t},e}(Di);Gi.prototype.bytesPerElement=4,Hn("StructArrayLayout1ul4",Gi);var Zi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n,i,a,o,s,u,l,p){var c=this.length;return this.resize(c+1),this.emplace(c,t,e,r,n,i,a,o,s,u,l,p)},e.prototype.emplace=function(t,e,r,n,i,a,o,s,u,l,p,c){var h=12*t,f=6*t;return this.int16[h+0]=e,this.int16[h+1]=r,this.int16[h+2]=n,this.int16[h+3]=i,this.int16[h+4]=a,this.int16[h+5]=o,this.uint32[f+3]=s,this.uint16[h+8]=u,this.uint16[h+9]=l,this.int16[h+10]=p,this.int16[h+11]=c,t},e}(Di);Zi.prototype.bytesPerElement=24,Hn("StructArrayLayout6i1ul2ui2i24",Zi);var Ji=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n,i,a){var o=this.length;return this.resize(o+1),this.emplace(o,t,e,r,n,i,a)},e.prototype.emplace=function(t,e,r,n,i,a,o){var s=6*t;return this.int16[s+0]=e,this.int16[s+1]=r,this.int16[s+2]=n,this.int16[s+3]=i,this.int16[s+4]=a,this.int16[s+5]=o,t},e}(Di);Ji.prototype.bytesPerElement=12,Hn("StructArrayLayout2i2i2i12",Ji);var Hi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n){var i=this.length;return this.resize(i+1),this.emplace(i,t,e,r,n)},e.prototype.emplace=function(t,e,r,n,i){var a=12*t,o=3*t;return this.uint8[a+0]=e,this.uint8[a+1]=r,this.float32[o+1]=n,this.float32[o+2]=i,t},e}(Di);Hi.prototype.bytesPerElement=12,Hn("StructArrayLayout2ub2f12",Hi);var Yi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n,i,a,o,s,u,l,p,c,h,f,y,d,m){var v=this.length;return this.resize(v+1),this.emplace(v,t,e,r,n,i,a,o,s,u,l,p,c,h,f,y,d,m)},e.prototype.emplace=function(t,e,r,n,i,a,o,s,u,l,p,c,h,f,y,d,m,v){var g=24*t,x=12*t,b=48*t;return this.int16[g+0]=e,this.int16[g+1]=r,this.uint16[g+2]=n,this.uint16[g+3]=i,this.uint32[x+2]=a,this.uint32[x+3]=o,this.uint32[x+4]=s,this.uint16[g+10]=u,this.uint16[g+11]=l,this.uint16[g+12]=p,this.float32[x+7]=c,this.float32[x+8]=h,this.uint8[b+36]=f,this.uint8[b+37]=y,this.uint8[b+38]=d,this.uint32[x+10]=m,this.int16[g+22]=v,t},e}(Di);Yi.prototype.bytesPerElement=48,Hn("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48",Yi);var $i=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n,i,a,o,s,u,l,p,c,h,f,y,d,m,v,g,x,b,w,_,A,S,k){var I=this.length;return this.resize(I+1),this.emplace(I,t,e,r,n,i,a,o,s,u,l,p,c,h,f,y,d,m,v,g,x,b,w,_,A,S,k)},e.prototype.emplace=function(t,e,r,n,i,a,o,s,u,l,p,c,h,f,y,d,m,v,g,x,b,w,_,A,S,k,I){var z=30*t,C=15*t;return this.int16[z+0]=e,this.int16[z+1]=r,this.int16[z+2]=n,this.int16[z+3]=i,this.int16[z+4]=a,this.int16[z+5]=o,this.int16[z+6]=s,this.int16[z+7]=u,this.uint16[z+8]=l,this.uint16[z+9]=p,this.uint16[z+10]=c,this.uint16[z+11]=h,this.uint16[z+12]=f,this.uint16[z+13]=y,this.uint16[z+14]=d,this.uint16[z+15]=m,this.uint16[z+16]=v,this.uint16[z+17]=g,this.uint16[z+18]=x,this.uint16[z+19]=b,this.uint16[z+20]=w,this.uint16[z+21]=_,this.uint32[C+11]=A,this.float32[C+12]=S,this.float32[C+13]=k,this.float32[C+14]=I,t},e}(Di);$i.prototype.bytesPerElement=60,Hn("StructArrayLayout8i14ui1ul3f60",$i);var Wi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t){var e=this.length;return this.resize(e+1),this.emplace(e,t)},e.prototype.emplace=function(t,e){return this.float32[1*t+0]=e,t},e}(Di);Wi.prototype.bytesPerElement=4,Hn("StructArrayLayout1f4",Wi);var Qi=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r){var n=this.length;return this.resize(n+1),this.emplace(n,t,e,r)},e.prototype.emplace=function(t,e,r,n){var i=3*t;return this.int16[i+0]=e,this.int16[i+1]=r,this.int16[i+2]=n,t},e}(Di);Qi.prototype.bytesPerElement=6,Hn("StructArrayLayout3i6",Qi);var ta=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r){var n=this.length;return this.resize(n+1),this.emplace(n,t,e,r)},e.prototype.emplace=function(t,e,r,n){var i=4*t;return this.uint32[2*t+0]=e,this.uint16[i+2]=r,this.uint16[i+3]=n,t},e}(Di);ta.prototype.bytesPerElement=8,Hn("StructArrayLayout1ul2ui8",ta);var ea=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r){var n=this.length;return this.resize(n+1),this.emplace(n,t,e,r)},e.prototype.emplace=function(t,e,r,n){var i=3*t;return this.uint16[i+0]=e,this.uint16[i+1]=r,this.uint16[i+2]=n,t},e}(Di);ea.prototype.bytesPerElement=6,Hn("StructArrayLayout3ui6",ea);var ra=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e){var r=this.length;return this.resize(r+1),this.emplace(r,t,e)},e.prototype.emplace=function(t,e,r){var n=2*t;return this.uint16[n+0]=e,this.uint16[n+1]=r,t},e}(Di);ra.prototype.bytesPerElement=4,Hn("StructArrayLayout2ui4",ra);var na=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t){var e=this.length;return this.resize(e+1),this.emplace(e,t)},e.prototype.emplace=function(t,e){return this.uint16[1*t+0]=e,t},e}(Di);na.prototype.bytesPerElement=2,Hn("StructArrayLayout1ui2",na);var ia=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e){var r=this.length;return this.resize(r+1),this.emplace(r,t,e)},e.prototype.emplace=function(t,e,r){var n=2*t;return this.float32[n+0]=e,this.float32[n+1]=r,t},e}(Di);ia.prototype.bytesPerElement=8,Hn("StructArrayLayout2f8",ia);var aa=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._refreshViews=function(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);},e.prototype.emplaceBack=function(t,e,r,n){var i=this.length;return this.resize(i+1),this.emplace(i,t,e,r,n)},e.prototype.emplace=function(t,e,r,n,i){var a=4*t;return this.float32[a+0]=e,this.float32[a+1]=r,this.float32[a+2]=n,this.float32[a+3]=i,t},e}(Di);aa.prototype.bytesPerElement=16,Hn("StructArrayLayout4f16",aa);var oa=function(t){function e(){t.apply(this,arguments);}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var r={anchorPointX:{configurable:!0},anchorPointY:{configurable:!0},x1:{configurable:!0},y1:{configurable:!0},x2:{configurable:!0},y2:{configurable:!0},featureIndex:{configurable:!0},sourceLayerIndex:{configurable:!0},bucketIndex:{configurable:!0},radius:{configurable:!0},signedDistanceFromAnchor:{configurable:!0},anchorPoint:{configurable:!0}};return r.anchorPointX.get=function(){return this._structArray.int16[this._pos2+0]},r.anchorPointY.get=function(){return this._structArray.int16[this._pos2+1]},r.x1.get=function(){return this._structArray.int16[this._pos2+2]},r.y1.get=function(){return this._structArray.int16[this._pos2+3]},r.x2.get=function(){return this._structArray.int16[this._pos2+4]},r.y2.get=function(){return this._structArray.int16[this._pos2+5]},r.featureIndex.get=function(){return this._structArray.uint32[this._pos4+3]},r.sourceLayerIndex.get=function(){return this._structArray.uint16[this._pos2+8]},r.bucketIndex.get=function(){return this._structArray.uint16[this._pos2+9]},r.radius.get=function(){return this._structArray.int16[this._pos2+10]},r.signedDistanceFromAnchor.get=function(){return this._structArray.int16[this._pos2+11]},r.anchorPoint.get=function(){return new i(this.anchorPointX,this.anchorPointY)},Object.defineProperties(e.prototype,r),e}(Fi);oa.prototype.size=24;var sa=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.get=function(t){return new oa(this,t)},e}(Zi);Hn("CollisionBoxArray",sa);var ua=function(t){function e(){t.apply(this,arguments);}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var r={anchorX:{configurable:!0},anchorY:{configurable:!0},glyphStartIndex:{configurable:!0},numGlyphs:{configurable:!0},vertexStartIndex:{configurable:!0},lineStartIndex:{configurable:!0},lineLength:{configurable:!0},segment:{configurable:!0},lowerSize:{configurable:!0},upperSize:{configurable:!0},lineOffsetX:{configurable:!0},lineOffsetY:{configurable:!0},writingMode:{configurable:!0},placedOrientation:{configurable:!0},hidden:{configurable:!0},crossTileID:{configurable:!0},associatedIconIndex:{configurable:!0}};return r.anchorX.get=function(){return this._structArray.int16[this._pos2+0]},r.anchorY.get=function(){return this._structArray.int16[this._pos2+1]},r.glyphStartIndex.get=function(){return this._structArray.uint16[this._pos2+2]},r.numGlyphs.get=function(){return this._structArray.uint16[this._pos2+3]},r.vertexStartIndex.get=function(){return this._structArray.uint32[this._pos4+2]},r.lineStartIndex.get=function(){return this._structArray.uint32[this._pos4+3]},r.lineLength.get=function(){return this._structArray.uint32[this._pos4+4]},r.segment.get=function(){return this._structArray.uint16[this._pos2+10]},r.lowerSize.get=function(){return this._structArray.uint16[this._pos2+11]},r.upperSize.get=function(){return this._structArray.uint16[this._pos2+12]},r.lineOffsetX.get=function(){return this._structArray.float32[this._pos4+7]},r.lineOffsetY.get=function(){return this._structArray.float32[this._pos4+8]},r.writingMode.get=function(){return this._structArray.uint8[this._pos1+36]},r.placedOrientation.get=function(){return this._structArray.uint8[this._pos1+37]},r.placedOrientation.set=function(t){this._structArray.uint8[this._pos1+37]=t;},r.hidden.get=function(){return this._structArray.uint8[this._pos1+38]},r.hidden.set=function(t){this._structArray.uint8[this._pos1+38]=t;},r.crossTileID.get=function(){return this._structArray.uint32[this._pos4+10]},r.crossTileID.set=function(t){this._structArray.uint32[this._pos4+10]=t;},r.associatedIconIndex.get=function(){return this._structArray.int16[this._pos2+22]},Object.defineProperties(e.prototype,r),e}(Fi);ua.prototype.size=48;var la=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.get=function(t){return new ua(this,t)},e}(Yi);Hn("PlacedSymbolArray",la);var pa=function(t){function e(){t.apply(this,arguments);}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var r={anchorX:{configurable:!0},anchorY:{configurable:!0},rightJustifiedTextSymbolIndex:{configurable:!0},centerJustifiedTextSymbolIndex:{configurable:!0},leftJustifiedTextSymbolIndex:{configurable:!0},verticalPlacedTextSymbolIndex:{configurable:!0},placedIconSymbolIndex:{configurable:!0},verticalPlacedIconSymbolIndex:{configurable:!0},key:{configurable:!0},textBoxStartIndex:{configurable:!0},textBoxEndIndex:{configurable:!0},verticalTextBoxStartIndex:{configurable:!0},verticalTextBoxEndIndex:{configurable:!0},iconBoxStartIndex:{configurable:!0},iconBoxEndIndex:{configurable:!0},verticalIconBoxStartIndex:{configurable:!0},verticalIconBoxEndIndex:{configurable:!0},featureIndex:{configurable:!0},numHorizontalGlyphVertices:{configurable:!0},numVerticalGlyphVertices:{configurable:!0},numIconVertices:{configurable:!0},numVerticalIconVertices:{configurable:!0},crossTileID:{configurable:!0},textBoxScale:{configurable:!0},textOffset0:{configurable:!0},textOffset1:{configurable:!0}};return r.anchorX.get=function(){return this._structArray.int16[this._pos2+0]},r.anchorY.get=function(){return this._structArray.int16[this._pos2+1]},r.rightJustifiedTextSymbolIndex.get=function(){return this._structArray.int16[this._pos2+2]},r.centerJustifiedTextSymbolIndex.get=function(){return this._structArray.int16[this._pos2+3]},r.leftJustifiedTextSymbolIndex.get=function(){return this._structArray.int16[this._pos2+4]},r.verticalPlacedTextSymbolIndex.get=function(){return this._structArray.int16[this._pos2+5]},r.placedIconSymbolIndex.get=function(){return this._structArray.int16[this._pos2+6]},r.verticalPlacedIconSymbolIndex.get=function(){return this._structArray.int16[this._pos2+7]},r.key.get=function(){return this._structArray.uint16[this._pos2+8]},r.textBoxStartIndex.get=function(){return this._structArray.uint16[this._pos2+9]},r.textBoxEndIndex.get=function(){return this._structArray.uint16[this._pos2+10]},r.verticalTextBoxStartIndex.get=function(){return this._structArray.uint16[this._pos2+11]},r.verticalTextBoxEndIndex.get=function(){return this._structArray.uint16[this._pos2+12]},r.iconBoxStartIndex.get=function(){return this._structArray.uint16[this._pos2+13]},r.iconBoxEndIndex.get=function(){return this._structArray.uint16[this._pos2+14]},r.verticalIconBoxStartIndex.get=function(){return this._structArray.uint16[this._pos2+15]},r.verticalIconBoxEndIndex.get=function(){return this._structArray.uint16[this._pos2+16]},r.featureIndex.get=function(){return this._structArray.uint16[this._pos2+17]},r.numHorizontalGlyphVertices.get=function(){return this._structArray.uint16[this._pos2+18]},r.numVerticalGlyphVertices.get=function(){return this._structArray.uint16[this._pos2+19]},r.numIconVertices.get=function(){return this._structArray.uint16[this._pos2+20]},r.numVerticalIconVertices.get=function(){return this._structArray.uint16[this._pos2+21]},r.crossTileID.get=function(){return this._structArray.uint32[this._pos4+11]},r.crossTileID.set=function(t){this._structArray.uint32[this._pos4+11]=t;},r.textBoxScale.get=function(){return this._structArray.float32[this._pos4+12]},r.textOffset0.get=function(){return this._structArray.float32[this._pos4+13]},r.textOffset1.get=function(){return this._structArray.float32[this._pos4+14]},Object.defineProperties(e.prototype,r),e}(Fi);pa.prototype.size=60;var ca=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.get=function(t){return new pa(this,t)},e}($i);Hn("SymbolInstanceArray",ca);var ha=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getoffsetX=function(t){return this.float32[1*t+0]},e}(Wi);Hn("GlyphOffsetArray",ha);var fa=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getx=function(t){return this.int16[3*t+0]},e.prototype.gety=function(t){return this.int16[3*t+1]},e.prototype.gettileUnitDistanceFromAnchor=function(t){return this.int16[3*t+2]},e}(Qi);Hn("SymbolLineVertexArray",fa);var ya=function(t){function e(){t.apply(this,arguments);}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var r={featureIndex:{configurable:!0},sourceLayerIndex:{configurable:!0},bucketIndex:{configurable:!0}};return r.featureIndex.get=function(){return this._structArray.uint32[this._pos4+0]},r.sourceLayerIndex.get=function(){return this._structArray.uint16[this._pos2+2]},r.bucketIndex.get=function(){return this._structArray.uint16[this._pos2+3]},Object.defineProperties(e.prototype,r),e}(Fi);ya.prototype.size=8;var da=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.get=function(t){return new ya(this,t)},e}(ta);Hn("FeatureIndexArray",da);var ma=Li([{name:"a_pos",components:2,type:"Int16"}],4).members,va=function(t){void 0===t&&(t=[]),this.segments=t;};function ga(t,e){return 256*(t=u(Math.floor(t),0,255))+u(Math.floor(e),0,255)}va.prototype.prepareSegment=function(t,e,r,n){var i=this.segments[this.segments.length-1];return t>va.MAX_VERTEX_ARRAY_LENGTH&&w("Max vertices per segment is "+va.MAX_VERTEX_ARRAY_LENGTH+": bucket requested "+t),(!i||i.vertexLength+t>va.MAX_VERTEX_ARRAY_LENGTH||i.sortKey!==n)&&(i={vertexOffset:e.length,primitiveOffset:r.length,vertexLength:0,primitiveLength:0},void 0!==n&&(i.sortKey=n),this.segments.push(i)),i},va.prototype.get=function(){return this.segments},va.prototype.destroy=function(){for(var t=0,e=this.segments;t<e.length;t+=1){var r=e[t];for(var n in r.vaos)r.vaos[n].destroy();}},va.simpleSegment=function(t,e,r,n){return new va([{vertexOffset:t,primitiveOffset:e,vertexLength:r,primitiveLength:n,vaos:{},sortKey:0}])},va.MAX_VERTEX_ARRAY_LENGTH=Math.pow(2,16)-1,Hn("SegmentVector",va);var xa=Li([{name:"a_pattern_from",components:4,type:"Uint16"},{name:"a_pattern_to",components:4,type:"Uint16"},{name:"a_pixel_ratio_from",components:1,type:"Uint8"},{name:"a_pixel_ratio_to",components:1,type:"Uint8"}]),ba=e((function(t){t.exports=function(t,e){var r,n,i,a,o,s,u,l;for(n=t.length-(r=3&t.length),i=e,o=3432918353,s=461845907,l=0;l<n;)u=255&t.charCodeAt(l)|(255&t.charCodeAt(++l))<<8|(255&t.charCodeAt(++l))<<16|(255&t.charCodeAt(++l))<<24,++l,i=27492+(65535&(a=5*(65535&(i=(i^=u=(65535&(u=(u=(65535&u)*o+(((u>>>16)*o&65535)<<16)&4294967295)<<15|u>>>17))*s+(((u>>>16)*s&65535)<<16)&4294967295)<<13|i>>>19))+((5*(i>>>16)&65535)<<16)&4294967295))+((58964+(a>>>16)&65535)<<16);switch(u=0,r){case 3:u^=(255&t.charCodeAt(l+2))<<16;case 2:u^=(255&t.charCodeAt(l+1))<<8;case 1:i^=u=(65535&(u=(u=(65535&(u^=255&t.charCodeAt(l)))*o+(((u>>>16)*o&65535)<<16)&4294967295)<<15|u>>>17))*s+(((u>>>16)*s&65535)<<16)&4294967295;}return i^=t.length,i=2246822507*(65535&(i^=i>>>16))+((2246822507*(i>>>16)&65535)<<16)&4294967295,i=3266489909*(65535&(i^=i>>>13))+((3266489909*(i>>>16)&65535)<<16)&4294967295,(i^=i>>>16)>>>0};})),wa=e((function(t){t.exports=function(t,e){for(var r,n=t.length,i=e^n,a=0;n>=4;)r=1540483477*(65535&(r=255&t.charCodeAt(a)|(255&t.charCodeAt(++a))<<8|(255&t.charCodeAt(++a))<<16|(255&t.charCodeAt(++a))<<24))+((1540483477*(r>>>16)&65535)<<16),i=1540483477*(65535&i)+((1540483477*(i>>>16)&65535)<<16)^(r=1540483477*(65535&(r^=r>>>24))+((1540483477*(r>>>16)&65535)<<16)),n-=4,++a;switch(n){case 3:i^=(255&t.charCodeAt(a+2))<<16;case 2:i^=(255&t.charCodeAt(a+1))<<8;case 1:i=1540483477*(65535&(i^=255&t.charCodeAt(a)))+((1540483477*(i>>>16)&65535)<<16);}return i=1540483477*(65535&(i^=i>>>13))+((1540483477*(i>>>16)&65535)<<16),(i^=i>>>15)>>>0};})),_a=ba,Aa=wa;_a.murmur3=ba,_a.murmur2=Aa;var Sa=function(){this.ids=[],this.positions=[],this.indexed=!1;};Sa.prototype.add=function(t,e,r,n){this.ids.push(Ia(t)),this.positions.push(e,r,n);},Sa.prototype.getPositions=function(t){for(var e=Ia(t),r=0,n=this.ids.length-1;r<n;){var i=r+n>>1;this.ids[i]>=e?n=i:r=i+1;}for(var a=[];this.ids[r]===e;)a.push({index:this.positions[3*r],start:this.positions[3*r+1],end:this.positions[3*r+2]}),r++;return a},Sa.serialize=function(t,e){var r=new Float64Array(t.ids),n=new Uint32Array(t.positions);return function t(e,r,n,i){if(!(n>=i)){for(var a=e[n+i>>1],o=n-1,s=i+1;;){do{o++;}while(e[o]<a);do{s--;}while(e[s]>a);if(o>=s)break;za(e,o,s),za(r,3*o,3*s),za(r,3*o+1,3*s+1),za(r,3*o+2,3*s+2);}t(e,r,n,s),t(e,r,s+1,i);}}(r,n,0,r.length-1),e&&e.push(r.buffer,n.buffer),{ids:r,positions:n}},Sa.deserialize=function(t){var e=new Sa;return e.ids=t.ids,e.positions=t.positions,e.indexed=!0,e};var ka=Math.pow(2,53)-1;function Ia(t){var e=+t;return !isNaN(e)&&e<=ka?e:_a(String(t))}function za(t,e,r){var n=t[e];t[e]=t[r],t[r]=n;}Hn("FeaturePositionMap",Sa);var Ca=function(t,e){this.gl=t.gl,this.location=e;},Ma=function(t){function e(e,r){t.call(this,e,r),this.current=0;}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.set=function(t){this.current!==t&&(this.current=t,this.gl.uniform1i(this.location,t));},e}(Ca),Ta=function(t){function e(e,r){t.call(this,e,r),this.current=0;}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.set=function(t){this.current!==t&&(this.current=t,this.gl.uniform1f(this.location,t));},e}(Ca),Ea=function(t){function e(e,r){t.call(this,e,r),this.current=[0,0];}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.set=function(t){t[0]===this.current[0]&&t[1]===this.current[1]||(this.current=t,this.gl.uniform2f(this.location,t[0],t[1]));},e}(Ca),Pa=function(t){function e(e,r){t.call(this,e,r),this.current=[0,0,0];}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.set=function(t){t[0]===this.current[0]&&t[1]===this.current[1]&&t[2]===this.current[2]||(this.current=t,this.gl.uniform3f(this.location,t[0],t[1],t[2]));},e}(Ca),Ba=function(t){function e(e,r){t.call(this,e,r),this.current=[0,0,0,0];}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.set=function(t){t[0]===this.current[0]&&t[1]===this.current[1]&&t[2]===this.current[2]&&t[3]===this.current[3]||(this.current=t,this.gl.uniform4f(this.location,t[0],t[1],t[2],t[3]));},e}(Ca),Va=function(t){function e(e,r){t.call(this,e,r),this.current=$t.transparent;}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.set=function(t){t.r===this.current.r&&t.g===this.current.g&&t.b===this.current.b&&t.a===this.current.a||(this.current=t,this.gl.uniform4f(this.location,t.r,t.g,t.b,t.a));},e}(Ca),Fa=new Float32Array(16),Da=function(t){function e(e,r){t.call(this,e,r),this.current=Fa;}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.set=function(t){if(t[12]!==this.current[12]||t[0]!==this.current[0])return this.current=t,void this.gl.uniformMatrix4fv(this.location,!1,t);for(var e=1;e<16;e++)if(t[e]!==this.current[e]){this.current=t,this.gl.uniformMatrix4fv(this.location,!1,t);break}},e}(Ca);function La(t){return [ga(255*t.r,255*t.g),ga(255*t.b,255*t.a)]}var Ra=function(t,e,r){this.value=t,this.uniformNames=e.map((function(t){return "u_"+t})),this.type=r;};Ra.prototype.setUniform=function(t,e,r){t.set(r.constantOr(this.value));},Ra.prototype.getBinding=function(t,e,r){return "color"===this.type?new Va(t,e):new Ta(t,e)};var Oa=function(t,e){this.uniformNames=e.map((function(t){return "u_"+t})),this.patternFrom=null,this.patternTo=null,this.pixelRatioFrom=1,this.pixelRatioTo=1;};Oa.prototype.setConstantPatternPositions=function(t,e){this.pixelRatioFrom=e.pixelRatio,this.pixelRatioTo=t.pixelRatio,this.patternFrom=e.tlbr,this.patternTo=t.tlbr;},Oa.prototype.setUniform=function(t,e,r,n){var i="u_pattern_to"===n?this.patternTo:"u_pattern_from"===n?this.patternFrom:"u_pixel_ratio_to"===n?this.pixelRatioTo:"u_pixel_ratio_from"===n?this.pixelRatioFrom:null;i&&t.set(i);},Oa.prototype.getBinding=function(t,e,r){return "u_pattern"===r.substr(0,9)?new Ba(t,e):new Ta(t,e)};var Ua=function(t,e,r,n){this.expression=t,this.type=r,this.maxValue=0,this.paintVertexAttributes=e.map((function(t){return {name:"a_"+t,type:"Float32",components:"color"===r?2:1,offset:0}})),this.paintVertexArray=new n;};Ua.prototype.populatePaintArray=function(t,e,r,n,i){var a=this.paintVertexArray.length,o=this.expression.evaluate(new gi(0),e,{},n,[],i);this.paintVertexArray.resize(t),this._setPaintValue(a,t,o);},Ua.prototype.updatePaintArray=function(t,e,r,n){var i=this.expression.evaluate({zoom:0},r,n);this._setPaintValue(t,e,i);},Ua.prototype._setPaintValue=function(t,e,r){if("color"===this.type)for(var n=La(r),i=t;i<e;i++)this.paintVertexArray.emplace(i,n[0],n[1]);else{for(var a=t;a<e;a++)this.paintVertexArray.emplace(a,r);this.maxValue=Math.max(this.maxValue,Math.abs(r));}},Ua.prototype.upload=function(t){this.paintVertexArray&&this.paintVertexArray.arrayBuffer&&(this.paintVertexBuffer&&this.paintVertexBuffer.buffer?this.paintVertexBuffer.updateData(this.paintVertexArray):this.paintVertexBuffer=t.createVertexBuffer(this.paintVertexArray,this.paintVertexAttributes,this.expression.isStateDependent));},Ua.prototype.destroy=function(){this.paintVertexBuffer&&this.paintVertexBuffer.destroy();};var ja=function(t,e,r,n,i,a){this.expression=t,this.uniformNames=e.map((function(t){return "u_"+t+"_t"})),this.type=r,this.useIntegerZoom=n,this.zoom=i,this.maxValue=0,this.paintVertexAttributes=e.map((function(t){return {name:"a_"+t,type:"Float32",components:"color"===r?4:2,offset:0}})),this.paintVertexArray=new a;};ja.prototype.populatePaintArray=function(t,e,r,n,i){var a=this.expression.evaluate(new gi(this.zoom),e,{},n,[],i),o=this.expression.evaluate(new gi(this.zoom+1),e,{},n,[],i),s=this.paintVertexArray.length;this.paintVertexArray.resize(t),this._setPaintValue(s,t,a,o);},ja.prototype.updatePaintArray=function(t,e,r,n){var i=this.expression.evaluate({zoom:this.zoom},r,n),a=this.expression.evaluate({zoom:this.zoom+1},r,n);this._setPaintValue(t,e,i,a);},ja.prototype._setPaintValue=function(t,e,r,n){if("color"===this.type)for(var i=La(r),a=La(n),o=t;o<e;o++)this.paintVertexArray.emplace(o,i[0],i[1],a[0],a[1]);else{for(var s=t;s<e;s++)this.paintVertexArray.emplace(s,r,n);this.maxValue=Math.max(this.maxValue,Math.abs(r),Math.abs(n));}},ja.prototype.upload=function(t){this.paintVertexArray&&this.paintVertexArray.arrayBuffer&&(this.paintVertexBuffer&&this.paintVertexBuffer.buffer?this.paintVertexBuffer.updateData(this.paintVertexArray):this.paintVertexBuffer=t.createVertexBuffer(this.paintVertexArray,this.paintVertexAttributes,this.expression.isStateDependent));},ja.prototype.destroy=function(){this.paintVertexBuffer&&this.paintVertexBuffer.destroy();},ja.prototype.setUniform=function(t,e){var r=this.useIntegerZoom?Math.floor(e.zoom):e.zoom,n=u(this.expression.interpolationFactor(r,this.zoom,this.zoom+1),0,1);t.set(n);},ja.prototype.getBinding=function(t,e,r){return new Ta(t,e)};var qa=function(t,e,r,n,i,a){this.expression=t,this.type=e,this.useIntegerZoom=r,this.zoom=n,this.layerId=a,this.zoomInPaintVertexArray=new i,this.zoomOutPaintVertexArray=new i;};qa.prototype.populatePaintArray=function(t,e,r){var n=this.zoomInPaintVertexArray.length;this.zoomInPaintVertexArray.resize(t),this.zoomOutPaintVertexArray.resize(t),this._setPaintValues(n,t,e.patterns&&e.patterns[this.layerId],r);},qa.prototype.updatePaintArray=function(t,e,r,n,i){this._setPaintValues(t,e,r.patterns&&r.patterns[this.layerId],i);},qa.prototype._setPaintValues=function(t,e,r,n){if(n&&r){var i=n[r.min],a=n[r.mid],o=n[r.max];if(i&&a&&o)for(var s=t;s<e;s++)this.zoomInPaintVertexArray.emplace(s,a.tl[0],a.tl[1],a.br[0],a.br[1],i.tl[0],i.tl[1],i.br[0],i.br[1],a.pixelRatio,i.pixelRatio),this.zoomOutPaintVertexArray.emplace(s,a.tl[0],a.tl[1],a.br[0],a.br[1],o.tl[0],o.tl[1],o.br[0],o.br[1],a.pixelRatio,o.pixelRatio);}},qa.prototype.upload=function(t){this.zoomInPaintVertexArray&&this.zoomInPaintVertexArray.arrayBuffer&&this.zoomOutPaintVertexArray&&this.zoomOutPaintVertexArray.arrayBuffer&&(this.zoomInPaintVertexBuffer=t.createVertexBuffer(this.zoomInPaintVertexArray,xa.members,this.expression.isStateDependent),this.zoomOutPaintVertexBuffer=t.createVertexBuffer(this.zoomOutPaintVertexArray,xa.members,this.expression.isStateDependent));},qa.prototype.destroy=function(){this.zoomOutPaintVertexBuffer&&this.zoomOutPaintVertexBuffer.destroy(),this.zoomInPaintVertexBuffer&&this.zoomInPaintVertexBuffer.destroy();};var Na=function(t,e,r,n){this.binders={},this.layoutAttributes=n,this._buffers=[];var i=[];for(var a in t.paint._values)if(r(a)){var o=t.paint.get(a);if(o instanceof ki&&Nr(o.property.specification)){var s=Xa(a,t.type),u=o.value,l=o.property.specification.type,p=o.property.useIntegerZoom,c=o.property.specification["property-type"],h="cross-faded"===c||"cross-faded-data-driven"===c;if("constant"===u.kind)this.binders[a]=h?new Oa(u.value,s):new Ra(u.value,s,l),i.push("/u_"+a);else if("source"===u.kind||h){var f=Ga(a,l,"source");this.binders[a]=h?new qa(u,l,p,e,f,t.id):new Ua(u,s,l,f),i.push("/a_"+a);}else{var y=Ga(a,l,"composite");this.binders[a]=new ja(u,s,l,p,e,y),i.push("/z_"+a);}}}this.cacheKey=i.sort().join("");};Na.prototype.getMaxValue=function(t){var e=this.binders[t];return e instanceof Ua||e instanceof ja?e.maxValue:0},Na.prototype.populatePaintArrays=function(t,e,r,n,i){for(var a in this.binders){var o=this.binders[a];(o instanceof Ua||o instanceof ja||o instanceof qa)&&o.populatePaintArray(t,e,r,n,i);}},Na.prototype.setConstantPatternPositions=function(t,e){for(var r in this.binders){var n=this.binders[r];n instanceof Oa&&n.setConstantPatternPositions(t,e);}},Na.prototype.updatePaintArrays=function(t,e,r,n,i){var a=!1;for(var o in t)for(var s=0,u=e.getPositions(o);s<u.length;s+=1){var l=u[s],p=r.feature(l.index);for(var c in this.binders){var h=this.binders[c];if((h instanceof Ua||h instanceof ja||h instanceof qa)&&!0===h.expression.isStateDependent){var f=n.paint.get(c);h.expression=f.value,h.updatePaintArray(l.start,l.end,p,t[o],i),a=!0;}}}return a},Na.prototype.defines=function(){var t=[];for(var e in this.binders){var r=this.binders[e];(r instanceof Ra||r instanceof Oa)&&t.push.apply(t,r.uniformNames.map((function(t){return "#define HAS_UNIFORM_"+t})));}return t},Na.prototype.getPaintVertexBuffers=function(){return this._buffers},Na.prototype.getUniforms=function(t,e){var r=[];for(var n in this.binders){var i=this.binders[n];if(i instanceof Ra||i instanceof Oa||i instanceof ja)for(var a=0,o=i.uniformNames;a<o.length;a+=1){var s=o[a];if(e[s]){var u=i.getBinding(t,e[s],s);r.push({name:s,property:n,binding:u});}}}return r},Na.prototype.setUniforms=function(t,e,r,n){for(var i=0,a=e;i<a.length;i+=1){var o=a[i],s=o.name,u=o.property;this.binders[u].setUniform(o.binding,n,r.get(u),s);}},Na.prototype.updatePaintBuffers=function(t){for(var e in this._buffers=[],this.binders){var r=this.binders[e];if(t&&r instanceof qa){var n=2===t.fromScale?r.zoomInPaintVertexBuffer:r.zoomOutPaintVertexBuffer;n&&this._buffers.push(n);}else(r instanceof Ua||r instanceof ja)&&r.paintVertexBuffer&&this._buffers.push(r.paintVertexBuffer);}},Na.prototype.upload=function(t){for(var e in this.binders){var r=this.binders[e];(r instanceof Ua||r instanceof ja||r instanceof qa)&&r.upload(t);}this.updatePaintBuffers();},Na.prototype.destroy=function(){for(var t in this.binders){var e=this.binders[t];(e instanceof Ua||e instanceof ja||e instanceof qa)&&e.destroy();}};var Ka=function(t,e,r,n){void 0===n&&(n=function(){return !0}),this.programConfigurations={};for(var i=0,a=e;i<a.length;i+=1){var o=a[i];this.programConfigurations[o.id]=new Na(o,r,n,t);}this.needsUpload=!1,this._featureMap=new Sa,this._bufferOffset=0;};function Xa(t,e){return {"text-opacity":["opacity"],"icon-opacity":["opacity"],"text-color":["fill_color"],"icon-color":["fill_color"],"text-halo-color":["halo_color"],"icon-halo-color":["halo_color"],"text-halo-blur":["halo_blur"],"icon-halo-blur":["halo_blur"],"text-halo-width":["halo_width"],"icon-halo-width":["halo_width"],"line-gap-width":["gapwidth"],"line-pattern":["pattern_to","pattern_from","pixel_ratio_to","pixel_ratio_from"],"fill-pattern":["pattern_to","pattern_from","pixel_ratio_to","pixel_ratio_from"],"fill-extrusion-pattern":["pattern_to","pattern_from","pixel_ratio_to","pixel_ratio_from"]}[t]||[t.replace(e+"-","").replace(/-/g,"_")]}function Ga(t,e,r){var n={color:{source:ia,composite:aa},number:{source:Wi,composite:ia}},i=function(t){return {"line-pattern":{source:Ni,composite:Ni},"fill-pattern":{source:Ni,composite:Ni},"fill-extrusion-pattern":{source:Ni,composite:Ni}}[t]}(t);return i&&i[r]||n[e][r]}Ka.prototype.populatePaintArrays=function(t,e,r,n,i,a){for(var o in this.programConfigurations)this.programConfigurations[o].populatePaintArrays(t,e,n,i,a);void 0!==e.id&&this._featureMap.add(e.id,r,this._bufferOffset,t),this._bufferOffset=t,this.needsUpload=!0;},Ka.prototype.updatePaintArrays=function(t,e,r,n){for(var i=0,a=r;i<a.length;i+=1){var o=a[i];this.needsUpload=this.programConfigurations[o.id].updatePaintArrays(t,this._featureMap,e,o,n)||this.needsUpload;}},Ka.prototype.get=function(t){return this.programConfigurations[t]},Ka.prototype.upload=function(t){if(this.needsUpload){for(var e in this.programConfigurations)this.programConfigurations[e].upload(t);this.needsUpload=!1;}},Ka.prototype.destroy=function(){for(var t in this.programConfigurations)this.programConfigurations[t].destroy();},Hn("ConstantBinder",Ra),Hn("CrossFadedConstantBinder",Oa),Hn("SourceExpressionBinder",Ua),Hn("CrossFadedCompositeBinder",qa),Hn("CompositeExpressionBinder",ja),Hn("ProgramConfiguration",Na,{omit:["_buffers"]}),Hn("ProgramConfigurationSet",Ka);var Za={min:-1*Math.pow(2,14),max:Math.pow(2,14)-1};function Ja(t){for(var e=ze/t.extent,r=t.loadGeometry(),n=0;n<r.length;n++)for(var i=r[n],a=0;a<i.length;a++){var o=i[a];o.x=Math.round(o.x*e),o.y=Math.round(o.y*e),(o.x<Za.min||o.x>Za.max||o.y<Za.min||o.y>Za.max)&&(w("Geometry exceeds allowed extent, reduce your vector tile buffer size"),o.x=u(o.x,Za.min,Za.max),o.y=u(o.y,Za.min,Za.max));}return r}function Ha(t,e,r,n,i){t.emplaceBack(2*e+(n+1)/2,2*r+(i+1)/2);}var Ya=function(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map((function(t){return t.id})),this.index=t.index,this.hasPattern=!1,this.layoutVertexArray=new Oi,this.indexArray=new ea,this.segments=new va,this.programConfigurations=new Ka(ma,t.layers,t.zoom),this.stateDependentLayerIds=this.layers.filter((function(t){return t.isStateDependent()})).map((function(t){return t.id}));};function $a(t,e){for(var r=0;r<t.length;r++)if(oo(e,t[r]))return !0;for(var n=0;n<e.length;n++)if(oo(t,e[n]))return !0;return !!eo(t,e)}function Wa(t,e,r){return !!oo(t,e)||!!no(e,t,r)}function Qa(t,e){if(1===t.length)return ao(e,t[0]);for(var r=0;r<e.length;r++)for(var n=e[r],i=0;i<n.length;i++)if(oo(t,n[i]))return !0;for(var a=0;a<t.length;a++)if(ao(e,t[a]))return !0;for(var o=0;o<e.length;o++)if(eo(t,e[o]))return !0;return !1}function to(t,e,r){if(t.length>1){if(eo(t,e))return !0;for(var n=0;n<e.length;n++)if(no(e[n],t,r))return !0}for(var i=0;i<t.length;i++)if(no(t[i],e,r))return !0;return !1}function eo(t,e){if(0===t.length||0===e.length)return !1;for(var r=0;r<t.length-1;r++)for(var n=t[r],i=t[r+1],a=0;a<e.length-1;a++)if(ro(n,i,e[a],e[a+1]))return !0;return !1}function ro(t,e,r,n){return _(t,r,n)!==_(e,r,n)&&_(t,e,r)!==_(t,e,n)}function no(t,e,r){var n=r*r;if(1===e.length)return t.distSqr(e[0])<n;for(var i=1;i<e.length;i++)if(io(t,e[i-1],e[i])<n)return !0;return !1}function io(t,e,r){var n=e.distSqr(r);if(0===n)return t.distSqr(e);var i=((t.x-e.x)*(r.x-e.x)+(t.y-e.y)*(r.y-e.y))/n;return t.distSqr(i<0?e:i>1?r:r.sub(e)._mult(i)._add(e))}function ao(t,e){for(var r,n,i,a=!1,o=0;o<t.length;o++)for(var s=0,u=(r=t[o]).length-1;s<r.length;u=s++)(n=r[s]).y>e.y!=(i=r[u]).y>e.y&&e.x<(i.x-n.x)*(e.y-n.y)/(i.y-n.y)+n.x&&(a=!a);return a}function oo(t,e){for(var r=!1,n=0,i=t.length-1;n<t.length;i=n++){var a=t[n],o=t[i];a.y>e.y!=o.y>e.y&&e.x<(o.x-a.x)*(e.y-a.y)/(o.y-a.y)+a.x&&(r=!r);}return r}function so(t,e,r){var n=r[0],i=r[2];if(t.x<n.x&&e.x<n.x||t.x>i.x&&e.x>i.x||t.y<n.y&&e.y<n.y||t.y>i.y&&e.y>i.y)return !1;var a=_(t,e,r[0]);return a!==_(t,e,r[1])||a!==_(t,e,r[2])||a!==_(t,e,r[3])}function uo(t,e,r){var n=e.paint.get(t).value;return "constant"===n.kind?n.value:r.programConfigurations.get(e.id).getMaxValue(t)}function lo(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1])}function po(t,e,r,n,a){if(!e[0]&&!e[1])return t;var o=i.convert(e)._mult(a);"viewport"===r&&o._rotate(-n);for(var s=[],u=0;u<t.length;u++)s.push(t[u].sub(o));return s}Ya.prototype.populate=function(t,e,r){var n=this.layers[0],i=[],a=null;"circle"===n.type&&(a=n.layout.get("circle-sort-key"));for(var o=0,s=t;o<s.length;o+=1){var u=s[o],l=u.feature,p=u.id,c=u.index,h=u.sourceLayerIndex,f=this.layers[0]._featureFilter.needGeometry,y={type:l.type,id:p,properties:l.properties,geometry:f?Ja(l):[]};if(this.layers[0]._featureFilter.filter(new gi(this.zoom),y,r)){f||(y.geometry=Ja(l));var d=a?a.evaluate(y,{},r):void 0;i.push({id:p,properties:l.properties,type:l.type,sourceLayerIndex:h,index:c,geometry:y.geometry,patterns:{},sortKey:d});}}a&&i.sort((function(t,e){return t.sortKey-e.sortKey}));for(var m=0,v=i;m<v.length;m+=1){var g=v[m],x=g.geometry,b=g.index,w=g.sourceLayerIndex,_=t[b].feature;this.addFeature(g,x,b,r),e.featureIndex.insert(_,x,b,w,this.index);}},Ya.prototype.update=function(t,e,r){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,e,this.stateDependentLayers,r);},Ya.prototype.isEmpty=function(){return 0===this.layoutVertexArray.length},Ya.prototype.uploadPending=function(){return !this.uploaded||this.programConfigurations.needsUpload},Ya.prototype.upload=function(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,ma),this.indexBuffer=t.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(t),this.uploaded=!0;},Ya.prototype.destroy=function(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy());},Ya.prototype.addFeature=function(t,e,r,n){for(var i=0,a=e;i<a.length;i+=1)for(var o=0,s=a[i];o<s.length;o+=1){var u=s[o],l=u.x,p=u.y;if(!(l<0||l>=ze||p<0||p>=ze)){var c=this.segments.prepareSegment(4,this.layoutVertexArray,this.indexArray,t.sortKey),h=c.vertexLength;Ha(this.layoutVertexArray,l,p,-1,-1),Ha(this.layoutVertexArray,l,p,1,-1),Ha(this.layoutVertexArray,l,p,1,1),Ha(this.layoutVertexArray,l,p,-1,1),this.indexArray.emplaceBack(h,h+1,h+2),this.indexArray.emplaceBack(h,h+3,h+2),c.vertexLength+=4,c.primitiveLength+=2;}}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,r,{},n);},Hn("CircleBucket",Ya,{omit:["layers"]});var co,ho=new Pi({"circle-sort-key":new Ci(Ct.layout_circle["circle-sort-key"])}),fo={paint:new Pi({"circle-radius":new Ci(Ct.paint_circle["circle-radius"]),"circle-color":new Ci(Ct.paint_circle["circle-color"]),"circle-blur":new Ci(Ct.paint_circle["circle-blur"]),"circle-opacity":new Ci(Ct.paint_circle["circle-opacity"]),"circle-translate":new zi(Ct.paint_circle["circle-translate"]),"circle-translate-anchor":new zi(Ct.paint_circle["circle-translate-anchor"]),"circle-pitch-scale":new zi(Ct.paint_circle["circle-pitch-scale"]),"circle-pitch-alignment":new zi(Ct.paint_circle["circle-pitch-alignment"]),"circle-stroke-width":new Ci(Ct.paint_circle["circle-stroke-width"]),"circle-stroke-color":new Ci(Ct.paint_circle["circle-stroke-color"]),"circle-stroke-opacity":new Ci(Ct.paint_circle["circle-stroke-opacity"])}),layout:ho},yo="undefined"!=typeof Float32Array?Float32Array:Array;function mo(t,e,r){var n=e[0],i=e[1],a=e[2],o=e[3];return t[0]=r[0]*n+r[4]*i+r[8]*a+r[12]*o,t[1]=r[1]*n+r[5]*i+r[9]*a+r[13]*o,t[2]=r[2]*n+r[6]*i+r[10]*a+r[14]*o,t[3]=r[3]*n+r[7]*i+r[11]*a+r[15]*o,t}Math.hypot||(Math.hypot=function(){for(var t=arguments,e=0,r=arguments.length;r--;)e+=t[r]*t[r];return Math.sqrt(e)}),co=new yo(3),yo!=Float32Array&&(co[0]=0,co[1]=0,co[2]=0),function(){var t=new yo(4);yo!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0);}();var vo=(function(){var t=new yo(2);yo!=Float32Array&&(t[0]=0,t[1]=0);}(),function(t){function e(e){t.call(this,e,fo);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.createBucket=function(t){return new Ya(t)},e.prototype.queryRadius=function(t){var e=t;return uo("circle-radius",this,e)+uo("circle-stroke-width",this,e)+lo(this.paint.get("circle-translate"))},e.prototype.queryIntersectsFeature=function(t,e,r,n,i,a,o,s){for(var u=po(t,this.paint.get("circle-translate"),this.paint.get("circle-translate-anchor"),a.angle,o),l=this.paint.get("circle-radius").evaluate(e,r)+this.paint.get("circle-stroke-width").evaluate(e,r),p="map"===this.paint.get("circle-pitch-alignment"),c=p?u:function(t,e){return t.map((function(t){return go(t,e)}))}(u,s),h=p?l*o:l,f=0,y=n;f<y.length;f+=1)for(var d=0,m=y[f];d<m.length;d+=1){var v=m[d],g=p?v:go(v,s),x=h,b=mo([],[v.x,v.y,0,1],s);if("viewport"===this.paint.get("circle-pitch-scale")&&"map"===this.paint.get("circle-pitch-alignment")?x*=b[3]/a.cameraToCenterDistance:"map"===this.paint.get("circle-pitch-scale")&&"viewport"===this.paint.get("circle-pitch-alignment")&&(x*=a.cameraToCenterDistance/b[3]),Wa(c,g,x))return !0}return !1},e}(Bi));function go(t,e){var r=mo([],[t.x,t.y,0,1],e);return new i(r[0]/r[3],r[1]/r[3])}var xo=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e}(Ya);function bo(t,e,r,n){var i=e.width,a=e.height;if(n){if(n instanceof Uint8ClampedArray)n=new Uint8Array(n.buffer);else if(n.length!==i*a*r)throw new RangeError("mismatched image size")}else n=new Uint8Array(i*a*r);return t.width=i,t.height=a,t.data=n,t}function wo(t,e,r){var n=e.width,i=e.height;if(n!==t.width||i!==t.height){var a=bo({},{width:n,height:i},r);_o(t,a,{x:0,y:0},{x:0,y:0},{width:Math.min(t.width,n),height:Math.min(t.height,i)},r),t.width=n,t.height=i,t.data=a.data;}}function _o(t,e,r,n,i,a){if(0===i.width||0===i.height)return e;if(i.width>t.width||i.height>t.height||r.x>t.width-i.width||r.y>t.height-i.height)throw new RangeError("out of range source coordinates for image copy");if(i.width>e.width||i.height>e.height||n.x>e.width-i.width||n.y>e.height-i.height)throw new RangeError("out of range destination coordinates for image copy");for(var o=t.data,s=e.data,u=0;u<i.height;u++)for(var l=((r.y+u)*t.width+r.x)*a,p=((n.y+u)*e.width+n.x)*a,c=0;c<i.width*a;c++)s[p+c]=o[l+c];return e}Hn("HeatmapBucket",xo,{omit:["layers"]});var Ao=function(t,e){bo(this,t,1,e);};Ao.prototype.resize=function(t){wo(this,t,1);},Ao.prototype.clone=function(){return new Ao({width:this.width,height:this.height},new Uint8Array(this.data))},Ao.copy=function(t,e,r,n,i){_o(t,e,r,n,i,1);};var So=function(t,e){bo(this,t,4,e);};So.prototype.resize=function(t){wo(this,t,4);},So.prototype.replace=function(t,e){e?this.data.set(t):this.data=t instanceof Uint8ClampedArray?new Uint8Array(t.buffer):t;},So.prototype.clone=function(){return new So({width:this.width,height:this.height},new Uint8Array(this.data))},So.copy=function(t,e,r,n,i){_o(t,e,r,n,i,4);},Hn("AlphaImage",Ao),Hn("RGBAImage",So);var ko={paint:new Pi({"heatmap-radius":new Ci(Ct.paint_heatmap["heatmap-radius"]),"heatmap-weight":new Ci(Ct.paint_heatmap["heatmap-weight"]),"heatmap-intensity":new zi(Ct.paint_heatmap["heatmap-intensity"]),"heatmap-color":new Ei(Ct.paint_heatmap["heatmap-color"]),"heatmap-opacity":new zi(Ct.paint_heatmap["heatmap-opacity"])})};function Io(t,e){for(var r=new Uint8Array(1024),n={},i=0,a=0;i<256;i++,a+=4){n[e]=i/255;var o=t.evaluate(n);r[a+0]=Math.floor(255*o.r/o.a),r[a+1]=Math.floor(255*o.g/o.a),r[a+2]=Math.floor(255*o.b/o.a),r[a+3]=Math.floor(255*o.a);}return new So({width:256,height:1},r)}var zo=function(t){function e(e){t.call(this,e,ko),this._updateColorRamp();}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.createBucket=function(t){return new xo(t)},e.prototype._handleSpecialPaintPropertyUpdate=function(t){"heatmap-color"===t&&this._updateColorRamp();},e.prototype._updateColorRamp=function(){this.colorRamp=Io(this._transitionablePaint._values["heatmap-color"].value.expression,"heatmapDensity"),this.colorRampTexture=null;},e.prototype.resize=function(){this.heatmapFbo&&(this.heatmapFbo.destroy(),this.heatmapFbo=null);},e.prototype.queryRadius=function(){return 0},e.prototype.queryIntersectsFeature=function(){return !1},e.prototype.hasOffscreenPass=function(){return 0!==this.paint.get("heatmap-opacity")&&"none"!==this.visibility},e}(Bi),Co={paint:new Pi({"hillshade-illumination-direction":new zi(Ct.paint_hillshade["hillshade-illumination-direction"]),"hillshade-illumination-anchor":new zi(Ct.paint_hillshade["hillshade-illumination-anchor"]),"hillshade-exaggeration":new zi(Ct.paint_hillshade["hillshade-exaggeration"]),"hillshade-shadow-color":new zi(Ct.paint_hillshade["hillshade-shadow-color"]),"hillshade-highlight-color":new zi(Ct.paint_hillshade["hillshade-highlight-color"]),"hillshade-accent-color":new zi(Ct.paint_hillshade["hillshade-accent-color"])})},Mo=function(t){function e(e){t.call(this,e,Co);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.hasOffscreenPass=function(){return 0!==this.paint.get("hillshade-exaggeration")&&"none"!==this.visibility},e}(Bi),To=Li([{name:"a_pos",components:2,type:"Int16"}],4).members,Eo=Bo,Po=Bo;function Bo(t,e,r){r=r||2;var n,i,a,o,s,u,l,p=e&&e.length,c=p?e[0]*r:t.length,h=Vo(t,0,c,r,!0),f=[];if(!h||h.next===h.prev)return f;if(p&&(h=function(t,e,r,n){var i,a,o,s=[];for(i=0,a=e.length;i<a;i++)(o=Vo(t,e[i]*n,i<a-1?e[i+1]*n:t.length,n,!1))===o.next&&(o.steiner=!0),s.push(Xo(o));for(s.sort(jo),i=0;i<s.length;i++)qo(s[i],r),r=Fo(r,r.next);return r}(t,e,h,r)),t.length>80*r){n=a=t[0],i=o=t[1];for(var y=r;y<c;y+=r)(s=t[y])<n&&(n=s),(u=t[y+1])<i&&(i=u),s>a&&(a=s),u>o&&(o=u);l=0!==(l=Math.max(a-n,o-i))?1/l:0;}return Do(h,f,r,n,i,l),f}function Vo(t,e,r,n,i){var a,o;if(i===is(t,e,r,n)>0)for(a=e;a<r;a+=n)o=es(a,t[a],t[a+1],o);else for(a=r-n;a>=e;a-=n)o=es(a,t[a],t[a+1],o);return o&&Ho(o,o.next)&&(rs(o),o=o.next),o}function Fo(t,e){if(!t)return t;e||(e=t);var r,n=t;do{if(r=!1,n.steiner||!Ho(n,n.next)&&0!==Jo(n.prev,n,n.next))n=n.next;else{if(rs(n),(n=e=n.prev)===n.next)break;r=!0;}}while(r||n!==e);return e}function Do(t,e,r,n,i,a,o){if(t){!o&&a&&function(t,e,r,n){var i=t;do{null===i.z&&(i.z=Ko(i.x,i.y,e,r,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;}while(i!==t);i.prevZ.nextZ=null,i.prevZ=null,function(t){var e,r,n,i,a,o,s,u,l=1;do{for(r=t,t=null,a=null,o=0;r;){for(o++,n=r,s=0,e=0;e<l&&(s++,n=n.nextZ);e++);for(u=l;s>0||u>0&&n;)0!==s&&(0===u||!n||r.z<=n.z)?(i=r,r=r.nextZ,s--):(i=n,n=n.nextZ,u--),a?a.nextZ=i:t=i,i.prevZ=a,a=i;r=n;}a.nextZ=null,l*=2;}while(o>1)}(i);}(t,n,i,a);for(var s,u,l=t;t.prev!==t.next;)if(s=t.prev,u=t.next,a?Ro(t,n,i,a):Lo(t))e.push(s.i/r),e.push(t.i/r),e.push(u.i/r),rs(t),t=u.next,l=u.next;else if((t=u)===l){o?1===o?Do(t=Oo(Fo(t),e,r),e,r,n,i,a,2):2===o&&Uo(t,e,r,n,i,a):Do(Fo(t),e,r,n,i,a,1);break}}}function Lo(t){var e=t.prev,r=t,n=t.next;if(Jo(e,r,n)>=0)return !1;for(var i=t.next.next;i!==t.prev;){if(Go(e.x,e.y,r.x,r.y,n.x,n.y,i.x,i.y)&&Jo(i.prev,i,i.next)>=0)return !1;i=i.next;}return !0}function Ro(t,e,r,n){var i=t.prev,a=t,o=t.next;if(Jo(i,a,o)>=0)return !1;for(var s=i.x>a.x?i.x>o.x?i.x:o.x:a.x>o.x?a.x:o.x,u=i.y>a.y?i.y>o.y?i.y:o.y:a.y>o.y?a.y:o.y,l=Ko(i.x<a.x?i.x<o.x?i.x:o.x:a.x<o.x?a.x:o.x,i.y<a.y?i.y<o.y?i.y:o.y:a.y<o.y?a.y:o.y,e,r,n),p=Ko(s,u,e,r,n),c=t.prevZ,h=t.nextZ;c&&c.z>=l&&h&&h.z<=p;){if(c!==t.prev&&c!==t.next&&Go(i.x,i.y,a.x,a.y,o.x,o.y,c.x,c.y)&&Jo(c.prev,c,c.next)>=0)return !1;if(c=c.prevZ,h!==t.prev&&h!==t.next&&Go(i.x,i.y,a.x,a.y,o.x,o.y,h.x,h.y)&&Jo(h.prev,h,h.next)>=0)return !1;h=h.nextZ;}for(;c&&c.z>=l;){if(c!==t.prev&&c!==t.next&&Go(i.x,i.y,a.x,a.y,o.x,o.y,c.x,c.y)&&Jo(c.prev,c,c.next)>=0)return !1;c=c.prevZ;}for(;h&&h.z<=p;){if(h!==t.prev&&h!==t.next&&Go(i.x,i.y,a.x,a.y,o.x,o.y,h.x,h.y)&&Jo(h.prev,h,h.next)>=0)return !1;h=h.nextZ;}return !0}function Oo(t,e,r){var n=t;do{var i=n.prev,a=n.next.next;!Ho(i,a)&&Yo(i,n,n.next,a)&&Qo(i,a)&&Qo(a,i)&&(e.push(i.i/r),e.push(n.i/r),e.push(a.i/r),rs(n),rs(n.next),n=t=a),n=n.next;}while(n!==t);return Fo(n)}function Uo(t,e,r,n,i,a){var o=t;do{for(var s=o.next.next;s!==o.prev;){if(o.i!==s.i&&Zo(o,s)){var u=ts(o,s);return o=Fo(o,o.next),u=Fo(u,u.next),Do(o,e,r,n,i,a),void Do(u,e,r,n,i,a)}s=s.next;}o=o.next;}while(o!==t)}function jo(t,e){return t.x-e.x}function qo(t,e){if(e=function(t,e){var r,n=e,i=t.x,a=t.y,o=-1/0;do{if(a<=n.y&&a>=n.next.y&&n.next.y!==n.y){var s=n.x+(a-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(s<=i&&s>o){if(o=s,s===i){if(a===n.y)return n;if(a===n.next.y)return n.next}r=n.x<n.next.x?n:n.next;}}n=n.next;}while(n!==e);if(!r)return null;if(i===o)return r;var u,l=r,p=r.x,c=r.y,h=1/0;n=r;do{i>=n.x&&n.x>=p&&i!==n.x&&Go(a<c?i:o,a,p,c,a<c?o:i,a,n.x,n.y)&&(u=Math.abs(a-n.y)/(i-n.x),Qo(n,t)&&(u<h||u===h&&(n.x>r.x||n.x===r.x&&No(r,n)))&&(r=n,h=u)),n=n.next;}while(n!==l);return r}(t,e)){var r=ts(e,t);Fo(e,e.next),Fo(r,r.next);}}function No(t,e){return Jo(t.prev,t,e.prev)<0&&Jo(e.next,t,t.next)<0}function Ko(t,e,r,n,i){return (t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-r)*i)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-n)*i)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function Xo(t){var e=t,r=t;do{(e.x<r.x||e.x===r.x&&e.y<r.y)&&(r=e),e=e.next;}while(e!==t);return r}function Go(t,e,r,n,i,a,o,s){return (i-o)*(e-s)-(t-o)*(a-s)>=0&&(t-o)*(n-s)-(r-o)*(e-s)>=0&&(r-o)*(a-s)-(i-o)*(n-s)>=0}function Zo(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){var r=t;do{if(r.i!==t.i&&r.next.i!==t.i&&r.i!==e.i&&r.next.i!==e.i&&Yo(r,r.next,t,e))return !0;r=r.next;}while(r!==t);return !1}(t,e)&&(Qo(t,e)&&Qo(e,t)&&function(t,e){var r=t,n=!1,i=(t.x+e.x)/2,a=(t.y+e.y)/2;do{r.y>a!=r.next.y>a&&r.next.y!==r.y&&i<(r.next.x-r.x)*(a-r.y)/(r.next.y-r.y)+r.x&&(n=!n),r=r.next;}while(r!==t);return n}(t,e)&&(Jo(t.prev,t,e.prev)||Jo(t,e.prev,e))||Ho(t,e)&&Jo(t.prev,t,t.next)>0&&Jo(e.prev,e,e.next)>0)}function Jo(t,e,r){return (e.y-t.y)*(r.x-e.x)-(e.x-t.x)*(r.y-e.y)}function Ho(t,e){return t.x===e.x&&t.y===e.y}function Yo(t,e,r,n){var i=Wo(Jo(t,e,r)),a=Wo(Jo(t,e,n)),o=Wo(Jo(r,n,t)),s=Wo(Jo(r,n,e));return i!==a&&o!==s||!(0!==i||!$o(t,r,e))||!(0!==a||!$o(t,n,e))||!(0!==o||!$o(r,t,n))||!(0!==s||!$o(r,e,n))}function $o(t,e,r){return e.x<=Math.max(t.x,r.x)&&e.x>=Math.min(t.x,r.x)&&e.y<=Math.max(t.y,r.y)&&e.y>=Math.min(t.y,r.y)}function Wo(t){return t>0?1:t<0?-1:0}function Qo(t,e){return Jo(t.prev,t,t.next)<0?Jo(t,e,t.next)>=0&&Jo(t,t.prev,e)>=0:Jo(t,e,t.prev)<0||Jo(t,t.next,e)<0}function ts(t,e){var r=new ns(t.i,t.x,t.y),n=new ns(e.i,e.x,e.y),i=t.next,a=e.prev;return t.next=e,e.prev=t,r.next=i,i.prev=r,n.next=r,r.prev=n,a.next=n,n.prev=a,n}function es(t,e,r,n){var i=new ns(t,e,r);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function rs(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ);}function ns(t,e,r){this.i=t,this.x=e,this.y=r,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1;}function is(t,e,r,n){for(var i=0,a=e,o=r-n;a<r;a+=n)i+=(t[o]-t[a])*(t[a+1]+t[o+1]),o=a;return i}function as(t,e,r,n,i){!function t(e,r,n,i,a){for(;i>n;){if(i-n>600){var o=i-n+1,s=r-n+1,u=Math.log(o),l=.5*Math.exp(2*u/3),p=.5*Math.sqrt(u*l*(o-l)/o)*(s-o/2<0?-1:1);t(e,r,Math.max(n,Math.floor(r-s*l/o+p)),Math.min(i,Math.floor(r+(o-s)*l/o+p)),a);}var c=e[r],h=n,f=i;for(os(e,n,r),a(e[i],c)>0&&os(e,n,i);h<f;){for(os(e,h,f),h++,f--;a(e[h],c)<0;)h++;for(;a(e[f],c)>0;)f--;}0===a(e[n],c)?os(e,n,f):os(e,++f,i),f<=r&&(n=f+1),r<=f&&(i=f-1);}}(t,e,r||0,n||t.length-1,i||ss);}function os(t,e,r){var n=t[e];t[e]=t[r],t[r]=n;}function ss(t,e){return t<e?-1:t>e?1:0}function us(t,e){var r=t.length;if(r<=1)return [t];for(var n,i,a=[],o=0;o<r;o++){var s=A(t[o]);0!==s&&(t[o].area=Math.abs(s),void 0===i&&(i=s<0),i===s<0?(n&&a.push(n),n=[t[o]]):n.push(t[o]));}if(n&&a.push(n),e>1)for(var u=0;u<a.length;u++)a[u].length<=e||(as(a[u],e,1,a[u].length-1,ls),a[u]=a[u].slice(0,e));return a}function ls(t,e){return e.area-t.area}function ps(t,e,r){for(var n=r.patternDependencies,i=!1,a=0,o=e;a<o.length;a+=1){var s=o[a].paint.get(t+"-pattern");s.isConstant()||(i=!0);var u=s.constantOr(null);u&&(i=!0,n[u.to]=!0,n[u.from]=!0);}return i}function cs(t,e,r,n,i){for(var a=i.patternDependencies,o=0,s=e;o<s.length;o+=1){var u=s[o],l=u.paint.get(t+"-pattern").value;if("constant"!==l.kind){var p=l.evaluate({zoom:n-1},r,{},i.availableImages),c=l.evaluate({zoom:n},r,{},i.availableImages),h=l.evaluate({zoom:n+1},r,{},i.availableImages);c=c&&c.name?c.name:c,h=h&&h.name?h.name:h,a[p=p&&p.name?p.name:p]=!0,a[c]=!0,a[h]=!0,r.patterns[u.id]={min:p,mid:c,max:h};}}return r}Bo.deviation=function(t,e,r,n){var i=e&&e.length,a=Math.abs(is(t,0,i?e[0]*r:t.length,r));if(i)for(var o=0,s=e.length;o<s;o++)a-=Math.abs(is(t,e[o]*r,o<s-1?e[o+1]*r:t.length,r));var u=0;for(o=0;o<n.length;o+=3){var l=n[o]*r,p=n[o+1]*r,c=n[o+2]*r;u+=Math.abs((t[l]-t[c])*(t[p+1]-t[l+1])-(t[l]-t[p])*(t[c+1]-t[l+1]));}return 0===a&&0===u?0:Math.abs((u-a)/a)},Bo.flatten=function(t){for(var e=t[0][0].length,r={vertices:[],holes:[],dimensions:e},n=0,i=0;i<t.length;i++){for(var a=0;a<t[i].length;a++)for(var o=0;o<e;o++)r.vertices.push(t[i][a][o]);i>0&&r.holes.push(n+=t[i-1].length);}return r},Eo.default=Po;var hs=function(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map((function(t){return t.id})),this.index=t.index,this.hasPattern=!1,this.patternFeatures=[],this.layoutVertexArray=new Oi,this.indexArray=new ea,this.indexArray2=new ra,this.programConfigurations=new Ka(To,t.layers,t.zoom),this.segments=new va,this.segments2=new va,this.stateDependentLayerIds=this.layers.filter((function(t){return t.isStateDependent()})).map((function(t){return t.id}));};hs.prototype.populate=function(t,e,r){this.hasPattern=ps("fill",this.layers,e);for(var n=this.layers[0].layout.get("fill-sort-key"),i=[],a=0,o=t;a<o.length;a+=1){var s=o[a],u=s.feature,l=s.id,p=s.index,c=s.sourceLayerIndex,h=this.layers[0]._featureFilter.needGeometry,f={type:u.type,id:l,properties:u.properties,geometry:h?Ja(u):[]};if(this.layers[0]._featureFilter.filter(new gi(this.zoom),f,r)){h||(f.geometry=Ja(u));var y=n?n.evaluate(f,{},r,e.availableImages):void 0;i.push({id:l,properties:u.properties,type:u.type,sourceLayerIndex:c,index:p,geometry:f.geometry,patterns:{},sortKey:y});}}n&&i.sort((function(t,e){return t.sortKey-e.sortKey}));for(var d=0,m=i;d<m.length;d+=1){var v=m[d],g=v.geometry,x=v.index,b=v.sourceLayerIndex;if(this.hasPattern){var w=cs("fill",this.layers,v,this.zoom,e);this.patternFeatures.push(w);}else this.addFeature(v,g,x,r,{});e.featureIndex.insert(t[x].feature,g,x,b,this.index);}},hs.prototype.update=function(t,e,r){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,e,this.stateDependentLayers,r);},hs.prototype.addFeatures=function(t,e,r){for(var n=0,i=this.patternFeatures;n<i.length;n+=1){var a=i[n];this.addFeature(a,a.geometry,a.index,e,r);}},hs.prototype.isEmpty=function(){return 0===this.layoutVertexArray.length},hs.prototype.uploadPending=function(){return !this.uploaded||this.programConfigurations.needsUpload},hs.prototype.upload=function(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,To),this.indexBuffer=t.createIndexBuffer(this.indexArray),this.indexBuffer2=t.createIndexBuffer(this.indexArray2)),this.programConfigurations.upload(t),this.uploaded=!0;},hs.prototype.destroy=function(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.indexBuffer2.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.segments2.destroy());},hs.prototype.addFeature=function(t,e,r,n,i){for(var a=0,o=us(e,500);a<o.length;a+=1){for(var s=o[a],u=0,l=0,p=s;l<p.length;l+=1)u+=p[l].length;for(var c=this.segments.prepareSegment(u,this.layoutVertexArray,this.indexArray),h=c.vertexLength,f=[],y=[],d=0,m=s;d<m.length;d+=1){var v=m[d];if(0!==v.length){v!==s[0]&&y.push(f.length/2);var g=this.segments2.prepareSegment(v.length,this.layoutVertexArray,this.indexArray2),x=g.vertexLength;this.layoutVertexArray.emplaceBack(v[0].x,v[0].y),this.indexArray2.emplaceBack(x+v.length-1,x),f.push(v[0].x),f.push(v[0].y);for(var b=1;b<v.length;b++)this.layoutVertexArray.emplaceBack(v[b].x,v[b].y),this.indexArray2.emplaceBack(x+b-1,x+b),f.push(v[b].x),f.push(v[b].y);g.vertexLength+=v.length,g.primitiveLength+=v.length;}}for(var w=Eo(f,y),_=0;_<w.length;_+=3)this.indexArray.emplaceBack(h+w[_],h+w[_+1],h+w[_+2]);c.vertexLength+=u,c.primitiveLength+=w.length/3;}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,r,i,n);},Hn("FillBucket",hs,{omit:["layers","patternFeatures"]});var fs=new Pi({"fill-sort-key":new Ci(Ct.layout_fill["fill-sort-key"])}),ys={paint:new Pi({"fill-antialias":new zi(Ct.paint_fill["fill-antialias"]),"fill-opacity":new Ci(Ct.paint_fill["fill-opacity"]),"fill-color":new Ci(Ct.paint_fill["fill-color"]),"fill-outline-color":new Ci(Ct.paint_fill["fill-outline-color"]),"fill-translate":new zi(Ct.paint_fill["fill-translate"]),"fill-translate-anchor":new zi(Ct.paint_fill["fill-translate-anchor"]),"fill-pattern":new Mi(Ct.paint_fill["fill-pattern"])}),layout:fs},ds=function(t){function e(e){t.call(this,e,ys);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.recalculate=function(e,r){t.prototype.recalculate.call(this,e,r);var n=this.paint._values["fill-outline-color"];"constant"===n.value.kind&&void 0===n.value.value&&(this.paint._values["fill-outline-color"]=this.paint._values["fill-color"]);},e.prototype.createBucket=function(t){return new hs(t)},e.prototype.queryRadius=function(){return lo(this.paint.get("fill-translate"))},e.prototype.queryIntersectsFeature=function(t,e,r,n,i,a,o){return Qa(po(t,this.paint.get("fill-translate"),this.paint.get("fill-translate-anchor"),a.angle,o),n)},e.prototype.isTileClipped=function(){return !0},e}(Bi),ms=Li([{name:"a_pos",components:2,type:"Int16"},{name:"a_normal_ed",components:4,type:"Int16"}],4).members,vs=gs;function gs(t,e,r,n,i){this.properties={},this.extent=r,this.type=0,this._pbf=t,this._geometry=-1,this._keys=n,this._values=i,t.readFields(xs,this,e);}function xs(t,e,r){1==t?e.id=r.readVarint():2==t?function(t,e){for(var r=t.readVarint()+t.pos;t.pos<r;){var n=e._keys[t.readVarint()],i=e._values[t.readVarint()];e.properties[n]=i;}}(r,e):3==t?e.type=r.readVarint():4==t&&(e._geometry=r.pos);}function bs(t){for(var e,r,n=0,i=0,a=t.length,o=a-1;i<a;o=i++)n+=((r=t[o]).x-(e=t[i]).x)*(e.y+r.y);return n}gs.types=["Unknown","Point","LineString","Polygon"],gs.prototype.loadGeometry=function(){var t=this._pbf;t.pos=this._geometry;for(var e,r=t.readVarint()+t.pos,n=1,a=0,o=0,s=0,u=[];t.pos<r;){if(a<=0){var l=t.readVarint();n=7&l,a=l>>3;}if(a--,1===n||2===n)o+=t.readSVarint(),s+=t.readSVarint(),1===n&&(e&&u.push(e),e=[]),e.push(new i(o,s));else{if(7!==n)throw new Error("unknown command "+n);e&&e.push(e[0].clone());}}return e&&u.push(e),u},gs.prototype.bbox=function(){var t=this._pbf;t.pos=this._geometry;for(var e=t.readVarint()+t.pos,r=1,n=0,i=0,a=0,o=1/0,s=-1/0,u=1/0,l=-1/0;t.pos<e;){if(n<=0){var p=t.readVarint();r=7&p,n=p>>3;}if(n--,1===r||2===r)(i+=t.readSVarint())<o&&(o=i),i>s&&(s=i),(a+=t.readSVarint())<u&&(u=a),a>l&&(l=a);else if(7!==r)throw new Error("unknown command "+r)}return [o,u,s,l]},gs.prototype.toGeoJSON=function(t,e,r){var n,i,a=this.extent*Math.pow(2,r),o=this.extent*t,s=this.extent*e,u=this.loadGeometry(),l=gs.types[this.type];function p(t){for(var e=0;e<t.length;e++){var r=t[e];t[e]=[360*(r.x+o)/a-180,360/Math.PI*Math.atan(Math.exp((180-360*(r.y+s)/a)*Math.PI/180))-90];}}switch(this.type){case 1:var c=[];for(n=0;n<u.length;n++)c[n]=u[n][0];p(u=c);break;case 2:for(n=0;n<u.length;n++)p(u[n]);break;case 3:for(u=function(t){var e=t.length;if(e<=1)return [t];for(var r,n,i=[],a=0;a<e;a++){var o=bs(t[a]);0!==o&&(void 0===n&&(n=o<0),n===o<0?(r&&i.push(r),r=[t[a]]):r.push(t[a]));}return r&&i.push(r),i}(u),n=0;n<u.length;n++)for(i=0;i<u[n].length;i++)p(u[n][i]);}1===u.length?u=u[0]:l="Multi"+l;var h={type:"Feature",geometry:{type:l,coordinates:u},properties:this.properties};return "id"in this&&(h.id=this.id),h};var ws=_s;function _s(t,e){this.version=1,this.name=null,this.extent=4096,this.length=0,this._pbf=t,this._keys=[],this._values=[],this._features=[],t.readFields(As,this,e),this.length=this._features.length;}function As(t,e,r){15===t?e.version=r.readVarint():1===t?e.name=r.readString():5===t?e.extent=r.readVarint():2===t?e._features.push(r.pos):3===t?e._keys.push(r.readString()):4===t&&e._values.push(function(t){for(var e=null,r=t.readVarint()+t.pos;t.pos<r;){var n=t.readVarint()>>3;e=1===n?t.readString():2===n?t.readFloat():3===n?t.readDouble():4===n?t.readVarint64():5===n?t.readVarint():6===n?t.readSVarint():7===n?t.readBoolean():null;}return e}(r));}function Ss(t,e,r){if(3===t){var n=new ws(r,r.readVarint()+r.pos);n.length&&(e[n.name]=n);}}_s.prototype.feature=function(t){if(t<0||t>=this._features.length)throw new Error("feature index out of bounds");this._pbf.pos=this._features[t];var e=this._pbf.readVarint()+this._pbf.pos;return new vs(this._pbf,e,this.extent,this._keys,this._values)};var ks={VectorTile:function(t,e){this.layers=t.readFields(Ss,{},e);},VectorTileFeature:vs,VectorTileLayer:ws},Is=ks.VectorTileFeature.types,zs=Math.pow(2,13);function Cs(t,e,r,n,i,a,o,s){t.emplaceBack(e,r,2*Math.floor(n*zs)+o,i*zs*2,a*zs*2,Math.round(s));}var Ms=function(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map((function(t){return t.id})),this.index=t.index,this.hasPattern=!1,this.layoutVertexArray=new ji,this.indexArray=new ea,this.programConfigurations=new Ka(ms,t.layers,t.zoom),this.segments=new va,this.stateDependentLayerIds=this.layers.filter((function(t){return t.isStateDependent()})).map((function(t){return t.id}));};function Ts(t,e){return t.x===e.x&&(t.x<0||t.x>ze)||t.y===e.y&&(t.y<0||t.y>ze)}Ms.prototype.populate=function(t,e,r){this.features=[],this.hasPattern=ps("fill-extrusion",this.layers,e);for(var n=0,i=t;n<i.length;n+=1){var a=i[n],o=a.feature,s=a.id,u=a.index,l=a.sourceLayerIndex,p=this.layers[0]._featureFilter.needGeometry,c={type:o.type,id:s,properties:o.properties,geometry:p?Ja(o):[]};if(this.layers[0]._featureFilter.filter(new gi(this.zoom),c,r)){var h={id:s,sourceLayerIndex:l,index:u,geometry:p?c.geometry:Ja(o),properties:o.properties,type:o.type,patterns:{}};void 0!==o.id&&(h.id=o.id),this.hasPattern?this.features.push(cs("fill-extrusion",this.layers,h,this.zoom,e)):this.addFeature(h,h.geometry,u,r,{}),e.featureIndex.insert(o,h.geometry,u,l,this.index,!0);}}},Ms.prototype.addFeatures=function(t,e,r){for(var n=0,i=this.features;n<i.length;n+=1){var a=i[n];this.addFeature(a,a.geometry,a.index,e,r);}},Ms.prototype.update=function(t,e,r){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,e,this.stateDependentLayers,r);},Ms.prototype.isEmpty=function(){return 0===this.layoutVertexArray.length},Ms.prototype.uploadPending=function(){return !this.uploaded||this.programConfigurations.needsUpload},Ms.prototype.upload=function(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,ms),this.indexBuffer=t.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(t),this.uploaded=!0;},Ms.prototype.destroy=function(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy());},Ms.prototype.addFeature=function(t,e,r,n,i){for(var a=0,o=us(e,500);a<o.length;a+=1){for(var s=o[a],u=0,l=0,p=s;l<p.length;l+=1)u+=p[l].length;for(var c=this.segments.prepareSegment(4,this.layoutVertexArray,this.indexArray),h=0,f=s;h<f.length;h+=1){var y=f[h];if(0!==y.length&&!((P=y).every((function(t){return t.x<0}))||P.every((function(t){return t.x>ze}))||P.every((function(t){return t.y<0}))||P.every((function(t){return t.y>ze}))))for(var d=0,m=0;m<y.length;m++){var v=y[m];if(m>=1){var g=y[m-1];if(!Ts(v,g)){c.vertexLength+4>va.MAX_VERTEX_ARRAY_LENGTH&&(c=this.segments.prepareSegment(4,this.layoutVertexArray,this.indexArray));var x=v.sub(g)._perp()._unit(),b=g.dist(v);d+b>32768&&(d=0),Cs(this.layoutVertexArray,v.x,v.y,x.x,x.y,0,0,d),Cs(this.layoutVertexArray,v.x,v.y,x.x,x.y,0,1,d),Cs(this.layoutVertexArray,g.x,g.y,x.x,x.y,0,0,d+=b),Cs(this.layoutVertexArray,g.x,g.y,x.x,x.y,0,1,d);var w=c.vertexLength;this.indexArray.emplaceBack(w,w+2,w+1),this.indexArray.emplaceBack(w+1,w+2,w+3),c.vertexLength+=4,c.primitiveLength+=2;}}}}if(c.vertexLength+u>va.MAX_VERTEX_ARRAY_LENGTH&&(c=this.segments.prepareSegment(u,this.layoutVertexArray,this.indexArray)),"Polygon"===Is[t.type]){for(var _=[],A=[],S=c.vertexLength,k=0,I=s;k<I.length;k+=1){var z=I[k];if(0!==z.length){z!==s[0]&&A.push(_.length/2);for(var C=0;C<z.length;C++){var M=z[C];Cs(this.layoutVertexArray,M.x,M.y,0,0,1,1,0),_.push(M.x),_.push(M.y);}}}for(var T=Eo(_,A),E=0;E<T.length;E+=3)this.indexArray.emplaceBack(S+T[E],S+T[E+2],S+T[E+1]);c.primitiveLength+=T.length/3,c.vertexLength+=u;}}var P;this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,r,i,n);},Hn("FillExtrusionBucket",Ms,{omit:["layers","features"]});var Es={paint:new Pi({"fill-extrusion-opacity":new zi(Ct["paint_fill-extrusion"]["fill-extrusion-opacity"]),"fill-extrusion-color":new Ci(Ct["paint_fill-extrusion"]["fill-extrusion-color"]),"fill-extrusion-translate":new zi(Ct["paint_fill-extrusion"]["fill-extrusion-translate"]),"fill-extrusion-translate-anchor":new zi(Ct["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),"fill-extrusion-pattern":new Mi(Ct["paint_fill-extrusion"]["fill-extrusion-pattern"]),"fill-extrusion-height":new Ci(Ct["paint_fill-extrusion"]["fill-extrusion-height"]),"fill-extrusion-base":new Ci(Ct["paint_fill-extrusion"]["fill-extrusion-base"]),"fill-extrusion-vertical-gradient":new zi(Ct["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])})},Ps=function(t){function e(e){t.call(this,e,Es);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.createBucket=function(t){return new Ms(t)},e.prototype.queryRadius=function(){return lo(this.paint.get("fill-extrusion-translate"))},e.prototype.is3D=function(){return !0},e.prototype.queryIntersectsFeature=function(t,e,r,n,a,o,s,u){var l=po(t,this.paint.get("fill-extrusion-translate"),this.paint.get("fill-extrusion-translate-anchor"),o.angle,s),p=this.paint.get("fill-extrusion-height").evaluate(e,r),c=this.paint.get("fill-extrusion-base").evaluate(e,r),h=function(t,e,r,n){for(var a=[],o=0,s=t;o<s.length;o+=1){var u=s[o],l=[u.x,u.y,0,1];mo(l,l,e),a.push(new i(l[0]/l[3],l[1]/l[3]));}return a}(l,u),f=function(t,e,r,n){for(var a=[],o=[],s=n[8]*e,u=n[9]*e,l=n[10]*e,p=n[11]*e,c=n[8]*r,h=n[9]*r,f=n[10]*r,y=n[11]*r,d=0,m=t;d<m.length;d+=1){for(var v=[],g=[],x=0,b=m[d];x<b.length;x+=1){var w=b[x],_=w.x,A=w.y,S=n[0]*_+n[4]*A+n[12],k=n[1]*_+n[5]*A+n[13],I=n[2]*_+n[6]*A+n[14],z=n[3]*_+n[7]*A+n[15],C=I+l,M=z+p,T=S+c,E=k+h,P=I+f,B=z+y,V=new i((S+s)/M,(k+u)/M);V.z=C/M,v.push(V);var F=new i(T/B,E/B);F.z=P/B,g.push(F);}a.push(v),o.push(g);}return [a,o]}(n,c,p,u);return function(t,e,r){var n=1/0;Qa(r,e)&&(n=Vs(r,e[0]));for(var i=0;i<e.length;i++)for(var a=e[i],o=t[i],s=0;s<a.length-1;s++){var u=a[s],l=[u,a[s+1],o[s+1],o[s],u];$a(r,l)&&(n=Math.min(n,Vs(r,l)));}return n!==1/0&&n}(f[0],f[1],h)},e}(Bi);function Bs(t,e){return t.x*e.x+t.y*e.y}function Vs(t,e){if(1===t.length){for(var r,n,i=0,a=e[i++];!r||a.equals(r);)if(!(r=e[i++]))return 1/0;for(;!n||a.equals(n)||r.equals(n);)if(!(n=e[i++]))return 1/0;var o=t[0],s=r.sub(a),u=n.sub(a),l=o.sub(a),p=Bs(s,s),c=Bs(s,u),h=Bs(u,u),f=Bs(l,s),y=Bs(l,u),d=p*h-c*c,m=(h*f-c*y)/d,v=(p*y-c*f)/d;return a.z*(1-m-v)+r.z*m+n.z*v}for(var g=1/0,x=0,b=e;x<b.length;x+=1)g=Math.min(g,b[x].z);return g}var Fs=Li([{name:"a_pos_normal",components:2,type:"Int16"},{name:"a_data",components:4,type:"Uint8"}],4).members,Ds=ks.VectorTileFeature.types,Ls=Math.cos(Math.PI/180*37.5),Rs=Math.pow(2,14)/.5,Os=function(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map((function(t){return t.id})),this.index=t.index,this.hasPattern=!1,this.patternFeatures=[],this.layoutVertexArray=new qi,this.indexArray=new ea,this.programConfigurations=new Ka(Fs,t.layers,t.zoom),this.segments=new va,this.stateDependentLayerIds=this.layers.filter((function(t){return t.isStateDependent()})).map((function(t){return t.id}));};Os.prototype.populate=function(t,e,r){this.hasPattern=ps("line",this.layers,e);for(var n=this.layers[0].layout.get("line-sort-key"),i=[],a=0,o=t;a<o.length;a+=1){var s=o[a],u=s.feature,l=s.id,p=s.index,c=s.sourceLayerIndex,h=this.layers[0]._featureFilter.needGeometry,f={type:u.type,id:l,properties:u.properties,geometry:h?Ja(u):[]};if(this.layers[0]._featureFilter.filter(new gi(this.zoom),f,r)){h||(f.geometry=Ja(u));var y=n?n.evaluate(f,{},r):void 0;i.push({id:l,properties:u.properties,type:u.type,sourceLayerIndex:c,index:p,geometry:f.geometry,patterns:{},sortKey:y});}}n&&i.sort((function(t,e){return t.sortKey-e.sortKey}));for(var d=0,m=i;d<m.length;d+=1){var v=m[d],g=v.geometry,x=v.index,b=v.sourceLayerIndex;if(this.hasPattern){var w=cs("line",this.layers,v,this.zoom,e);this.patternFeatures.push(w);}else this.addFeature(v,g,x,r,{});e.featureIndex.insert(t[x].feature,g,x,b,this.index);}},Os.prototype.update=function(t,e,r){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,e,this.stateDependentLayers,r);},Os.prototype.addFeatures=function(t,e,r){for(var n=0,i=this.patternFeatures;n<i.length;n+=1){var a=i[n];this.addFeature(a,a.geometry,a.index,e,r);}},Os.prototype.isEmpty=function(){return 0===this.layoutVertexArray.length},Os.prototype.uploadPending=function(){return !this.uploaded||this.programConfigurations.needsUpload},Os.prototype.upload=function(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,Fs),this.indexBuffer=t.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(t),this.uploaded=!0;},Os.prototype.destroy=function(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy());},Os.prototype.addFeature=function(t,e,r,n,i){for(var a=this.layers[0].layout,o=a.get("line-join").evaluate(t,{}),s=a.get("line-cap"),u=a.get("line-miter-limit"),l=a.get("line-round-limit"),p=0,c=e;p<c.length;p+=1)this.addLine(c[p],t,o,s,u,l,r,n,i);},Os.prototype.addLine=function(t,e,r,n,i,a,o,s,u){if(this.distance=0,this.scaledDistance=0,this.totalDistance=0,e.properties&&e.properties.hasOwnProperty("mapbox_clip_start")&&e.properties.hasOwnProperty("mapbox_clip_end")){this.clipStart=+e.properties.mapbox_clip_start,this.clipEnd=+e.properties.mapbox_clip_end;for(var l=0;l<t.length-1;l++)this.totalDistance+=t[l].dist(t[l+1]);this.updateScaledDistance();}for(var p="Polygon"===Ds[e.type],c=t.length;c>=2&&t[c-1].equals(t[c-2]);)c--;for(var h=0;h<c-1&&t[h].equals(t[h+1]);)h++;if(!(c<(p?3:2))){"bevel"===r&&(i=1.05);var f,y=this.overscaling<=16?15*ze/(512*this.overscaling):0,d=this.segments.prepareSegment(10*c,this.layoutVertexArray,this.indexArray),m=void 0,v=void 0,g=void 0,x=void 0;this.e1=this.e2=-1,p&&(x=t[h].sub(f=t[c-2])._unit()._perp());for(var b=h;b<c;b++)if(!(v=b===c-1?p?t[h+1]:void 0:t[b+1])||!t[b].equals(v)){x&&(g=x),f&&(m=f),f=t[b],x=v?v.sub(f)._unit()._perp():g;var w=(g=g||x).add(x);0===w.x&&0===w.y||w._unit();var _=g.x*x.x+g.y*x.y,A=w.x*x.x+w.y*x.y,S=0!==A?1/A:1/0,k=2*Math.sqrt(2-2*A),I=A<Ls&&m&&v,z=g.x*x.y-g.y*x.x>0;if(I&&b>h){var C=f.dist(m);if(C>2*y){var M=f.sub(f.sub(m)._mult(y/C)._round());this.updateDistance(m,M),this.addCurrentVertex(M,g,0,0,d),m=M;}}var T=m&&v,E=T?r:p?"butt":n;if(T&&"round"===E&&(S<a?E="miter":S<=2&&(E="fakeround")),"miter"===E&&S>i&&(E="bevel"),"bevel"===E&&(S>2&&(E="flipbevel"),S<i&&(E="miter")),m&&this.updateDistance(m,f),"miter"===E)w._mult(S),this.addCurrentVertex(f,w,0,0,d);else if("flipbevel"===E){if(S>100)w=x.mult(-1);else{var P=S*g.add(x).mag()/g.sub(x).mag();w._perp()._mult(P*(z?-1:1));}this.addCurrentVertex(f,w,0,0,d),this.addCurrentVertex(f,w.mult(-1),0,0,d);}else if("bevel"===E||"fakeround"===E){var B=-Math.sqrt(S*S-1),V=z?B:0,F=z?0:B;if(m&&this.addCurrentVertex(f,g,V,F,d),"fakeround"===E)for(var D=Math.round(180*k/Math.PI/20),L=1;L<D;L++){var R=L/D;if(.5!==R){var O=R-.5;R+=R*O*(R-1)*((1.0904+_*(_*(3.55645-1.43519*_)-3.2452))*O*O+(.848013+_*(.215638*_-1.06021)));}var U=x.sub(g)._mult(R)._add(g)._unit()._mult(z?-1:1);this.addHalfVertex(f,U.x,U.y,!1,z,0,d);}v&&this.addCurrentVertex(f,x,-V,-F,d);}else if("butt"===E)this.addCurrentVertex(f,w,0,0,d);else if("square"===E){var j=m?1:-1;this.addCurrentVertex(f,w,j,j,d);}else"round"===E&&(m&&(this.addCurrentVertex(f,g,0,0,d),this.addCurrentVertex(f,g,1,1,d,!0)),v&&(this.addCurrentVertex(f,x,-1,-1,d,!0),this.addCurrentVertex(f,x,0,0,d)));if(I&&b<c-1){var q=f.dist(v);if(q>2*y){var N=f.add(v.sub(f)._mult(y/q)._round());this.updateDistance(f,N),this.addCurrentVertex(N,x,0,0,d),f=N;}}}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,e,o,u,s);}},Os.prototype.addCurrentVertex=function(t,e,r,n,i,a){void 0===a&&(a=!1);var o=e.y*n-e.x,s=-e.y-e.x*n;this.addHalfVertex(t,e.x+e.y*r,e.y-e.x*r,a,!1,r,i),this.addHalfVertex(t,o,s,a,!0,-n,i),this.distance>Rs/2&&0===this.totalDistance&&(this.distance=0,this.addCurrentVertex(t,e,r,n,i,a));},Os.prototype.addHalfVertex=function(t,e,r,n,i,a,o){var s=.5*this.scaledDistance;this.layoutVertexArray.emplaceBack((t.x<<1)+(n?1:0),(t.y<<1)+(i?1:0),Math.round(63*e)+128,Math.round(63*r)+128,1+(0===a?0:a<0?-1:1)|(63&s)<<2,s>>6);var u=o.vertexLength++;this.e1>=0&&this.e2>=0&&(this.indexArray.emplaceBack(this.e1,this.e2,u),o.primitiveLength++),i?this.e2=u:this.e1=u;},Os.prototype.updateScaledDistance=function(){this.scaledDistance=this.totalDistance>0?(this.clipStart+(this.clipEnd-this.clipStart)*this.distance/this.totalDistance)*(Rs-1):this.distance;},Os.prototype.updateDistance=function(t,e){this.distance+=t.dist(e),this.updateScaledDistance();},Hn("LineBucket",Os,{omit:["layers","patternFeatures"]});var Us=new Pi({"line-cap":new zi(Ct.layout_line["line-cap"]),"line-join":new Ci(Ct.layout_line["line-join"]),"line-miter-limit":new zi(Ct.layout_line["line-miter-limit"]),"line-round-limit":new zi(Ct.layout_line["line-round-limit"]),"line-sort-key":new Ci(Ct.layout_line["line-sort-key"])}),js={paint:new Pi({"line-opacity":new Ci(Ct.paint_line["line-opacity"]),"line-color":new Ci(Ct.paint_line["line-color"]),"line-translate":new zi(Ct.paint_line["line-translate"]),"line-translate-anchor":new zi(Ct.paint_line["line-translate-anchor"]),"line-width":new Ci(Ct.paint_line["line-width"]),"line-gap-width":new Ci(Ct.paint_line["line-gap-width"]),"line-offset":new Ci(Ct.paint_line["line-offset"]),"line-blur":new Ci(Ct.paint_line["line-blur"]),"line-dasharray":new Ti(Ct.paint_line["line-dasharray"]),"line-pattern":new Mi(Ct.paint_line["line-pattern"]),"line-gradient":new Ei(Ct.paint_line["line-gradient"])}),layout:Us},qs=new(function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.possiblyEvaluate=function(e,r){return r=new gi(Math.floor(r.zoom),{now:r.now,fadeDuration:r.fadeDuration,zoomHistory:r.zoomHistory,transition:r.transition}),t.prototype.possiblyEvaluate.call(this,e,r)},e.prototype.evaluate=function(e,r,n,i){return r=p({},r,{zoom:Math.floor(r.zoom)}),t.prototype.evaluate.call(this,e,r,n,i)},e}(Ci))(js.paint.properties["line-width"].specification);qs.useIntegerZoom=!0;var Ns=function(t){function e(e){t.call(this,e,js);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype._handleSpecialPaintPropertyUpdate=function(t){"line-gradient"===t&&this._updateGradient();},e.prototype._updateGradient=function(){this.gradient=Io(this._transitionablePaint._values["line-gradient"].value.expression,"lineProgress"),this.gradientTexture=null;},e.prototype.recalculate=function(e,r){t.prototype.recalculate.call(this,e,r),this.paint._values["line-floorwidth"]=qs.possiblyEvaluate(this._transitioningPaint._values["line-width"].value,e);},e.prototype.createBucket=function(t){return new Os(t)},e.prototype.queryRadius=function(t){var e=t,r=Ks(uo("line-width",this,e),uo("line-gap-width",this,e)),n=uo("line-offset",this,e);return r/2+Math.abs(n)+lo(this.paint.get("line-translate"))},e.prototype.queryIntersectsFeature=function(t,e,r,n,a,o,s){var u=po(t,this.paint.get("line-translate"),this.paint.get("line-translate-anchor"),o.angle,s),l=s/2*Ks(this.paint.get("line-width").evaluate(e,r),this.paint.get("line-gap-width").evaluate(e,r)),p=this.paint.get("line-offset").evaluate(e,r);return p&&(n=function(t,e){for(var r=[],n=new i(0,0),a=0;a<t.length;a++){for(var o=t[a],s=[],u=0;u<o.length;u++){var l=o[u],p=o[u+1],c=0===u?n:l.sub(o[u-1])._unit()._perp(),h=u===o.length-1?n:p.sub(l)._unit()._perp(),f=c._add(h)._unit();f._mult(1/(f.x*h.x+f.y*h.y)),s.push(f._mult(e)._add(l));}r.push(s);}return r}(n,p*s)),function(t,e,r){for(var n=0;n<e.length;n++){var i=e[n];if(t.length>=3)for(var a=0;a<i.length;a++)if(oo(t,i[a]))return !0;if(to(t,i,r))return !0}return !1}(u,n,l)},e.prototype.isTileClipped=function(){return !0},e}(Bi);function Ks(t,e){return e>0?e+2*t:t}var Xs=Li([{name:"a_pos_offset",components:4,type:"Int16"},{name:"a_data",components:4,type:"Uint16"},{name:"a_pixeloffset",components:4,type:"Int16"}],4),Gs=Li([{name:"a_projected_pos",components:3,type:"Float32"}],4),Zs=(Li([{name:"a_fade_opacity",components:1,type:"Uint32"}],4),Li([{name:"a_placed",components:2,type:"Uint8"},{name:"a_shift",components:2,type:"Float32"}])),Js=(Li([{type:"Int16",name:"anchorPointX"},{type:"Int16",name:"anchorPointY"},{type:"Int16",name:"x1"},{type:"Int16",name:"y1"},{type:"Int16",name:"x2"},{type:"Int16",name:"y2"},{type:"Uint32",name:"featureIndex"},{type:"Uint16",name:"sourceLayerIndex"},{type:"Uint16",name:"bucketIndex"},{type:"Int16",name:"radius"},{type:"Int16",name:"signedDistanceFromAnchor"}]),Li([{name:"a_pos",components:2,type:"Int16"},{name:"a_anchor_pos",components:2,type:"Int16"},{name:"a_extrude",components:2,type:"Int16"}],4)),Hs=Li([{name:"a_pos",components:2,type:"Int16"},{name:"a_anchor_pos",components:2,type:"Int16"},{name:"a_extrude",components:2,type:"Int16"}],4);function Ys(t,e,r){return t.sections.forEach((function(t){t.text=function(t,e,r){var n=e.layout.get("text-transform").evaluate(r,{});return "uppercase"===n?t=t.toLocaleUpperCase():"lowercase"===n&&(t=t.toLocaleLowerCase()),vi.applyArabicShaping&&(t=vi.applyArabicShaping(t)),t}(t.text,e,r);})),t}Li([{type:"Int16",name:"anchorX"},{type:"Int16",name:"anchorY"},{type:"Uint16",name:"glyphStartIndex"},{type:"Uint16",name:"numGlyphs"},{type:"Uint32",name:"vertexStartIndex"},{type:"Uint32",name:"lineStartIndex"},{type:"Uint32",name:"lineLength"},{type:"Uint16",name:"segment"},{type:"Uint16",name:"lowerSize"},{type:"Uint16",name:"upperSize"},{type:"Float32",name:"lineOffsetX"},{type:"Float32",name:"lineOffsetY"},{type:"Uint8",name:"writingMode"},{type:"Uint8",name:"placedOrientation"},{type:"Uint8",name:"hidden"},{type:"Uint32",name:"crossTileID"},{type:"Int16",name:"associatedIconIndex"}]),Li([{type:"Int16",name:"anchorX"},{type:"Int16",name:"anchorY"},{type:"Int16",name:"rightJustifiedTextSymbolIndex"},{type:"Int16",name:"centerJustifiedTextSymbolIndex"},{type:"Int16",name:"leftJustifiedTextSymbolIndex"},{type:"Int16",name:"verticalPlacedTextSymbolIndex"},{type:"Int16",name:"placedIconSymbolIndex"},{type:"Int16",name:"verticalPlacedIconSymbolIndex"},{type:"Uint16",name:"key"},{type:"Uint16",name:"textBoxStartIndex"},{type:"Uint16",name:"textBoxEndIndex"},{type:"Uint16",name:"verticalTextBoxStartIndex"},{type:"Uint16",name:"verticalTextBoxEndIndex"},{type:"Uint16",name:"iconBoxStartIndex"},{type:"Uint16",name:"iconBoxEndIndex"},{type:"Uint16",name:"verticalIconBoxStartIndex"},{type:"Uint16",name:"verticalIconBoxEndIndex"},{type:"Uint16",name:"featureIndex"},{type:"Uint16",name:"numHorizontalGlyphVertices"},{type:"Uint16",name:"numVerticalGlyphVertices"},{type:"Uint16",name:"numIconVertices"},{type:"Uint16",name:"numVerticalIconVertices"},{type:"Uint32",name:"crossTileID"},{type:"Float32",name:"textBoxScale"},{type:"Float32",components:2,name:"textOffset"}]),Li([{type:"Float32",name:"offsetX"}]),Li([{type:"Int16",name:"x"},{type:"Int16",name:"y"},{type:"Int16",name:"tileUnitDistanceFromAnchor"}]);var $s={"!":"","#":"",$:"","%":"","&":"","(":"",")":"","*":"","+":"",",":"","-":"",".":"","/":"",":":"",";":"","<":"","=":"",">":"","?":"","@":"","[":"","\\":"","]":"","^":"",_:"","`":"","{":"","|":"","}":"","~":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":""},Ws=24,Qs=function(t,e,r,n,i){var a,o,s=8*i-n-1,u=(1<<s)-1,l=u>>1,p=-7,c=r?i-1:0,h=r?-1:1,f=t[e+c];for(c+=h,a=f&(1<<-p)-1,f>>=-p,p+=s;p>0;a=256*a+t[e+c],c+=h,p-=8);for(o=a&(1<<-p)-1,a>>=-p,p+=n;p>0;o=256*o+t[e+c],c+=h,p-=8);if(0===a)a=1-l;else{if(a===u)return o?NaN:1/0*(f?-1:1);o+=Math.pow(2,n),a-=l;}return (f?-1:1)*o*Math.pow(2,a-n)},tu=function(t,e,r,n,i,a){var o,s,u,l=8*a-i-1,p=(1<<l)-1,c=p>>1,h=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,f=n?0:a-1,y=n?1:-1,d=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(s=isNaN(e)?1:0,o=p):(o=Math.floor(Math.log(e)/Math.LN2),e*(u=Math.pow(2,-o))<1&&(o--,u*=2),(e+=o+c>=1?h/u:h*Math.pow(2,1-c))*u>=2&&(o++,u/=2),o+c>=p?(s=0,o=p):o+c>=1?(s=(e*u-1)*Math.pow(2,i),o+=c):(s=e*Math.pow(2,c-1)*Math.pow(2,i),o=0));i>=8;t[r+f]=255&s,f+=y,s/=256,i-=8);for(o=o<<i|s,l+=i;l>0;t[r+f]=255&o,f+=y,o/=256,l-=8);t[r+f-y]|=128*d;},eu=ru;function ru(t){this.buf=ArrayBuffer.isView&&ArrayBuffer.isView(t)?t:new Uint8Array(t||0),this.pos=0,this.type=0,this.length=this.buf.length;}ru.Varint=0,ru.Fixed64=1,ru.Bytes=2,ru.Fixed32=5;var nu="undefined"==typeof TextDecoder?null:new TextDecoder("utf8");function iu(t){return t.type===ru.Bytes?t.readVarint()+t.pos:t.pos+1}function au(t,e,r){return r?4294967296*e+(t>>>0):4294967296*(e>>>0)+(t>>>0)}function ou(t,e,r){var n=e<=16383?1:e<=2097151?2:e<=268435455?3:Math.floor(Math.log(e)/(7*Math.LN2));r.realloc(n);for(var i=r.pos-1;i>=t;i--)r.buf[i+n]=r.buf[i];}function su(t,e){for(var r=0;r<t.length;r++)e.writeVarint(t[r]);}function uu(t,e){for(var r=0;r<t.length;r++)e.writeSVarint(t[r]);}function lu(t,e){for(var r=0;r<t.length;r++)e.writeFloat(t[r]);}function pu(t,e){for(var r=0;r<t.length;r++)e.writeDouble(t[r]);}function cu(t,e){for(var r=0;r<t.length;r++)e.writeBoolean(t[r]);}function hu(t,e){for(var r=0;r<t.length;r++)e.writeFixed32(t[r]);}function fu(t,e){for(var r=0;r<t.length;r++)e.writeSFixed32(t[r]);}function yu(t,e){for(var r=0;r<t.length;r++)e.writeFixed64(t[r]);}function du(t,e){for(var r=0;r<t.length;r++)e.writeSFixed64(t[r]);}function mu(t,e){return (t[e]|t[e+1]<<8|t[e+2]<<16)+16777216*t[e+3]}function vu(t,e,r){t[r]=e,t[r+1]=e>>>8,t[r+2]=e>>>16,t[r+3]=e>>>24;}function gu(t,e){return (t[e]|t[e+1]<<8|t[e+2]<<16)+(t[e+3]<<24)}ru.prototype={destroy:function(){this.buf=null;},readFields:function(t,e,r){for(r=r||this.length;this.pos<r;){var n=this.readVarint(),i=n>>3,a=this.pos;this.type=7&n,t(i,e,this),this.pos===a&&this.skip(n);}return e},readMessage:function(t,e){return this.readFields(t,e,this.readVarint()+this.pos)},readFixed32:function(){var t=mu(this.buf,this.pos);return this.pos+=4,t},readSFixed32:function(){var t=gu(this.buf,this.pos);return this.pos+=4,t},readFixed64:function(){var t=mu(this.buf,this.pos)+4294967296*mu(this.buf,this.pos+4);return this.pos+=8,t},readSFixed64:function(){var t=mu(this.buf,this.pos)+4294967296*gu(this.buf,this.pos+4);return this.pos+=8,t},readFloat:function(){var t=Qs(this.buf,this.pos,!0,23,4);return this.pos+=4,t},readDouble:function(){var t=Qs(this.buf,this.pos,!0,52,8);return this.pos+=8,t},readVarint:function(t){var e,r,n=this.buf;return e=127&(r=n[this.pos++]),r<128?e:(e|=(127&(r=n[this.pos++]))<<7,r<128?e:(e|=(127&(r=n[this.pos++]))<<14,r<128?e:(e|=(127&(r=n[this.pos++]))<<21,r<128?e:function(t,e,r){var n,i,a=r.buf;if(n=(112&(i=a[r.pos++]))>>4,i<128)return au(t,n,e);if(n|=(127&(i=a[r.pos++]))<<3,i<128)return au(t,n,e);if(n|=(127&(i=a[r.pos++]))<<10,i<128)return au(t,n,e);if(n|=(127&(i=a[r.pos++]))<<17,i<128)return au(t,n,e);if(n|=(127&(i=a[r.pos++]))<<24,i<128)return au(t,n,e);if(n|=(1&(i=a[r.pos++]))<<31,i<128)return au(t,n,e);throw new Error("Expected varint not more than 10 bytes")}(e|=(15&(r=n[this.pos]))<<28,t,this))))},readVarint64:function(){return this.readVarint(!0)},readSVarint:function(){var t=this.readVarint();return t%2==1?(t+1)/-2:t/2},readBoolean:function(){return Boolean(this.readVarint())},readString:function(){var t=this.readVarint()+this.pos,e=this.pos;return this.pos=t,t-e>=12&&nu?function(t,e,r){return nu.decode(t.subarray(e,r))}(this.buf,e,t):function(t,e,r){for(var n="",i=e;i<r;){var a,o,s,u=t[i],l=null,p=u>239?4:u>223?3:u>191?2:1;if(i+p>r)break;1===p?u<128&&(l=u):2===p?128==(192&(a=t[i+1]))&&(l=(31&u)<<6|63&a)<=127&&(l=null):3===p?(o=t[i+2],128==(192&(a=t[i+1]))&&128==(192&o)&&((l=(15&u)<<12|(63&a)<<6|63&o)<=2047||l>=55296&&l<=57343)&&(l=null)):4===p&&(o=t[i+2],s=t[i+3],128==(192&(a=t[i+1]))&&128==(192&o)&&128==(192&s)&&((l=(15&u)<<18|(63&a)<<12|(63&o)<<6|63&s)<=65535||l>=1114112)&&(l=null)),null===l?(l=65533,p=1):l>65535&&(l-=65536,n+=String.fromCharCode(l>>>10&1023|55296),l=56320|1023&l),n+=String.fromCharCode(l),i+=p;}return n}(this.buf,e,t)},readBytes:function(){var t=this.readVarint()+this.pos,e=this.buf.subarray(this.pos,t);return this.pos=t,e},readPackedVarint:function(t,e){if(this.type!==ru.Bytes)return t.push(this.readVarint(e));var r=iu(this);for(t=t||[];this.pos<r;)t.push(this.readVarint(e));return t},readPackedSVarint:function(t){if(this.type!==ru.Bytes)return t.push(this.readSVarint());var e=iu(this);for(t=t||[];this.pos<e;)t.push(this.readSVarint());return t},readPackedBoolean:function(t){if(this.type!==ru.Bytes)return t.push(this.readBoolean());var e=iu(this);for(t=t||[];this.pos<e;)t.push(this.readBoolean());return t},readPackedFloat:function(t){if(this.type!==ru.Bytes)return t.push(this.readFloat());var e=iu(this);for(t=t||[];this.pos<e;)t.push(this.readFloat());return t},readPackedDouble:function(t){if(this.type!==ru.Bytes)return t.push(this.readDouble());var e=iu(this);for(t=t||[];this.pos<e;)t.push(this.readDouble());return t},readPackedFixed32:function(t){if(this.type!==ru.Bytes)return t.push(this.readFixed32());var e=iu(this);for(t=t||[];this.pos<e;)t.push(this.readFixed32());return t},readPackedSFixed32:function(t){if(this.type!==ru.Bytes)return t.push(this.readSFixed32());var e=iu(this);for(t=t||[];this.pos<e;)t.push(this.readSFixed32());return t},readPackedFixed64:function(t){if(this.type!==ru.Bytes)return t.push(this.readFixed64());var e=iu(this);for(t=t||[];this.pos<e;)t.push(this.readFixed64());return t},readPackedSFixed64:function(t){if(this.type!==ru.Bytes)return t.push(this.readSFixed64());var e=iu(this);for(t=t||[];this.pos<e;)t.push(this.readSFixed64());return t},skip:function(t){var e=7&t;if(e===ru.Varint)for(;this.buf[this.pos++]>127;);else if(e===ru.Bytes)this.pos=this.readVarint()+this.pos;else if(e===ru.Fixed32)this.pos+=4;else{if(e!==ru.Fixed64)throw new Error("Unimplemented type: "+e);this.pos+=8;}},writeTag:function(t,e){this.writeVarint(t<<3|e);},realloc:function(t){for(var e=this.length||16;e<this.pos+t;)e*=2;if(e!==this.length){var r=new Uint8Array(e);r.set(this.buf),this.buf=r,this.length=e;}},finish:function(){return this.length=this.pos,this.pos=0,this.buf.subarray(0,this.length)},writeFixed32:function(t){this.realloc(4),vu(this.buf,t,this.pos),this.pos+=4;},writeSFixed32:function(t){this.realloc(4),vu(this.buf,t,this.pos),this.pos+=4;},writeFixed64:function(t){this.realloc(8),vu(this.buf,-1&t,this.pos),vu(this.buf,Math.floor(t*(1/4294967296)),this.pos+4),this.pos+=8;},writeSFixed64:function(t){this.realloc(8),vu(this.buf,-1&t,this.pos),vu(this.buf,Math.floor(t*(1/4294967296)),this.pos+4),this.pos+=8;},writeVarint:function(t){(t=+t||0)>268435455||t<0?function(t,e){var r,n;if(t>=0?(r=t%4294967296|0,n=t/4294967296|0):(n=~(-t/4294967296),4294967295^(r=~(-t%4294967296))?r=r+1|0:(r=0,n=n+1|0)),t>=0x10000000000000000||t<-0x10000000000000000)throw new Error("Given varint doesn't fit into 10 bytes");e.realloc(10),function(t,e,r){r.buf[r.pos++]=127&t|128,t>>>=7,r.buf[r.pos++]=127&t|128,t>>>=7,r.buf[r.pos++]=127&t|128,t>>>=7,r.buf[r.pos++]=127&t|128,r.buf[r.pos]=127&(t>>>=7);}(r,0,e),function(t,e){var r=(7&t)<<4;e.buf[e.pos++]|=r|((t>>>=3)?128:0),t&&(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),t&&(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),t&&(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),t&&(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),t&&(e.buf[e.pos++]=127&t)))));}(n,e);}(t,this):(this.realloc(4),this.buf[this.pos++]=127&t|(t>127?128:0),t<=127||(this.buf[this.pos++]=127&(t>>>=7)|(t>127?128:0),t<=127||(this.buf[this.pos++]=127&(t>>>=7)|(t>127?128:0),t<=127||(this.buf[this.pos++]=t>>>7&127))));},writeSVarint:function(t){this.writeVarint(t<0?2*-t-1:2*t);},writeBoolean:function(t){this.writeVarint(Boolean(t));},writeString:function(t){t=String(t),this.realloc(4*t.length),this.pos++;var e=this.pos;this.pos=function(t,e,r){for(var n,i,a=0;a<e.length;a++){if((n=e.charCodeAt(a))>55295&&n<57344){if(!i){n>56319||a+1===e.length?(t[r++]=239,t[r++]=191,t[r++]=189):i=n;continue}if(n<56320){t[r++]=239,t[r++]=191,t[r++]=189,i=n;continue}n=i-55296<<10|n-56320|65536,i=null;}else i&&(t[r++]=239,t[r++]=191,t[r++]=189,i=null);n<128?t[r++]=n:(n<2048?t[r++]=n>>6|192:(n<65536?t[r++]=n>>12|224:(t[r++]=n>>18|240,t[r++]=n>>12&63|128),t[r++]=n>>6&63|128),t[r++]=63&n|128);}return r}(this.buf,t,this.pos);var r=this.pos-e;r>=128&&ou(e,r,this),this.pos=e-1,this.writeVarint(r),this.pos+=r;},writeFloat:function(t){this.realloc(4),tu(this.buf,t,this.pos,!0,23,4),this.pos+=4;},writeDouble:function(t){this.realloc(8),tu(this.buf,t,this.pos,!0,52,8),this.pos+=8;},writeBytes:function(t){var e=t.length;this.writeVarint(e),this.realloc(e);for(var r=0;r<e;r++)this.buf[this.pos++]=t[r];},writeRawMessage:function(t,e){this.pos++;var r=this.pos;t(e,this);var n=this.pos-r;n>=128&&ou(r,n,this),this.pos=r-1,this.writeVarint(n),this.pos+=n;},writeMessage:function(t,e,r){this.writeTag(t,ru.Bytes),this.writeRawMessage(e,r);},writePackedVarint:function(t,e){e.length&&this.writeMessage(t,su,e);},writePackedSVarint:function(t,e){e.length&&this.writeMessage(t,uu,e);},writePackedBoolean:function(t,e){e.length&&this.writeMessage(t,cu,e);},writePackedFloat:function(t,e){e.length&&this.writeMessage(t,lu,e);},writePackedDouble:function(t,e){e.length&&this.writeMessage(t,pu,e);},writePackedFixed32:function(t,e){e.length&&this.writeMessage(t,hu,e);},writePackedSFixed32:function(t,e){e.length&&this.writeMessage(t,fu,e);},writePackedFixed64:function(t,e){e.length&&this.writeMessage(t,yu,e);},writePackedSFixed64:function(t,e){e.length&&this.writeMessage(t,du,e);},writeBytesField:function(t,e){this.writeTag(t,ru.Bytes),this.writeBytes(e);},writeFixed32Field:function(t,e){this.writeTag(t,ru.Fixed32),this.writeFixed32(e);},writeSFixed32Field:function(t,e){this.writeTag(t,ru.Fixed32),this.writeSFixed32(e);},writeFixed64Field:function(t,e){this.writeTag(t,ru.Fixed64),this.writeFixed64(e);},writeSFixed64Field:function(t,e){this.writeTag(t,ru.Fixed64),this.writeSFixed64(e);},writeVarintField:function(t,e){this.writeTag(t,ru.Varint),this.writeVarint(e);},writeSVarintField:function(t,e){this.writeTag(t,ru.Varint),this.writeSVarint(e);},writeStringField:function(t,e){this.writeTag(t,ru.Bytes),this.writeString(e);},writeFloatField:function(t,e){this.writeTag(t,ru.Fixed32),this.writeFloat(e);},writeDoubleField:function(t,e){this.writeTag(t,ru.Fixed64),this.writeDouble(e);},writeBooleanField:function(t,e){this.writeVarintField(t,Boolean(e));}};var xu=3;function bu(t,e,r){1===t&&r.readMessage(wu,e);}function wu(t,e,r){if(3===t){var n=r.readMessage(_u,{}),i=n.width,a=n.height,o=n.left,s=n.top,u=n.advance;e.push({id:n.id,bitmap:new Ao({width:i+2*xu,height:a+2*xu},n.bitmap),metrics:{width:i,height:a,left:o,top:s,advance:u}});}}function _u(t,e,r){1===t?e.id=r.readVarint():2===t?e.bitmap=r.readBytes():3===t?e.width=r.readVarint():4===t?e.height=r.readVarint():5===t?e.left=r.readSVarint():6===t?e.top=r.readSVarint():7===t&&(e.advance=r.readVarint());}var Au=xu;function Su(t){for(var e=0,r=0,n=0,i=t;n<i.length;n+=1){var a=i[n];e+=a.w*a.h,r=Math.max(r,a.w);}t.sort((function(t,e){return e.h-t.h}));for(var o=[{x:0,y:0,w:Math.max(Math.ceil(Math.sqrt(e/.95)),r),h:1/0}],s=0,u=0,l=0,p=t;l<p.length;l+=1)for(var c=p[l],h=o.length-1;h>=0;h--){var f=o[h];if(!(c.w>f.w||c.h>f.h)){if(c.x=f.x,c.y=f.y,u=Math.max(u,c.y+c.h),s=Math.max(s,c.x+c.w),c.w===f.w&&c.h===f.h){var y=o.pop();h<o.length&&(o[h]=y);}else c.h===f.h?(f.x+=c.w,f.w-=c.w):c.w===f.w?(f.y+=c.h,f.h-=c.h):(o.push({x:f.x+c.w,y:f.y,w:f.w-c.w,h:c.h}),f.y+=c.h,f.h-=c.h);break}}return {w:s,h:u,fill:e/(s*u)||0}}var ku=1,Iu=function(t,e){var r=e.pixelRatio,n=e.version,i=e.stretchX,a=e.stretchY,o=e.content;this.paddedRect=t,this.pixelRatio=r,this.stretchX=i,this.stretchY=a,this.content=o,this.version=n;},zu={tl:{configurable:!0},br:{configurable:!0},tlbr:{configurable:!0},displaySize:{configurable:!0}};zu.tl.get=function(){return [this.paddedRect.x+ku,this.paddedRect.y+ku]},zu.br.get=function(){return [this.paddedRect.x+this.paddedRect.w-ku,this.paddedRect.y+this.paddedRect.h-ku]},zu.tlbr.get=function(){return this.tl.concat(this.br)},zu.displaySize.get=function(){return [(this.paddedRect.w-2*ku)/this.pixelRatio,(this.paddedRect.h-2*ku)/this.pixelRatio]},Object.defineProperties(Iu.prototype,zu);var Cu=function(t,e){var r={},n={};this.haveRenderCallbacks=[];var i=[];this.addImages(t,r,i),this.addImages(e,n,i);var a=Su(i),o=new So({width:a.w||1,height:a.h||1});for(var s in t){var u=t[s],l=r[s].paddedRect;So.copy(u.data,o,{x:0,y:0},{x:l.x+ku,y:l.y+ku},u.data);}for(var p in e){var c=e[p],h=n[p].paddedRect,f=h.x+ku,y=h.y+ku,d=c.data.width,m=c.data.height;So.copy(c.data,o,{x:0,y:0},{x:f,y:y},c.data),So.copy(c.data,o,{x:0,y:m-1},{x:f,y:y-1},{width:d,height:1}),So.copy(c.data,o,{x:0,y:0},{x:f,y:y+m},{width:d,height:1}),So.copy(c.data,o,{x:d-1,y:0},{x:f-1,y:y},{width:1,height:m}),So.copy(c.data,o,{x:0,y:0},{x:f+d,y:y},{width:1,height:m});}this.image=o,this.iconPositions=r,this.patternPositions=n;};Cu.prototype.addImages=function(t,e,r){for(var n in t){var i=t[n],a={x:0,y:0,w:i.data.width+2*ku,h:i.data.height+2*ku};r.push(a),e[n]=new Iu(a,i),i.hasRenderCallback&&this.haveRenderCallbacks.push(n);}},Cu.prototype.patchUpdatedImages=function(t,e){for(var r in t.dispatchRenderCallbacks(this.haveRenderCallbacks),t.updatedImages)this.patchUpdatedImage(this.iconPositions[r],t.getImage(r),e),this.patchUpdatedImage(this.patternPositions[r],t.getImage(r),e);},Cu.prototype.patchUpdatedImage=function(t,e,r){if(t&&e&&t.version!==e.version){t.version=e.version;var n=t.tl;r.update(e.data,void 0,{x:n[0],y:n[1]});}},Hn("ImagePosition",Iu),Hn("ImageAtlas",Cu);var Mu={horizontal:1,vertical:2,horizontalOnly:3},Tu=-17,Eu=function(){this.scale=1,this.fontStack="",this.imageName=null;};Eu.forText=function(t,e){var r=new Eu;return r.scale=t||1,r.fontStack=e,r},Eu.forImage=function(t){var e=new Eu;return e.imageName=t,e};var Pu=function(){this.text="",this.sectionIndex=[],this.sections=[],this.imageSectionID=null;};function Bu(t,e,r,n,i,a,o,s,u,l,p,c,h,f,y,d){var m,v=Pu.fromFeature(t,i);c===Mu.vertical&&v.verticalizePunctuation();var g=vi.processBidirectionalText,x=vi.processStyledBidirectionalText;if(g&&1===v.sections.length){m=[];for(var b=0,w=g(v.toString(),Uu(v,l,a,e,n,f,y));b<w.length;b+=1){var _=w[b],A=new Pu;A.text=_,A.sections=v.sections;for(var S=0;S<_.length;S++)A.sectionIndex.push(0);m.push(A);}}else if(x){m=[];for(var k=0,I=x(v.text,v.sectionIndex,Uu(v,l,a,e,n,f,y));k<I.length;k+=1){var z=I[k],C=new Pu;C.text=z[0],C.sectionIndex=z[1],C.sections=v.sections,m.push(C);}}else m=function(t,e){for(var r=[],n=t.text,i=0,a=0,o=e;a<o.length;a+=1){var s=o[a];r.push(t.substring(i,s)),i=s;}return i<n.length&&r.push(t.substring(i,n.length)),r}(v,Uu(v,l,a,e,n,f,y));var M=[],T={positionedLines:M,text:v.toString(),top:p[1],bottom:p[1],left:p[0],right:p[0],writingMode:c,iconsInText:!1,verticalizable:!1};return function(t,e,r,n,i,a,o,s,u,l,p,c){for(var h=0,f=Tu,y=0,d=0,m="right"===s?1:"left"===s?0:.5,v=0,g=0,x=i;g<x.length;g+=1){var b=x[g];b.trim();var w=b.getMaxScale(),_=(w-1)*Ws,A={positionedGlyphs:[],lineOffset:0};t.positionedLines[v]=A;var S=A.positionedGlyphs,k=0;if(b.length()){for(var I=0;I<b.length();I++){var z=b.getSection(I),C=b.getSectionIndex(I),M=b.getCharCode(I),T=0,E=null,P=null,B=null,V=Ws,F=!(u===Mu.horizontal||!p&&!ii(M)||p&&(Vu[M]||(K=M,ri.Arabic(K)||ri["Arabic Supplement"](K)||ri["Arabic Extended-A"](K)||ri["Arabic Presentation Forms-A"](K)||ri["Arabic Presentation Forms-B"](K))));if(z.imageName){var D=n[z.imageName];if(!D)continue;B=z.imageName,t.iconsInText=t.iconsInText||!0,P=D.paddedRect;var L=D.displaySize;z.scale=z.scale*Ws/c,T=_+(Ws-L[1]*z.scale),V=(E={width:L[0],height:L[1],left:ku,top:-Au,advance:F?L[1]:L[0]}).advance;var R=F?L[0]*z.scale-Ws*w:L[1]*z.scale-Ws*w;R>0&&R>k&&(k=R);}else{var O=r[z.fontStack],U=O&&O[M];if(U&&U.rect)P=U.rect,E=U.metrics;else{var j=e[z.fontStack],q=j&&j[M];if(!q)continue;E=q.metrics;}T=(w-z.scale)*Ws;}F?(t.verticalizable=!0,S.push({glyph:M,imageName:B,x:h,y:f+T,vertical:F,scale:z.scale,fontStack:z.fontStack,sectionIndex:C,metrics:E,rect:P}),h+=V*z.scale+l):(S.push({glyph:M,imageName:B,x:h,y:f+T,vertical:F,scale:z.scale,fontStack:z.fontStack,sectionIndex:C,metrics:E,rect:P}),h+=E.advance*z.scale+l);}0!==S.length&&(y=Math.max(h-l,y),qu(S,0,S.length-1,m,k)),h=0;var N=a*w+k;A.lineOffset=Math.max(k,_),f+=N,d=Math.max(N,d),++v;}else f+=a,++v;}var K,X=f-Tu,G=ju(o),Z=G.horizontalAlign,J=G.verticalAlign;(function(t,e,r,n,i,a,o,s,u){var l,p=(e-r)*i;l=a!==o?-s*n-Tu:(-n*u+.5)*o;for(var c=0,h=t;c<h.length;c+=1)for(var f=0,y=h[c].positionedGlyphs;f<y.length;f+=1){var d=y[f];d.x+=p,d.y+=l;}})(t.positionedLines,m,Z,J,y,d,a,X,i.length),t.top+=-J*X,t.bottom=t.top+X,t.left+=-Z*y,t.right=t.left+y;}(T,e,r,n,m,o,s,u,c,l,h,d),!function(t){for(var e=0,r=t;e<r.length;e+=1)if(0!==r[e].positionedGlyphs.length)return !1;return !0}(M)&&T}Pu.fromFeature=function(t,e){for(var r=new Pu,n=0;n<t.sections.length;n++){var i=t.sections[n];i.image?r.addImageSection(i):r.addTextSection(i,e);}return r},Pu.prototype.length=function(){return this.text.length},Pu.prototype.getSection=function(t){return this.sections[this.sectionIndex[t]]},Pu.prototype.getSectionIndex=function(t){return this.sectionIndex[t]},Pu.prototype.getCharCode=function(t){return this.text.charCodeAt(t)},Pu.prototype.verticalizePunctuation=function(){this.text=function(t){for(var e="",r=0;r<t.length;r++){var n=t.charCodeAt(r+1)||null,i=t.charCodeAt(r-1)||null;e+=n&&ai(n)&&!$s[t[r+1]]||i&&ai(i)&&!$s[t[r-1]]||!$s[t[r]]?t[r]:$s[t[r]];}return e}(this.text);},Pu.prototype.trim=function(){for(var t=0,e=0;e<this.text.length&&Vu[this.text.charCodeAt(e)];e++)t++;for(var r=this.text.length,n=this.text.length-1;n>=0&&n>=t&&Vu[this.text.charCodeAt(n)];n--)r--;this.text=this.text.substring(t,r),this.sectionIndex=this.sectionIndex.slice(t,r);},Pu.prototype.substring=function(t,e){var r=new Pu;return r.text=this.text.substring(t,e),r.sectionIndex=this.sectionIndex.slice(t,e),r.sections=this.sections,r},Pu.prototype.toString=function(){return this.text},Pu.prototype.getMaxScale=function(){var t=this;return this.sectionIndex.reduce((function(e,r){return Math.max(e,t.sections[r].scale)}),0)},Pu.prototype.addTextSection=function(t,e){this.text+=t.text,this.sections.push(Eu.forText(t.scale,t.fontStack||e));for(var r=this.sections.length-1,n=0;n<t.text.length;++n)this.sectionIndex.push(r);},Pu.prototype.addImageSection=function(t){var e=t.image?t.image.name:"";if(0!==e.length){var r=this.getNextImageSectionCharCode();r?(this.text+=String.fromCharCode(r),this.sections.push(Eu.forImage(e)),this.sectionIndex.push(this.sections.length-1)):w("Reached maximum number of images 6401");}else w("Can't add FormattedSection with an empty image.");},Pu.prototype.getNextImageSectionCharCode=function(){return this.imageSectionID?this.imageSectionID>=63743?null:++this.imageSectionID:(this.imageSectionID=57344,this.imageSectionID)};var Vu={9:!0,10:!0,11:!0,12:!0,13:!0,32:!0},Fu={};function Du(t,e,r,n,i,a){if(e.imageName){var o=n[e.imageName];return o?o.displaySize[0]*e.scale*Ws/a+i:0}var s=r[e.fontStack],u=s&&s[t];return u?u.metrics.advance*e.scale+i:0}function Lu(t,e,r,n){var i=Math.pow(t-e,2);return n?t<e?i/2:2*i:i+Math.abs(r)*r}function Ru(t,e,r){var n=0;return 10===t&&(n-=1e4),r&&(n+=150),40!==t&&65288!==t||(n+=50),41!==e&&65289!==e||(n+=50),n}function Ou(t,e,r,n,i,a){for(var o=null,s=Lu(e,r,i,a),u=0,l=n;u<l.length;u+=1){var p=l[u],c=Lu(e-p.x,r,i,a)+p.badness;c<=s&&(o=p,s=c);}return {index:t,x:e,priorBreak:o,badness:s}}function Uu(t,e,r,n,i,a,o){if("point"!==a)return [];if(!t)return [];for(var s,u=[],l=function(t,e,r,n,i,a){for(var o=0,s=0;s<t.length();s++){var u=t.getSection(s);o+=Du(t.getCharCode(s),u,n,i,e,a);}return o/Math.max(1,Math.ceil(o/r))}(t,e,r,n,i,o),p=t.text.indexOf("")>=0,c=0,h=0;h<t.length();h++){var f=t.getSection(h),y=t.getCharCode(h);if(Vu[y]||(c+=Du(y,f,n,i,e,o)),h<t.length()-1){var d=!((s=y)<11904||!(ri["Bopomofo Extended"](s)||ri.Bopomofo(s)||ri["CJK Compatibility Forms"](s)||ri["CJK Compatibility Ideographs"](s)||ri["CJK Compatibility"](s)||ri["CJK Radicals Supplement"](s)||ri["CJK Strokes"](s)||ri["CJK Symbols and Punctuation"](s)||ri["CJK Unified Ideographs Extension A"](s)||ri["CJK Unified Ideographs"](s)||ri["Enclosed CJK Letters and Months"](s)||ri["Halfwidth and Fullwidth Forms"](s)||ri.Hiragana(s)||ri["Ideographic Description Characters"](s)||ri["Kangxi Radicals"](s)||ri["Katakana Phonetic Extensions"](s)||ri.Katakana(s)||ri["Vertical Forms"](s)||ri["Yi Radicals"](s)||ri["Yi Syllables"](s)));(Fu[y]||d||f.imageName)&&u.push(Ou(h+1,c,l,u,Ru(y,t.getCharCode(h+1),d&&p),!1));}}return function t(e){return e?t(e.priorBreak).concat(e.index):[]}(Ou(t.length(),c,l,u,0,!0))}function ju(t){var e=.5,r=.5;switch(t){case"right":case"top-right":case"bottom-right":e=1;break;case"left":case"top-left":case"bottom-left":e=0;}switch(t){case"bottom":case"bottom-right":case"bottom-left":r=1;break;case"top":case"top-right":case"top-left":r=0;}return {horizontalAlign:e,verticalAlign:r}}function qu(t,e,r,n,i){if(n||i)for(var a=t[r],o=(t[r].x+a.metrics.advance*a.scale)*n,s=e;s<=r;s++)t[s].x-=o,t[s].y+=i;}function Nu(t,e,r,n,i,a){var o,s=t.image;if(s.content){var u=s.content,l=s.pixelRatio||1;o=[u[0]/l,u[1]/l,s.displaySize[0]-u[2]/l,s.displaySize[1]-u[3]/l];}var p,c,h,f,y=e.left*a,d=e.right*a;"width"===r||"both"===r?(f=i[0]+y-n[3],c=i[0]+d+n[1]):c=(f=i[0]+(y+d-s.displaySize[0])/2)+s.displaySize[0];var m=e.top*a,v=e.bottom*a;return "height"===r||"both"===r?(p=i[1]+m-n[0],h=i[1]+v+n[2]):h=(p=i[1]+(m+v-s.displaySize[1])/2)+s.displaySize[1],{image:s,top:p,right:c,bottom:h,left:f,collisionPadding:o}}Fu[10]=!0,Fu[32]=!0,Fu[38]=!0,Fu[40]=!0,Fu[41]=!0,Fu[43]=!0,Fu[45]=!0,Fu[47]=!0,Fu[173]=!0,Fu[183]=!0,Fu[8203]=!0,Fu[8208]=!0,Fu[8211]=!0,Fu[8231]=!0;var Ku=function(t){function e(e,r,n,i){t.call(this,e,r),this.angle=n,void 0!==i&&(this.segment=i);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.clone=function(){return new e(this.x,this.y,this.angle,this.segment)},e}(i);Hn("Anchor",Ku);var Xu=128;function Gu(t,e){var r=e.expression;if("constant"===r.kind)return {kind:"constant",layoutSize:r.evaluate(new gi(t+1))};if("source"===r.kind)return {kind:"source"};for(var n=r.zoomStops,i=r.interpolationType,a=0;a<n.length&&n[a]<=t;)a++;for(var o=a=Math.max(0,a-1);o<n.length&&n[o]<t+1;)o++;o=Math.min(n.length-1,o);var s=n[a],u=n[o];return "composite"===r.kind?{kind:"composite",minZoom:s,maxZoom:u,interpolationType:i}:{kind:"camera",minZoom:s,maxZoom:u,minSize:r.evaluate(new gi(s)),maxSize:r.evaluate(new gi(u)),interpolationType:i}}function Zu(t,e,r){var n=e.uSize,i=r.lowerSize;return "source"===t.kind?i/Xu:"composite"===t.kind?Ye(i/Xu,r.upperSize/Xu,e.uSizeT):n}function Ju(t,e){var r=0,n=0;if("constant"===t.kind)n=t.layoutSize;else if("source"!==t.kind){var i=t.interpolationType,a=i?u(vr.interpolationFactor(i,e,t.minZoom,t.maxZoom),0,1):0;"camera"===t.kind?n=Ye(t.minSize,t.maxSize,a):r=a;}return {uSizeT:r,uSize:n}}var Hu=Object.freeze({__proto__:null,getSizeData:Gu,evaluateSizeForFeature:Zu,evaluateSizeForZoom:Ju,SIZE_PACK_FACTOR:Xu});function Yu(t,e,r,n,i){if(void 0===e.segment)return !0;for(var a=e,o=e.segment+1,s=0;s>-r/2;){if(--o<0)return !1;s-=t[o].dist(a),a=t[o];}s+=t[o].dist(t[o+1]),o++;for(var u=[],l=0;s<r/2;){var p=t[o],c=t[o+1];if(!c)return !1;var h=t[o-1].angleTo(p)-p.angleTo(c);for(h=Math.abs((h+3*Math.PI)%(2*Math.PI)-Math.PI),u.push({distance:s,angleDelta:h}),l+=h;s-u[0].distance>n;)l-=u.shift().angleDelta;if(l>i)return !1;o++,s+=p.dist(c);}return !0}function $u(t){for(var e=0,r=0;r<t.length-1;r++)e+=t[r].dist(t[r+1]);return e}function Wu(t,e,r){return t?.6*e*r:0}function Qu(t,e){return Math.max(t?t.right-t.left:0,e?e.right-e.left:0)}function tl(t,e,r,n,i,a){for(var o=Wu(r,i,a),s=Qu(r,n)*a,u=0,l=$u(t)/2,p=0;p<t.length-1;p++){var c=t[p],h=t[p+1],f=c.dist(h);if(u+f>l){var y=(l-u)/f,d=Ye(c.x,h.x,y),m=Ye(c.y,h.y,y),v=new Ku(d,m,h.angleTo(c),p);return v._round(),!o||Yu(t,v,s,o,e)?v:void 0}u+=f;}}function el(t,e,r,n,i,a,o,s,u){var l=Wu(n,a,o),p=Qu(n,i),c=p*o,h=0===t[0].x||t[0].x===u||0===t[0].y||t[0].y===u;return e-c<e/4&&(e=c+e/4),function t(e,r,n,i,a,o,s,u,l){for(var p=o/2,c=$u(e),h=0,f=r-n,y=[],d=0;d<e.length-1;d++){for(var m=e[d],v=e[d+1],g=m.dist(v),x=v.angleTo(m);f+n<h+g;){var b=((f+=n)-h)/g,w=Ye(m.x,v.x,b),_=Ye(m.y,v.y,b);if(w>=0&&w<l&&_>=0&&_<l&&f-p>=0&&f+p<=c){var A=new Ku(w,_,x,d);A._round(),i&&!Yu(e,A,o,i,a)||y.push(A);}}h+=g;}return u||y.length||s||(y=t(e,h/2,n,i,a,o,s,!0,l)),y}(t,h?e/2*s%e:(p/2+2*a)*o*s%e,e,l,r,c,h,!1,u)}var rl=ku;function nl(t,e,r,n){var a=[],o=t.image,s=o.pixelRatio,u=o.paddedRect.w-2*rl,l=o.paddedRect.h-2*rl,p=t.right-t.left,c=t.bottom-t.top,h=o.stretchX||[[0,u]],f=o.stretchY||[[0,l]],y=function(t,e){return t+e[1]-e[0]},d=h.reduce(y,0),m=f.reduce(y,0),v=u-d,g=l-m,x=0,b=d,w=0,_=m,A=0,S=v,k=0,I=g;if(o.content&&n){var z=o.content;x=il(h,0,z[0]),w=il(f,0,z[1]),b=il(h,z[0],z[2]),_=il(f,z[1],z[3]),A=z[0]-x,k=z[1]-w,S=z[2]-z[0]-b,I=z[3]-z[1]-_;}var C=function(n,a,u,l){var h=ol(n.stretch-x,b,p,t.left),f=sl(n.fixed-A,S,n.stretch,d),y=ol(a.stretch-w,_,c,t.top),v=sl(a.fixed-k,I,a.stretch,m),g=ol(u.stretch-x,b,p,t.left),z=sl(u.fixed-A,S,u.stretch,d),C=ol(l.stretch-w,_,c,t.top),M=sl(l.fixed-k,I,l.stretch,m),T=new i(h,y),E=new i(g,y),P=new i(g,C),B=new i(h,C),V=new i(f/s,v/s),F=new i(z/s,M/s),D=e*Math.PI/180;if(D){var L=Math.sin(D),R=Math.cos(D),O=[R,-L,L,R];T._matMult(O),E._matMult(O),B._matMult(O),P._matMult(O);}var U=n.stretch+n.fixed,j=a.stretch+a.fixed;return {tl:T,tr:E,bl:B,br:P,tex:{x:o.paddedRect.x+rl+U,y:o.paddedRect.y+rl+j,w:u.stretch+u.fixed-U,h:l.stretch+l.fixed-j},writingMode:void 0,glyphOffset:[0,0],sectionIndex:0,pixelOffsetTL:V,pixelOffsetBR:F,minFontScaleX:S/s/p,minFontScaleY:I/s/c,isSDF:r}};if(n&&(o.stretchX||o.stretchY))for(var M=al(h,v,d),T=al(f,g,m),E=0;E<M.length-1;E++)for(var P=M[E],B=M[E+1],V=0;V<T.length-1;V++)a.push(C(P,T[V],B,T[V+1]));else a.push(C({fixed:0,stretch:-1},{fixed:0,stretch:-1},{fixed:0,stretch:u+1},{fixed:0,stretch:l+1}));return a}function il(t,e,r){for(var n=0,i=0,a=t;i<a.length;i+=1){var o=a[i];n+=Math.max(e,Math.min(r,o[1]))-Math.max(e,Math.min(r,o[0]));}return n}function al(t,e,r){for(var n=[{fixed:-rl,stretch:0}],i=0,a=t;i<a.length;i+=1){var o=a[i],s=o[0],u=o[1],l=n[n.length-1];n.push({fixed:s-l.stretch,stretch:l.stretch}),n.push({fixed:s-l.stretch,stretch:l.stretch+(u-s)});}return n.push({fixed:e+rl,stretch:r}),n}function ol(t,e,r,n){return t/e*r+n}function sl(t,e,r,n){return t-e*r/n}var ul=function(t,e,r,n,a,o,s,u,l,p,c,h){var f=s.top*u-l,y=s.bottom*u+l,d=s.left*u-l,m=s.right*u+l,v=s.collisionPadding;if(v&&(d-=v[0]*u,f-=v[1]*u,m+=v[2]*u,y+=v[3]*u),this.boxStartIndex=t.length,p){var g=y-f,x=m-d;g>0&&(g=Math.max(10*u,g),this._addLineCollisionCircles(t,e,r,r.segment,x,g,n,a,o,c));}else{if(h){var b=new i(d,f),w=new i(m,f),_=new i(d,y),A=new i(m,y),S=h*Math.PI/180;b._rotate(S),w._rotate(S),_._rotate(S),A._rotate(S),d=Math.min(b.x,w.x,_.x,A.x),m=Math.max(b.x,w.x,_.x,A.x),f=Math.min(b.y,w.y,_.y,A.y),y=Math.max(b.y,w.y,_.y,A.y);}t.emplaceBack(r.x,r.y,d,f,m,y,n,a,o,0,0);}this.boxEndIndex=t.length;};ul.prototype._addLineCollisionCircles=function(t,e,r,n,i,a,o,s,u,l){var p=a/2,c=Math.floor(i/p)||1,h=1+.4*Math.log(l)/Math.LN2,f=Math.floor(c*h/2),y=-a/2,d=r,m=n+1,v=y,g=-i/2,x=g-i/4;do{if(--m<0){if(v>g)return;m=0;break}v-=e[m].dist(d),d=e[m];}while(v>x);for(var b=e[m].dist(e[m+1]),w=-f;w<c+f;w++){var _=w*p,A=g+_;if(_<0&&(A+=_),_>i&&(A+=_-i),!(A<v)){for(;v+b<A;){if(v+=b,++m+1>=e.length)return;b=e[m].dist(e[m+1]);}var S=A-v,k=e[m],I=e[m+1].sub(k)._unit()._mult(S)._add(k)._round(),z=Math.abs(A-y)<p?0:.8*(A-y);t.emplaceBack(I.x,I.y,-a/2,-a/2,a/2,a/2,o,s,u,a/2,z);}}};var ll=function(t,e){if(void 0===t&&(t=[]),void 0===e&&(e=pl),this.data=t,this.length=this.data.length,this.compare=e,this.length>0)for(var r=(this.length>>1)-1;r>=0;r--)this._down(r);};function pl(t,e){return t<e?-1:t>e?1:0}function cl(t,e,r){void 0===e&&(e=1),void 0===r&&(r=!1);for(var n=1/0,a=1/0,o=-1/0,s=-1/0,u=t[0],l=0;l<u.length;l++){var p=u[l];(!l||p.x<n)&&(n=p.x),(!l||p.y<a)&&(a=p.y),(!l||p.x>o)&&(o=p.x),(!l||p.y>s)&&(s=p.y);}var c=Math.min(o-n,s-a),h=c/2,f=new ll([],hl);if(0===c)return new i(n,a);for(var y=n;y<o;y+=c)for(var d=a;d<s;d+=c)f.push(new fl(y+h,d+h,h,t));for(var m=function(t){for(var e=0,r=0,n=0,i=t[0],a=0,o=i.length,s=o-1;a<o;s=a++){var u=i[a],l=i[s],p=u.x*l.y-l.x*u.y;r+=(u.x+l.x)*p,n+=(u.y+l.y)*p,e+=3*p;}return new fl(r/e,n/e,0,t)}(t),v=f.length;f.length;){var g=f.pop();(g.d>m.d||!m.d)&&(m=g,r&&console.log("found best %d after %d probes",Math.round(1e4*g.d)/1e4,v)),g.max-m.d<=e||(f.push(new fl(g.p.x-(h=g.h/2),g.p.y-h,h,t)),f.push(new fl(g.p.x+h,g.p.y-h,h,t)),f.push(new fl(g.p.x-h,g.p.y+h,h,t)),f.push(new fl(g.p.x+h,g.p.y+h,h,t)),v+=4);}return r&&(console.log("num probes: "+v),console.log("best distance: "+m.d)),m.p}function hl(t,e){return e.max-t.max}function fl(t,e,r,n){this.p=new i(t,e),this.h=r,this.d=function(t,e){for(var r=!1,n=1/0,i=0;i<e.length;i++)for(var a=e[i],o=0,s=a.length,u=s-1;o<s;u=o++){var l=a[o],p=a[u];l.y>t.y!=p.y>t.y&&t.x<(p.x-l.x)*(t.y-l.y)/(p.y-l.y)+l.x&&(r=!r),n=Math.min(n,io(t,l,p));}return (r?1:-1)*Math.sqrt(n)}(this.p,n),this.max=this.d+this.h*Math.SQRT2;}ll.prototype.push=function(t){this.data.push(t),this.length++,this._up(this.length-1);},ll.prototype.pop=function(){if(0!==this.length){var t=this.data[0],e=this.data.pop();return this.length--,this.length>0&&(this.data[0]=e,this._down(0)),t}},ll.prototype.peek=function(){return this.data[0]},ll.prototype._up=function(t){for(var e=this.data,r=this.compare,n=e[t];t>0;){var i=t-1>>1,a=e[i];if(r(n,a)>=0)break;e[t]=a,t=i;}e[t]=n;},ll.prototype._down=function(t){for(var e=this.data,r=this.compare,n=this.length>>1,i=e[t];t<n;){var a=1+(t<<1),o=e[a],s=a+1;if(s<this.length&&r(e[s],o)<0&&(a=s,o=e[s]),r(o,i)>=0)break;e[t]=o,t=a;}e[t]=i;};var yl=7,dl=Number.POSITIVE_INFINITY;function ml(t,e){return e[1]!==dl?function(t,e,r){var n=0,i=0;switch(e=Math.abs(e),r=Math.abs(r),t){case"top-right":case"top-left":case"top":i=r-yl;break;case"bottom-right":case"bottom-left":case"bottom":i=-r+yl;}switch(t){case"top-right":case"bottom-right":case"right":n=-e;break;case"top-left":case"bottom-left":case"left":n=e;}return [n,i]}(t,e[0],e[1]):function(t,e){var r=0,n=0;e<0&&(e=0);var i=e/Math.sqrt(2);switch(t){case"top-right":case"top-left":n=i-yl;break;case"bottom-right":case"bottom-left":n=-i+yl;break;case"bottom":n=-e+yl;break;case"top":n=e-yl;}switch(t){case"top-right":case"bottom-right":r=-i;break;case"top-left":case"bottom-left":r=i;break;case"left":r=e;break;case"right":r=-e;}return [r,n]}(t,e[0])}function vl(t){switch(t){case"right":case"top-right":case"bottom-right":return "right";case"left":case"top-left":case"bottom-left":return "left"}return "center"}var gl=255,xl=gl*Xu;function bl(t,e,r,n,a,o,s,u,l,p,c,h,f,y,d){var m=function(t,e,r,n,a,o,s,u){for(var l=n.layout.get("text-rotate").evaluate(o,{})*Math.PI/180,p=[],c=0,h=e.positionedLines;c<h.length;c+=1)for(var f=h[c],y=0,d=f.positionedGlyphs;y<d.length;y+=1){var m=d[y];if(m.rect){var v=m.rect||{},g=Au+1,x=!0,b=1,w=0,_=(a||u)&&m.vertical,A=m.metrics.advance*m.scale/2;if(u&&e.verticalizable&&(w=f.lineOffset/2-(m.imageName?-(Ws-m.metrics.width*m.scale)/2:(m.scale-1)*Ws)),m.imageName){var S=s[m.imageName];x=S.sdf,g=ku/(b=S.pixelRatio);}var k=a?[m.x+A,m.y]:[0,0],I=a?[0,0]:[m.x+A+r[0],m.y+r[1]-w],z=[0,0];_&&(z=I,I=[0,0]);var C=(m.metrics.left-g)*m.scale-A+I[0],M=(-m.metrics.top-g)*m.scale+I[1],T=C+v.w*m.scale/b,E=M+v.h*m.scale/b,P=new i(C,M),B=new i(T,M),V=new i(C,E),F=new i(T,E);if(_){var D=new i(-A,A-Tu),L=-Math.PI/2,R=Ws/2-A,O=new i(5-Tu-R,-(m.imageName?R:0)),U=new(Function.prototype.bind.apply(i,[null].concat(z)));P._rotateAround(L,D)._add(O)._add(U),B._rotateAround(L,D)._add(O)._add(U),V._rotateAround(L,D)._add(O)._add(U),F._rotateAround(L,D)._add(O)._add(U);}if(l){var j=Math.sin(l),q=Math.cos(l),N=[q,-j,j,q];P._matMult(N),B._matMult(N),V._matMult(N),F._matMult(N);}var K=new i(0,0),X=new i(0,0);p.push({tl:P,tr:B,bl:V,br:F,tex:v,writingMode:e.writingMode,glyphOffset:k,sectionIndex:m.sectionIndex,isSDF:x,pixelOffsetTL:K,pixelOffsetBR:X,minFontScaleX:0,minFontScaleY:0});}}return p}(0,r,u,a,o,s,n,t.allowVerticalPlacement),v=t.textSizeData,g=null;"source"===v.kind?(g=[Xu*a.layout.get("text-size").evaluate(s,{})])[0]>xl&&w(t.layerIds[0]+': Value for "text-size" is >= '+gl+'. Reduce your "text-size".'):"composite"===v.kind&&((g=[Xu*y.compositeTextSizes[0].evaluate(s,{},d),Xu*y.compositeTextSizes[1].evaluate(s,{},d)])[0]>xl||g[1]>xl)&&w(t.layerIds[0]+': Value for "text-size" is >= '+gl+'. Reduce your "text-size".'),t.addSymbols(t.text,m,g,u,o,s,p,e,l.lineStartIndex,l.lineLength,f,d);for(var x=0,b=c;x<b.length;x+=1)h[b[x]]=t.text.placedSymbolArray.length-1;return 4*m.length}function wl(t){for(var e in t)return t[e];return null}function _l(t,e,r,n){var i=t.compareText;if(e in i){for(var a=i[e],o=a.length-1;o>=0;o--)if(n.dist(a[o])<r)return !0}else i[e]=[];return i[e].push(n),!1}var Al=ks.VectorTileFeature.types,Sl=[{name:"a_fade_opacity",components:1,type:"Uint8",offset:0}];function kl(t,e,r,n,i,a,o,s,u,l,p,c,h){var f=s?Math.min(xl,Math.round(s[0])):0,y=s?Math.min(xl,Math.round(s[1])):0;t.emplaceBack(e,r,Math.round(32*n),Math.round(32*i),a,o,(f<<1)+(u?1:0),y,16*l,16*p,256*c,256*h);}function Il(t,e,r){t.emplaceBack(e.x,e.y,r),t.emplaceBack(e.x,e.y,r),t.emplaceBack(e.x,e.y,r),t.emplaceBack(e.x,e.y,r);}function zl(t){for(var e=0,r=t.sections;e<r.length;e+=1)if(ui(r[e].text))return !0;return !1}var Cl=function(t){this.layoutVertexArray=new Ki,this.indexArray=new ea,this.programConfigurations=t,this.segments=new va,this.dynamicLayoutVertexArray=new Xi,this.opacityVertexArray=new Gi,this.placedSymbolArray=new la;};Cl.prototype.isEmpty=function(){return 0===this.layoutVertexArray.length&&0===this.indexArray.length&&0===this.dynamicLayoutVertexArray.length&&0===this.opacityVertexArray.length},Cl.prototype.upload=function(t,e,r,n){this.isEmpty()||(r&&(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,Xs.members),this.indexBuffer=t.createIndexBuffer(this.indexArray,e),this.dynamicLayoutVertexBuffer=t.createVertexBuffer(this.dynamicLayoutVertexArray,Gs.members,!0),this.opacityVertexBuffer=t.createVertexBuffer(this.opacityVertexArray,Sl,!0),this.opacityVertexBuffer.itemSize=1),(r||n)&&this.programConfigurations.upload(t));},Cl.prototype.destroy=function(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.dynamicLayoutVertexBuffer.destroy(),this.opacityVertexBuffer.destroy());},Hn("SymbolBuffers",Cl);var Ml=function(t,e,r){this.layoutVertexArray=new t,this.layoutAttributes=e,this.indexArray=new r,this.segments=new va,this.collisionVertexArray=new Hi;};Ml.prototype.upload=function(t){this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,this.layoutAttributes),this.indexBuffer=t.createIndexBuffer(this.indexArray),this.collisionVertexBuffer=t.createVertexBuffer(this.collisionVertexArray,Zs.members,!0);},Ml.prototype.destroy=function(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.segments.destroy(),this.collisionVertexBuffer.destroy());},Hn("CollisionBuffers",Ml);var Tl=function(t){this.collisionBoxArray=t.collisionBoxArray,this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map((function(t){return t.id})),this.index=t.index,this.pixelRatio=t.pixelRatio,this.sourceLayerIndex=t.sourceLayerIndex,this.hasPattern=!1,this.hasRTLText=!1,this.sortKeyRanges=[];var e=this.layers[0]._unevaluatedLayout._values;this.textSizeData=Gu(this.zoom,e["text-size"]),this.iconSizeData=Gu(this.zoom,e["icon-size"]);var r=this.layers[0].layout,n=r.get("symbol-sort-key"),i=r.get("symbol-z-order");this.sortFeaturesByKey="viewport-y"!==i&&void 0!==n.constantOr(1),this.sortFeaturesByY=("viewport-y"===i||"auto"===i&&!this.sortFeaturesByKey)&&(r.get("text-allow-overlap")||r.get("icon-allow-overlap")||r.get("text-ignore-placement")||r.get("icon-ignore-placement")),"point"===r.get("symbol-placement")&&(this.writingModes=r.get("text-writing-mode").map((function(t){return Mu[t]}))),this.stateDependentLayerIds=this.layers.filter((function(t){return t.isStateDependent()})).map((function(t){return t.id})),this.sourceID=t.sourceID;};Tl.prototype.createArrays=function(){this.text=new Cl(new Ka(Xs.members,this.layers,this.zoom,(function(t){return /^text/.test(t)}))),this.icon=new Cl(new Ka(Xs.members,this.layers,this.zoom,(function(t){return /^icon/.test(t)}))),this.glyphOffsetArray=new ha,this.lineVertexArray=new fa,this.symbolInstances=new ca;},Tl.prototype.calculateGlyphDependencies=function(t,e,r,n,i){for(var a=0;a<t.length;a++)if(e[t.charCodeAt(a)]=!0,(r||n)&&i){var o=$s[t.charAt(a)];o&&(e[o.charCodeAt(0)]=!0);}},Tl.prototype.populate=function(t,e,r){var n=this.layers[0],i=n.layout,a=i.get("text-font"),o=i.get("text-field"),s=i.get("icon-image"),u=("constant"!==o.value.kind||o.value.value instanceof te&&!o.value.value.isEmpty()||o.value.value.toString().length>0)&&("constant"!==a.value.kind||a.value.value.length>0),l="constant"!==s.value.kind||!!s.value.value||Object.keys(s.parameters).length>0,p=i.get("symbol-sort-key");if(this.features=[],u||l){for(var c=e.iconDependencies,h=e.glyphDependencies,f=e.availableImages,y=new gi(this.zoom),d=0,m=t;d<m.length;d+=1){var v=m[d],g=v.feature,x=v.id,b=v.index,w=v.sourceLayerIndex,_=n._featureFilter.needGeometry,A={type:g.type,id:x,properties:g.properties,geometry:_?Ja(g):[]};if(n._featureFilter.filter(y,A,r)){_||(A.geometry=Ja(g));var S=void 0;if(u){var k=n.getValueAndResolveTokens("text-field",A,r,f),I=te.factory(k);zl(I)&&(this.hasRTLText=!0),(!this.hasRTLText||"unavailable"===di()||this.hasRTLText&&vi.isParsed())&&(S=Ys(I,n,A));}var z=void 0;if(l){var C=n.getValueAndResolveTokens("icon-image",A,r,f);z=C instanceof ee?C:ee.fromString(C);}if(S||z){var M=this.sortFeaturesByKey?p.evaluate(A,{},r):void 0,T={id:x,text:S,icon:z,index:b,sourceLayerIndex:w,geometry:Ja(g),properties:g.properties,type:Al[g.type],sortKey:M};if(this.features.push(T),z&&(c[z.name]=!0),S){var E=a.evaluate(A,{},r).join(","),P="map"===i.get("text-rotation-alignment")&&"point"!==i.get("symbol-placement");this.allowVerticalPlacement=this.writingModes&&this.writingModes.indexOf(Mu.vertical)>=0;for(var B=0,V=S.sections;B<V.length;B+=1){var F=V[B];if(F.image)c[F.image.name]=!0;else{var D=ni(S.toString()),L=F.fontStack||E,R=h[L]=h[L]||{};this.calculateGlyphDependencies(F.text,R,P,this.allowVerticalPlacement,D);}}}}}}"line"===i.get("symbol-placement")&&(this.features=function(t){var e={},r={},n=[],i=0;function a(e){n.push(t[e]),i++;}function o(t,e,i){var a=r[t];return delete r[t],r[e]=a,n[a].geometry[0].pop(),n[a].geometry[0]=n[a].geometry[0].concat(i[0]),a}function s(t,r,i){var a=e[r];return delete e[r],e[t]=a,n[a].geometry[0].shift(),n[a].geometry[0]=i[0].concat(n[a].geometry[0]),a}function u(t,e,r){var n=r?e[0][e[0].length-1]:e[0][0];return t+":"+n.x+":"+n.y}for(var l=0;l<t.length;l++){var p=t[l],c=p.geometry,h=p.text?p.text.toString():null;if(h){var f=u(h,c),y=u(h,c,!0);if(f in r&&y in e&&r[f]!==e[y]){var d=s(f,y,c),m=o(f,y,n[d].geometry);delete e[f],delete r[y],r[u(h,n[m].geometry,!0)]=m,n[d].geometry=null;}else f in r?o(f,y,c):y in e?s(f,y,c):(a(l),e[f]=i-1,r[y]=i-1);}else a(l);}return n.filter((function(t){return t.geometry}))}(this.features)),this.sortFeaturesByKey&&this.features.sort((function(t,e){return t.sortKey-e.sortKey}));}},Tl.prototype.update=function(t,e,r){this.stateDependentLayers.length&&(this.text.programConfigurations.updatePaintArrays(t,e,this.layers,r),this.icon.programConfigurations.updatePaintArrays(t,e,this.layers,r));},Tl.prototype.isEmpty=function(){return 0===this.symbolInstances.length&&!this.hasRTLText},Tl.prototype.uploadPending=function(){return !this.uploaded||this.text.programConfigurations.needsUpload||this.icon.programConfigurations.needsUpload},Tl.prototype.upload=function(t){!this.uploaded&&this.hasDebugData()&&(this.textCollisionBox.upload(t),this.iconCollisionBox.upload(t),this.textCollisionCircle.upload(t),this.iconCollisionCircle.upload(t)),this.text.upload(t,this.sortFeaturesByY,!this.uploaded,this.text.programConfigurations.needsUpload),this.icon.upload(t,this.sortFeaturesByY,!this.uploaded,this.icon.programConfigurations.needsUpload),this.uploaded=!0;},Tl.prototype.destroyDebugData=function(){this.textCollisionBox.destroy(),this.iconCollisionBox.destroy(),this.textCollisionCircle.destroy(),this.iconCollisionCircle.destroy();},Tl.prototype.destroy=function(){this.text.destroy(),this.icon.destroy(),this.hasDebugData()&&this.destroyDebugData();},Tl.prototype.addToLineVertexArray=function(t,e){var r=this.lineVertexArray.length;if(void 0!==t.segment){for(var n=t.dist(e[t.segment+1]),i=t.dist(e[t.segment]),a={},o=t.segment+1;o<e.length;o++)a[o]={x:e[o].x,y:e[o].y,tileUnitDistanceFromAnchor:n},o<e.length-1&&(n+=e[o+1].dist(e[o]));for(var s=t.segment||0;s>=0;s--)a[s]={x:e[s].x,y:e[s].y,tileUnitDistanceFromAnchor:i},s>0&&(i+=e[s-1].dist(e[s]));for(var u=0;u<e.length;u++){var l=a[u];this.lineVertexArray.emplaceBack(l.x,l.y,l.tileUnitDistanceFromAnchor);}}return {lineStartIndex:r,lineLength:this.lineVertexArray.length-r}},Tl.prototype.addSymbols=function(t,e,r,n,i,a,o,s,u,l,p,c){for(var h=t.indexArray,f=t.layoutVertexArray,y=t.segments.prepareSegment(4*e.length,f,h,a.sortKey),d=this.glyphOffsetArray.length,m=y.vertexLength,v=this.allowVerticalPlacement&&o===Mu.vertical?Math.PI/2:0,g=a.text&&a.text.sections,x=0;x<e.length;x++){var b=e[x],w=b.tl,_=b.tr,A=b.bl,S=b.br,k=b.tex,I=b.pixelOffsetTL,z=b.pixelOffsetBR,C=b.minFontScaleX,M=b.minFontScaleY,T=b.glyphOffset,E=b.isSDF,P=b.sectionIndex,B=y.vertexLength,V=T[1];kl(f,s.x,s.y,w.x,V+w.y,k.x,k.y,r,E,I.x,I.y,C,M),kl(f,s.x,s.y,_.x,V+_.y,k.x+k.w,k.y,r,E,z.x,I.y,C,M),kl(f,s.x,s.y,A.x,V+A.y,k.x,k.y+k.h,r,E,I.x,z.y,C,M),kl(f,s.x,s.y,S.x,V+S.y,k.x+k.w,k.y+k.h,r,E,z.x,z.y,C,M),Il(t.dynamicLayoutVertexArray,s,v),h.emplaceBack(B,B+1,B+2),h.emplaceBack(B+1,B+2,B+3),y.vertexLength+=4,y.primitiveLength+=2,this.glyphOffsetArray.emplaceBack(T[0]),x!==e.length-1&&P===e[x+1].sectionIndex||t.programConfigurations.populatePaintArrays(f.length,a,a.index,{},c,g&&g[P]);}t.placedSymbolArray.emplaceBack(s.x,s.y,d,this.glyphOffsetArray.length-d,m,u,l,s.segment,r?r[0]:0,r?r[1]:0,n[0],n[1],o,0,!1,0,p);},Tl.prototype._addCollisionDebugVertex=function(t,e,r,n,i,a){return e.emplaceBack(0,0),t.emplaceBack(r.x,r.y,n,i,Math.round(a.x),Math.round(a.y))},Tl.prototype.addCollisionDebugVertices=function(t,e,r,n,a,o,s,u){var l=a.segments.prepareSegment(4,a.layoutVertexArray,a.indexArray),p=l.vertexLength,c=a.layoutVertexArray,h=a.collisionVertexArray,f=s.anchorX,y=s.anchorY;if(this._addCollisionDebugVertex(c,h,o,f,y,new i(t,e)),this._addCollisionDebugVertex(c,h,o,f,y,new i(r,e)),this._addCollisionDebugVertex(c,h,o,f,y,new i(r,n)),this._addCollisionDebugVertex(c,h,o,f,y,new i(t,n)),l.vertexLength+=4,u){var d=a.indexArray;d.emplaceBack(p,p+1,p+2),d.emplaceBack(p,p+2,p+3),l.primitiveLength+=2;}else{var m=a.indexArray;m.emplaceBack(p,p+1),m.emplaceBack(p+1,p+2),m.emplaceBack(p+2,p+3),m.emplaceBack(p+3,p),l.primitiveLength+=4;}},Tl.prototype.addDebugCollisionBoxes=function(t,e,r,n){for(var i=t;i<e;i++){var a=this.collisionBoxArray.get(i),o=a.radius>0;this.addCollisionDebugVertices(a.x1,a.y1,a.x2,a.y2,o?n?this.textCollisionCircle:this.iconCollisionCircle:n?this.textCollisionBox:this.iconCollisionBox,a.anchorPoint,r,o);}},Tl.prototype.generateCollisionDebugBuffers=function(){this.hasDebugData()&&this.destroyDebugData(),this.textCollisionBox=new Ml(Ji,Js.members,ra),this.iconCollisionBox=new Ml(Ji,Js.members,ra),this.textCollisionCircle=new Ml(Ji,Hs.members,ea),this.iconCollisionCircle=new Ml(Ji,Hs.members,ea);for(var t=0;t<this.symbolInstances.length;t++){var e=this.symbolInstances.get(t);this.addDebugCollisionBoxes(e.textBoxStartIndex,e.textBoxEndIndex,e,!0),this.addDebugCollisionBoxes(e.verticalTextBoxStartIndex,e.verticalTextBoxEndIndex,e,!0),this.addDebugCollisionBoxes(e.iconBoxStartIndex,e.iconBoxEndIndex,e,!1),this.addDebugCollisionBoxes(e.verticalIconBoxStartIndex,e.verticalIconBoxEndIndex,e,!1);}},Tl.prototype._deserializeCollisionBoxesForSymbol=function(t,e,r,n,i,a,o,s,u){for(var l={},p=e;p<r;p++){var c=t.get(p);if(0===c.radius){l.textBox={x1:c.x1,y1:c.y1,x2:c.x2,y2:c.y2,anchorPointX:c.anchorPointX,anchorPointY:c.anchorPointY},l.textFeatureIndex=c.featureIndex;break}l.textCircles||(l.textCircles=[],l.textFeatureIndex=c.featureIndex),l.textCircles.push(c.anchorPointX,c.anchorPointY,c.radius,c.signedDistanceFromAnchor,1);}for(var h=n;h<i;h++){var f=t.get(h);if(0===f.radius){l.verticalTextBox={x1:f.x1,y1:f.y1,x2:f.x2,y2:f.y2,anchorPointX:f.anchorPointX,anchorPointY:f.anchorPointY},l.verticalTextFeatureIndex=f.featureIndex;break}}for(var y=a;y<o;y++){var d=t.get(y);if(0===d.radius){l.iconBox={x1:d.x1,y1:d.y1,x2:d.x2,y2:d.y2,anchorPointX:d.anchorPointX,anchorPointY:d.anchorPointY},l.iconFeatureIndex=d.featureIndex;break}}for(var m=s;m<u;m++){var v=t.get(m);if(0===v.radius){l.verticalIconBox={x1:v.x1,y1:v.y1,x2:v.x2,y2:v.y2,anchorPointX:v.anchorPointX,anchorPointY:v.anchorPointY},l.verticalIconFeatureIndex=v.featureIndex;break}}return l},Tl.prototype.deserializeCollisionBoxes=function(t){this.collisionArrays=[];for(var e=0;e<this.symbolInstances.length;e++){var r=this.symbolInstances.get(e);this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t,r.textBoxStartIndex,r.textBoxEndIndex,r.verticalTextBoxStartIndex,r.verticalTextBoxEndIndex,r.iconBoxStartIndex,r.iconBoxEndIndex,r.verticalIconBoxStartIndex,r.verticalIconBoxEndIndex));}},Tl.prototype.hasTextData=function(){return this.text.segments.get().length>0},Tl.prototype.hasIconData=function(){return this.icon.segments.get().length>0},Tl.prototype.hasDebugData=function(){return this.textCollisionBox&&this.iconCollisionBox&&this.textCollisionCircle&&this.iconCollisionCircle},Tl.prototype.hasTextCollisionBoxData=function(){return this.hasDebugData()&&this.textCollisionBox.segments.get().length>0},Tl.prototype.hasIconCollisionBoxData=function(){return this.hasDebugData()&&this.iconCollisionBox.segments.get().length>0},Tl.prototype.hasTextCollisionCircleData=function(){return this.hasDebugData()&&this.textCollisionCircle.segments.get().length>0},Tl.prototype.hasIconCollisionCircleData=function(){return this.hasDebugData()&&this.iconCollisionCircle.segments.get().length>0},Tl.prototype.addIndicesForPlacedSymbol=function(t,e){for(var r=t.placedSymbolArray.get(e),n=r.vertexStartIndex+4*r.numGlyphs,i=r.vertexStartIndex;i<n;i+=4)t.indexArray.emplaceBack(i,i+1,i+2),t.indexArray.emplaceBack(i+1,i+2,i+3);},Tl.prototype.getSortedSymbolIndexes=function(t){if(this.sortedAngle===t&&void 0!==this.symbolInstanceIndexes)return this.symbolInstanceIndexes;for(var e=Math.sin(t),r=Math.cos(t),n=[],i=[],a=[],o=0;o<this.symbolInstances.length;++o){a.push(o);var s=this.symbolInstances.get(o);n.push(0|Math.round(e*s.anchorX+r*s.anchorY)),i.push(s.featureIndex);}return a.sort((function(t,e){return n[t]-n[e]||i[e]-i[t]})),a},Tl.prototype.addToSortKeyRanges=function(t,e){var r=this.sortKeyRanges[this.sortKeyRanges.length-1];r&&r.sortKey===e?r.symbolInstanceEnd=t+1:this.sortKeyRanges.push({sortKey:e,symbolInstanceStart:t,symbolInstanceEnd:t+1});},Tl.prototype.sortFeatures=function(t){var e=this;if(this.sortFeaturesByY&&this.sortedAngle!==t&&!(this.text.segments.get().length>1||this.icon.segments.get().length>1)){this.symbolInstanceIndexes=this.getSortedSymbolIndexes(t),this.sortedAngle=t,this.text.indexArray.clear(),this.icon.indexArray.clear(),this.featureSortOrder=[];for(var r=0,n=this.symbolInstanceIndexes;r<n.length;r+=1){var i=this.symbolInstances.get(n[r]);this.featureSortOrder.push(i.featureIndex),[i.rightJustifiedTextSymbolIndex,i.centerJustifiedTextSymbolIndex,i.leftJustifiedTextSymbolIndex].forEach((function(t,r,n){t>=0&&n.indexOf(t)===r&&e.addIndicesForPlacedSymbol(e.text,t);})),i.verticalPlacedTextSymbolIndex>=0&&this.addIndicesForPlacedSymbol(this.text,i.verticalPlacedTextSymbolIndex),i.placedIconSymbolIndex>=0&&this.addIndicesForPlacedSymbol(this.icon,i.placedIconSymbolIndex),i.verticalPlacedIconSymbolIndex>=0&&this.addIndicesForPlacedSymbol(this.icon,i.verticalPlacedIconSymbolIndex);}this.text.indexBuffer&&this.text.indexBuffer.updateData(this.text.indexArray),this.icon.indexBuffer&&this.icon.indexBuffer.updateData(this.icon.indexArray);}},Hn("SymbolBucket",Tl,{omit:["layers","collisionBoxArray","features","compareText"]}),Tl.MAX_GLYPHS=65535,Tl.addDynamicAttributes=Il;var El=new Pi({"symbol-placement":new zi(Ct.layout_symbol["symbol-placement"]),"symbol-spacing":new zi(Ct.layout_symbol["symbol-spacing"]),"symbol-avoid-edges":new zi(Ct.layout_symbol["symbol-avoid-edges"]),"symbol-sort-key":new Ci(Ct.layout_symbol["symbol-sort-key"]),"symbol-z-order":new zi(Ct.layout_symbol["symbol-z-order"]),"icon-allow-overlap":new zi(Ct.layout_symbol["icon-allow-overlap"]),"icon-ignore-placement":new zi(Ct.layout_symbol["icon-ignore-placement"]),"icon-optional":new zi(Ct.layout_symbol["icon-optional"]),"icon-rotation-alignment":new zi(Ct.layout_symbol["icon-rotation-alignment"]),"icon-size":new Ci(Ct.layout_symbol["icon-size"]),"icon-text-fit":new zi(Ct.layout_symbol["icon-text-fit"]),"icon-text-fit-padding":new zi(Ct.layout_symbol["icon-text-fit-padding"]),"icon-image":new Ci(Ct.layout_symbol["icon-image"]),"icon-rotate":new Ci(Ct.layout_symbol["icon-rotate"]),"icon-padding":new zi(Ct.layout_symbol["icon-padding"]),"icon-keep-upright":new zi(Ct.layout_symbol["icon-keep-upright"]),"icon-offset":new Ci(Ct.layout_symbol["icon-offset"]),"icon-anchor":new Ci(Ct.layout_symbol["icon-anchor"]),"icon-pitch-alignment":new zi(Ct.layout_symbol["icon-pitch-alignment"]),"text-pitch-alignment":new zi(Ct.layout_symbol["text-pitch-alignment"]),"text-rotation-alignment":new zi(Ct.layout_symbol["text-rotation-alignment"]),"text-field":new Ci(Ct.layout_symbol["text-field"]),"text-font":new Ci(Ct.layout_symbol["text-font"]),"text-size":new Ci(Ct.layout_symbol["text-size"]),"text-max-width":new Ci(Ct.layout_symbol["text-max-width"]),"text-line-height":new zi(Ct.layout_symbol["text-line-height"]),"text-letter-spacing":new Ci(Ct.layout_symbol["text-letter-spacing"]),"text-justify":new Ci(Ct.layout_symbol["text-justify"]),"text-radial-offset":new Ci(Ct.layout_symbol["text-radial-offset"]),"text-variable-anchor":new zi(Ct.layout_symbol["text-variable-anchor"]),"text-anchor":new Ci(Ct.layout_symbol["text-anchor"]),"text-max-angle":new zi(Ct.layout_symbol["text-max-angle"]),"text-writing-mode":new zi(Ct.layout_symbol["text-writing-mode"]),"text-rotate":new Ci(Ct.layout_symbol["text-rotate"]),"text-padding":new zi(Ct.layout_symbol["text-padding"]),"text-keep-upright":new zi(Ct.layout_symbol["text-keep-upright"]),"text-transform":new Ci(Ct.layout_symbol["text-transform"]),"text-offset":new Ci(Ct.layout_symbol["text-offset"]),"text-allow-overlap":new zi(Ct.layout_symbol["text-allow-overlap"]),"text-ignore-placement":new zi(Ct.layout_symbol["text-ignore-placement"]),"text-optional":new zi(Ct.layout_symbol["text-optional"])}),Pl={paint:new Pi({"icon-opacity":new Ci(Ct.paint_symbol["icon-opacity"]),"icon-color":new Ci(Ct.paint_symbol["icon-color"]),"icon-halo-color":new Ci(Ct.paint_symbol["icon-halo-color"]),"icon-halo-width":new Ci(Ct.paint_symbol["icon-halo-width"]),"icon-halo-blur":new Ci(Ct.paint_symbol["icon-halo-blur"]),"icon-translate":new zi(Ct.paint_symbol["icon-translate"]),"icon-translate-anchor":new zi(Ct.paint_symbol["icon-translate-anchor"]),"text-opacity":new Ci(Ct.paint_symbol["text-opacity"]),"text-color":new Ci(Ct.paint_symbol["text-color"],{runtimeType:Ut,getOverride:function(t){return t.textColor},hasOverride:function(t){return !!t.textColor}}),"text-halo-color":new Ci(Ct.paint_symbol["text-halo-color"]),"text-halo-width":new Ci(Ct.paint_symbol["text-halo-width"]),"text-halo-blur":new Ci(Ct.paint_symbol["text-halo-blur"]),"text-translate":new zi(Ct.paint_symbol["text-translate"]),"text-translate-anchor":new zi(Ct.paint_symbol["text-translate-anchor"])}),layout:El},Bl=function(t){this.type=t.property.overrides?t.property.overrides.runtimeType:Dt,this.defaultValue=t;};Bl.prototype.evaluate=function(t){if(t.formattedSection){var e=this.defaultValue.property.overrides;if(e&&e.hasOverride(t.formattedSection))return e.getOverride(t.formattedSection)}return t.feature&&t.featureState?this.defaultValue.evaluate(t.feature,t.featureState):this.defaultValue.property.specification.default},Bl.prototype.eachChild=function(t){this.defaultValue.isConstant()||t(this.defaultValue.value._styleExpression.expression);},Bl.prototype.outputDefined=function(){return !1},Bl.prototype.serialize=function(){return null},Hn("FormatSectionOverride",Bl,{omit:["defaultValue"]});var Vl=function(t){function e(e){t.call(this,e,Pl);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.recalculate=function(e,r){if(t.prototype.recalculate.call(this,e,r),"auto"===this.layout.get("icon-rotation-alignment")&&(this.layout._values["icon-rotation-alignment"]="point"!==this.layout.get("symbol-placement")?"map":"viewport"),"auto"===this.layout.get("text-rotation-alignment")&&(this.layout._values["text-rotation-alignment"]="point"!==this.layout.get("symbol-placement")?"map":"viewport"),"auto"===this.layout.get("text-pitch-alignment")&&(this.layout._values["text-pitch-alignment"]=this.layout.get("text-rotation-alignment")),"auto"===this.layout.get("icon-pitch-alignment")&&(this.layout._values["icon-pitch-alignment"]=this.layout.get("icon-rotation-alignment")),"point"===this.layout.get("symbol-placement")){var n=this.layout.get("text-writing-mode");if(n){for(var i=[],a=0,o=n;a<o.length;a+=1){var s=o[a];i.indexOf(s)<0&&i.push(s);}this.layout._values["text-writing-mode"]=i;}else this.layout._values["text-writing-mode"]=["horizontal"];}this._setPaintOverrides();},e.prototype.getValueAndResolveTokens=function(t,e,r,n){var i=this.layout.get(t).evaluate(e,{},r,n),a=this._unevaluatedLayout._values[t];return a.isDataDriven()||en(a.value)||!i?i:function(t,e){return e.replace(/{([^{}]+)}/g,(function(e,r){return r in t?String(t[r]):""}))}(e.properties,i)},e.prototype.createBucket=function(t){return new Tl(t)},e.prototype.queryRadius=function(){return 0},e.prototype.queryIntersectsFeature=function(){return !1},e.prototype._setPaintOverrides=function(){for(var t=0,r=Pl.paint.overridableProperties;t<r.length;t+=1){var n=r[t];if(e.hasPaintOverride(this.layout,n)){var i,a=this.paint.get(n),o=new Bl(a),s=new tn(o,a.property.specification);i="constant"===a.value.kind||"source"===a.value.kind?new nn("source",s):new an("composite",s,a.value.zoomStops,a.value._interpolationType),this.paint._values[n]=new ki(a.property,i,a.parameters);}}},e.prototype._handleOverridablePaintPropertyUpdate=function(t,r,n){return !(!this.layout||r.isDataDriven()||n.isDataDriven())&&e.hasPaintOverride(this.layout,t)},e.hasPaintOverride=function(t,e){var r=t.get("text-field"),n=Pl.paint.properties[e],i=!1,a=function(t){for(var e=0,r=t;e<r.length;e+=1)if(n.overrides&&n.overrides.hasOverride(r[e]))return void(i=!0)};if("constant"===r.value.kind&&r.value.value instanceof te)a(r.value.value.sections);else if("source"===r.value.kind){var o=function(t){i||(t instanceof oe&&ie(t.value)===Kt?a(t.value.sections):t instanceof pe?a(t.sections):t.eachChild(o));},s=r.value;s._styleExpression&&o(s._styleExpression.expression);}return i},e}(Bi),Fl={paint:new Pi({"background-color":new zi(Ct.paint_background["background-color"]),"background-pattern":new Ti(Ct.paint_background["background-pattern"]),"background-opacity":new zi(Ct.paint_background["background-opacity"])})},Dl=function(t){function e(e){t.call(this,e,Fl);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e}(Bi),Ll={paint:new Pi({"raster-opacity":new zi(Ct.paint_raster["raster-opacity"]),"raster-hue-rotate":new zi(Ct.paint_raster["raster-hue-rotate"]),"raster-brightness-min":new zi(Ct.paint_raster["raster-brightness-min"]),"raster-brightness-max":new zi(Ct.paint_raster["raster-brightness-max"]),"raster-saturation":new zi(Ct.paint_raster["raster-saturation"]),"raster-contrast":new zi(Ct.paint_raster["raster-contrast"]),"raster-resampling":new zi(Ct.paint_raster["raster-resampling"]),"raster-fade-duration":new zi(Ct.paint_raster["raster-fade-duration"])})},Rl=function(t){function e(e){t.call(this,e,Ll);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e}(Bi),Ol=function(t){function e(e){t.call(this,e,{}),this.implementation=e;}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.is3D=function(){return "3d"===this.implementation.renderingMode},e.prototype.hasOffscreenPass=function(){return void 0!==this.implementation.prerender},e.prototype.recalculate=function(){},e.prototype.updateTransitions=function(){},e.prototype.hasTransition=function(){},e.prototype.serialize=function(){},e.prototype.onAdd=function(t){this.implementation.onAdd&&this.implementation.onAdd(t,t.painter.context.gl);},e.prototype.onRemove=function(t){this.implementation.onRemove&&this.implementation.onRemove(t,t.painter.context.gl);},e}(Bi),Ul={circle:vo,heatmap:zo,hillshade:Mo,fill:ds,"fill-extrusion":Ps,line:Ns,symbol:Vl,background:Dl,raster:Rl},jl=self.HTMLImageElement,ql=self.HTMLCanvasElement,Nl=self.HTMLVideoElement,Kl=self.ImageData,Xl=self.ImageBitmap,Gl=function(t,e,r,n){this.context=t,this.format=r,this.texture=t.gl.createTexture(),this.update(e,n);};Gl.prototype.update=function(t,e,r){var n=t.width,i=t.height,a=!(this.size&&this.size[0]===n&&this.size[1]===i||r),o=this.context,s=o.gl;if(this.useMipmap=Boolean(e&&e.useMipmap),s.bindTexture(s.TEXTURE_2D,this.texture),o.pixelStoreUnpackFlipY.set(!1),o.pixelStoreUnpack.set(1),o.pixelStoreUnpackPremultiplyAlpha.set(this.format===s.RGBA&&(!e||!1!==e.premultiply)),a)this.size=[n,i],t instanceof jl||t instanceof ql||t instanceof Nl||t instanceof Kl||Xl&&t instanceof Xl?s.texImage2D(s.TEXTURE_2D,0,this.format,this.format,s.UNSIGNED_BYTE,t):s.texImage2D(s.TEXTURE_2D,0,this.format,n,i,0,this.format,s.UNSIGNED_BYTE,t.data);else{var u=r||{x:0,y:0},l=u.x,p=u.y;t instanceof jl||t instanceof ql||t instanceof Nl||t instanceof Kl||Xl&&t instanceof Xl?s.texSubImage2D(s.TEXTURE_2D,0,l,p,s.RGBA,s.UNSIGNED_BYTE,t):s.texSubImage2D(s.TEXTURE_2D,0,l,p,n,i,s.RGBA,s.UNSIGNED_BYTE,t.data);}this.useMipmap&&this.isSizePowerOfTwo()&&s.generateMipmap(s.TEXTURE_2D);},Gl.prototype.bind=function(t,e,r){var n=this.context.gl;n.bindTexture(n.TEXTURE_2D,this.texture),r!==n.LINEAR_MIPMAP_NEAREST||this.isSizePowerOfTwo()||(r=n.LINEAR),t!==this.filter&&(n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,t),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,r||t),this.filter=t),e!==this.wrap&&(n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,e),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,e),this.wrap=e);},Gl.prototype.isSizePowerOfTwo=function(){return this.size[0]===this.size[1]&&Math.log(this.size[0])/Math.LN2%1==0},Gl.prototype.destroy=function(){this.context.gl.deleteTexture(this.texture),this.texture=null;};var Zl=function(t){var e=this;this._callback=t,this._triggered=!1,"undefined"!=typeof MessageChannel&&(this._channel=new MessageChannel,this._channel.port2.onmessage=function(){e._triggered=!1,e._callback();});};Zl.prototype.trigger=function(){var t=this;this._triggered||(this._triggered=!0,this._channel?this._channel.port1.postMessage(!0):setTimeout((function(){t._triggered=!1,t._callback();}),0));},Zl.prototype.remove=function(){delete this._channel,this._callback=function(){};};var Jl=function(t,e,r){this.target=t,this.parent=e,this.mapId=r,this.callbacks={},this.tasks={},this.taskQueue=[],this.cancelCallbacks={},d(["receive","process"],this),this.invoker=new Zl(this.process),this.target.addEventListener("message",this.receive,!1),this.globalScope=S()?t:self;};function Hl(t,e,r){var n=2*Math.PI*6378137/256/Math.pow(2,r);return [t*n-2*Math.PI*6378137/2,e*n-2*Math.PI*6378137/2]}Jl.prototype.send=function(t,e,r,n,i){var a=this;void 0===i&&(i=!1);var o=Math.round(1e18*Math.random()).toString(36).substring(0,10);r&&(this.callbacks[o]=r);var s=z(this.globalScope)?void 0:[];return this.target.postMessage({id:o,type:t,hasCallback:!!r,targetMapId:n,mustQueue:i,sourceMapId:this.mapId,data:Qn(e,s)},s),{cancel:function(){r&&delete a.callbacks[o],a.target.postMessage({id:o,type:"<cancel>",targetMapId:n,sourceMapId:a.mapId});}}},Jl.prototype.receive=function(t){var e=t.data,r=e.id;if(r&&(!e.targetMapId||this.mapId===e.targetMapId))if("<cancel>"===e.type){delete this.tasks[r];var n=this.cancelCallbacks[r];delete this.cancelCallbacks[r],n&&n();}else S()||e.mustQueue?(this.tasks[r]=e,this.taskQueue.push(r),this.invoker.trigger()):this.processTask(r,e);},Jl.prototype.process=function(){if(this.taskQueue.length){var t=this.taskQueue.shift(),e=this.tasks[t];delete this.tasks[t],this.taskQueue.length&&this.invoker.trigger(),e&&this.processTask(t,e);}},Jl.prototype.processTask=function(t,e){var r=this;if("<response>"===e.type){var n=this.callbacks[t];delete this.callbacks[t],n&&(e.error?n(ti(e.error)):n(null,ti(e.data)));}else{var i=!1,a=z(this.globalScope)?void 0:[],o=e.hasCallback?function(e,n){i=!0,delete r.cancelCallbacks[t],r.target.postMessage({id:t,type:"<response>",sourceMapId:r.mapId,error:e?Qn(e):null,data:Qn(n,a)},a);}:function(t){i=!0;},s=null,u=ti(e.data);if(this.parent[e.type])s=this.parent[e.type](e.sourceMapId,u,o);else if(this.parent.getWorkerSource){var l=e.type.split(".");s=this.parent.getWorkerSource(e.sourceMapId,l[0],u.source)[l[1]](u,o);}else o(new Error("Could not find function "+e.type));!i&&s&&s.cancel&&(this.cancelCallbacks[t]=s.cancel);}},Jl.prototype.remove=function(){this.invoker.remove(),this.target.removeEventListener("message",this.receive,!1);};var Yl=function(t,e,r){this.z=t,this.x=e,this.y=r,this.key=Ql(0,t,t,e,r);};Yl.prototype.equals=function(t){return this.z===t.z&&this.x===t.x&&this.y===t.y},Yl.prototype.url=function(t,e){var r,n,i,a,o,s=(n=this.y,i=this.z,a=Hl(256*(r=this.x),256*(n=Math.pow(2,i)-n-1),i),o=Hl(256*(r+1),256*(n+1),i),a[0]+","+a[1]+","+o[0]+","+o[1]),u=function(t,e,r){for(var n,i="",a=t;a>0;a--)i+=(e&(n=1<<a-1)?1:0)+(r&n?2:0);return i}(this.z,this.x,this.y);return t[(this.x+this.y)%t.length].replace("{prefix}",(this.x%16).toString(16)+(this.y%16).toString(16)).replace("{z}",String(this.z)).replace("{x}",String(this.x)).replace("{y}",String("tms"===e?Math.pow(2,this.z)-this.y-1:this.y)).replace("{quadkey}",u).replace("{bbox-epsg-3857}",s)},Yl.prototype.getTilePoint=function(t){var e=Math.pow(2,this.z);return new i((t.x*e-this.x)*ze,(t.y*e-this.y)*ze)},Yl.prototype.toString=function(){return this.z+"/"+this.x+"/"+this.y};var $l=function(t,e){this.wrap=t,this.canonical=e,this.key=Ql(t,e.z,e.z,e.x,e.y);},Wl=function(t,e,r,n,i){this.overscaledZ=t,this.wrap=e,this.canonical=new Yl(r,+n,+i),this.key=Ql(e,t,r,n,i);};function Ql(t,e,r,n,i){(t*=2)<0&&(t=-1*t-1);var a=1<<r;return (a*a*t+a*i+n).toString(36)+r.toString(36)+e.toString(36)}Wl.prototype.equals=function(t){return this.overscaledZ===t.overscaledZ&&this.wrap===t.wrap&&this.canonical.equals(t.canonical)},Wl.prototype.scaledTo=function(t){var e=this.canonical.z-t;return t>this.canonical.z?new Wl(t,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y):new Wl(t,this.wrap,t,this.canonical.x>>e,this.canonical.y>>e)},Wl.prototype.calculateScaledKey=function(t,e){var r=this.canonical.z-t;return t>this.canonical.z?Ql(this.wrap*+e,t,this.canonical.z,this.canonical.x,this.canonical.y):Ql(this.wrap*+e,t,t,this.canonical.x>>r,this.canonical.y>>r)},Wl.prototype.isChildOf=function(t){if(t.wrap!==this.wrap)return !1;var e=this.canonical.z-t.canonical.z;return 0===t.overscaledZ||t.overscaledZ<this.overscaledZ&&t.canonical.x===this.canonical.x>>e&&t.canonical.y===this.canonical.y>>e},Wl.prototype.children=function(t){if(this.overscaledZ>=t)return [new Wl(this.overscaledZ+1,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)];var e=this.canonical.z+1,r=2*this.canonical.x,n=2*this.canonical.y;return [new Wl(e,this.wrap,e,r,n),new Wl(e,this.wrap,e,r+1,n),new Wl(e,this.wrap,e,r,n+1),new Wl(e,this.wrap,e,r+1,n+1)]},Wl.prototype.isLessThan=function(t){return this.wrap<t.wrap||!(this.wrap>t.wrap)&&(this.overscaledZ<t.overscaledZ||!(this.overscaledZ>t.overscaledZ)&&(this.canonical.x<t.canonical.x||!(this.canonical.x>t.canonical.x)&&this.canonical.y<t.canonical.y))},Wl.prototype.wrapped=function(){return new Wl(this.overscaledZ,0,this.canonical.z,this.canonical.x,this.canonical.y)},Wl.prototype.unwrapTo=function(t){return new Wl(this.overscaledZ,t,this.canonical.z,this.canonical.x,this.canonical.y)},Wl.prototype.overscaleFactor=function(){return Math.pow(2,this.overscaledZ-this.canonical.z)},Wl.prototype.toUnwrapped=function(){return new $l(this.wrap,this.canonical)},Wl.prototype.toString=function(){return this.overscaledZ+"/"+this.canonical.x+"/"+this.canonical.y},Wl.prototype.getTilePoint=function(t){return this.canonical.getTilePoint(new Ie(t.x-this.wrap,t.y))},Hn("CanonicalTileID",Yl),Hn("OverscaledTileID",Wl,{omit:["posMatrix"]});var tp=function(t,e,r){if(this.uid=t,e.height!==e.width)throw new RangeError("DEM tiles must be square");if(r&&"mapbox"!==r&&"terrarium"!==r)return w('"'+r+'" is not a valid encoding type. Valid types include "mapbox" and "terrarium".');this.stride=e.height;var n=this.dim=e.height-2;this.data=new Uint32Array(e.data.buffer),this.encoding=r||"mapbox";for(var i=0;i<n;i++)this.data[this._idx(-1,i)]=this.data[this._idx(0,i)],this.data[this._idx(n,i)]=this.data[this._idx(n-1,i)],this.data[this._idx(i,-1)]=this.data[this._idx(i,0)],this.data[this._idx(i,n)]=this.data[this._idx(i,n-1)];this.data[this._idx(-1,-1)]=this.data[this._idx(0,0)],this.data[this._idx(n,-1)]=this.data[this._idx(n-1,0)],this.data[this._idx(-1,n)]=this.data[this._idx(0,n-1)],this.data[this._idx(n,n)]=this.data[this._idx(n-1,n-1)];};tp.prototype.get=function(t,e){var r=new Uint8Array(this.data.buffer),n=4*this._idx(t,e);return ("terrarium"===this.encoding?this._unpackTerrarium:this._unpackMapbox)(r[n],r[n+1],r[n+2])},tp.prototype.getUnpackVector=function(){return "terrarium"===this.encoding?[256,1,1/256,32768]:[6553.6,25.6,.1,1e4]},tp.prototype._idx=function(t,e){if(t<-1||t>=this.dim+1||e<-1||e>=this.dim+1)throw new RangeError("out of range source coordinates for DEM data");return (e+1)*this.stride+(t+1)},tp.prototype._unpackMapbox=function(t,e,r){return (256*t*256+256*e+r)/10-1e4},tp.prototype._unpackTerrarium=function(t,e,r){return 256*t+e+r/256-32768},tp.prototype.getPixels=function(){return new So({width:this.stride,height:this.stride},new Uint8Array(this.data.buffer))},tp.prototype.backfillBorder=function(t,e,r){if(this.dim!==t.dim)throw new Error("dem dimension mismatch");var n=e*this.dim,i=e*this.dim+this.dim,a=r*this.dim,o=r*this.dim+this.dim;switch(e){case-1:n=i-1;break;case 1:i=n+1;}switch(r){case-1:a=o-1;break;case 1:o=a+1;}for(var s=-e*this.dim,u=-r*this.dim,l=a;l<o;l++)for(var p=n;p<i;p++)this.data[this._idx(p,l)]=t.data[this._idx(p+s,l+u)];},Hn("DEMData",tp);var ep=function(t){this._stringToNumber={},this._numberToString=[];for(var e=0;e<t.length;e++){var r=t[e];this._stringToNumber[r]=e,this._numberToString[e]=r;}};ep.prototype.encode=function(t){return this._stringToNumber[t]},ep.prototype.decode=function(t){return this._numberToString[t]};var rp=function(t,e,r,n,i){this.type="Feature",this._vectorTileFeature=t,t._z=e,t._x=r,t._y=n,this.properties=t.properties,this.id=i;},np={geometry:{configurable:!0}};np.geometry.get=function(){return void 0===this._geometry&&(this._geometry=this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x,this._vectorTileFeature._y,this._vectorTileFeature._z).geometry),this._geometry},np.geometry.set=function(t){this._geometry=t;},rp.prototype.toJSON=function(){var t={geometry:this.geometry};for(var e in this)"_geometry"!==e&&"_vectorTileFeature"!==e&&(t[e]=this[e]);return t},Object.defineProperties(rp.prototype,np);var ip=function(){this.state={},this.stateChanges={},this.deletedStates={};};ip.prototype.updateState=function(t,e,r){var n=String(e);if(this.stateChanges[t]=this.stateChanges[t]||{},this.stateChanges[t][n]=this.stateChanges[t][n]||{},p(this.stateChanges[t][n],r),null===this.deletedStates[t])for(var i in this.deletedStates[t]={},this.state[t])i!==n&&(this.deletedStates[t][i]=null);else if(this.deletedStates[t]&&null===this.deletedStates[t][n])for(var a in this.deletedStates[t][n]={},this.state[t][n])r[a]||(this.deletedStates[t][n][a]=null);else for(var o in r)this.deletedStates[t]&&this.deletedStates[t][n]&&null===this.deletedStates[t][n][o]&&delete this.deletedStates[t][n][o];},ip.prototype.removeFeatureState=function(t,e,r){if(null!==this.deletedStates[t]){var n=String(e);if(this.deletedStates[t]=this.deletedStates[t]||{},r&&void 0!==e)null!==this.deletedStates[t][n]&&(this.deletedStates[t][n]=this.deletedStates[t][n]||{},this.deletedStates[t][n][r]=null);else if(void 0!==e)if(this.stateChanges[t]&&this.stateChanges[t][n])for(r in this.deletedStates[t][n]={},this.stateChanges[t][n])this.deletedStates[t][n][r]=null;else this.deletedStates[t][n]=null;else this.deletedStates[t]=null;}},ip.prototype.getState=function(t,e){var r=String(e),n=p({},(this.state[t]||{})[r],(this.stateChanges[t]||{})[r]);if(null===this.deletedStates[t])return {};if(this.deletedStates[t]){var i=this.deletedStates[t][e];if(null===i)return {};for(var a in i)delete n[a];}return n},ip.prototype.initializeTileState=function(t,e){t.setFeatureState(this.state,e);},ip.prototype.coalesceChanges=function(t,e){var r={};for(var n in this.stateChanges){this.state[n]=this.state[n]||{};var i={};for(var a in this.stateChanges[n])this.state[n][a]||(this.state[n][a]={}),p(this.state[n][a],this.stateChanges[n][a]),i[a]=this.state[n][a];r[n]=i;}for(var o in this.deletedStates){this.state[o]=this.state[o]||{};var s={};if(null===this.deletedStates[o])for(var u in this.state[o])s[u]={},this.state[o][u]={};else for(var l in this.deletedStates[o]){if(null===this.deletedStates[o][l])this.state[o][l]={};else for(var c=0,h=Object.keys(this.deletedStates[o][l]);c<h.length;c+=1)delete this.state[o][l][h[c]];s[l]=this.state[o][l];}r[o]=r[o]||{},p(r[o],s);}if(this.stateChanges={},this.deletedStates={},0!==Object.keys(r).length)for(var f in t)t[f].setFeatureState(r,e);};var ap=function(t,e){this.tileID=t,this.x=t.canonical.x,this.y=t.canonical.y,this.z=t.canonical.z,this.grid=new Nn(ze,16,0),this.grid3D=new Nn(ze,16,0),this.featureIndexArray=new da,this.promoteId=e;};function op(t,e,r,n,i){return v(t,(function(t,a){var o=e instanceof Ii?e.get(a):null;return o&&o.evaluate?o.evaluate(r,n,i):o}))}function sp(t){for(var e=1/0,r=1/0,n=-1/0,i=-1/0,a=0,o=t;a<o.length;a+=1){var s=o[a];e=Math.min(e,s.x),r=Math.min(r,s.y),n=Math.max(n,s.x),i=Math.max(i,s.y);}return {minX:e,minY:r,maxX:n,maxY:i}}function up(t,e){return e-t}ap.prototype.insert=function(t,e,r,n,i,a){var o=this.featureIndexArray.length;this.featureIndexArray.emplaceBack(r,n,i);for(var s=a?this.grid3D:this.grid,u=0;u<e.length;u++){for(var l=e[u],p=[1/0,1/0,-1/0,-1/0],c=0;c<l.length;c++){var h=l[c];p[0]=Math.min(p[0],h.x),p[1]=Math.min(p[1],h.y),p[2]=Math.max(p[2],h.x),p[3]=Math.max(p[3],h.y);}p[0]<ze&&p[1]<ze&&p[2]>=0&&p[3]>=0&&s.insert(o,p[0],p[1],p[2],p[3]);}},ap.prototype.loadVTLayers=function(){return this.vtLayers||(this.vtLayers=new ks.VectorTile(new eu(this.rawTileData)).layers,this.sourceLayerCoder=new ep(this.vtLayers?Object.keys(this.vtLayers).sort():["_geojsonTileLayer"])),this.vtLayers},ap.prototype.query=function(t,e,r,n){var a=this;this.loadVTLayers();for(var o=t.params||{},s=ze/t.tileSize/t.scale,u=mn(o.filter),l=t.queryGeometry,p=t.queryPadding*s,c=sp(l),h=this.grid.query(c.minX-p,c.minY-p,c.maxX+p,c.maxY+p),f=sp(t.cameraQueryGeometry),y=this.grid3D.query(f.minX-p,f.minY-p,f.maxX+p,f.maxY+p,(function(e,r,n,a){return function(t,e,r,n,a){for(var o=0,s=t;o<s.length;o+=1){var u=s[o];if(e<=u.x&&r<=u.y&&n>=u.x&&a>=u.y)return !0}var l=[new i(e,r),new i(e,a),new i(n,a),new i(n,r)];if(t.length>2)for(var p=0,c=l;p<c.length;p+=1)if(oo(t,c[p]))return !0;for(var h=0;h<t.length-1;h++)if(so(t[h],t[h+1],l))return !0;return !1}(t.cameraQueryGeometry,e-p,r-p,n+p,a+p)})),d=0,m=y;d<m.length;d+=1)h.push(m[d]);h.sort(up);for(var v,g={},x=function(i){var p=h[i];if(p!==v){v=p;var c=a.featureIndexArray.get(p),f=null;a.loadMatchingFeature(g,c.bucketIndex,c.sourceLayerIndex,c.featureIndex,u,o.layers,o.availableImages,e,r,n,(function(e,r,n){return f||(f=Ja(e)),r.queryIntersectsFeature(l,e,n,f,a.z,t.transform,s,t.pixelPosMatrix)}));}},b=0;b<h.length;b++)x(b);return g},ap.prototype.loadMatchingFeature=function(t,e,r,n,i,a,o,s,u,l,p){var c=this.bucketLayerIDs[e];if(!a||function(t,e){for(var r=0;r<t.length;r++)if(e.indexOf(t[r])>=0)return !0;return !1}(a,c)){var h=this.sourceLayerCoder.decode(r),f=this.vtLayers[h].feature(n);if(i.filter(new gi(this.tileID.overscaledZ),f))for(var y=this.getId(f,h),d=0;d<c.length;d++){var m=c[d];if(!(a&&a.indexOf(m)<0)){var v=s[m];if(v){var g={};void 0!==y&&l&&(g=l.getState(v.sourceLayer||"_geojsonTileLayer",y));var x=u[m];x.paint=op(x.paint,v.paint,f,g,o),x.layout=op(x.layout,v.layout,f,g,o);var b=!p||p(f,v,g);if(b){var w=new rp(f,this.z,this.x,this.y,y);w.layer=x;var _=t[m];void 0===_&&(_=t[m]=[]),_.push({featureIndex:n,feature:w,intersectionZ:b});}}}}}},ap.prototype.lookupSymbolFeatures=function(t,e,r,n,i,a,o,s){var u={};this.loadVTLayers();for(var l=mn(i),p=0,c=t;p<c.length;p+=1)this.loadMatchingFeature(u,r,n,c[p],l,a,o,s,e);return u},ap.prototype.hasLayer=function(t){for(var e=0,r=this.bucketLayerIDs;e<r.length;e+=1)for(var n=0,i=r[e];n<i.length;n+=1)if(t===i[n])return !0;return !1},ap.prototype.getId=function(t,e){var r=t.id;return this.promoteId&&"boolean"==typeof(r=t.properties["string"==typeof this.promoteId?this.promoteId:this.promoteId[e]])&&(r=Number(r)),r},Hn("FeatureIndex",ap,{omit:["rawTileData","sourceLayerCoder"]});var lp=function(t,e){this.tileID=t,this.uid=h(),this.uses=0,this.tileSize=e,this.buckets={},this.expirationTime=null,this.queryPadding=0,this.hasSymbolBuckets=!1,this.hasRTLText=!1,this.dependencies={},this.expiredRequestCount=0,this.state="loading";};lp.prototype.registerFadeDuration=function(t){var e=t+this.timeAdded;e<D.now()||this.fadeEndTime&&e<this.fadeEndTime||(this.fadeEndTime=e);},lp.prototype.wasRequested=function(){return "errored"===this.state||"loaded"===this.state||"reloading"===this.state},lp.prototype.loadVectorData=function(t,e,r){if(this.hasData()&&this.unloadVectorData(),this.state="loaded",t){for(var n in t.featureIndex&&(this.latestFeatureIndex=t.featureIndex,t.rawTileData?(this.latestRawTileData=t.rawTileData,this.latestFeatureIndex.rawTileData=t.rawTileData):this.latestRawTileData&&(this.latestFeatureIndex.rawTileData=this.latestRawTileData)),this.collisionBoxArray=t.collisionBoxArray,this.buckets=function(t,e){var r={};if(!e)return r;for(var n=function(){var t=a[i],n=t.layerIds.map((function(t){return e.getLayer(t)})).filter(Boolean);if(0!==n.length){t.layers=n,t.stateDependentLayerIds&&(t.stateDependentLayers=t.stateDependentLayerIds.map((function(t){return n.filter((function(e){return e.id===t}))[0]})));for(var o=0,s=n;o<s.length;o+=1)r[s[o].id]=t;}},i=0,a=t;i<a.length;i+=1)n();return r}(t.buckets,e.style),this.hasSymbolBuckets=!1,this.buckets){var i=this.buckets[n];if(i instanceof Tl){if(this.hasSymbolBuckets=!0,!r)break;i.justReloaded=!0;}}if(this.hasRTLText=!1,this.hasSymbolBuckets)for(var a in this.buckets){var o=this.buckets[a];if(o instanceof Tl&&o.hasRTLText){this.hasRTLText=!0,vi.isLoading()||vi.isLoaded()||"deferred"!==di()||mi();break}}for(var s in this.queryPadding=0,this.buckets){var u=this.buckets[s];this.queryPadding=Math.max(this.queryPadding,e.style.getLayer(s).queryRadius(u));}t.imageAtlas&&(this.imageAtlas=t.imageAtlas),t.glyphAtlasImage&&(this.glyphAtlasImage=t.glyphAtlasImage);}else this.collisionBoxArray=new sa;},lp.prototype.unloadVectorData=function(){for(var t in this.buckets)this.buckets[t].destroy();this.buckets={},this.imageAtlasTexture&&this.imageAtlasTexture.destroy(),this.imageAtlas&&(this.imageAtlas=null),this.glyphAtlasTexture&&this.glyphAtlasTexture.destroy(),this.latestFeatureIndex=null,this.state="unloaded";},lp.prototype.getBucket=function(t){return this.buckets[t.id]},lp.prototype.upload=function(t){for(var e in this.buckets){var r=this.buckets[e];r.uploadPending()&&r.upload(t);}var n=t.gl;this.imageAtlas&&!this.imageAtlas.uploaded&&(this.imageAtlasTexture=new Gl(t,this.imageAtlas.image,n.RGBA),this.imageAtlas.uploaded=!0),this.glyphAtlasImage&&(this.glyphAtlasTexture=new Gl(t,this.glyphAtlasImage,n.ALPHA),this.glyphAtlasImage=null);},lp.prototype.prepare=function(t){this.imageAtlas&&this.imageAtlas.patchUpdatedImages(t,this.imageAtlasTexture);},lp.prototype.queryRenderedFeatures=function(t,e,r,n,i,a,o,s,u,l){return this.latestFeatureIndex&&this.latestFeatureIndex.rawTileData?this.latestFeatureIndex.query({queryGeometry:n,cameraQueryGeometry:i,scale:a,tileSize:this.tileSize,pixelPosMatrix:l,transform:s,params:o,queryPadding:this.queryPadding*u},t,e,r):{}},lp.prototype.querySourceFeatures=function(t,e){var r=this.latestFeatureIndex;if(r&&r.rawTileData){var n=r.loadVTLayers(),i=e?e.sourceLayer:"",a=n._geojsonTileLayer||n[i];if(a)for(var o=mn(e&&e.filter),s=this.tileID.canonical,u=s.z,l=s.x,p=s.y,c={z:u,x:l,y:p},h=0;h<a.length;h++){var f=a.feature(h);if(o.filter(new gi(this.tileID.overscaledZ),f)){var y=r.getId(f,i),d=new rp(f,u,l,p,y);d.tile=c,t.push(d);}}}},lp.prototype.hasData=function(){return "loaded"===this.state||"reloading"===this.state||"expired"===this.state},lp.prototype.patternsLoaded=function(){return this.imageAtlas&&!!Object.keys(this.imageAtlas.patternPositions).length},lp.prototype.setExpiryData=function(t){var e=this.expirationTime;if(t.cacheControl){var r=k(t.cacheControl);r["max-age"]&&(this.expirationTime=Date.now()+1e3*r["max-age"]);}else t.expires&&(this.expirationTime=new Date(t.expires).getTime());if(this.expirationTime){var n=Date.now(),i=!1;if(this.expirationTime>n)i=!1;else if(e)if(this.expirationTime<e)i=!0;else{var a=this.expirationTime-e;a?this.expirationTime=n+Math.max(a,3e4):i=!0;}else i=!0;i?(this.expiredRequestCount++,this.state="expired"):this.expiredRequestCount=0;}},lp.prototype.getExpiryTimeout=function(){if(this.expirationTime)return this.expiredRequestCount?1e3*(1<<Math.min(this.expiredRequestCount-1,31)):Math.min(this.expirationTime-(new Date).getTime(),Math.pow(2,31)-1)},lp.prototype.setFeatureState=function(t,e){if(this.latestFeatureIndex&&this.latestFeatureIndex.rawTileData&&0!==Object.keys(t).length){var r=this.latestFeatureIndex.loadVTLayers();for(var n in this.buckets)if(e.style.hasLayer(n)){var i=this.buckets[n],a=i.layers[0].sourceLayer||"_geojsonTileLayer",o=r[a],s=t[a];o&&s&&0!==Object.keys(s).length&&(i.update(s,o,this.imageAtlas&&this.imageAtlas.patternPositions||{}),e&&e.style&&(this.queryPadding=Math.max(this.queryPadding,e.style.getLayer(n).queryRadius(i))));}}},lp.prototype.holdingForFade=function(){return void 0!==this.symbolFadeHoldUntil},lp.prototype.symbolFadeFinished=function(){return !this.symbolFadeHoldUntil||this.symbolFadeHoldUntil<D.now()},lp.prototype.clearFadeHold=function(){this.symbolFadeHoldUntil=void 0;},lp.prototype.setHoldDuration=function(t){this.symbolFadeHoldUntil=D.now()+t;},lp.prototype.setDependencies=function(t,e){for(var r={},n=0,i=e;n<i.length;n+=1)r[i[n]]=!0;this.dependencies[t]=r;},lp.prototype.hasDependency=function(t,e){for(var r=0,n=t;r<n.length;r+=1){var i=this.dependencies[n[r]];if(i)for(var a=0,o=e;a<o.length;a+=1)if(i[o[a]])return !0}return !1};var pp=self.performance,cp=function(t){this._marks={start:[t.url,"start"].join("#"),end:[t.url,"end"].join("#"),measure:t.url.toString()},pp.mark(this._marks.start);};cp.prototype.finish=function(){pp.mark(this._marks.end);var t=pp.getEntriesByName(this._marks.measure);return 0===t.length&&(pp.measure(this._marks.measure,this._marks.start,this._marks.end),t=pp.getEntriesByName(this._marks.measure),pp.clearMarks(this._marks.start),pp.clearMarks(this._marks.end),pp.clearMeasures(this._marks.measure)),t},t.Actor=Jl,t.AlphaImage=Ao,t.CanonicalTileID=Yl,t.CollisionBoxArray=sa,t.Color=$t,t.DEMData=tp,t.DataConstantProperty=zi,t.DictionaryCoder=ep,t.EXTENT=ze,t.ErrorEvent=It,t.EvaluationParameters=gi,t.Event=kt,t.Evented=zt,t.FeatureIndex=ap,t.FillBucket=hs,t.FillExtrusionBucket=Ms,t.ImageAtlas=Cu,t.ImagePosition=Iu,t.LineBucket=Os,t.LngLat=xe,t.LngLatBounds=ge,t.MercatorCoordinate=Ie,t.ONE_EM=Ws,t.OverscaledTileID=Wl,t.Point=i,t.Point$1=i,t.Properties=Pi,t.Protobuf=eu,t.RGBAImage=So,t.RequestManager=N,t.RequestPerformance=cp,t.ResourceType=yt,t.SegmentVector=va,t.SourceFeatureState=ip,t.StructArrayLayout1ui2=na,t.StructArrayLayout2i4=Oi,t.StructArrayLayout3ui6=ea,t.StructArrayLayout4i8=Ui,t.SymbolBucket=Tl,t.Texture=Gl,t.Tile=lp,t.Transitionable=wi,t.Uniform1f=Ta,t.Uniform1i=Ma,t.Uniform2f=Ea,t.Uniform3f=Pa,t.Uniform4f=Ba,t.UniformColor=Va,t.UniformMatrix4f=Da,t.UnwrappedTileID=$l,t.ValidationError=Mt,t.WritingMode=Mu,t.ZoomHistory=ei,t.add=function(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t[2]=e[2]+r[2],t},t.addDynamicAttributes=Il,t.asyncAll=function(t,e,r){if(!t.length)return r(null,[]);var n=t.length,i=new Array(t.length),a=null;t.forEach((function(t,o){e(t,(function(t,e){t&&(a=t),i[o]=e,0==--n&&r(a,i);}));}));},t.bezier=o,t.bindAll=d,t.browser=D,t.cacheEntryPossiblyAdded=function(t){++ht>st&&(t.getActor().send("enforceCacheSizeLimit",ot),ht=0);},t.clamp=u,t.clearTileCache=function(t){var e=self.caches.delete(at);t&&e.catch(t).then((function(){return t()}));},t.clone=function(t){var e=new yo(16);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e},t.clone$1=x,t.clone$2=function(t){var e=new yo(3);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e},t.config=L,t.create=function(){var t=new yo(16);return yo!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t},t.create$1=function(){var t=new yo(9);return yo!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[5]=0,t[6]=0,t[7]=0),t[0]=1,t[4]=1,t[8]=1,t},t.create$2=function(){var t=new yo(4);return yo!=Float32Array&&(t[1]=0,t[2]=0),t[0]=1,t[3]=1,t},t.createCommonjsModule=e,t.createExpression=rn,t.createLayout=Li,t.createStyleLayer=function(t){return "custom"===t.type?new Ol(t):new Ul[t.type](t)},t.cross=function(t,e,r){var n=e[0],i=e[1],a=e[2],o=r[0],s=r[1],u=r[2];return t[0]=i*u-a*s,t[1]=a*o-n*u,t[2]=n*s-i*o,t},t.deepEqual=function t(e,r){if(Array.isArray(e)){if(!Array.isArray(r)||e.length!==r.length)return !1;for(var n=0;n<e.length;n++)if(!t(e[n],r[n]))return !1;return !0}if("object"==typeof e&&null!==e&&null!==r){if("object"!=typeof r)return !1;if(Object.keys(e).length!==Object.keys(r).length)return !1;for(var i in e)if(!t(e[i],r[i]))return !1;return !0}return e===r},t.dot=function(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]},t.dot$1=function(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]+t[3]*e[3]},t.ease=s,t.emitValidationErrors=qn,t.endsWith=m,t.enforceCacheSizeLimit=function(t){lt(),W&&W.then((function(e){e.keys().then((function(r){for(var n=0;n<r.length-t;n++)e.delete(r[n]);}));}));},t.evaluateSizeForFeature=Zu,t.evaluateSizeForZoom=Ju,t.evaluateVariableOffset=ml,t.evented=yi,t.extend=p,t.featureFilter=mn,t.filterObject=g,t.fromRotation=function(t,e){var r=Math.sin(e),n=Math.cos(e);return t[0]=n,t[1]=r,t[2]=0,t[3]=-r,t[4]=n,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},t.getAnchorAlignment=ju,t.getAnchorJustification=vl,t.getArrayBuffer=bt,t.getImage=_t,t.getJSON=function(t,e){return xt(p(t,{type:"json"}),e)},t.getRTLTextPluginStatus=di,t.getReferrer=mt,t.getVideo=function(t,e){var r,n,i=self.document.createElement("video");i.muted=!0,i.onloadstart=function(){e(null,i);};for(var a=0;a<t.length;a++){var o=self.document.createElement("source");r=t[a],n=void 0,(n=self.document.createElement("a")).href=r,(n.protocol!==self.document.location.protocol||n.host!==self.document.location.host)&&(i.crossOrigin="Anonymous"),o.src=t[a],i.appendChild(o);}return {cancel:function(){}}},t.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},t.invert=function(t,e){var r=e[0],n=e[1],i=e[2],a=e[3],o=e[4],s=e[5],u=e[6],l=e[7],p=e[8],c=e[9],h=e[10],f=e[11],y=e[12],d=e[13],m=e[14],v=e[15],g=r*s-n*o,x=r*u-i*o,b=r*l-a*o,w=n*u-i*s,_=n*l-a*s,A=i*l-a*u,S=p*d-c*y,k=p*m-h*y,I=p*v-f*y,z=c*m-h*d,C=c*v-f*d,M=h*v-f*m,T=g*M-x*C+b*z+w*I-_*k+A*S;return T?(t[0]=(s*M-u*C+l*z)*(T=1/T),t[1]=(i*C-n*M-a*z)*T,t[2]=(d*A-m*_+v*w)*T,t[3]=(h*_-c*A-f*w)*T,t[4]=(u*I-o*M-l*k)*T,t[5]=(r*M-i*I+a*k)*T,t[6]=(m*b-y*A-v*x)*T,t[7]=(p*A-h*b+f*x)*T,t[8]=(o*C-s*I+l*S)*T,t[9]=(n*I-r*C-a*S)*T,t[10]=(y*_-d*b+v*g)*T,t[11]=(c*b-p*_-f*g)*T,t[12]=(s*k-o*z-u*S)*T,t[13]=(r*z-n*k+i*S)*T,t[14]=(d*x-y*w-m*g)*T,t[15]=(p*w-c*x+h*g)*T,t):null},t.isChar=ri,t.isMapboxURL=K,t.keysDifference=function(t,e){var r=[];for(var n in t)n in e||r.push(n);return r},t.makeRequest=xt,t.mapObject=v,t.mercatorXfromLng=_e,t.mercatorYfromLat=Ae,t.mercatorZfromAltitude=Se,t.multiply=function(t,e,r){var n=e[0],i=e[1],a=e[2],o=e[3],s=e[4],u=e[5],l=e[6],p=e[7],c=e[8],h=e[9],f=e[10],y=e[11],d=e[12],m=e[13],v=e[14],g=e[15],x=r[0],b=r[1],w=r[2],_=r[3];return t[0]=x*n+b*s+w*c+_*d,t[1]=x*i+b*u+w*h+_*m,t[2]=x*a+b*l+w*f+_*v,t[3]=x*o+b*p+w*y+_*g,t[4]=(x=r[4])*n+(b=r[5])*s+(w=r[6])*c+(_=r[7])*d,t[5]=x*i+b*u+w*h+_*m,t[6]=x*a+b*l+w*f+_*v,t[7]=x*o+b*p+w*y+_*g,t[8]=(x=r[8])*n+(b=r[9])*s+(w=r[10])*c+(_=r[11])*d,t[9]=x*i+b*u+w*h+_*m,t[10]=x*a+b*l+w*f+_*v,t[11]=x*o+b*p+w*y+_*g,t[12]=(x=r[12])*n+(b=r[13])*s+(w=r[14])*c+(_=r[15])*d,t[13]=x*i+b*u+w*h+_*m,t[14]=x*a+b*l+w*f+_*v,t[15]=x*o+b*p+w*y+_*g,t},t.mvt=ks,t.normalize=function(t,e){var r=e[0],n=e[1],i=e[2],a=r*r+n*n+i*i;return a>0&&(a=1/Math.sqrt(a)),t[0]=e[0]*a,t[1]=e[1]*a,t[2]=e[2]*a,t},t.number=Ye,t.offscreenCanvasSupported=ft,t.ortho=function(t,e,r,n,i,a,o){var s=1/(e-r),u=1/(n-i),l=1/(a-o);return t[0]=-2*s,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*u,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*l,t[11]=0,t[12]=(e+r)*s,t[13]=(i+n)*u,t[14]=(o+a)*l,t[15]=1,t},t.parseGlyphPBF=function(t){return new eu(t).readFields(bu,[])},t.pbf=eu,t.performSymbolLayout=function(t,e,r,n,a,o,s){t.createArrays(),t.tilePixelRatio=ze/(512*t.overscaling),t.compareText={},t.iconsNeedLinear=!1;var u=t.layers[0].layout,l=t.layers[0]._unevaluatedLayout._values,p={};if("composite"===t.textSizeData.kind){var c=t.textSizeData,h=c.maxZoom;p.compositeTextSizes=[l["text-size"].possiblyEvaluate(new gi(c.minZoom),s),l["text-size"].possiblyEvaluate(new gi(h),s)];}if("composite"===t.iconSizeData.kind){var f=t.iconSizeData,y=f.maxZoom;p.compositeIconSizes=[l["icon-size"].possiblyEvaluate(new gi(f.minZoom),s),l["icon-size"].possiblyEvaluate(new gi(y),s)];}p.layoutTextSize=l["text-size"].possiblyEvaluate(new gi(t.zoom+1),s),p.layoutIconSize=l["icon-size"].possiblyEvaluate(new gi(t.zoom+1),s),p.textMaxSize=l["text-size"].possiblyEvaluate(new gi(18));for(var d=u.get("text-line-height")*Ws,m="map"===u.get("text-rotation-alignment")&&"point"!==u.get("symbol-placement"),v=u.get("text-keep-upright"),g=u.get("text-size"),x=function(){var o=_[b],l=u.get("text-font").evaluate(o,{},s).join(","),c=g.evaluate(o,{},s),h=p.layoutTextSize.evaluate(o,{},s),f=p.layoutIconSize.evaluate(o,{},s),y={horizontal:{},vertical:void 0},x=o.text,A=[0,0];if(x){var S=x.toString(),k=u.get("text-letter-spacing").evaluate(o,{},s)*Ws,I=function(t){for(var e=0,r=t;e<r.length;e+=1)if(n=r[e].charCodeAt(0),ri.Arabic(n)||ri["Arabic Supplement"](n)||ri["Arabic Extended-A"](n)||ri["Arabic Presentation Forms-A"](n)||ri["Arabic Presentation Forms-B"](n))return !1;var n;return !0}(S)?k:0,z=u.get("text-anchor").evaluate(o,{},s),C=u.get("text-variable-anchor");if(!C){var M=u.get("text-radial-offset").evaluate(o,{},s);A=M?ml(z,[M*Ws,dl]):u.get("text-offset").evaluate(o,{},s).map((function(t){return t*Ws}));}var T=m?"center":u.get("text-justify").evaluate(o,{},s),E=u.get("symbol-placement"),P="point"===E?u.get("text-max-width").evaluate(o,{},s)*Ws:0,B=function(){t.allowVerticalPlacement&&ni(S)&&(y.vertical=Bu(x,e,r,a,l,P,d,z,"left",I,A,Mu.vertical,!0,E,h,c));};if(!m&&C){for(var V="auto"===T?C.map((function(t){return vl(t)})):[T],F=!1,D=0;D<V.length;D++){var L=V[D];if(!y.horizontal[L])if(F)y.horizontal[L]=y.horizontal[0];else{var R=Bu(x,e,r,a,l,P,d,"center",L,I,A,Mu.horizontal,!1,E,h,c);R&&(y.horizontal[L]=R,F=1===R.positionedLines.length);}}B();}else{"auto"===T&&(T=vl(z));var O=Bu(x,e,r,a,l,P,d,z,T,I,A,Mu.horizontal,!1,E,h,c);O&&(y.horizontal[T]=O),B(),ni(S)&&m&&v&&(y.vertical=Bu(x,e,r,a,l,P,d,z,T,I,A,Mu.vertical,!1,E,h,c));}}var U=void 0,j=!1;if(o.icon&&o.icon.name){var q=n[o.icon.name];q&&(U=function(t,e,r){var n=ju(r),i=e[0]-t.displaySize[0]*n.horizontalAlign,a=e[1]-t.displaySize[1]*n.verticalAlign;return {image:t,top:a,bottom:a+t.displaySize[1],left:i,right:i+t.displaySize[0]}}(a[o.icon.name],u.get("icon-offset").evaluate(o,{},s),u.get("icon-anchor").evaluate(o,{},s)),j=q.sdf,void 0===t.sdfIcons?t.sdfIcons=q.sdf:t.sdfIcons!==q.sdf&&w("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"),q.pixelRatio!==t.pixelRatio?t.iconsNeedLinear=!0:0!==u.get("icon-rotate").constantOr(1)&&(t.iconsNeedLinear=!0));}var N=wl(y.horizontal)||y.vertical;t.iconsInText=!!N&&N.iconsInText,(N||U)&&function(t,e,r,n,a,o,s,u,l,p,c){var h=o.textMaxSize.evaluate(e,{});void 0===h&&(h=s);var f,y=t.layers[0].layout,d=y.get("icon-offset").evaluate(e,{},c),m=wl(r.horizontal),v=s/24,g=t.tilePixelRatio*v,x=t.tilePixelRatio*h/24,b=t.tilePixelRatio*u,_=t.tilePixelRatio*y.get("symbol-spacing"),A=y.get("text-padding")*t.tilePixelRatio,S=y.get("icon-padding")*t.tilePixelRatio,k=y.get("text-max-angle")/180*Math.PI,I="map"===y.get("text-rotation-alignment")&&"point"!==y.get("symbol-placement"),z="map"===y.get("icon-rotation-alignment")&&"point"!==y.get("symbol-placement"),C=y.get("symbol-placement"),M=_/2,T=y.get("icon-text-fit");n&&"none"!==T&&(t.allowVerticalPlacement&&r.vertical&&(f=Nu(n,r.vertical,T,y.get("icon-text-fit-padding"),d,v)),m&&(n=Nu(n,m,T,y.get("icon-text-fit-padding"),d,v)));var E=function(i,s){s.x<0||s.x>=ze||s.y<0||s.y>=ze||function(t,e,r,n,i,a,o,s,u,l,p,c,h,f,y,d,m,v,g,x,b,_,A,S){var k,I,z,C,M,T=t.addToLineVertexArray(e,r),E=0,P=0,B=0,V=0,F=-1,D=-1,L={},R=_a(""),O=0,U=0;if(void 0===s._unevaluatedLayout.getValue("text-radial-offset")?(O=(k=s.layout.get("text-offset").evaluate(b,{},S).map((function(t){return t*Ws})))[0],U=k[1]):(O=s.layout.get("text-radial-offset").evaluate(b,{},S)*Ws,U=dl),t.allowVerticalPlacement&&n.vertical){var j=s.layout.get("text-rotate").evaluate(b,{},S)+90;C=new ul(u,r,e,l,p,c,n.vertical,h,f,y,t.overscaling,j),o&&(M=new ul(u,r,e,l,p,c,o,m,v,y,t.overscaling,j));}if(i){var q=s.layout.get("icon-rotate").evaluate(b,{}),N="none"!==s.layout.get("icon-text-fit"),K=nl(i,q,A,N),X=o?nl(o,q,A,N):void 0;z=new ul(u,r,e,l,p,c,i,m,v,!1,t.overscaling,q),E=4*K.length;var G=t.iconSizeData,Z=null;"source"===G.kind?(Z=[Xu*s.layout.get("icon-size").evaluate(b,{})])[0]>xl&&w(t.layerIds[0]+': Value for "icon-size" is >= '+gl+'. Reduce your "icon-size".'):"composite"===G.kind&&((Z=[Xu*_.compositeIconSizes[0].evaluate(b,{},S),Xu*_.compositeIconSizes[1].evaluate(b,{},S)])[0]>xl||Z[1]>xl)&&w(t.layerIds[0]+': Value for "icon-size" is >= '+gl+'. Reduce your "icon-size".'),t.addSymbols(t.icon,K,Z,x,g,b,!1,e,T.lineStartIndex,T.lineLength,-1,S),F=t.icon.placedSymbolArray.length-1,X&&(P=4*X.length,t.addSymbols(t.icon,X,Z,x,g,b,Mu.vertical,e,T.lineStartIndex,T.lineLength,-1,S),D=t.icon.placedSymbolArray.length-1);}for(var J in n.horizontal){var H=n.horizontal[J];if(!I){R=_a(H.text);var Y=s.layout.get("text-rotate").evaluate(b,{},S);I=new ul(u,r,e,l,p,c,H,h,f,y,t.overscaling,Y);}var $=1===H.positionedLines.length;if(B+=bl(t,e,H,a,s,y,b,d,T,n.vertical?Mu.horizontal:Mu.horizontalOnly,$?Object.keys(n.horizontal):[J],L,F,_,S),$)break}n.vertical&&(V+=bl(t,e,n.vertical,a,s,y,b,d,T,Mu.vertical,["vertical"],L,D,_,S));var W=I?I.boxStartIndex:t.collisionBoxArray.length,Q=I?I.boxEndIndex:t.collisionBoxArray.length,tt=C?C.boxStartIndex:t.collisionBoxArray.length,et=C?C.boxEndIndex:t.collisionBoxArray.length,rt=z?z.boxStartIndex:t.collisionBoxArray.length,nt=z?z.boxEndIndex:t.collisionBoxArray.length,it=M?M.boxStartIndex:t.collisionBoxArray.length,at=M?M.boxEndIndex:t.collisionBoxArray.length;t.glyphOffsetArray.length>=Tl.MAX_GLYPHS&&w("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"),void 0!==b.sortKey&&t.addToSortKeyRanges(t.symbolInstances.length,b.sortKey),t.symbolInstances.emplaceBack(e.x,e.y,L.right>=0?L.right:-1,L.center>=0?L.center:-1,L.left>=0?L.left:-1,L.vertical||-1,F,D,R,W,Q,tt,et,rt,nt,it,at,l,B,V,E,P,0,h,O,U);}(t,s,i,r,n,a,f,t.layers[0],t.collisionBoxArray,e.index,e.sourceLayerIndex,t.index,g,A,I,l,b,S,z,d,e,o,p,c);};if("line"===C)for(var P=0,B=function(t,e,r,n,a){for(var o=[],s=0;s<t.length;s++)for(var u=t[s],l=void 0,p=0;p<u.length-1;p++){var c=u[p],h=u[p+1];c.x<0&&h.x<0||(c.x<0?c=new i(0,c.y+(0-c.x)/(h.x-c.x)*(h.y-c.y))._round():h.x<0&&(h=new i(0,c.y+(0-c.x)/(h.x-c.x)*(h.y-c.y))._round()),c.y<0&&h.y<0||(c.y<0?c=new i(c.x+(0-c.y)/(h.y-c.y)*(h.x-c.x),0)._round():h.y<0&&(h=new i(c.x+(0-c.y)/(h.y-c.y)*(h.x-c.x),0)._round()),c.x>=n&&h.x>=n||(c.x>=n?c=new i(n,c.y+(n-c.x)/(h.x-c.x)*(h.y-c.y))._round():h.x>=n&&(h=new i(n,c.y+(n-c.x)/(h.x-c.x)*(h.y-c.y))._round()),c.y>=a&&h.y>=a||(c.y>=a?c=new i(c.x+(a-c.y)/(h.y-c.y)*(h.x-c.x),a)._round():h.y>=a&&(h=new i(c.x+(a-c.y)/(h.y-c.y)*(h.x-c.x),a)._round()),l&&c.equals(l[l.length-1])||o.push(l=[c]),l.push(h)))));}return o}(e.geometry,0,0,ze,ze);P<B.length;P+=1)for(var V=B[P],F=0,D=el(V,_,k,r.vertical||m,n,24,x,t.overscaling,ze);F<D.length;F+=1){var L=D[F];m&&_l(t,m.text,M,L)||E(V,L);}else if("line-center"===C)for(var R=0,O=e.geometry;R<O.length;R+=1){var U=O[R];if(U.length>1){var j=tl(U,k,r.vertical||m,n,24,x);j&&E(U,j);}}else if("Polygon"===e.type)for(var q=0,N=us(e.geometry,0);q<N.length;q+=1){var K=N[q],X=cl(K,16);E(K[0],new Ku(X.x,X.y,0));}else if("LineString"===e.type)for(var G=0,Z=e.geometry;G<Z.length;G+=1){var J=Z[G];E(J,new Ku(J[0].x,J[0].y,0));}else if("Point"===e.type)for(var H=0,Y=e.geometry;H<Y.length;H+=1)for(var $=0,W=Y[H];$<W.length;$+=1){var Q=W[$];E([Q],new Ku(Q.x,Q.y,0));}}(t,o,y,U,n,p,h,f,A,j,s);},b=0,_=t.features;b<_.length;b+=1)x();o&&t.generateCollisionDebugBuffers();},t.perspective=function(t,e,r,n,i){var a,o=1/Math.tan(e/2);return t[0]=o/r,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=o,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,null!=i&&i!==1/0?(t[10]=(i+n)*(a=1/(n-i)),t[14]=2*i*n*a):(t[10]=-1,t[14]=-2*n),t},t.pick=function(t,e){for(var r={},n=0;n<e.length;n++){var i=e[n];i in t&&(r[i]=t[i]);}return r},t.plugin=vi,t.polygonIntersectsPolygon=$a,t.postMapLoadEvent=it,t.postTurnstileEvent=rt,t.potpack=Su,t.refProperties=["type","source","source-layer","minzoom","maxzoom","filter","layout"],t.register=Hn,t.registerForPluginStateChange=function(t){return t({pluginStatus:pi,pluginURL:ci}),yi.on("pluginStateChange",t),t},t.rotate=function(t,e,r){var n=e[0],i=e[1],a=e[2],o=e[3],s=Math.sin(r),u=Math.cos(r);return t[0]=n*u+a*s,t[1]=i*u+o*s,t[2]=n*-s+a*u,t[3]=i*-s+o*u,t},t.rotateX=function(t,e,r){var n=Math.sin(r),i=Math.cos(r),a=e[4],o=e[5],s=e[6],u=e[7],l=e[8],p=e[9],c=e[10],h=e[11];return e!==t&&(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[4]=a*i+l*n,t[5]=o*i+p*n,t[6]=s*i+c*n,t[7]=u*i+h*n,t[8]=l*i-a*n,t[9]=p*i-o*n,t[10]=c*i-s*n,t[11]=h*i-u*n,t},t.rotateZ=function(t,e,r){var n=Math.sin(r),i=Math.cos(r),a=e[0],o=e[1],s=e[2],u=e[3],l=e[4],p=e[5],c=e[6],h=e[7];return e!==t&&(t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=a*i+l*n,t[1]=o*i+p*n,t[2]=s*i+c*n,t[3]=u*i+h*n,t[4]=l*i-a*n,t[5]=p*i-o*n,t[6]=c*i-s*n,t[7]=h*i-u*n,t},t.scale=function(t,e,r){var n=r[0],i=r[1],a=r[2];return t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n,t[3]=e[3]*n,t[4]=e[4]*i,t[5]=e[5]*i,t[6]=e[6]*i,t[7]=e[7]*i,t[8]=e[8]*a,t[9]=e[9]*a,t[10]=e[10]*a,t[11]=e[11]*a,t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t},t.scale$1=function(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t},t.scale$2=function(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t},t.setCacheLimits=function(t,e){ot=t,st=e;},t.setRTLTextPlugin=function(t,e,r){if(void 0===r&&(r=!1),"deferred"===pi||"loading"===pi||"loaded"===pi)throw new Error("setRTLTextPlugin cannot be called multiple times.");ci=D.resolveURL(t),pi="deferred",li=e,fi(),r||mi();},t.sphericalToCartesian=function(t){var e=t[0],r=t[1],n=t[2];return r+=90,r*=Math.PI/180,n*=Math.PI/180,{x:e*Math.cos(r)*Math.sin(n),y:e*Math.sin(r)*Math.sin(n),z:e*Math.cos(n)}},t.sqrLen=function(t){var e=t[0],r=t[1];return e*e+r*r},t.styleSpec=Ct,t.sub=function(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t[2]=e[2]-r[2],t},t.symbolSize=Hu,t.transformMat3=function(t,e,r){var n=e[0],i=e[1],a=e[2];return t[0]=n*r[0]+i*r[3]+a*r[6],t[1]=n*r[1]+i*r[4]+a*r[7],t[2]=n*r[2]+i*r[5]+a*r[8],t},t.transformMat4=mo,t.translate=function(t,e,r){var n,i,a,o,s,u,l,p,c,h,f,y,d=r[0],m=r[1],v=r[2];return e===t?(t[12]=e[0]*d+e[4]*m+e[8]*v+e[12],t[13]=e[1]*d+e[5]*m+e[9]*v+e[13],t[14]=e[2]*d+e[6]*m+e[10]*v+e[14],t[15]=e[3]*d+e[7]*m+e[11]*v+e[15]):(i=e[1],a=e[2],o=e[3],s=e[4],u=e[5],l=e[6],p=e[7],c=e[8],h=e[9],f=e[10],y=e[11],t[0]=n=e[0],t[1]=i,t[2]=a,t[3]=o,t[4]=s,t[5]=u,t[6]=l,t[7]=p,t[8]=c,t[9]=h,t[10]=f,t[11]=y,t[12]=n*d+s*m+c*v+e[12],t[13]=i*d+u*m+h*v+e[13],t[14]=a*d+l*m+f*v+e[14],t[15]=o*d+p*m+y*v+e[15]),t},t.triggerPluginCompletionEvent=hi,t.uniqueId=h,t.validateCustomStyleLayer=function(t){var e=[],r=t.id;return void 0===r&&e.push({message:"layers."+r+': missing required property "id"'}),void 0===t.render&&e.push({message:"layers."+r+': missing required method "render"'}),t.renderingMode&&"2d"!==t.renderingMode&&"3d"!==t.renderingMode&&e.push({message:"layers."+r+': property "renderingMode" must be either "2d" or "3d"'}),e},t.validateLight=On,t.validateStyle=Rn,t.values=function(t){var e=[];for(var r in t)e.push(t[r]);return e},t.vectorTile=ks,t.version="1.9.1",t.warnOnce=w,t.webpSupported=R,t.window=self,t.wrap=l;}));

define(["./shared"],(function(e){"use strict";function t(e){var r=typeof e;if("number"===r||"boolean"===r||"string"===r||null==e)return JSON.stringify(e);if(Array.isArray(e)){for(var i="[",o=0,n=e;o<n.length;o+=1)i+=t(n[o])+",";return i+"]"}for(var a=Object.keys(e).sort(),s="{",l=0;l<a.length;l++)s+=JSON.stringify(a[l])+":"+t(e[a[l]])+",";return s+"}"}function r(r){for(var i="",o=0,n=e.refProperties;o<n.length;o+=1)i+="/"+t(r[n[o]]);return i}var i=function(e){this.keyCache={},e&&this.replace(e);};i.prototype.replace=function(e){this._layerConfigs={},this._layers={},this.update(e,[]);},i.prototype.update=function(t,i){for(var o=this,n=0,a=t;n<a.length;n+=1){var s=a[n];this._layerConfigs[s.id]=s;var l=this._layers[s.id]=e.createStyleLayer(s);l._featureFilter=e.featureFilter(l.filter),this.keyCache[s.id]&&delete this.keyCache[s.id];}for(var u=0,h=i;u<h.length;u+=1){var c=h[u];delete this.keyCache[c],delete this._layerConfigs[c],delete this._layers[c];}this.familiesBySource={};for(var p=0,f=function(e,t){for(var i={},o=0;o<e.length;o++){var n=t&&t[e[o].id]||r(e[o]);t&&(t[e[o].id]=n);var a=i[n];a||(a=i[n]=[]),a.push(e[o]);}var s=[];for(var l in i)s.push(i[l]);return s}(e.values(this._layerConfigs),this.keyCache);p<f.length;p+=1){var d=f[p].map((function(e){return o._layers[e.id]})),g=d[0];if("none"!==g.visibility){var m=g.source||"",v=this.familiesBySource[m];v||(v=this.familiesBySource[m]={});var y=g.sourceLayer||"_geojsonTileLayer",x=v[y];x||(x=v[y]=[]),x.push(d);}}};var o=function(t){var r={},i=[];for(var o in t){var n=t[o],a=r[o]={};for(var s in n){var l=n[+s];if(l&&0!==l.bitmap.width&&0!==l.bitmap.height){var u={x:0,y:0,w:l.bitmap.width+2,h:l.bitmap.height+2};i.push(u),a[s]={rect:u,metrics:l.metrics};}}}var h=e.potpack(i),c=new e.AlphaImage({width:h.w||1,height:h.h||1});for(var p in t){var f=t[p];for(var d in f){var g=f[+d];if(g&&0!==g.bitmap.width&&0!==g.bitmap.height){var m=r[p][d].rect;e.AlphaImage.copy(g.bitmap,c,{x:0,y:0},{x:m.x+1,y:m.y+1},g.bitmap);}}}this.image=c,this.positions=r;};e.register("GlyphAtlas",o);var n=function(t){this.tileID=new e.OverscaledTileID(t.tileID.overscaledZ,t.tileID.wrap,t.tileID.canonical.z,t.tileID.canonical.x,t.tileID.canonical.y),this.uid=t.uid,this.zoom=t.zoom,this.pixelRatio=t.pixelRatio,this.tileSize=t.tileSize,this.source=t.source,this.overscaling=this.tileID.overscaleFactor(),this.showCollisionBoxes=t.showCollisionBoxes,this.collectResourceTiming=!!t.collectResourceTiming,this.returnDependencies=!!t.returnDependencies,this.promoteId=t.promoteId;};function a(t,r,i){for(var o=new e.EvaluationParameters(r),n=0,a=t;n<a.length;n+=1)a[n].recalculate(o,i);}function s(t,r){var i=e.getArrayBuffer(t.request,(function(t,i,o,n){t?r(t):i&&r(null,{vectorTile:new e.vectorTile.VectorTile(new e.pbf(i)),rawData:i,cacheControl:o,expires:n});}));return function(){i.cancel(),r();}}n.prototype.parse=function(t,r,i,n,s){var l=this;this.status="parsing",this.data=t,this.collisionBoxArray=new e.CollisionBoxArray;var u=new e.DictionaryCoder(Object.keys(t.layers).sort()),h=new e.FeatureIndex(this.tileID,this.promoteId);h.bucketLayerIDs=[];var c,p,f,d,g={},m={featureIndex:h,iconDependencies:{},patternDependencies:{},glyphDependencies:{},availableImages:i},v=r.familiesBySource[this.source];for(var y in v){var x=t.layers[y];if(x){1===x.version&&e.warnOnce('Vector tile source "'+this.source+'" layer "'+y+'" does not use vector tile spec v2 and therefore may have some rendering errors.');for(var w=u.encode(y),S=[],I=0;I<x.length;I++){var M=x.feature(I),b=h.getId(M,y);S.push({feature:M,id:b,index:I,sourceLayerIndex:w});}for(var P=0,_=v[y];P<_.length;P+=1){var k=_[P],T=k[0];T.minzoom&&this.zoom<Math.floor(T.minzoom)||T.maxzoom&&this.zoom>=T.maxzoom||"none"!==T.visibility&&(a(k,this.zoom,i),(g[T.id]=T.createBucket({index:h.bucketLayerIDs.length,layers:k,zoom:this.zoom,pixelRatio:this.pixelRatio,overscaling:this.overscaling,collisionBoxArray:this.collisionBoxArray,sourceLayerIndex:w,sourceID:this.source})).populate(S,m,this.tileID.canonical),h.bucketLayerIDs.push(k.map((function(e){return e.id}))));}}}var C=e.mapObject(m.glyphDependencies,(function(e){return Object.keys(e).map(Number)}));Object.keys(C).length?n.send("getGlyphs",{uid:this.uid,stacks:C},(function(e,t){c||(c=e,p=t,O.call(l));})):p={};var D=Object.keys(m.iconDependencies);D.length?n.send("getImages",{icons:D,source:this.source,tileID:this.tileID,type:"icons"},(function(e,t){c||(c=e,f=t,O.call(l));})):f={};var L=Object.keys(m.patternDependencies);function O(){if(c)return s(c);if(p&&f&&d){var t=new o(p),r=new e.ImageAtlas(f,d);for(var n in g){var l=g[n];l instanceof e.SymbolBucket?(a(l.layers,this.zoom,i),e.performSymbolLayout(l,p,t.positions,f,r.iconPositions,this.showCollisionBoxes,this.tileID.canonical)):l.hasPattern&&(l instanceof e.LineBucket||l instanceof e.FillBucket||l instanceof e.FillExtrusionBucket)&&(a(l.layers,this.zoom,i),l.addFeatures(m,this.tileID.canonical,r.patternPositions));}this.status="done",s(null,{buckets:e.values(g).filter((function(e){return !e.isEmpty()})),featureIndex:h,collisionBoxArray:this.collisionBoxArray,glyphAtlasImage:t.image,imageAtlas:r,glyphMap:this.returnDependencies?p:null,iconMap:this.returnDependencies?f:null,glyphPositions:this.returnDependencies?t.positions:null});}}L.length?n.send("getImages",{icons:L,source:this.source,tileID:this.tileID,type:"patterns"},(function(e,t){c||(c=e,d=t,O.call(l));})):d={},O.call(this);};var l=function(e,t,r,i){this.actor=e,this.layerIndex=t,this.availableImages=r,this.loadVectorData=i||s,this.loading={},this.loaded={};};l.prototype.loadTile=function(t,r){var i=this,o=t.uid;this.loading||(this.loading={});var a=!!(t&&t.request&&t.request.collectResourceTiming)&&new e.RequestPerformance(t.request),s=this.loading[o]=new n(t);s.abort=this.loadVectorData(t,(function(t,n){if(delete i.loading[o],t||!n)return s.status="done",i.loaded[o]=s,r(t);var l=n.rawData,u={};n.expires&&(u.expires=n.expires),n.cacheControl&&(u.cacheControl=n.cacheControl);var h={};if(a){var c=a.finish();c&&(h.resourceTiming=JSON.parse(JSON.stringify(c)));}s.vectorTile=n.vectorTile,s.parse(n.vectorTile,i.layerIndex,i.availableImages,i.actor,(function(t,i){if(t||!i)return r(t);r(null,e.extend({rawTileData:l.slice(0)},i,u,h));})),i.loaded=i.loaded||{},i.loaded[o]=s;}));},l.prototype.reloadTile=function(e,t){var r=this,i=this.loaded,o=e.uid,n=this;if(i&&i[o]){var a=i[o];a.showCollisionBoxes=e.showCollisionBoxes;var s=function(e,i){var o=a.reloadCallback;o&&(delete a.reloadCallback,a.parse(a.vectorTile,n.layerIndex,r.availableImages,n.actor,o)),t(e,i);};"parsing"===a.status?a.reloadCallback=s:"done"===a.status&&(a.vectorTile?a.parse(a.vectorTile,this.layerIndex,this.availableImages,this.actor,s):s());}},l.prototype.abortTile=function(e,t){var r=this.loading,i=e.uid;r&&r[i]&&r[i].abort&&(r[i].abort(),delete r[i]),t();},l.prototype.removeTile=function(e,t){var r=this.loaded,i=e.uid;r&&r[i]&&delete r[i],t();};var u=e.window.ImageBitmap,h=function(){this.loaded={};};h.prototype.loadTile=function(t,r){var i=t.uid,o=t.encoding,n=t.rawImageData,a=u&&n instanceof u?this.getImageData(n):n,s=new e.DEMData(i,a,o);this.loaded=this.loaded||{},this.loaded[i]=s,r(null,s);},h.prototype.getImageData=function(t){this.offscreenCanvas&&this.offscreenCanvasContext||(this.offscreenCanvas=new OffscreenCanvas(t.width,t.height),this.offscreenCanvasContext=this.offscreenCanvas.getContext("2d")),this.offscreenCanvas.width=t.width,this.offscreenCanvas.height=t.height,this.offscreenCanvasContext.drawImage(t,0,0,t.width,t.height);var r=this.offscreenCanvasContext.getImageData(-1,-1,t.width+2,t.height+2);return this.offscreenCanvasContext.clearRect(0,0,this.offscreenCanvas.width,this.offscreenCanvas.height),new e.RGBAImage({width:r.width,height:r.height},r.data)},h.prototype.removeTile=function(e){var t=this.loaded,r=e.uid;t&&t[r]&&delete t[r];};var c={RADIUS:6378137,FLATTENING:1/298.257223563,POLAR_RADIUS:6356752.3142};function p(e){var t=0;if(e&&e.length>0){t+=Math.abs(f(e[0]));for(var r=1;r<e.length;r++)t-=Math.abs(f(e[r]));}return t}function f(e){var t,r,i,o,n,a,s=0,l=e.length;if(l>2){for(a=0;a<l;a++)a===l-2?(i=l-2,o=l-1,n=0):a===l-1?(i=l-1,o=0,n=1):(i=a,o=a+1,n=a+2),t=e[i],r=e[o],s+=(d(e[n][0])-d(t[0]))*Math.sin(d(r[1]));s=s*c.RADIUS*c.RADIUS/2;}return s}function d(e){return e*Math.PI/180}var g={geometry:function e(t){var r,i=0;switch(t.type){case"Polygon":return p(t.coordinates);case"MultiPolygon":for(r=0;r<t.coordinates.length;r++)i+=p(t.coordinates[r]);return i;case"Point":case"MultiPoint":case"LineString":case"MultiLineString":return 0;case"GeometryCollection":for(r=0;r<t.geometries.length;r++)i+=e(t.geometries[r]);return i}},ring:f};function m(e,t){return function(r){return e(r,t)}}function v(e,t){e[0]=y(e[0],t=!!t);for(var r=1;r<e.length;r++)e[r]=y(e[r],!t);return e}function y(e,t){return function(e){return g.ring(e)>=0}(e)===t?e:e.reverse()}var x=e.vectorTile.VectorTileFeature.prototype.toGeoJSON,w=function(t){this._feature=t,this.extent=e.EXTENT,this.type=t.type,this.properties=t.tags,"id"in t&&!isNaN(t.id)&&(this.id=parseInt(t.id,10));};w.prototype.loadGeometry=function(){if(1===this._feature.type){for(var t=[],r=0,i=this._feature.geometry;r<i.length;r+=1){var o=i[r];t.push([new e.Point$1(o[0],o[1])]);}return t}for(var n=[],a=0,s=this._feature.geometry;a<s.length;a+=1){for(var l=[],u=0,h=s[a];u<h.length;u+=1){var c=h[u];l.push(new e.Point$1(c[0],c[1]));}n.push(l);}return n},w.prototype.toGeoJSON=function(e,t,r){return x.call(this,e,t,r)};var S=function(t){this.layers={_geojsonTileLayer:this},this.name="_geojsonTileLayer",this.extent=e.EXTENT,this.length=t.length,this._features=t;};S.prototype.feature=function(e){return new w(this._features[e])};var I=e.vectorTile.VectorTileFeature,M=b;function b(e,t){this.options=t||{},this.features=e,this.length=e.length;}function P(e,t){this.id="number"==typeof e.id?e.id:void 0,this.type=e.type,this.rawGeometry=1===e.type?[e.geometry]:e.geometry,this.properties=e.tags,this.extent=t||4096;}b.prototype.feature=function(e){return new P(this.features[e],this.options.extent)},P.prototype.loadGeometry=function(){var t=this.rawGeometry;this.geometry=[];for(var r=0;r<t.length;r++){for(var i=t[r],o=[],n=0;n<i.length;n++)o.push(new e.Point$1(i[n][0],i[n][1]));this.geometry.push(o);}return this.geometry},P.prototype.bbox=function(){this.geometry||this.loadGeometry();for(var e=this.geometry,t=1/0,r=-1/0,i=1/0,o=-1/0,n=0;n<e.length;n++)for(var a=e[n],s=0;s<a.length;s++){var l=a[s];t=Math.min(t,l.x),r=Math.max(r,l.x),i=Math.min(i,l.y),o=Math.max(o,l.y);}return [t,i,r,o]},P.prototype.toGeoJSON=I.prototype.toGeoJSON;var _=T,k=M;function T(t){var r=new e.pbf;return function(e,t){for(var r in e.layers)t.writeMessage(3,C,e.layers[r]);}(t,r),r.finish()}function C(e,t){var r;t.writeVarintField(15,e.version||1),t.writeStringField(1,e.name||""),t.writeVarintField(5,e.extent||4096);var i={keys:[],values:[],keycache:{},valuecache:{}};for(r=0;r<e.length;r++)i.feature=e.feature(r),t.writeMessage(2,D,i);var o=i.keys;for(r=0;r<o.length;r++)t.writeStringField(3,o[r]);var n=i.values;for(r=0;r<n.length;r++)t.writeMessage(4,N,n[r]);}function D(e,t){var r=e.feature;void 0!==r.id&&t.writeVarintField(1,r.id),t.writeMessage(2,L,e),t.writeVarintField(3,r.type),t.writeMessage(4,E,r);}function L(e,t){var r=e.feature,i=e.keys,o=e.values,n=e.keycache,a=e.valuecache;for(var s in r.properties){var l=n[s];void 0===l&&(i.push(s),n[s]=l=i.length-1),t.writeVarint(l);var u=r.properties[s],h=typeof u;"string"!==h&&"boolean"!==h&&"number"!==h&&(u=JSON.stringify(u));var c=h+":"+u,p=a[c];void 0===p&&(o.push(u),a[c]=p=o.length-1),t.writeVarint(p);}}function O(e,t){return (t<<3)+(7&e)}function z(e){return e<<1^e>>31}function E(e,t){for(var r=e.loadGeometry(),i=e.type,o=0,n=0,a=r.length,s=0;s<a;s++){var l=r[s],u=1;1===i&&(u=l.length),t.writeVarint(O(1,u));for(var h=3===i?l.length-1:l.length,c=0;c<h;c++){1===c&&1!==i&&t.writeVarint(O(2,h-1));var p=l[c].x-o,f=l[c].y-n;t.writeVarint(z(p)),t.writeVarint(z(f)),o+=p,n+=f;}3===i&&t.writeVarint(O(7,1));}}function N(e,t){var r=typeof e;"string"===r?t.writeStringField(1,e):"boolean"===r?t.writeBooleanField(7,e):"number"===r&&(e%1!=0?t.writeDoubleField(3,e):e<0?t.writeSVarintField(6,e):t.writeVarintField(5,e));}function F(e,t,r,i){A(e,r,i),A(t,2*r,2*i),A(t,2*r+1,2*i+1);}function A(e,t,r){var i=e[t];e[t]=e[r],e[r]=i;}function J(e,t,r,i){var o=e-r,n=t-i;return o*o+n*n}_.fromVectorTileJs=T,_.fromGeojsonVt=function(e,t){t=t||{};var r={};for(var i in e)r[i]=new M(e[i].features,t),r[i].name=i,r[i].version=t.version,r[i].extent=t.extent;return T({layers:r})},_.GeoJSONWrapper=k;var Z=function(e){return e[0]},B=function(e){return e[1]},G=function(e,t,r,i,o){void 0===t&&(t=Z),void 0===r&&(r=B),void 0===i&&(i=64),void 0===o&&(o=Float64Array),this.nodeSize=i,this.points=e;for(var n=e.length<65536?Uint16Array:Uint32Array,a=this.ids=new n(e.length),s=this.coords=new o(2*e.length),l=0;l<e.length;l++)a[l]=l,s[2*l]=t(e[l]),s[2*l+1]=r(e[l]);!function e(t,r,i,o,n,a){if(!(n-o<=i)){var s=o+n>>1;!function e(t,r,i,o,n,a){for(;n>o;){if(n-o>600){var s=n-o+1,l=i-o+1,u=Math.log(s),h=.5*Math.exp(2*u/3),c=.5*Math.sqrt(u*h*(s-h)/s)*(l-s/2<0?-1:1);e(t,r,i,Math.max(o,Math.floor(i-l*h/s+c)),Math.min(n,Math.floor(i+(s-l)*h/s+c)),a);}var p=r[2*i+a],f=o,d=n;for(F(t,r,o,i),r[2*n+a]>p&&F(t,r,o,n);f<d;){for(F(t,r,f,d),f++,d--;r[2*f+a]<p;)f++;for(;r[2*d+a]>p;)d--;}r[2*o+a]===p?F(t,r,o,d):F(t,r,++d,n),d<=i&&(o=d+1),i<=d&&(n=d-1);}}(t,r,s,o,n,a%2),e(t,r,i,o,s-1,a+1),e(t,r,i,s+1,n,a+1);}}(a,s,i,0,a.length-1,0);};G.prototype.range=function(e,t,r,i){return function(e,t,r,i,o,n,a){for(var s,l,u=[0,e.length-1,0],h=[];u.length;){var c=u.pop(),p=u.pop(),f=u.pop();if(p-f<=a)for(var d=f;d<=p;d++)l=t[2*d+1],(s=t[2*d])>=r&&s<=o&&l>=i&&l<=n&&h.push(e[d]);else{var g=Math.floor((f+p)/2);l=t[2*g+1],(s=t[2*g])>=r&&s<=o&&l>=i&&l<=n&&h.push(e[g]);var m=(c+1)%2;(0===c?r<=s:i<=l)&&(u.push(f),u.push(g-1),u.push(m)),(0===c?o>=s:n>=l)&&(u.push(g+1),u.push(p),u.push(m));}}return h}(this.ids,this.coords,e,t,r,i,this.nodeSize)},G.prototype.within=function(e,t,r){return function(e,t,r,i,o,n){for(var a=[0,e.length-1,0],s=[],l=o*o;a.length;){var u=a.pop(),h=a.pop(),c=a.pop();if(h-c<=n)for(var p=c;p<=h;p++)J(t[2*p],t[2*p+1],r,i)<=l&&s.push(e[p]);else{var f=Math.floor((c+h)/2),d=t[2*f],g=t[2*f+1];J(d,g,r,i)<=l&&s.push(e[f]);var m=(u+1)%2;(0===u?r-o<=d:i-o<=g)&&(a.push(c),a.push(f-1),a.push(m)),(0===u?r+o>=d:i+o>=g)&&(a.push(f+1),a.push(h),a.push(m));}}return s}(this.ids,this.coords,e,t,r,this.nodeSize)};var Y={minZoom:0,maxZoom:16,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:function(e){return e}},R=function(e){this.options=$(Object.create(Y),e),this.trees=new Array(this.options.maxZoom+1);};function j(e,t,r,i,o){return {x:e,y:t,zoom:1/0,id:r,parentId:-1,numPoints:i,properties:o}}function V(e,t){var r=e.geometry.coordinates,i=r[1];return {x:q(r[0]),y:U(i),zoom:1/0,index:t,parentId:-1}}function X(e){return {type:"Feature",id:e.id,properties:W(e),geometry:{type:"Point",coordinates:[(i=e.x,360*(i-.5)),(t=e.y,r=(180-360*t)*Math.PI/180,360*Math.atan(Math.exp(r))/Math.PI-90)]}};var t,r,i;}function W(e){var t=e.numPoints,r=t>=1e4?Math.round(t/1e3)+"k":t>=1e3?Math.round(t/100)/10+"k":t;return $($({},e.properties),{cluster:!0,cluster_id:e.id,point_count:t,point_count_abbreviated:r})}function q(e){return e/360+.5}function U(e){var t=Math.sin(e*Math.PI/180),r=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return r<0?0:r>1?1:r}function $(e,t){for(var r in t)e[r]=t[r];return e}function H(e){return e.x}function K(e){return e.y}function Q(e,t,r,i,o,n){var a=o-r,s=n-i;if(0!==a||0!==s){var l=((e-r)*a+(t-i)*s)/(a*a+s*s);l>1?(r=o,i=n):l>0&&(r+=a*l,i+=s*l);}return (a=e-r)*a+(s=t-i)*s}function ee(e,t,r,i){var o={id:void 0===e?null:e,type:t,geometry:r,tags:i,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0};return function(e){var t=e.geometry,r=e.type;if("Point"===r||"MultiPoint"===r||"LineString"===r)te(e,t);else if("Polygon"===r||"MultiLineString"===r)for(var i=0;i<t.length;i++)te(e,t[i]);else if("MultiPolygon"===r)for(i=0;i<t.length;i++)for(var o=0;o<t[i].length;o++)te(e,t[i][o]);}(o),o}function te(e,t){for(var r=0;r<t.length;r+=3)e.minX=Math.min(e.minX,t[r]),e.minY=Math.min(e.minY,t[r+1]),e.maxX=Math.max(e.maxX,t[r]),e.maxY=Math.max(e.maxY,t[r+1]);}function re(e,t,r,i){if(t.geometry){var o=t.geometry.coordinates,n=t.geometry.type,a=Math.pow(r.tolerance/((1<<r.maxZoom)*r.extent),2),s=[],l=t.id;if(r.promoteId?l=t.properties[r.promoteId]:r.generateId&&(l=i||0),"Point"===n)ie(o,s);else if("MultiPoint"===n)for(var u=0;u<o.length;u++)ie(o[u],s);else if("LineString"===n)oe(o,s,a,!1);else if("MultiLineString"===n){if(r.lineMetrics){for(u=0;u<o.length;u++)oe(o[u],s=[],a,!1),e.push(ee(l,"LineString",s,t.properties));return}ne(o,s,a,!1);}else if("Polygon"===n)ne(o,s,a,!0);else{if("MultiPolygon"!==n){if("GeometryCollection"===n){for(u=0;u<t.geometry.geometries.length;u++)re(e,{id:l,geometry:t.geometry.geometries[u],properties:t.properties},r,i);return}throw new Error("Input data is not a valid GeoJSON object.")}for(u=0;u<o.length;u++){var h=[];ne(o[u],h,a,!0),s.push(h);}}e.push(ee(l,n,s,t.properties));}}function ie(e,t){t.push(ae(e[0])),t.push(se(e[1])),t.push(0);}function oe(e,t,r,i){for(var o,n,a=0,s=0;s<e.length;s++){var l=ae(e[s][0]),u=se(e[s][1]);t.push(l),t.push(u),t.push(0),s>0&&(a+=i?(o*u-l*n)/2:Math.sqrt(Math.pow(l-o,2)+Math.pow(u-n,2))),o=l,n=u;}var h=t.length-3;t[2]=1,function e(t,r,i,o){for(var n,a=o,s=i-r>>1,l=i-r,u=t[r],h=t[r+1],c=t[i],p=t[i+1],f=r+3;f<i;f+=3){var d=Q(t[f],t[f+1],u,h,c,p);if(d>a)n=f,a=d;else if(d===a){var g=Math.abs(f-s);g<l&&(n=f,l=g);}}a>o&&(n-r>3&&e(t,r,n,o),t[n+2]=a,i-n>3&&e(t,n,i,o));}(t,0,h,r),t[h+2]=1,t.size=Math.abs(a),t.start=0,t.end=t.size;}function ne(e,t,r,i){for(var o=0;o<e.length;o++){var n=[];oe(e[o],n,r,i),t.push(n);}}function ae(e){return e/360+.5}function se(e){var t=Math.sin(e*Math.PI/180),r=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return r<0?0:r>1?1:r}function le(e,t,r,i,o,n,a,s){if(i/=t,n>=(r/=t)&&a<i)return e;if(a<r||n>=i)return null;for(var l=[],u=0;u<e.length;u++){var h=e[u],c=h.geometry,p=h.type,f=0===o?h.minX:h.minY,d=0===o?h.maxX:h.maxY;if(f>=r&&d<i)l.push(h);else if(!(d<r||f>=i)){var g=[];if("Point"===p||"MultiPoint"===p)ue(c,g,r,i,o);else if("LineString"===p)he(c,g,r,i,o,!1,s.lineMetrics);else if("MultiLineString"===p)pe(c,g,r,i,o,!1);else if("Polygon"===p)pe(c,g,r,i,o,!0);else if("MultiPolygon"===p)for(var m=0;m<c.length;m++){var v=[];pe(c[m],v,r,i,o,!0),v.length&&g.push(v);}if(g.length){if(s.lineMetrics&&"LineString"===p){for(m=0;m<g.length;m++)l.push(ee(h.id,p,g[m],h.tags));continue}"LineString"!==p&&"MultiLineString"!==p||(1===g.length?(p="LineString",g=g[0]):p="MultiLineString"),"Point"!==p&&"MultiPoint"!==p||(p=3===g.length?"Point":"MultiPoint"),l.push(ee(h.id,p,g,h.tags));}}}return l.length?l:null}function ue(e,t,r,i,o){for(var n=0;n<e.length;n+=3){var a=e[n+o];a>=r&&a<=i&&(t.push(e[n]),t.push(e[n+1]),t.push(e[n+2]));}}function he(e,t,r,i,o,n,a){for(var s,l,u=ce(e),h=0===o?de:ge,c=e.start,p=0;p<e.length-3;p+=3){var f=e[p],d=e[p+1],g=e[p+2],m=e[p+3],v=e[p+4],y=0===o?f:d,x=0===o?m:v,w=!1;a&&(s=Math.sqrt(Math.pow(f-m,2)+Math.pow(d-v,2))),y<r?x>r&&(l=h(u,f,d,m,v,r),a&&(u.start=c+s*l)):y>i?x<i&&(l=h(u,f,d,m,v,i),a&&(u.start=c+s*l)):fe(u,f,d,g),x<r&&y>=r&&(l=h(u,f,d,m,v,r),w=!0),x>i&&y<=i&&(l=h(u,f,d,m,v,i),w=!0),!n&&w&&(a&&(u.end=c+s*l),t.push(u),u=ce(e)),a&&(c+=s);}var S=e.length-3;f=e[S],d=e[S+1],g=e[S+2],(y=0===o?f:d)>=r&&y<=i&&fe(u,f,d,g),S=u.length-3,n&&S>=3&&(u[S]!==u[0]||u[S+1]!==u[1])&&fe(u,u[0],u[1],u[2]),u.length&&t.push(u);}function ce(e){var t=[];return t.size=e.size,t.start=e.start,t.end=e.end,t}function pe(e,t,r,i,o,n){for(var a=0;a<e.length;a++)he(e[a],t,r,i,o,n,!1);}function fe(e,t,r,i){e.push(t),e.push(r),e.push(i);}function de(e,t,r,i,o,n){var a=(n-t)/(i-t);return e.push(n),e.push(r+(o-r)*a),e.push(1),a}function ge(e,t,r,i,o,n){var a=(n-r)/(o-r);return e.push(t+(i-t)*a),e.push(n),e.push(1),a}function me(e,t){for(var r=[],i=0;i<e.length;i++){var o,n=e[i],a=n.type;if("Point"===a||"MultiPoint"===a||"LineString"===a)o=ve(n.geometry,t);else if("MultiLineString"===a||"Polygon"===a){o=[];for(var s=0;s<n.geometry.length;s++)o.push(ve(n.geometry[s],t));}else if("MultiPolygon"===a)for(o=[],s=0;s<n.geometry.length;s++){for(var l=[],u=0;u<n.geometry[s].length;u++)l.push(ve(n.geometry[s][u],t));o.push(l);}r.push(ee(n.id,a,o,n.tags));}return r}function ve(e,t){var r=[];r.size=e.size,void 0!==e.start&&(r.start=e.start,r.end=e.end);for(var i=0;i<e.length;i+=3)r.push(e[i]+t,e[i+1],e[i+2]);return r}function ye(e,t){if(e.transformed)return e;var r,i,o,n=1<<e.z,a=e.x,s=e.y;for(r=0;r<e.features.length;r++){var l=e.features[r],u=l.geometry,h=l.type;if(l.geometry=[],1===h)for(i=0;i<u.length;i+=2)l.geometry.push(xe(u[i],u[i+1],t,n,a,s));else for(i=0;i<u.length;i++){var c=[];for(o=0;o<u[i].length;o+=2)c.push(xe(u[i][o],u[i][o+1],t,n,a,s));l.geometry.push(c);}}return e.transformed=!0,e}function xe(e,t,r,i,o,n){return [Math.round(r*(e*i-o)),Math.round(r*(t*i-n))]}function we(e,t,r,i,o){for(var n=t===o.maxZoom?0:o.tolerance/((1<<t)*o.extent),a={features:[],numPoints:0,numSimplified:0,numFeatures:0,source:null,x:r,y:i,z:t,transformed:!1,minX:2,minY:1,maxX:-1,maxY:0},s=0;s<e.length;s++){a.numFeatures++,Se(a,e[s],n,o);var l=e[s].minX,u=e[s].minY,h=e[s].maxX,c=e[s].maxY;l<a.minX&&(a.minX=l),u<a.minY&&(a.minY=u),h>a.maxX&&(a.maxX=h),c>a.maxY&&(a.maxY=c);}return a}function Se(e,t,r,i){var o=t.geometry,n=t.type,a=[];if("Point"===n||"MultiPoint"===n)for(var s=0;s<o.length;s+=3)a.push(o[s]),a.push(o[s+1]),e.numPoints++,e.numSimplified++;else if("LineString"===n)Ie(a,o,e,r,!1,!1);else if("MultiLineString"===n||"Polygon"===n)for(s=0;s<o.length;s++)Ie(a,o[s],e,r,"Polygon"===n,0===s);else if("MultiPolygon"===n)for(var l=0;l<o.length;l++){var u=o[l];for(s=0;s<u.length;s++)Ie(a,u[s],e,r,!0,0===s);}if(a.length){var h=t.tags||null;if("LineString"===n&&i.lineMetrics){for(var c in h={},t.tags)h[c]=t.tags[c];h.mapbox_clip_start=o.start/o.size,h.mapbox_clip_end=o.end/o.size;}var p={geometry:a,type:"Polygon"===n||"MultiPolygon"===n?3:"LineString"===n||"MultiLineString"===n?2:1,tags:h};null!==t.id&&(p.id=t.id),e.features.push(p);}}function Ie(e,t,r,i,o,n){var a=i*i;if(i>0&&t.size<(o?a:i))r.numPoints+=t.length/3;else{for(var s=[],l=0;l<t.length;l+=3)(0===i||t[l+2]>a)&&(r.numSimplified++,s.push(t[l]),s.push(t[l+1])),r.numPoints++;o&&function(e,t){for(var r=0,i=0,o=e.length,n=o-2;i<o;n=i,i+=2)r+=(e[i]-e[n])*(e[i+1]+e[n+1]);if(r>0===t)for(i=0,o=e.length;i<o/2;i+=2){var a=e[i],s=e[i+1];e[i]=e[o-2-i],e[i+1]=e[o-1-i],e[o-2-i]=a,e[o-1-i]=s;}}(s,n),e.push(s);}}function Me(e,t){var r=(t=this.options=function(e,t){for(var r in t)e[r]=t[r];return e}(Object.create(this.options),t)).debug;if(r&&console.time("preprocess data"),t.maxZoom<0||t.maxZoom>24)throw new Error("maxZoom should be in the 0-24 range");if(t.promoteId&&t.generateId)throw new Error("promoteId and generateId cannot be used together.");var i=function(e,t){var r=[];if("FeatureCollection"===e.type)for(var i=0;i<e.features.length;i++)re(r,e.features[i],t,i);else re(r,"Feature"===e.type?e:{geometry:e},t);return r}(e,t);this.tiles={},this.tileCoords=[],r&&(console.timeEnd("preprocess data"),console.log("index: maxZoom: %d, maxPoints: %d",t.indexMaxZoom,t.indexMaxPoints),console.time("generate tiles"),this.stats={},this.total=0),(i=function(e,t){var r=t.buffer/t.extent,i=e,o=le(e,1,-1-r,r,0,-1,2,t),n=le(e,1,1-r,2+r,0,-1,2,t);return (o||n)&&(i=le(e,1,-r,1+r,0,-1,2,t)||[],o&&(i=me(o,1).concat(i)),n&&(i=i.concat(me(n,-1)))),i}(i,t)).length&&this.splitTile(i,0,0,0),r&&(i.length&&console.log("features: %d, points: %d",this.tiles[0].numFeatures,this.tiles[0].numPoints),console.timeEnd("generate tiles"),console.log("tiles generated:",this.total,JSON.stringify(this.stats)));}function be(e,t,r){return 32*((1<<e)*r+t)+e}function Pe(e,t){var r=e.tileID.canonical;if(!this._geoJSONIndex)return t(null,null);var i=this._geoJSONIndex.getTile(r.z,r.x,r.y);if(!i)return t(null,null);var o=new S(i.features),n=_(o);0===n.byteOffset&&n.byteLength===n.buffer.byteLength||(n=new Uint8Array(n)),t(null,{vectorTile:o,rawData:n.buffer});}R.prototype.load=function(e){var t=this.options,r=t.log,i=t.minZoom,o=t.maxZoom,n=t.nodeSize;r&&console.time("total time");var a="prepare "+e.length+" points";r&&console.time(a),this.points=e;for(var s=[],l=0;l<e.length;l++)e[l].geometry&&s.push(V(e[l],l));this.trees[o+1]=new G(s,H,K,n,Float32Array),r&&console.timeEnd(a);for(var u=o;u>=i;u--){var h=+Date.now();s=this._cluster(s,u),this.trees[u]=new G(s,H,K,n,Float32Array),r&&console.log("z%d: %d clusters in %dms",u,s.length,+Date.now()-h);}return r&&console.timeEnd("total time"),this},R.prototype.getClusters=function(e,t){var r=((e[0]+180)%360+360)%360-180,i=Math.max(-90,Math.min(90,e[1])),o=180===e[2]?180:((e[2]+180)%360+360)%360-180,n=Math.max(-90,Math.min(90,e[3]));if(e[2]-e[0]>=360)r=-180,o=180;else if(r>o){var a=this.getClusters([r,i,180,n],t),s=this.getClusters([-180,i,o,n],t);return a.concat(s)}for(var l=this.trees[this._limitZoom(t)],u=[],h=0,c=l.range(q(r),U(n),q(o),U(i));h<c.length;h+=1){var p=l.points[c[h]];u.push(p.numPoints?X(p):this.points[p.index]);}return u},R.prototype.getChildren=function(e){var t=this._getOriginId(e),r=this._getOriginZoom(e),i="No cluster with the specified id.",o=this.trees[r];if(!o)throw new Error(i);var n=o.points[t];if(!n)throw new Error(i);for(var a=this.options.radius/(this.options.extent*Math.pow(2,r-1)),s=[],l=0,u=o.within(n.x,n.y,a);l<u.length;l+=1){var h=o.points[u[l]];h.parentId===e&&s.push(h.numPoints?X(h):this.points[h.index]);}if(0===s.length)throw new Error(i);return s},R.prototype.getLeaves=function(e,t,r){var i=[];return this._appendLeaves(i,e,t=t||10,r=r||0,0),i},R.prototype.getTile=function(e,t,r){var i=this.trees[this._limitZoom(e)],o=Math.pow(2,e),n=this.options,a=n.radius/n.extent,s=(r-a)/o,l=(r+1+a)/o,u={features:[]};return this._addTileFeatures(i.range((t-a)/o,s,(t+1+a)/o,l),i.points,t,r,o,u),0===t&&this._addTileFeatures(i.range(1-a/o,s,1,l),i.points,o,r,o,u),t===o-1&&this._addTileFeatures(i.range(0,s,a/o,l),i.points,-1,r,o,u),u.features.length?u:null},R.prototype.getClusterExpansionZoom=function(e){for(var t=this._getOriginZoom(e)-1;t<=this.options.maxZoom;){var r=this.getChildren(e);if(t++,1!==r.length)break;e=r[0].properties.cluster_id;}return t},R.prototype._appendLeaves=function(e,t,r,i,o){for(var n=0,a=this.getChildren(t);n<a.length;n+=1){var s=a[n],l=s.properties;if(l&&l.cluster?o+l.point_count<=i?o+=l.point_count:o=this._appendLeaves(e,l.cluster_id,r,i,o):o<i?o++:e.push(s),e.length===r)break}return o},R.prototype._addTileFeatures=function(e,t,r,i,o,n){for(var a=0,s=e;a<s.length;a+=1){var l=t[s[a]],u=l.numPoints,h={type:1,geometry:[[Math.round(this.options.extent*(l.x*o-r)),Math.round(this.options.extent*(l.y*o-i))]],tags:u?W(l):this.points[l.index].properties},c=void 0;u?c=l.id:this.options.generateId?c=l.index:this.points[l.index].id&&(c=this.points[l.index].id),void 0!==c&&(h.id=c),n.features.push(h);}},R.prototype._limitZoom=function(e){return Math.max(this.options.minZoom,Math.min(e,this.options.maxZoom+1))},R.prototype._cluster=function(e,t){for(var r=[],i=this.options,o=i.reduce,n=i.radius/(i.extent*Math.pow(2,t)),a=0;a<e.length;a++){var s=e[a];if(!(s.zoom<=t)){s.zoom=t;for(var l=this.trees[t+1],u=l.within(s.x,s.y,n),h=s.numPoints||1,c=s.x*h,p=s.y*h,f=o&&h>1?this._map(s,!0):null,d=(a<<5)+(t+1)+this.points.length,g=0,m=u;g<m.length;g+=1){var v=l.points[m[g]];if(!(v.zoom<=t)){v.zoom=t;var y=v.numPoints||1;c+=v.x*y,p+=v.y*y,h+=y,v.parentId=d,o&&(f||(f=this._map(s,!0)),o(f,this._map(v)));}}1===h?r.push(s):(s.parentId=d,r.push(j(c/h,p/h,d,h,f)));}}return r},R.prototype._getOriginId=function(e){return e-this.points.length>>5},R.prototype._getOriginZoom=function(e){return (e-this.points.length)%32},R.prototype._map=function(e,t){if(e.numPoints)return t?$({},e.properties):e.properties;var r=this.points[e.index].properties,i=this.options.map(r);return t&&i===r?$({},i):i},Me.prototype.options={maxZoom:14,indexMaxZoom:5,indexMaxPoints:1e5,tolerance:3,extent:4096,buffer:64,lineMetrics:!1,promoteId:null,generateId:!1,debug:0},Me.prototype.splitTile=function(e,t,r,i,o,n,a){for(var s=[e,t,r,i],l=this.options,u=l.debug;s.length;){i=s.pop(),r=s.pop(),t=s.pop(),e=s.pop();var h=1<<t,c=be(t,r,i),p=this.tiles[c];if(!p&&(u>1&&console.time("creation"),p=this.tiles[c]=we(e,t,r,i,l),this.tileCoords.push({z:t,x:r,y:i}),u)){u>1&&(console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",t,r,i,p.numFeatures,p.numPoints,p.numSimplified),console.timeEnd("creation"));var f="z"+t;this.stats[f]=(this.stats[f]||0)+1,this.total++;}if(p.source=e,o){if(t===l.maxZoom||t===o)continue;var d=1<<o-t;if(r!==Math.floor(n/d)||i!==Math.floor(a/d))continue}else if(t===l.indexMaxZoom||p.numPoints<=l.indexMaxPoints)continue;if(p.source=null,0!==e.length){u>1&&console.time("clipping");var g,m,v,y,x,w,S=.5*l.buffer/l.extent,I=.5-S,M=.5+S,b=1+S;g=m=v=y=null,x=le(e,h,r-S,r+M,0,p.minX,p.maxX,l),w=le(e,h,r+I,r+b,0,p.minX,p.maxX,l),e=null,x&&(g=le(x,h,i-S,i+M,1,p.minY,p.maxY,l),m=le(x,h,i+I,i+b,1,p.minY,p.maxY,l),x=null),w&&(v=le(w,h,i-S,i+M,1,p.minY,p.maxY,l),y=le(w,h,i+I,i+b,1,p.minY,p.maxY,l),w=null),u>1&&console.timeEnd("clipping"),s.push(g||[],t+1,2*r,2*i),s.push(m||[],t+1,2*r,2*i+1),s.push(v||[],t+1,2*r+1,2*i),s.push(y||[],t+1,2*r+1,2*i+1);}}},Me.prototype.getTile=function(e,t,r){var i=this.options,o=i.extent,n=i.debug;if(e<0||e>24)return null;var a=1<<e,s=be(e,t=(t%a+a)%a,r);if(this.tiles[s])return ye(this.tiles[s],o);n>1&&console.log("drilling down to z%d-%d-%d",e,t,r);for(var l,u=e,h=t,c=r;!l&&u>0;)u--,h=Math.floor(h/2),c=Math.floor(c/2),l=this.tiles[be(u,h,c)];return l&&l.source?(n>1&&console.log("found parent tile z%d-%d-%d",u,h,c),n>1&&console.time("drilling down"),this.splitTile(l.source,u,h,c,e,t,r),n>1&&console.timeEnd("drilling down"),this.tiles[s]?ye(this.tiles[s],o):null):null};var _e=function(t){function r(e,r,i,o){t.call(this,e,r,i,Pe),o&&(this.loadGeoJSON=o);}return t&&(r.__proto__=t),(r.prototype=Object.create(t&&t.prototype)).constructor=r,r.prototype.loadData=function(e,t){this._pendingCallback&&this._pendingCallback(null,{abandoned:!0}),this._pendingCallback=t,this._pendingLoadDataParams=e,this._state&&"Idle"!==this._state?this._state="NeedsLoadData":(this._state="Coalescing",this._loadData());},r.prototype._loadData=function(){var t=this;if(this._pendingCallback&&this._pendingLoadDataParams){var r=this._pendingCallback,i=this._pendingLoadDataParams;delete this._pendingCallback,delete this._pendingLoadDataParams;var o=!!(i&&i.request&&i.request.collectResourceTiming)&&new e.RequestPerformance(i.request);this.loadGeoJSON(i,(function(n,a){if(n||!a)return r(n);if("object"!=typeof a)return r(new Error("Input data given to '"+i.source+"' is not a valid GeoJSON object."));!function e(t,r){switch(t&&t.type||null){case"FeatureCollection":return t.features=t.features.map(m(e,r)),t;case"GeometryCollection":return t.geometries=t.geometries.map(m(e,r)),t;case"Feature":return t.geometry=e(t.geometry,r),t;case"Polygon":case"MultiPolygon":return function(e,t){return "Polygon"===e.type?e.coordinates=v(e.coordinates,t):"MultiPolygon"===e.type&&(e.coordinates=e.coordinates.map(m(v,t))),e}(t,r);default:return t}}(a,!0);try{t._geoJSONIndex=i.cluster?new R(function(t){var r=t.superclusterOptions,i=t.clusterProperties;if(!i||!r)return r;for(var o={},n={},a={accumulated:null,zoom:0},s={properties:null},l=Object.keys(i),u=0,h=l;u<h.length;u+=1){var c=h[u],p=i[c],f=p[0],d=e.createExpression(p[1]),g=e.createExpression("string"==typeof f?[f,["accumulated"],["get",c]]:f);o[c]=d.value,n[c]=g.value;}return r.map=function(e){s.properties=e;for(var t={},r=0,i=l;r<i.length;r+=1){var n=i[r];t[n]=o[n].evaluate(a,s);}return t},r.reduce=function(e,t){s.properties=t;for(var r=0,i=l;r<i.length;r+=1){var o=i[r];a.accumulated=e[o],e[o]=n[o].evaluate(a,s);}},r}(i)).load(a.features):function(e,t){return new Me(e,t)}(a,i.geojsonVtOptions);}catch(n){return r(n)}t.loaded={};var s={};if(o){var l=o.finish();l&&(s.resourceTiming={},s.resourceTiming[i.source]=JSON.parse(JSON.stringify(l)));}r(null,s);}));}},r.prototype.coalesce=function(){"Coalescing"===this._state?this._state="Idle":"NeedsLoadData"===this._state&&(this._state="Coalescing",this._loadData());},r.prototype.reloadTile=function(e,r){var i=this.loaded;return i&&i[e.uid]?t.prototype.reloadTile.call(this,e,r):this.loadTile(e,r)},r.prototype.loadGeoJSON=function(t,r){if(t.request)e.getJSON(t.request,r);else{if("string"!=typeof t.data)return r(new Error("Input data given to '"+t.source+"' is not a valid GeoJSON object."));try{return r(null,JSON.parse(t.data))}catch(e){return r(new Error("Input data given to '"+t.source+"' is not a valid GeoJSON object."))}}},r.prototype.removeSource=function(e,t){this._pendingCallback&&this._pendingCallback(null,{abandoned:!0}),t();},r.prototype.getClusterExpansionZoom=function(e,t){try{t(null,this._geoJSONIndex.getClusterExpansionZoom(e.clusterId));}catch(e){t(e);}},r.prototype.getClusterChildren=function(e,t){try{t(null,this._geoJSONIndex.getChildren(e.clusterId));}catch(e){t(e);}},r.prototype.getClusterLeaves=function(e,t){try{t(null,this._geoJSONIndex.getLeaves(e.clusterId,e.limit,e.offset));}catch(e){t(e);}},r}(l),ke=function(t){var r=this;this.self=t,this.actor=new e.Actor(t,this),this.layerIndexes={},this.availableImages={},this.workerSourceTypes={vector:l,geojson:_e},this.workerSources={},this.demWorkerSources={},this.self.registerWorkerSource=function(e,t){if(r.workerSourceTypes[e])throw new Error('Worker source with name "'+e+'" already registered.');r.workerSourceTypes[e]=t;},this.self.registerRTLTextPlugin=function(t){if(e.plugin.isParsed())throw new Error("RTL text plugin already registered.");e.plugin.applyArabicShaping=t.applyArabicShaping,e.plugin.processBidirectionalText=t.processBidirectionalText,e.plugin.processStyledBidirectionalText=t.processStyledBidirectionalText;};};return ke.prototype.setReferrer=function(e,t){this.referrer=t;},ke.prototype.setImages=function(e,t,r){this.availableImages[e]=t,r();},ke.prototype.setLayers=function(e,t,r){this.getLayerIndex(e).replace(t),r();},ke.prototype.updateLayers=function(e,t,r){this.getLayerIndex(e).update(t.layers,t.removedIds),r();},ke.prototype.loadTile=function(e,t,r){this.getWorkerSource(e,t.type,t.source).loadTile(t,r);},ke.prototype.loadDEMTile=function(e,t,r){this.getDEMWorkerSource(e,t.source).loadTile(t,r);},ke.prototype.reloadTile=function(e,t,r){this.getWorkerSource(e,t.type,t.source).reloadTile(t,r);},ke.prototype.abortTile=function(e,t,r){this.getWorkerSource(e,t.type,t.source).abortTile(t,r);},ke.prototype.removeTile=function(e,t,r){this.getWorkerSource(e,t.type,t.source).removeTile(t,r);},ke.prototype.removeDEMTile=function(e,t){this.getDEMWorkerSource(e,t.source).removeTile(t);},ke.prototype.removeSource=function(e,t,r){if(this.workerSources[e]&&this.workerSources[e][t.type]&&this.workerSources[e][t.type][t.source]){var i=this.workerSources[e][t.type][t.source];delete this.workerSources[e][t.type][t.source],void 0!==i.removeSource?i.removeSource(t,r):r();}},ke.prototype.loadWorkerSource=function(e,t,r){try{this.self.importScripts(t.url),r();}catch(e){r(e.toString());}},ke.prototype.syncRTLPluginState=function(t,r,i){try{e.plugin.setState(r);var o=e.plugin.getPluginURL();if(e.plugin.isLoaded()&&!e.plugin.isParsed()&&null!=o){this.self.importScripts(o);var n=e.plugin.isParsed();i(n?void 0:new Error("RTL Text Plugin failed to import scripts from "+o),n);}}catch(e){i(e.toString());}},ke.prototype.getAvailableImages=function(e){var t=this.availableImages[e];return t||(t=[]),t},ke.prototype.getLayerIndex=function(e){var t=this.layerIndexes[e];return t||(t=this.layerIndexes[e]=new i),t},ke.prototype.getWorkerSource=function(e,t,r){var i=this;return this.workerSources[e]||(this.workerSources[e]={}),this.workerSources[e][t]||(this.workerSources[e][t]={}),this.workerSources[e][t][r]||(this.workerSources[e][t][r]=new this.workerSourceTypes[t]({send:function(t,r,o){i.actor.send(t,r,o,e);}},this.getLayerIndex(e),this.getAvailableImages(e))),this.workerSources[e][t][r]},ke.prototype.getDEMWorkerSource=function(e,t){return this.demWorkerSources[e]||(this.demWorkerSources[e]={}),this.demWorkerSources[e][t]||(this.demWorkerSources[e][t]=new h),this.demWorkerSources[e][t]},ke.prototype.enforceCacheSizeLimit=function(t,r){e.enforceCacheSizeLimit(r);},"undefined"!=typeof WorkerGlobalScope&&void 0!==e.window&&e.window instanceof WorkerGlobalScope&&(e.window.worker=new ke(e.window)),ke}));

define(["./shared"],(function(t){"use strict";var e=t.createCommonjsModule((function(t){function e(t){return !!("undefined"!=typeof window&&"undefined"!=typeof document&&Array.prototype&&Array.prototype.every&&Array.prototype.filter&&Array.prototype.forEach&&Array.prototype.indexOf&&Array.prototype.lastIndexOf&&Array.prototype.map&&Array.prototype.some&&Array.prototype.reduce&&Array.prototype.reduceRight&&Array.isArray&&Function.prototype&&Function.prototype.bind&&Object.keys&&Object.create&&Object.getPrototypeOf&&Object.getOwnPropertyNames&&Object.isSealed&&Object.isFrozen&&Object.isExtensible&&Object.getOwnPropertyDescriptor&&Object.defineProperty&&Object.defineProperties&&Object.seal&&Object.freeze&&Object.preventExtensions&&"JSON"in window&&"parse"in JSON&&"stringify"in JSON&&function(){if(!("Worker"in window&&"Blob"in window&&"URL"in window))return !1;var t,e,i=new Blob([""],{type:"text/javascript"}),o=URL.createObjectURL(i);try{e=new Worker(o),t=!0;}catch(e){t=!1;}return e&&e.terminate(),URL.revokeObjectURL(o),t}()&&"Uint8ClampedArray"in window&&ArrayBuffer.isView&&(o=t&&t.failIfMajorPerformanceCaveat,void 0===i[o]&&(i[o]=function(t){var i=document.createElement("canvas"),o=Object.create(e.webGLContextAttributes);return o.failIfMajorPerformanceCaveat=t,i.probablySupportsContext?i.probablySupportsContext("webgl",o)||i.probablySupportsContext("experimental-webgl",o):i.supportsContext?i.supportsContext("webgl",o)||i.supportsContext("experimental-webgl",o):i.getContext("webgl",o)||i.getContext("experimental-webgl",o)}(o)),i[o]));var o;}t.exports?t.exports=e:window&&(window.mapboxgl=window.mapboxgl||{},window.mapboxgl.supported=e);var i={};e.webGLContextAttributes={antialias:!1,alpha:!0,stencil:!0,depth:!0};})),i={create:function(e,i,o){var r=t.window.document.createElement(e);return void 0!==i&&(r.className=i),o&&o.appendChild(r),r},createNS:function(e,i){return t.window.document.createElementNS(e,i)}},o=t.window.document.documentElement.style;function r(t){if(!o)return t[0];for(var e=0;e<t.length;e++)if(t[e]in o)return t[e];return t[0]}var a,n=r(["userSelect","MozUserSelect","WebkitUserSelect","msUserSelect"]);i.disableDrag=function(){o&&n&&(a=o[n],o[n]="none");},i.enableDrag=function(){o&&n&&(o[n]=a);};var s=r(["transform","WebkitTransform"]);i.setTransform=function(t,e){t.style[s]=e;};var l=!1;try{var c=Object.defineProperty({},"passive",{get:function(){l=!0;}});t.window.addEventListener("test",c,c),t.window.removeEventListener("test",c,c);}catch(t){l=!1;}i.addEventListener=function(t,e,i,o){void 0===o&&(o={}),t.addEventListener(e,i,"passive"in o&&l?o:o.capture);},i.removeEventListener=function(t,e,i,o){void 0===o&&(o={}),t.removeEventListener(e,i,"passive"in o&&l?o:o.capture);};var u=function(e){e.preventDefault(),e.stopPropagation(),t.window.removeEventListener("click",u,!0);};function h(t){var e=t.userImage;return !!(e&&e.render&&e.render())&&(t.data.replace(new Uint8Array(e.data.buffer)),!0)}i.suppressClick=function(){t.window.addEventListener("click",u,!0),t.window.setTimeout((function(){t.window.removeEventListener("click",u,!0);}),0);},i.mousePos=function(e,i){var o=e.getBoundingClientRect(),r=t.window.TouchEvent&&i instanceof t.window.TouchEvent?i.touches[0]:i;return new t.Point(r.clientX-o.left-e.clientLeft,r.clientY-o.top-e.clientTop)},i.touchPos=function(e,i){for(var o=e.getBoundingClientRect(),r=[],a="touchend"===i.type?i.changedTouches:i.touches,n=0;n<a.length;n++)r.push(new t.Point(a[n].clientX-o.left-e.clientLeft,a[n].clientY-o.top-e.clientTop));return r},i.mouseButton=function(e){return void 0!==t.window.InstallTrigger&&2===e.button&&e.ctrlKey&&t.window.navigator.platform.toUpperCase().indexOf("MAC")>=0?0:e.button},i.remove=function(t){t.parentNode&&t.parentNode.removeChild(t);};var p=function(e){function i(){e.call(this),this.images={},this.updatedImages={},this.callbackDispatchedThisFrame={},this.loaded=!1,this.requestors=[],this.patterns={},this.atlasImage=new t.RGBAImage({width:1,height:1}),this.dirty=!0;}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.isLoaded=function(){return this.loaded},i.prototype.setLoaded=function(t){if(this.loaded!==t&&(this.loaded=t,t)){for(var e=0,i=this.requestors;e<i.length;e+=1){var o=i[e];this._notify(o.ids,o.callback);}this.requestors=[];}},i.prototype.getImage=function(t){return this.images[t]},i.prototype.addImage=function(t,e){this._validate(t,e)&&(this.images[t]=e);},i.prototype._validate=function(e,i){var o=!0;return this._validateStretch(i.stretchX,i.data&&i.data.width)||(this.fire(new t.ErrorEvent(new Error('Image "'+e+'" has invalid "stretchX" value'))),o=!1),this._validateStretch(i.stretchY,i.data&&i.data.height)||(this.fire(new t.ErrorEvent(new Error('Image "'+e+'" has invalid "stretchY" value'))),o=!1),this._validateContent(i.content,i)||(this.fire(new t.ErrorEvent(new Error('Image "'+e+'" has invalid "content" value'))),o=!1),o},i.prototype._validateStretch=function(t,e){if(!t)return !0;for(var i=0,o=0,r=t;o<r.length;o+=1){var a=r[o];if(a[0]<i||a[1]<a[0]||e<a[1])return !1;i=a[1];}return !0},i.prototype._validateContent=function(t,e){return !(t&&(4!==t.length||t[0]<0||e.data.width<t[0]||t[1]<0||e.data.height<t[1]||t[2]<0||e.data.width<t[2]||t[3]<0||e.data.height<t[3]||t[2]<t[0]||t[3]<t[1]))},i.prototype.updateImage=function(t,e){e.version=this.images[t].version+1,this.images[t]=e,this.updatedImages[t]=!0;},i.prototype.removeImage=function(t){var e=this.images[t];delete this.images[t],delete this.patterns[t],e.userImage&&e.userImage.onRemove&&e.userImage.onRemove();},i.prototype.listImages=function(){return Object.keys(this.images)},i.prototype.getImages=function(t,e){var i=!0;if(!this.isLoaded())for(var o=0,r=t;o<r.length;o+=1)this.images[r[o]]||(i=!1);this.isLoaded()||i?this._notify(t,e):this.requestors.push({ids:t,callback:e});},i.prototype._notify=function(e,i){for(var o={},r=0,a=e;r<a.length;r+=1){var n=a[r];this.images[n]||this.fire(new t.Event("styleimagemissing",{id:n}));var s=this.images[n];s?o[n]={data:s.data.clone(),pixelRatio:s.pixelRatio,sdf:s.sdf,version:s.version,stretchX:s.stretchX,stretchY:s.stretchY,content:s.content,hasRenderCallback:Boolean(s.userImage&&s.userImage.render)}:t.warnOnce('Image "'+n+'" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.');}i(null,o);},i.prototype.getPixelSize=function(){var t=this.atlasImage;return {width:t.width,height:t.height}},i.prototype.getPattern=function(e){var i=this.patterns[e],o=this.getImage(e);if(!o)return null;if(i&&i.position.version===o.version)return i.position;if(i)i.position.version=o.version;else{var r={w:o.data.width+2,h:o.data.height+2,x:0,y:0},a=new t.ImagePosition(r,o);this.patterns[e]={bin:r,position:a};}return this._updatePatternAtlas(),this.patterns[e].position},i.prototype.bind=function(e){var i=e.gl;this.atlasTexture?this.dirty&&(this.atlasTexture.update(this.atlasImage),this.dirty=!1):this.atlasTexture=new t.Texture(e,this.atlasImage,i.RGBA),this.atlasTexture.bind(i.LINEAR,i.CLAMP_TO_EDGE);},i.prototype._updatePatternAtlas=function(){var e=[];for(var i in this.patterns)e.push(this.patterns[i].bin);var o=t.potpack(e),r=o.w,a=o.h,n=this.atlasImage;for(var s in n.resize({width:r||1,height:a||1}),this.patterns){var l=this.patterns[s].bin,c=l.x+1,u=l.y+1,h=this.images[s].data,p=h.width,d=h.height;t.RGBAImage.copy(h,n,{x:0,y:0},{x:c,y:u},{width:p,height:d}),t.RGBAImage.copy(h,n,{x:0,y:d-1},{x:c,y:u-1},{width:p,height:1}),t.RGBAImage.copy(h,n,{x:0,y:0},{x:c,y:u+d},{width:p,height:1}),t.RGBAImage.copy(h,n,{x:p-1,y:0},{x:c-1,y:u},{width:1,height:d}),t.RGBAImage.copy(h,n,{x:0,y:0},{x:c+p,y:u},{width:1,height:d});}this.dirty=!0;},i.prototype.beginFrame=function(){this.callbackDispatchedThisFrame={};},i.prototype.dispatchRenderCallbacks=function(t){for(var e=0,i=t;e<i.length;e+=1){var o=i[e];if(!this.callbackDispatchedThisFrame[o]){this.callbackDispatchedThisFrame[o]=!0;var r=this.images[o];h(r)&&this.updateImage(o,r);}}},i}(t.Evented),d=m,_=m,f=1e20;function m(t,e,i,o,r,a){this.fontSize=t||24,this.buffer=void 0===e?3:e,this.cutoff=o||.25,this.fontFamily=r||"sans-serif",this.fontWeight=a||"normal",this.radius=i||8;var n=this.size=this.fontSize+2*this.buffer;this.canvas=document.createElement("canvas"),this.canvas.width=this.canvas.height=n,this.ctx=this.canvas.getContext("2d"),this.ctx.font=this.fontWeight+" "+this.fontSize+"px "+this.fontFamily,this.ctx.textBaseline="middle",this.ctx.fillStyle="black",this.gridOuter=new Float64Array(n*n),this.gridInner=new Float64Array(n*n),this.f=new Float64Array(n),this.d=new Float64Array(n),this.z=new Float64Array(n+1),this.v=new Int16Array(n),this.middle=Math.round(n/2*(navigator.userAgent.indexOf("Gecko/")>=0?1.2:1));}function g(t,e,i,o,r,a,n){for(var s=0;s<e;s++){for(var l=0;l<i;l++)o[l]=t[l*e+s];for(v(o,r,a,n,i),l=0;l<i;l++)t[l*e+s]=r[l];}for(l=0;l<i;l++){for(s=0;s<e;s++)o[s]=t[l*e+s];for(v(o,r,a,n,e),s=0;s<e;s++)t[l*e+s]=Math.sqrt(r[s]);}}function v(t,e,i,o,r){i[0]=0,o[0]=-f,o[1]=+f;for(var a=1,n=0;a<r;a++){for(var s=(t[a]+a*a-(t[i[n]]+i[n]*i[n]))/(2*a-2*i[n]);s<=o[n];)s=(t[a]+a*a-(t[i[--n]]+i[n]*i[n]))/(2*a-2*i[n]);i[++n]=a,o[n]=s,o[n+1]=+f;}for(a=0,n=0;a<r;a++){for(;o[n+1]<a;)n++;e[a]=(a-i[n])*(a-i[n])+t[i[n]];}}m.prototype.draw=function(t){this.ctx.clearRect(0,0,this.size,this.size),this.ctx.fillText(t,this.buffer,this.middle);for(var e=this.ctx.getImageData(0,0,this.size,this.size),i=new Uint8ClampedArray(this.size*this.size),o=0;o<this.size*this.size;o++){var r=e.data[4*o+3]/255;this.gridOuter[o]=1===r?0:0===r?f:Math.pow(Math.max(0,.5-r),2),this.gridInner[o]=1===r?f:0===r?0:Math.pow(Math.max(0,r-.5),2);}for(g(this.gridOuter,this.size,this.size,this.f,this.d,this.v,this.z),g(this.gridInner,this.size,this.size,this.f,this.d,this.v,this.z),o=0;o<this.size*this.size;o++)i[o]=Math.max(0,Math.min(255,Math.round(255-255*((this.gridOuter[o]-this.gridInner[o])/this.radius+this.cutoff))));return i},d.default=_;var y=function(t,e){this.requestManager=t,this.localIdeographFontFamily=e,this.entries={};};y.prototype.setURL=function(t){this.url=t;},y.prototype.getGlyphs=function(e,i){var o=this,r=[];for(var a in e)for(var n=0,s=e[a];n<s.length;n+=1)r.push({stack:a,id:s[n]});t.asyncAll(r,(function(t,e){var i=t.stack,r=t.id,a=o.entries[i];a||(a=o.entries[i]={glyphs:{},requests:{}});var n=a.glyphs[r];if(void 0===n){if(n=o._tinySDF(a,i,r))return a.glyphs[r]=n,void e(null,{stack:i,id:r,glyph:n});var s=Math.floor(r/256);if(256*s>65535)e(new Error("glyphs > 65535 not supported"));else{var l=a.requests[s];l||(l=a.requests[s]=[],y.loadGlyphRange(i,s,o.url,o.requestManager,(function(t,e){if(e)for(var i in e)o._doesCharSupportLocalGlyph(+i)||(a.glyphs[+i]=e[+i]);for(var r=0,n=l;r<n.length;r+=1)(0,n[r])(t,e);delete a.requests[s];}))),l.push((function(t,o){t?e(t):o&&e(null,{stack:i,id:r,glyph:o[r]||null});}));}}else e(null,{stack:i,id:r,glyph:n});}),(function(t,e){if(t)i(t);else if(e){for(var o={},r=0,a=e;r<a.length;r+=1){var n=a[r],s=n.stack,l=n.id,c=n.glyph;(o[s]||(o[s]={}))[l]=c&&{id:c.id,bitmap:c.bitmap.clone(),metrics:c.metrics};}i(null,o);}}));},y.prototype._doesCharSupportLocalGlyph=function(e){return !!this.localIdeographFontFamily&&(t.isChar["CJK Unified Ideographs"](e)||t.isChar["Hangul Syllables"](e)||t.isChar.Hiragana(e)||t.isChar.Katakana(e))},y.prototype._tinySDF=function(e,i,o){var r=this.localIdeographFontFamily;if(r&&this._doesCharSupportLocalGlyph(o)){var a=e.tinySDF;if(!a){var n="400";/bold/i.test(i)?n="900":/medium/i.test(i)?n="500":/light/i.test(i)&&(n="200"),a=e.tinySDF=new y.TinySDF(24,3,8,.25,r,n);}return {id:o,bitmap:new t.AlphaImage({width:30,height:30},a.draw(String.fromCharCode(o))),metrics:{width:24,height:24,left:0,top:-8,advance:24}}}},y.loadGlyphRange=function(e,i,o,r,a){var n=256*i,s=n+255,l=r.transformRequest(r.normalizeGlyphsURL(o).replace("{fontstack}",e).replace("{range}",n+"-"+s),t.ResourceType.Glyphs);t.getArrayBuffer(l,(function(e,i){if(e)a(e);else if(i){for(var o={},r=0,n=t.parseGlyphPBF(i);r<n.length;r+=1){var s=n[r];o[s.id]=s;}a(null,o);}}));},y.TinySDF=d;var x=function(){this.specification=t.styleSpec.light.position;};x.prototype.possiblyEvaluate=function(e,i){return t.sphericalToCartesian(e.expression.evaluate(i))},x.prototype.interpolate=function(e,i,o){return {x:t.number(e.x,i.x,o),y:t.number(e.y,i.y,o),z:t.number(e.z,i.z,o)}};var b=new t.Properties({anchor:new t.DataConstantProperty(t.styleSpec.light.anchor),position:new x,color:new t.DataConstantProperty(t.styleSpec.light.color),intensity:new t.DataConstantProperty(t.styleSpec.light.intensity)}),w=function(e){function i(i){e.call(this),this._transitionable=new t.Transitionable(b),this.setLight(i),this._transitioning=this._transitionable.untransitioned();}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.getLight=function(){return this._transitionable.serialize()},i.prototype.setLight=function(e,i){if(void 0===i&&(i={}),!this._validate(t.validateLight,e,i))for(var o in e){var r=e[o];t.endsWith(o,"-transition")?this._transitionable.setTransition(o.slice(0,-"-transition".length),r):this._transitionable.setValue(o,r);}},i.prototype.updateTransitions=function(t){this._transitioning=this._transitionable.transitioned(t,this._transitioning);},i.prototype.hasTransition=function(){return this._transitioning.hasTransition()},i.prototype.recalculate=function(t){this.properties=this._transitioning.possiblyEvaluate(t);},i.prototype._validate=function(e,i,o){return (!o||!1!==o.validate)&&t.emitValidationErrors(this,e.call(t.validateStyle,t.extend({value:i,style:{glyphs:!0,sprite:!0},styleSpec:t.styleSpec})))},i}(t.Evented),E=function(t,e){this.width=t,this.height=e,this.nextRow=0,this.data=new Uint8Array(this.width*this.height),this.dashEntry={};};E.prototype.getDash=function(t,e){var i=t.join(",")+String(e);return this.dashEntry[i]||(this.dashEntry[i]=this.addDash(t,e)),this.dashEntry[i]},E.prototype.getDashRanges=function(t,e,i){var o=[],r=t.length%2==1?-t[t.length-1]*i:0,a=t[0]*i,n=!0;o.push({left:r,right:a,isDash:n,zeroLength:0===t[0]});for(var s=t[0],l=1;l<t.length;l++){var c=t[l];o.push({left:r=s*i,right:a=(s+=c)*i,isDash:n=!n,zeroLength:0===c});}return o},E.prototype.addRoundDash=function(t,e,i){for(var o=e/2,r=-i;r<=i;r++)for(var a=this.width*(this.nextRow+i+r),n=0,s=t[n],l=0;l<this.width;l++){l/s.right>1&&(s=t[++n]);var c=Math.abs(l-s.left),u=Math.abs(l-s.right),h=Math.min(c,u),p=void 0,d=r/i*(o+1);if(s.isDash){var _=o-Math.abs(d);p=Math.sqrt(h*h+_*_);}else p=o-Math.sqrt(h*h+d*d);this.data[a+l]=Math.max(0,Math.min(255,p+128));}},E.prototype.addRegularDash=function(t){for(var e=t.length-1;e>=0;--e){var i=t[e],o=t[e+1];i.zeroLength?t.splice(e,1):o&&o.isDash===i.isDash&&(o.left=i.left,t.splice(e,1));}var r=t[0],a=t[t.length-1];r.isDash===a.isDash&&(r.left=a.left-this.width,a.right=r.right+this.width);for(var n=this.width*this.nextRow,s=0,l=t[s],c=0;c<this.width;c++){c/l.right>1&&(l=t[++s]);var u=Math.abs(c-l.left),h=Math.abs(c-l.right),p=Math.min(u,h);this.data[n+c]=Math.max(0,Math.min(255,(l.isDash?p:-p)+128));}},E.prototype.addDash=function(e,i){var o=i?7:0,r=2*o+1;if(this.nextRow+r>this.height)return t.warnOnce("LineAtlas out of space"),null;for(var a=0,n=0;n<e.length;n++)a+=e[n];if(0!==a){var s=this.width/a,l=this.getDashRanges(e,this.width,s);i?this.addRoundDash(l,s,o):this.addRegularDash(l);}var c={y:(this.nextRow+o+.5)/this.height,height:2*o/this.height,width:a};return this.nextRow+=r,this.dirty=!0,c},E.prototype.bind=function(t){var e=t.gl;this.texture?(e.bindTexture(e.TEXTURE_2D,this.texture),this.dirty&&(this.dirty=!1,e.texSubImage2D(e.TEXTURE_2D,0,0,0,this.width,this.height,e.ALPHA,e.UNSIGNED_BYTE,this.data))):(this.texture=e.createTexture(),e.bindTexture(e.TEXTURE_2D,this.texture),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.REPEAT),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.REPEAT),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texImage2D(e.TEXTURE_2D,0,e.ALPHA,this.width,this.height,0,e.ALPHA,e.UNSIGNED_BYTE,this.data));};var T=function e(i,o){this.workerPool=i,this.actors=[],this.currentActor=0,this.id=t.uniqueId();for(var r=this.workerPool.acquire(this.id),a=0;a<r.length;a++){var n=new e.Actor(r[a],o,this.id);n.name="Worker "+a,this.actors.push(n);}};function I(e,i,o){var r=function(r,a){if(r)return o(r);if(a){var n=t.pick(t.extend(a,e),["tiles","minzoom","maxzoom","attribution","mapbox_logo","bounds","scheme","tileSize","encoding"]);a.vector_layers&&(n.vectorLayers=a.vector_layers,n.vectorLayerIds=n.vectorLayers.map((function(t){return t.id}))),n.tiles=i.canonicalizeTileset(n,e.url),o(null,n);}};return e.url?t.getJSON(i.transformRequest(i.normalizeSourceURL(e.url),t.ResourceType.Source),r):t.browser.frame((function(){return r(null,e)}))}T.prototype.broadcast=function(e,i,o){t.asyncAll(this.actors,(function(t,o){t.send(e,i,o);}),o=o||function(){});},T.prototype.getActor=function(){return this.currentActor=(this.currentActor+1)%this.actors.length,this.actors[this.currentActor]},T.prototype.remove=function(){this.actors.forEach((function(t){t.remove();})),this.actors=[],this.workerPool.release(this.id);},T.Actor=t.Actor;var C=function(e,i,o){this.bounds=t.LngLatBounds.convert(this.validateBounds(e)),this.minzoom=i||0,this.maxzoom=o||24;};C.prototype.validateBounds=function(t){return Array.isArray(t)&&4===t.length?[Math.max(-180,t[0]),Math.max(-90,t[1]),Math.min(180,t[2]),Math.min(90,t[3])]:[-180,-90,180,90]},C.prototype.contains=function(e){var i=Math.pow(2,e.z),o=Math.floor(t.mercatorXfromLng(this.bounds.getWest())*i),r=Math.floor(t.mercatorYfromLat(this.bounds.getNorth())*i),a=Math.ceil(t.mercatorXfromLng(this.bounds.getEast())*i),n=Math.ceil(t.mercatorYfromLat(this.bounds.getSouth())*i);return e.x>=o&&e.x<a&&e.y>=r&&e.y<n};var S=function(e){function i(i,o,r,a){if(e.call(this),this.id=i,this.dispatcher=r,this.type="vector",this.minzoom=0,this.maxzoom=22,this.scheme="xyz",this.tileSize=512,this.reparseOverscaled=!0,this.isTileClipped=!0,this._loaded=!1,t.extend(this,t.pick(o,["url","scheme","tileSize","promoteId"])),this._options=t.extend({type:"vector"},o),this._collectResourceTiming=o.collectResourceTiming,512!==this.tileSize)throw new Error("vector tile sources must have a tileSize of 512");this.setEventedParent(a);}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.load=function(){var e=this;this._loaded=!1,this.fire(new t.Event("dataloading",{dataType:"source"})),this._tileJSONRequest=I(this._options,this.map._requestManager,(function(i,o){e._tileJSONRequest=null,e._loaded=!0,i?e.fire(new t.ErrorEvent(i)):o&&(t.extend(e,o),o.bounds&&(e.tileBounds=new C(o.bounds,e.minzoom,e.maxzoom)),t.postTurnstileEvent(o.tiles,e.map._requestManager._customAccessToken),t.postMapLoadEvent(o.tiles,e.map._getMapId(),e.map._requestManager._skuToken,e.map._requestManager._customAccessToken),e.fire(new t.Event("data",{dataType:"source",sourceDataType:"metadata"})),e.fire(new t.Event("data",{dataType:"source",sourceDataType:"content"})));}));},i.prototype.loaded=function(){return this._loaded},i.prototype.hasTile=function(t){return !this.tileBounds||this.tileBounds.contains(t.canonical)},i.prototype.onAdd=function(t){this.map=t,this.load();},i.prototype.onRemove=function(){this._tileJSONRequest&&(this._tileJSONRequest.cancel(),this._tileJSONRequest=null);},i.prototype.serialize=function(){return t.extend({},this._options)},i.prototype.loadTile=function(e,i){var o=this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles,this.scheme)),r={request:this.map._requestManager.transformRequest(o,t.ResourceType.Tile),uid:e.uid,tileID:e.tileID,zoom:e.tileID.overscaledZ,tileSize:this.tileSize*e.tileID.overscaleFactor(),type:this.type,source:this.id,pixelRatio:t.browser.devicePixelRatio,showCollisionBoxes:this.map.showCollisionBoxes,promoteId:this.promoteId};function a(o,r){return delete e.request,e.aborted?i(null):o&&404!==o.status?i(o):(r&&r.resourceTiming&&(e.resourceTiming=r.resourceTiming),this.map._refreshExpiredTiles&&r&&e.setExpiryData(r),e.loadVectorData(r,this.map.painter),t.cacheEntryPossiblyAdded(this.dispatcher),i(null),void(e.reloadCallback&&(this.loadTile(e,e.reloadCallback),e.reloadCallback=null)))}r.request.collectResourceTiming=this._collectResourceTiming,e.actor&&"expired"!==e.state?"loading"===e.state?e.reloadCallback=i:e.request=e.actor.send("reloadTile",r,a.bind(this)):(e.actor=this.dispatcher.getActor(),e.request=e.actor.send("loadTile",r,a.bind(this)));},i.prototype.abortTile=function(t){t.request&&(t.request.cancel(),delete t.request),t.actor&&t.actor.send("abortTile",{uid:t.uid,type:this.type,source:this.id},void 0);},i.prototype.unloadTile=function(t){t.unloadVectorData(),t.actor&&t.actor.send("removeTile",{uid:t.uid,type:this.type,source:this.id},void 0);},i.prototype.hasTransition=function(){return !1},i}(t.Evented),P=function(e){function i(i,o,r,a){e.call(this),this.id=i,this.dispatcher=r,this.setEventedParent(a),this.type="raster",this.minzoom=0,this.maxzoom=22,this.roundZoom=!0,this.scheme="xyz",this.tileSize=512,this._loaded=!1,this._options=t.extend({type:"raster"},o),t.extend(this,t.pick(o,["url","scheme","tileSize"]));}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.load=function(){var e=this;this._loaded=!1,this.fire(new t.Event("dataloading",{dataType:"source"})),this._tileJSONRequest=I(this._options,this.map._requestManager,(function(i,o){e._tileJSONRequest=null,e._loaded=!0,i?e.fire(new t.ErrorEvent(i)):o&&(t.extend(e,o),o.bounds&&(e.tileBounds=new C(o.bounds,e.minzoom,e.maxzoom)),t.postTurnstileEvent(o.tiles),t.postMapLoadEvent(o.tiles,e.map._getMapId(),e.map._requestManager._skuToken),e.fire(new t.Event("data",{dataType:"source",sourceDataType:"metadata"})),e.fire(new t.Event("data",{dataType:"source",sourceDataType:"content"})));}));},i.prototype.loaded=function(){return this._loaded},i.prototype.onAdd=function(t){this.map=t,this.load();},i.prototype.onRemove=function(){this._tileJSONRequest&&(this._tileJSONRequest.cancel(),this._tileJSONRequest=null);},i.prototype.serialize=function(){return t.extend({},this._options)},i.prototype.hasTile=function(t){return !this.tileBounds||this.tileBounds.contains(t.canonical)},i.prototype.loadTile=function(e,i){var o=this,r=this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles,this.scheme),this.tileSize);e.request=t.getImage(this.map._requestManager.transformRequest(r,t.ResourceType.Tile),(function(r,a){if(delete e.request,e.aborted)e.state="unloaded",i(null);else if(r)e.state="errored",i(r);else if(a){o.map._refreshExpiredTiles&&e.setExpiryData(a),delete a.cacheControl,delete a.expires;var n=o.map.painter.context,s=n.gl;e.texture=o.map.painter.getTileTexture(a.width),e.texture?e.texture.update(a,{useMipmap:!0}):(e.texture=new t.Texture(n,a,s.RGBA,{useMipmap:!0}),e.texture.bind(s.LINEAR,s.CLAMP_TO_EDGE,s.LINEAR_MIPMAP_NEAREST),n.extTextureFilterAnisotropic&&s.texParameterf(s.TEXTURE_2D,n.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,n.extTextureFilterAnisotropicMax)),e.state="loaded",t.cacheEntryPossiblyAdded(o.dispatcher),i(null);}}));},i.prototype.abortTile=function(t,e){t.request&&(t.request.cancel(),delete t.request),e();},i.prototype.unloadTile=function(t,e){t.texture&&this.map.painter.saveTileTexture(t.texture),e();},i.prototype.hasTransition=function(){return !1},i}(t.Evented),z=function(e){function i(i,o,r,a){e.call(this,i,o,r,a),this.type="raster-dem",this.maxzoom=22,this._options=t.extend({type:"raster-dem"},o),this.encoding=o.encoding||"mapbox";}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.serialize=function(){return {type:"raster-dem",url:this.url,tileSize:this.tileSize,tiles:this.tiles,bounds:this.bounds,encoding:this.encoding}},i.prototype.loadTile=function(e,i){var o=this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles,this.scheme),this.tileSize);function r(t,o){t&&(e.state="errored",i(t)),o&&(e.dem=o,e.needsHillshadePrepare=!0,e.state="loaded",i(null));}e.request=t.getImage(this.map._requestManager.transformRequest(o,t.ResourceType.Tile),function(o,a){if(delete e.request,e.aborted)e.state="unloaded",i(null);else if(o)e.state="errored",i(o);else if(a){this.map._refreshExpiredTiles&&e.setExpiryData(a),delete a.cacheControl,delete a.expires;var n=t.window.ImageBitmap&&a instanceof t.window.ImageBitmap&&t.offscreenCanvasSupported()?a:t.browser.getImageData(a,1),s={uid:e.uid,coord:e.tileID,source:this.id,rawImageData:n,encoding:this.encoding};e.actor&&"expired"!==e.state||(e.actor=this.dispatcher.getActor(),e.actor.send("loadDEMTile",s,r.bind(this)));}}.bind(this)),e.neighboringTiles=this._getNeighboringTiles(e.tileID);},i.prototype._getNeighboringTiles=function(e){var i=e.canonical,o=Math.pow(2,i.z),r=(i.x-1+o)%o,a=0===i.x?e.wrap-1:e.wrap,n=(i.x+1+o)%o,s=i.x+1===o?e.wrap+1:e.wrap,l={};return l[new t.OverscaledTileID(e.overscaledZ,a,i.z,r,i.y).key]={backfilled:!1},l[new t.OverscaledTileID(e.overscaledZ,s,i.z,n,i.y).key]={backfilled:!1},i.y>0&&(l[new t.OverscaledTileID(e.overscaledZ,a,i.z,r,i.y-1).key]={backfilled:!1},l[new t.OverscaledTileID(e.overscaledZ,e.wrap,i.z,i.x,i.y-1).key]={backfilled:!1},l[new t.OverscaledTileID(e.overscaledZ,s,i.z,n,i.y-1).key]={backfilled:!1}),i.y+1<o&&(l[new t.OverscaledTileID(e.overscaledZ,a,i.z,r,i.y+1).key]={backfilled:!1},l[new t.OverscaledTileID(e.overscaledZ,e.wrap,i.z,i.x,i.y+1).key]={backfilled:!1},l[new t.OverscaledTileID(e.overscaledZ,s,i.z,n,i.y+1).key]={backfilled:!1}),l},i.prototype.unloadTile=function(t){t.demTexture&&this.map.painter.saveTileTexture(t.demTexture),t.fbo&&(t.fbo.destroy(),delete t.fbo),t.dem&&delete t.dem,delete t.neighboringTiles,t.state="unloaded",t.actor&&t.actor.send("removeDEMTile",{uid:t.uid,source:this.id});},i}(P),L=function(e){function i(i,o,r,a){e.call(this),this.id=i,this.type="geojson",this.minzoom=0,this.maxzoom=18,this.tileSize=512,this.isTileClipped=!0,this.reparseOverscaled=!0,this._removed=!1,this._loaded=!1,this.actor=r.getActor(),this.setEventedParent(a),this._data=o.data,this._options=t.extend({},o),this._collectResourceTiming=o.collectResourceTiming,this._resourceTiming=[],void 0!==o.maxzoom&&(this.maxzoom=o.maxzoom),o.type&&(this.type=o.type),o.attribution&&(this.attribution=o.attribution),this.promoteId=o.promoteId;var n=t.EXTENT/this.tileSize;this.workerOptions=t.extend({source:this.id,cluster:o.cluster||!1,geojsonVtOptions:{buffer:(void 0!==o.buffer?o.buffer:128)*n,tolerance:(void 0!==o.tolerance?o.tolerance:.375)*n,extent:t.EXTENT,maxZoom:this.maxzoom,lineMetrics:o.lineMetrics||!1,generateId:o.generateId||!1},superclusterOptions:{maxZoom:void 0!==o.clusterMaxZoom?Math.min(o.clusterMaxZoom,this.maxzoom-1):this.maxzoom-1,extent:t.EXTENT,radius:(o.clusterRadius||50)*n,log:!1,generateId:o.generateId||!1},clusterProperties:o.clusterProperties},o.workerOptions);}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.load=function(){var e=this;this.fire(new t.Event("dataloading",{dataType:"source"})),this._updateWorkerData((function(i){if(i)e.fire(new t.ErrorEvent(i));else{var o={dataType:"source",sourceDataType:"metadata"};e._collectResourceTiming&&e._resourceTiming&&e._resourceTiming.length>0&&(o.resourceTiming=e._resourceTiming,e._resourceTiming=[]),e.fire(new t.Event("data",o));}}));},i.prototype.onAdd=function(t){this.map=t,this.load();},i.prototype.setData=function(e){var i=this;return this._data=e,this.fire(new t.Event("dataloading",{dataType:"source"})),this._updateWorkerData((function(e){if(e)i.fire(new t.ErrorEvent(e));else{var o={dataType:"source",sourceDataType:"content"};i._collectResourceTiming&&i._resourceTiming&&i._resourceTiming.length>0&&(o.resourceTiming=i._resourceTiming,i._resourceTiming=[]),i.fire(new t.Event("data",o));}})),this},i.prototype.getClusterExpansionZoom=function(t,e){return this.actor.send("geojson.getClusterExpansionZoom",{clusterId:t,source:this.id},e),this},i.prototype.getClusterChildren=function(t,e){return this.actor.send("geojson.getClusterChildren",{clusterId:t,source:this.id},e),this},i.prototype.getClusterLeaves=function(t,e,i,o){return this.actor.send("geojson.getClusterLeaves",{source:this.id,clusterId:t,limit:e,offset:i},o),this},i.prototype._updateWorkerData=function(e){var i=this;this._loaded=!1;var o=t.extend({},this.workerOptions),r=this._data;"string"==typeof r?(o.request=this.map._requestManager.transformRequest(t.browser.resolveURL(r),t.ResourceType.Source),o.request.collectResourceTiming=this._collectResourceTiming):o.data=JSON.stringify(r),this.actor.send(this.type+".loadData",o,(function(t,r){i._removed||r&&r.abandoned||(i._loaded=!0,r&&r.resourceTiming&&r.resourceTiming[i.id]&&(i._resourceTiming=r.resourceTiming[i.id].slice(0)),i.actor.send(i.type+".coalesce",{source:o.source},null),e(t));}));},i.prototype.loaded=function(){return this._loaded},i.prototype.loadTile=function(e,i){var o=this,r=e.actor?"reloadTile":"loadTile";e.actor=this.actor,e.request=this.actor.send(r,{type:this.type,uid:e.uid,tileID:e.tileID,zoom:e.tileID.overscaledZ,maxZoom:this.maxzoom,tileSize:this.tileSize,source:this.id,pixelRatio:t.browser.devicePixelRatio,showCollisionBoxes:this.map.showCollisionBoxes,promoteId:this.promoteId},(function(t,a){return delete e.request,e.unloadVectorData(),e.aborted?i(null):t?i(t):(e.loadVectorData(a,o.map.painter,"reloadTile"===r),i(null))}));},i.prototype.abortTile=function(t){t.request&&(t.request.cancel(),delete t.request),t.aborted=!0;},i.prototype.unloadTile=function(t){t.unloadVectorData(),this.actor.send("removeTile",{uid:t.uid,type:this.type,source:this.id});},i.prototype.onRemove=function(){this._removed=!0,this.actor.send("removeSource",{type:this.type,source:this.id});},i.prototype.serialize=function(){return t.extend({},this._options,{type:this.type,data:this._data})},i.prototype.hasTransition=function(){return !1},i}(t.Evented),M=t.createLayout([{name:"a_pos",type:"Int16",components:2},{name:"a_texture_pos",type:"Int16",components:2}]),D=function(e){function i(t,i,o,r){e.call(this),this.id=t,this.dispatcher=o,this.coordinates=i.coordinates,this.type="image",this.minzoom=0,this.maxzoom=22,this.tileSize=512,this.tiles={},this._loaded=!1,this.setEventedParent(r),this.options=i;}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.load=function(e,i){var o=this;this._loaded=!1,this.fire(new t.Event("dataloading",{dataType:"source"})),this.url=this.options.url,t.getImage(this.map._requestManager.transformRequest(this.url,t.ResourceType.Image),(function(r,a){o._loaded=!0,r?o.fire(new t.ErrorEvent(r)):a&&(o.image=a,e&&(o.coordinates=e),i&&i(),o._finishLoading());}));},i.prototype.loaded=function(){return this._loaded},i.prototype.updateImage=function(t){var e=this;return this.image&&t.url?(this.options.url=t.url,this.load(t.coordinates,(function(){e.texture=null;})),this):this},i.prototype._finishLoading=function(){this.map&&(this.setCoordinates(this.coordinates),this.fire(new t.Event("data",{dataType:"source",sourceDataType:"metadata"})));},i.prototype.onAdd=function(t){this.map=t,this.load();},i.prototype.setCoordinates=function(e){var i=this;this.coordinates=e;var o=e.map(t.MercatorCoordinate.fromLngLat);this.tileID=function(e){for(var i=1/0,o=1/0,r=-1/0,a=-1/0,n=0,s=e;n<s.length;n+=1){var l=s[n];i=Math.min(i,l.x),o=Math.min(o,l.y),r=Math.max(r,l.x),a=Math.max(a,l.y);}var c=Math.max(r-i,a-o),u=Math.max(0,Math.floor(-Math.log(c)/Math.LN2)),h=Math.pow(2,u);return new t.CanonicalTileID(u,Math.floor((i+r)/2*h),Math.floor((o+a)/2*h))}(o),this.minzoom=this.maxzoom=this.tileID.z;var r=o.map((function(t){return i.tileID.getTilePoint(t)._round()}));return this._boundsArray=new t.StructArrayLayout4i8,this._boundsArray.emplaceBack(r[0].x,r[0].y,0,0),this._boundsArray.emplaceBack(r[1].x,r[1].y,t.EXTENT,0),this._boundsArray.emplaceBack(r[3].x,r[3].y,0,t.EXTENT),this._boundsArray.emplaceBack(r[2].x,r[2].y,t.EXTENT,t.EXTENT),this.boundsBuffer&&(this.boundsBuffer.destroy(),delete this.boundsBuffer),this.fire(new t.Event("data",{dataType:"source",sourceDataType:"content"})),this},i.prototype.prepare=function(){if(0!==Object.keys(this.tiles).length&&this.image){var e=this.map.painter.context,i=e.gl;for(var o in this.boundsBuffer||(this.boundsBuffer=e.createVertexBuffer(this._boundsArray,M.members)),this.boundsSegments||(this.boundsSegments=t.SegmentVector.simpleSegment(0,0,4,2)),this.texture||(this.texture=new t.Texture(e,this.image,i.RGBA),this.texture.bind(i.LINEAR,i.CLAMP_TO_EDGE)),this.tiles){var r=this.tiles[o];"loaded"!==r.state&&(r.state="loaded",r.texture=this.texture);}}},i.prototype.loadTile=function(t,e){this.tileID&&this.tileID.equals(t.tileID.canonical)?(this.tiles[String(t.tileID.wrap)]=t,t.buckets={},e(null)):(t.state="errored",e(null));},i.prototype.serialize=function(){return {type:"image",url:this.options.url,coordinates:this.coordinates}},i.prototype.hasTransition=function(){return !1},i}(t.Evented),A=function(e){function i(t,i,o,r){e.call(this,t,i,o,r),this.roundZoom=!0,this.type="video",this.options=i;}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.load=function(){var e=this;this._loaded=!1;var i=this.options;this.urls=[];for(var o=0,r=i.urls;o<r.length;o+=1)this.urls.push(this.map._requestManager.transformRequest(r[o],t.ResourceType.Source).url);t.getVideo(this.urls,(function(i,o){e._loaded=!0,i?e.fire(new t.ErrorEvent(i)):o&&(e.video=o,e.video.loop=!0,e.video.addEventListener("playing",(function(){e.map.triggerRepaint();})),e.map&&e.video.play(),e._finishLoading());}));},i.prototype.pause=function(){this.video&&this.video.pause();},i.prototype.play=function(){this.video&&this.video.play();},i.prototype.seek=function(e){if(this.video){var i=this.video.seekable;e<i.start(0)||e>i.end(0)?this.fire(new t.ErrorEvent(new t.ValidationError("sources."+this.id,null,"Playback for this video can be set only between the "+i.start(0)+" and "+i.end(0)+"-second mark."))):this.video.currentTime=e;}},i.prototype.getVideo=function(){return this.video},i.prototype.onAdd=function(t){this.map||(this.map=t,this.load(),this.video&&(this.video.play(),this.setCoordinates(this.coordinates)));},i.prototype.prepare=function(){if(!(0===Object.keys(this.tiles).length||this.video.readyState<2)){var e=this.map.painter.context,i=e.gl;for(var o in this.boundsBuffer||(this.boundsBuffer=e.createVertexBuffer(this._boundsArray,M.members)),this.boundsSegments||(this.boundsSegments=t.SegmentVector.simpleSegment(0,0,4,2)),this.texture?this.video.paused||(this.texture.bind(i.LINEAR,i.CLAMP_TO_EDGE),i.texSubImage2D(i.TEXTURE_2D,0,0,0,i.RGBA,i.UNSIGNED_BYTE,this.video)):(this.texture=new t.Texture(e,this.video,i.RGBA),this.texture.bind(i.LINEAR,i.CLAMP_TO_EDGE)),this.tiles){var r=this.tiles[o];"loaded"!==r.state&&(r.state="loaded",r.texture=this.texture);}}},i.prototype.serialize=function(){return {type:"video",urls:this.urls,coordinates:this.coordinates}},i.prototype.hasTransition=function(){return this.video&&!this.video.paused},i}(D),R=function(e){function i(i,o,r,a){e.call(this,i,o,r,a),o.coordinates?Array.isArray(o.coordinates)&&4===o.coordinates.length&&!o.coordinates.some((function(t){return !Array.isArray(t)||2!==t.length||t.some((function(t){return "number"!=typeof t}))}))||this.fire(new t.ErrorEvent(new t.ValidationError("sources."+i,null,'"coordinates" property must be an array of 4 longitude/latitude array pairs'))):this.fire(new t.ErrorEvent(new t.ValidationError("sources."+i,null,'missing required property "coordinates"'))),o.animate&&"boolean"!=typeof o.animate&&this.fire(new t.ErrorEvent(new t.ValidationError("sources."+i,null,'optional "animate" property must be a boolean value'))),o.canvas?"string"==typeof o.canvas||o.canvas instanceof t.window.HTMLCanvasElement||this.fire(new t.ErrorEvent(new t.ValidationError("sources."+i,null,'"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))):this.fire(new t.ErrorEvent(new t.ValidationError("sources."+i,null,'missing required property "canvas"'))),this.options=o,this.animate=void 0===o.animate||o.animate;}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.load=function(){this._loaded=!0,this.canvas||(this.canvas=this.options.canvas instanceof t.window.HTMLCanvasElement?this.options.canvas:t.window.document.getElementById(this.options.canvas)),this.width=this.canvas.width,this.height=this.canvas.height,this._hasInvalidDimensions()?this.fire(new t.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))):(this.play=function(){this._playing=!0,this.map.triggerRepaint();},this.pause=function(){this._playing&&(this.prepare(),this._playing=!1);},this._finishLoading());},i.prototype.getCanvas=function(){return this.canvas},i.prototype.onAdd=function(t){this.map=t,this.load(),this.canvas&&this.animate&&this.play();},i.prototype.onRemove=function(){this.pause();},i.prototype.prepare=function(){var e=!1;if(this.canvas.width!==this.width&&(this.width=this.canvas.width,e=!0),this.canvas.height!==this.height&&(this.height=this.canvas.height,e=!0),!this._hasInvalidDimensions()&&0!==Object.keys(this.tiles).length){var i=this.map.painter.context,o=i.gl;for(var r in this.boundsBuffer||(this.boundsBuffer=i.createVertexBuffer(this._boundsArray,M.members)),this.boundsSegments||(this.boundsSegments=t.SegmentVector.simpleSegment(0,0,4,2)),this.texture?(e||this._playing)&&this.texture.update(this.canvas,{premultiply:!0}):this.texture=new t.Texture(i,this.canvas,o.RGBA,{premultiply:!0}),this.tiles){var a=this.tiles[r];"loaded"!==a.state&&(a.state="loaded",a.texture=this.texture);}}},i.prototype.serialize=function(){return {type:"canvas",coordinates:this.coordinates}},i.prototype.hasTransition=function(){return this._playing},i.prototype._hasInvalidDimensions=function(){for(var t=0,e=[this.canvas.width,this.canvas.height];t<e.length;t+=1){var i=e[t];if(isNaN(i)||i<=0)return !0}return !1},i}(D),k={vector:S,raster:P,"raster-dem":z,geojson:L,video:A,image:D,canvas:R},B=function(e,i,o,r){var a=new k[i.type](e,i,o,r);if(a.id!==e)throw new Error("Expected Source id to be "+e+" instead of "+a.id);return t.bindAll(["load","abort","unload","serialize","prepare"],a),a};function O(e,i){var o=t.identity([]);return t.translate(o,o,[1,1,0]),t.scale(o,o,[.5*e.width,.5*e.height,1]),t.multiply(o,o,e.calculatePosMatrix(i.toUnwrapped()))}function F(t,e,i,o,r,a){var n=function(t,e,i){if(t)for(var o=0,r=t;o<r.length;o+=1){var a=e[r[o]];if(a&&a.source===i&&"fill-extrusion"===a.type)return !0}else for(var n in e){var s=e[n];if(s.source===i&&"fill-extrusion"===s.type)return !0}return !1}(r&&r.layers,e,t.id),s=a.maxPitchScaleFactor(),l=t.tilesIn(o,s,n);l.sort(U);for(var c=[],u=0,h=l;u<h.length;u+=1){var p=h[u];c.push({wrappedTileID:p.tileID.wrapped().key,queryResults:p.tile.queryRenderedFeatures(e,i,t._state,p.queryGeometry,p.cameraQueryGeometry,p.scale,r,a,s,O(t.transform,p.tileID))});}var d=function(t){for(var e={},i={},o=0,r=t;o<r.length;o+=1){var a=r[o],n=a.queryResults,s=a.wrappedTileID,l=i[s]=i[s]||{};for(var c in n)for(var u=n[c],h=l[c]=l[c]||{},p=e[c]=e[c]||[],d=0,_=u;d<_.length;d+=1){var f=_[d];h[f.featureIndex]||(h[f.featureIndex]=!0,p.push(f));}}return e}(c);for(var _ in d)d[_].forEach((function(e){var i=e.feature,o=t.getFeatureState(i.layer["source-layer"],i.id);i.source=i.layer.source,i.layer["source-layer"]&&(i.sourceLayer=i.layer["source-layer"]),i.state=o;}));return d}function U(t,e){var i=t.tileID,o=e.tileID;return i.overscaledZ-o.overscaledZ||i.canonical.y-o.canonical.y||i.wrap-o.wrap||i.canonical.x-o.canonical.x}var N=function(t,e){this.max=t,this.onRemove=e,this.reset();};N.prototype.reset=function(){for(var t in this.data)for(var e=0,i=this.data[t];e<i.length;e+=1){var o=i[e];o.timeout&&clearTimeout(o.timeout),this.onRemove(o.value);}return this.data={},this.order=[],this},N.prototype.add=function(t,e,i){var o=this,r=t.wrapped().key;void 0===this.data[r]&&(this.data[r]=[]);var a={value:e,timeout:void 0};if(void 0!==i&&(a.timeout=setTimeout((function(){o.remove(t,a);}),i)),this.data[r].push(a),this.order.push(r),this.order.length>this.max){var n=this._getAndRemoveByKey(this.order[0]);n&&this.onRemove(n);}return this},N.prototype.has=function(t){return t.wrapped().key in this.data},N.prototype.getAndRemove=function(t){return this.has(t)?this._getAndRemoveByKey(t.wrapped().key):null},N.prototype._getAndRemoveByKey=function(t){var e=this.data[t].shift();return e.timeout&&clearTimeout(e.timeout),0===this.data[t].length&&delete this.data[t],this.order.splice(this.order.indexOf(t),1),e.value},N.prototype.getByKey=function(t){var e=this.data[t];return e?e[0].value:null},N.prototype.get=function(t){return this.has(t)?this.data[t.wrapped().key][0].value:null},N.prototype.remove=function(t,e){if(!this.has(t))return this;var i=t.wrapped().key,o=void 0===e?0:this.data[i].indexOf(e),r=this.data[i][o];return this.data[i].splice(o,1),r.timeout&&clearTimeout(r.timeout),0===this.data[i].length&&delete this.data[i],this.onRemove(r.value),this.order.splice(this.order.indexOf(i),1),this},N.prototype.setMaxSize=function(t){for(this.max=t;this.order.length>this.max;){var e=this._getAndRemoveByKey(this.order[0]);e&&this.onRemove(e);}return this},N.prototype.filter=function(t){var e=[];for(var i in this.data)for(var o=0,r=this.data[i];o<r.length;o+=1){var a=r[o];t(a.value)||e.push(a);}for(var n=0,s=e;n<s.length;n+=1){var l=s[n];this.remove(l.value.tileID,l);}};var Z=function(t,e,i){this.context=t;var o=t.gl;this.buffer=o.createBuffer(),this.dynamicDraw=Boolean(i),this.context.unbindVAO(),t.bindElementBuffer.set(this.buffer),o.bufferData(o.ELEMENT_ARRAY_BUFFER,e.arrayBuffer,this.dynamicDraw?o.DYNAMIC_DRAW:o.STATIC_DRAW),this.dynamicDraw||delete e.arrayBuffer;};Z.prototype.bind=function(){this.context.bindElementBuffer.set(this.buffer);},Z.prototype.updateData=function(t){var e=this.context.gl;this.context.unbindVAO(),this.bind(),e.bufferSubData(e.ELEMENT_ARRAY_BUFFER,0,t.arrayBuffer);},Z.prototype.destroy=function(){this.buffer&&(this.context.gl.deleteBuffer(this.buffer),delete this.buffer);};var q={Int8:"BYTE",Uint8:"UNSIGNED_BYTE",Int16:"SHORT",Uint16:"UNSIGNED_SHORT",Int32:"INT",Uint32:"UNSIGNED_INT",Float32:"FLOAT"},j=function(t,e,i,o){this.length=e.length,this.attributes=i,this.itemSize=e.bytesPerElement,this.dynamicDraw=o,this.context=t;var r=t.gl;this.buffer=r.createBuffer(),t.bindVertexBuffer.set(this.buffer),r.bufferData(r.ARRAY_BUFFER,e.arrayBuffer,this.dynamicDraw?r.DYNAMIC_DRAW:r.STATIC_DRAW),this.dynamicDraw||delete e.arrayBuffer;};j.prototype.bind=function(){this.context.bindVertexBuffer.set(this.buffer);},j.prototype.updateData=function(t){var e=this.context.gl;this.bind(),e.bufferSubData(e.ARRAY_BUFFER,0,t.arrayBuffer);},j.prototype.enableAttributes=function(t,e){for(var i=0;i<this.attributes.length;i++){var o=e.attributes[this.attributes[i].name];void 0!==o&&t.enableVertexAttribArray(o);}},j.prototype.setVertexAttribPointers=function(t,e,i){for(var o=0;o<this.attributes.length;o++){var r=this.attributes[o],a=e.attributes[r.name];void 0!==a&&t.vertexAttribPointer(a,r.components,t[q[r.type]],!1,this.itemSize,r.offset+this.itemSize*(i||0));}},j.prototype.destroy=function(){this.buffer&&(this.context.gl.deleteBuffer(this.buffer),delete this.buffer);};var V=function(t){this.gl=t.gl,this.default=this.getDefault(),this.current=this.default,this.dirty=!1;};V.prototype.get=function(){return this.current},V.prototype.set=function(t){},V.prototype.getDefault=function(){return this.default},V.prototype.setDefault=function(){this.set(this.default);};var G=function(e){function i(){e.apply(this,arguments);}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.getDefault=function(){return t.Color.transparent},i.prototype.set=function(t){var e=this.current;(t.r!==e.r||t.g!==e.g||t.b!==e.b||t.a!==e.a||this.dirty)&&(this.gl.clearColor(t.r,t.g,t.b,t.a),this.current=t,this.dirty=!1);},i}(V),W=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return 1},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.clearDepth(t),this.current=t,this.dirty=!1);},e}(V),X=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return 0},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.clearStencil(t),this.current=t,this.dirty=!1);},e}(V),H=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return [!0,!0,!0,!0]},e.prototype.set=function(t){var e=this.current;(t[0]!==e[0]||t[1]!==e[1]||t[2]!==e[2]||t[3]!==e[3]||this.dirty)&&(this.gl.colorMask(t[0],t[1],t[2],t[3]),this.current=t,this.dirty=!1);},e}(V),K=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return !0},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.depthMask(t),this.current=t,this.dirty=!1);},e}(V),Y=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return 255},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.stencilMask(t),this.current=t,this.dirty=!1);},e}(V),J=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return {func:this.gl.ALWAYS,ref:0,mask:255}},e.prototype.set=function(t){var e=this.current;(t.func!==e.func||t.ref!==e.ref||t.mask!==e.mask||this.dirty)&&(this.gl.stencilFunc(t.func,t.ref,t.mask),this.current=t,this.dirty=!1);},e}(V),Q=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){var t=this.gl;return [t.KEEP,t.KEEP,t.KEEP]},e.prototype.set=function(t){var e=this.current;(t[0]!==e[0]||t[1]!==e[1]||t[2]!==e[2]||this.dirty)&&(this.gl.stencilOp(t[0],t[1],t[2]),this.current=t,this.dirty=!1);},e}(V),$=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return !1},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;t?e.enable(e.STENCIL_TEST):e.disable(e.STENCIL_TEST),this.current=t,this.dirty=!1;}},e}(V),tt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return [0,1]},e.prototype.set=function(t){var e=this.current;(t[0]!==e[0]||t[1]!==e[1]||this.dirty)&&(this.gl.depthRange(t[0],t[1]),this.current=t,this.dirty=!1);},e}(V),et=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return !1},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;t?e.enable(e.DEPTH_TEST):e.disable(e.DEPTH_TEST),this.current=t,this.dirty=!1;}},e}(V),it=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return this.gl.LESS},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.depthFunc(t),this.current=t,this.dirty=!1);},e}(V),ot=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return !1},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;t?e.enable(e.BLEND):e.disable(e.BLEND),this.current=t,this.dirty=!1;}},e}(V),rt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){var t=this.gl;return [t.ONE,t.ZERO]},e.prototype.set=function(t){var e=this.current;(t[0]!==e[0]||t[1]!==e[1]||this.dirty)&&(this.gl.blendFunc(t[0],t[1]),this.current=t,this.dirty=!1);},e}(V),at=function(e){function i(){e.apply(this,arguments);}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.getDefault=function(){return t.Color.transparent},i.prototype.set=function(t){var e=this.current;(t.r!==e.r||t.g!==e.g||t.b!==e.b||t.a!==e.a||this.dirty)&&(this.gl.blendColor(t.r,t.g,t.b,t.a),this.current=t,this.dirty=!1);},i}(V),nt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return this.gl.FUNC_ADD},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.blendEquation(t),this.current=t,this.dirty=!1);},e}(V),st=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return !1},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;t?e.enable(e.CULL_FACE):e.disable(e.CULL_FACE),this.current=t,this.dirty=!1;}},e}(V),lt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return this.gl.BACK},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.cullFace(t),this.current=t,this.dirty=!1);},e}(V),ct=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return this.gl.CCW},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.frontFace(t),this.current=t,this.dirty=!1);},e}(V),ut=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return null},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.useProgram(t),this.current=t,this.dirty=!1);},e}(V),ht=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return this.gl.TEXTURE0},e.prototype.set=function(t){(t!==this.current||this.dirty)&&(this.gl.activeTexture(t),this.current=t,this.dirty=!1);},e}(V),pt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){var t=this.gl;return [0,0,t.drawingBufferWidth,t.drawingBufferHeight]},e.prototype.set=function(t){var e=this.current;(t[0]!==e[0]||t[1]!==e[1]||t[2]!==e[2]||t[3]!==e[3]||this.dirty)&&(this.gl.viewport(t[0],t[1],t[2],t[3]),this.current=t,this.dirty=!1);},e}(V),dt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return null},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,t),this.current=t,this.dirty=!1;}},e}(V),_t=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return null},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;e.bindRenderbuffer(e.RENDERBUFFER,t),this.current=t,this.dirty=!1;}},e}(V),ft=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return null},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;e.bindTexture(e.TEXTURE_2D,t),this.current=t,this.dirty=!1;}},e}(V),mt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return null},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;e.bindBuffer(e.ARRAY_BUFFER,t),this.current=t,this.dirty=!1;}},e}(V),gt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return null},e.prototype.set=function(t){var e=this.gl;e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t),this.current=t,this.dirty=!1;},e}(V),vt=function(t){function e(e){t.call(this,e),this.vao=e.extVertexArrayObject;}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return null},e.prototype.set=function(t){this.vao&&(t!==this.current||this.dirty)&&(this.vao.bindVertexArrayOES(t),this.current=t,this.dirty=!1);},e}(V),yt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return 4},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;e.pixelStorei(e.UNPACK_ALIGNMENT,t),this.current=t,this.dirty=!1;}},e}(V),xt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return !1},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,t),this.current=t,this.dirty=!1;}},e}(V),bt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return !1},e.prototype.set=function(t){if(t!==this.current||this.dirty){var e=this.gl;e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,t),this.current=t,this.dirty=!1;}},e}(V),wt=function(t){function e(e,i){t.call(this,e),this.context=e,this.parent=i;}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.getDefault=function(){return null},e}(V),Et=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.setDirty=function(){this.dirty=!0;},e.prototype.set=function(t){if(t!==this.current||this.dirty){this.context.bindFramebuffer.set(this.parent);var e=this.gl;e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0),this.current=t,this.dirty=!1;}},e}(wt),Tt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e,e.prototype.set=function(t){if(t!==this.current||this.dirty){this.context.bindFramebuffer.set(this.parent);var e=this.gl;e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.RENDERBUFFER,t),this.current=t,this.dirty=!1;}},e}(wt),It=function(t,e,i,o){this.context=t,this.width=e,this.height=i;var r=this.framebuffer=t.gl.createFramebuffer();this.colorAttachment=new Et(t,r),o&&(this.depthAttachment=new Tt(t,r));};It.prototype.destroy=function(){var t=this.context.gl,e=this.colorAttachment.get();if(e&&t.deleteTexture(e),this.depthAttachment){var i=this.depthAttachment.get();i&&t.deleteRenderbuffer(i);}t.deleteFramebuffer(this.framebuffer);};var Ct=function(t,e,i){this.func=t,this.mask=e,this.range=i;};Ct.ReadOnly=!1,Ct.ReadWrite=!0,Ct.disabled=new Ct(519,Ct.ReadOnly,[0,1]);var St=function(t,e,i,o,r,a){this.test=t,this.ref=e,this.mask=i,this.fail=o,this.depthFail=r,this.pass=a;};St.disabled=new St({func:519,mask:0},0,0,7680,7680,7680);var Pt=function(t,e,i){this.blendFunction=t,this.blendColor=e,this.mask=i;};Pt.Replace=[1,0],Pt.disabled=new Pt(Pt.Replace,t.Color.transparent,[!1,!1,!1,!1]),Pt.unblended=new Pt(Pt.Replace,t.Color.transparent,[!0,!0,!0,!0]),Pt.alphaBlended=new Pt([1,771],t.Color.transparent,[!0,!0,!0,!0]);var zt=function(t,e,i){this.enable=t,this.mode=e,this.frontFace=i;};zt.disabled=new zt(!1,1029,2305),zt.backCCW=new zt(!0,1029,2305);var Lt=function(t){this.gl=t,this.extVertexArrayObject=this.gl.getExtension("OES_vertex_array_object"),this.clearColor=new G(this),this.clearDepth=new W(this),this.clearStencil=new X(this),this.colorMask=new H(this),this.depthMask=new K(this),this.stencilMask=new Y(this),this.stencilFunc=new J(this),this.stencilOp=new Q(this),this.stencilTest=new $(this),this.depthRange=new tt(this),this.depthTest=new et(this),this.depthFunc=new it(this),this.blend=new ot(this),this.blendFunc=new rt(this),this.blendColor=new at(this),this.blendEquation=new nt(this),this.cullFace=new st(this),this.cullFaceSide=new lt(this),this.frontFace=new ct(this),this.program=new ut(this),this.activeTexture=new ht(this),this.viewport=new pt(this),this.bindFramebuffer=new dt(this),this.bindRenderbuffer=new _t(this),this.bindTexture=new ft(this),this.bindVertexBuffer=new mt(this),this.bindElementBuffer=new gt(this),this.bindVertexArrayOES=this.extVertexArrayObject&&new vt(this),this.pixelStoreUnpack=new yt(this),this.pixelStoreUnpackPremultiplyAlpha=new xt(this),this.pixelStoreUnpackFlipY=new bt(this),this.extTextureFilterAnisotropic=t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),this.extTextureFilterAnisotropic&&(this.extTextureFilterAnisotropicMax=t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)),this.extTextureHalfFloat=t.getExtension("OES_texture_half_float"),this.extTextureHalfFloat&&t.getExtension("OES_texture_half_float_linear"),this.extTimerQuery=t.getExtension("EXT_disjoint_timer_query");};Lt.prototype.setDefault=function(){this.unbindVAO(),this.clearColor.setDefault(),this.clearDepth.setDefault(),this.clearStencil.setDefault(),this.colorMask.setDefault(),this.depthMask.setDefault(),this.stencilMask.setDefault(),this.stencilFunc.setDefault(),this.stencilOp.setDefault(),this.stencilTest.setDefault(),this.depthRange.setDefault(),this.depthTest.setDefault(),this.depthFunc.setDefault(),this.blend.setDefault(),this.blendFunc.setDefault(),this.blendColor.setDefault(),this.blendEquation.setDefault(),this.cullFace.setDefault(),this.cullFaceSide.setDefault(),this.frontFace.setDefault(),this.program.setDefault(),this.activeTexture.setDefault(),this.bindFramebuffer.setDefault(),this.pixelStoreUnpack.setDefault(),this.pixelStoreUnpackPremultiplyAlpha.setDefault(),this.pixelStoreUnpackFlipY.setDefault();},Lt.prototype.setDirty=function(){this.clearColor.dirty=!0,this.clearDepth.dirty=!0,this.clearStencil.dirty=!0,this.colorMask.dirty=!0,this.depthMask.dirty=!0,this.stencilMask.dirty=!0,this.stencilFunc.dirty=!0,this.stencilOp.dirty=!0,this.stencilTest.dirty=!0,this.depthRange.dirty=!0,this.depthTest.dirty=!0,this.depthFunc.dirty=!0,this.blend.dirty=!0,this.blendFunc.dirty=!0,this.blendColor.dirty=!0,this.blendEquation.dirty=!0,this.cullFace.dirty=!0,this.cullFaceSide.dirty=!0,this.frontFace.dirty=!0,this.program.dirty=!0,this.activeTexture.dirty=!0,this.viewport.dirty=!0,this.bindFramebuffer.dirty=!0,this.bindRenderbuffer.dirty=!0,this.bindTexture.dirty=!0,this.bindVertexBuffer.dirty=!0,this.bindElementBuffer.dirty=!0,this.extVertexArrayObject&&(this.bindVertexArrayOES.dirty=!0),this.pixelStoreUnpack.dirty=!0,this.pixelStoreUnpackPremultiplyAlpha.dirty=!0,this.pixelStoreUnpackFlipY.dirty=!0;},Lt.prototype.createIndexBuffer=function(t,e){return new Z(this,t,e)},Lt.prototype.createVertexBuffer=function(t,e,i){return new j(this,t,e,i)},Lt.prototype.createRenderbuffer=function(t,e,i){var o=this.gl,r=o.createRenderbuffer();return this.bindRenderbuffer.set(r),o.renderbufferStorage(o.RENDERBUFFER,t,e,i),this.bindRenderbuffer.set(null),r},Lt.prototype.createFramebuffer=function(t,e,i){return new It(this,t,e,i)},Lt.prototype.clear=function(t){var e=t.color,i=t.depth,o=this.gl,r=0;e&&(r|=o.COLOR_BUFFER_BIT,this.clearColor.set(e),this.colorMask.set([!0,!0,!0,!0])),void 0!==i&&(r|=o.DEPTH_BUFFER_BIT,this.depthRange.set([0,1]),this.clearDepth.set(i),this.depthMask.set(!0)),o.clear(r);},Lt.prototype.setCullFace=function(t){!1===t.enable?this.cullFace.set(!1):(this.cullFace.set(!0),this.cullFaceSide.set(t.mode),this.frontFace.set(t.frontFace));},Lt.prototype.setDepthMode=function(t){t.func!==this.gl.ALWAYS||t.mask?(this.depthTest.set(!0),this.depthFunc.set(t.func),this.depthMask.set(t.mask),this.depthRange.set(t.range)):this.depthTest.set(!1);},Lt.prototype.setStencilMode=function(t){t.test.func!==this.gl.ALWAYS||t.mask?(this.stencilTest.set(!0),this.stencilMask.set(t.mask),this.stencilOp.set([t.fail,t.depthFail,t.pass]),this.stencilFunc.set({func:t.test.func,ref:t.ref,mask:t.test.mask})):this.stencilTest.set(!1);},Lt.prototype.setColorMode=function(e){t.deepEqual(e.blendFunction,Pt.Replace)?this.blend.set(!1):(this.blend.set(!0),this.blendFunc.set(e.blendFunction),this.blendColor.set(e.blendColor)),this.colorMask.set(e.mask);},Lt.prototype.unbindVAO=function(){this.extVertexArrayObject&&this.bindVertexArrayOES.set(null);};var Mt=function(e){function i(i,o,r){var a=this;e.call(this),this.id=i,this.dispatcher=r,this.on("data",(function(t){"source"===t.dataType&&"metadata"===t.sourceDataType&&(a._sourceLoaded=!0),a._sourceLoaded&&!a._paused&&"source"===t.dataType&&"content"===t.sourceDataType&&(a.reload(),a.transform&&a.update(a.transform));})),this.on("error",(function(){a._sourceErrored=!0;})),this._source=B(i,o,r,this),this._tiles={},this._cache=new N(0,this._unloadTile.bind(this)),this._timers={},this._cacheTimers={},this._maxTileCacheSize=null,this._loadedParentTiles={},this._coveredTiles={},this._state=new t.SourceFeatureState;}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.onAdd=function(t){this.map=t,this._maxTileCacheSize=t?t._maxTileCacheSize:null,this._source&&this._source.onAdd&&this._source.onAdd(t);},i.prototype.onRemove=function(t){this._source&&this._source.onRemove&&this._source.onRemove(t);},i.prototype.loaded=function(){if(this._sourceErrored)return !0;if(!this._sourceLoaded)return !1;if(!this._source.loaded())return !1;for(var t in this._tiles){var e=this._tiles[t];if("loaded"!==e.state&&"errored"!==e.state)return !1}return !0},i.prototype.getSource=function(){return this._source},i.prototype.pause=function(){this._paused=!0;},i.prototype.resume=function(){if(this._paused){var t=this._shouldReloadOnResume;this._paused=!1,this._shouldReloadOnResume=!1,t&&this.reload(),this.transform&&this.update(this.transform);}},i.prototype._loadTile=function(t,e){return this._source.loadTile(t,e)},i.prototype._unloadTile=function(t){if(this._source.unloadTile)return this._source.unloadTile(t,(function(){}))},i.prototype._abortTile=function(t){if(this._source.abortTile)return this._source.abortTile(t,(function(){}))},i.prototype.serialize=function(){return this._source.serialize()},i.prototype.prepare=function(t){for(var e in this._source.prepare&&this._source.prepare(),this._state.coalesceChanges(this._tiles,this.map?this.map.painter:null),this._tiles){var i=this._tiles[e];i.upload(t),i.prepare(this.map.style.imageManager);}},i.prototype.getIds=function(){return t.values(this._tiles).map((function(t){return t.tileID})).sort(Dt).map((function(t){return t.key}))},i.prototype.getRenderableIds=function(e){var i=this,o=[];for(var r in this._tiles)this._isIdRenderable(r,e)&&o.push(this._tiles[r]);return e?o.sort((function(e,o){var r=e.tileID,a=o.tileID,n=new t.Point(r.canonical.x,r.canonical.y)._rotate(i.transform.angle),s=new t.Point(a.canonical.x,a.canonical.y)._rotate(i.transform.angle);return r.overscaledZ-a.overscaledZ||s.y-n.y||s.x-n.x})).map((function(t){return t.tileID.key})):o.map((function(t){return t.tileID})).sort(Dt).map((function(t){return t.key}))},i.prototype.hasRenderableParent=function(t){var e=this.findLoadedParent(t,0);return !!e&&this._isIdRenderable(e.tileID.key)},i.prototype._isIdRenderable=function(t,e){return this._tiles[t]&&this._tiles[t].hasData()&&!this._coveredTiles[t]&&(e||!this._tiles[t].holdingForFade())},i.prototype.reload=function(){if(this._paused)this._shouldReloadOnResume=!0;else for(var t in this._cache.reset(),this._tiles)"errored"!==this._tiles[t].state&&this._reloadTile(t,"reloading");},i.prototype._reloadTile=function(t,e){var i=this._tiles[t];i&&("loading"!==i.state&&(i.state=e),this._loadTile(i,this._tileLoaded.bind(this,i,t,e)));},i.prototype._tileLoaded=function(e,i,o,r){if(r)return e.state="errored",void(404!==r.status?this._source.fire(new t.ErrorEvent(r,{tile:e})):this.update(this.transform));e.timeAdded=t.browser.now(),"expired"===o&&(e.refreshedUponExpiration=!0),this._setTileReloadTimer(i,e),"raster-dem"===this.getSource().type&&e.dem&&this._backfillDEM(e),this._state.initializeTileState(e,this.map?this.map.painter:null),this._source.fire(new t.Event("data",{dataType:"source",tile:e,coord:e.tileID}));},i.prototype._backfillDEM=function(t){for(var e=this.getRenderableIds(),i=0;i<e.length;i++){var o=e[i];if(t.neighboringTiles&&t.neighboringTiles[o]){var r=this.getTileByID(o);a(t,r),a(r,t);}}function a(t,e){t.needsHillshadePrepare=!0;var i=e.tileID.canonical.x-t.tileID.canonical.x,o=e.tileID.canonical.y-t.tileID.canonical.y,r=Math.pow(2,t.tileID.canonical.z),a=e.tileID.key;0===i&&0===o||Math.abs(o)>1||(Math.abs(i)>1&&(1===Math.abs(i+r)?i+=r:1===Math.abs(i-r)&&(i-=r)),e.dem&&t.dem&&(t.dem.backfillBorder(e.dem,i,o),t.neighboringTiles&&t.neighboringTiles[a]&&(t.neighboringTiles[a].backfilled=!0)));}},i.prototype.getTile=function(t){return this.getTileByID(t.key)},i.prototype.getTileByID=function(t){return this._tiles[t]},i.prototype._retainLoadedChildren=function(t,e,i,o){for(var r in this._tiles){var a=this._tiles[r];if(!(o[r]||!a.hasData()||a.tileID.overscaledZ<=e||a.tileID.overscaledZ>i)){for(var n=a.tileID;a&&a.tileID.overscaledZ>e+1;){var s=a.tileID.scaledTo(a.tileID.overscaledZ-1);(a=this._tiles[s.key])&&a.hasData()&&(n=s);}for(var l=n;l.overscaledZ>e;)if(t[(l=l.scaledTo(l.overscaledZ-1)).key]){o[n.key]=n;break}}}},i.prototype.findLoadedParent=function(t,e){if(t.key in this._loadedParentTiles){var i=this._loadedParentTiles[t.key];return i&&i.tileID.overscaledZ>=e?i:null}for(var o=t.overscaledZ-1;o>=e;o--){var r=t.scaledTo(o),a=this._getLoadedTile(r);if(a)return a}},i.prototype._getLoadedTile=function(t){var e=this._tiles[t.key];return e&&e.hasData()?e:this._cache.getByKey(t.wrapped().key)},i.prototype.updateCacheSize=function(t){var e=Math.ceil(t.width/this._source.tileSize)+1,i=Math.ceil(t.height/this._source.tileSize)+1,o=Math.floor(e*i*5),r="number"==typeof this._maxTileCacheSize?Math.min(this._maxTileCacheSize,o):o;this._cache.setMaxSize(r);},i.prototype.handleWrapJump=function(t){var e=Math.round((t-(void 0===this._prevLng?t:this._prevLng))/360);if(this._prevLng=t,e){var i={};for(var o in this._tiles){var r=this._tiles[o];r.tileID=r.tileID.unwrapTo(r.tileID.wrap+e),i[r.tileID.key]=r;}for(var a in this._tiles=i,this._timers)clearTimeout(this._timers[a]),delete this._timers[a];for(var n in this._tiles)this._setTileReloadTimer(n,this._tiles[n]);}},i.prototype.update=function(e){var o=this;if(this.transform=e,this._sourceLoaded&&!this._paused){var r;this.updateCacheSize(e),this.handleWrapJump(this.transform.center.lng),this._coveredTiles={},this.used?this._source.tileID?r=e.getVisibleUnwrappedCoordinates(this._source.tileID).map((function(e){return new t.OverscaledTileID(e.canonical.z,e.wrap,e.canonical.z,e.canonical.x,e.canonical.y)})):(r=e.coveringTiles({tileSize:this._source.tileSize,minzoom:this._source.minzoom,maxzoom:this._source.maxzoom,roundZoom:this._source.roundZoom,reparseOverscaled:this._source.reparseOverscaled}),this._source.hasTile&&(r=r.filter((function(t){return o._source.hasTile(t)})))):r=[];var a=e.coveringZoomLevel(this._source),n=Math.max(a-i.maxOverzooming,this._source.minzoom),s=Math.max(a+i.maxUnderzooming,this._source.minzoom),l=this._updateRetainedTiles(r,a);if(At(this._source.type)){for(var c={},u={},h=0,p=Object.keys(l);h<p.length;h+=1){var d=p[h],_=l[d],f=this._tiles[d];if(f&&!(f.fadeEndTime&&f.fadeEndTime<=t.browser.now())){var m=this.findLoadedParent(_,n);m&&(this._addTile(m.tileID),c[m.tileID.key]=m.tileID),u[d]=_;}}for(var g in this._retainLoadedChildren(u,a,s,l),c)l[g]||(this._coveredTiles[g]=!0,l[g]=c[g]);}for(var v in l)this._tiles[v].clearFadeHold();for(var y=0,x=t.keysDifference(this._tiles,l);y<x.length;y+=1){var b=x[y],w=this._tiles[b];w.hasSymbolBuckets&&!w.holdingForFade()?w.setHoldDuration(this.map._fadeDuration):w.hasSymbolBuckets&&!w.symbolFadeFinished()||this._removeTile(b);}this._updateLoadedParentTileCache();}},i.prototype.releaseSymbolFadeTiles=function(){for(var t in this._tiles)this._tiles[t].holdingForFade()&&this._removeTile(t);},i.prototype._updateRetainedTiles=function(t,e){for(var o={},r={},a=Math.max(e-i.maxOverzooming,this._source.minzoom),n=Math.max(e+i.maxUnderzooming,this._source.minzoom),s={},l=0,c=t;l<c.length;l+=1){var u=c[l],h=this._addTile(u);o[u.key]=u,h.hasData()||e<this._source.maxzoom&&(s[u.key]=u);}this._retainLoadedChildren(s,e,n,o);for(var p=0,d=t;p<d.length;p+=1){var _=d[p],f=this._tiles[_.key];if(!f.hasData()){if(e+1>this._source.maxzoom){var m=_.children(this._source.maxzoom)[0],g=this.getTile(m);if(g&&g.hasData()){o[m.key]=m;continue}}else{var v=_.children(this._source.maxzoom);if(o[v[0].key]&&o[v[1].key]&&o[v[2].key]&&o[v[3].key])continue}for(var y=f.wasRequested(),x=_.overscaledZ-1;x>=a;--x){var b=_.scaledTo(x);if(r[b.key])break;if(r[b.key]=!0,!(f=this.getTile(b))&&y&&(f=this._addTile(b)),f&&(o[b.key]=b,y=f.wasRequested(),f.hasData()))break}}}return o},i.prototype._updateLoadedParentTileCache=function(){for(var t in this._loadedParentTiles={},this._tiles){for(var e=[],i=void 0,o=this._tiles[t].tileID;o.overscaledZ>0;){if(o.key in this._loadedParentTiles){i=this._loadedParentTiles[o.key];break}e.push(o.key);var r=o.scaledTo(o.overscaledZ-1);if(i=this._getLoadedTile(r))break;o=r;}for(var a=0,n=e;a<n.length;a+=1)this._loadedParentTiles[n[a]]=i;}},i.prototype._addTile=function(e){var i=this._tiles[e.key];if(i)return i;(i=this._cache.getAndRemove(e))&&(this._setTileReloadTimer(e.key,i),i.tileID=e,this._state.initializeTileState(i,this.map?this.map.painter:null),this._cacheTimers[e.key]&&(clearTimeout(this._cacheTimers[e.key]),delete this._cacheTimers[e.key],this._setTileReloadTimer(e.key,i)));var o=Boolean(i);return o||(i=new t.Tile(e,this._source.tileSize*e.overscaleFactor()),this._loadTile(i,this._tileLoaded.bind(this,i,e.key,i.state))),i?(i.uses++,this._tiles[e.key]=i,o||this._source.fire(new t.Event("dataloading",{tile:i,coord:i.tileID,dataType:"source"})),i):null},i.prototype._setTileReloadTimer=function(t,e){var i=this;t in this._timers&&(clearTimeout(this._timers[t]),delete this._timers[t]);var o=e.getExpiryTimeout();o&&(this._timers[t]=setTimeout((function(){i._reloadTile(t,"expired"),delete i._timers[t];}),o));},i.prototype._removeTile=function(t){var e=this._tiles[t];e&&(e.uses--,delete this._tiles[t],this._timers[t]&&(clearTimeout(this._timers[t]),delete this._timers[t]),e.uses>0||(e.hasData()&&"reloading"!==e.state?this._cache.add(e.tileID,e,e.getExpiryTimeout()):(e.aborted=!0,this._abortTile(e),this._unloadTile(e))));},i.prototype.clearTiles=function(){for(var t in this._shouldReloadOnResume=!1,this._paused=!1,this._tiles)this._removeTile(t);this._cache.reset();},i.prototype.tilesIn=function(e,i,o){var r=this,a=[],n=this.transform;if(!n)return a;for(var s=o?n.getCameraQueryGeometry(e):e,l=e.map((function(t){return n.pointCoordinate(t)})),c=s.map((function(t){return n.pointCoordinate(t)})),u=this.getIds(),h=1/0,p=1/0,d=-1/0,_=-1/0,f=0,m=c;f<m.length;f+=1){var g=m[f];h=Math.min(h,g.x),p=Math.min(p,g.y),d=Math.max(d,g.x),_=Math.max(_,g.y);}for(var v=function(e){var o=r._tiles[u[e]];if(!o.holdingForFade()){var s=o.tileID,f=Math.pow(2,n.zoom-o.tileID.overscaledZ),m=i*o.queryPadding*t.EXTENT/o.tileSize/f,g=[s.getTilePoint(new t.MercatorCoordinate(h,p)),s.getTilePoint(new t.MercatorCoordinate(d,_))];if(g[0].x-m<t.EXTENT&&g[0].y-m<t.EXTENT&&g[1].x+m>=0&&g[1].y+m>=0){var v=l.map((function(t){return s.getTilePoint(t)})),y=c.map((function(t){return s.getTilePoint(t)}));a.push({tile:o,tileID:s,queryGeometry:v,cameraQueryGeometry:y,scale:f});}}},y=0;y<u.length;y++)v(y);return a},i.prototype.getVisibleCoordinates=function(t){for(var e=this,i=this.getRenderableIds(t).map((function(t){return e._tiles[t].tileID})),o=0,r=i;o<r.length;o+=1){var a=r[o];a.posMatrix=this.transform.calculatePosMatrix(a.toUnwrapped());}return i},i.prototype.hasTransition=function(){if(this._source.hasTransition())return !0;if(At(this._source.type))for(var e in this._tiles){var i=this._tiles[e];if(void 0!==i.fadeEndTime&&i.fadeEndTime>=t.browser.now())return !0}return !1},i.prototype.setFeatureState=function(t,e,i){this._state.updateState(t=t||"_geojsonTileLayer",e,i);},i.prototype.removeFeatureState=function(t,e,i){this._state.removeFeatureState(t=t||"_geojsonTileLayer",e,i);},i.prototype.getFeatureState=function(t,e){return this._state.getState(t=t||"_geojsonTileLayer",e)},i.prototype.setDependencies=function(t,e,i){var o=this._tiles[t];o&&o.setDependencies(e,i);},i.prototype.reloadTilesForDependencies=function(t,e){for(var i in this._tiles)this._tiles[i].hasDependency(t,e)&&this._reloadTile(i,"reloading");this._cache.filter((function(i){return !i.hasDependency(t,e)}));},i}(t.Evented);function Dt(t,e){var i=Math.abs(2*t.wrap)-+(t.wrap<0),o=Math.abs(2*e.wrap)-+(e.wrap<0);return t.overscaledZ-e.overscaledZ||o-i||e.canonical.y-t.canonical.y||e.canonical.x-t.canonical.x}function At(t){return "raster"===t||"image"===t||"video"===t}function Rt(){return new t.window.Worker(mr.workerUrl)}Mt.maxOverzooming=10,Mt.maxUnderzooming=3;var kt=function(){this.active={};};kt.prototype.acquire=function(t){if(!this.workers)for(this.workers=[];this.workers.length<kt.workerCount;)this.workers.push(new Rt);return this.active[t]=!0,this.workers.slice()},kt.prototype.release=function(t){delete this.active[t],0===Object.keys(this.active).length&&(this.workers.forEach((function(t){t.terminate();})),this.workers=null);};var Bt,Ot=Math.floor(t.browser.hardwareConcurrency/2);function Ft(e,i){var o={};for(var r in e)"ref"!==r&&(o[r]=e[r]);return t.refProperties.forEach((function(t){t in i&&(o[t]=i[t]);})),o}function Ut(t){t=t.slice();for(var e=Object.create(null),i=0;i<t.length;i++)e[t[i].id]=t[i];for(var o=0;o<t.length;o++)"ref"in t[o]&&(t[o]=Ft(t[o],e[t[o].ref]));return t}kt.workerCount=Math.max(Math.min(Ot,6),1);var Nt={setStyle:"setStyle",addLayer:"addLayer",removeLayer:"removeLayer",setPaintProperty:"setPaintProperty",setLayoutProperty:"setLayoutProperty",setFilter:"setFilter",addSource:"addSource",removeSource:"removeSource",setGeoJSONSourceData:"setGeoJSONSourceData",setLayerZoomRange:"setLayerZoomRange",setLayerProperty:"setLayerProperty",setCenter:"setCenter",setZoom:"setZoom",setBearing:"setBearing",setPitch:"setPitch",setSprite:"setSprite",setGlyphs:"setGlyphs",setTransition:"setTransition",setLight:"setLight"};function Zt(t,e,i){i.push({command:Nt.addSource,args:[t,e[t]]});}function qt(t,e,i){e.push({command:Nt.removeSource,args:[t]}),i[t]=!0;}function jt(t,e,i,o){qt(t,i,o),Zt(t,e,i);}function Vt(e,i,o){var r;for(r in e[o])if(e[o].hasOwnProperty(r)&&"data"!==r&&!t.deepEqual(e[o][r],i[o][r]))return !1;for(r in i[o])if(i[o].hasOwnProperty(r)&&"data"!==r&&!t.deepEqual(e[o][r],i[o][r]))return !1;return !0}function Gt(e,i,o,r,a,n){var s;for(s in i=i||{},e=e||{})e.hasOwnProperty(s)&&(t.deepEqual(e[s],i[s])||o.push({command:n,args:[r,s,i[s],a]}));for(s in i)i.hasOwnProperty(s)&&!e.hasOwnProperty(s)&&(t.deepEqual(e[s],i[s])||o.push({command:n,args:[r,s,i[s],a]}));}function Wt(t){return t.id}function Xt(t,e){return t[e.id]=e,t}var Ht=function(t,e,i){var o=this.boxCells=[],r=this.circleCells=[];this.xCellCount=Math.ceil(t/i),this.yCellCount=Math.ceil(e/i);for(var a=0;a<this.xCellCount*this.yCellCount;a++)o.push([]),r.push([]);this.circleKeys=[],this.boxKeys=[],this.bboxes=[],this.circles=[],this.width=t,this.height=e,this.xScale=this.xCellCount/t,this.yScale=this.yCellCount/e,this.boxUid=0,this.circleUid=0;};function Kt(e,i,o,r,a){var n=t.create();return i?(t.scale(n,n,[1/a,1/a,1]),o||t.rotateZ(n,n,r.angle)):t.multiply(n,r.labelPlaneMatrix,e),n}function Yt(e,i,o,r,a){if(i){var n=t.clone(e);return t.scale(n,n,[a,a,1]),o||t.rotateZ(n,n,-r.angle),n}return r.glCoordMatrix}function Jt(e,i){var o=[e.x,e.y,0,1];se(o,o,i);var r=o[3];return {point:new t.Point(o[0]/r,o[1]/r),signedDistanceFromCamera:r}}function Qt(t,e){var i=t[0]/t[3],o=t[1]/t[3];return i>=-e[0]&&i<=e[0]&&o>=-e[1]&&o<=e[1]}function $t(e,i,o,r,a,n,s,l){var c=r?e.textSizeData:e.iconSizeData,u=t.evaluateSizeForZoom(c,o.transform.zoom),h=[256/o.width*2+1,256/o.height*2+1],p=r?e.text.dynamicLayoutVertexArray:e.icon.dynamicLayoutVertexArray;p.clear();for(var d=e.lineVertexArray,_=r?e.text.placedSymbolArray:e.icon.placedSymbolArray,f=o.transform.width/o.transform.height,m=!1,g=0;g<_.length;g++){var v=_.get(g);if(v.hidden||v.writingMode===t.WritingMode.vertical&&!m)ne(v.numGlyphs,p);else{m=!1;var y=[v.anchorX,v.anchorY,0,1];if(t.transformMat4(y,y,i),Qt(y,h)){var x=.5+y[3]/o.transform.cameraToCenterDistance*.5,b=t.evaluateSizeForFeature(c,u,v),w=s?b*x:b/x,E=new t.Point(v.anchorX,v.anchorY),T=Jt(E,a).point,I={},C=ie(v,w,!1,l,i,a,n,e.glyphOffsetArray,d,p,T,E,I,f);m=C.useVertical,(C.notEnoughRoom||m||C.needsFlipping&&ie(v,w,!0,l,i,a,n,e.glyphOffsetArray,d,p,T,E,I,f).notEnoughRoom)&&ne(v.numGlyphs,p);}else ne(v.numGlyphs,p);}}r?e.text.dynamicLayoutVertexBuffer.updateData(p):e.icon.dynamicLayoutVertexBuffer.updateData(p);}function te(t,e,i,o,r,a,n,s,l,c,u,h){var p=s.glyphStartIndex+s.numGlyphs,d=s.lineStartIndex,_=s.lineStartIndex+s.lineLength,f=e.getoffsetX(s.glyphStartIndex),m=e.getoffsetX(p-1),g=re(t*f,i,o,r,a,n,s.segment,d,_,l,c,u,h);if(!g)return null;var v=re(t*m,i,o,r,a,n,s.segment,d,_,l,c,u,h);return v?{first:g,last:v}:null}function ee(e,i,o,r){return e===t.WritingMode.horizontal&&Math.abs(o.y-i.y)>Math.abs(o.x-i.x)*r?{useVertical:!0}:(e===t.WritingMode.vertical?i.y<o.y:i.x>o.x)?{needsFlipping:!0}:null}function ie(e,i,o,r,a,n,s,l,c,u,h,p,d,_){var f,m=i/24,g=e.lineOffsetX*m,v=e.lineOffsetY*m;if(e.numGlyphs>1){var y=e.glyphStartIndex+e.numGlyphs,x=e.lineStartIndex,b=e.lineStartIndex+e.lineLength,w=te(m,l,g,v,o,h,p,e,c,n,d,!1);if(!w)return {notEnoughRoom:!0};var E=Jt(w.first.point,s).point,T=Jt(w.last.point,s).point;if(r&&!o){var I=ee(e.writingMode,E,T,_);if(I)return I}f=[w.first];for(var C=e.glyphStartIndex+1;C<y-1;C++)f.push(re(m*l.getoffsetX(C),g,v,o,h,p,e.segment,x,b,c,n,d,!1));f.push(w.last);}else{if(r&&!o){var S=Jt(p,a).point,P=e.lineStartIndex+e.segment+1,z=new t.Point(c.getx(P),c.gety(P)),L=Jt(z,a),M=L.signedDistanceFromCamera>0?L.point:oe(p,z,S,1,a),D=ee(e.writingMode,S,M,_);if(D)return D}var A=re(m*l.getoffsetX(e.glyphStartIndex),g,v,o,h,p,e.segment,e.lineStartIndex,e.lineStartIndex+e.lineLength,c,n,d,!1);if(!A)return {notEnoughRoom:!0};f=[A];}for(var R=0,k=f;R<k.length;R+=1){var B=k[R];t.addDynamicAttributes(u,B.point,B.angle);}return {}}function oe(t,e,i,o,r){var a=Jt(t.add(t.sub(e)._unit()),r).point,n=i.sub(a);return i.add(n._mult(o/n.mag()))}function re(e,i,o,r,a,n,s,l,c,u,h,p,d){var _=r?e-i:e+i,f=_>0?1:-1,m=0;r&&(f*=-1,m=Math.PI),f<0&&(m+=Math.PI);for(var g=f>0?l+s:l+s+1,v=g,y=a,x=a,b=0,w=0,E=Math.abs(_);b+w<=E;){if((g+=f)<l||g>=c)return null;if(x=y,void 0===(y=p[g])){var T=new t.Point(u.getx(g),u.gety(g)),I=Jt(T,h);if(I.signedDistanceFromCamera>0)y=p[g]=I.point;else{var C=g-f;y=oe(0===b?n:new t.Point(u.getx(C),u.gety(C)),T,x,E-b+1,h);}}b+=w,w=x.dist(y);}var S=(E-b)/w,P=y.sub(x),z=P.mult(S)._add(x);return z._add(P._unit()._perp()._mult(o*f)),{point:z,angle:m+Math.atan2(y.y-x.y,y.x-x.x),tileDistance:d?{prevTileDistance:g-f===v?0:u.gettileUnitDistanceFromAnchor(g-f),lastSegmentViewportDistance:E-b}:null}}Ht.prototype.keysLength=function(){return this.boxKeys.length+this.circleKeys.length},Ht.prototype.insert=function(t,e,i,o,r){this._forEachCell(e,i,o,r,this._insertBoxCell,this.boxUid++),this.boxKeys.push(t),this.bboxes.push(e),this.bboxes.push(i),this.bboxes.push(o),this.bboxes.push(r);},Ht.prototype.insertCircle=function(t,e,i,o){this._forEachCell(e-o,i-o,e+o,i+o,this._insertCircleCell,this.circleUid++),this.circleKeys.push(t),this.circles.push(e),this.circles.push(i),this.circles.push(o);},Ht.prototype._insertBoxCell=function(t,e,i,o,r,a){this.boxCells[r].push(a);},Ht.prototype._insertCircleCell=function(t,e,i,o,r,a){this.circleCells[r].push(a);},Ht.prototype._query=function(t,e,i,o,r,a){if(i<0||t>this.width||o<0||e>this.height)return !r&&[];var n=[];if(t<=0&&e<=0&&this.width<=i&&this.height<=o){if(r)return !0;for(var s=0;s<this.boxKeys.length;s++)n.push({key:this.boxKeys[s],x1:this.bboxes[4*s],y1:this.bboxes[4*s+1],x2:this.bboxes[4*s+2],y2:this.bboxes[4*s+3]});for(var l=0;l<this.circleKeys.length;l++){var c=this.circles[3*l],u=this.circles[3*l+1],h=this.circles[3*l+2];n.push({key:this.circleKeys[l],x1:c-h,y1:u-h,x2:c+h,y2:u+h});}return a?n.filter(a):n}return this._forEachCell(t,e,i,o,this._queryCell,n,{hitTest:r,seenUids:{box:{},circle:{}}},a),r?n.length>0:n},Ht.prototype._queryCircle=function(t,e,i,o,r){var a=t-i,n=t+i,s=e-i,l=e+i;if(n<0||a>this.width||l<0||s>this.height)return !o&&[];var c=[];return this._forEachCell(a,s,n,l,this._queryCellCircle,c,{hitTest:o,circle:{x:t,y:e,radius:i},seenUids:{box:{},circle:{}}},r),o?c.length>0:c},Ht.prototype.query=function(t,e,i,o,r){return this._query(t,e,i,o,!1,r)},Ht.prototype.hitTest=function(t,e,i,o,r){return this._query(t,e,i,o,!0,r)},Ht.prototype.hitTestCircle=function(t,e,i,o){return this._queryCircle(t,e,i,!0,o)},Ht.prototype._queryCell=function(t,e,i,o,r,a,n,s){var l=n.seenUids,c=this.boxCells[r];if(null!==c)for(var u=this.bboxes,h=0,p=c;h<p.length;h+=1){var d=p[h];if(!l.box[d]){l.box[d]=!0;var _=4*d;if(t<=u[_+2]&&e<=u[_+3]&&i>=u[_+0]&&o>=u[_+1]&&(!s||s(this.boxKeys[d]))){if(n.hitTest)return a.push(!0),!0;a.push({key:this.boxKeys[d],x1:u[_],y1:u[_+1],x2:u[_+2],y2:u[_+3]});}}}var f=this.circleCells[r];if(null!==f)for(var m=this.circles,g=0,v=f;g<v.length;g+=1){var y=v[g];if(!l.circle[y]){l.circle[y]=!0;var x=3*y;if(this._circleAndRectCollide(m[x],m[x+1],m[x+2],t,e,i,o)&&(!s||s(this.circleKeys[y]))){if(n.hitTest)return a.push(!0),!0;var b=m[x],w=m[x+1],E=m[x+2];a.push({key:this.circleKeys[y],x1:b-E,y1:w-E,x2:b+E,y2:w+E});}}}},Ht.prototype._queryCellCircle=function(t,e,i,o,r,a,n,s){var l=n.circle,c=n.seenUids,u=this.boxCells[r];if(null!==u)for(var h=this.bboxes,p=0,d=u;p<d.length;p+=1){var _=d[p];if(!c.box[_]){c.box[_]=!0;var f=4*_;if(this._circleAndRectCollide(l.x,l.y,l.radius,h[f+0],h[f+1],h[f+2],h[f+3])&&(!s||s(this.boxKeys[_])))return a.push(!0),!0}}var m=this.circleCells[r];if(null!==m)for(var g=this.circles,v=0,y=m;v<y.length;v+=1){var x=y[v];if(!c.circle[x]){c.circle[x]=!0;var b=3*x;if(this._circlesCollide(g[b],g[b+1],g[b+2],l.x,l.y,l.radius)&&(!s||s(this.circleKeys[x])))return a.push(!0),!0}}},Ht.prototype._forEachCell=function(t,e,i,o,r,a,n,s){for(var l=this._convertToXCellCoord(t),c=this._convertToYCellCoord(e),u=this._convertToXCellCoord(i),h=this._convertToYCellCoord(o),p=l;p<=u;p++)for(var d=c;d<=h;d++)if(r.call(this,t,e,i,o,this.xCellCount*d+p,a,n,s))return},Ht.prototype._convertToXCellCoord=function(t){return Math.max(0,Math.min(this.xCellCount-1,Math.floor(t*this.xScale)))},Ht.prototype._convertToYCellCoord=function(t){return Math.max(0,Math.min(this.yCellCount-1,Math.floor(t*this.yScale)))},Ht.prototype._circlesCollide=function(t,e,i,o,r,a){var n=o-t,s=r-e,l=i+a;return l*l>n*n+s*s},Ht.prototype._circleAndRectCollide=function(t,e,i,o,r,a,n){var s=(a-o)/2,l=Math.abs(t-(o+s));if(l>s+i)return !1;var c=(n-r)/2,u=Math.abs(e-(r+c));if(u>c+i)return !1;if(l<=s||u<=c)return !0;var h=l-s,p=u-c;return h*h+p*p<=i*i};var ae=new Float32Array([-1/0,-1/0,0,-1/0,-1/0,0,-1/0,-1/0,0,-1/0,-1/0,0]);function ne(t,e){for(var i=0;i<t;i++){var o=e.length;e.resize(o+4),e.float32.set(ae,3*o);}}function se(t,e,i){var o=e[0],r=e[1];return t[0]=i[0]*o+i[4]*r+i[12],t[1]=i[1]*o+i[5]*r+i[13],t[3]=i[3]*o+i[7]*r+i[15],t}var le=function(t,e,i){void 0===e&&(e=new Ht(t.width+200,t.height+200,25)),void 0===i&&(i=new Ht(t.width+200,t.height+200,25)),this.transform=t,this.grid=e,this.ignoredGrid=i,this.pitchfactor=Math.cos(t._pitch)*t.cameraToCenterDistance,this.screenRightBoundary=t.width+100,this.screenBottomBoundary=t.height+100,this.gridRightBoundary=t.width+200,this.gridBottomBoundary=t.height+200;};function ce(t,e,i){t[e+4]=i?1:0;}function ue(e,i,o){return i*(t.EXTENT/(e.tileSize*Math.pow(2,o-e.tileID.overscaledZ)))}le.prototype.placeCollisionBox=function(t,e,i,o,r){var a=this.projectAndGetPerspectiveRatio(o,t.anchorPointX,t.anchorPointY),n=i*a.perspectiveRatio,s=t.x1*n+a.point.x,l=t.y1*n+a.point.y,c=t.x2*n+a.point.x,u=t.y2*n+a.point.y;return !this.isInsideGrid(s,l,c,u)||!e&&this.grid.hitTest(s,l,c,u,r)?{box:[],offscreen:!1}:{box:[s,l,c,u],offscreen:this.isOffscreen(s,l,c,u)}},le.prototype.approximateTileDistance=function(t,e,i,o,r){var a=t.lastSegmentViewportDistance*i;return t.prevTileDistance+a+((r?1:o/this.pitchfactor)-1)*a*Math.abs(Math.sin(e))},le.prototype.placeCollisionCircles=function(e,i,o,r,a,n,s,l,c,u,h,p,d){var _=[],f=this.projectAnchor(c,a.anchorX,a.anchorY),m=l/24,g=a.lineOffsetX*l,v=a.lineOffsetY*l,y=new t.Point(a.anchorX,a.anchorY),x=te(m,s,g,v,!1,Jt(y,u).point,y,a,n,u,{},!0),b=!1,w=!1,E=!0,T=f.perspectiveRatio*r,I=1/(r*o),C=0,S=0;x&&(C=this.approximateTileDistance(x.first.tileDistance,x.first.angle,I,f.cameraDistance,p),S=this.approximateTileDistance(x.last.tileDistance,x.last.angle,I,f.cameraDistance,p));for(var P=0;P<e.length;P+=5){var z=e[P],L=e[P+1],M=e[P+2],D=e[P+3];if(!x||D<-C||D>S)ce(e,P,!1);else{var A=this.projectPoint(c,z,L),R=M*T;if(_.length>0){var k=A.x-_[_.length-4],B=A.y-_[_.length-3];if(R*R*2>k*k+B*B&&P+8<e.length){var O=e[P+8];if(O>-C&&O<S){ce(e,P,!1);continue}}}_.push(A.x,A.y,R,P/5),ce(e,P,!0);var F=A.x-R,U=A.y-R,N=A.x+R,Z=A.y+R;if(E=E&&this.isOffscreen(F,U,N,Z),w=w||this.isInsideGrid(F,U,N,Z),!i&&this.grid.hitTestCircle(A.x,A.y,R,d)){if(!h)return {circles:[],offscreen:!1};b=!0;}}}return {circles:b||!w?[]:_,offscreen:E}},le.prototype.queryRenderedSymbols=function(e){if(0===e.length||0===this.grid.keysLength()&&0===this.ignoredGrid.keysLength())return {};for(var i=[],o=1/0,r=1/0,a=-1/0,n=-1/0,s=0,l=e;s<l.length;s+=1){var c=l[s],u=new t.Point(c.x+100,c.y+100);o=Math.min(o,u.x),r=Math.min(r,u.y),a=Math.max(a,u.x),n=Math.max(n,u.y),i.push(u);}for(var h={},p={},d=0,_=this.grid.query(o,r,a,n).concat(this.ignoredGrid.query(o,r,a,n));d<_.length;d+=1){var f=_[d],m=f.key;if(void 0===h[m.bucketInstanceId]&&(h[m.bucketInstanceId]={}),!h[m.bucketInstanceId][m.featureIndex]){var g=[new t.Point(f.x1,f.y1),new t.Point(f.x2,f.y1),new t.Point(f.x2,f.y2),new t.Point(f.x1,f.y2)];t.polygonIntersectsPolygon(i,g)&&(h[m.bucketInstanceId][m.featureIndex]=!0,void 0===p[m.bucketInstanceId]&&(p[m.bucketInstanceId]=[]),p[m.bucketInstanceId].push(m.featureIndex));}}return p},le.prototype.insertCollisionBox=function(t,e,i,o,r){(e?this.ignoredGrid:this.grid).insert({bucketInstanceId:i,featureIndex:o,collisionGroupID:r},t[0],t[1],t[2],t[3]);},le.prototype.insertCollisionCircles=function(t,e,i,o,r){for(var a=e?this.ignoredGrid:this.grid,n={bucketInstanceId:i,featureIndex:o,collisionGroupID:r},s=0;s<t.length;s+=4)a.insertCircle(n,t[s],t[s+1],t[s+2]);},le.prototype.projectAnchor=function(t,e,i){var o=[e,i,0,1];return se(o,o,t),{perspectiveRatio:.5+this.transform.cameraToCenterDistance/o[3]*.5,cameraDistance:o[3]}},le.prototype.projectPoint=function(e,i,o){var r=[i,o,0,1];return se(r,r,e),new t.Point((r[0]/r[3]+1)/2*this.transform.width+100,(-r[1]/r[3]+1)/2*this.transform.height+100)},le.prototype.projectAndGetPerspectiveRatio=function(e,i,o){var r=[i,o,0,1];return se(r,r,e),{point:new t.Point((r[0]/r[3]+1)/2*this.transform.width+100,(-r[1]/r[3]+1)/2*this.transform.height+100),perspectiveRatio:.5+this.transform.cameraToCenterDistance/r[3]*.5}},le.prototype.isOffscreen=function(t,e,i,o){return i<100||t>=this.screenRightBoundary||o<100||e>this.screenBottomBoundary},le.prototype.isInsideGrid=function(t,e,i,o){return i>=0&&t<this.gridRightBoundary&&o>=0&&e<this.gridBottomBoundary};var he=function(t,e,i,o){this.opacity=t?Math.max(0,Math.min(1,t.opacity+(t.placed?e:-e))):o&&i?1:0,this.placed=i;};he.prototype.isHidden=function(){return 0===this.opacity&&!this.placed};var pe=function(t,e,i,o,r){this.text=new he(t?t.text:null,e,i,r),this.icon=new he(t?t.icon:null,e,o,r);};pe.prototype.isHidden=function(){return this.text.isHidden()&&this.icon.isHidden()};var de=function(t,e,i){this.text=t,this.icon=e,this.skipFade=i;},_e=function(t,e,i,o,r){this.bucketInstanceId=t,this.featureIndex=e,this.sourceLayerIndex=i,this.bucketIndex=o,this.tileID=r;},fe=function(t){this.crossSourceCollisions=t,this.maxGroupID=0,this.collisionGroups={};};function me(e,i,o,r,a){var n=t.getAnchorAlignment(e),s=-(n.horizontalAlign-.5)*i,l=-(n.verticalAlign-.5)*o,c=t.evaluateVariableOffset(e,r);return new t.Point(s+c[0]*a,l+c[1]*a)}function ge(e,i,o,r,a,n){var s=e.x1,l=e.x2,c=e.y1,u=e.y2,h=e.anchorPointX,p=e.anchorPointY,d=new t.Point(i,o);return r&&d._rotate(a?n:-n),{x1:s+d.x,y1:c+d.y,x2:l+d.x,y2:u+d.y,anchorPointX:h,anchorPointY:p}}fe.prototype.get=function(t){if(this.crossSourceCollisions)return {ID:0,predicate:null};if(!this.collisionGroups[t]){var e=++this.maxGroupID;this.collisionGroups[t]={ID:e,predicate:function(t){return t.collisionGroupID===e}};}return this.collisionGroups[t]};var ve=function(t,e,i,o){this.transform=t.clone(),this.collisionIndex=new le(this.transform),this.placements={},this.opacities={},this.variableOffsets={},this.stale=!1,this.commitTime=0,this.fadeDuration=e,this.retainedQueryData={},this.collisionGroups=new fe(i),this.prevPlacement=o,o&&(o.prevPlacement=void 0),this.placedOrientations={};};function ye(t,e,i,o,r){t.emplaceBack(e?1:0,i?1:0,o||0,r||0),t.emplaceBack(e?1:0,i?1:0,o||0,r||0),t.emplaceBack(e?1:0,i?1:0,o||0,r||0),t.emplaceBack(e?1:0,i?1:0,o||0,r||0);}ve.prototype.getBucketParts=function(e,i,o,r){var a=o.getBucket(i),n=o.latestFeatureIndex;if(a&&n&&i.id===a.layerIds[0]){var s=o.collisionBoxArray,l=a.layers[0].layout,c=Math.pow(2,this.transform.zoom-o.tileID.overscaledZ),u=o.tileSize/t.EXTENT,h=this.transform.calculatePosMatrix(o.tileID.toUnwrapped()),p=Kt(h,"map"===l.get("text-pitch-alignment"),"map"===l.get("text-rotation-alignment"),this.transform,ue(o,1,this.transform.zoom));this.retainedQueryData[a.bucketInstanceId]=new _e(a.bucketInstanceId,n,a.sourceLayerIndex,a.index,o.tileID);var d={bucket:a,layout:l,posMatrix:h,textLabelPlaneMatrix:p,scale:c,textPixelRatio:u,holdingForFade:o.holdingForFade(),collisionBoxArray:s,partiallyEvaluatedTextSize:t.evaluateSizeForZoom(a.textSizeData,this.transform.zoom),collisionGroup:this.collisionGroups.get(a.sourceID)};if(r)for(var _=0,f=a.sortKeyRanges;_<f.length;_+=1){var m=f[_];e.push({sortKey:m.sortKey,symbolInstanceStart:m.symbolInstanceStart,symbolInstanceEnd:m.symbolInstanceEnd,parameters:d});}else e.push({symbolInstanceStart:0,symbolInstanceEnd:a.symbolInstances.length,parameters:d});}},ve.prototype.attemptAnchorPlacement=function(t,e,i,o,r,a,n,s,l,c,u,h,p,d,_){var f,m=[h.textOffset0,h.textOffset1],g=me(t,i,o,m,r),v=this.collisionIndex.placeCollisionBox(ge(e,g.x,g.y,a,n,this.transform.angle),u,s,l,c.predicate);if(!_||0!==this.collisionIndex.placeCollisionBox(ge(_,g.x,g.y,a,n,this.transform.angle),u,s,l,c.predicate).box.length)return v.box.length>0?(this.prevPlacement&&this.prevPlacement.variableOffsets[h.crossTileID]&&this.prevPlacement.placements[h.crossTileID]&&this.prevPlacement.placements[h.crossTileID].text&&(f=this.prevPlacement.variableOffsets[h.crossTileID].anchor),this.variableOffsets[h.crossTileID]={textOffset:m,width:i,height:o,anchor:t,textBoxScale:r,prevAnchor:f},this.markUsedJustification(p,t,h,d),p.allowVerticalPlacement&&(this.markUsedOrientation(p,d,h),this.placedOrientations[h.crossTileID]=d),{shift:g,placedGlyphBoxes:v}):void 0},ve.prototype.placeLayerBucketPart=function(e,i,o){var r=this,a=e.parameters,n=a.bucket,s=a.layout,l=a.posMatrix,c=a.textLabelPlaneMatrix,u=a.scale,h=a.textPixelRatio,p=a.holdingForFade,d=a.collisionBoxArray,_=a.partiallyEvaluatedTextSize,f=a.collisionGroup,m=s.get("text-optional"),g=s.get("icon-optional"),v=s.get("text-allow-overlap"),y=s.get("icon-allow-overlap"),x="map"===s.get("text-rotation-alignment"),b="map"===s.get("text-pitch-alignment"),w="none"!==s.get("icon-text-fit"),E="viewport-y"===s.get("symbol-z-order"),T=v&&(y||!n.hasIconData()||g),I=y&&(v||!n.hasTextData()||m);!n.collisionArrays&&d&&n.deserializeCollisionBoxes(d);var C=function(e,a){if(!i[e.crossTileID])if(p)r.placements[e.crossTileID]=new de(!1,!1,!1);else{var d,E=!1,C=!1,S=!0,P=null,z={box:null,offscreen:null},L={box:null,offscreen:null},M=null,D=null,A=0,R=0,k=0;a.textFeatureIndex&&(A=a.textFeatureIndex),a.verticalTextFeatureIndex&&(R=a.verticalTextFeatureIndex);var B=a.textBox;if(B){var O=function(i){var o=t.WritingMode.horizontal;if(n.allowVerticalPlacement&&!i&&r.prevPlacement){var a=r.prevPlacement.placedOrientations[e.crossTileID];a&&(r.placedOrientations[e.crossTileID]=a,r.markUsedOrientation(n,o=a,e));}return o},F=function(i,o){if(n.allowVerticalPlacement&&e.numVerticalGlyphVertices>0&&a.verticalTextBox)for(var r=0,s=n.writingModes;r<s.length&&(s[r]===t.WritingMode.vertical?(z=o(),L=z):z=i(),!(z&&z.box&&z.box.length));r+=1);else z=i();};if(s.get("text-variable-anchor")){var U=s.get("text-variable-anchor");if(r.prevPlacement&&r.prevPlacement.variableOffsets[e.crossTileID]){var N=r.prevPlacement.variableOffsets[e.crossTileID];U.indexOf(N.anchor)>0&&(U=U.filter((function(t){return t!==N.anchor}))).unshift(N.anchor);}var Z=function(t,i,o){for(var a=t.x2-t.x1,s=t.y2-t.y1,c=e.textBoxScale,u=w&&!y?i:null,p={box:[],offscreen:!1},d=v?2*U.length:U.length,_=0;_<d;++_){var m=r.attemptAnchorPlacement(U[_%U.length],t,a,s,c,x,b,h,l,f,_>=U.length,e,n,o,u);if(m&&(p=m.placedGlyphBoxes)&&p.box&&p.box.length){E=!0,P=m.shift;break}}return p};F((function(){return Z(B,a.iconBox,t.WritingMode.horizontal)}),(function(){var i=a.verticalTextBox;return n.allowVerticalPlacement&&!(z&&z.box&&z.box.length)&&e.numVerticalGlyphVertices>0&&i?Z(i,a.verticalIconBox,t.WritingMode.vertical):{box:null,offscreen:null}})),z&&(E=z.box,S=z.offscreen);var q=O(z&&z.box);if(!E&&r.prevPlacement){var j=r.prevPlacement.variableOffsets[e.crossTileID];j&&(r.variableOffsets[e.crossTileID]=j,r.markUsedJustification(n,j.anchor,e,q));}}else{var V=function(t,i){var o=r.collisionIndex.placeCollisionBox(t,v,h,l,f.predicate);return o&&o.box&&o.box.length&&(r.markUsedOrientation(n,i,e),r.placedOrientations[e.crossTileID]=i),o};F((function(){return V(B,t.WritingMode.horizontal)}),(function(){var i=a.verticalTextBox;return n.allowVerticalPlacement&&e.numVerticalGlyphVertices>0&&i?V(i,t.WritingMode.vertical):{box:null,offscreen:null}})),O(z&&z.box&&z.box.length);}}E=(d=z)&&d.box&&d.box.length>0,S=d&&d.offscreen;var G=a.textCircles;if(G){var W=n.text.placedSymbolArray.get(e.centerJustifiedTextSymbolIndex),X=t.evaluateSizeForFeature(n.textSizeData,_,W);M=r.collisionIndex.placeCollisionCircles(G,v,u,h,W,n.lineVertexArray,n.glyphOffsetArray,X,l,c,o,b,f.predicate),E=v||M.circles.length>0,S=S&&M.offscreen;}if(a.iconFeatureIndex&&(k=a.iconFeatureIndex),a.iconBox){var H=function(t){var e=w&&P?ge(t,P.x,P.y,x,b,r.transform.angle):t;return r.collisionIndex.placeCollisionBox(e,y,h,l,f.predicate)};C=L&&L.box&&L.box.length&&a.verticalIconBox?(D=H(a.verticalIconBox)).box.length>0:(D=H(a.iconBox)).box.length>0,S=S&&D.offscreen;}var K=m||0===e.numHorizontalGlyphVertices&&0===e.numVerticalGlyphVertices,Y=g||0===e.numIconVertices;K||Y?Y?K||(C=C&&E):E=C&&E:C=E=C&&E,E&&d&&d.box&&r.collisionIndex.insertCollisionBox(d.box,s.get("text-ignore-placement"),n.bucketInstanceId,L&&L.box&&R?R:A,f.ID),C&&D&&r.collisionIndex.insertCollisionBox(D.box,s.get("icon-ignore-placement"),n.bucketInstanceId,k,f.ID),E&&M&&r.collisionIndex.insertCollisionCircles(M.circles,s.get("text-ignore-placement"),n.bucketInstanceId,A,f.ID),r.placements[e.crossTileID]=new de(E||T,C||I,S||n.justReloaded),i[e.crossTileID]=!0;}};if(E)for(var S=n.getSortedSymbolIndexes(this.transform.angle),P=S.length-1;P>=0;--P){var z=S[P];C(n.symbolInstances.get(z),n.collisionArrays[z]);}else for(var L=e.symbolInstanceStart;L<e.symbolInstanceEnd;L++)C(n.symbolInstances.get(L),n.collisionArrays[L]);n.justReloaded=!1;},ve.prototype.markUsedJustification=function(e,i,o,r){var a;a=r===t.WritingMode.vertical?o.verticalPlacedTextSymbolIndex:{left:o.leftJustifiedTextSymbolIndex,center:o.centerJustifiedTextSymbolIndex,right:o.rightJustifiedTextSymbolIndex}[t.getAnchorJustification(i)];for(var n=0,s=[o.leftJustifiedTextSymbolIndex,o.centerJustifiedTextSymbolIndex,o.rightJustifiedTextSymbolIndex,o.verticalPlacedTextSymbolIndex];n<s.length;n+=1){var l=s[n];l>=0&&(e.text.placedSymbolArray.get(l).crossTileID=a>=0&&l!==a?0:o.crossTileID);}},ve.prototype.markUsedOrientation=function(e,i,o){for(var r=i===t.WritingMode.horizontal||i===t.WritingMode.horizontalOnly?i:0,a=i===t.WritingMode.vertical?i:0,n=0,s=[o.leftJustifiedTextSymbolIndex,o.centerJustifiedTextSymbolIndex,o.rightJustifiedTextSymbolIndex];n<s.length;n+=1)e.text.placedSymbolArray.get(s[n]).placedOrientation=r;o.verticalPlacedTextSymbolIndex&&(e.text.placedSymbolArray.get(o.verticalPlacedTextSymbolIndex).placedOrientation=a);},ve.prototype.commit=function(t){this.commitTime=t,this.zoomAtLastRecencyCheck=this.transform.zoom;var e=this.prevPlacement,i=!1;this.prevZoomAdjustment=e?e.zoomAdjustment(this.transform.zoom):0;var o=e?e.symbolFadeChange(t):1,r=e?e.opacities:{},a=e?e.variableOffsets:{},n=e?e.placedOrientations:{};for(var s in this.placements){var l=this.placements[s],c=r[s];c?(this.opacities[s]=new pe(c,o,l.text,l.icon),i=i||l.text!==c.text.placed||l.icon!==c.icon.placed):(this.opacities[s]=new pe(null,o,l.text,l.icon,l.skipFade),i=i||l.text||l.icon);}for(var u in r){var h=r[u];if(!this.opacities[u]){var p=new pe(h,o,!1,!1);p.isHidden()||(this.opacities[u]=p,i=i||h.text.placed||h.icon.placed);}}for(var d in a)this.variableOffsets[d]||!this.opacities[d]||this.opacities[d].isHidden()||(this.variableOffsets[d]=a[d]);for(var _ in n)this.placedOrientations[_]||!this.opacities[_]||this.opacities[_].isHidden()||(this.placedOrientations[_]=n[_]);i?this.lastPlacementChangeTime=t:"number"!=typeof this.lastPlacementChangeTime&&(this.lastPlacementChangeTime=e?e.lastPlacementChangeTime:t);},ve.prototype.updateLayerOpacities=function(t,e){for(var i={},o=0,r=e;o<r.length;o+=1){var a=r[o],n=a.getBucket(t);n&&a.latestFeatureIndex&&t.id===n.layerIds[0]&&this.updateBucketOpacities(n,i,a.collisionBoxArray);}},ve.prototype.updateBucketOpacities=function(e,i,o){var r=this;e.hasTextData()&&e.text.opacityVertexArray.clear(),e.hasIconData()&&e.icon.opacityVertexArray.clear(),e.hasIconCollisionBoxData()&&e.iconCollisionBox.collisionVertexArray.clear(),e.hasTextCollisionBoxData()&&e.textCollisionBox.collisionVertexArray.clear(),e.hasIconCollisionCircleData()&&e.iconCollisionCircle.collisionVertexArray.clear(),e.hasTextCollisionCircleData()&&e.textCollisionCircle.collisionVertexArray.clear();var a=e.layers[0].layout,n=new pe(null,0,!1,!1,!0),s=a.get("text-allow-overlap"),l=a.get("icon-allow-overlap"),c=a.get("text-variable-anchor"),u="map"===a.get("text-rotation-alignment"),h="map"===a.get("text-pitch-alignment"),p="none"!==a.get("icon-text-fit"),d=new pe(null,0,s&&(l||!e.hasIconData()||a.get("icon-optional")),l&&(s||!e.hasTextData()||a.get("text-optional")),!0);!e.collisionArrays&&o&&(e.hasIconCollisionBoxData()||e.hasIconCollisionCircleData()||e.hasTextCollisionBoxData()||e.hasTextCollisionCircleData())&&e.deserializeCollisionBoxes(o);for(var _=function(t,e,i){for(var o=0;o<e/4;o++)t.opacityVertexArray.emplaceBack(i);},f=function(o){var a=e.symbolInstances.get(o),s=a.numHorizontalGlyphVertices,l=a.numVerticalGlyphVertices,f=a.crossTileID,m=i[f],g=r.opacities[f];m?g=n:g||(r.opacities[f]=g=d),i[f]=!0;var v=a.numIconVertices>0,y=r.placedOrientations[a.crossTileID],x=y===t.WritingMode.vertical,b=y===t.WritingMode.horizontal||y===t.WritingMode.horizontalOnly;if(s>0||l>0){var w=Se(g.text);_(e.text,s,x?Pe:w),_(e.text,l,b?Pe:w);var E=g.text.isHidden();[a.rightJustifiedTextSymbolIndex,a.centerJustifiedTextSymbolIndex,a.leftJustifiedTextSymbolIndex].forEach((function(t){t>=0&&(e.text.placedSymbolArray.get(t).hidden=E||x?1:0);})),a.verticalPlacedTextSymbolIndex>=0&&(e.text.placedSymbolArray.get(a.verticalPlacedTextSymbolIndex).hidden=E||b?1:0);var T=r.variableOffsets[a.crossTileID];T&&r.markUsedJustification(e,T.anchor,a,y);var I=r.placedOrientations[a.crossTileID];I&&(r.markUsedJustification(e,"left",a,I),r.markUsedOrientation(e,I,a));}if(v){var C=Se(g.icon),S=!(p&&a.verticalPlacedIconSymbolIndex&&x);a.placedIconSymbolIndex>=0&&(_(e.icon,a.numIconVertices,S?C:Pe),e.icon.placedSymbolArray.get(a.placedIconSymbolIndex).hidden=g.icon.isHidden()),a.verticalPlacedIconSymbolIndex>=0&&(_(e.icon,a.numVerticalIconVertices,S?Pe:C),e.icon.placedSymbolArray.get(a.verticalPlacedIconSymbolIndex).hidden=g.icon.isHidden());}if(e.hasIconCollisionBoxData()||e.hasIconCollisionCircleData()||e.hasTextCollisionBoxData()||e.hasTextCollisionCircleData()){var P=e.collisionArrays[o];if(P){var z=new t.Point(0,0);if(P.textBox||P.verticalTextBox){var L=!0;if(c){var M=r.variableOffsets[f];M?(z=me(M.anchor,M.width,M.height,M.textOffset,M.textBoxScale),u&&z._rotate(h?r.transform.angle:-r.transform.angle)):L=!1;}P.textBox&&ye(e.textCollisionBox.collisionVertexArray,g.text.placed,!L||x,z.x,z.y),P.verticalTextBox&&ye(e.textCollisionBox.collisionVertexArray,g.text.placed,!L||b,z.x,z.y);}var D=Boolean(!b&&P.verticalIconBox);P.iconBox&&ye(e.iconCollisionBox.collisionVertexArray,g.icon.placed,D,p?z.x:0,p?z.y:0),P.verticalIconBox&&ye(e.iconCollisionBox.collisionVertexArray,g.icon.placed,!D,p?z.x:0,p?z.y:0);var A=P.textCircles;if(A&&e.hasTextCollisionCircleData())for(var R=0;R<A.length;R+=5)ye(e.textCollisionCircle.collisionVertexArray,g.text.placed,m||0===A[R+4]);}}},m=0;m<e.symbolInstances.length;m++)f(m);e.sortFeatures(this.transform.angle),this.retainedQueryData[e.bucketInstanceId]&&(this.retainedQueryData[e.bucketInstanceId].featureSortOrder=e.featureSortOrder),e.hasTextData()&&e.text.opacityVertexBuffer&&e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray),e.hasIconData()&&e.icon.opacityVertexBuffer&&e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray),e.hasIconCollisionBoxData()&&e.iconCollisionBox.collisionVertexBuffer&&e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray),e.hasTextCollisionBoxData()&&e.textCollisionBox.collisionVertexBuffer&&e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray),e.hasIconCollisionCircleData()&&e.iconCollisionCircle.collisionVertexBuffer&&e.iconCollisionCircle.collisionVertexBuffer.updateData(e.iconCollisionCircle.collisionVertexArray),e.hasTextCollisionCircleData()&&e.textCollisionCircle.collisionVertexBuffer&&e.textCollisionCircle.collisionVertexBuffer.updateData(e.textCollisionCircle.collisionVertexArray);},ve.prototype.symbolFadeChange=function(t){return 0===this.fadeDuration?1:(t-this.commitTime)/this.fadeDuration+this.prevZoomAdjustment},ve.prototype.zoomAdjustment=function(t){return Math.max(0,(this.transform.zoom-t)/1.5)},ve.prototype.hasTransitions=function(t){return this.stale||t-this.lastPlacementChangeTime<this.fadeDuration},ve.prototype.stillRecent=function(t,e){var i=this.zoomAtLastRecencyCheck===e?1-this.zoomAdjustment(e):1;return this.zoomAtLastRecencyCheck=e,this.commitTime+this.fadeDuration*i>t},ve.prototype.setStale=function(){this.stale=!0;};var xe=Math.pow(2,25),be=Math.pow(2,24),we=Math.pow(2,17),Ee=Math.pow(2,16),Te=Math.pow(2,9),Ie=Math.pow(2,8),Ce=Math.pow(2,1);function Se(t){if(0===t.opacity&&!t.placed)return 0;if(1===t.opacity&&t.placed)return 4294967295;var e=t.placed?1:0,i=Math.floor(127*t.opacity);return i*xe+e*be+i*we+e*Ee+i*Te+e*Ie+i*Ce+e}var Pe=0,ze=function(t){this._sortAcrossTiles="viewport-y"!==t.layout.get("symbol-z-order")&&void 0!==t.layout.get("symbol-sort-key").constantOr(1),this._currentTileIndex=0,this._currentPartIndex=0,this._seenCrossTileIDs={},this._bucketParts=[];};ze.prototype.continuePlacement=function(t,e,i,o,r){for(var a=this._bucketParts;this._currentTileIndex<t.length;)if(e.getBucketParts(a,o,t[this._currentTileIndex],this._sortAcrossTiles),this._currentTileIndex++,r())return !0;for(this._sortAcrossTiles&&(this._sortAcrossTiles=!1,a.sort((function(t,e){return t.sortKey-e.sortKey})));this._currentPartIndex<a.length;)if(e.placeLayerBucketPart(a[this._currentPartIndex],this._seenCrossTileIDs,i),this._currentPartIndex++,r())return !0;return !1};var Le=function(t,e,i,o,r,a,n){this.placement=new ve(t,r,a,n),this._currentPlacementIndex=e.length-1,this._forceFullPlacement=i,this._showCollisionBoxes=o,this._done=!1;};Le.prototype.isDone=function(){return this._done},Le.prototype.continuePlacement=function(e,i,o){for(var r=this,a=t.browser.now(),n=function(){var e=t.browser.now()-a;return !r._forceFullPlacement&&e>2};this._currentPlacementIndex>=0;){var s=i[e[this._currentPlacementIndex]],l=this.placement.collisionIndex.transform.zoom;if("symbol"===s.type&&(!s.minzoom||s.minzoom<=l)&&(!s.maxzoom||s.maxzoom>l)){if(this._inProgressLayer||(this._inProgressLayer=new ze(s)),this._inProgressLayer.continuePlacement(o[s.source],this.placement,this._showCollisionBoxes,s,n))return;delete this._inProgressLayer;}this._currentPlacementIndex--;}this._done=!0;},Le.prototype.commit=function(t){return this.placement.commit(t),this.placement};var Me=512/t.EXTENT/2,De=function(t,e,i){this.tileID=t,this.indexedSymbolInstances={},this.bucketInstanceId=i;for(var o=0;o<e.length;o++){var r=e.get(o),a=r.key;this.indexedSymbolInstances[a]||(this.indexedSymbolInstances[a]=[]),this.indexedSymbolInstances[a].push({crossTileID:r.crossTileID,coord:this.getScaledCoordinates(r,t)});}};De.prototype.getScaledCoordinates=function(e,i){var o=Me/Math.pow(2,i.canonical.z-this.tileID.canonical.z);return {x:Math.floor((i.canonical.x*t.EXTENT+e.anchorX)*o),y:Math.floor((i.canonical.y*t.EXTENT+e.anchorY)*o)}},De.prototype.findMatches=function(t,e,i){for(var o=this.tileID.canonical.z<e.canonical.z?1:Math.pow(2,this.tileID.canonical.z-e.canonical.z),r=0;r<t.length;r++){var a=t.get(r);if(!a.crossTileID){var n=this.indexedSymbolInstances[a.key];if(n)for(var s=this.getScaledCoordinates(a,e),l=0,c=n;l<c.length;l+=1){var u=c[l];if(Math.abs(u.coord.x-s.x)<=o&&Math.abs(u.coord.y-s.y)<=o&&!i[u.crossTileID]){i[u.crossTileID]=!0,a.crossTileID=u.crossTileID;break}}}}};var Ae=function(){this.maxCrossTileID=0;};Ae.prototype.generate=function(){return ++this.maxCrossTileID};var Re=function(){this.indexes={},this.usedCrossTileIDs={},this.lng=0;};Re.prototype.handleWrapJump=function(t){var e=Math.round((t-this.lng)/360);if(0!==e)for(var i in this.indexes){var o=this.indexes[i],r={};for(var a in o){var n=o[a];n.tileID=n.tileID.unwrapTo(n.tileID.wrap+e),r[n.tileID.key]=n;}this.indexes[i]=r;}this.lng=t;},Re.prototype.addBucket=function(t,e,i){if(this.indexes[t.overscaledZ]&&this.indexes[t.overscaledZ][t.key]){if(this.indexes[t.overscaledZ][t.key].bucketInstanceId===e.bucketInstanceId)return !1;this.removeBucketCrossTileIDs(t.overscaledZ,this.indexes[t.overscaledZ][t.key]);}for(var o=0;o<e.symbolInstances.length;o++)e.symbolInstances.get(o).crossTileID=0;this.usedCrossTileIDs[t.overscaledZ]||(this.usedCrossTileIDs[t.overscaledZ]={});var r=this.usedCrossTileIDs[t.overscaledZ];for(var a in this.indexes){var n=this.indexes[a];if(Number(a)>t.overscaledZ)for(var s in n){var l=n[s];l.tileID.isChildOf(t)&&l.findMatches(e.symbolInstances,t,r);}else{var c=n[t.scaledTo(Number(a)).key];c&&c.findMatches(e.symbolInstances,t,r);}}for(var u=0;u<e.symbolInstances.length;u++){var h=e.symbolInstances.get(u);h.crossTileID||(h.crossTileID=i.generate(),r[h.crossTileID]=!0);}return void 0===this.indexes[t.overscaledZ]&&(this.indexes[t.overscaledZ]={}),this.indexes[t.overscaledZ][t.key]=new De(t,e.symbolInstances,e.bucketInstanceId),!0},Re.prototype.removeBucketCrossTileIDs=function(t,e){for(var i in e.indexedSymbolInstances)for(var o=0,r=e.indexedSymbolInstances[i];o<r.length;o+=1)delete this.usedCrossTileIDs[t][r[o].crossTileID];},Re.prototype.removeStaleBuckets=function(t){var e=!1;for(var i in this.indexes){var o=this.indexes[i];for(var r in o)t[o[r].bucketInstanceId]||(this.removeBucketCrossTileIDs(i,o[r]),delete o[r],e=!0);}return e};var ke=function(){this.layerIndexes={},this.crossTileIDs=new Ae,this.maxBucketInstanceId=0,this.bucketsInCurrentPlacement={};};ke.prototype.addLayer=function(t,e,i){var o=this.layerIndexes[t.id];void 0===o&&(o=this.layerIndexes[t.id]=new Re);var r=!1,a={};o.handleWrapJump(i);for(var n=0,s=e;n<s.length;n+=1){var l=s[n],c=l.getBucket(t);c&&t.id===c.layerIds[0]&&(c.bucketInstanceId||(c.bucketInstanceId=++this.maxBucketInstanceId),o.addBucket(l.tileID,c,this.crossTileIDs)&&(r=!0),a[c.bucketInstanceId]=!0);}return o.removeStaleBuckets(a)&&(r=!0),r},ke.prototype.pruneUnusedLayers=function(t){var e={};for(var i in t.forEach((function(t){e[t]=!0;})),this.layerIndexes)e[i]||delete this.layerIndexes[i];};var Be=function(e,i){return t.emitValidationErrors(e,i&&i.filter((function(t){return "source.canvas"!==t.identifier})))},Oe=t.pick(Nt,["addLayer","removeLayer","setPaintProperty","setLayoutProperty","setFilter","addSource","removeSource","setLayerZoomRange","setLight","setTransition","setGeoJSONSourceData"]),Fe=t.pick(Nt,["setCenter","setZoom","setBearing","setPitch"]),Ue=function(){var e={},i=t.styleSpec.$version;for(var o in t.styleSpec.$root){var r,a=t.styleSpec.$root[o];if(a.required)null!=(r="version"===o?i:"array"===a.type?[]:{})&&(e[o]=r);}return e}(),Ne=function(e){function i(o,r){var a=this;void 0===r&&(r={}),e.call(this),this.map=o,this.dispatcher=new T((Bt||(Bt=new kt),Bt),this),this.imageManager=new p,this.imageManager.setEventedParent(this),this.glyphManager=new y(o._requestManager,r.localIdeographFontFamily),this.lineAtlas=new E(256,512),this.crossTileSymbolIndex=new ke,this._layers={},this._serializedLayers={},this._order=[],this.sourceCaches={},this.zoomHistory=new t.ZoomHistory,this._loaded=!1,this._availableImages=[],this._resetUpdates(),this.dispatcher.broadcast("setReferrer",t.getReferrer());var n=this;this._rtlTextPluginCallback=i.registerForPluginStateChange((function(e){n.dispatcher.broadcast("syncRTLPluginState",{pluginStatus:e.pluginStatus,pluginURL:e.pluginURL},(function(e,i){if(t.triggerPluginCompletionEvent(e),i&&i.every((function(t){return t})))for(var o in n.sourceCaches)n.sourceCaches[o].reload();}));})),this.on("data",(function(t){if("source"===t.dataType&&"metadata"===t.sourceDataType){var e=a.sourceCaches[t.sourceId];if(e){var i=e.getSource();if(i&&i.vectorLayerIds)for(var o in a._layers){var r=a._layers[o];r.source===i.id&&a._validateLayer(r);}}}}));}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.loadURL=function(e,i){var o=this;void 0===i&&(i={}),this.fire(new t.Event("dataloading",{dataType:"style"}));var r="boolean"==typeof i.validate?i.validate:!t.isMapboxURL(e);e=this.map._requestManager.normalizeStyleURL(e,i.accessToken);var a=this.map._requestManager.transformRequest(e,t.ResourceType.Style);this._request=t.getJSON(a,(function(e,i){o._request=null,e?o.fire(new t.ErrorEvent(e)):i&&o._load(i,r);}));},i.prototype.loadJSON=function(e,i){var o=this;void 0===i&&(i={}),this.fire(new t.Event("dataloading",{dataType:"style"})),this._request=t.browser.frame((function(){o._request=null,o._load(e,!1!==i.validate);}));},i.prototype.loadEmpty=function(){this.fire(new t.Event("dataloading",{dataType:"style"})),this._load(Ue,!1);},i.prototype._load=function(e,i){if(!i||!Be(this,t.validateStyle(e))){for(var o in this._loaded=!0,this.stylesheet=e,e.sources)this.addSource(o,e.sources[o],{validate:!1});e.sprite?this._loadSprite(e.sprite):this.imageManager.setLoaded(!0),this.glyphManager.setURL(e.glyphs);var r=Ut(this.stylesheet.layers);this._order=r.map((function(t){return t.id})),this._layers={},this._serializedLayers={};for(var a=0,n=r;a<n.length;a+=1){var s=n[a];(s=t.createStyleLayer(s)).setEventedParent(this,{layer:{id:s.id}}),this._layers[s.id]=s,this._serializedLayers[s.id]=s.serialize();}this.dispatcher.broadcast("setLayers",this._serializeLayers(this._order)),this.light=new w(this.stylesheet.light),this.fire(new t.Event("data",{dataType:"style"})),this.fire(new t.Event("style.load"));}},i.prototype._loadSprite=function(e){var i=this;this._spriteRequest=function(e,i,o){var r,a,n,s=t.browser.devicePixelRatio>1?"@2x":"",l=t.getJSON(i.transformRequest(i.normalizeSpriteURL(e,s,".json"),t.ResourceType.SpriteJSON),(function(t,e){l=null,n||(n=t,r=e,u());})),c=t.getImage(i.transformRequest(i.normalizeSpriteURL(e,s,".png"),t.ResourceType.SpriteImage),(function(t,e){c=null,n||(n=t,a=e,u());}));function u(){if(n)o(n);else if(r&&a){var e=t.browser.getImageData(a),i={};for(var s in r){var l=r[s],c=l.width,u=l.height,h=l.x,p=l.y,d=l.sdf,_=l.pixelRatio,f=l.stretchX,m=l.stretchY,g=l.content,v=new t.RGBAImage({width:c,height:u});t.RGBAImage.copy(e,v,{x:h,y:p},{x:0,y:0},{width:c,height:u}),i[s]={data:v,pixelRatio:_,sdf:d,stretchX:f,stretchY:m,content:g};}o(null,i);}}return {cancel:function(){l&&(l.cancel(),l=null),c&&(c.cancel(),c=null);}}}(e,this.map._requestManager,(function(e,o){if(i._spriteRequest=null,e)i.fire(new t.ErrorEvent(e));else if(o)for(var r in o)i.imageManager.addImage(r,o[r]);i.imageManager.setLoaded(!0),i._availableImages=i.imageManager.listImages(),i.dispatcher.broadcast("setImages",i._availableImages),i.fire(new t.Event("data",{dataType:"style"}));}));},i.prototype._validateLayer=function(e){var i=this.sourceCaches[e.source];if(i){var o=e.sourceLayer;if(o){var r=i.getSource();("geojson"===r.type||r.vectorLayerIds&&-1===r.vectorLayerIds.indexOf(o))&&this.fire(new t.ErrorEvent(new Error('Source layer "'+o+'" does not exist on source "'+r.id+'" as specified by style layer "'+e.id+'"')));}}},i.prototype.loaded=function(){if(!this._loaded)return !1;if(Object.keys(this._updatedSources).length)return !1;for(var t in this.sourceCaches)if(!this.sourceCaches[t].loaded())return !1;return !!this.imageManager.isLoaded()},i.prototype._serializeLayers=function(t){for(var e=[],i=0,o=t;i<o.length;i+=1){var r=this._layers[o[i]];"custom"!==r.type&&e.push(r.serialize());}return e},i.prototype.hasTransitions=function(){if(this.light&&this.light.hasTransition())return !0;for(var t in this.sourceCaches)if(this.sourceCaches[t].hasTransition())return !0;for(var e in this._layers)if(this._layers[e].hasTransition())return !0;return !1},i.prototype._checkLoaded=function(){if(!this._loaded)throw new Error("Style is not done loading")},i.prototype.update=function(e){if(this._loaded){var i=this._changed;if(this._changed){var o=Object.keys(this._updatedLayers),r=Object.keys(this._removedLayers);for(var a in (o.length||r.length)&&this._updateWorkerLayers(o,r),this._updatedSources){var n=this._updatedSources[a];"reload"===n?this._reloadSource(a):"clear"===n&&this._clearSource(a);}for(var s in this._updateTilesForChangedImages(),this._updatedPaintProps)this._layers[s].updateTransitions(e);this.light.updateTransitions(e),this._resetUpdates();}for(var l in this.sourceCaches)this.sourceCaches[l].used=!1;for(var c=0,u=this._order;c<u.length;c+=1){var h=this._layers[u[c]];h.recalculate(e,this._availableImages),!h.isHidden(e.zoom)&&h.source&&(this.sourceCaches[h.source].used=!0);}this.light.recalculate(e),this.z=e.zoom,i&&this.fire(new t.Event("data",{dataType:"style"}));}},i.prototype._updateTilesForChangedImages=function(){var t=Object.keys(this._changedImages);if(t.length){for(var e in this.sourceCaches)this.sourceCaches[e].reloadTilesForDependencies(["icons","patterns"],t);this._changedImages={};}},i.prototype._updateWorkerLayers=function(t,e){this.dispatcher.broadcast("updateLayers",{layers:this._serializeLayers(t),removedIds:e});},i.prototype._resetUpdates=function(){this._changed=!1,this._updatedLayers={},this._removedLayers={},this._updatedSources={},this._updatedPaintProps={},this._changedImages={};},i.prototype.setState=function(e){var i=this;if(this._checkLoaded(),Be(this,t.validateStyle(e)))return !1;(e=t.clone$1(e)).layers=Ut(e.layers);var o=function(e,i){if(!e)return [{command:Nt.setStyle,args:[i]}];var o=[];try{if(!t.deepEqual(e.version,i.version))return [{command:Nt.setStyle,args:[i]}];t.deepEqual(e.center,i.center)||o.push({command:Nt.setCenter,args:[i.center]}),t.deepEqual(e.zoom,i.zoom)||o.push({command:Nt.setZoom,args:[i.zoom]}),t.deepEqual(e.bearing,i.bearing)||o.push({command:Nt.setBearing,args:[i.bearing]}),t.deepEqual(e.pitch,i.pitch)||o.push({command:Nt.setPitch,args:[i.pitch]}),t.deepEqual(e.sprite,i.sprite)||o.push({command:Nt.setSprite,args:[i.sprite]}),t.deepEqual(e.glyphs,i.glyphs)||o.push({command:Nt.setGlyphs,args:[i.glyphs]}),t.deepEqual(e.transition,i.transition)||o.push({command:Nt.setTransition,args:[i.transition]}),t.deepEqual(e.light,i.light)||o.push({command:Nt.setLight,args:[i.light]});var r={},a=[];!function(e,i,o,r){var a;for(a in i=i||{},e=e||{})e.hasOwnProperty(a)&&(i.hasOwnProperty(a)||qt(a,o,r));for(a in i)i.hasOwnProperty(a)&&(e.hasOwnProperty(a)?t.deepEqual(e[a],i[a])||("geojson"===e[a].type&&"geojson"===i[a].type&&Vt(e,i,a)?o.push({command:Nt.setGeoJSONSourceData,args:[a,i[a].data]}):jt(a,i,o,r)):Zt(a,i,o));}(e.sources,i.sources,a,r);var n=[];e.layers&&e.layers.forEach((function(t){r[t.source]?o.push({command:Nt.removeLayer,args:[t.id]}):n.push(t);})),o=o.concat(a),function(e,i,o){i=i||[];var r,a,n,s,l,c,u,h=(e=e||[]).map(Wt),p=i.map(Wt),d=e.reduce(Xt,{}),_=i.reduce(Xt,{}),f=h.slice(),m=Object.create(null);for(r=0,a=0;r<h.length;r++)_.hasOwnProperty(n=h[r])?a++:(o.push({command:Nt.removeLayer,args:[n]}),f.splice(f.indexOf(n,a),1));for(r=0,a=0;r<p.length;r++)f[f.length-1-r]!==(n=p[p.length-1-r])&&(d.hasOwnProperty(n)?(o.push({command:Nt.removeLayer,args:[n]}),f.splice(f.lastIndexOf(n,f.length-a),1)):a++,o.push({command:Nt.addLayer,args:[_[n],c=f[f.length-r]]}),f.splice(f.length-r,0,n),m[n]=!0);for(r=0;r<p.length;r++)if(s=d[n=p[r]],l=_[n],!m[n]&&!t.deepEqual(s,l))if(t.deepEqual(s.source,l.source)&&t.deepEqual(s["source-layer"],l["source-layer"])&&t.deepEqual(s.type,l.type)){for(u in Gt(s.layout,l.layout,o,n,null,Nt.setLayoutProperty),Gt(s.paint,l.paint,o,n,null,Nt.setPaintProperty),t.deepEqual(s.filter,l.filter)||o.push({command:Nt.setFilter,args:[n,l.filter]}),t.deepEqual(s.minzoom,l.minzoom)&&t.deepEqual(s.maxzoom,l.maxzoom)||o.push({command:Nt.setLayerZoomRange,args:[n,l.minzoom,l.maxzoom]}),s)s.hasOwnProperty(u)&&"layout"!==u&&"paint"!==u&&"filter"!==u&&"metadata"!==u&&"minzoom"!==u&&"maxzoom"!==u&&(0===u.indexOf("paint.")?Gt(s[u],l[u],o,n,u.slice(6),Nt.setPaintProperty):t.deepEqual(s[u],l[u])||o.push({command:Nt.setLayerProperty,args:[n,u,l[u]]}));for(u in l)l.hasOwnProperty(u)&&!s.hasOwnProperty(u)&&"layout"!==u&&"paint"!==u&&"filter"!==u&&"metadata"!==u&&"minzoom"!==u&&"maxzoom"!==u&&(0===u.indexOf("paint.")?Gt(s[u],l[u],o,n,u.slice(6),Nt.setPaintProperty):t.deepEqual(s[u],l[u])||o.push({command:Nt.setLayerProperty,args:[n,u,l[u]]}));}else o.push({command:Nt.removeLayer,args:[n]}),c=f[f.lastIndexOf(n)+1],o.push({command:Nt.addLayer,args:[l,c]});}(n,i.layers,o);}catch(t){console.warn("Unable to compute style diff:",t),o=[{command:Nt.setStyle,args:[i]}];}return o}(this.serialize(),e).filter((function(t){return !(t.command in Fe)}));if(0===o.length)return !1;var r=o.filter((function(t){return !(t.command in Oe)}));if(r.length>0)throw new Error("Unimplemented: "+r.map((function(t){return t.command})).join(", ")+".");return o.forEach((function(t){"setTransition"!==t.command&&i[t.command].apply(i,t.args);})),this.stylesheet=e,!0},i.prototype.addImage=function(e,i){if(this.getImage(e))return this.fire(new t.ErrorEvent(new Error("An image with this name already exists.")));this.imageManager.addImage(e,i),this._availableImages=this.imageManager.listImages(),this._changedImages[e]=!0,this._changed=!0,this.fire(new t.Event("data",{dataType:"style"}));},i.prototype.updateImage=function(t,e){this.imageManager.updateImage(t,e);},i.prototype.getImage=function(t){return this.imageManager.getImage(t)},i.prototype.removeImage=function(e){if(!this.getImage(e))return this.fire(new t.ErrorEvent(new Error("No image with this name exists.")));this.imageManager.removeImage(e),this._availableImages=this.imageManager.listImages(),this._changedImages[e]=!0,this._changed=!0,this.fire(new t.Event("data",{dataType:"style"}));},i.prototype.listImages=function(){return this._checkLoaded(),this.imageManager.listImages()},i.prototype.addSource=function(e,i,o){var r=this;if(void 0===o&&(o={}),this._checkLoaded(),void 0!==this.sourceCaches[e])throw new Error("There is already a source with this ID");if(!i.type)throw new Error("The type property must be defined, but the only the following properties were given: "+Object.keys(i).join(", ")+".");if(!(["vector","raster","geojson","video","image"].indexOf(i.type)>=0&&this._validate(t.validateStyle.source,"sources."+e,i,null,o))){this.map&&this.map._collectResourceTiming&&(i.collectResourceTiming=!0);var a=this.sourceCaches[e]=new Mt(e,i,this.dispatcher);a.style=this,a.setEventedParent(this,(function(){return {isSourceLoaded:r.loaded(),source:a.serialize(),sourceId:e}})),a.onAdd(this.map),this._changed=!0;}},i.prototype.removeSource=function(e){if(this._checkLoaded(),void 0===this.sourceCaches[e])throw new Error("There is no source with this ID");for(var i in this._layers)if(this._layers[i].source===e)return this.fire(new t.ErrorEvent(new Error('Source "'+e+'" cannot be removed while layer "'+i+'" is using it.')));var o=this.sourceCaches[e];delete this.sourceCaches[e],delete this._updatedSources[e],o.fire(new t.Event("data",{sourceDataType:"metadata",dataType:"source",sourceId:e})),o.setEventedParent(null),o.clearTiles(),o.onRemove&&o.onRemove(this.map),this._changed=!0;},i.prototype.setGeoJSONSourceData=function(t,e){this._checkLoaded(),this.sourceCaches[t].getSource().setData(e),this._changed=!0;},i.prototype.getSource=function(t){return this.sourceCaches[t]&&this.sourceCaches[t].getSource()},i.prototype.addLayer=function(e,i,o){void 0===o&&(o={}),this._checkLoaded();var r=e.id;if(this.getLayer(r))this.fire(new t.ErrorEvent(new Error('Layer with id "'+r+'" already exists on this map')));else{var a;if("custom"===e.type){if(Be(this,t.validateCustomStyleLayer(e)))return;a=t.createStyleLayer(e);}else{if("object"==typeof e.source&&(this.addSource(r,e.source),e=t.clone$1(e),e=t.extend(e,{source:r})),this._validate(t.validateStyle.layer,"layers."+r,e,{arrayIndex:-1},o))return;a=t.createStyleLayer(e),this._validateLayer(a),a.setEventedParent(this,{layer:{id:r}}),this._serializedLayers[a.id]=a.serialize();}var n=i?this._order.indexOf(i):this._order.length;if(i&&-1===n)this.fire(new t.ErrorEvent(new Error('Layer with id "'+i+'" does not exist on this map.')));else{if(this._order.splice(n,0,r),this._layerOrderChanged=!0,this._layers[r]=a,this._removedLayers[r]&&a.source&&"custom"!==a.type){var s=this._removedLayers[r];delete this._removedLayers[r],s.type!==a.type?this._updatedSources[a.source]="clear":(this._updatedSources[a.source]="reload",this.sourceCaches[a.source].pause());}this._updateLayer(a),a.onAdd&&a.onAdd(this.map);}}},i.prototype.moveLayer=function(e,i){if(this._checkLoaded(),this._changed=!0,this._layers[e]){if(e!==i){var o=this._order.indexOf(e);this._order.splice(o,1);var r=i?this._order.indexOf(i):this._order.length;i&&-1===r?this.fire(new t.ErrorEvent(new Error('Layer with id "'+i+'" does not exist on this map.'))):(this._order.splice(r,0,e),this._layerOrderChanged=!0);}}else this.fire(new t.ErrorEvent(new Error("The layer '"+e+"' does not exist in the map's style and cannot be moved.")));},i.prototype.removeLayer=function(e){this._checkLoaded();var i=this._layers[e];if(i){i.setEventedParent(null);var o=this._order.indexOf(e);this._order.splice(o,1),this._layerOrderChanged=!0,this._changed=!0,this._removedLayers[e]=i,delete this._layers[e],delete this._serializedLayers[e],delete this._updatedLayers[e],delete this._updatedPaintProps[e],i.onRemove&&i.onRemove(this.map);}else this.fire(new t.ErrorEvent(new Error("The layer '"+e+"' does not exist in the map's style and cannot be removed.")));},i.prototype.getLayer=function(t){return this._layers[t]},i.prototype.hasLayer=function(t){return t in this._layers},i.prototype.setLayerZoomRange=function(e,i,o){this._checkLoaded();var r=this.getLayer(e);r?r.minzoom===i&&r.maxzoom===o||(null!=i&&(r.minzoom=i),null!=o&&(r.maxzoom=o),this._updateLayer(r)):this.fire(new t.ErrorEvent(new Error("The layer '"+e+"' does not exist in the map's style and cannot have zoom extent.")));},i.prototype.setFilter=function(e,i,o){void 0===o&&(o={}),this._checkLoaded();var r=this.getLayer(e);if(r){if(!t.deepEqual(r.filter,i))return null==i?(r.filter=void 0,void this._updateLayer(r)):void(this._validate(t.validateStyle.filter,"layers."+r.id+".filter",i,null,o)||(r.filter=t.clone$1(i),this._updateLayer(r)))}else this.fire(new t.ErrorEvent(new Error("The layer '"+e+"' does not exist in the map's style and cannot be filtered.")));},i.prototype.getFilter=function(e){return t.clone$1(this.getLayer(e).filter)},i.prototype.setLayoutProperty=function(e,i,o,r){void 0===r&&(r={}),this._checkLoaded();var a=this.getLayer(e);a?t.deepEqual(a.getLayoutProperty(i),o)||(a.setLayoutProperty(i,o,r),this._updateLayer(a)):this.fire(new t.ErrorEvent(new Error("The layer '"+e+"' does not exist in the map's style and cannot be styled.")));},i.prototype.getLayoutProperty=function(e,i){var o=this.getLayer(e);if(o)return o.getLayoutProperty(i);this.fire(new t.ErrorEvent(new Error("The layer '"+e+"' does not exist in the map's style.")));},i.prototype.setPaintProperty=function(e,i,o,r){void 0===r&&(r={}),this._checkLoaded();var a=this.getLayer(e);a?t.deepEqual(a.getPaintProperty(i),o)||(a.setPaintProperty(i,o,r)&&this._updateLayer(a),this._changed=!0,this._updatedPaintProps[e]=!0):this.fire(new t.ErrorEvent(new Error("The layer '"+e+"' does not exist in the map's style and cannot be styled.")));},i.prototype.getPaintProperty=function(t,e){return this.getLayer(t).getPaintProperty(e)},i.prototype.setFeatureState=function(e,i){this._checkLoaded();var o=e.source,r=e.sourceLayer,a=this.sourceCaches[o];if(void 0!==a){var n=a.getSource().type;"geojson"===n&&r?this.fire(new t.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))):"vector"!==n||r?(void 0===e.id&&this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))),a.setFeatureState(r,e.id,i)):this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));}else this.fire(new t.ErrorEvent(new Error("The source '"+o+"' does not exist in the map's style.")));},i.prototype.removeFeatureState=function(e,i){this._checkLoaded();var o=e.source,r=this.sourceCaches[o];if(void 0!==r){var a=r.getSource().type,n="vector"===a?e.sourceLayer:void 0;"vector"!==a||n?i&&"string"!=typeof e.id&&"number"!=typeof e.id?this.fire(new t.ErrorEvent(new Error("A feature id is requred to remove its specific state property."))):r.removeFeatureState(n,e.id,i):this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));}else this.fire(new t.ErrorEvent(new Error("The source '"+o+"' does not exist in the map's style.")));},i.prototype.getFeatureState=function(e){this._checkLoaded();var i=e.source,o=e.sourceLayer,r=this.sourceCaches[i];if(void 0!==r){if("vector"!==r.getSource().type||o)return void 0===e.id&&this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))),r.getFeatureState(o,e.id);this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));}else this.fire(new t.ErrorEvent(new Error("The source '"+i+"' does not exist in the map's style.")));},i.prototype.getTransition=function(){return t.extend({duration:300,delay:0},this.stylesheet&&this.stylesheet.transition)},i.prototype.serialize=function(){return t.filterObject({version:this.stylesheet.version,name:this.stylesheet.name,metadata:this.stylesheet.metadata,light:this.stylesheet.light,center:this.stylesheet.center,zoom:this.stylesheet.zoom,bearing:this.stylesheet.bearing,pitch:this.stylesheet.pitch,sprite:this.stylesheet.sprite,glyphs:this.stylesheet.glyphs,transition:this.stylesheet.transition,sources:t.mapObject(this.sourceCaches,(function(t){return t.serialize()})),layers:this._serializeLayers(this._order)},(function(t){return void 0!==t}))},i.prototype._updateLayer=function(t){this._updatedLayers[t.id]=!0,t.source&&!this._updatedSources[t.source]&&"raster"!==this.sourceCaches[t.source].getSource().type&&(this._updatedSources[t.source]="reload",this.sourceCaches[t.source].pause()),this._changed=!0;},i.prototype._flattenAndSortRenderedFeatures=function(t){for(var e=this,i=function(t){return "fill-extrusion"===e._layers[t].type},o={},r=[],a=this._order.length-1;a>=0;a--){var n=this._order[a];if(i(n)){o[n]=a;for(var s=0,l=t;s<l.length;s+=1){var c=l[s][n];if(c)for(var u=0,h=c;u<h.length;u+=1)r.push(h[u]);}}}r.sort((function(t,e){return e.intersectionZ-t.intersectionZ}));for(var p=[],d=this._order.length-1;d>=0;d--){var _=this._order[d];if(i(_))for(var f=r.length-1;f>=0;f--){var m=r[f].feature;if(o[m.layer.id]<d)break;p.push(m),r.pop();}else for(var g=0,v=t;g<v.length;g+=1){var y=v[g][_];if(y)for(var x=0,b=y;x<b.length;x+=1)p.push(b[x].feature);}}return p},i.prototype.queryRenderedFeatures=function(e,i,o){i&&i.filter&&this._validate(t.validateStyle.filter,"queryRenderedFeatures.filter",i.filter,null,i);var r={};if(i&&i.layers){if(!Array.isArray(i.layers))return this.fire(new t.ErrorEvent(new Error("parameters.layers must be an Array."))),[];for(var a=0,n=i.layers;a<n.length;a+=1){var s=n[a],l=this._layers[s];if(!l)return this.fire(new t.ErrorEvent(new Error("The layer '"+s+"' does not exist in the map's style and cannot be queried for features."))),[];r[l.source]=!0;}}var c=[];for(var u in i.availableImages=this._availableImages,this.sourceCaches)i.layers&&!r[u]||c.push(F(this.sourceCaches[u],this._layers,this._serializedLayers,e,i,o));return this.placement&&c.push(function(t,e,i,o,r,a,n){for(var s={},l=a.queryRenderedSymbols(o),c=[],u=0,h=Object.keys(l).map(Number);u<h.length;u+=1)c.push(n[h[u]]);c.sort(U);for(var p=function(){var i=_[d],o=i.featureIndex.lookupSymbolFeatures(l[i.bucketInstanceId],e,i.bucketIndex,i.sourceLayerIndex,r.filter,r.layers,r.availableImages,t);for(var a in o){var n=s[a]=s[a]||[],c=o[a];c.sort((function(t,e){var o=i.featureSortOrder;if(o){var r=o.indexOf(t.featureIndex);return o.indexOf(e.featureIndex)-r}return e.featureIndex-t.featureIndex}));for(var u=0,h=c;u<h.length;u+=1)n.push(h[u]);}},d=0,_=c;d<_.length;d+=1)p();var f=function(e){s[e].forEach((function(o){var r=o.feature,a=i[t[e].source].getFeatureState(r.layer["source-layer"],r.id);r.source=r.layer.source,r.layer["source-layer"]&&(r.sourceLayer=r.layer["source-layer"]),r.state=a;}));};for(var m in s)f(m);return s}(this._layers,this._serializedLayers,this.sourceCaches,e,i,this.placement.collisionIndex,this.placement.retainedQueryData)),this._flattenAndSortRenderedFeatures(c)},i.prototype.querySourceFeatures=function(e,i){i&&i.filter&&this._validate(t.validateStyle.filter,"querySourceFeatures.filter",i.filter,null,i);var o=this.sourceCaches[e];return o?function(t,e){for(var i=t.getRenderableIds().map((function(e){return t.getTileByID(e)})),o=[],r={},a=0;a<i.length;a++){var n=i[a],s=n.tileID.canonical.key;r[s]||(r[s]=!0,n.querySourceFeatures(o,e));}return o}(o,i):[]},i.prototype.addSourceType=function(t,e,o){return i.getSourceType(t)?o(new Error('A source type called "'+t+'" already exists.')):(i.setSourceType(t,e),e.workerSourceURL?void this.dispatcher.broadcast("loadWorkerSource",{name:t,url:e.workerSourceURL},o):o(null,null))},i.prototype.getLight=function(){return this.light.getLight()},i.prototype.setLight=function(e,i){void 0===i&&(i={}),this._checkLoaded();var o=this.light.getLight(),r=!1;for(var a in e)if(!t.deepEqual(e[a],o[a])){r=!0;break}if(r){var n={now:t.browser.now(),transition:t.extend({duration:300,delay:0},this.stylesheet.transition)};this.light.setLight(e,i),this.light.updateTransitions(n);}},i.prototype._validate=function(e,i,o,r,a){return void 0===a&&(a={}),(!a||!1!==a.validate)&&Be(this,e.call(t.validateStyle,t.extend({key:i,style:this.serialize(),value:o,styleSpec:t.styleSpec},r)))},i.prototype._remove=function(){for(var e in this._request&&(this._request.cancel(),this._request=null),this._spriteRequest&&(this._spriteRequest.cancel(),this._spriteRequest=null),t.evented.off("pluginStateChange",this._rtlTextPluginCallback),this._layers)this._layers[e].setEventedParent(null);for(var i in this.sourceCaches)this.sourceCaches[i].clearTiles(),this.sourceCaches[i].setEventedParent(null);this.imageManager.setEventedParent(null),this.setEventedParent(null),this.dispatcher.remove();},i.prototype._clearSource=function(t){this.sourceCaches[t].clearTiles();},i.prototype._reloadSource=function(t){this.sourceCaches[t].resume(),this.sourceCaches[t].reload();},i.prototype._updateSources=function(t){for(var e in this.sourceCaches)this.sourceCaches[e].update(t);},i.prototype._generateCollisionBoxes=function(){for(var t in this.sourceCaches)this._reloadSource(t);},i.prototype._updatePlacement=function(e,i,o,r,a){void 0===a&&(a=!1);for(var n=!1,s=!1,l={},c=0,u=this._order;c<u.length;c+=1){var h=this._layers[u[c]];if("symbol"===h.type){if(!l[h.source]){var p=this.sourceCaches[h.source];l[h.source]=p.getRenderableIds(!0).map((function(t){return p.getTileByID(t)})).sort((function(t,e){return e.tileID.overscaledZ-t.tileID.overscaledZ||(t.tileID.isLessThan(e.tileID)?-1:1)}));}var d=this.crossTileSymbolIndex.addLayer(h,l[h.source],e.center.lng);n=n||d;}}if(this.crossTileSymbolIndex.pruneUnusedLayers(this._order),((a=a||this._layerOrderChanged||0===o)||!this.pauseablePlacement||this.pauseablePlacement.isDone()&&!this.placement.stillRecent(t.browser.now(),e.zoom))&&(this.pauseablePlacement=new Le(e,this._order,a,i,o,r,this.placement),this._layerOrderChanged=!1),this.pauseablePlacement.isDone()?this.placement.setStale():(this.pauseablePlacement.continuePlacement(this._order,this._layers,l),this.pauseablePlacement.isDone()&&(this.placement=this.pauseablePlacement.commit(t.browser.now()),s=!0),n&&this.pauseablePlacement.placement.setStale()),s||n)for(var _=0,f=this._order;_<f.length;_+=1){var m=this._layers[f[_]];"symbol"===m.type&&this.placement.updateLayerOpacities(m,l[m.source]);}return !this.pauseablePlacement.isDone()||this.placement.hasTransitions(t.browser.now())},i.prototype._releaseSymbolFadeTiles=function(){for(var t in this.sourceCaches)this.sourceCaches[t].releaseSymbolFadeTiles();},i.prototype.getImages=function(t,e,i){this.imageManager.getImages(e.icons,i),this._updateTilesForChangedImages();var o=this.sourceCaches[e.source];o&&o.setDependencies(e.tileID.key,e.type,e.icons);},i.prototype.getGlyphs=function(t,e,i){this.glyphManager.getGlyphs(e.stacks,i);},i.prototype.getResource=function(e,i,o){return t.makeRequest(i,o)},i}(t.Evented);Ne.getSourceType=function(t){return k[t]},Ne.setSourceType=function(t,e){k[t]=e;},Ne.registerForPluginStateChange=t.registerForPluginStateChange;var Ze=t.createLayout([{name:"a_pos",type:"Int16",components:2}]),qe=_i("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif","#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}"),je=_i("uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),Ve=_i("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),Ge=_i("varying vec3 v_data;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,0,1);} else {gl_Position=u_matrix*vec4(circle_center,0,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"),We=_i("void main() {gl_FragColor=vec4(1.0);}","attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),Xe=_i("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}"),He=_i("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),Ke=_i("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}","attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,0.0,1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"),Ye=_i("uniform float u_overscale_factor;varying float v_placed;varying float v_notUsed;varying float v_radius;varying vec2 v_extrude;varying vec2 v_extrude_scale;void main() {float alpha=0.5;vec4 color=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {color=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {color*=.2;}float extrude_scale_length=length(v_extrude_scale);float extrude_length=length(v_extrude)*extrude_scale_length;float stroke_width=15.0*extrude_scale_length/u_overscale_factor;float radius=v_radius*extrude_scale_length;float distance_to_edge=abs(extrude_length-radius);float opacity_t=smoothstep(-stroke_width,0.0,-distance_to_edge);gl_FragColor=opacity_t*color;}","attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;varying float v_radius;varying vec2 v_extrude;varying vec2 v_extrude_scale;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,0.0,1.0);highp float padding_factor=1.2;gl_Position.xy+=a_extrude*u_extrude_scale*padding_factor*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;v_radius=abs(a_extrude.y);v_extrude=a_extrude*padding_factor;v_extrude_scale=u_extrude_scale*u_camera_to_center_distance*collision_perspective_ratio;}"),Je=_i("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}","attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,0,1);}"),Qe=_i("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}"),$e=_i("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"),ti=_i("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"),ei=_i("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"),ii=_i("varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"),oi=_i("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"),ri=_i("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform float u_maxzoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggeration=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/ pow(2.0,(u_zoom-u_maxzoom)*exaggeration+19.2562-u_zoom);gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),ai=_i("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"),ni=_i("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"),si=_i("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp float v_lineprogress;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,vec2(v_lineprogress,0.5));gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","\n#define MAX_LINE_DISTANCE 32767.0\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_lineprogress;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_lineprogress=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0/MAX_LINE_DISTANCE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"),li=_i("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"),ci=_i("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"),ui=_i("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"),hi=_i("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),0.0,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));}"),pi=_i("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"),di=_i("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}","const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}");function _i(t,e){var i=/#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,o={};return {fragmentSource:t=t.replace(i,(function(t,e,i,r,a){return o[a]=!0,"define"===e?"\n#ifndef HAS_UNIFORM_u_"+a+"\nvarying "+i+" "+r+" "+a+";\n#else\nuniform "+i+" "+r+" u_"+a+";\n#endif\n":"\n#ifdef HAS_UNIFORM_u_"+a+"\n    "+i+" "+r+" "+a+" = u_"+a+";\n#endif\n"})),vertexSource:e=e.replace(i,(function(t,e,i,r,a){var n="float"===r?"vec2":"vec4",s=a.match(/color/)?"color":n;return o[a]?"define"===e?"\n#ifndef HAS_UNIFORM_u_"+a+"\nuniform lowp float u_"+a+"_t;\nattribute "+i+" "+n+" a_"+a+";\nvarying "+i+" "+r+" "+a+";\n#else\nuniform "+i+" "+r+" u_"+a+";\n#endif\n":"vec4"===s?"\n#ifndef HAS_UNIFORM_u_"+a+"\n    "+a+" = a_"+a+";\n#else\n    "+i+" "+r+" "+a+" = u_"+a+";\n#endif\n":"\n#ifndef HAS_UNIFORM_u_"+a+"\n    "+a+" = unpack_mix_"+s+"(a_"+a+", u_"+a+"_t);\n#else\n    "+i+" "+r+" "+a+" = u_"+a+";\n#endif\n":"define"===e?"\n#ifndef HAS_UNIFORM_u_"+a+"\nuniform lowp float u_"+a+"_t;\nattribute "+i+" "+n+" a_"+a+";\n#else\nuniform "+i+" "+r+" u_"+a+";\n#endif\n":"vec4"===s?"\n#ifndef HAS_UNIFORM_u_"+a+"\n    "+i+" "+r+" "+a+" = a_"+a+";\n#else\n    "+i+" "+r+" "+a+" = u_"+a+";\n#endif\n":"\n#ifndef HAS_UNIFORM_u_"+a+"\n    "+i+" "+r+" "+a+" = unpack_mix_"+s+"(a_"+a+", u_"+a+"_t);\n#else\n    "+i+" "+r+" "+a+" = u_"+a+";\n#endif\n"}))}}var fi=Object.freeze({__proto__:null,prelude:qe,background:je,backgroundPattern:Ve,circle:Ge,clippingMask:We,heatmap:Xe,heatmapTexture:He,collisionBox:Ke,collisionCircle:Ye,debug:Je,fill:Qe,fillOutline:$e,fillOutlinePattern:ti,fillPattern:ei,fillExtrusion:ii,fillExtrusionPattern:oi,hillshadePrepare:ri,hillshade:ai,line:ni,lineGradient:si,linePattern:li,lineSDF:ci,raster:ui,symbolIcon:hi,symbolSDF:pi,symbolTextAndIcon:di}),mi=function(){this.boundProgram=null,this.boundLayoutVertexBuffer=null,this.boundPaintVertexBuffers=[],this.boundIndexBuffer=null,this.boundVertexOffset=null,this.boundDynamicVertexBuffer=null,this.vao=null;};mi.prototype.bind=function(t,e,i,o,r,a,n,s){this.context=t;for(var l=this.boundPaintVertexBuffers.length!==o.length,c=0;!l&&c<o.length;c++)this.boundPaintVertexBuffers[c]!==o[c]&&(l=!0);t.extVertexArrayObject&&this.vao&&this.boundProgram===e&&this.boundLayoutVertexBuffer===i&&!l&&this.boundIndexBuffer===r&&this.boundVertexOffset===a&&this.boundDynamicVertexBuffer===n&&this.boundDynamicVertexBuffer2===s?(t.bindVertexArrayOES.set(this.vao),n&&n.bind(),r&&r.dynamicDraw&&r.bind(),s&&s.bind()):this.freshBind(e,i,o,r,a,n,s);},mi.prototype.freshBind=function(t,e,i,o,r,a,n){var s,l=t.numAttributes,c=this.context,u=c.gl;if(c.extVertexArrayObject)this.vao&&this.destroy(),this.vao=c.extVertexArrayObject.createVertexArrayOES(),c.bindVertexArrayOES.set(this.vao),s=0,this.boundProgram=t,this.boundLayoutVertexBuffer=e,this.boundPaintVertexBuffers=i,this.boundIndexBuffer=o,this.boundVertexOffset=r,this.boundDynamicVertexBuffer=a,this.boundDynamicVertexBuffer2=n;else{s=c.currentNumAttributes||0;for(var h=l;h<s;h++)u.disableVertexAttribArray(h);}e.enableAttributes(u,t);for(var p=0,d=i;p<d.length;p+=1)d[p].enableAttributes(u,t);a&&a.enableAttributes(u,t),n&&n.enableAttributes(u,t),e.bind(),e.setVertexAttribPointers(u,t,r);for(var _=0,f=i;_<f.length;_+=1){var m=f[_];m.bind(),m.setVertexAttribPointers(u,t,r);}a&&(a.bind(),a.setVertexAttribPointers(u,t,r)),o&&o.bind(),n&&(n.bind(),n.setVertexAttribPointers(u,t,r)),c.currentNumAttributes=l;},mi.prototype.destroy=function(){this.vao&&(this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao),this.vao=null);};var gi=function(t,e,i,o,r){var a=t.gl;this.program=a.createProgram();var n=i?i.defines():[];r&&n.push("#define OVERDRAW_INSPECTOR;");var s=n.concat(qe.fragmentSource,e.fragmentSource).join("\n"),l=n.concat(qe.vertexSource,e.vertexSource).join("\n"),c=a.createShader(a.FRAGMENT_SHADER);if(a.isContextLost())this.failedToCreate=!0;else{a.shaderSource(c,s),a.compileShader(c),a.attachShader(this.program,c);var u=a.createShader(a.VERTEX_SHADER);if(a.isContextLost())this.failedToCreate=!0;else{a.shaderSource(u,l),a.compileShader(u),a.attachShader(this.program,u);for(var h=i?i.layoutAttributes:[],p=0;p<h.length;p++)a.bindAttribLocation(this.program,p,h[p].name);a.linkProgram(this.program),this.numAttributes=a.getProgramParameter(this.program,a.ACTIVE_ATTRIBUTES),this.attributes={};for(var d={},_=0;_<this.numAttributes;_++){var f=a.getActiveAttrib(this.program,_);f&&(this.attributes[f.name]=a.getAttribLocation(this.program,f.name));}for(var m=a.getProgramParameter(this.program,a.ACTIVE_UNIFORMS),g=0;g<m;g++){var v=a.getActiveUniform(this.program,g);v&&(d[v.name]=a.getUniformLocation(this.program,v.name));}this.fixedUniforms=o(t,d),this.binderUniforms=i?i.getUniforms(t,d):[];}}};function vi(t,e,i){var o=1/ue(i,1,e.transform.tileZoom),r=Math.pow(2,i.tileID.overscaledZ),a=i.tileSize*Math.pow(2,e.transform.tileZoom)/r,n=a*(i.tileID.canonical.x+i.tileID.wrap*r),s=a*i.tileID.canonical.y;return {u_image:0,u_texsize:i.imageAtlasTexture.size,u_scale:[o,t.fromScale,t.toScale],u_fade:t.t,u_pixel_coord_upper:[n>>16,s>>16],u_pixel_coord_lower:[65535&n,65535&s]}}gi.prototype.draw=function(t,e,i,o,r,a,n,s,l,c,u,h,p,d,_,f){var m,g=t.gl;if(!this.failedToCreate){for(var v in t.program.set(this.program),t.setDepthMode(i),t.setStencilMode(o),t.setColorMode(r),t.setCullFace(a),this.fixedUniforms)this.fixedUniforms[v].set(n[v]);d&&d.setUniforms(t,this.binderUniforms,h,{zoom:p});for(var y=(m={},m[g.LINES]=2,m[g.TRIANGLES]=3,m[g.LINE_STRIP]=1,m)[e],x=0,b=u.get();x<b.length;x+=1){var w=b[x],E=w.vaos||(w.vaos={});(E[s]||(E[s]=new mi)).bind(t,this,l,d?d.getPaintVertexBuffers():[],c,w.vertexOffset,_,f),g.drawElements(e,w.primitiveLength*y,g.UNSIGNED_SHORT,w.primitiveOffset*y*2);}}};var yi=function(e,i,o,r){var a=i.style.light,n=a.properties.get("position"),s=[n.x,n.y,n.z],l=t.create$1();"viewport"===a.properties.get("anchor")&&t.fromRotation(l,-i.transform.angle),t.transformMat3(s,s,l);var c=a.properties.get("color");return {u_matrix:e,u_lightpos:s,u_lightintensity:a.properties.get("intensity"),u_lightcolor:[c.r,c.g,c.b],u_vertical_gradient:+o,u_opacity:r}},xi=function(e,i,o,r,a,n,s){return t.extend(yi(e,i,o,r),vi(n,i,s),{u_height_factor:-Math.pow(2,a.overscaledZ)/s.tileSize/8})},bi=function(t){return {u_matrix:t}},wi=function(e,i,o,r){return t.extend(bi(e),vi(o,i,r))},Ei=function(t,e){return {u_matrix:t,u_world:e}},Ti=function(e,i,o,r,a){return t.extend(wi(e,i,o,r),{u_world:a})},Ii=function(e,i,o,r){var a,n,s=e.transform;if("map"===r.paint.get("circle-pitch-alignment")){var l=ue(o,1,s.zoom);a=!0,n=[l,l];}else a=!1,n=s.pixelsToGLUnits;return {u_camera_to_center_distance:s.cameraToCenterDistance,u_scale_with_map:+("map"===r.paint.get("circle-pitch-scale")),u_matrix:e.translatePosMatrix(i.posMatrix,o,r.paint.get("circle-translate"),r.paint.get("circle-translate-anchor")),u_pitch_with_map:+a,u_device_pixel_ratio:t.browser.devicePixelRatio,u_extrude_scale:n}},Ci=function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_camera_to_center_distance:new t.Uniform1f(e,i.u_camera_to_center_distance),u_pixels_to_tile_units:new t.Uniform1f(e,i.u_pixels_to_tile_units),u_extrude_scale:new t.Uniform2f(e,i.u_extrude_scale),u_overscale_factor:new t.Uniform1f(e,i.u_overscale_factor)}},Si=function(t,e,i){var o=ue(i,1,e.zoom),r=Math.pow(2,e.zoom-i.tileID.overscaledZ),a=i.tileID.overscaleFactor();return {u_matrix:t,u_camera_to_center_distance:e.cameraToCenterDistance,u_pixels_to_tile_units:o,u_extrude_scale:[e.pixelsToGLUnits[0]/(o*r),e.pixelsToGLUnits[1]/(o*r)],u_overscale_factor:a}},Pi=function(t,e,i){return void 0===i&&(i=1),{u_matrix:t,u_color:e,u_overlay:0,u_overlay_scale:i}},zi=function(t){return {u_matrix:t}},Li=function(t,e,i,o){return {u_matrix:t,u_extrude_scale:ue(e,1,i),u_intensity:o}},Mi=function(e,i,o){var r=o.paint.get("hillshade-shadow-color"),a=o.paint.get("hillshade-highlight-color"),n=o.paint.get("hillshade-accent-color"),s=o.paint.get("hillshade-illumination-direction")*(Math.PI/180);"viewport"===o.paint.get("hillshade-illumination-anchor")&&(s-=e.transform.angle);var l,c,u,h=!e.options.moving;return {u_matrix:e.transform.calculatePosMatrix(i.tileID.toUnwrapped(),h),u_image:0,u_latrange:(l=i.tileID,c=Math.pow(2,l.canonical.z),u=l.canonical.y,[new t.MercatorCoordinate(0,u/c).toLngLat().lat,new t.MercatorCoordinate(0,(u+1)/c).toLngLat().lat]),u_light:[o.paint.get("hillshade-exaggeration"),s],u_shadow:r,u_highlight:a,u_accent:n}},Di=function(e,i,o){var r=i.stride,a=t.create();return t.ortho(a,0,t.EXTENT,-t.EXTENT,0,0,1),t.translate(a,a,[0,-t.EXTENT,0]),{u_matrix:a,u_image:1,u_dimension:[r,r],u_zoom:e.overscaledZ,u_maxzoom:o,u_unpack:i.getUnpackVector()}},Ai=function(e,i,o){var r=e.transform;return {u_matrix:Fi(e,i,o),u_ratio:1/ue(i,1,r.zoom),u_device_pixel_ratio:t.browser.devicePixelRatio,u_units_to_pixels:[1/r.pixelsToGLUnits[0],1/r.pixelsToGLUnits[1]]}},Ri=function(e,i,o){return t.extend(Ai(e,i,o),{u_image:0})},ki=function(e,i,o,r){var a=e.transform,n=Oi(i,a);return {u_matrix:Fi(e,i,o),u_texsize:i.imageAtlasTexture.size,u_ratio:1/ue(i,1,a.zoom),u_device_pixel_ratio:t.browser.devicePixelRatio,u_image:0,u_scale:[n,r.fromScale,r.toScale],u_fade:r.t,u_units_to_pixels:[1/a.pixelsToGLUnits[0],1/a.pixelsToGLUnits[1]]}},Bi=function(e,i,o,r,a){var n=e.lineAtlas,s=Oi(i,e.transform),l="round"===o.layout.get("line-cap"),c=n.getDash(r.from,l),u=n.getDash(r.to,l),h=c.width*a.fromScale,p=u.width*a.toScale;return t.extend(Ai(e,i,o),{u_patternscale_a:[s/h,-c.height/2],u_patternscale_b:[s/p,-u.height/2],u_sdfgamma:n.width/(256*Math.min(h,p)*t.browser.devicePixelRatio)/2,u_image:0,u_tex_y_a:c.y,u_tex_y_b:u.y,u_mix:a.t})};function Oi(t,e){return 1/ue(t,1,e.tileZoom)}function Fi(t,e,i){return t.translatePosMatrix(e.tileID.posMatrix,e,i.paint.get("line-translate"),i.paint.get("line-translate-anchor"))}var Ui=function(t,e,i,o,r){return {u_matrix:t,u_tl_parent:e,u_scale_parent:i,u_buffer_scale:1,u_fade_t:o.mix,u_opacity:o.opacity*r.paint.get("raster-opacity"),u_image0:0,u_image1:1,u_brightness_low:r.paint.get("raster-brightness-min"),u_brightness_high:r.paint.get("raster-brightness-max"),u_saturation_factor:(n=r.paint.get("raster-saturation"),n>0?1-1/(1.001-n):-n),u_contrast_factor:(a=r.paint.get("raster-contrast"),a>0?1/(1-a):1+a),u_spin_weights:Ni(r.paint.get("raster-hue-rotate"))};var a,n;};function Ni(t){t*=Math.PI/180;var e=Math.sin(t),i=Math.cos(t);return [(2*i+1)/3,(-Math.sqrt(3)*e-i+1)/3,(Math.sqrt(3)*e-i+1)/3]}var Zi=function(t,e,i,o,r,a,n,s,l,c){var u=r.transform;return {u_is_size_zoom_constant:+("constant"===t||"source"===t),u_is_size_feature_constant:+("constant"===t||"camera"===t),u_size_t:e?e.uSizeT:0,u_size:e?e.uSize:0,u_camera_to_center_distance:u.cameraToCenterDistance,u_pitch:u.pitch/360*2*Math.PI,u_rotate_symbol:+i,u_aspect_ratio:u.width/u.height,u_fade_change:r.options.fadeDuration?r.symbolFadeChange:1,u_matrix:a,u_label_plane_matrix:n,u_coord_matrix:s,u_is_text:+l,u_pitch_with_map:+o,u_texsize:c,u_texture:0}},qi=function(e,i,o,r,a,n,s,l,c,u,h){var p=a.transform;return t.extend(Zi(e,i,o,r,a,n,s,l,c,u),{u_gamma_scale:r?Math.cos(p._pitch)*p.cameraToCenterDistance:1,u_device_pixel_ratio:t.browser.devicePixelRatio,u_is_halo:+h})},ji=function(e,i,o,r,a,n,s,l,c,u){return t.extend(qi(e,i,o,r,a,n,s,l,!0,c,!0),{u_texsize_icon:u,u_texture_icon:1})},Vi=function(t,e,i){return {u_matrix:t,u_opacity:e,u_color:i}},Gi=function(e,i,o,r,a,n){return t.extend(function(t,e,i,o){var r=i.imageManager.getPattern(t.from.toString()),a=i.imageManager.getPattern(t.to.toString()),n=i.imageManager.getPixelSize(),s=n.width,l=n.height,c=Math.pow(2,o.tileID.overscaledZ),u=o.tileSize*Math.pow(2,i.transform.tileZoom)/c,h=u*(o.tileID.canonical.x+o.tileID.wrap*c),p=u*o.tileID.canonical.y;return {u_image:0,u_pattern_tl_a:r.tl,u_pattern_br_a:r.br,u_pattern_tl_b:a.tl,u_pattern_br_b:a.br,u_texsize:[s,l],u_mix:e.t,u_pattern_size_a:r.displaySize,u_pattern_size_b:a.displaySize,u_scale_a:e.fromScale,u_scale_b:e.toScale,u_tile_units_to_pixels:1/ue(o,1,i.transform.tileZoom),u_pixel_coord_upper:[h>>16,p>>16],u_pixel_coord_lower:[65535&h,65535&p]}}(r,n,o,a),{u_matrix:e,u_opacity:i})},Wi={fillExtrusion:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_lightpos:new t.Uniform3f(e,i.u_lightpos),u_lightintensity:new t.Uniform1f(e,i.u_lightintensity),u_lightcolor:new t.Uniform3f(e,i.u_lightcolor),u_vertical_gradient:new t.Uniform1f(e,i.u_vertical_gradient),u_opacity:new t.Uniform1f(e,i.u_opacity)}},fillExtrusionPattern:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_lightpos:new t.Uniform3f(e,i.u_lightpos),u_lightintensity:new t.Uniform1f(e,i.u_lightintensity),u_lightcolor:new t.Uniform3f(e,i.u_lightcolor),u_vertical_gradient:new t.Uniform1f(e,i.u_vertical_gradient),u_height_factor:new t.Uniform1f(e,i.u_height_factor),u_image:new t.Uniform1i(e,i.u_image),u_texsize:new t.Uniform2f(e,i.u_texsize),u_pixel_coord_upper:new t.Uniform2f(e,i.u_pixel_coord_upper),u_pixel_coord_lower:new t.Uniform2f(e,i.u_pixel_coord_lower),u_scale:new t.Uniform3f(e,i.u_scale),u_fade:new t.Uniform1f(e,i.u_fade),u_opacity:new t.Uniform1f(e,i.u_opacity)}},fill:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix)}},fillPattern:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_image:new t.Uniform1i(e,i.u_image),u_texsize:new t.Uniform2f(e,i.u_texsize),u_pixel_coord_upper:new t.Uniform2f(e,i.u_pixel_coord_upper),u_pixel_coord_lower:new t.Uniform2f(e,i.u_pixel_coord_lower),u_scale:new t.Uniform3f(e,i.u_scale),u_fade:new t.Uniform1f(e,i.u_fade)}},fillOutline:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_world:new t.Uniform2f(e,i.u_world)}},fillOutlinePattern:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_world:new t.Uniform2f(e,i.u_world),u_image:new t.Uniform1i(e,i.u_image),u_texsize:new t.Uniform2f(e,i.u_texsize),u_pixel_coord_upper:new t.Uniform2f(e,i.u_pixel_coord_upper),u_pixel_coord_lower:new t.Uniform2f(e,i.u_pixel_coord_lower),u_scale:new t.Uniform3f(e,i.u_scale),u_fade:new t.Uniform1f(e,i.u_fade)}},circle:function(e,i){return {u_camera_to_center_distance:new t.Uniform1f(e,i.u_camera_to_center_distance),u_scale_with_map:new t.Uniform1i(e,i.u_scale_with_map),u_pitch_with_map:new t.Uniform1i(e,i.u_pitch_with_map),u_extrude_scale:new t.Uniform2f(e,i.u_extrude_scale),u_device_pixel_ratio:new t.Uniform1f(e,i.u_device_pixel_ratio),u_matrix:new t.UniformMatrix4f(e,i.u_matrix)}},collisionBox:Ci,collisionCircle:Ci,debug:function(e,i){return {u_color:new t.UniformColor(e,i.u_color),u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_overlay:new t.Uniform1i(e,i.u_overlay),u_overlay_scale:new t.Uniform1f(e,i.u_overlay_scale)}},clippingMask:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix)}},heatmap:function(e,i){return {u_extrude_scale:new t.Uniform1f(e,i.u_extrude_scale),u_intensity:new t.Uniform1f(e,i.u_intensity),u_matrix:new t.UniformMatrix4f(e,i.u_matrix)}},heatmapTexture:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_world:new t.Uniform2f(e,i.u_world),u_image:new t.Uniform1i(e,i.u_image),u_color_ramp:new t.Uniform1i(e,i.u_color_ramp),u_opacity:new t.Uniform1f(e,i.u_opacity)}},hillshade:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_image:new t.Uniform1i(e,i.u_image),u_latrange:new t.Uniform2f(e,i.u_latrange),u_light:new t.Uniform2f(e,i.u_light),u_shadow:new t.UniformColor(e,i.u_shadow),u_highlight:new t.UniformColor(e,i.u_highlight),u_accent:new t.UniformColor(e,i.u_accent)}},hillshadePrepare:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_image:new t.Uniform1i(e,i.u_image),u_dimension:new t.Uniform2f(e,i.u_dimension),u_zoom:new t.Uniform1f(e,i.u_zoom),u_maxzoom:new t.Uniform1f(e,i.u_maxzoom),u_unpack:new t.Uniform4f(e,i.u_unpack)}},line:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_ratio:new t.Uniform1f(e,i.u_ratio),u_device_pixel_ratio:new t.Uniform1f(e,i.u_device_pixel_ratio),u_units_to_pixels:new t.Uniform2f(e,i.u_units_to_pixels)}},lineGradient:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_ratio:new t.Uniform1f(e,i.u_ratio),u_device_pixel_ratio:new t.Uniform1f(e,i.u_device_pixel_ratio),u_units_to_pixels:new t.Uniform2f(e,i.u_units_to_pixels),u_image:new t.Uniform1i(e,i.u_image)}},linePattern:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_texsize:new t.Uniform2f(e,i.u_texsize),u_ratio:new t.Uniform1f(e,i.u_ratio),u_device_pixel_ratio:new t.Uniform1f(e,i.u_device_pixel_ratio),u_image:new t.Uniform1i(e,i.u_image),u_units_to_pixels:new t.Uniform2f(e,i.u_units_to_pixels),u_scale:new t.Uniform3f(e,i.u_scale),u_fade:new t.Uniform1f(e,i.u_fade)}},lineSDF:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_ratio:new t.Uniform1f(e,i.u_ratio),u_device_pixel_ratio:new t.Uniform1f(e,i.u_device_pixel_ratio),u_units_to_pixels:new t.Uniform2f(e,i.u_units_to_pixels),u_patternscale_a:new t.Uniform2f(e,i.u_patternscale_a),u_patternscale_b:new t.Uniform2f(e,i.u_patternscale_b),u_sdfgamma:new t.Uniform1f(e,i.u_sdfgamma),u_image:new t.Uniform1i(e,i.u_image),u_tex_y_a:new t.Uniform1f(e,i.u_tex_y_a),u_tex_y_b:new t.Uniform1f(e,i.u_tex_y_b),u_mix:new t.Uniform1f(e,i.u_mix)}},raster:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_tl_parent:new t.Uniform2f(e,i.u_tl_parent),u_scale_parent:new t.Uniform1f(e,i.u_scale_parent),u_buffer_scale:new t.Uniform1f(e,i.u_buffer_scale),u_fade_t:new t.Uniform1f(e,i.u_fade_t),u_opacity:new t.Uniform1f(e,i.u_opacity),u_image0:new t.Uniform1i(e,i.u_image0),u_image1:new t.Uniform1i(e,i.u_image1),u_brightness_low:new t.Uniform1f(e,i.u_brightness_low),u_brightness_high:new t.Uniform1f(e,i.u_brightness_high),u_saturation_factor:new t.Uniform1f(e,i.u_saturation_factor),u_contrast_factor:new t.Uniform1f(e,i.u_contrast_factor),u_spin_weights:new t.Uniform3f(e,i.u_spin_weights)}},symbolIcon:function(e,i){return {u_is_size_zoom_constant:new t.Uniform1i(e,i.u_is_size_zoom_constant),u_is_size_feature_constant:new t.Uniform1i(e,i.u_is_size_feature_constant),u_size_t:new t.Uniform1f(e,i.u_size_t),u_size:new t.Uniform1f(e,i.u_size),u_camera_to_center_distance:new t.Uniform1f(e,i.u_camera_to_center_distance),u_pitch:new t.Uniform1f(e,i.u_pitch),u_rotate_symbol:new t.Uniform1i(e,i.u_rotate_symbol),u_aspect_ratio:new t.Uniform1f(e,i.u_aspect_ratio),u_fade_change:new t.Uniform1f(e,i.u_fade_change),u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_label_plane_matrix:new t.UniformMatrix4f(e,i.u_label_plane_matrix),u_coord_matrix:new t.UniformMatrix4f(e,i.u_coord_matrix),u_is_text:new t.Uniform1i(e,i.u_is_text),u_pitch_with_map:new t.Uniform1i(e,i.u_pitch_with_map),u_texsize:new t.Uniform2f(e,i.u_texsize),u_texture:new t.Uniform1i(e,i.u_texture)}},symbolSDF:function(e,i){return {u_is_size_zoom_constant:new t.Uniform1i(e,i.u_is_size_zoom_constant),u_is_size_feature_constant:new t.Uniform1i(e,i.u_is_size_feature_constant),u_size_t:new t.Uniform1f(e,i.u_size_t),u_size:new t.Uniform1f(e,i.u_size),u_camera_to_center_distance:new t.Uniform1f(e,i.u_camera_to_center_distance),u_pitch:new t.Uniform1f(e,i.u_pitch),u_rotate_symbol:new t.Uniform1i(e,i.u_rotate_symbol),u_aspect_ratio:new t.Uniform1f(e,i.u_aspect_ratio),u_fade_change:new t.Uniform1f(e,i.u_fade_change),u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_label_plane_matrix:new t.UniformMatrix4f(e,i.u_label_plane_matrix),u_coord_matrix:new t.UniformMatrix4f(e,i.u_coord_matrix),u_is_text:new t.Uniform1i(e,i.u_is_text),u_pitch_with_map:new t.Uniform1i(e,i.u_pitch_with_map),u_texsize:new t.Uniform2f(e,i.u_texsize),u_texture:new t.Uniform1i(e,i.u_texture),u_gamma_scale:new t.Uniform1f(e,i.u_gamma_scale),u_device_pixel_ratio:new t.Uniform1f(e,i.u_device_pixel_ratio),u_is_halo:new t.Uniform1i(e,i.u_is_halo)}},symbolTextAndIcon:function(e,i){return {u_is_size_zoom_constant:new t.Uniform1i(e,i.u_is_size_zoom_constant),u_is_size_feature_constant:new t.Uniform1i(e,i.u_is_size_feature_constant),u_size_t:new t.Uniform1f(e,i.u_size_t),u_size:new t.Uniform1f(e,i.u_size),u_camera_to_center_distance:new t.Uniform1f(e,i.u_camera_to_center_distance),u_pitch:new t.Uniform1f(e,i.u_pitch),u_rotate_symbol:new t.Uniform1i(e,i.u_rotate_symbol),u_aspect_ratio:new t.Uniform1f(e,i.u_aspect_ratio),u_fade_change:new t.Uniform1f(e,i.u_fade_change),u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_label_plane_matrix:new t.UniformMatrix4f(e,i.u_label_plane_matrix),u_coord_matrix:new t.UniformMatrix4f(e,i.u_coord_matrix),u_is_text:new t.Uniform1i(e,i.u_is_text),u_pitch_with_map:new t.Uniform1i(e,i.u_pitch_with_map),u_texsize:new t.Uniform2f(e,i.u_texsize),u_texsize_icon:new t.Uniform2f(e,i.u_texsize_icon),u_texture:new t.Uniform1i(e,i.u_texture),u_texture_icon:new t.Uniform1i(e,i.u_texture_icon),u_gamma_scale:new t.Uniform1f(e,i.u_gamma_scale),u_device_pixel_ratio:new t.Uniform1f(e,i.u_device_pixel_ratio),u_is_halo:new t.Uniform1i(e,i.u_is_halo)}},background:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_opacity:new t.Uniform1f(e,i.u_opacity),u_color:new t.UniformColor(e,i.u_color)}},backgroundPattern:function(e,i){return {u_matrix:new t.UniformMatrix4f(e,i.u_matrix),u_opacity:new t.Uniform1f(e,i.u_opacity),u_image:new t.Uniform1i(e,i.u_image),u_pattern_tl_a:new t.Uniform2f(e,i.u_pattern_tl_a),u_pattern_br_a:new t.Uniform2f(e,i.u_pattern_br_a),u_pattern_tl_b:new t.Uniform2f(e,i.u_pattern_tl_b),u_pattern_br_b:new t.Uniform2f(e,i.u_pattern_br_b),u_texsize:new t.Uniform2f(e,i.u_texsize),u_mix:new t.Uniform1f(e,i.u_mix),u_pattern_size_a:new t.Uniform2f(e,i.u_pattern_size_a),u_pattern_size_b:new t.Uniform2f(e,i.u_pattern_size_b),u_scale_a:new t.Uniform1f(e,i.u_scale_a),u_scale_b:new t.Uniform1f(e,i.u_scale_b),u_pixel_coord_upper:new t.Uniform2f(e,i.u_pixel_coord_upper),u_pixel_coord_lower:new t.Uniform2f(e,i.u_pixel_coord_lower),u_tile_units_to_pixels:new t.Uniform1f(e,i.u_tile_units_to_pixels)}}};function Xi(t,e,i,o,r,a,n,s){for(var l=t.context,c=l.gl,u=t.useProgram(r?"collisionCircle":"collisionBox"),h=0;h<o.length;h++){var p=o[h],d=e.getTile(p),_=d.getBucket(i);if(_){var f=r?s?_.textCollisionCircle:_.iconCollisionCircle:s?_.textCollisionBox:_.iconCollisionBox;if(f){var m=p.posMatrix;0===a[0]&&0===a[1]||(m=t.translatePosMatrix(p.posMatrix,d,a,n)),u.draw(l,r?c.TRIANGLES:c.LINES,Ct.disabled,St.disabled,t.colorModeForRenderPass(),zt.disabled,Si(m,t.transform,d),i.id,f.layoutVertexBuffer,f.indexBuffer,f.segments,null,t.transform.zoom,null,null,f.collisionVertexBuffer);}}}}function Hi(t,e,i,o,r,a,n){Xi(t,e,i,o,!1,r,a,n),Xi(t,e,i,o,!0,r,a,n);}var Ki=t.identity(new Float32Array(16));function Yi(e,i,o,r,a,n){var s=t.getAnchorAlignment(e),l=-(s.horizontalAlign-.5)*i,c=-(s.verticalAlign-.5)*o,u=t.evaluateVariableOffset(e,r);return new t.Point((l/a+u[0])*n,(c/a+u[1])*n)}function Ji(e,i,o,r,a,n,s,l,c,u,h){var p=e.text.placedSymbolArray,d=e.text.dynamicLayoutVertexArray,_=e.icon.dynamicLayoutVertexArray,f={};d.clear();for(var m=0;m<p.length;m++){var g=p.get(m),v=g.hidden||!g.crossTileID||e.allowVerticalPlacement&&!g.placedOrientation?null:r[g.crossTileID];if(v){var y=new t.Point(g.anchorX,g.anchorY),x=Jt(y,o?l:s),b=.5+n.cameraToCenterDistance/x.signedDistanceFromCamera*.5,w=a.evaluateSizeForFeature(e.textSizeData,u,g)*b/t.ONE_EM;o&&(w*=e.tilePixelRatio/c);for(var E=Yi(v.anchor,v.width,v.height,v.textOffset,v.textBoxScale,w),T=o?Jt(y.add(E),s).point:x.point.add(i?E.rotate(-n.angle):E),I=e.allowVerticalPlacement&&g.placedOrientation===t.WritingMode.vertical?Math.PI/2:0,C=0;C<g.numGlyphs;C++)t.addDynamicAttributes(d,T,I);h&&g.associatedIconIndex>=0&&(f[g.associatedIconIndex]={shiftedAnchor:T,angle:I});}else ne(g.numGlyphs,d);}if(h){_.clear();for(var S=e.icon.placedSymbolArray,P=0;P<S.length;P++){var z=S.get(P);if(z.hidden)ne(z.numGlyphs,_);else{var L=f[P];if(L)for(var M=0;M<z.numGlyphs;M++)t.addDynamicAttributes(_,L.shiftedAnchor,L.angle);else ne(z.numGlyphs,_);}}e.icon.dynamicLayoutVertexBuffer.updateData(_);}e.text.dynamicLayoutVertexBuffer.updateData(d);}function Qi(t,e,i){return i.iconsInText&&e?"symbolTextAndIcon":t?"symbolSDF":"symbolIcon"}function $i(e,i,o,r,a,n,s,l,c,u,h,p){for(var d=e.context,_=d.gl,f=e.transform,m="map"===l,g="map"===c,v=m&&"point"!==o.layout.get("symbol-placement"),y=m&&!g&&!v,x=void 0!==o.layout.get("symbol-sort-key").constantOr(1),b=e.depthModeForSublayer(0,Ct.ReadOnly),w=o.layout.get("text-variable-anchor"),E=[],T=0,I=r;T<I.length;T+=1){var C=I[T],S=i.getTile(C),P=S.getBucket(o);if(P){var z=a?P.text:P.icon;if(z&&z.segments.get().length){var L=z.programConfigurations.get(o.id),M=a||P.sdfIcons,D=a?P.textSizeData:P.iconSizeData,A=g||0!==f.pitch,R=e.useProgram(Qi(M,a,P),L),k=t.evaluateSizeForZoom(D,f.zoom),B=void 0,O=[0,0],F=void 0,U=void 0,N=null,Z=void 0;if(a)F=S.glyphAtlasTexture,U=_.LINEAR,B=S.glyphAtlasTexture.size,P.iconsInText&&(O=S.imageAtlasTexture.size,N=S.imageAtlasTexture,Z=A||e.options.rotating||e.options.zooming||"composite"===D.kind||"camera"===D.kind?_.LINEAR:_.NEAREST);else{var q=1!==o.layout.get("icon-size").constantOr(0)||P.iconsNeedLinear;F=S.imageAtlasTexture,U=M||e.options.rotating||e.options.zooming||q||A?_.LINEAR:_.NEAREST,B=S.imageAtlasTexture.size;}var j=ue(S,1,e.transform.zoom),V=Kt(C.posMatrix,g,m,e.transform,j),G=Yt(C.posMatrix,g,m,e.transform,j),W=w&&P.hasTextData(),X="none"!==o.layout.get("icon-text-fit")&&W&&P.hasIconData();v&&$t(P,C.posMatrix,e,a,V,G,g,u);var H=e.translatePosMatrix(C.posMatrix,S,n,s),K=v||a&&w||X?Ki:V,Y=e.translatePosMatrix(G,S,n,s,!0),J=M&&0!==o.paint.get(a?"text-halo-width":"icon-halo-width").constantOr(1),Q={program:R,buffers:z,uniformValues:M?P.iconsInText?ji(D.kind,k,y,g,e,H,K,Y,B,O):qi(D.kind,k,y,g,e,H,K,Y,a,B,!0):Zi(D.kind,k,y,g,e,H,K,Y,a,B),atlasTexture:F,atlasTextureIcon:N,atlasInterpolation:U,atlasInterpolationIcon:Z,isSDF:M,hasHalo:J};if(x)for(var $=0,tt=z.segments.get();$<tt.length;$+=1){var et=tt[$];E.push({segments:new t.SegmentVector([et]),sortKey:et.sortKey,state:Q});}else E.push({segments:z.segments,sortKey:0,state:Q});}}}x&&E.sort((function(t,e){return t.sortKey-e.sortKey}));for(var it=0,ot=E;it<ot.length;it+=1){var rt=ot[it],at=rt.state;if(d.activeTexture.set(_.TEXTURE0),at.atlasTexture.bind(at.atlasInterpolation,_.CLAMP_TO_EDGE),at.atlasTextureIcon&&(d.activeTexture.set(_.TEXTURE1),at.atlasTextureIcon&&at.atlasTextureIcon.bind(at.atlasInterpolationIcon,_.CLAMP_TO_EDGE)),at.isSDF){var nt=at.uniformValues;at.hasHalo&&(nt.u_is_halo=1,to(at.buffers,rt.segments,o,e,at.program,b,h,p,nt)),nt.u_is_halo=0;}to(at.buffers,rt.segments,o,e,at.program,b,h,p,at.uniformValues);}}function to(t,e,i,o,r,a,n,s,l){var c=o.context;r.draw(c,c.gl.TRIANGLES,a,n,s,zt.disabled,l,i.id,t.layoutVertexBuffer,t.indexBuffer,e,i.paint,o.transform.zoom,t.programConfigurations.get(i.id),t.dynamicLayoutVertexBuffer,t.opacityVertexBuffer);}function eo(t,e,i,o,r,a,n){var s,l,c,u,h,p=t.context.gl,d=i.paint.get("fill-pattern"),_=d&&d.constantOr(1),f=i.getCrossfadeParameters();n?(l=_&&!i.getPaintProperty("fill-outline-color")?"fillOutlinePattern":"fillOutline",s=p.LINES):(l=_?"fillPattern":"fill",s=p.TRIANGLES);for(var m=0,g=o;m<g.length;m+=1){var v=g[m],y=e.getTile(v);if(!_||y.patternsLoaded()){var x=y.getBucket(i);if(x){var b=x.programConfigurations.get(i.id),w=t.useProgram(l,b);_&&(t.context.activeTexture.set(p.TEXTURE0),y.imageAtlasTexture.bind(p.LINEAR,p.CLAMP_TO_EDGE),b.updatePaintBuffers(f));var E=d.constantOr(null);if(E&&y.imageAtlas){var T=y.imageAtlas,I=T.patternPositions[E.to.toString()],C=T.patternPositions[E.from.toString()];I&&C&&b.setConstantPatternPositions(I,C);}var S=t.translatePosMatrix(v.posMatrix,y,i.paint.get("fill-translate"),i.paint.get("fill-translate-anchor"));if(n){u=x.indexBuffer2,h=x.segments2;var P=[p.drawingBufferWidth,p.drawingBufferHeight];c="fillOutlinePattern"===l&&_?Ti(S,t,f,y,P):Ei(S,P);}else u=x.indexBuffer,h=x.segments,c=_?wi(S,t,f,y):bi(S);w.draw(t.context,s,r,t.stencilModeForClipping(v),a,zt.disabled,c,i.id,x.layoutVertexBuffer,u,h,i.paint,t.transform.zoom,b);}}}}function io(t,e,i,o,r,a,n){for(var s=t.context,l=s.gl,c=i.paint.get("fill-extrusion-pattern"),u=c.constantOr(1),h=i.getCrossfadeParameters(),p=i.paint.get("fill-extrusion-opacity"),d=0,_=o;d<_.length;d+=1){var f=_[d],m=e.getTile(f),g=m.getBucket(i);if(g){var v=g.programConfigurations.get(i.id),y=t.useProgram(u?"fillExtrusionPattern":"fillExtrusion",v);u&&(t.context.activeTexture.set(l.TEXTURE0),m.imageAtlasTexture.bind(l.LINEAR,l.CLAMP_TO_EDGE),v.updatePaintBuffers(h));var x=c.constantOr(null);if(x&&m.imageAtlas){var b=m.imageAtlas,w=b.patternPositions[x.to.toString()],E=b.patternPositions[x.from.toString()];w&&E&&v.setConstantPatternPositions(w,E);}var T=t.translatePosMatrix(f.posMatrix,m,i.paint.get("fill-extrusion-translate"),i.paint.get("fill-extrusion-translate-anchor")),I=i.paint.get("fill-extrusion-vertical-gradient"),C=u?xi(T,t,I,p,f,h,m):yi(T,t,I,p);y.draw(s,s.gl.TRIANGLES,r,a,n,zt.backCCW,C,i.id,g.layoutVertexBuffer,g.indexBuffer,g.segments,i.paint,t.transform.zoom,v);}}}function oo(t,e,i,o,r,a){var n=t.context,s=n.gl,l=e.fbo;if(l){var c=t.useProgram("hillshade");n.activeTexture.set(s.TEXTURE0),s.bindTexture(s.TEXTURE_2D,l.colorAttachment.get());var u=Mi(t,e,i);c.draw(n,s.TRIANGLES,o,r,a,zt.disabled,u,i.id,t.rasterBoundsBuffer,t.quadTriangleIndexBuffer,t.rasterBoundsSegments);}}function ro(e,i,o,r,a,n,s){var l=e.context,c=l.gl,u=i.dem;if(u&&u.data){var h=u.dim,p=u.stride,d=u.getPixels();if(l.activeTexture.set(c.TEXTURE1),l.pixelStoreUnpackPremultiplyAlpha.set(!1),i.demTexture=i.demTexture||e.getTileTexture(p),i.demTexture){var _=i.demTexture;_.update(d,{premultiply:!1}),_.bind(c.NEAREST,c.CLAMP_TO_EDGE);}else i.demTexture=new t.Texture(l,d,c.RGBA,{premultiply:!1}),i.demTexture.bind(c.NEAREST,c.CLAMP_TO_EDGE);l.activeTexture.set(c.TEXTURE0);var f=i.fbo;if(!f){var m=new t.Texture(l,{width:h,height:h,data:null},c.RGBA);m.bind(c.LINEAR,c.CLAMP_TO_EDGE),(f=i.fbo=l.createFramebuffer(h,h,!0)).colorAttachment.set(m.texture);}l.bindFramebuffer.set(f.framebuffer),l.viewport.set([0,0,h,h]),e.useProgram("hillshadePrepare").draw(l,c.TRIANGLES,a,n,s,zt.disabled,Di(i.tileID,u,r),o.id,e.rasterBoundsBuffer,e.quadTriangleIndexBuffer,e.rasterBoundsSegments),i.needsHillshadePrepare=!1;}}function ao(e,i,o,r,a){var n=r.paint.get("raster-fade-duration");if(n>0){var s=t.browser.now(),l=(s-e.timeAdded)/n,c=i?(s-i.timeAdded)/n:-1,u=o.getSource(),h=a.coveringZoomLevel({tileSize:u.tileSize,roundZoom:u.roundZoom}),p=!i||Math.abs(i.tileID.overscaledZ-h)>Math.abs(e.tileID.overscaledZ-h),d=p&&e.refreshedUponExpiration?1:t.clamp(p?l:1-c,0,1);return e.refreshedUponExpiration&&l>=1&&(e.refreshedUponExpiration=!1),i?{opacity:1,mix:1-d}:{opacity:d,mix:0}}return {opacity:1,mix:0}}var no=new t.Color(1,0,0,1),so=new t.Color(0,1,0,1),lo=new t.Color(0,0,1,1),co=new t.Color(1,0,1,1),uo=new t.Color(0,1,1,1);function ho(t,e,i,o){_o(t,0,e+i/2,t.transform.width,i,o);}function po(t,e,i,o){_o(t,e-i/2,0,i,t.transform.height,o);}function _o(e,i,o,r,a,n){var s=e.context,l=s.gl;l.enable(l.SCISSOR_TEST),l.scissor(i*t.browser.devicePixelRatio,o*t.browser.devicePixelRatio,r*t.browser.devicePixelRatio,a*t.browser.devicePixelRatio),s.clear({color:n}),l.disable(l.SCISSOR_TEST);}function fo(e,i,o){var r=e.context,a=r.gl,n=o.posMatrix,s=e.useProgram("debug"),l=Ct.disabled,c=St.disabled,u=e.colorModeForRenderPass();r.activeTexture.set(a.TEXTURE0),e.emptyTexture.bind(a.LINEAR,a.CLAMP_TO_EDGE),s.draw(r,a.LINE_STRIP,l,c,u,zt.disabled,Pi(n,t.Color.red),"$debug",e.debugBuffer,e.tileBorderIndexBuffer,e.debugSegments);var h=i.getTileByID(o.key).latestRawTileData,p=Math.floor((h&&h.byteLength||0)/1024),d=i.getTile(o).tileSize,_=512/Math.min(d,512)*(o.overscaledZ/e.transform.zoom)*.5,f=o.canonical.toString();o.overscaledZ!==o.canonical.z&&(f+=" => "+o.overscaledZ),function(t,e){t.initDebugOverlayCanvas();var i=t.debugOverlayCanvas,o=t.context.gl,r=t.debugOverlayCanvas.getContext("2d");r.clearRect(0,0,i.width,i.height),r.shadowColor="white",r.shadowBlur=2,r.lineWidth=1.5,r.strokeStyle="white",r.textBaseline="top",r.font="bold 36px Open Sans, sans-serif",r.fillText(e,5,5),r.strokeText(e,5,5),t.debugOverlayTexture.update(i),t.debugOverlayTexture.bind(o.LINEAR,o.CLAMP_TO_EDGE);}(e,f+" "+p+"kb"),s.draw(r,a.TRIANGLES,l,c,Pt.alphaBlended,zt.disabled,Pi(n,t.Color.transparent,_),"$debug",e.debugBuffer,e.quadTriangleIndexBuffer,e.debugSegments);}var mo={symbol:function(e,i,o,r,a){if("translucent"===e.renderPass){var n=St.disabled,s=e.colorModeForRenderPass();o.layout.get("text-variable-anchor")&&function(e,i,o,r,a,n,s){for(var l=i.transform,c="map"===a,u="map"===n,h=0,p=e;h<p.length;h+=1){var d=p[h],_=r.getTile(d),f=_.getBucket(o);if(f&&f.text&&f.text.segments.get().length){var m=t.evaluateSizeForZoom(f.textSizeData,l.zoom),g=ue(_,1,i.transform.zoom),v=Kt(d.posMatrix,u,c,i.transform,g),y="none"!==o.layout.get("icon-text-fit")&&f.hasIconData();if(m){var x=Math.pow(2,l.zoom-_.tileID.overscaledZ);Ji(f,c,u,s,t.symbolSize,l,v,d.posMatrix,x,m,y);}}}}(r,e,o,i,o.layout.get("text-rotation-alignment"),o.layout.get("text-pitch-alignment"),a),0!==o.paint.get("icon-opacity").constantOr(1)&&$i(e,i,o,r,!1,o.paint.get("icon-translate"),o.paint.get("icon-translate-anchor"),o.layout.get("icon-rotation-alignment"),o.layout.get("icon-pitch-alignment"),o.layout.get("icon-keep-upright"),n,s),0!==o.paint.get("text-opacity").constantOr(1)&&$i(e,i,o,r,!0,o.paint.get("text-translate"),o.paint.get("text-translate-anchor"),o.layout.get("text-rotation-alignment"),o.layout.get("text-pitch-alignment"),o.layout.get("text-keep-upright"),n,s),i.map.showCollisionBoxes&&(Hi(e,i,o,r,o.paint.get("text-translate"),o.paint.get("text-translate-anchor"),!0),Hi(e,i,o,r,o.paint.get("icon-translate"),o.paint.get("icon-translate-anchor"),!1));}},circle:function(e,i,o,r){if("translucent"===e.renderPass){var a=o.paint.get("circle-opacity"),n=o.paint.get("circle-stroke-width"),s=o.paint.get("circle-stroke-opacity"),l=void 0!==o.layout.get("circle-sort-key").constantOr(1);if(0!==a.constantOr(1)||0!==n.constantOr(1)&&0!==s.constantOr(1)){for(var c=e.context,u=c.gl,h=e.depthModeForSublayer(0,Ct.ReadOnly),p=St.disabled,d=e.colorModeForRenderPass(),_=[],f=0;f<r.length;f++){var m=r[f],g=i.getTile(m),v=g.getBucket(o);if(v){var y=v.programConfigurations.get(o.id),x={programConfiguration:y,program:e.useProgram("circle",y),layoutVertexBuffer:v.layoutVertexBuffer,indexBuffer:v.indexBuffer,uniformValues:Ii(e,m,g,o)};if(l)for(var b=0,w=v.segments.get();b<w.length;b+=1){var E=w[b];_.push({segments:new t.SegmentVector([E]),sortKey:E.sortKey,state:x});}else _.push({segments:v.segments,sortKey:0,state:x});}}l&&_.sort((function(t,e){return t.sortKey-e.sortKey}));for(var T=0,I=_;T<I.length;T+=1){var C=I[T],S=C.state;S.program.draw(c,u.TRIANGLES,h,p,d,zt.disabled,S.uniformValues,o.id,S.layoutVertexBuffer,S.indexBuffer,C.segments,o.paint,e.transform.zoom,S.programConfiguration);}}}},heatmap:function(e,i,o,r){if(0!==o.paint.get("heatmap-opacity"))if("offscreen"===e.renderPass){var a=e.context,n=a.gl,s=St.disabled,l=new Pt([n.ONE,n.ONE],t.Color.transparent,[!0,!0,!0,!0]);!function(t,e,i){var o=t.gl;t.activeTexture.set(o.TEXTURE1),t.viewport.set([0,0,e.width/4,e.height/4]);var r=i.heatmapFbo;if(r)o.bindTexture(o.TEXTURE_2D,r.colorAttachment.get()),t.bindFramebuffer.set(r.framebuffer);else{var a=o.createTexture();o.bindTexture(o.TEXTURE_2D,a),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_S,o.CLAMP_TO_EDGE),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_T,o.CLAMP_TO_EDGE),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MIN_FILTER,o.LINEAR),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MAG_FILTER,o.LINEAR),r=i.heatmapFbo=t.createFramebuffer(e.width/4,e.height/4,!1),function t(e,i,o,r){var a=e.gl;a.texImage2D(a.TEXTURE_2D,0,a.RGBA,i.width/4,i.height/4,0,a.RGBA,e.extTextureHalfFloat?e.extTextureHalfFloat.HALF_FLOAT_OES:a.UNSIGNED_BYTE,null),r.colorAttachment.set(o),e.extTextureHalfFloat&&a.checkFramebufferStatus(a.FRAMEBUFFER)!==a.FRAMEBUFFER_COMPLETE&&(e.extTextureHalfFloat=null,r.colorAttachment.setDirty(),t(e,i,o,r));}(t,e,a,r);}}(a,e,o),a.clear({color:t.Color.transparent});for(var c=0;c<r.length;c++){var u=r[c];if(!i.hasRenderableParent(u)){var h=i.getTile(u),p=h.getBucket(o);if(p){var d=p.programConfigurations.get(o.id);e.useProgram("heatmap",d).draw(a,n.TRIANGLES,Ct.disabled,s,l,zt.disabled,Li(u.posMatrix,h,e.transform.zoom,o.paint.get("heatmap-intensity")),o.id,p.layoutVertexBuffer,p.indexBuffer,p.segments,o.paint,e.transform.zoom,d);}}}a.viewport.set([0,0,e.width,e.height]);}else"translucent"===e.renderPass&&(e.context.setColorMode(e.colorModeForRenderPass()),function(e,i){var o=e.context,r=o.gl,a=i.heatmapFbo;if(a){o.activeTexture.set(r.TEXTURE0),r.bindTexture(r.TEXTURE_2D,a.colorAttachment.get()),o.activeTexture.set(r.TEXTURE1);var n=i.colorRampTexture;n||(n=i.colorRampTexture=new t.Texture(o,i.colorRamp,r.RGBA)),n.bind(r.LINEAR,r.CLAMP_TO_EDGE),e.useProgram("heatmapTexture").draw(o,r.TRIANGLES,Ct.disabled,St.disabled,e.colorModeForRenderPass(),zt.disabled,function(e,i,o,r){var a=t.create();t.ortho(a,0,e.width,e.height,0,0,1);var n=e.context.gl;return {u_matrix:a,u_world:[n.drawingBufferWidth,n.drawingBufferHeight],u_image:0,u_color_ramp:1,u_opacity:i.paint.get("heatmap-opacity")}}(e,i),i.id,e.viewportBuffer,e.quadTriangleIndexBuffer,e.viewportSegments,i.paint,e.transform.zoom);}}(e,o));},line:function(e,i,o,r){if("translucent"===e.renderPass){var a=o.paint.get("line-opacity"),n=o.paint.get("line-width");if(0!==a.constantOr(1)&&0!==n.constantOr(1)){var s=e.depthModeForSublayer(0,Ct.ReadOnly),l=e.colorModeForRenderPass(),c=o.paint.get("line-dasharray"),u=o.paint.get("line-pattern"),h=u.constantOr(1),p=o.paint.get("line-gradient"),d=o.getCrossfadeParameters(),_=h?"linePattern":c?"lineSDF":p?"lineGradient":"line",f=e.context,m=f.gl,g=!0;if(p){f.activeTexture.set(m.TEXTURE0);var v=o.gradientTexture;if(!o.gradient)return;v||(v=o.gradientTexture=new t.Texture(f,o.gradient,m.RGBA)),v.bind(m.LINEAR,m.CLAMP_TO_EDGE);}for(var y=0,x=r;y<x.length;y+=1){var b=x[y],w=i.getTile(b);if(!h||w.patternsLoaded()){var E=w.getBucket(o);if(E){var T=E.programConfigurations.get(o.id),I=e.context.program.get(),C=e.useProgram(_,T),S=g||C.program!==I,P=u.constantOr(null);if(P&&w.imageAtlas){var z=w.imageAtlas,L=z.patternPositions[P.to.toString()],M=z.patternPositions[P.from.toString()];L&&M&&T.setConstantPatternPositions(L,M);}var D=h?ki(e,w,o,d):c?Bi(e,w,o,c,d):p?Ri(e,w,o):Ai(e,w,o);h?(f.activeTexture.set(m.TEXTURE0),w.imageAtlasTexture.bind(m.LINEAR,m.CLAMP_TO_EDGE),T.updatePaintBuffers(d)):c&&(S||e.lineAtlas.dirty)&&(f.activeTexture.set(m.TEXTURE0),e.lineAtlas.bind(f)),C.draw(f,m.TRIANGLES,s,e.stencilModeForClipping(b),l,zt.disabled,D,o.id,E.layoutVertexBuffer,E.indexBuffer,E.segments,o.paint,e.transform.zoom,T),g=!1;}}}}}},fill:function(e,i,o,r){var a=o.paint.get("fill-color"),n=o.paint.get("fill-opacity");if(0!==n.constantOr(1)){var s=e.colorModeForRenderPass(),l=o.paint.get("fill-pattern"),c=e.opaquePassEnabledForLayer()&&!l.constantOr(1)&&1===a.constantOr(t.Color.transparent).a&&1===n.constantOr(0)?"opaque":"translucent";if(e.renderPass===c){var u=e.depthModeForSublayer(1,"opaque"===e.renderPass?Ct.ReadWrite:Ct.ReadOnly);eo(e,i,o,r,u,s,!1);}if("translucent"===e.renderPass&&o.paint.get("fill-antialias")){var h=e.depthModeForSublayer(o.getPaintProperty("fill-outline-color")?2:0,Ct.ReadOnly);eo(e,i,o,r,h,s,!0);}}},"fill-extrusion":function(t,e,i,o){var r=i.paint.get("fill-extrusion-opacity");if(0!==r&&"translucent"===t.renderPass){var a=new Ct(t.context.gl.LEQUAL,Ct.ReadWrite,t.depthRangeFor3D);if(1!==r||i.paint.get("fill-extrusion-pattern").constantOr(1))io(t,e,i,o,a,St.disabled,Pt.disabled),io(t,e,i,o,a,t.stencilModeFor3D(),t.colorModeForRenderPass());else{var n=t.colorModeForRenderPass();io(t,e,i,o,a,St.disabled,n);}}},hillshade:function(t,e,i,o){if("offscreen"===t.renderPass||"translucent"===t.renderPass){for(var r=t.context,a=e.getSource().maxzoom,n=t.depthModeForSublayer(0,Ct.ReadOnly),s=t.colorModeForRenderPass(),l="translucent"===t.renderPass?t.stencilConfigForOverlap(o):[{},o],c=l[0],u=0,h=l[1];u<h.length;u+=1){var p=h[u],d=e.getTile(p);d.needsHillshadePrepare&&"offscreen"===t.renderPass?ro(t,d,i,a,n,St.disabled,s):"translucent"===t.renderPass&&oo(t,d,i,n,c[p.overscaledZ],s);}r.viewport.set([0,0,t.width,t.height]);}},raster:function(t,e,i,o){if("translucent"===t.renderPass&&0!==i.paint.get("raster-opacity")&&o.length)for(var r=t.context,a=r.gl,n=e.getSource(),s=t.useProgram("raster"),l=t.colorModeForRenderPass(),c=n instanceof D?[{},o]:t.stencilConfigForOverlap(o),u=c[0],h=c[1],p=h[h.length-1].overscaledZ,d=!t.options.moving,_=0,f=h;_<f.length;_+=1){var m=f[_],g=t.depthModeForSublayer(m.overscaledZ-p,1===i.paint.get("raster-opacity")?Ct.ReadWrite:Ct.ReadOnly,a.LESS),v=e.getTile(m),y=t.transform.calculatePosMatrix(m.toUnwrapped(),d);v.registerFadeDuration(i.paint.get("raster-fade-duration"));var x=e.findLoadedParent(m,0),b=ao(v,x,e,i,t.transform),w=void 0,E=void 0,T="nearest"===i.paint.get("raster-resampling")?a.NEAREST:a.LINEAR;r.activeTexture.set(a.TEXTURE0),v.texture.bind(T,a.CLAMP_TO_EDGE,a.LINEAR_MIPMAP_NEAREST),r.activeTexture.set(a.TEXTURE1),x?(x.texture.bind(T,a.CLAMP_TO_EDGE,a.LINEAR_MIPMAP_NEAREST),w=Math.pow(2,x.tileID.overscaledZ-v.tileID.overscaledZ),E=[v.tileID.canonical.x*w%1,v.tileID.canonical.y*w%1]):v.texture.bind(T,a.CLAMP_TO_EDGE,a.LINEAR_MIPMAP_NEAREST);var I=Ui(y,E||[0,0],w||1,b,i);n instanceof D?s.draw(r,a.TRIANGLES,g,St.disabled,l,zt.disabled,I,i.id,n.boundsBuffer,t.quadTriangleIndexBuffer,n.boundsSegments):s.draw(r,a.TRIANGLES,g,u[m.overscaledZ],l,zt.disabled,I,i.id,t.rasterBoundsBuffer,t.quadTriangleIndexBuffer,t.rasterBoundsSegments);}},background:function(t,e,i){var o=i.paint.get("background-color"),r=i.paint.get("background-opacity");if(0!==r){var a=t.context,n=a.gl,s=t.transform,l=s.tileSize,c=i.paint.get("background-pattern");if(!t.isPatternMissing(c)){var u=!c&&1===o.a&&1===r&&t.opaquePassEnabledForLayer()?"opaque":"translucent";if(t.renderPass===u){var h=St.disabled,p=t.depthModeForSublayer(0,"opaque"===u?Ct.ReadWrite:Ct.ReadOnly),d=t.colorModeForRenderPass(),_=t.useProgram(c?"backgroundPattern":"background"),f=s.coveringTiles({tileSize:l});c&&(a.activeTexture.set(n.TEXTURE0),t.imageManager.bind(t.context));for(var m=i.getCrossfadeParameters(),g=0,v=f;g<v.length;g+=1){var y=v[g],x=t.transform.calculatePosMatrix(y.toUnwrapped()),b=c?Gi(x,r,t,c,{tileID:y,tileSize:l},m):Vi(x,r,o);_.draw(a,n.TRIANGLES,p,h,d,zt.disabled,b,i.id,t.tileExtentBuffer,t.quadTriangleIndexBuffer,t.tileExtentSegments);}}}}},debug:function(t,e,i){for(var o=0;o<i.length;o++)fo(t,e,i[o]);},custom:function(t,e,i){var o=t.context,r=i.implementation;if("offscreen"===t.renderPass){var a=r.prerender;a&&(t.setCustomLayerDefaults(),o.setColorMode(t.colorModeForRenderPass()),a.call(r,o.gl,t.transform.customLayerMatrix()),o.setDirty(),t.setBaseState());}else if("translucent"===t.renderPass){t.setCustomLayerDefaults(),o.setColorMode(t.colorModeForRenderPass()),o.setStencilMode(St.disabled);var n="3d"===r.renderingMode?new Ct(t.context.gl.LEQUAL,Ct.ReadWrite,t.depthRangeFor3D):t.depthModeForSublayer(0,Ct.ReadOnly);o.setDepthMode(n),r.render(o.gl,t.transform.customLayerMatrix()),o.setDirty(),t.setBaseState(),o.bindFramebuffer.set(null);}}},go=function(t,e){this.context=new Lt(t),this.transform=e,this._tileTextures={},this.setup(),this.numSublayers=Mt.maxUnderzooming+Mt.maxOverzooming+1,this.depthEpsilon=1/Math.pow(2,16),this.crossTileSymbolIndex=new ke,this.gpuTimers={};};go.prototype.resize=function(e,i){if(this.width=e*t.browser.devicePixelRatio,this.height=i*t.browser.devicePixelRatio,this.context.viewport.set([0,0,this.width,this.height]),this.style)for(var o=0,r=this.style._order;o<r.length;o+=1)this.style._layers[r[o]].resize();},go.prototype.setup=function(){var e=this.context,i=new t.StructArrayLayout2i4;i.emplaceBack(0,0),i.emplaceBack(t.EXTENT,0),i.emplaceBack(0,t.EXTENT),i.emplaceBack(t.EXTENT,t.EXTENT),this.tileExtentBuffer=e.createVertexBuffer(i,Ze.members),this.tileExtentSegments=t.SegmentVector.simpleSegment(0,0,4,2);var o=new t.StructArrayLayout2i4;o.emplaceBack(0,0),o.emplaceBack(t.EXTENT,0),o.emplaceBack(0,t.EXTENT),o.emplaceBack(t.EXTENT,t.EXTENT),this.debugBuffer=e.createVertexBuffer(o,Ze.members),this.debugSegments=t.SegmentVector.simpleSegment(0,0,4,5);var r=new t.StructArrayLayout4i8;r.emplaceBack(0,0,0,0),r.emplaceBack(t.EXTENT,0,t.EXTENT,0),r.emplaceBack(0,t.EXTENT,0,t.EXTENT),r.emplaceBack(t.EXTENT,t.EXTENT,t.EXTENT,t.EXTENT),this.rasterBoundsBuffer=e.createVertexBuffer(r,M.members),this.rasterBoundsSegments=t.SegmentVector.simpleSegment(0,0,4,2);var a=new t.StructArrayLayout2i4;a.emplaceBack(0,0),a.emplaceBack(1,0),a.emplaceBack(0,1),a.emplaceBack(1,1),this.viewportBuffer=e.createVertexBuffer(a,Ze.members),this.viewportSegments=t.SegmentVector.simpleSegment(0,0,4,2);var n=new t.StructArrayLayout1ui2;n.emplaceBack(0),n.emplaceBack(1),n.emplaceBack(3),n.emplaceBack(2),n.emplaceBack(0),this.tileBorderIndexBuffer=e.createIndexBuffer(n);var s=new t.StructArrayLayout3ui6;s.emplaceBack(0,1,2),s.emplaceBack(2,1,3),this.quadTriangleIndexBuffer=e.createIndexBuffer(s),this.emptyTexture=new t.Texture(e,{width:1,height:1,data:new Uint8Array([0,0,0,0])},e.gl.RGBA);var l=this.context.gl;this.stencilClearMode=new St({func:l.ALWAYS,mask:0},0,255,l.ZERO,l.ZERO,l.ZERO);},go.prototype.clearStencil=function(){var e=this.context,i=e.gl;this.nextStencilID=1,this.currentStencilSource=void 0;var o=t.create();t.ortho(o,0,this.width,this.height,0,0,1),t.scale(o,o,[i.drawingBufferWidth,i.drawingBufferHeight,0]),this.useProgram("clippingMask").draw(e,i.TRIANGLES,Ct.disabled,this.stencilClearMode,Pt.disabled,zt.disabled,zi(o),"$clipping",this.viewportBuffer,this.quadTriangleIndexBuffer,this.viewportSegments);},go.prototype._renderTileClippingMasks=function(t,e){if(this.currentStencilSource!==t.source&&t.isTileClipped()&&e&&e.length){this.currentStencilSource=t.source;var i=this.context,o=i.gl;this.nextStencilID+e.length>256&&this.clearStencil(),i.setColorMode(Pt.disabled),i.setDepthMode(Ct.disabled);var r=this.useProgram("clippingMask");this._tileClippingMaskIDs={};for(var a=0,n=e;a<n.length;a+=1){var s=n[a],l=this._tileClippingMaskIDs[s.key]=this.nextStencilID++;r.draw(i,o.TRIANGLES,Ct.disabled,new St({func:o.ALWAYS,mask:0},l,255,o.KEEP,o.KEEP,o.REPLACE),Pt.disabled,zt.disabled,zi(s.posMatrix),"$clipping",this.tileExtentBuffer,this.quadTriangleIndexBuffer,this.tileExtentSegments);}}},go.prototype.stencilModeFor3D=function(){this.currentStencilSource=void 0,this.nextStencilID+1>256&&this.clearStencil();var t=this.nextStencilID++,e=this.context.gl;return new St({func:e.NOTEQUAL,mask:255},t,255,e.KEEP,e.KEEP,e.REPLACE)},go.prototype.stencilModeForClipping=function(t){var e=this.context.gl;return new St({func:e.EQUAL,mask:255},this._tileClippingMaskIDs[t.key],0,e.KEEP,e.KEEP,e.REPLACE)},go.prototype.stencilConfigForOverlap=function(t){var e,i=this.context.gl,o=t.sort((function(t,e){return e.overscaledZ-t.overscaledZ})),r=o[o.length-1].overscaledZ,a=o[0].overscaledZ-r+1;if(a>1){this.currentStencilSource=void 0,this.nextStencilID+a>256&&this.clearStencil();for(var n={},s=0;s<a;s++)n[s+r]=new St({func:i.GEQUAL,mask:255},s+this.nextStencilID,255,i.KEEP,i.KEEP,i.REPLACE);return this.nextStencilID+=a,[n,o]}return [(e={},e[r]=St.disabled,e),o]},go.prototype.colorModeForRenderPass=function(){var e=this.context.gl;return this._showOverdrawInspector?new Pt([e.CONSTANT_COLOR,e.ONE],new t.Color(1/8,1/8,1/8,0),[!0,!0,!0,!0]):"opaque"===this.renderPass?Pt.unblended:Pt.alphaBlended},go.prototype.depthModeForSublayer=function(t,e,i){if(!this.opaquePassEnabledForLayer())return Ct.disabled;var o=1-((1+this.currentLayer)*this.numSublayers+t)*this.depthEpsilon;return new Ct(i||this.context.gl.LEQUAL,e,[o,o])},go.prototype.opaquePassEnabledForLayer=function(){return this.currentLayer<this.opaquePassCutoff},go.prototype.render=function(e,i){var o=this;this.style=e,this.options=i,this.lineAtlas=e.lineAtlas,this.imageManager=e.imageManager,this.glyphManager=e.glyphManager,this.symbolFadeChange=e.placement.symbolFadeChange(t.browser.now()),this.imageManager.beginFrame();var r=this.style._order,a=this.style.sourceCaches;for(var n in a){var s=a[n];s.used&&s.prepare(this.context);}var l,c,u={},h={},p={};for(var d in a){var _=a[d];u[d]=_.getVisibleCoordinates(),h[d]=u[d].slice().reverse(),p[d]=_.getVisibleCoordinates(!0).reverse();}this.opaquePassCutoff=1/0;for(var f=0;f<r.length;f++)if(this.style._layers[r[f]].is3D()){this.opaquePassCutoff=f;break}this.renderPass="offscreen";for(var m=0,g=r;m<g.length;m+=1){var v=this.style._layers[g[m]];if(v.hasOffscreenPass()&&!v.isHidden(this.transform.zoom)){var y=h[v.source];("custom"===v.type||y.length)&&this.renderLayer(this,a[v.source],v,y);}}for(this.context.bindFramebuffer.set(null),this.context.clear({color:i.showOverdrawInspector?t.Color.black:t.Color.transparent,depth:1}),this.clearStencil(),this._showOverdrawInspector=i.showOverdrawInspector,this.depthRangeFor3D=[0,1-(e._order.length+2)*this.numSublayers*this.depthEpsilon],this.renderPass="opaque",this.currentLayer=r.length-1;this.currentLayer>=0;this.currentLayer--){var x=this.style._layers[r[this.currentLayer]],b=a[x.source],w=u[x.source];this._renderTileClippingMasks(x,w),this.renderLayer(this,b,x,w);}for(this.renderPass="translucent",this.currentLayer=0;this.currentLayer<r.length;this.currentLayer++){var E=this.style._layers[r[this.currentLayer]],T=a[E.source],I=("symbol"===E.type?p:h)[E.source];this._renderTileClippingMasks(E,u[E.source]),this.renderLayer(this,T,E,I);}this.options.showTileBoundaries&&(t.values(this.style._layers).forEach((function(t){t.source&&!t.isHidden(o.transform.zoom)&&(t.source!==(c&&c.id)&&(c=o.style.sourceCaches[t.source]),(!l||l.getSource().maxzoom<c.getSource().maxzoom)&&(l=c));})),l&&mo.debug(this,l,l.getVisibleCoordinates())),this.options.showPadding&&function(t){var e=t.transform.padding;ho(t,t.transform.height-(e.top||0),3,no),ho(t,e.bottom||0,3,so),po(t,e.left||0,3,lo),po(t,t.transform.width-(e.right||0),3,co);var i=t.transform.centerPoint;!function(t,e,i,o){_o(t,e-1,i-10,2,20,o),_o(t,e-10,i-1,20,2,o);}(t,i.x,t.transform.height-i.y,uo);}(this),this.context.setDefault();},go.prototype.renderLayer=function(t,e,i,o){i.isHidden(this.transform.zoom)||("background"===i.type||"custom"===i.type||o.length)&&(this.id=i.id,this.gpuTimingStart(i),mo[i.type](t,e,i,o,this.style.placement.variableOffsets),this.gpuTimingEnd());},go.prototype.gpuTimingStart=function(t){if(this.options.gpuTiming){var e=this.context.extTimerQuery,i=this.gpuTimers[t.id];i||(i=this.gpuTimers[t.id]={calls:0,cpuTime:0,query:e.createQueryEXT()}),i.calls++,e.beginQueryEXT(e.TIME_ELAPSED_EXT,i.query);}},go.prototype.gpuTimingEnd=function(){if(this.options.gpuTiming){var t=this.context.extTimerQuery;t.endQueryEXT(t.TIME_ELAPSED_EXT);}},go.prototype.collectGpuTimers=function(){var t=this.gpuTimers;return this.gpuTimers={},t},go.prototype.queryGpuTimers=function(t){var e={};for(var i in t){var o=t[i],r=this.context.extTimerQuery,a=r.getQueryObjectEXT(o.query,r.QUERY_RESULT_EXT)/1e6;r.deleteQueryEXT(o.query),e[i]=a;}return e},go.prototype.translatePosMatrix=function(e,i,o,r,a){if(!o[0]&&!o[1])return e;var n=a?"map"===r?this.transform.angle:0:"viewport"===r?-this.transform.angle:0;if(n){var s=Math.sin(n),l=Math.cos(n);o=[o[0]*l-o[1]*s,o[0]*s+o[1]*l];}var c=[a?o[0]:ue(i,o[0],this.transform.zoom),a?o[1]:ue(i,o[1],this.transform.zoom),0],u=new Float32Array(16);return t.translate(u,e,c),u},go.prototype.saveTileTexture=function(t){var e=this._tileTextures[t.size[0]];e?e.push(t):this._tileTextures[t.size[0]]=[t];},go.prototype.getTileTexture=function(t){var e=this._tileTextures[t];return e&&e.length>0?e.pop():null},go.prototype.isPatternMissing=function(t){if(!t)return !1;var e=this.imageManager.getPattern(t.from.toString()),i=this.imageManager.getPattern(t.to.toString());return !e||!i},go.prototype.useProgram=function(t,e){this.cache=this.cache||{};var i=""+t+(e?e.cacheKey:"")+(this._showOverdrawInspector?"/overdraw":"");return this.cache[i]||(this.cache[i]=new gi(this.context,fi[t],e,Wi[t],this._showOverdrawInspector)),this.cache[i]},go.prototype.setCustomLayerDefaults=function(){this.context.unbindVAO(),this.context.cullFace.setDefault(),this.context.activeTexture.setDefault(),this.context.pixelStoreUnpack.setDefault(),this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(),this.context.pixelStoreUnpackFlipY.setDefault();},go.prototype.setBaseState=function(){var t=this.context.gl;this.context.cullFace.set(!1),this.context.viewport.set([0,0,this.width,this.height]),this.context.blendEquation.set(t.FUNC_ADD);},go.prototype.initDebugOverlayCanvas=function(){null==this.debugOverlayCanvas&&(this.debugOverlayCanvas=t.window.document.createElement("canvas"),this.debugOverlayCanvas.width=512,this.debugOverlayCanvas.height=512,this.debugOverlayTexture=new t.Texture(this.context,this.debugOverlayCanvas,this.context.gl.RGBA));},go.prototype.destroy=function(){this.emptyTexture.destroy(),this.debugOverlayTexture&&this.debugOverlayTexture.destroy();};var vo=function(t,e){this.points=t,this.planes=e;};vo.fromInvProjectionMatrix=function(e,i,o){var r=Math.pow(2,o),a=[[-1,1,-1,1],[1,1,-1,1],[1,-1,-1,1],[-1,-1,-1,1],[-1,1,1,1],[1,1,1,1],[1,-1,1,1],[-1,-1,1,1]].map((function(i){return t.transformMat4([],i,e)})).map((function(e){return t.scale$1([],e,1/e[3]/i*r)})),n=[[0,1,2],[6,5,4],[0,3,7],[2,1,5],[3,2,6],[0,4,5]].map((function(e){var i=t.sub([],a[e[0]],a[e[1]]),o=t.sub([],a[e[2]],a[e[1]]),r=t.normalize([],t.cross([],i,o)),n=-t.dot(r,a[e[1]]);return r.concat(n)}));return new vo(a,n)};var yo=function(e,i){this.min=e,this.max=i,this.center=t.scale$2([],t.add([],this.min,this.max),.5);};yo.prototype.quadrant=function(e){for(var i=[e%2==0,e<2],o=t.clone$2(this.min),r=t.clone$2(this.max),a=0;a<i.length;a++)o[a]=i[a]?this.min[a]:this.center[a],r[a]=i[a]?this.center[a]:this.max[a];return r[2]=this.max[2],new yo(o,r)},yo.prototype.distanceX=function(t){return Math.max(Math.min(this.max[0],t[0]),this.min[0])-t[0]},yo.prototype.distanceY=function(t){return Math.max(Math.min(this.max[1],t[1]),this.min[1])-t[1]},yo.prototype.intersects=function(e){for(var i=[[this.min[0],this.min[1],0,1],[this.max[0],this.min[1],0,1],[this.max[0],this.max[1],0,1],[this.min[0],this.max[1],0,1]],o=!0,r=0;r<e.planes.length;r++){for(var a=e.planes[r],n=0,s=0;s<i.length;s++)n+=t.dot$1(a,i[s])>=0;if(0===n)return 0;n!==i.length&&(o=!1);}if(o)return 2;for(var l=0;l<3;l++){for(var c=Number.MAX_VALUE,u=-Number.MAX_VALUE,h=0;h<e.points.length;h++){var p=e.points[h][l]-this.min[l];c=Math.min(c,p),u=Math.max(u,p);}if(u<0||c>this.max[l]-this.min[l])return 0}return 1};var xo=function(t,e,i,o){if(void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),void 0===o&&(o=0),isNaN(t)||t<0||isNaN(e)||e<0||isNaN(i)||i<0||isNaN(o)||o<0)throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");this.top=t,this.bottom=e,this.left=i,this.right=o;};xo.prototype.interpolate=function(e,i,o){return null!=i.top&&null!=e.top&&(this.top=t.number(e.top,i.top,o)),null!=i.bottom&&null!=e.bottom&&(this.bottom=t.number(e.bottom,i.bottom,o)),null!=i.left&&null!=e.left&&(this.left=t.number(e.left,i.left,o)),null!=i.right&&null!=e.right&&(this.right=t.number(e.right,i.right,o)),this},xo.prototype.getCenter=function(e,i){var o=t.clamp((this.left+e-this.right)/2,0,e),r=t.clamp((this.top+i-this.bottom)/2,0,i);return new t.Point(o,r)},xo.prototype.equals=function(t){return this.top===t.top&&this.bottom===t.bottom&&this.left===t.left&&this.right===t.right},xo.prototype.clone=function(){return new xo(this.top,this.bottom,this.left,this.right)},xo.prototype.toJSON=function(){return {top:this.top,bottom:this.bottom,left:this.left,right:this.right}};var bo=function(e,i,o,r,a){this.tileSize=512,this.maxValidLatitude=85.051129,this._renderWorldCopies=void 0===a||a,this._minZoom=e||0,this._maxZoom=i||22,this._minPitch=null==o?0:o,this._maxPitch=null==r?60:r,this.setMaxBounds(),this.width=0,this.height=0,this._center=new t.LngLat(0,0),this.zoom=0,this.angle=0,this._fov=.6435011087932844,this._pitch=0,this._unmodified=!0,this._edgeInsets=new xo,this._posMatrixCache={},this._alignedPosMatrixCache={};},wo={minZoom:{configurable:!0},maxZoom:{configurable:!0},minPitch:{configurable:!0},maxPitch:{configurable:!0},renderWorldCopies:{configurable:!0},worldSize:{configurable:!0},centerOffset:{configurable:!0},size:{configurable:!0},bearing:{configurable:!0},pitch:{configurable:!0},fov:{configurable:!0},zoom:{configurable:!0},center:{configurable:!0},padding:{configurable:!0},centerPoint:{configurable:!0},unmodified:{configurable:!0},point:{configurable:!0}};bo.prototype.clone=function(){var t=new bo(this._minZoom,this._maxZoom,this._minPitch,this.maxPitch,this._renderWorldCopies);return t.tileSize=this.tileSize,t.latRange=this.latRange,t.width=this.width,t.height=this.height,t._center=this._center,t.zoom=this.zoom,t.angle=this.angle,t._fov=this._fov,t._pitch=this._pitch,t._unmodified=this._unmodified,t._edgeInsets=this._edgeInsets.clone(),t._calcMatrices(),t},wo.minZoom.get=function(){return this._minZoom},wo.minZoom.set=function(t){this._minZoom!==t&&(this._minZoom=t,this.zoom=Math.max(this.zoom,t));},wo.maxZoom.get=function(){return this._maxZoom},wo.maxZoom.set=function(t){this._maxZoom!==t&&(this._maxZoom=t,this.zoom=Math.min(this.zoom,t));},wo.minPitch.get=function(){return this._minPitch},wo.minPitch.set=function(t){this._minPitch!==t&&(this._minPitch=t,this.pitch=Math.max(this.pitch,t));},wo.maxPitch.get=function(){return this._maxPitch},wo.maxPitch.set=function(t){this._maxPitch!==t&&(this._maxPitch=t,this.pitch=Math.min(this.pitch,t));},wo.renderWorldCopies.get=function(){return this._renderWorldCopies},wo.renderWorldCopies.set=function(t){void 0===t?t=!0:null===t&&(t=!1),this._renderWorldCopies=t;},wo.worldSize.get=function(){return this.tileSize*this.scale},wo.centerOffset.get=function(){return this.centerPoint._sub(this.size._div(2))},wo.size.get=function(){return new t.Point(this.width,this.height)},wo.bearing.get=function(){return -this.angle/Math.PI*180},wo.bearing.set=function(e){var i=-t.wrap(e,-180,180)*Math.PI/180;this.angle!==i&&(this._unmodified=!1,this.angle=i,this._calcMatrices(),this.rotationMatrix=t.create$2(),t.rotate(this.rotationMatrix,this.rotationMatrix,this.angle));},wo.pitch.get=function(){return this._pitch/Math.PI*180},wo.pitch.set=function(e){var i=t.clamp(e,this.minPitch,this.maxPitch)/180*Math.PI;this._pitch!==i&&(this._unmodified=!1,this._pitch=i,this._calcMatrices());},wo.fov.get=function(){return this._fov/Math.PI*180},wo.fov.set=function(t){t=Math.max(.01,Math.min(60,t)),this._fov!==t&&(this._unmodified=!1,this._fov=t/180*Math.PI,this._calcMatrices());},wo.zoom.get=function(){return this._zoom},wo.zoom.set=function(t){var e=Math.min(Math.max(t,this.minZoom),this.maxZoom);this._zoom!==e&&(this._unmodified=!1,this._zoom=e,this.scale=this.zoomScale(e),this.tileZoom=Math.floor(e),this.zoomFraction=e-this.tileZoom,this._constrain(),this._calcMatrices());},wo.center.get=function(){return this._center},wo.center.set=function(t){t.lat===this._center.lat&&t.lng===this._center.lng||(this._unmodified=!1,this._center=t,this._constrain(),this._calcMatrices());},wo.padding.get=function(){return this._edgeInsets.toJSON()},wo.padding.set=function(t){this._edgeInsets.equals(t)||(this._unmodified=!1,this._edgeInsets.interpolate(this._edgeInsets,t,1),this._calcMatrices());},wo.centerPoint.get=function(){return this._edgeInsets.getCenter(this.width,this.height)},bo.prototype.isPaddingEqual=function(t){return this._edgeInsets.equals(t)},bo.prototype.interpolatePadding=function(t,e,i){this._unmodified=!1,this._edgeInsets.interpolate(t,e,i),this._constrain(),this._calcMatrices();},bo.prototype.coveringZoomLevel=function(t){var e=(t.roundZoom?Math.round:Math.floor)(this.zoom+this.scaleZoom(this.tileSize/t.tileSize));return Math.max(0,e)},bo.prototype.getVisibleUnwrappedCoordinates=function(e){var i=[new t.UnwrappedTileID(0,e)];if(this._renderWorldCopies)for(var o=this.pointCoordinate(new t.Point(0,0)),r=this.pointCoordinate(new t.Point(this.width,0)),a=this.pointCoordinate(new t.Point(this.width,this.height)),n=this.pointCoordinate(new t.Point(0,this.height)),s=Math.floor(Math.min(o.x,r.x,a.x,n.x)),l=Math.floor(Math.max(o.x,r.x,a.x,n.x)),c=s-1;c<=l+1;c++)0!==c&&i.push(new t.UnwrappedTileID(c,e));return i},bo.prototype.coveringTiles=function(e){var i=this.coveringZoomLevel(e),o=i;if(void 0!==e.minzoom&&i<e.minzoom)return [];void 0!==e.maxzoom&&i>e.maxzoom&&(i=e.maxzoom);var r=t.MercatorCoordinate.fromLngLat(this.center),a=Math.pow(2,i),n=[a*r.x,a*r.y,0],s=vo.fromInvProjectionMatrix(this.invProjMatrix,this.worldSize,i),l=e.minzoom||0;this.pitch<=60&&this._edgeInsets.top<.1&&(l=i);var c=function(t){return {aabb:new yo([t*a,0,0],[(t+1)*a,a,0]),zoom:0,x:0,y:0,wrap:t,fullyVisible:!1}},u=[],h=[],p=i,d=e.reparseOverscaled?o:i;if(this._renderWorldCopies)for(var _=1;_<=3;_++)u.push(c(-_)),u.push(c(_));for(u.push(c(0));u.length>0;){var f=u.pop(),m=f.x,g=f.y,v=f.fullyVisible;if(!v){var y=f.aabb.intersects(s);if(0===y)continue;v=2===y;}var x=f.aabb.distanceX(n),b=f.aabb.distanceY(n),w=Math.max(Math.abs(x),Math.abs(b));if(f.zoom===p||w>3+(1<<p-f.zoom)-2&&f.zoom>=l)h.push({tileID:new t.OverscaledTileID(f.zoom===p?d:f.zoom,f.wrap,f.zoom,m,g),distanceSq:t.sqrLen([n[0]-.5-m,n[1]-.5-g])});else for(var E=0;E<4;E++){var T=(m<<1)+E%2,I=(g<<1)+(E>>1);u.push({aabb:f.aabb.quadrant(E),zoom:f.zoom+1,x:T,y:I,wrap:f.wrap,fullyVisible:v});}}return h.sort((function(t,e){return t.distanceSq-e.distanceSq})).map((function(t){return t.tileID}))},bo.prototype.resize=function(t,e){this.width=t,this.height=e,this.pixelsToGLUnits=[2/t,-2/e],this._constrain(),this._calcMatrices();},wo.unmodified.get=function(){return this._unmodified},bo.prototype.zoomScale=function(t){return Math.pow(2,t)},bo.prototype.scaleZoom=function(t){return Math.log(t)/Math.LN2},bo.prototype.project=function(e){var i=t.clamp(e.lat,-this.maxValidLatitude,this.maxValidLatitude);return new t.Point(t.mercatorXfromLng(e.lng)*this.worldSize,t.mercatorYfromLat(i)*this.worldSize)},bo.prototype.unproject=function(e){return new t.MercatorCoordinate(e.x/this.worldSize,e.y/this.worldSize).toLngLat()},wo.point.get=function(){return this.project(this.center)},bo.prototype.setLocationAtPoint=function(e,i){var o=this.pointCoordinate(i),r=this.pointCoordinate(this.centerPoint),a=this.locationCoordinate(e),n=new t.MercatorCoordinate(a.x-(o.x-r.x),a.y-(o.y-r.y));this.center=this.coordinateLocation(n),this._renderWorldCopies&&(this.center=this.center.wrap());},bo.prototype.locationPoint=function(t){return this.coordinatePoint(this.locationCoordinate(t))},bo.prototype.pointLocation=function(t){return this.coordinateLocation(this.pointCoordinate(t))},bo.prototype.locationCoordinate=function(e){return t.MercatorCoordinate.fromLngLat(e)},bo.prototype.coordinateLocation=function(t){return t.toLngLat()},bo.prototype.pointCoordinate=function(e){var i=[e.x,e.y,0,1],o=[e.x,e.y,1,1];t.transformMat4(i,i,this.pixelMatrixInverse),t.transformMat4(o,o,this.pixelMatrixInverse);var r=i[3],a=o[3],n=i[1]/r,s=o[1]/a,l=i[2]/r,c=o[2]/a,u=l===c?0:(0-l)/(c-l);return new t.MercatorCoordinate(t.number(i[0]/r,o[0]/a,u)/this.worldSize,t.number(n,s,u)/this.worldSize)},bo.prototype.coordinatePoint=function(e){var i=[e.x*this.worldSize,e.y*this.worldSize,0,1];return t.transformMat4(i,i,this.pixelMatrix),new t.Point(i[0]/i[3],i[1]/i[3])},bo.prototype.getBounds=function(){return (new t.LngLatBounds).extend(this.pointLocation(new t.Point(0,0))).extend(this.pointLocation(new t.Point(this.width,0))).extend(this.pointLocation(new t.Point(this.width,this.height))).extend(this.pointLocation(new t.Point(0,this.height)))},bo.prototype.getMaxBounds=function(){return this.latRange&&2===this.latRange.length&&this.lngRange&&2===this.lngRange.length?new t.LngLatBounds([this.lngRange[0],this.latRange[0]],[this.lngRange[1],this.latRange[1]]):null},bo.prototype.setMaxBounds=function(t){t?(this.lngRange=[t.getWest(),t.getEast()],this.latRange=[t.getSouth(),t.getNorth()],this._constrain()):(this.lngRange=null,this.latRange=[-this.maxValidLatitude,this.maxValidLatitude]);},bo.prototype.calculatePosMatrix=function(e,i){void 0===i&&(i=!1);var o=e.key,r=i?this._alignedPosMatrixCache:this._posMatrixCache;if(r[o])return r[o];var a=e.canonical,n=this.worldSize/this.zoomScale(a.z),s=a.x+Math.pow(2,a.z)*e.wrap,l=t.identity(new Float64Array(16));return t.translate(l,l,[s*n,a.y*n,0]),t.scale(l,l,[n/t.EXTENT,n/t.EXTENT,1]),t.multiply(l,i?this.alignedProjMatrix:this.projMatrix,l),r[o]=new Float32Array(l),r[o]},bo.prototype.customLayerMatrix=function(){return this.mercatorMatrix.slice()},bo.prototype._constrain=function(){if(this.center&&this.width&&this.height&&!this._constraining){this._constraining=!0;var e,i,o,r,a=-90,n=90,s=-180,l=180,c=this.size,u=this._unmodified;if(this.latRange){var h=this.latRange;a=t.mercatorYfromLat(h[1])*this.worldSize,e=(n=t.mercatorYfromLat(h[0])*this.worldSize)-a<c.y?c.y/(n-a):0;}if(this.lngRange){var p=this.lngRange;s=t.mercatorXfromLng(p[0])*this.worldSize,i=(l=t.mercatorXfromLng(p[1])*this.worldSize)-s<c.x?c.x/(l-s):0;}var d=this.point,_=Math.max(i||0,e||0);if(_)return this.center=this.unproject(new t.Point(i?(l+s)/2:d.x,e?(n+a)/2:d.y)),this.zoom+=this.scaleZoom(_),this._unmodified=u,void(this._constraining=!1);if(this.latRange){var f=d.y,m=c.y/2;f-m<a&&(r=a+m),f+m>n&&(r=n-m);}if(this.lngRange){var g=d.x,v=c.x/2;g-v<s&&(o=s+v),g+v>l&&(o=l-v);}void 0===o&&void 0===r||(this.center=this.unproject(new t.Point(void 0!==o?o:d.x,void 0!==r?r:d.y))),this._unmodified=u,this._constraining=!1;}},bo.prototype._calcMatrices=function(){if(this.height){var e=this.centerOffset;this.cameraToCenterDistance=.5/Math.tan(this._fov/2)*this.height;var i=Math.PI/2+this._pitch,o=this._fov*(.5+e.y/this.height),r=Math.sin(o)*this.cameraToCenterDistance/Math.sin(t.clamp(Math.PI-i-o,.01,Math.PI-.01)),a=this.point,n=a.x,s=a.y,l=1.01*(Math.cos(Math.PI/2-this._pitch)*r+this.cameraToCenterDistance),c=this.height/50,u=new Float64Array(16);t.perspective(u,this._fov,this.width/this.height,c,l),u[8]=2*-e.x/this.width,u[9]=2*e.y/this.height,t.scale(u,u,[1,-1,1]),t.translate(u,u,[0,0,-this.cameraToCenterDistance]),t.rotateX(u,u,this._pitch),t.rotateZ(u,u,this.angle),t.translate(u,u,[-n,-s,0]),this.mercatorMatrix=t.scale([],u,[this.worldSize,this.worldSize,this.worldSize]),t.scale(u,u,[1,1,t.mercatorZfromAltitude(1,this.center.lat)*this.worldSize,1]),this.projMatrix=u,this.invProjMatrix=t.invert([],this.projMatrix);var h=this.width%2/2,p=this.height%2/2,d=Math.cos(this.angle),_=Math.sin(this.angle),f=n-Math.round(n)+d*h+_*p,m=s-Math.round(s)+d*p+_*h,g=new Float64Array(u);if(t.translate(g,g,[f>.5?f-1:f,m>.5?m-1:m,0]),this.alignedProjMatrix=g,u=t.create(),t.scale(u,u,[this.width/2,-this.height/2,1]),t.translate(u,u,[1,-1,0]),this.labelPlaneMatrix=u,u=t.create(),t.scale(u,u,[1,-1,1]),t.translate(u,u,[-1,-1,0]),t.scale(u,u,[2/this.width,2/this.height,1]),this.glCoordMatrix=u,this.pixelMatrix=t.multiply(new Float64Array(16),this.labelPlaneMatrix,this.projMatrix),!(u=t.invert(new Float64Array(16),this.pixelMatrix)))throw new Error("failed to invert matrix");this.pixelMatrixInverse=u,this._posMatrixCache={},this._alignedPosMatrixCache={};}},bo.prototype.maxPitchScaleFactor=function(){if(!this.pixelMatrixInverse)return 1;var e=this.pointCoordinate(new t.Point(0,0)),i=[e.x*this.worldSize,e.y*this.worldSize,0,1];return t.transformMat4(i,i,this.pixelMatrix)[3]/this.cameraToCenterDistance},bo.prototype.getCameraPoint=function(){var e=Math.tan(this._pitch)*(this.cameraToCenterDistance||1);return this.centerPoint.add(new t.Point(0,e))},bo.prototype.getCameraQueryGeometry=function(e){var i=this.getCameraPoint();if(1===e.length)return [e[0],i];for(var o=i.x,r=i.y,a=i.x,n=i.y,s=0,l=e;s<l.length;s+=1){var c=l[s];o=Math.min(o,c.x),r=Math.min(r,c.y),a=Math.max(a,c.x),n=Math.max(n,c.y);}return [new t.Point(o,r),new t.Point(a,r),new t.Point(a,n),new t.Point(o,n),new t.Point(o,r)]},Object.defineProperties(bo.prototype,wo);var Eo=function(e){var i,o,r,a;this._hashName=e&&encodeURIComponent(e),t.bindAll(["_getCurrentHash","_onHashChange","_updateHash"],this),this._updateHash=(i=this._updateHashUnthrottled.bind(this),o=!1,r=null,a=function(){r=null,o&&(i(),r=setTimeout(a,300),o=!1);},function(){return o=!0,r||a(),r});};Eo.prototype.addTo=function(e){return this._map=e,t.window.addEventListener("hashchange",this._onHashChange,!1),this._map.on("moveend",this._updateHash),this},Eo.prototype.remove=function(){return t.window.removeEventListener("hashchange",this._onHashChange,!1),this._map.off("moveend",this._updateHash),clearTimeout(this._updateHash()),delete this._map,this},Eo.prototype.getHashString=function(e){var i=this._map.getCenter(),o=Math.round(100*this._map.getZoom())/100,r=Math.ceil((o*Math.LN2+Math.log(512/360/.5))/Math.LN10),a=Math.pow(10,r),n=Math.round(i.lng*a)/a,s=Math.round(i.lat*a)/a,l=this._map.getBearing(),c=this._map.getPitch(),u="";if(u+=e?"/"+n+"/"+s+"/"+o:o+"/"+s+"/"+n,(l||c)&&(u+="/"+Math.round(10*l)/10),c&&(u+="/"+Math.round(c)),this._hashName){var h=this._hashName,p=!1,d=t.window.location.hash.slice(1).split("&").map((function(t){var e=t.split("=")[0];return e===h?(p=!0,e+"="+u):t})).filter((function(t){return t}));return p||d.push(h+"="+u),"#"+d.join("&")}return "#"+u},Eo.prototype._getCurrentHash=function(){var e,i=this,o=t.window.location.hash.replace("#","");return this._hashName?(o.split("&").map((function(t){return t.split("=")})).forEach((function(t){t[0]===i._hashName&&(e=t);})),(e&&e[1]||"").split("/")):o.split("/")},Eo.prototype._onHashChange=function(){var t=this._getCurrentHash();if(t.length>=3&&!t.some((function(t){return isNaN(t)}))){var e=this._map.dragRotate.isEnabled()&&this._map.touchZoomRotate.isEnabled()?+(t[3]||0):this._map.getBearing();return this._map.jumpTo({center:[+t[2],+t[1]],zoom:+t[0],bearing:e,pitch:+(t[4]||0)}),!0}return !1},Eo.prototype._updateHashUnthrottled=function(){var e=this.getHashString();try{t.window.history.replaceState(t.window.history.state,"",e);}catch(t){}};var To=function(e){function o(o,r,a,n){void 0===n&&(n={});var s=i.mousePos(r.getCanvasContainer(),a),l=r.unproject(s);e.call(this,o,t.extend({point:s,lngLat:l,originalEvent:a},n)),this._defaultPrevented=!1,this.target=r;}e&&(o.__proto__=e),(o.prototype=Object.create(e&&e.prototype)).constructor=o;var r={defaultPrevented:{configurable:!0}};return o.prototype.preventDefault=function(){this._defaultPrevented=!0;},r.defaultPrevented.get=function(){return this._defaultPrevented},Object.defineProperties(o.prototype,r),o}(t.Event),Io=function(e){function o(o,r,a){var n=i.touchPos(r.getCanvasContainer(),a),s=n.map((function(t){return r.unproject(t)})),l=n.reduce((function(t,e,i,o){return t.add(e.div(o.length))}),new t.Point(0,0)),c=r.unproject(l);e.call(this,o,{points:n,point:l,lngLats:s,lngLat:c,originalEvent:a}),this._defaultPrevented=!1;}e&&(o.__proto__=e),(o.prototype=Object.create(e&&e.prototype)).constructor=o;var r={defaultPrevented:{configurable:!0}};return o.prototype.preventDefault=function(){this._defaultPrevented=!0;},r.defaultPrevented.get=function(){return this._defaultPrevented},Object.defineProperties(o.prototype,r),o}(t.Event),Co=function(t){function e(e,i,o){t.call(this,e,{originalEvent:o}),this._defaultPrevented=!1;}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var i={defaultPrevented:{configurable:!0}};return e.prototype.preventDefault=function(){this._defaultPrevented=!0;},i.defaultPrevented.get=function(){return this._defaultPrevented},Object.defineProperties(e.prototype,i),e}(t.Event),So=function(e){this._map=e,this._el=e.getCanvasContainer(),this._delta=0,this._defaultZoomRate=.01,this._wheelZoomRate=1/450,t.bindAll(["_onWheel","_onTimeout","_onScrollFrame","_onScrollFinished"],this);};So.prototype.setZoomRate=function(t){this._defaultZoomRate=t;},So.prototype.setWheelZoomRate=function(t){this._wheelZoomRate=t;},So.prototype.isEnabled=function(){return !!this._enabled},So.prototype.isActive=function(){return !!this._active},So.prototype.isZooming=function(){return !!this._zooming},So.prototype.enable=function(t){this.isEnabled()||(this._enabled=!0,this._aroundCenter=t&&"center"===t.around);},So.prototype.disable=function(){this.isEnabled()&&(this._enabled=!1);},So.prototype.onWheel=function(e){if(this.isEnabled()){var i=e.deltaMode===t.window.WheelEvent.DOM_DELTA_LINE?40*e.deltaY:e.deltaY,o=t.browser.now(),r=o-(this._lastWheelEventTime||0);this._lastWheelEventTime=o,0!==i&&i%4.000244140625==0?this._type="wheel":0!==i&&Math.abs(i)<4?this._type="trackpad":r>400?(this._type=null,this._lastValue=i,this._timeout=setTimeout(this._onTimeout,40,e)):this._type||(this._type=Math.abs(r*i)<200?"trackpad":"wheel",this._timeout&&(clearTimeout(this._timeout),this._timeout=null,i+=this._lastValue)),e.shiftKey&&i&&(i/=4),this._type&&(this._lastWheelEvent=e,this._delta-=i,this.isActive()||this._start(e)),e.preventDefault();}},So.prototype._onTimeout=function(t){this._type="wheel",this._delta-=this._lastValue,this.isActive()||this._start(t);},So.prototype._start=function(e){if(this._delta){this._frameId&&(this._map._cancelRenderFrame(this._frameId),this._frameId=null),this._active=!0,this.isZooming()||(this._zooming=!0,this._map.fire(new t.Event("movestart",{originalEvent:e})),this._map.fire(new t.Event("zoomstart",{originalEvent:e}))),this._finishTimeout&&clearTimeout(this._finishTimeout);var o=i.mousePos(this._el,e);this._around=t.LngLat.convert(this._aroundCenter?this._map.getCenter():this._map.unproject(o)),this._aroundPoint=this._map.transform.locationPoint(this._around),this._frameId||(this._frameId=this._map._requestRenderFrame(this._onScrollFrame));}},So.prototype._onScrollFrame=function(){var e=this;if(this._frameId=null,this.isActive()){var i=this._map.transform;if(0!==this._delta){var o="wheel"===this._type&&Math.abs(this._delta)>4.000244140625?this._wheelZoomRate:this._defaultZoomRate,r=2/(1+Math.exp(-Math.abs(this._delta*o)));this._delta<0&&0!==r&&(r=1/r);var a="number"==typeof this._targetZoom?i.zoomScale(this._targetZoom):i.scale;this._targetZoom=Math.min(i.maxZoom,Math.max(i.minZoom,i.scaleZoom(a*r))),"wheel"===this._type&&(this._startZoom=i.zoom,this._easing=this._smoothOutEasing(200)),this._delta=0;}var n="number"==typeof this._targetZoom?this._targetZoom:i.zoom,s=this._startZoom,l=this._easing,c=!1;if("wheel"===this._type&&s&&l){var u=Math.min((t.browser.now()-this._lastWheelEventTime)/200,1),h=l(u);i.zoom=t.number(s,n,h),u<1?this._frameId||(this._frameId=this._map._requestRenderFrame(this._onScrollFrame)):c=!0;}else i.zoom=n,c=!0;i.setLocationAtPoint(this._around,this._aroundPoint),this._map.fire(new t.Event("move",{originalEvent:this._lastWheelEvent})),this._map.fire(new t.Event("zoom",{originalEvent:this._lastWheelEvent})),c&&(this._active=!1,this._finishTimeout=setTimeout((function(){e._zooming=!1,e._map.fire(new t.Event("zoomend",{originalEvent:e._lastWheelEvent})),e._map.fire(new t.Event("moveend",{originalEvent:e._lastWheelEvent})),delete e._targetZoom;}),200));}},So.prototype._smoothOutEasing=function(e){var i=t.ease;if(this._prevEase){var o=this._prevEase,r=(t.browser.now()-o.start)/o.duration,a=o.easing(r+.01)-o.easing(r),n=.27/Math.sqrt(a*a+1e-4)*.01,s=Math.sqrt(.0729-n*n);i=t.bezier(n,s,.25,1);}return this._prevEase={start:t.browser.now(),duration:e,easing:i},i};var Po=function(e,i){this._map=e,this._el=e.getCanvasContainer(),this._container=e.getContainer(),this._clickTolerance=i.clickTolerance||1,t.bindAll(["_onMouseMove","_onMouseUp","_onKeyDown"],this);};Po.prototype.isEnabled=function(){return !!this._enabled},Po.prototype.isActive=function(){return !!this._active},Po.prototype.enable=function(){this.isEnabled()||(this._enabled=!0);},Po.prototype.disable=function(){this.isEnabled()&&(this._enabled=!1);},Po.prototype.onMouseDown=function(e){this.isEnabled()&&e.shiftKey&&0===e.button&&(t.window.document.addEventListener("mousemove",this._onMouseMove,!1),t.window.document.addEventListener("keydown",this._onKeyDown,!1),t.window.document.addEventListener("mouseup",this._onMouseUp,!1),i.disableDrag(),this._startPos=this._lastPos=i.mousePos(this._el,e),this._active=!0);},Po.prototype._onMouseMove=function(t){var e=i.mousePos(this._el,t);if(!(this._lastPos.equals(e)||!this._box&&e.dist(this._startPos)<this._clickTolerance)){var o=this._startPos;this._lastPos=e,this._box||(this._box=i.create("div","mapboxgl-boxzoom",this._container),this._container.classList.add("mapboxgl-crosshair"),this._fireEvent("boxzoomstart",t));var r=Math.min(o.x,e.x),a=Math.max(o.x,e.x),n=Math.min(o.y,e.y),s=Math.max(o.y,e.y);i.setTransform(this._box,"translate("+r+"px,"+n+"px)"),this._box.style.width=a-r+"px",this._box.style.height=s-n+"px";}},Po.prototype._onMouseUp=function(e){if(0===e.button){var o=this._startPos,r=i.mousePos(this._el,e);this._finish(),i.suppressClick(),o.x===r.x&&o.y===r.y?this._fireEvent("boxzoomcancel",e):this._map.fitScreenCoordinates(o,r,this._map.getBearing(),{linear:!0}).fire(new t.Event("boxzoomend",{originalEvent:e}));}},Po.prototype._onKeyDown=function(t){27===t.keyCode&&(this._finish(),this._fireEvent("boxzoomcancel",t));},Po.prototype._finish=function(){this._active=!1,t.window.document.removeEventListener("mousemove",this._onMouseMove,!1),t.window.document.removeEventListener("keydown",this._onKeyDown,!1),t.window.document.removeEventListener("mouseup",this._onMouseUp,!1),this._container.classList.remove("mapboxgl-crosshair"),this._box&&(i.remove(this._box),this._box=null),i.enableDrag(),delete this._startPos,delete this._lastPos;},Po.prototype._fireEvent=function(e,i){return this._map.fire(new t.Event(e,{originalEvent:i}))};var zo=t.bezier(0,0,.25,1),Lo=function(e,i){this._map=e,this._el=i.element||e.getCanvasContainer(),this._state="disabled",this._button=i.button||"right",this._bearingSnap=i.bearingSnap||0,this._pitchWithRotate=!1!==i.pitchWithRotate,this._clickTolerance=i.clickTolerance||1,t.bindAll(["onMouseDown","_onMouseMove","_onMouseUp","_onBlur","_onDragFrame"],this);};Lo.prototype.isEnabled=function(){return "disabled"!==this._state},Lo.prototype.isActive=function(){return "active"===this._state},Lo.prototype.enable=function(){this.isEnabled()||(this._state="enabled");},Lo.prototype.disable=function(){if(this.isEnabled())switch(this._state){case"active":this._state="disabled",this._unbind(),this._deactivate(),this._fireEvent("rotateend"),this._pitchWithRotate&&this._fireEvent("pitchend"),this._fireEvent("moveend");break;case"pending":this._state="disabled",this._unbind();break;default:this._state="disabled";}},Lo.prototype.onMouseDown=function(e){if("enabled"===this._state){var o="touchstart"===e.type;if(o)this._startTime=Date.now();else if("right"===this._button){if(this._eventButton=i.mouseButton(e),e.altKey||e.metaKey)return;if(this._eventButton!==(e.ctrlKey?0:2))return}else{if(e.ctrlKey||0!==i.mouseButton(e))return;this._eventButton=0;}i.disableDrag(),o?(t.window.document.addEventListener("touchmove",this._onMouseMove,{capture:!0}),t.window.document.addEventListener("touchend",this._onMouseUp)):(t.window.document.addEventListener("mousemove",this._onMouseMove,{capture:!0}),t.window.document.addEventListener("mouseup",this._onMouseUp)),t.window.addEventListener("blur",this._onBlur),this._state="pending",this._inertia=[[t.browser.now(),this._map.getBearing()]],this._startPos=this._prevPos=this._lastPos=i.mousePos(this._el,e),this._center=this._map.transform.centerPoint,e.preventDefault();}},Lo.prototype._onMouseMove=function(t){var e=i.mousePos(this._el,t);this._lastPos.equals(e)||"pending"===this._state&&e.dist(this._startPos)<this._clickTolerance||(this._lastMoveEvent=t,this._lastPos=e,"pending"===this._state&&(this._state="active",this._fireEvent("rotatestart",t),this._fireEvent("movestart",t),this._pitchWithRotate&&this._fireEvent("pitchstart",t)),this._frameId||(this._frameId=this._map._requestRenderFrame(this._onDragFrame)));},Lo.prototype._onDragFrame=function(){this._frameId=null;var e=this._lastMoveEvent;if(e){var i=this._map.transform,o=this._prevPos,r=this._lastPos,a=i.bearing-.8*(o.x-r.x),n=i.pitch- -.5*(o.y-r.y),s=this._inertia,l=s[s.length-1];this._drainInertiaBuffer(),s.push([t.browser.now(),this._map._normalizeBearing(a,l[1])]);var c=i.bearing;if(i.bearing=a,this._pitchWithRotate){var u=i.pitch;i.pitch=n,i.pitch!==u&&this._fireEvent("pitch",e);}i.bearing!==c&&this._fireEvent("rotate",e),this._fireEvent("move",e),delete this._lastMoveEvent,this._prevPos=this._lastPos;}},Lo.prototype._onMouseUp=function(t){var e="touchend"===t.type;if(e&&this._startPos===this._lastPos&&Date.now()-this._startTime<300&&this._el.click(),e||i.mouseButton(t)===this._eventButton)switch(this._state){case"active":this._state="enabled",i.suppressClick(),this._unbind(),this._deactivate(),this._inertialRotate(t);break;case"pending":this._state="enabled",this._unbind();}},Lo.prototype._onBlur=function(t){switch(this._state){case"active":this._state="enabled",this._unbind(),this._deactivate(),this._fireEvent("rotateend",t),this._pitchWithRotate&&this._fireEvent("pitchend",t),this._fireEvent("moveend",t);break;case"pending":this._state="enabled",this._unbind();}},Lo.prototype._unbind=function(){t.window.document.removeEventListener("mousemove",this._onMouseMove,{capture:!0}),t.window.document.removeEventListener("mouseup",this._onMouseUp),t.window.document.removeEventListener("touchmove",this._onMouseMove,{capture:!0}),t.window.document.removeEventListener("touchend",this._onMouseUp),t.window.removeEventListener("blur",this._onBlur),i.enableDrag();},Lo.prototype._deactivate=function(){this._frameId&&(this._map._cancelRenderFrame(this._frameId),this._frameId=null),delete this._lastMoveEvent,delete this._startPos,delete this._prevPos,delete this._lastPos;},Lo.prototype._inertialRotate=function(t){var e=this;this._fireEvent("rotateend",t),this._drainInertiaBuffer();var i=this._map,o=i.getBearing(),r=this._inertia,a=function(){Math.abs(o)<e._bearingSnap?i.resetNorth({noMoveStart:!0},{originalEvent:t}):e._fireEvent("moveend",t),e._pitchWithRotate&&e._fireEvent("pitchend",t);};if(r.length<2)a();else{var n=r[0],s=r[r.length-1],l=i._normalizeBearing(o,r[r.length-2][1]),c=s[1]-n[1],u=c<0?-1:1,h=(s[0]-n[0])/1e3;if(0!==c&&0!==h){var p=Math.abs(c*(.25/h));p>180&&(p=180);var d=p/180;l+=u*p*(d/2),Math.abs(i._normalizeBearing(l,0))<this._bearingSnap&&(l=i._normalizeBearing(0,l)),i.rotateTo(l,{duration:1e3*d,easing:zo,noMoveStart:!0},{originalEvent:t});}else a();}},Lo.prototype._fireEvent=function(e,i){return this._map.fire(new t.Event(e,i?{originalEvent:i}:{}))},Lo.prototype._drainInertiaBuffer=function(){for(var e=this._inertia,i=t.browser.now();e.length>0&&i-e[0][0]>160;)e.shift();};var Mo={linearity:.3,easing:t.bezier(0,0,.3,1),maxSpeed:1400,deceleration:2500},Do=function(e,i){this._map=e,this._el=e.getCanvasContainer(),this._state="disabled",this._clickTolerance=i.clickTolerance||1,this._inertiaOptions=Mo,t.bindAll(["_onMove","_onMouseUp","_onTouchEnd","_onBlur","_onDragFrame"],this);};Do.prototype.isEnabled=function(){return "disabled"!==this._state},Do.prototype.isActive=function(){return "active"===this._state},Do.prototype.enable=function(e){this.isEnabled()||(this._el.classList.add("mapboxgl-touch-drag-pan"),this._state="enabled",this._inertiaOptions=t.extend(Mo,e));},Do.prototype.disable=function(){if(this.isEnabled())switch(this._el.classList.remove("mapboxgl-touch-drag-pan"),this._state){case"active":this._state="disabled",this._unbind(),this._deactivate(),this._fireEvent("dragend"),this._fireEvent("moveend");break;case"pending":this._state="disabled",this._unbind();break;default:this._state="disabled";}},Do.prototype.onMouseDown=function(e){"enabled"===this._state&&(e.ctrlKey||0!==i.mouseButton(e)||(i.addEventListener(t.window.document,"mousemove",this._onMove,{capture:!0}),i.addEventListener(t.window.document,"mouseup",this._onMouseUp),this._start(e)));},Do.prototype.onTouchStart=function(e){this.isEnabled()&&(e.touches&&e.touches.length>1&&("pending"===this._state||"active"===this._state)||(i.addEventListener(t.window.document,"touchmove",this._onMove,{capture:!0,passive:!1}),i.addEventListener(t.window.document,"touchend",this._onTouchEnd),this._start(e)));},Do.prototype._start=function(e){t.window.addEventListener("blur",this._onBlur),this._state="pending",this._startPos=this._mouseDownPos=this._prevPos=this._lastPos=i.mousePos(this._el,e),this._startTouch=this._lastTouch=t.window.TouchEvent&&e instanceof t.window.TouchEvent?i.touchPos(this._el,e):null,this._inertia=[[t.browser.now(),this._startPos]];},Do.prototype._touchesMatch=function(t,e){return !(!t||!e||t.length!==e.length)&&t.every((function(t,i){return e[i]===t}))},Do.prototype._onMove=function(e){e.preventDefault();var o=t.window.TouchEvent&&e instanceof t.window.TouchEvent?i.touchPos(this._el,e):null,r=i.mousePos(this._el,e);(o?this._touchesMatch(this._lastTouch,o):this._lastPos.equals(r))||"pending"===this._state&&r.dist(this._mouseDownPos)<this._clickTolerance||(this._lastMoveEvent=e,this._lastPos=r,this._lastTouch=o,this._drainInertiaBuffer(),this._inertia.push([t.browser.now(),this._lastPos]),"pending"===this._state&&(this._state="active",this._shouldStart=!0),this._frameId||(this._frameId=this._map._requestRenderFrame(this._onDragFrame)));},Do.prototype._onDragFrame=function(){this._frameId=null;var t=this._lastMoveEvent;if(t)if(this._map.touchZoomRotate.isActive())this._abort(t);else if(this._shouldStart&&(this._fireEvent("dragstart",t),this._fireEvent("movestart",t),this._shouldStart=!1),this.isActive()){var e=this._map.transform;e.setLocationAtPoint(e.pointLocation(this._prevPos),this._lastPos),this._fireEvent("drag",t),this._fireEvent("move",t),this._prevPos=this._lastPos,delete this._lastMoveEvent;}},Do.prototype._onMouseUp=function(t){if(0===i.mouseButton(t))switch(this._state){case"active":this._state="enabled",i.suppressClick(),this._unbind(),this._deactivate(),this._inertialPan(t);break;case"pending":this._state="enabled",this._unbind();}},Do.prototype._onTouchEnd=function(t){if(t.touches&&0!==t.touches.length)switch(this._state){case"pending":case"active":break;case"enabled":this.onTouchStart(t);}else switch(this._state){case"active":this._state="enabled",this._unbind(),this._deactivate(),this._inertialPan(t);break;case"pending":this._state="enabled",this._unbind();break;case"enabled":this._unbind();}},Do.prototype._abort=function(e){switch(this._state){case"active":this._state="enabled",this._shouldStart||(this._fireEvent("dragend",e),this._fireEvent("moveend",e)),this._unbind(),this._deactivate(),t.window.TouchEvent&&e instanceof t.window.TouchEvent&&e.touches.length>1&&i.addEventListener(t.window.document,"touchend",this._onTouchEnd);break;case"pending":this._state="enabled",this._unbind();break;case"enabled":this._unbind();}},Do.prototype._onBlur=function(t){this._abort(t);},Do.prototype._unbind=function(){i.removeEventListener(t.window.document,"touchmove",this._onMove,{capture:!0,passive:!1}),i.removeEventListener(t.window.document,"touchend",this._onTouchEnd),i.removeEventListener(t.window.document,"mousemove",this._onMove,{capture:!0}),i.removeEventListener(t.window.document,"mouseup",this._onMouseUp),i.removeEventListener(t.window,"blur",this._onBlur);},Do.prototype._deactivate=function(){this._frameId&&(this._map._cancelRenderFrame(this._frameId),this._frameId=null),delete this._lastMoveEvent,delete this._startPos,delete this._prevPos,delete this._mouseDownPos,delete this._lastPos,delete this._startTouch,delete this._lastTouch,delete this._shouldStart;},Do.prototype._inertialPan=function(t){this._fireEvent("dragend",t),this._drainInertiaBuffer();var e=this._inertia;if(e.length<2)this._fireEvent("moveend",t);else{var i=e[e.length-1],o=e[0],r=i[1].sub(o[1]),a=(i[0]-o[0])/1e3;if(0===a||i[1].equals(o[1]))this._fireEvent("moveend",t);else{var n=this._inertiaOptions,s=n.linearity,l=n.easing,c=n.maxSpeed,u=n.deceleration,h=r.mult(s/a),p=h.mag();p>c&&(p=c,h._unit()._mult(p));var d=p/(u*s),_=h.mult(-d/2);this._map.panBy(_,{duration:1e3*d,easing:l,noMoveStart:!0},{originalEvent:t});}}},Do.prototype._fireEvent=function(e,i){return this._map.fire(new t.Event(e,i?{originalEvent:i}:{}))},Do.prototype._drainInertiaBuffer=function(){for(var e=this._inertia,i=t.browser.now();e.length>0&&i-e[0][0]>160;)e.shift();};var Ao=function(e){this._map=e,this._el=e.getCanvasContainer(),t.bindAll(["_onKeyDown"],this);};function Ro(t){return t*(2-t)}Ao.prototype.isEnabled=function(){return !!this._enabled},Ao.prototype.enable=function(){this.isEnabled()||(this._el.addEventListener("keydown",this._onKeyDown,!1),this._enabled=!0);},Ao.prototype.disable=function(){this.isEnabled()&&(this._el.removeEventListener("keydown",this._onKeyDown),this._enabled=!1);},Ao.prototype._onKeyDown=function(t){if(!(t.altKey||t.ctrlKey||t.metaKey)){var e=0,i=0,o=0,r=0,a=0;switch(t.keyCode){case 61:case 107:case 171:case 187:e=1;break;case 189:case 109:case 173:e=-1;break;case 37:t.shiftKey?i=-1:(t.preventDefault(),r=-1);break;case 39:t.shiftKey?i=1:(t.preventDefault(),r=1);break;case 38:t.shiftKey?o=1:(t.preventDefault(),a=-1);break;case 40:t.shiftKey?o=-1:(a=1,t.preventDefault());break;default:return}var n=this._map,s=n.getZoom(),l={duration:300,delayEndEvents:500,easing:Ro,zoom:e?Math.round(s)+e*(t.shiftKey?2:1):s,bearing:n.getBearing()+15*i,pitch:n.getPitch()+10*o,offset:[100*-r,100*-a],center:n.getCenter()};n.easeTo(l,{originalEvent:t});}};var ko=function(e){this._map=e,t.bindAll(["_onDblClick","_onZoomEnd"],this);};ko.prototype.isEnabled=function(){return !!this._enabled},ko.prototype.isActive=function(){return !!this._active},ko.prototype.enable=function(){this.isEnabled()||(this._enabled=!0);},ko.prototype.disable=function(){this.isEnabled()&&(this._enabled=!1);},ko.prototype.onTouchStart=function(t){var e=this;if(this.isEnabled()&&!(t.points.length>1))if(this._tapped){var i=this._tappedPoint;if(i&&i.dist(t.points[0])<=30){t.originalEvent.preventDefault();var o=function(){e._tapped&&e._zoom(t),e._map.off("touchcancel",r),e._resetTapped();},r=function(){e._map.off("touchend",o),e._resetTapped();};this._map.once("touchend",o),this._map.once("touchcancel",r);}else this._resetTapped();}else this._tappedPoint=t.points[0],this._tapped=setTimeout((function(){e._tapped=null,e._tappedPoint=null;}),300);},ko.prototype._resetTapped=function(){clearTimeout(this._tapped),this._tapped=null,this._tappedPoint=null;},ko.prototype.onDblClick=function(t){this.isEnabled()&&(t.originalEvent.preventDefault(),this._zoom(t));},ko.prototype._zoom=function(t){this._active=!0,this._map.on("zoomend",this._onZoomEnd),this._map.zoomTo(this._map.getZoom()+(t.originalEvent.shiftKey?-1:1),{around:t.lngLat},t);},ko.prototype._onZoomEnd=function(){this._active=!1,this._map.off("zoomend",this._onZoomEnd);};var Bo=t.bezier(0,0,.15,1),Oo=function(e){this._map=e,this._el=e.getCanvasContainer(),t.bindAll(["_onMove","_onEnd","_onTouchFrame"],this);};Oo.prototype.isEnabled=function(){return !!this._enabled},Oo.prototype.enable=function(t){this.isEnabled()||(this._el.classList.add("mapboxgl-touch-zoom-rotate"),this._enabled=!0,this._aroundCenter=!!t&&"center"===t.around);},Oo.prototype.disable=function(){this.isEnabled()&&(this._el.classList.remove("mapboxgl-touch-zoom-rotate"),this._enabled=!1);},Oo.prototype.disableRotation=function(){this._rotationDisabled=!0;},Oo.prototype.enableRotation=function(){this._rotationDisabled=!1;},Oo.prototype.isActive=function(){return this.isEnabled()&&!!this._gestureIntent},Oo.prototype.onStart=function(e){if(this.isEnabled()&&2===e.touches.length){var o=i.mousePos(this._el,e.touches[0]),r=i.mousePos(this._el,e.touches[1]),a=o.add(r).div(2);this._startVec=o.sub(r),this._startAround=this._map.transform.pointLocation(a),this._gestureIntent=void 0,this._inertia=[],i.addEventListener(t.window.document,"touchmove",this._onMove,{passive:!1}),i.addEventListener(t.window.document,"touchend",this._onEnd);}},Oo.prototype._getTouchEventData=function(t){var e=i.mousePos(this._el,t.touches[0]),o=i.mousePos(this._el,t.touches[1]),r=e.sub(o);return {vec:r,center:e.add(o).div(2),scale:r.mag()/this._startVec.mag(),bearing:this._rotationDisabled?0:180*r.angleWith(this._startVec)/Math.PI}},Oo.prototype._onMove=function(e){if(2===e.touches.length){var i=this._getTouchEventData(e),o=i.vec,r=i.scale,a=i.bearing;if(!this._gestureIntent){var n=this._rotationDisabled&&1!==r||Math.abs(1-r)>.15;Math.abs(a)>10?this._gestureIntent="rotate":n&&(this._gestureIntent="zoom"),this._gestureIntent&&(this._map.fire(new t.Event(this._gestureIntent+"start",{originalEvent:e})),this._map.fire(new t.Event("movestart",{originalEvent:e})),this._startVec=o);}this._lastTouchEvent=e,this._frameId||(this._frameId=this._map._requestRenderFrame(this._onTouchFrame)),e.preventDefault();}},Oo.prototype._onTouchFrame=function(){this._frameId=null;var e=this._gestureIntent;if(e){var i=this._map.transform;this._startScale||(this._startScale=i.scale,this._startBearing=i.bearing);var o=this._getTouchEventData(this._lastTouchEvent),r=o.center,a=o.bearing,n=o.scale,s=i.pointLocation(r),l=i.locationPoint(s);"rotate"===e&&(i.bearing=this._startBearing+a),i.zoom=i.scaleZoom(this._startScale*n),i.setLocationAtPoint(this._startAround,l),this._map.fire(new t.Event(e,{originalEvent:this._lastTouchEvent})),this._map.fire(new t.Event("move",{originalEvent:this._lastTouchEvent})),this._drainInertiaBuffer(),this._inertia.push([t.browser.now(),n,r]);}},Oo.prototype._onEnd=function(e){i.removeEventListener(t.window.document,"touchmove",this._onMove,{passive:!1}),i.removeEventListener(t.window.document,"touchend",this._onEnd);var o=this._gestureIntent,r=this._startScale;if(this._frameId&&(this._map._cancelRenderFrame(this._frameId),this._frameId=null),delete this._gestureIntent,delete this._startScale,delete this._startBearing,delete this._lastTouchEvent,o){this._map.fire(new t.Event(o+"end",{originalEvent:e})),this._drainInertiaBuffer();var a=this._inertia,n=this._map;if(a.length<2)n.snapToNorth({},{originalEvent:e});else{var s=a[a.length-1],l=a[0],c=n.transform.scaleZoom(r*s[1]),u=n.transform.scaleZoom(r*l[1]),h=(s[0]-l[0])/1e3,p=s[2];if(0!==h&&c!==u){var d=.15*(c-u)/h;Math.abs(d)>2.5&&(d=d>0?2.5:-2.5);var _=1e3*Math.abs(d/(12*.15));n.easeTo({zoom:c+d*_/2e3,duration:_,easing:Bo,around:this._aroundCenter?n.getCenter():n.unproject(p),noMoveStart:!0},{originalEvent:e});}else n.snapToNorth({},{originalEvent:e});}}},Oo.prototype._drainInertiaBuffer=function(){for(var e=this._inertia,i=t.browser.now();e.length>2&&i-e[0][0]>160;)e.shift();};var Fo={scrollZoom:So,boxZoom:Po,dragRotate:Lo,dragPan:Do,keyboard:Ao,doubleClickZoom:ko,touchZoomRotate:Oo},Uo=function(e){function i(i,o){e.call(this),this._moving=!1,this._zooming=!1,this.transform=i,this._bearingSnap=o.bearingSnap,t.bindAll(["_renderFrameCallback"],this);}return e&&(i.__proto__=e),(i.prototype=Object.create(e&&e.prototype)).constructor=i,i.prototype.getCenter=function(){return new t.LngLat(this.transform.center.lng,this.transform.center.lat)},i.prototype.setCenter=function(t,e){return this.jumpTo({center:t},e)},i.prototype.panBy=function(e,i,o){return e=t.Point.convert(e).mult(-1),this.panTo(this.transform.center,t.extend({offset:e},i),o)},i.prototype.panTo=function(e,i,o){return this.easeTo(t.extend({center:e},i),o)},i.prototype.getZoom=function(){return this.transform.zoom},i.prototype.setZoom=function(t,e){return this.jumpTo({zoom:t},e),this},i.prototype.zoomTo=function(e,i,o){return this.easeTo(t.extend({zoom:e},i),o)},i.prototype.zoomIn=function(t,e){return this.zoomTo(this.getZoom()+1,t,e),this},i.prototype.zoomOut=function(t,e){return this.zoomTo(this.getZoom()-1,t,e),this},i.prototype.getBearing=function(){return this.transform.bearing},i.prototype.setBearing=function(t,e){return this.jumpTo({bearing:t},e),this},i.prototype.getPadding=function(){return this.transform.padding},i.prototype.setPadding=function(t,e){return this.jumpTo({padding:t},e),this},i.prototype.rotateTo=function(e,i,o){return this.easeTo(t.extend({bearing:e},i),o)},i.prototype.resetNorth=function(e,i){return this.rotateTo(0,t.extend({duration:1e3},e),i),this},i.prototype.resetNorthPitch=function(e,i){return this.easeTo(t.extend({bearing:0,pitch:0,duration:1e3},e),i),this},i.prototype.snapToNorth=function(t,e){return Math.abs(this.getBearing())<this._bearingSnap?this.resetNorth(t,e):this},i.prototype.getPitch=function(){return this.transform.pitch},i.prototype.setPitch=function(t,e){return this.jumpTo({pitch:t},e),this},i.prototype.cameraForBounds=function(e,i){return e=t.LngLatBounds.convert(e),this._cameraForBoxAndBearing(e.getNorthWest(),e.getSouthEast(),0,i)},i.prototype._cameraForBoxAndBearing=function(e,i,o,r){var a={top:0,bottom:0,right:0,left:0};if("number"==typeof(r=t.extend({padding:a,offset:[0,0],maxZoom:this.transform.maxZoom},r)).padding){var n=r.padding;r.padding={top:n,bottom:n,right:n,left:n};}r.padding=t.extend(a,r.padding);var s=this.transform,l=s.padding,c=s.project(t.LngLat.convert(e)),u=s.project(t.LngLat.convert(i)),h=c.rotate(-o*Math.PI/180),p=u.rotate(-o*Math.PI/180),d=new t.Point(Math.max(h.x,p.x),Math.max(h.y,p.y)),_=new t.Point(Math.min(h.x,p.x),Math.min(h.y,p.y)),f=d.sub(_),m=(s.width-(l.left+l.right+r.padding.left+r.padding.right))/f.x,g=(s.height-(l.top+l.bottom+r.padding.top+r.padding.bottom))/f.y;if(!(g<0||m<0)){var v=Math.min(s.scaleZoom(s.scale*Math.min(m,g)),r.maxZoom),y=t.Point.convert(r.offset),x=new t.Point(y.x+(r.padding.left-r.padding.right)/2,y.y+(r.padding.top-r.padding.bottom)/2).mult(s.scale/s.zoomScale(v));return {center:s.unproject(c.add(u).div(2).sub(x)),zoom:v,bearing:o}}t.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");},i.prototype.fitBounds=function(t,e,i){return this._fitInternal(this.cameraForBounds(t,e),e,i)},i.prototype.fitScreenCoordinates=function(e,i,o,r,a){return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(t.Point.convert(e)),this.transform.pointLocation(t.Point.convert(i)),o,r),r,a)},i.prototype._fitInternal=function(e,i,o){return e?(delete(i=t.extend(e,i)).padding,i.linear?this.easeTo(i,o):this.flyTo(i,o)):this},i.prototype.jumpTo=function(e,i){this.stop();var o=this.transform,r=!1,a=!1,n=!1;return "zoom"in e&&o.zoom!==+e.zoom&&(r=!0,o.zoom=+e.zoom),void 0!==e.center&&(o.center=t.LngLat.convert(e.center)),"bearing"in e&&o.bearing!==+e.bearing&&(a=!0,o.bearing=+e.bearing),"pitch"in e&&o.pitch!==+e.pitch&&(n=!0,o.pitch=+e.pitch),null==e.padding||o.isPaddingEqual(e.padding)||(o.padding=e.padding),this.fire(new t.Event("movestart",i)).fire(new t.Event("move",i)),r&&this.fire(new t.Event("zoomstart",i)).fire(new t.Event("zoom",i)).fire(new t.Event("zoomend",i)),a&&this.fire(new t.Event("rotatestart",i)).fire(new t.Event("rotate",i)).fire(new t.Event("rotateend",i)),n&&this.fire(new t.Event("pitchstart",i)).fire(new t.Event("pitch",i)).fire(new t.Event("pitchend",i)),this.fire(new t.Event("moveend",i))},i.prototype.easeTo=function(e,i){var o=this;this.stop(),(!1===(e=t.extend({offset:[0,0],duration:500,easing:t.ease},e)).animate||!e.essential&&t.browser.prefersReducedMotion)&&(e.duration=0);var r=this.transform,a=this.getZoom(),n=this.getBearing(),s=this.getPitch(),l=this.getPadding(),c="zoom"in e?+e.zoom:a,u="bearing"in e?this._normalizeBearing(e.bearing,n):n,h="pitch"in e?+e.pitch:s,p="padding"in e?e.padding:r.padding,d=t.Point.convert(e.offset),_=r.centerPoint.add(d),f=r.pointLocation(_),m=t.LngLat.convert(e.center||f);this._normalizeCenter(m);var g,v,y=r.project(f),x=r.project(m).sub(y),b=r.zoomScale(c-a);return e.around&&(g=t.LngLat.convert(e.around),v=r.locationPoint(g)),this._zooming=c!==a,this._rotating=n!==u,this._pitching=h!==s,this._padding=!r.isPaddingEqual(p),this._prepareEase(i,e.noMoveStart),clearTimeout(this._easeEndTimeoutID),this._ease((function(e){if(o._zooming&&(r.zoom=t.number(a,c,e)),o._rotating&&(r.bearing=t.number(n,u,e)),o._pitching&&(r.pitch=t.number(s,h,e)),o._padding&&(r.interpolatePadding(l,p,e),_=r.centerPoint.add(d)),g)r.setLocationAtPoint(g,v);else{var f=r.zoomScale(r.zoom-a),m=c>a?Math.min(2,b):Math.max(.5,b),w=Math.pow(m,1-e),E=r.unproject(y.add(x.mult(e*w)).mult(f));r.setLocationAtPoint(r.renderWorldCopies?E.wrap():E,_);}o._fireMoveEvents(i);}),(function(){e.delayEndEvents?o._easeEndTimeoutID=setTimeout((function(){return o._afterEase(i)}),e.delayEndEvents):o._afterEase(i);}),e),this},i.prototype._prepareEase=function(e,i){this._moving=!0,i||this.fire(new t.Event("movestart",e)),this._zooming&&this.fire(new t.Event("zoomstart",e)),this._rotating&&this.fire(new t.Event("rotatestart",e)),this._pitching&&this.fire(new t.Event("pitchstart",e));},i.prototype._fireMoveEvents=function(e){this.fire(new t.Event("move",e)),this._zooming&&this.fire(new t.Event("zoom",e)),this._rotating&&this.fire(new t.Event("rotate",e)),this._pitching&&this.fire(new t.Event("pitch",e));},i.prototype._afterEase=function(e){var i=this._zooming,o=this._rotating,r=this._pitching;this._moving=!1,this._zooming=!1,this._rotating=!1,this._pitching=!1,this._padding=!1,i&&this.fire(new t.Event("zoomend",e)),o&&this.fire(new t.Event("rotateend",e)),r&&this.fire(new t.Event("pitchend",e)),this.fire(new t.Event("moveend",e));},i.prototype.flyTo=function(e,i){var o=this;if(!e.essential&&t.browser.prefersReducedMotion){var r=t.pick(e,["center","zoom","bearing","pitch","around"]);return this.jumpTo(r,i)}this.stop(),e=t.extend({offset:[0,0],speed:1.2,curve:1.42,easing:t.ease},e);var a=this.transform,n=this.getZoom(),s=this.getBearing(),l=this.getPitch(),c=this.getPadding(),u="zoom"in e?t.clamp(+e.zoom,a.minZoom,a.maxZoom):n,h="bearing"in e?this._normalizeBearing(e.bearing,s):s,p="pitch"in e?+e.pitch:l,d="padding"in e?e.padding:a.padding,_=a.zoomScale(u-n),f=t.Point.convert(e.offset),m=a.centerPoint.add(f),g=a.pointLocation(m),v=t.LngLat.convert(e.center||g);this._normalizeCenter(v);var y=a.project(g),x=a.project(v).sub(y),b=e.curve,w=Math.max(a.width,a.height),E=w/_,T=x.mag();if("minZoom"in e){var I=t.clamp(Math.min(e.minZoom,n,u),a.minZoom,a.maxZoom),C=w/a.zoomScale(I-n);b=Math.sqrt(C/T*2);}var S=b*b;function P(t){var e=(E*E-w*w+(t?-1:1)*S*S*T*T)/(2*(t?E:w)*S*T);return Math.log(Math.sqrt(e*e+1)-e)}function z(t){return (Math.exp(t)-Math.exp(-t))/2}function L(t){return (Math.exp(t)+Math.exp(-t))/2}var M=P(0),D=function(t){return L(M)/L(M+b*t)},A=function(t){return w*((L(M)*(z(e=M+b*t)/L(e))-z(M))/S)/T;var e;},R=(P(1)-M)/b;if(Math.abs(T)<1e-6||!isFinite(R)){if(Math.abs(w-E)<1e-6)return this.easeTo(e,i);var k=E<w?-1:1;R=Math.abs(Math.log(E/w))/b,A=function(){return 0},D=function(t){return Math.exp(k*b*t)};}return e.duration="duration"in e?+e.duration:1e3*R/("screenSpeed"in e?+e.screenSpeed/b:+e.speed),e.maxDuration&&e.duration>e.maxDuration&&(e.duration=0),this._zooming=!0,this._rotating=s!==h,this._pitching=p!==l,this._padding=!a.isPaddingEqual(d),this._prepareEase(i,!1),this._ease((function(e){var r=e*R,_=1/D(r);a.zoom=1===e?u:n+a.scaleZoom(_),o._rotating&&(a.bearing=t.number(s,h,e)),o._pitching&&(a.pitch=t.number(l,p,e)),o._padding&&(a.interpolatePadding(c,d,e),m=a.centerPoint.add(f));var g=1===e?v:a.unproject(y.add(x.mult(A(r))).mult(_));a.setLocationAtPoint(a.renderWorldCopies?g.wrap():g,m),o._fireMoveEvents(i);}),(function(){return o._afterEase(i)}),e),this},i.prototype.isEasing=function(){return !!this._easeFrameId},i.prototype.stop=function(){if(this._easeFrameId&&(this._cancelRenderFrame(this._easeFrameId),delete this._easeFrameId,delete this._onEaseFrame),this._onEaseEnd){var t=this._onEaseEnd;delete this._onEaseEnd,t.call(this);}return this},i.prototype._ease=function(e,i,o){!1===o.animate||0===o.duration?(e(1),i()):(this._easeStart=t.browser.now(),this._easeOptions=o,this._onEaseFrame=e,this._onEaseEnd=i,this._easeFrameId=this._requestRenderFrame(this._renderFrameCallback));},i.prototype._renderFrameCallback=function(){var e=Math.min((t.browser.now()-this._easeStart)/this._easeOptions.duration,1);this._onEaseFrame(this._easeOptions.easing(e)),e<1?this._easeFrameId=this._requestRenderFrame(this._renderFrameCallback):this.stop();},i.prototype._normalizeBearing=function(e,i){e=t.wrap(e,-180,180);var o=Math.abs(e-i);return Math.abs(e-360-i)<o&&(e-=360),Math.abs(e+360-i)<o&&(e+=360),e},i.prototype._normalizeCenter=function(t){var e=this.transform;if(e.renderWorldCopies&&!e.lngRange){var i=t.lng-e.center.lng;t.lng+=i>180?-360:i<-180?360:0;}},i}(t.Evented),No=function(e){void 0===e&&(e={}),this.options=e,t.bindAll(["_updateEditLink","_updateData","_updateCompact"],this);};No.prototype.getDefaultPosition=function(){return "bottom-right"},No.prototype.onAdd=function(t){var e=this.options&&this.options.compact;return this._map=t,this._container=i.create("div","mapboxgl-ctrl mapboxgl-ctrl-attrib"),this._innerContainer=i.create("div","mapboxgl-ctrl-attrib-inner",this._container),e&&this._container.classList.add("mapboxgl-compact"),this._updateAttributions(),this._updateEditLink(),this._map.on("styledata",this._updateData),this._map.on("sourcedata",this._updateData),this._map.on("moveend",this._updateEditLink),void 0===e&&(this._map.on("resize",this._updateCompact),this._updateCompact()),this._container},No.prototype.onRemove=function(){i.remove(this._container),this._map.off("styledata",this._updateData),this._map.off("sourcedata",this._updateData),this._map.off("moveend",this._updateEditLink),this._map.off("resize",this._updateCompact),this._map=void 0,this._attribHTML=void 0;},No.prototype._updateEditLink=function(){var e=this._editLink;e||(e=this._editLink=this._container.querySelector(".mapbox-improve-map"));var i=[{key:"owner",value:this.styleOwner},{key:"id",value:this.styleId},{key:"access_token",value:this._map._requestManager._customAccessToken||t.config.ACCESS_TOKEN}];if(e){var o=i.reduce((function(t,e,o){return e.value&&(t+=e.key+"="+e.value+(o<i.length-1?"&":"")),t}),"?");e.href=t.config.FEEDBACK_URL+"/"+o+(this._map._hash?this._map._hash.getHashString(!0):""),e.rel="noopener nofollow";}},No.prototype._updateData=function(t){!t||"metadata"!==t.sourceDataType&&"style"!==t.dataType||(this._updateAttributions(),this._updateEditLink());},No.prototype._updateAttributions=function(){if(this._map.style){var t=[];if(this.options.customAttribution&&(Array.isArray(this.options.customAttribution)?t=t.concat(this.options.customAttribution.map((function(t){return "string"!=typeof t?"":t}))):"string"==typeof this.options.customAttribution&&t.push(this.options.customAttribution)),this._map.style.stylesheet){var e=this._map.style.stylesheet;this.styleOwner=e.owner,this.styleId=e.id;}var i=this._map.style.sourceCaches;for(var o in i){var r=i[o];if(r.used){var a=r.getSource();a.attribution&&t.indexOf(a.attribution)<0&&t.push(a.attribution);}}t.sort((function(t,e){return t.length-e.length}));var n=(t=t.filter((function(e,i){for(var o=i+1;o<t.length;o++)if(t[o].indexOf(e)>=0)return !1;return !0}))).join(" | ");n!==this._attribHTML&&(this._attribHTML=n,t.length?(this._innerContainer.innerHTML=n,this._container.classList.remove("mapboxgl-attrib-empty")):this._container.classList.add("mapboxgl-attrib-empty"),this._editLink=null);}},No.prototype._updateCompact=function(){this._map.getCanvasContainer().offsetWidth<=640?this._container.classList.add("mapboxgl-compact"):this._container.classList.remove("mapboxgl-compact");};var Zo=function(){t.bindAll(["_updateLogo"],this),t.bindAll(["_updateCompact"],this);};Zo.prototype.onAdd=function(t){this._map=t,this._container=i.create("div","mapboxgl-ctrl");var e=i.create("a","mapboxgl-ctrl-logo");return e.target="_blank",e.rel="noopener nofollow",e.href="https://www.mapbox.com/",e.setAttribute("aria-label",this._map._getUIString("LogoControl.Title")),e.setAttribute("rel","noopener nofollow"),this._container.appendChild(e),this._container.style.display="none",this._map.on("sourcedata",this._updateLogo),this._updateLogo(),this._map.on("resize",this._updateCompact),this._updateCompact(),this._container},Zo.prototype.onRemove=function(){i.remove(this._container),this._map.off("sourcedata",this._updateLogo),this._map.off("resize",this._updateCompact);},Zo.prototype.getDefaultPosition=function(){return "bottom-left"},Zo.prototype._updateLogo=function(t){t&&"metadata"!==t.sourceDataType||(this._container.style.display=this._logoRequired()?"block":"none");},Zo.prototype._logoRequired=function(){if(this._map.style){var t=this._map.style.sourceCaches;for(var e in t)if(t[e].getSource().mapbox_logo)return !0;return !1}},Zo.prototype._updateCompact=function(){var t=this._container.children;if(t.length){var e=t[0];this._map.getCanvasContainer().offsetWidth<250?e.classList.add("mapboxgl-compact"):e.classList.remove("mapboxgl-compact");}};var qo=function(){this._queue=[],this._id=0,this._cleared=!1,this._currentlyRunning=!1;};qo.prototype.add=function(t){var e=++this._id;return this._queue.push({callback:t,id:e,cancelled:!1}),e},qo.prototype.remove=function(t){for(var e=this._currentlyRunning,i=0,o=e?this._queue.concat(e):this._queue;i<o.length;i+=1){var r=o[i];if(r.id===t)return void(r.cancelled=!0)}},qo.prototype.run=function(){var t=this._currentlyRunning=this._queue;this._queue=[];for(var e=0,i=t;e<i.length;e+=1){var o=i[e];if(!o.cancelled&&(o.callback(),this._cleared))break}this._cleared=!1,this._currentlyRunning=!1;},qo.prototype.clear=function(){this._currentlyRunning&&(this._cleared=!0),this._queue=[];};var jo={"FullscreenControl.Enter":"Enter fullscreen","FullscreenControl.Exit":"Exit fullscreen","GeolocateControl.FindMyLocation":"Find my location","GeolocateControl.LocationNotAvailable":"Location not available","LogoControl.Title":"Mapbox logo","NavigationControl.ResetBearing":"Reset bearing to north","NavigationControl.ZoomIn":"Zoom in","NavigationControl.ZoomOut":"Zoom out","ScaleControl.Feet":"ft","ScaleControl.Meters":"m","ScaleControl.Kilometers":"km","ScaleControl.Miles":"mi","ScaleControl.NauticalMiles":"nm"},Vo=t.window.HTMLImageElement,Go=t.window.HTMLElement,Wo=t.window.ImageBitmap,Xo=0,Ho=60,Ko={center:[0,0],zoom:0,bearing:0,pitch:0,minZoom:-2,maxZoom:22,minPitch:Xo,maxPitch:Ho,interactive:!0,scrollZoom:!0,boxZoom:!0,dragRotate:!0,dragPan:!0,keyboard:!0,doubleClickZoom:!0,touchZoomRotate:!0,bearingSnap:7,clickTolerance:3,hash:!1,attributionControl:!0,failIfMajorPerformanceCaveat:!1,preserveDrawingBuffer:!1,trackResize:!0,renderWorldCopies:!0,refreshExpiredTiles:!0,maxTileCacheSize:null,localIdeographFontFamily:"sans-serif",transformRequest:null,accessToken:null,fadeDuration:300,crossSourceCollisions:!0},Yo=function(o){function r(e){var r=this;if(null!=(e=t.extend({},Ko,e)).minZoom&&null!=e.maxZoom&&e.minZoom>e.maxZoom)throw new Error("maxZoom must be greater than or equal to minZoom");if(null!=e.minPitch&&null!=e.maxPitch&&e.minPitch>e.maxPitch)throw new Error("maxPitch must be greater than or equal to minPitch");if(null!=e.minPitch&&e.minPitch<Xo)throw new Error("minPitch must be greater than or equal to "+Xo);if(null!=e.maxPitch&&e.maxPitch>Ho)throw new Error("maxPitch must be less than or equal to "+Ho);var a=new bo(e.minZoom,e.maxZoom,e.minPitch,e.maxPitch,e.renderWorldCopies);if(o.call(this,a,e),this._interactive=e.interactive,this._maxTileCacheSize=e.maxTileCacheSize,this._failIfMajorPerformanceCaveat=e.failIfMajorPerformanceCaveat,this._preserveDrawingBuffer=e.preserveDrawingBuffer,this._antialias=e.antialias,this._trackResize=e.trackResize,this._bearingSnap=e.bearingSnap,this._refreshExpiredTiles=e.refreshExpiredTiles,this._fadeDuration=e.fadeDuration,this._crossSourceCollisions=e.crossSourceCollisions,this._crossFadingFactor=1,this._collectResourceTiming=e.collectResourceTiming,this._renderTaskQueue=new qo,this._controls=[],this._mapId=t.uniqueId(),this._locale=t.extend({},jo,e.locale),this._requestManager=new t.RequestManager(e.transformRequest,e.accessToken),"string"==typeof e.container){if(this._container=t.window.document.getElementById(e.container),!this._container)throw new Error("Container '"+e.container+"' not found.")}else{if(!(e.container instanceof Go))throw new Error("Invalid type: 'container' must be a String or HTMLElement.");this._container=e.container;}if(e.maxBounds&&this.setMaxBounds(e.maxBounds),t.bindAll(["_onWindowOnline","_onWindowResize","_contextLost","_contextRestored"],this),this._setupContainer(),this._setupPainter(),void 0===this.painter)throw new Error("Failed to initialize WebGL.");this.on("move",(function(){return r._update(!1)})),this.on("moveend",(function(){return r._update(!1)})),this.on("zoom",(function(){return r._update(!0)})),void 0!==t.window&&(t.window.addEventListener("online",this._onWindowOnline,!1),t.window.addEventListener("resize",this._onWindowResize,!1)),function(t,e){var o=t.getCanvasContainer(),r=null,a=!1,n=null;for(var s in Fo)t[s]=new Fo[s](t,e),e.interactive&&e[s]&&t[s].enable(e[s]);i.addEventListener(o,"mouseout",(function(e){t.fire(new To("mouseout",t,e));})),i.addEventListener(o,"mousedown",(function(r){a=!0,n=i.mousePos(o,r);var s=new To("mousedown",t,r);t.fire(s),s.defaultPrevented||(e.interactive&&!t.doubleClickZoom.isActive()&&t.stop(),t.boxZoom.onMouseDown(r),t.boxZoom.isActive()||t.dragPan.isActive()||t.dragRotate.onMouseDown(r),t.boxZoom.isActive()||t.dragRotate.isActive()||t.dragPan.onMouseDown(r));})),i.addEventListener(o,"mouseup",(function(e){var i=t.dragRotate.isActive();r&&!i&&t.fire(new To("contextmenu",t,r)),r=null,a=!1,t.fire(new To("mouseup",t,e));})),i.addEventListener(o,"mousemove",(function(e){if(!t.dragPan.isActive()&&!t.dragRotate.isActive()){for(var i=e.target;i&&i!==o;)i=i.parentNode;i===o&&t.fire(new To("mousemove",t,e));}})),i.addEventListener(o,"mouseover",(function(e){for(var i=e.target;i&&i!==o;)i=i.parentNode;i===o&&t.fire(new To("mouseover",t,e));})),i.addEventListener(o,"touchstart",(function(i){var o=new Io("touchstart",t,i);t.fire(o),o.defaultPrevented||(e.interactive&&t.stop(),t.boxZoom.isActive()||t.dragRotate.isActive()||t.dragPan.onTouchStart(i),t.touchZoomRotate.onStart(i),t.doubleClickZoom.onTouchStart(o));}),{passive:!1}),i.addEventListener(o,"touchmove",(function(e){t.fire(new Io("touchmove",t,e));}),{passive:!1}),i.addEventListener(o,"touchend",(function(e){t.fire(new Io("touchend",t,e));})),i.addEventListener(o,"touchcancel",(function(e){t.fire(new Io("touchcancel",t,e));})),i.addEventListener(o,"click",(function(r){var a=i.mousePos(o,r);(!n||a.equals(n)||a.dist(n)<e.clickTolerance)&&t.fire(new To("click",t,r));})),i.addEventListener(o,"dblclick",(function(e){var i=new To("dblclick",t,e);t.fire(i),i.defaultPrevented||t.doubleClickZoom.onDblClick(i);})),i.addEventListener(o,"contextmenu",(function(e){var i=t.dragRotate.isActive();a||i?a&&(r=e):t.fire(new To("contextmenu",t,e)),(t.dragRotate.isEnabled()||t.listens("contextmenu"))&&e.preventDefault();})),i.addEventListener(o,"wheel",(function(i){e.interactive&&t.stop();var o=new Co("wheel",t,i);t.fire(o),o.defaultPrevented||t.scrollZoom.onWheel(i);}),{passive:!1});}(this,e),this._hash=e.hash&&new Eo("string"==typeof e.hash&&e.hash||void 0).addTo(this),this._hash&&this._hash._onHashChange()||(this.jumpTo({center:e.center,zoom:e.zoom,bearing:e.bearing,pitch:e.pitch}),e.bounds&&(this.resize(),this.fitBounds(e.bounds,t.extend({},e.fitBoundsOptions,{duration:0})))),this.resize(),this._localIdeographFontFamily=e.localIdeographFontFamily,e.style&&this.setStyle(e.style,{localIdeographFontFamily:e.localIdeographFontFamily}),e.attributionControl&&this.addControl(new No({customAttribution:e.customAttribution})),this.addControl(new Zo,e.logoPosition),this.on("style.load",(function(){r.transform.unmodified&&r.jumpTo(r.style.stylesheet);})),this.on("data",(function(e){r._update("style"===e.dataType),r.fire(new t.Event(e.dataType+"data",e));})),this.on("dataloading",(function(e){r.fire(new t.Event(e.dataType+"dataloading",e));}));}o&&(r.__proto__=o),(r.prototype=Object.create(o&&o.prototype)).constructor=r;var a={showTileBoundaries:{configurable:!0},showPadding:{configurable:!0},showCollisionBoxes:{configurable:!0},showOverdrawInspector:{configurable:!0},repaint:{configurable:!0},vertices:{configurable:!0},version:{configurable:!0}};return r.prototype._getMapId=function(){return this._mapId},r.prototype.addControl=function(e,i){if(void 0===i&&e.getDefaultPosition&&(i=e.getDefaultPosition()),void 0===i&&(i="top-right"),!e||!e.onAdd)return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));var o=e.onAdd(this);this._controls.push(e);var r=this._controlPositions[i];return -1!==i.indexOf("bottom")?r.insertBefore(o,r.firstChild):r.appendChild(o),this},r.prototype.removeControl=function(e){if(!e||!e.onRemove)return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));var i=this._controls.indexOf(e);return i>-1&&this._controls.splice(i,1),e.onRemove(this),this},r.prototype.resize=function(e){var i=this._containerDimensions(),o=i[0],r=i[1];return this._resizeCanvas(o,r),this.transform.resize(o,r),this.painter.resize(o,r),this.fire(new t.Event("movestart",e)).fire(new t.Event("move",e)).fire(new t.Event("resize",e)).fire(new t.Event("moveend",e)),this},r.prototype.getBounds=function(){return this.transform.getBounds()},r.prototype.getMaxBounds=function(){return this.transform.getMaxBounds()},r.prototype.setMaxBounds=function(e){return this.transform.setMaxBounds(t.LngLatBounds.convert(e)),this._update()},r.prototype.setMinZoom=function(t){if((t=null==t?-2:t)>=-2&&t<=this.transform.maxZoom)return this.transform.minZoom=t,this._update(),this.getZoom()<t&&this.setZoom(t),this;throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")},r.prototype.getMinZoom=function(){return this.transform.minZoom},r.prototype.setMaxZoom=function(t){if((t=null==t?22:t)>=this.transform.minZoom)return this.transform.maxZoom=t,this._update(),this.getZoom()>t&&this.setZoom(t),this;throw new Error("maxZoom must be greater than the current minZoom")},r.prototype.getMaxZoom=function(){return this.transform.maxZoom},r.prototype.setMinPitch=function(t){if((t=null==t?Xo:t)<Xo)throw new Error("minPitch must be greater than or equal to "+Xo);if(t>=Xo&&t<=this.transform.maxPitch)return this.transform.minPitch=t,this._update(),this.getPitch()<t&&this.setPitch(t),this;throw new Error("minPitch must be between "+Xo+" and the current maxPitch, inclusive")},r.prototype.getMinPitch=function(){return this.transform.minPitch},r.prototype.setMaxPitch=function(t){if((t=null==t?Ho:t)>Ho)throw new Error("maxPitch must be less than or equal to "+Ho);if(t>=this.transform.minPitch)return this.transform.maxPitch=t,this._update(),this.getPitch()>t&&this.setPitch(t),this;throw new Error("maxPitch must be greater than the current minPitch")},r.prototype.getMaxPitch=function(){return this.transform.maxPitch},r.prototype.getRenderWorldCopies=function(){return this.transform.renderWorldCopies},r.prototype.setRenderWorldCopies=function(t){return this.transform.renderWorldCopies=t,this._update()},r.prototype.project=function(e){return this.transform.locationPoint(t.LngLat.convert(e))},r.prototype.unproject=function(e){return this.transform.pointLocation(t.Point.convert(e))},r.prototype.isMoving=function(){return this._moving||this.dragPan.isActive()||this.dragRotate.isActive()||this.scrollZoom.isActive()},r.prototype.isZooming=function(){return this._zooming||this.scrollZoom.isZooming()},r.prototype.isRotating=function(){return this._rotating||this.dragRotate.isActive()},r.prototype._createDelegatedListener=function(t,e,i){var o,r=this;if("mouseenter"===t||"mouseover"===t){var a=!1;return {layer:e,listener:i,delegates:{mousemove:function(o){var n=r.getLayer(e)?r.queryRenderedFeatures(o.point,{layers:[e]}):[];n.length?a||(a=!0,i.call(r,new To(t,r,o.originalEvent,{features:n}))):a=!1;},mouseout:function(){a=!1;}}}}if("mouseleave"===t||"mouseout"===t){var n=!1;return {layer:e,listener:i,delegates:{mousemove:function(o){(r.getLayer(e)?r.queryRenderedFeatures(o.point,{layers:[e]}):[]).length?n=!0:n&&(n=!1,i.call(r,new To(t,r,o.originalEvent)));},mouseout:function(e){n&&(n=!1,i.call(r,new To(t,r,e.originalEvent)));}}}}return {layer:e,listener:i,delegates:(o={},o[t]=function(t){var o=r.getLayer(e)?r.queryRenderedFeatures(t.point,{layers:[e]}):[];o.length&&(t.features=o,i.call(r,t),delete t.features);},o)}},r.prototype.on=function(t,e,i){if(void 0===i)return o.prototype.on.call(this,t,e);var r=this._createDelegatedListener(t,e,i);for(var a in this._delegatedListeners=this._delegatedListeners||{},this._delegatedListeners[t]=this._delegatedListeners[t]||[],this._delegatedListeners[t].push(r),r.delegates)this.on(a,r.delegates[a]);return this},r.prototype.once=function(t,e,i){if(void 0===i)return o.prototype.once.call(this,t,e);var r=this._createDelegatedListener(t,e,i);for(var a in r.delegates)this.once(a,r.delegates[a]);return this},r.prototype.off=function(t,e,i){var r=this;return void 0===i?o.prototype.off.call(this,t,e):(this._delegatedListeners&&this._delegatedListeners[t]&&function(o){for(var a=o[t],n=0;n<a.length;n++){var s=a[n];if(s.layer===e&&s.listener===i){for(var l in s.delegates)r.off(l,s.delegates[l]);return a.splice(n,1),r}}}(this._delegatedListeners),this)},r.prototype.queryRenderedFeatures=function(e,i){if(!this.style)return [];var o;if(void 0!==i||void 0===e||e instanceof t.Point||Array.isArray(e)||(i=e,e=void 0),i=i||{},(e=e||[[0,0],[this.transform.width,this.transform.height]])instanceof t.Point||"number"==typeof e[0])o=[t.Point.convert(e)];else{var r=t.Point.convert(e[0]),a=t.Point.convert(e[1]);o=[r,new t.Point(a.x,r.y),a,new t.Point(r.x,a.y),r];}return this.style.queryRenderedFeatures(o,i,this.transform)},r.prototype.querySourceFeatures=function(t,e){return this.style.querySourceFeatures(t,e)},r.prototype.setStyle=function(e,i){return !1!==(i=t.extend({},{localIdeographFontFamily:this._localIdeographFontFamily},i)).diff&&i.localIdeographFontFamily===this._localIdeographFontFamily&&this.style&&e?(this._diffStyle(e,i),this):(this._localIdeographFontFamily=i.localIdeographFontFamily,this._updateStyle(e,i))},r.prototype._getUIString=function(t){var e=this._locale[t];if(null==e)throw new Error("Missing UI string '"+t+"'");return e},r.prototype._updateStyle=function(t,e){return this.style&&(this.style.setEventedParent(null),this.style._remove()),t?(this.style=new Ne(this,e||{}),this.style.setEventedParent(this,{style:this.style}),"string"==typeof t?this.style.loadURL(t):this.style.loadJSON(t),this):(delete this.style,this)},r.prototype._lazyInitEmptyStyle=function(){this.style||(this.style=new Ne(this,{}),this.style.setEventedParent(this,{style:this.style}),this.style.loadEmpty());},r.prototype._diffStyle=function(e,i){var o=this;if("string"==typeof e){var r=this._requestManager.normalizeStyleURL(e),a=this._requestManager.transformRequest(r,t.ResourceType.Style);t.getJSON(a,(function(e,r){e?o.fire(new t.ErrorEvent(e)):r&&o._updateDiff(r,i);}));}else"object"==typeof e&&this._updateDiff(e,i);},r.prototype._updateDiff=function(e,i){try{this.style.setState(e)&&this._update(!0);}catch(o){t.warnOnce("Unable to perform style diff: "+(o.message||o.error||o)+".  Rebuilding the style from scratch."),this._updateStyle(e,i);}},r.prototype.getStyle=function(){if(this.style)return this.style.serialize()},r.prototype.isStyleLoaded=function(){return this.style?this.style.loaded():t.warnOnce("There is no style added to the map.")},r.prototype.addSource=function(t,e){return this._lazyInitEmptyStyle(),this.style.addSource(t,e),this._update(!0)},r.prototype.isSourceLoaded=function(e){var i=this.style&&this.style.sourceCaches[e];if(void 0!==i)return i.loaded();this.fire(new t.ErrorEvent(new Error("There is no source with ID '"+e+"'")));},r.prototype.areTilesLoaded=function(){var t=this.style&&this.style.sourceCaches;for(var e in t){var i=t[e]._tiles;for(var o in i){var r=i[o];if("loaded"!==r.state&&"errored"!==r.state)return !1}}return !0},r.prototype.addSourceType=function(t,e,i){return this._lazyInitEmptyStyle(),this.style.addSourceType(t,e,i)},r.prototype.removeSource=function(t){return this.style.removeSource(t),this._update(!0)},r.prototype.getSource=function(t){return this.style.getSource(t)},r.prototype.addImage=function(e,i,o){void 0===o&&(o={});var r=o.pixelRatio;void 0===r&&(r=1);var a=o.sdf;void 0===a&&(a=!1);var n=o.stretchX,s=o.stretchY,l=o.content;if(this._lazyInitEmptyStyle(),i instanceof Vo||Wo&&i instanceof Wo){var c=t.browser.getImageData(i);this.style.addImage(e,{data:new t.RGBAImage({width:c.width,height:c.height},c.data),pixelRatio:r,stretchX:n,stretchY:s,content:l,sdf:a,version:0});}else{if(void 0===i.width||void 0===i.height)return this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));var u=i;this.style.addImage(e,{data:new t.RGBAImage({width:i.width,height:i.height},new Uint8Array(i.data)),pixelRatio:r,stretchX:n,stretchY:s,content:l,sdf:a,version:0,userImage:u}),u.onAdd&&u.onAdd(this,e);}},r.prototype.updateImage=function(e,i){var o=this.style.getImage(e);if(!o)return this.fire(new t.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));var r=i instanceof Vo||Wo&&i instanceof Wo?t.browser.getImageData(i):i,a=r.width,n=r.height,s=r.data;return void 0===a||void 0===n?this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))):a!==o.data.width||n!==o.data.height?this.fire(new t.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image"))):(o.data.replace(s,!(i instanceof Vo||Wo&&i instanceof Wo)),void this.style.updateImage(e,o))},r.prototype.hasImage=function(e){return e?!!this.style.getImage(e):(this.fire(new t.ErrorEvent(new Error("Missing required image id"))),!1)},r.prototype.removeImage=function(t){this.style.removeImage(t);},r.prototype.loadImage=function(e,i){t.getImage(this._requestManager.transformRequest(e,t.ResourceType.Image),i);},r.prototype.listImages=function(){return this.style.listImages()},r.prototype.addLayer=function(t,e){return this._lazyInitEmptyStyle(),this.style.addLayer(t,e),this._update(!0)},r.prototype.moveLayer=function(t,e){return this.style.moveLayer(t,e),this._update(!0)},r.prototype.removeLayer=function(t){return this.style.removeLayer(t),this._update(!0)},r.prototype.getLayer=function(t){return this.style.getLayer(t)},r.prototype.setLayerZoomRange=function(t,e,i){return this.style.setLayerZoomRange(t,e,i),this._update(!0)},r.prototype.setFilter=function(t,e,i){return void 0===i&&(i={}),this.style.setFilter(t,e,i),this._update(!0)},r.prototype.getFilter=function(t){return this.style.getFilter(t)},r.prototype.setPaintProperty=function(t,e,i,o){return void 0===o&&(o={}),this.style.setPaintProperty(t,e,i,o),this._update(!0)},r.prototype.getPaintProperty=function(t,e){return this.style.getPaintProperty(t,e)},r.prototype.setLayoutProperty=function(t,e,i,o){return void 0===o&&(o={}),this.style.setLayoutProperty(t,e,i,o),this._update(!0)},r.prototype.getLayoutProperty=function(t,e){return this.style.getLayoutProperty(t,e)},r.prototype.setLight=function(t,e){return void 0===e&&(e={}),this._lazyInitEmptyStyle(),this.style.setLight(t,e),this._update(!0)},r.prototype.getLight=function(){return this.style.getLight()},r.prototype.setFeatureState=function(t,e){return this.style.setFeatureState(t,e),this._update()},r.prototype.removeFeatureState=function(t,e){return this.style.removeFeatureState(t,e),this._update()},r.prototype.getFeatureState=function(t){return this.style.getFeatureState(t)},r.prototype.getContainer=function(){return this._container},r.prototype.getCanvasContainer=function(){return this._canvasContainer},r.prototype.getCanvas=function(){return this._canvas},r.prototype._containerDimensions=function(){var t=0,e=0;return this._container&&(t=this._container.clientWidth||400,e=this._container.clientHeight||300),[t,e]},r.prototype._detectMissingCSS=function(){"rgb(250, 128, 114)"!==t.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color")&&t.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");},r.prototype._setupContainer=function(){var t=this._container;t.classList.add("mapboxgl-map"),(this._missingCSSCanary=i.create("div","mapboxgl-canary",t)).style.visibility="hidden",this._detectMissingCSS();var e=this._canvasContainer=i.create("div","mapboxgl-canvas-container",t);this._interactive&&e.classList.add("mapboxgl-interactive"),this._canvas=i.create("canvas","mapboxgl-canvas",e),this._canvas.addEventListener("webglcontextlost",this._contextLost,!1),this._canvas.addEventListener("webglcontextrestored",this._contextRestored,!1),this._canvas.setAttribute("tabindex","0"),this._canvas.setAttribute("aria-label","Map");var o=this._containerDimensions();this._resizeCanvas(o[0],o[1]);var r=this._controlContainer=i.create("div","mapboxgl-control-container",t),a=this._controlPositions={};["top-left","top-right","bottom-left","bottom-right"].forEach((function(t){a[t]=i.create("div","mapboxgl-ctrl-"+t,r);}));},r.prototype._resizeCanvas=function(e,i){var o=t.browser.devicePixelRatio||1;this._canvas.width=o*e,this._canvas.height=o*i,this._canvas.style.width=e+"px",this._canvas.style.height=i+"px";},r.prototype._setupPainter=function(){var i=t.extend({},e.webGLContextAttributes,{failIfMajorPerformanceCaveat:this._failIfMajorPerformanceCaveat,preserveDrawingBuffer:this._preserveDrawingBuffer,antialias:this._antialias||!1}),o=this._canvas.getContext("webgl",i)||this._canvas.getContext("experimental-webgl",i);o?(this.painter=new go(o,this.transform),t.webpSupported.testSupport(o)):this.fire(new t.ErrorEvent(new Error("Failed to initialize WebGL")));},r.prototype._contextLost=function(e){e.preventDefault(),this._frame&&(this._frame.cancel(),this._frame=null),this.fire(new t.Event("webglcontextlost",{originalEvent:e}));},r.prototype._contextRestored=function(e){this._setupPainter(),this.resize(),this._update(),this.fire(new t.Event("webglcontextrestored",{originalEvent:e}));},r.prototype.loaded=function(){return !this._styleDirty&&!this._sourcesDirty&&!!this.style&&this.style.loaded()},r.prototype._update=function(t){return this.style?(this._styleDirty=this._styleDirty||t,this._sourcesDirty=!0,this.triggerRepaint(),this):this},r.prototype._requestRenderFrame=function(t){return this._update(),this._renderTaskQueue.add(t)},r.prototype._cancelRenderFrame=function(t){this._renderTaskQueue.remove(t);},r.prototype._render=function(){var e,i=this,o=0,r=this.painter.context.extTimerQuery;this.listens("gpu-timing-frame")&&(e=r.createQueryEXT(),r.beginQueryEXT(r.TIME_ELAPSED_EXT,e),o=t.browser.now()),this.painter.context.setDirty(),this.painter.setBaseState(),this._renderTaskQueue.run();var a=!1;if(this.style&&this._styleDirty){this._styleDirty=!1;var n=this.transform.zoom,s=t.browser.now();this.style.zoomHistory.update(n,s);var l=new t.EvaluationParameters(n,{now:s,fadeDuration:this._fadeDuration,zoomHistory:this.style.zoomHistory,transition:this.style.getTransition()}),c=l.crossFadingFactor();1===c&&c===this._crossFadingFactor||(a=!0,this._crossFadingFactor=c),this.style.update(l);}if(this.style&&this._sourcesDirty&&(this._sourcesDirty=!1,this.style._updateSources(this.transform)),this._placementDirty=this.style&&this.style._updatePlacement(this.painter.transform,this.showCollisionBoxes,this._fadeDuration,this._crossSourceCollisions),this.painter.render(this.style,{showTileBoundaries:this.showTileBoundaries,showOverdrawInspector:this._showOverdrawInspector,rotating:this.isRotating(),zooming:this.isZooming(),moving:this.isMoving(),fadeDuration:this._fadeDuration,showPadding:this.showPadding,gpuTiming:!!this.listens("gpu-timing-layer")}),this.fire(new t.Event("render")),this.loaded()&&!this._loaded&&(this._loaded=!0,this.fire(new t.Event("load"))),this.style&&(this.style.hasTransitions()||a)&&(this._styleDirty=!0),this.style&&!this._placementDirty&&this.style._releaseSymbolFadeTiles(),this.listens("gpu-timing-frame")){var u=t.browser.now()-o;r.endQueryEXT(r.TIME_ELAPSED_EXT,e),setTimeout((function(){var o=r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6;r.deleteQueryEXT(e),i.fire(new t.Event("gpu-timing-frame",{cpuTime:u,gpuTime:o}));}),50);}if(this.listens("gpu-timing-layer")){var h=this.painter.collectGpuTimers();setTimeout((function(){var e=i.painter.queryGpuTimers(h);i.fire(new t.Event("gpu-timing-layer",{layerTimes:e}));}),50);}return this._sourcesDirty||this._styleDirty||this._placementDirty||this._repaint?this.triggerRepaint():!this.isMoving()&&this.loaded()&&(this._fullyLoaded||(this._fullyLoaded=!0),this.fire(new t.Event("idle"))),this},r.prototype.remove=function(){this._hash&&this._hash.remove();for(var e=0,i=this._controls;e<i.length;e+=1)i[e].onRemove(this);this._controls=[],this._frame&&(this._frame.cancel(),this._frame=null),this._renderTaskQueue.clear(),this.painter.destroy(),this.setStyle(null),void 0!==t.window&&(t.window.removeEventListener("resize",this._onWindowResize,!1),t.window.removeEventListener("online",this._onWindowOnline,!1));var o=this.painter.context.gl.getExtension("WEBGL_lose_context");o&&o.loseContext(),Jo(this._canvasContainer),Jo(this._controlContainer),Jo(this._missingCSSCanary),this._container.classList.remove("mapboxgl-map"),this.fire(new t.Event("remove"));},r.prototype.triggerRepaint=function(){var e=this;this.style&&!this._frame&&(this._frame=t.browser.frame((function(t){e._frame=null,e._render();})));},r.prototype._onWindowOnline=function(){this._update();},r.prototype._onWindowResize=function(t){this._trackResize&&this.resize({originalEvent:t})._update();},a.showTileBoundaries.get=function(){return !!this._showTileBoundaries},a.showTileBoundaries.set=function(t){this._showTileBoundaries!==t&&(this._showTileBoundaries=t,this._update());},a.showPadding.get=function(){return !!this._showPadding},a.showPadding.set=function(t){this._showPadding!==t&&(this._showPadding=t,this._update());},a.showCollisionBoxes.get=function(){return !!this._showCollisionBoxes},a.showCollisionBoxes.set=function(t){this._showCollisionBoxes!==t&&(this._showCollisionBoxes=t,t?this.style._generateCollisionBoxes():this._update());},a.showOverdrawInspector.get=function(){return !!this._showOverdrawInspector},a.showOverdrawInspector.set=function(t){this._showOverdrawInspector!==t&&(this._showOverdrawInspector=t,this._update());},a.repaint.get=function(){return !!this._repaint},a.repaint.set=function(t){this._repaint!==t&&(this._repaint=t,this.triggerRepaint());},a.vertices.get=function(){return !!this._vertices},a.vertices.set=function(t){this._vertices=t,this._update();},r.prototype._setCacheLimits=function(e,i){t.setCacheLimits(e,i);},a.version.get=function(){return t.version},Object.defineProperties(r.prototype,a),r}(Uo);function Jo(t){t.parentNode&&t.parentNode.removeChild(t);}var Qo={showCompass:!0,showZoom:!0,visualizePitch:!1},$o=function(e){var o=this;this.options=t.extend({},Qo,e),this._container=i.create("div","mapboxgl-ctrl mapboxgl-ctrl-group"),this._container.addEventListener("contextmenu",(function(t){return t.preventDefault()})),this.options.showZoom&&(t.bindAll(["_setButtonTitle","_updateZoomButtons"],this),this._zoomInButton=this._createButton("mapboxgl-ctrl-zoom-in",(function(t){return o._map.zoomIn({},{originalEvent:t})})),i.create("span","mapboxgl-ctrl-icon",this._zoomInButton).setAttribute("aria-hidden",!0),this._zoomOutButton=this._createButton("mapboxgl-ctrl-zoom-out",(function(t){return o._map.zoomOut({},{originalEvent:t})})),i.create("span","mapboxgl-ctrl-icon",this._zoomOutButton).setAttribute("aria-hidden",!0)),this.options.showCompass&&(t.bindAll(["_rotateCompassArrow"],this),this._compass=this._createButton("mapboxgl-ctrl-compass",(function(t){o.options.visualizePitch?o._map.resetNorthPitch({},{originalEvent:t}):o._map.resetNorth({},{originalEvent:t});})),this._compassIcon=i.create("span","mapboxgl-ctrl-icon",this._compass),this._compassIcon.setAttribute("aria-hidden",!0));};function tr(e,i,o){if(e=new t.LngLat(e.lng,e.lat),i){var r=new t.LngLat(e.lng-360,e.lat),a=new t.LngLat(e.lng+360,e.lat),n=o.locationPoint(e).distSqr(i);o.locationPoint(r).distSqr(i)<n?e=r:o.locationPoint(a).distSqr(i)<n&&(e=a);}for(;Math.abs(e.lng-o.center.lng)>180;){var s=o.locationPoint(e);if(s.x>=0&&s.y>=0&&s.x<=o.width&&s.y<=o.height)break;e.lng>o.center.lng?e.lng-=360:e.lng+=360;}return e}$o.prototype._updateZoomButtons=function(){var t=this._map.getZoom();this._zoomInButton.disabled=t===this._map.getMaxZoom(),this._zoomOutButton.disabled=t===this._map.getMinZoom();},$o.prototype._rotateCompassArrow=function(){var t=this.options.visualizePitch?"scale("+1/Math.pow(Math.cos(this._map.transform.pitch*(Math.PI/180)),.5)+") rotateX("+this._map.transform.pitch+"deg) rotateZ("+this._map.transform.angle*(180/Math.PI)+"deg)":"rotate("+this._map.transform.angle*(180/Math.PI)+"deg)";this._compassIcon.style.transform=t;},$o.prototype.onAdd=function(t){return this._map=t,this.options.showZoom&&(this._setButtonTitle(this._zoomInButton,"ZoomIn"),this._setButtonTitle(this._zoomOutButton,"ZoomOut"),this._map.on("zoom",this._updateZoomButtons),this._updateZoomButtons()),this.options.showCompass&&(this._setButtonTitle(this._compass,"ResetBearing"),this.options.visualizePitch&&this._map.on("pitch",this._rotateCompassArrow),this._map.on("rotate",this._rotateCompassArrow),this._rotateCompassArrow(),this._handler=new Lo(t,{button:"left",element:this._compass,clickTolerance:t.dragRotate._clickTolerance}),i.addEventListener(this._compass,"mousedown",this._handler.onMouseDown),i.addEventListener(this._compass,"touchstart",this._handler.onMouseDown,{passive:!1}),this._handler.enable()),this._container},$o.prototype.onRemove=function(){i.remove(this._container),this.options.showZoom&&this._map.off("zoom",this._updateZoomButtons),this.options.showCompass&&(this.options.visualizePitch&&this._map.off("pitch",this._rotateCompassArrow),this._map.off("rotate",this._rotateCompassArrow),i.removeEventListener(this._compass,"mousedown",this._handler.onMouseDown),i.removeEventListener(this._compass,"touchstart",this._handler.onMouseDown,{passive:!1}),this._handler.disable(),delete this._handler),delete this._map;},$o.prototype._createButton=function(t,e){var o=i.create("button",t,this._container);return o.type="button",o.addEventListener("click",e),o},$o.prototype._setButtonTitle=function(t,e){var i=this._map._getUIString("NavigationControl."+e);t.title=i,t.setAttribute("aria-label",i);};var er={center:"translate(-50%,-50%)",top:"translate(-50%,0)","top-left":"translate(0,0)","top-right":"translate(-100%,0)",bottom:"translate(-50%,-100%)","bottom-left":"translate(0,-100%)","bottom-right":"translate(-100%,-100%)",left:"translate(0,-50%)",right:"translate(-100%,-50%)"};function ir(t,e,i){var o=t.classList;for(var r in er)o.remove("mapboxgl-"+i+"-anchor-"+r);o.add("mapboxgl-"+i+"-anchor-"+e);}var or,rr=function(e){function o(o,r){var a=this;if(e.call(this),(o instanceof t.window.HTMLElement||r)&&(o=t.extend({element:o},r)),t.bindAll(["_update","_onMove","_onUp","_addDragHandler","_onMapClick","_onKeyPress"],this),this._anchor=o&&o.anchor||"center",this._color=o&&o.color||"#3FB1CE",this._draggable=o&&o.draggable||!1,this._state="inactive",this._rotation=o&&o.rotation||0,this._rotationAlignment=o&&o.rotationAlignment||"auto",this._pitchAlignment=o&&o.pitchAlignment&&"auto"!==o.pitchAlignment?o.pitchAlignment:this._rotationAlignment,o&&o.element)this._element=o.element,this._offset=t.Point.convert(o&&o.offset||[0,0]);else{this._defaultMarker=!0,this._element=i.create("div"),this._element.setAttribute("aria-label","Map marker");var n=i.createNS("http://www.w3.org/2000/svg","svg");n.setAttributeNS(null,"display","block"),n.setAttributeNS(null,"height","41px"),n.setAttributeNS(null,"width","27px"),n.setAttributeNS(null,"viewBox","0 0 27 41");var s=i.createNS("http://www.w3.org/2000/svg","g");s.setAttributeNS(null,"stroke","none"),s.setAttributeNS(null,"stroke-width","1"),s.setAttributeNS(null,"fill","none"),s.setAttributeNS(null,"fill-rule","evenodd");var l=i.createNS("http://www.w3.org/2000/svg","g");l.setAttributeNS(null,"fill-rule","nonzero");var c=i.createNS("http://www.w3.org/2000/svg","g");c.setAttributeNS(null,"transform","translate(3.0, 29.0)"),c.setAttributeNS(null,"fill","#000000");for(var u=0,h=[{rx:"10.5",ry:"5.25002273"},{rx:"10.5",ry:"5.25002273"},{rx:"9.5",ry:"4.77275007"},{rx:"8.5",ry:"4.29549936"},{rx:"7.5",ry:"3.81822308"},{rx:"6.5",ry:"3.34094679"},{rx:"5.5",ry:"2.86367051"},{rx:"4.5",ry:"2.38636864"}];u<h.length;u+=1){var p=h[u],d=i.createNS("http://www.w3.org/2000/svg","ellipse");d.setAttributeNS(null,"opacity","0.04"),d.setAttributeNS(null,"cx","10.5"),d.setAttributeNS(null,"cy","5.80029008"),d.setAttributeNS(null,"rx",p.rx),d.setAttributeNS(null,"ry",p.ry),c.appendChild(d);}var _=i.createNS("http://www.w3.org/2000/svg","g");_.setAttributeNS(null,"fill",this._color);var f=i.createNS("http://www.w3.org/2000/svg","path");f.setAttributeNS(null,"d","M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"),_.appendChild(f);var m=i.createNS("http://www.w3.org/2000/svg","g");m.setAttributeNS(null,"opacity","0.25"),m.setAttributeNS(null,"fill","#000000");var g=i.createNS("http://www.w3.org/2000/svg","path");g.setAttributeNS(null,"d","M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"),m.appendChild(g);var v=i.createNS("http://www.w3.org/2000/svg","g");v.setAttributeNS(null,"transform","translate(6.0, 7.0)"),v.setAttributeNS(null,"fill","#FFFFFF");var y=i.createNS("http://www.w3.org/2000/svg","g");y.setAttributeNS(null,"transform","translate(8.0, 8.0)");var x=i.createNS("http://www.w3.org/2000/svg","circle");x.setAttributeNS(null,"fill","#000000"),x.setAttributeNS(null,"opacity","0.25"),x.setAttributeNS(null,"cx","5.5"),x.setAttributeNS(null,"cy","5.5"),x.setAttributeNS(null,"r","5.4999962");var b=i.createNS("http://www.w3.org/2000/svg","circle");b.setAttributeNS(null,"fill","#FFFFFF"),b.setAttributeNS(null,"cx","5.5"),b.setAttributeNS(null,"cy","5.5"),b.setAttributeNS(null,"r","5.4999962"),y.appendChild(x),y.appendChild(b),l.appendChild(c),l.appendChild(_),l.appendChild(m),l.appendChild(v),l.appendChild(y),n.appendChild(l),this._element.appendChild(n),this._offset=t.Point.convert(o&&o.offset||[0,-14]);}this._element.classList.add("mapboxgl-marker"),this._element.addEventListener("dragstart",(function(t){t.preventDefault();})),this._element.addEventListener("mousedown",(function(t){t.preventDefault();})),this._element.addEventListener("focus",(function(){var t=a._map.getContainer();t.scrollTop=0,t.scrollLeft=0;})),ir(this._element,this._anchor,"marker"),this._popup=null;}return e&&(o.__proto__=e),(o.prototype=Object.create(e&&e.prototype)).constructor=o,o.prototype.addTo=function(t){return this.remove(),this._map=t,t.getCanvasContainer().appendChild(this._element),t.on("move",this._update),t.on("moveend",this._update),this.setDraggable(this._draggable),this._update(),this._map.on("click",this._onMapClick),this},o.prototype.remove=function(){return this._map&&(this._map.off("click",this._onMapClick),this._map.off("move",this._update),this._map.off("moveend",this._update),this._map.off("mousedown",this._addDragHandler),this._map.off("touchstart",this._addDragHandler),this._map.off("mouseup",this._onUp),this._map.off("touchend",this._onUp),this._map.off("mousemove",this._onMove),this._map.off("touchmove",this._onMove),delete this._map),i.remove(this._element),this._popup&&this._popup.remove(),this},o.prototype.getLngLat=function(){return this._lngLat},o.prototype.setLngLat=function(e){return this._lngLat=t.LngLat.convert(e),this._pos=null,this._popup&&this._popup.setLngLat(this._lngLat),this._update(),this},o.prototype.getElement=function(){return this._element},o.prototype.setPopup=function(t){if(this._popup&&(this._popup.remove(),this._popup=null,this._element.removeEventListener("keypress",this._onKeyPress),this._originalTabIndex||this._element.removeAttribute("tabindex")),t){if(!("offset"in t.options)){var e=Math.sqrt(Math.pow(13.5,2)/2);t.options.offset=this._defaultMarker?{top:[0,0],"top-left":[0,0],"top-right":[0,0],bottom:[0,-38.1],"bottom-left":[e,-1*(24.6+e)],"bottom-right":[-e,-1*(24.6+e)],left:[13.5,-24.6],right:[-13.5,-24.6]}:this._offset;}this._popup=t,this._lngLat&&this._popup.setLngLat(this._lngLat),this._originalTabIndex=this._element.getAttribute("tabindex"),this._originalTabIndex||this._element.setAttribute("tabindex","0"),this._element.addEventListener("keypress",this._onKeyPress);}return this},o.prototype._onKeyPress=function(t){var e=t.code,i=t.charCode||t.keyCode;"Space"!==e&&"Enter"!==e&&32!==i&&13!==i||this.togglePopup();},o.prototype._onMapClick=function(t){var e=t.originalEvent.target,i=this._element;this._popup&&(e===i||i.contains(e))&&this.togglePopup();},o.prototype.getPopup=function(){return this._popup},o.prototype.togglePopup=function(){var t=this._popup;return t?(t.isOpen()?t.remove():t.addTo(this._map),this):this},o.prototype._update=function(t){if(this._map){this._map.transform.renderWorldCopies&&(this._lngLat=tr(this._lngLat,this._pos,this._map.transform)),this._pos=this._map.project(this._lngLat)._add(this._offset);var e="";"viewport"===this._rotationAlignment||"auto"===this._rotationAlignment?e="rotateZ("+this._rotation+"deg)":"map"===this._rotationAlignment&&(e="rotateZ("+(this._rotation-this._map.getBearing())+"deg)");var o="";"viewport"===this._pitchAlignment||"auto"===this._pitchAlignment?o="rotateX(0deg)":"map"===this._pitchAlignment&&(o="rotateX("+this._map.getPitch()+"deg)"),t&&"moveend"!==t.type||(this._pos=this._pos.round()),i.setTransform(this._element,er[this._anchor]+" translate("+this._pos.x+"px, "+this._pos.y+"px) "+o+" "+e);}},o.prototype.getOffset=function(){return this._offset},o.prototype.setOffset=function(e){return this._offset=t.Point.convert(e),this._update(),this},o.prototype._onMove=function(e){this._pos=e.point.sub(this._positionDelta),this._lngLat=this._map.unproject(this._pos),this.setLngLat(this._lngLat),this._element.style.pointerEvents="none","pending"===this._state&&(this._state="active",this.fire(new t.Event("dragstart"))),this.fire(new t.Event("drag"));},o.prototype._onUp=function(){this._element.style.pointerEvents="auto",this._positionDelta=null,this._map.off("mousemove",this._onMove),this._map.off("touchmove",this._onMove),"active"===this._state&&this.fire(new t.Event("dragend")),this._state="inactive";},o.prototype._addDragHandler=function(t){this._element.contains(t.originalEvent.target)&&(t.preventDefault(),this._positionDelta=t.point.sub(this._pos).add(this._offset),this._state="pending",this._map.on("mousemove",this._onMove),this._map.on("touchmove",this._onMove),this._map.once("mouseup",this._onUp),this._map.once("touchend",this._onUp));},o.prototype.setDraggable=function(t){return this._draggable=!!t,this._map&&(t?(this._map.on("mousedown",this._addDragHandler),this._map.on("touchstart",this._addDragHandler)):(this._map.off("mousedown",this._addDragHandler),this._map.off("touchstart",this._addDragHandler))),this},o.prototype.isDraggable=function(){return this._draggable},o.prototype.setRotation=function(t){return this._rotation=t||0,this._update(),this},o.prototype.getRotation=function(){return this._rotation},o.prototype.setRotationAlignment=function(t){return this._rotationAlignment=t||"auto",this._update(),this},o.prototype.getRotationAlignment=function(){return this._rotationAlignment},o.prototype.setPitchAlignment=function(t){return this._pitchAlignment=t&&"auto"!==t?t:this._rotationAlignment,this._update(),this},o.prototype.getPitchAlignment=function(){return this._pitchAlignment},o}(t.Evented),ar={positionOptions:{enableHighAccuracy:!1,maximumAge:0,timeout:6e3},fitBoundsOptions:{maxZoom:15},trackUserLocation:!1,showAccuracyCircle:!0,showUserLocation:!0},nr=0,sr=!1,lr=function(e){function o(i){e.call(this),this.options=t.extend({},ar,i),t.bindAll(["_onSuccess","_onError","_onZoom","_finish","_setupUI","_updateCamera","_updateMarker"],this);}return e&&(o.__proto__=e),(o.prototype=Object.create(e&&e.prototype)).constructor=o,o.prototype.onAdd=function(e){var o;return this._map=e,this._container=i.create("div","mapboxgl-ctrl mapboxgl-ctrl-group"),o=this._setupUI,void 0!==or?o(or):void 0!==t.window.navigator.permissions?t.window.navigator.permissions.query({name:"geolocation"}).then((function(t){o(or="denied"!==t.state);})):o(or=!!t.window.navigator.geolocation),this._container},o.prototype.onRemove=function(){void 0!==this._geolocationWatchID&&(t.window.navigator.geolocation.clearWatch(this._geolocationWatchID),this._geolocationWatchID=void 0),this.options.showUserLocation&&this._userLocationDotMarker&&this._userLocationDotMarker.remove(),this.options.showAccuracyCircle&&this._accuracyCircleMarker&&this._accuracyCircleMarker.remove(),i.remove(this._container),this._map.off("zoom",this._onZoom),this._map=void 0,nr=0,sr=!1;},o.prototype._isOutOfMapMaxBounds=function(t){var e=this._map.getMaxBounds(),i=t.coords;return e&&(i.longitude<e.getWest()||i.longitude>e.getEast()||i.latitude<e.getSouth()||i.latitude>e.getNorth())},o.prototype._setErrorState=function(){switch(this._watchState){case"WAITING_ACTIVE":this._watchState="ACTIVE_ERROR",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");break;case"ACTIVE_LOCK":this._watchState="ACTIVE_ERROR",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");break;case"BACKGROUND":this._watchState="BACKGROUND_ERROR",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");}},o.prototype._onSuccess=function(e){if(this._map){if(this._isOutOfMapMaxBounds(e))return this._setErrorState(),this.fire(new t.Event("outofmaxbounds",e)),this._updateMarker(),void this._finish();if(this.options.trackUserLocation)switch(this._lastKnownPosition=e,this._watchState){case"WAITING_ACTIVE":case"ACTIVE_LOCK":case"ACTIVE_ERROR":this._watchState="ACTIVE_LOCK",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");break;case"BACKGROUND":case"BACKGROUND_ERROR":this._watchState="BACKGROUND",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");}this.options.showUserLocation&&"OFF"!==this._watchState&&this._updateMarker(e),this.options.trackUserLocation&&"ACTIVE_LOCK"!==this._watchState||this._updateCamera(e),this.options.showUserLocation&&this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"),this.fire(new t.Event("geolocate",e)),this._finish();}},o.prototype._updateCamera=function(e){var i=new t.LngLat(e.coords.longitude,e.coords.latitude),o=e.coords.accuracy,r=this._map.getBearing(),a=t.extend({bearing:r},this.options.fitBoundsOptions);this._map.fitBounds(i.toBounds(o),a,{geolocateSource:!0});},o.prototype._updateMarker=function(e){if(e){var i=new t.LngLat(e.coords.longitude,e.coords.latitude);this._accuracyCircleMarker.setLngLat(i).addTo(this._map),this._userLocationDotMarker.setLngLat(i).addTo(this._map),this._accuracy=e.coords.accuracy,this.options.showUserLocation&&this.options.showAccuracyCircle&&this._updateCircleRadius();}else this._userLocationDotMarker.remove(),this._accuracyCircleMarker.remove();},o.prototype._updateCircleRadius=function(){var t=this._map._container.clientHeight/2,e=this._map.unproject([0,t]),i=this._map.unproject([1,t]),o=e.distanceTo(i),r=Math.ceil(2*this._accuracy/o);this._circleElement.style.width=r+"px",this._circleElement.style.height=r+"px";},o.prototype._onZoom=function(){this.options.showUserLocation&&this.options.showAccuracyCircle&&this._updateCircleRadius();},o.prototype._onError=function(e){if(this._map){if(this.options.trackUserLocation)if(1===e.code){this._watchState="OFF",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),this._geolocateButton.disabled=!0;var i=this._map._getUIString("GeolocateControl.LocationNotAvailable");this._geolocateButton.title=i,this._geolocateButton.setAttribute("aria-label",i),void 0!==this._geolocationWatchID&&this._clearWatch();}else{if(3===e.code&&sr)return;this._setErrorState();}"OFF"!==this._watchState&&this.options.showUserLocation&&this._dotElement.classList.add("mapboxgl-user-location-dot-stale"),this.fire(new t.Event("error",e)),this._finish();}},o.prototype._finish=function(){this._timeoutId&&clearTimeout(this._timeoutId),this._timeoutId=void 0;},o.prototype._setupUI=function(e){var o=this;if(this._container.addEventListener("contextmenu",(function(t){return t.preventDefault()})),this._geolocateButton=i.create("button","mapboxgl-ctrl-geolocate",this._container),i.create("span","mapboxgl-ctrl-icon",this._geolocateButton).setAttribute("aria-hidden",!0),this._geolocateButton.type="button",!1===e){t.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");var r=this._map._getUIString("GeolocateControl.LocationNotAvailable");this._geolocateButton.disabled=!0,this._geolocateButton.title=r,this._geolocateButton.setAttribute("aria-label",r);}else{var a=this._map._getUIString("GeolocateControl.FindMyLocation");this._geolocateButton.title=a,this._geolocateButton.setAttribute("aria-label",a);}this.options.trackUserLocation&&(this._geolocateButton.setAttribute("aria-pressed","false"),this._watchState="OFF"),this.options.showUserLocation&&(this._dotElement=i.create("div","mapboxgl-user-location-dot"),this._userLocationDotMarker=new rr(this._dotElement),this._circleElement=i.create("div","mapboxgl-user-location-accuracy-circle"),this._accuracyCircleMarker=new rr({element:this._circleElement,pitchAlignment:"map"}),this.options.trackUserLocation&&(this._watchState="OFF"),this._map.on("zoom",this._onZoom)),this._geolocateButton.addEventListener("click",this.trigger.bind(this)),this._setup=!0,this.options.trackUserLocation&&this._map.on("movestart",(function(e){e.geolocateSource||"ACTIVE_LOCK"!==o._watchState||e.originalEvent&&"resize"===e.originalEvent.type||(o._watchState="BACKGROUND",o._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"),o._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),o.fire(new t.Event("trackuserlocationend")));}));},o.prototype.trigger=function(){if(!this._setup)return t.warnOnce("Geolocate control triggered before added to a map"),!1;if(this.options.trackUserLocation){switch(this._watchState){case"OFF":this._watchState="WAITING_ACTIVE",this.fire(new t.Event("trackuserlocationstart"));break;case"WAITING_ACTIVE":case"ACTIVE_LOCK":case"ACTIVE_ERROR":case"BACKGROUND_ERROR":nr--,sr=!1,this._watchState="OFF",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),this.fire(new t.Event("trackuserlocationend"));break;case"BACKGROUND":this._watchState="ACTIVE_LOCK",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),this._lastKnownPosition&&this._updateCamera(this._lastKnownPosition),this.fire(new t.Event("trackuserlocationstart"));}switch(this._watchState){case"WAITING_ACTIVE":this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");break;case"ACTIVE_LOCK":this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");break;case"ACTIVE_ERROR":this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");break;case"BACKGROUND":this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");break;case"BACKGROUND_ERROR":this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");}if("OFF"===this._watchState&&void 0!==this._geolocationWatchID)this._clearWatch();else if(void 0===this._geolocationWatchID){var e;this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.setAttribute("aria-pressed","true"),++nr>1?(e={maximumAge:6e5,timeout:0},sr=!0):(e=this.options.positionOptions,sr=!1),this._geolocationWatchID=t.window.navigator.geolocation.watchPosition(this._onSuccess,this._onError,e);}}else t.window.navigator.geolocation.getCurrentPosition(this._onSuccess,this._onError,this.options.positionOptions),this._timeoutId=setTimeout(this._finish,1e4);return !0},o.prototype._clearWatch=function(){t.window.navigator.geolocation.clearWatch(this._geolocationWatchID),this._geolocationWatchID=void 0,this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.setAttribute("aria-pressed","false"),this.options.showUserLocation&&this._updateMarker(null);},o}(t.Evented),cr={maxWidth:100,unit:"metric"},ur=function(e){this.options=t.extend({},cr,e),t.bindAll(["_onMove","setUnit"],this);};function hr(t,e,i){var o=i&&i.maxWidth||100,r=t._container.clientHeight/2,a=t.unproject([0,r]),n=t.unproject([o,r]),s=a.distanceTo(n);if(i&&"imperial"===i.unit){var l=3.2808*s;l>5280?pr(e,o,l/5280,t._getUIString("ScaleControl.Miles")):pr(e,o,l,t._getUIString("ScaleControl.Feet"));}else i&&"nautical"===i.unit?pr(e,o,s/1852,t._getUIString("ScaleControl.NauticalMiles")):s>=1e3?pr(e,o,s/1e3,t._getUIString("ScaleControl.Kilometers")):pr(e,o,s,t._getUIString("ScaleControl.Meters"));}function pr(t,e,i,o){var r,a,n,s=(r=i,(a=Math.pow(10,(""+Math.floor(r)).length-1))*(n=(n=r/a)>=10?10:n>=5?5:n>=3?3:n>=2?2:n>=1?1:function(t){var e=Math.pow(10,Math.ceil(-Math.log(t)/Math.LN10));return Math.round(t*e)/e}(n)));t.style.width=e*(s/i)+"px",t.innerHTML=s+"&nbsp;"+o;}ur.prototype.getDefaultPosition=function(){return "bottom-left"},ur.prototype._onMove=function(){hr(this._map,this._container,this.options);},ur.prototype.onAdd=function(t){return this._map=t,this._container=i.create("div","mapboxgl-ctrl mapboxgl-ctrl-scale",t.getContainer()),this._map.on("move",this._onMove),this._onMove(),this._container},ur.prototype.onRemove=function(){i.remove(this._container),this._map.off("move",this._onMove),this._map=void 0;},ur.prototype.setUnit=function(t){this.options.unit=t,hr(this._map,this._container,this.options);};var dr=function(e){this._fullscreen=!1,e&&e.container&&(e.container instanceof t.window.HTMLElement?this._container=e.container:t.warnOnce("Full screen control 'container' must be a DOM element.")),t.bindAll(["_onClickFullscreen","_changeIcon"],this),"onfullscreenchange"in t.window.document?this._fullscreenchange="fullscreenchange":"onmozfullscreenchange"in t.window.document?this._fullscreenchange="mozfullscreenchange":"onwebkitfullscreenchange"in t.window.document?this._fullscreenchange="webkitfullscreenchange":"onmsfullscreenchange"in t.window.document&&(this._fullscreenchange="MSFullscreenChange");};dr.prototype.onAdd=function(e){return this._map=e,this._container||(this._container=this._map.getContainer()),this._controlContainer=i.create("div","mapboxgl-ctrl mapboxgl-ctrl-group"),this._checkFullscreenSupport()?this._setupUI():(this._controlContainer.style.display="none",t.warnOnce("This device does not support fullscreen mode.")),this._controlContainer},dr.prototype.onRemove=function(){i.remove(this._controlContainer),this._map=null,t.window.document.removeEventListener(this._fullscreenchange,this._changeIcon);},dr.prototype._checkFullscreenSupport=function(){return !!(t.window.document.fullscreenEnabled||t.window.document.mozFullScreenEnabled||t.window.document.msFullscreenEnabled||t.window.document.webkitFullscreenEnabled)},dr.prototype._setupUI=function(){var e=this._fullscreenButton=i.create("button","mapboxgl-ctrl-fullscreen",this._controlContainer);i.create("span","mapboxgl-ctrl-icon",e).setAttribute("aria-hidden",!0),e.type="button",this._updateTitle(),this._fullscreenButton.addEventListener("click",this._onClickFullscreen),t.window.document.addEventListener(this._fullscreenchange,this._changeIcon);},dr.prototype._updateTitle=function(){var t=this._getTitle();this._fullscreenButton.setAttribute("aria-label",t),this._fullscreenButton.title=t;},dr.prototype._getTitle=function(){return this._map._getUIString(this._isFullscreen()?"FullscreenControl.Exit":"FullscreenControl.Enter")},dr.prototype._isFullscreen=function(){return this._fullscreen},dr.prototype._changeIcon=function(){(t.window.document.fullscreenElement||t.window.document.mozFullScreenElement||t.window.document.webkitFullscreenElement||t.window.document.msFullscreenElement)===this._container!==this._fullscreen&&(this._fullscreen=!this._fullscreen,this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"),this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"),this._updateTitle());},dr.prototype._onClickFullscreen=function(){this._isFullscreen()?t.window.document.exitFullscreen?t.window.document.exitFullscreen():t.window.document.mozCancelFullScreen?t.window.document.mozCancelFullScreen():t.window.document.msExitFullscreen?t.window.document.msExitFullscreen():t.window.document.webkitCancelFullScreen&&t.window.document.webkitCancelFullScreen():this._container.requestFullscreen?this._container.requestFullscreen():this._container.mozRequestFullScreen?this._container.mozRequestFullScreen():this._container.msRequestFullscreen?this._container.msRequestFullscreen():this._container.webkitRequestFullscreen&&this._container.webkitRequestFullscreen();};var _r={closeButton:!0,closeOnClick:!0,className:"",maxWidth:"240px"},fr=function(e){function o(i){e.call(this),this.options=t.extend(Object.create(_r),i),t.bindAll(["_update","_onClose","remove"],this);}return e&&(o.__proto__=e),(o.prototype=Object.create(e&&e.prototype)).constructor=o,o.prototype.addTo=function(e){var i=this;return this._map=e,this.options.closeOnClick&&this._map.on("click",this._onClose),this.options.closeOnMove&&this._map.on("move",this._onClose),this._map.on("remove",this.remove),this._update(),this._trackPointer?(this._map.on("mousemove",(function(t){i._update(t.point);})),this._map.on("mouseup",(function(t){i._update(t.point);})),this._container&&this._container.classList.add("mapboxgl-popup-track-pointer"),this._map._canvasContainer.classList.add("mapboxgl-track-pointer")):this._map.on("move",this._update),this.fire(new t.Event("open")),this},o.prototype.isOpen=function(){return !!this._map},o.prototype.remove=function(){return this._content&&i.remove(this._content),this._container&&(i.remove(this._container),delete this._container),this._map&&(this._map.off("move",this._update),this._map.off("move",this._onClose),this._map.off("click",this._onClose),this._map.off("remove",this.remove),this._map.off("mousemove"),delete this._map),this.fire(new t.Event("close")),this},o.prototype.getLngLat=function(){return this._lngLat},o.prototype.setLngLat=function(e){return this._lngLat=t.LngLat.convert(e),this._pos=null,this._trackPointer=!1,this._update(),this._map&&(this._map.on("move",this._update),this._map.off("mousemove"),this._container&&this._container.classList.remove("mapboxgl-popup-track-pointer"),this._map._canvasContainer.classList.remove("mapboxgl-track-pointer")),this},o.prototype.trackPointer=function(){var t=this;return this._trackPointer=!0,this._pos=null,this._update(),this._map&&(this._map.off("move",this._update),this._map.on("mousemove",(function(e){t._update(e.point);})),this._map.on("drag",(function(e){t._update(e.point);})),this._container&&this._container.classList.add("mapboxgl-popup-track-pointer"),this._map._canvasContainer.classList.add("mapboxgl-track-pointer")),this},o.prototype.getElement=function(){return this._container},o.prototype.setText=function(e){return this.setDOMContent(t.window.document.createTextNode(e))},o.prototype.setHTML=function(e){var i,o=t.window.document.createDocumentFragment(),r=t.window.document.createElement("body");for(r.innerHTML=e;i=r.firstChild;)o.appendChild(i);return this.setDOMContent(o)},o.prototype.getMaxWidth=function(){return this._container&&this._container.style.maxWidth},o.prototype.setMaxWidth=function(t){return this.options.maxWidth=t,this._update(),this},o.prototype.setDOMContent=function(t){return this._createContent(),this._content.appendChild(t),this._update(),this},o.prototype.addClassName=function(t){this._container&&this._container.classList.add(t);},o.prototype.removeClassName=function(t){this._container&&this._container.classList.remove(t);},o.prototype.toggleClassName=function(t){if(this._container)return this._container.classList.toggle(t)},o.prototype._createContent=function(){this._content&&i.remove(this._content),this._content=i.create("div","mapboxgl-popup-content",this._container),this.options.closeButton&&(this._closeButton=i.create("button","mapboxgl-popup-close-button",this._content),this._closeButton.type="button",this._closeButton.setAttribute("aria-label","Close popup"),this._closeButton.innerHTML="&#215;",this._closeButton.addEventListener("click",this._onClose));},o.prototype._update=function(e){var o=this;if(this._map&&(this._lngLat||this._trackPointer)&&this._content&&(this._container||(this._container=i.create("div","mapboxgl-popup",this._map.getContainer()),this._tip=i.create("div","mapboxgl-popup-tip",this._container),this._container.appendChild(this._content),this.options.className&&this.options.className.split(" ").forEach((function(t){return o._container.classList.add(t)})),this._trackPointer&&this._container.classList.add("mapboxgl-popup-track-pointer")),this.options.maxWidth&&this._container.style.maxWidth!==this.options.maxWidth&&(this._container.style.maxWidth=this.options.maxWidth),this._map.transform.renderWorldCopies&&!this._trackPointer&&(this._lngLat=tr(this._lngLat,this._pos,this._map.transform)),!this._trackPointer||e)){var r=this._pos=this._trackPointer&&e?e:this._map.project(this._lngLat),a=this.options.anchor,n=function e(i){if(i){if("number"==typeof i){var o=Math.round(Math.sqrt(.5*Math.pow(i,2)));return {center:new t.Point(0,0),top:new t.Point(0,i),"top-left":new t.Point(o,o),"top-right":new t.Point(-o,o),bottom:new t.Point(0,-i),"bottom-left":new t.Point(o,-o),"bottom-right":new t.Point(-o,-o),left:new t.Point(i,0),right:new t.Point(-i,0)}}if(i instanceof t.Point||Array.isArray(i)){var r=t.Point.convert(i);return {center:r,top:r,"top-left":r,"top-right":r,bottom:r,"bottom-left":r,"bottom-right":r,left:r,right:r}}return {center:t.Point.convert(i.center||[0,0]),top:t.Point.convert(i.top||[0,0]),"top-left":t.Point.convert(i["top-left"]||[0,0]),"top-right":t.Point.convert(i["top-right"]||[0,0]),bottom:t.Point.convert(i.bottom||[0,0]),"bottom-left":t.Point.convert(i["bottom-left"]||[0,0]),"bottom-right":t.Point.convert(i["bottom-right"]||[0,0]),left:t.Point.convert(i.left||[0,0]),right:t.Point.convert(i.right||[0,0])}}return e(new t.Point(0,0))}(this.options.offset);if(!a){var s,l=this._container.offsetWidth,c=this._container.offsetHeight;s=r.y+n.bottom.y<c?["top"]:r.y>this._map.transform.height-c?["bottom"]:[],r.x<l/2?s.push("left"):r.x>this._map.transform.width-l/2&&s.push("right"),a=0===s.length?"bottom":s.join("-");}var u=r.add(n[a]).round();i.setTransform(this._container,er[a]+" translate("+u.x+"px,"+u.y+"px)"),ir(this._container,a,"popup");}},o.prototype._onClose=function(){this.remove();},o}(t.Evented),mr={version:t.version,supported:e,setRTLTextPlugin:t.setRTLTextPlugin,getRTLTextPluginStatus:t.getRTLTextPluginStatus,Map:Yo,NavigationControl:$o,GeolocateControl:lr,AttributionControl:No,ScaleControl:ur,FullscreenControl:dr,Popup:fr,Marker:rr,Style:Ne,LngLat:t.LngLat,LngLatBounds:t.LngLatBounds,Point:t.Point,MercatorCoordinate:t.MercatorCoordinate,Evented:t.Evented,config:t.config,get accessToken(){return t.config.ACCESS_TOKEN},set accessToken(e){t.config.ACCESS_TOKEN=e;},get baseApiUrl(){return t.config.API_URL},set baseApiUrl(e){t.config.API_URL=e;},get workerCount(){return kt.workerCount},set workerCount(t){kt.workerCount=t;},get maxParallelImageRequests(){return t.config.MAX_PARALLEL_IMAGE_REQUESTS},set maxParallelImageRequests(e){t.config.MAX_PARALLEL_IMAGE_REQUESTS=e;},clearStorage:function(e){t.clearTileCache(e);},workerUrl:""};return mr}));

//

return mapboxgl;

})));
//# sourceMappingURL=mapbox-gl.js.map


/***/ })
/******/ ]);
});